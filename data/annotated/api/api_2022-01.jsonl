{"id": "NsBczG", "name": "Ripple effect - yegodes534", "author": "yegodes534", "description": "http://adrianboeing.blogspot.com/2011/02/ripple-effect-in-webgl.html", "tags": ["ripple"], "likes": 1, "viewed": 189, "published": 3, "date": "1643661053", "time_retrieved": "2024-07-30T17:06:05.756485", "image_code": "// http://adrianboeing.blogspot.com/2011/02/ripple-effect-in-webgl.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    cPos -= -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n    float cLength = length(cPos);\n\n    vec2 uv = gl_FragCoord.xy/iResolution.xy+(cPos/cLength)*cos(cLength*12.0-iTime*4.0)*0.03;\n    vec3 col = texture(iChannel0,uv).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 130, 130, 451]], "test": "untested"}
{"id": "tddyW8", "name": "Simple Mandelbrot experiment", "author": "MarcoF", "description": "Fractal", "tags": ["fractal"], "likes": 3, "viewed": 225, "published": 3, "date": "1643651504", "time_retrieved": "2024-07-30T17:06:06.501494", "image_code": "vec2 cart2pol(vec2 c) {\n    vec2 p = vec2(0);\n    p.x = length(c);\n    if (c.x != 0.0) p.y = atan(c.y / c.x);\n    return p;\n}\n\nvec2 pol2cart(vec2 p) {\n    vec2 c = vec2(0);\n    c.x = p.x * cos(p.y);\n    c.y = p.x * sin(p.y);\n    return c;\n}\n\nvec2 complexPow(vec2 polar, float n) {\n    polar.x = pow(polar.x, n);\n    polar.y *= n;\n    return polar;\n}\n\nvec2 scale(vec2 original, vec2 factor, vec2 pivot) {\n    factor = 1.0 / factor;\n    mat2 s = mat2(factor.x, 0.0, 0.0, factor.y);\n    vec2 result = original;\n    result -= pivot;\n    result *= s;\n    result += pivot;\n    return result;\n}\n\nvec2 nextNumber(vec2 prevZ, vec2 c, float power) {\n    vec2 polarZ = cart2pol(prevZ);\n        \n    polarZ = complexPow(polarZ, power);\n        \n    return pol2cart(polarZ) + c;\n}\n\nfloat zoomSpeed = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / minRes;\n    uv -= vec2(1.2, 0.5);\n    uv = scale(uv, vec2(0.45), vec2(0.0));\n    vec3 color = vec3(0);\n    \n    // Zoom.\n    //if (iTime > 10.)\n    //\tuv = scale(uv, vec2(iTime*zoomSpeed + 1. - 10.*zoomSpeed), vec2(-1.8, 0.));\n    \n    vec2 z = vec2(0.0);\n    int iterations = 0;\n    while (iterations < int(iTime)) {\n        iterations++;\n        \n        z = nextNumber(z, uv, 2.0);\n    }\n    \n    color = vec3(1) * length(z) / iTime;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 125], [127, 127, 150, 150, 240], [242, 242, 280, 280, 349], [351, 351, 403, 403, 587], [589, 589, 639, 639, 767], [793, 793, 850, 850, 1408]], "test": "untested"}
{"id": "Ws3yRj", "name": "Spiral trick", "author": "MarcoF", "description": "Experiment with polar coordinates", "tags": ["spiral", "polar"], "likes": 2, "viewed": 238, "published": 3, "date": "1643651500", "time_retrieved": "2024-07-30T17:06:07.324295", "image_code": "#define PI 3.1415926535\n\nvec2 cart2pol(vec2 uv) {\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    a = mod(a, PI * 2.0);\n    return vec2(r, a);\n}\n\nfloat spiral(float radius, float angle, float curv, float branches, float size) {\n    float c = sin(radius * curv + angle * branches);\n    //return step(1.0 - size, c);\n    return smoothstep(0., 10. * curv / iResolution.x, c + size - 1.);\n}\n\nvec2 rotate(vec2 original, float angle, vec2 pivot) {\n    mat2 rotation  = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 final = original;\n    final -= pivot;\n    final *= rotation;\n    final += pivot;\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - (fragColor.xy = iResolution.xy) ) / fragColor.y ;\n    \n    vec2 uvRotated = rotate(uv, iTime, vec2(0));\n    \n    vec2 polarUv = cart2pol(uvRotated);\n    \n    float s = spiral(polarUv.x, polarUv.y, 8., 1., 1.);\n    \n    vec3 col = vec3(0);\n    \n    col = vec3(s);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 49, 49, 158], [160, 160, 241, 241, 400], [402, 402, 455, 455, 641], [643, 643, 700, 700, 1028]], "test": "untested"}
{"id": "WsdyDH", "name": "colored fbm noise", "author": "MarcoF", "description": "Using fbm with 3d Simplex noise to create a changing effect.", "tags": ["noise", "fbm", "experiment", "simplex"], "likes": 3, "viewed": 235, "published": 3, "date": "1643651490", "time_retrieved": "2024-07-30T17:06:08.291707", "image_code": "// Return value between -0.5 and 0.5\nfloat snoise(vec3 v);\n\nfloat noise(vec3 v){\n    return snoise(v) + 0.5;\n}\n\nfloat fbm(vec3 uv, int octaves, float amplitude, float frequency, vec3 shift, float lacunarity, float gain) {\n\tfloat value = 0.0;\n    for (int i = 0; i < octaves; ++i) {\n        float sn = noise(uv * frequency);\n        value += amplitude * sn;\n        uv += shift;\n        frequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn value;\n}\n\nfloat fbm(vec3 uv, int octaves) {\n    return fbm(uv, octaves, 0.5, 1.0, vec3(8), 2.0, 0.5);\n}\n\nfloat fbm3d(vec3 uv, int octaves) {\n    float fbmNoise = fbm(uv, octaves);\n    \n    return fbmNoise + 0.5;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float size) {\n\tvec2 g = b - a;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), uv - a));\n\treturn smoothstep(d - 0.002, d + 0.002, size / 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / minRes;\n    \n    vec3 color = vec3(0.0);\n    \n    vec3 v = vec3(uv * 4.0, iTime * 0.2);\n    \n    float fbmNoise = fbm(v, 1, 1.5, 1.5, vec3(8), 2.0, 0.5);\n    \n    vec3 col = 0.5 + 0.5 * cos(iTime * 0.4 + uv.xyx + vec3(0, 2, 4));\n    \n    color = fbmNoise * col;\n    color += (1.0 - fbmNoise) * (1.0 - col);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 80, 80, 110], [112, 112, 221, 221, 451], [453, 453, 486, 486, 546], [548, 548, 583, 583, 656], [658, 658, 678, 678, 716], [718, 718, 738, 738, 805], [807, 807, 856, 856, 989], [991, 991, 1048, 1048, 1476], [1478, 1532, 1553, 1553, 1590], [1591, 1591, 1618, 1618, 1666], [1668, 1668, 1689, 1689, 3525]], "test": "untested"}
{"id": "sdjcWm", "name": "Rotating black hole", "author": "A_Toaster", "description": "I made changes to the raymarching code to simulate a Kerr metric rotating black hole. (https://en.wikipedia.org/wiki/Kerr_metric)\nCould be improved by better redshift, since the current redshift doesn't take the frame-dragging into account.", "tags": ["warping", "distortion", "blackhole", "rotating", "lensing", "kerr"], "likes": 27, "viewed": 1209, "published": 3, "date": "1643649511", "time_retrieved": "2024-07-30T17:06:09.177339", "image_code": "#define AA 2  //change to 1 to increase performance\n\n#define _Speed 3.0  //disk rotation speed\n\n#define _Steps  12. //disk texture layers\n#define _Size 0.3//size of BH\n\n\n\nfloat hash(float x){ return fract(sin(x)*152754.742);}\nfloat hash(vec2 x){\treturn hash(x.x + hash(x.y));}\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;\t\n    float b = mix(bl, br, fr.x);\t\n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*3., 100.); //(poor quality) \"stars\" created from value noise\n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    vec4 nebulae = texture(iChannel0, (uv*1.5 ));\n    nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    nebulae.xyz *= 0.25;\n    \n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n \n\tnebulae.xyz += stars;\n\treturn nebulae;\n}\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.); //no disk\n    \n\tvec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.4 *(1./_Steps) /( abs(ray.y) );\n\n    position += dist*_Steps*ray*0.5;     \n\n    vec2 deltaPos;\n    deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;\n    deltaPos.y = zeroPos.x*0.01 + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= sqrt(lengthPos);\n    parallel *= 0.5;\n    float redShift = parallel +0.3;\n    redShift *= redShift;\n\n    redShift = clamp(redShift, 0., 1.);\n    \n    float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);\n    vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);\n    \n    insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);\n\tinsideCol *= 1.25;\n    redShift += 0.12;\n    redShift *= redShift;\n\n    vec4 o = vec4(0.);\n\n    for(float i = 0. ; i < _Steps; i++)\n    {                      \n        position -= dist * ray ;  \n\n        float intensity =clamp( 1. - abs((i - 0.8) * (1./_Steps) * 2.), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 1.;\n\n        distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);        \n        distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);\n        distMult *= distMult;\n\n        float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;\n\n        vec2 xy ;\n        float rot = mod(iTime*_Speed, 8192.);\n        xy.x = -position.z*sin(rot) + position.x*cos(rot);\n        xy.y = position.x*sin(rot) + position.z*cos(rot);\n\n        float x = abs( xy.x/(xy.y));         \n\t\tfloat angle = 0.02*atan(x);\n  \n        const float f = 70.;\n        float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);\n        noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);     \n\n        float extraWidth =  noise * 1. * (1. -  clamp(i * (1./_Steps)*2. - 1., 0., 1.));\n\n        float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);\n\n        vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));\n        o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));\n\n        lengthPos *= (1./_Size);\n   \n        o.rgb+= redShift*(intensity*1. + 0.5)* (1./_Steps) * 100.*distMult/(lengthPos*lengthPos);\n    }  \n \n    o.rgb = clamp(o.rgb - 0.005, 0., 1.);\n    return o ;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 pos = vec3(0.,0.05,-(20.*iMouse.xy/iResolution.y-10.)*(20.*iMouse.xy/iResolution.y-10.)*.05); \n        vec2 angle = vec2(iTime*0.1,.2);      \n        angle.y = (2.*iMouse.y/iResolution.y)*3.14 + 0.1 + 3.14;\n        float dist = length(pos);\n        Rotate(pos,angle);\n        angle.xy -= min(.3/dist , 3.14) * vec2(1, 0.5);\n        Rotate(ray,angle);\n\n        vec4 col = vec4(0.); \n        vec4 glow = vec4(0.); \n        vec4 outCol =vec4(100.);\n\n        for(int disks = 0; disks< 256; disks++) //steps\n        {\n\n            for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)\n            {\n                float dotpos = dot(pos,pos);\n                float invDist = inversesqrt(dotpos); //1/distance to BH\n                float centDist = dotpos * invDist; \t//distance to BH\n                \n                \n                // stepDist was originally abs(pos.y /(ray.y)) * 0.9\n                // the min(dotpos * 0.2,...) was added to maintain shorter step distances when far from the disk.\n                float stepDist = min(dotpos * 0.2, abs(pos.y /(ray.y)) * 0.9);  //conservative distance to disk (y==0), but clamped to a max for more accurate frame dragging (the light could escape the BH with too large of steps)\n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n                float invDistSqr = invDist * invDist;\n                float bendForce = stepDist * invDistSqr * _Size * 0.625;  //bending force\n                \n                // Frame dragging computation below:\n                // Compute a vector in the direction of the BH's rotation\n                vec3 pos_cross_pole_axis = cross(vec3(0., 1., 0.), pos);\n                // Compute sin^2(latitude) of the current ray position\n                float sin2_colatitude = length(pos_cross_pole_axis)/length(pos);\n                sin2_colatitude = sin2_colatitude * sin2_colatitude;\n                \n                // the frame dragging rate is approximately proportional to 1/(r^2 * sin^2(colatitude)) (See: https://en.wikipedia.org/wiki/Frame-dragging)\n                vec3 frameDragForce = normalize(pos_cross_pole_axis) * invDistSqr * sin2_colatitude * 0.012; \n                \n                \n                ray =  normalize(ray - (bendForce * invDist)*pos);  //bend ray towards BH\n                pos += stepDist * (ray - frameDragForce) ; // Move the ray in the ray direction and move it according to frame dragging\n                // This could be acheived more accurately by computing a rotation matrix and using it to rotate the ray position & direction.\n                \n                glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            }\n\n            float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.5) //ray sucked in to BH\n            {\n                outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {                   \n                vec4 bg = background (ray);\n                outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);       \n                break;\n            }\n\n            else if (abs(pos.y) <= _Size * 0.0005 ) //ray hit accretion disk\n            {                             \n                vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n                //pos.y = 0.;\n                pos += abs(_Size * 0.001 /ray.y) * ray;  // skip over disk (keeps rays from getting trapped inside disk)\n                col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }\t\n        }\n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 191, 191, 225], [226, 226, 245, 245, 276], [278, 278, 322, 322, 672], [674, 674, 701, 701, 1468], [1470, 1470, 1513, 1555, 4069], [4072, 4072, 4118, 4118, 4272]], "test": "untested"}
{"id": "fdjcWm", "name": "Circular Wave", "author": "cmzw", "description": "Circular gradients driven by a wave propagating from the center", "tags": ["2d", "circle", "gradient"], "likes": 24, "viewed": 550, "published": 3, "date": "1643646361", "time_retrieved": "2024-07-30T17:06:09.934315", "image_code": "// Golfed by https://www.shadertoy.com/user/Xor\n\nvoid mainImage (out vec4 O, vec2 I)\n{\n    O -= O;\n    \n    for(int i=0; i++<36;)\n    {\n        vec2 r = iResolution.xy,\n             c = (I+I-r-1.+vec2(i%6,i/6)/3.) / r.y*8.-.5,\n             p = fract(c)-.5;\n    \n        O += step(dot(p,p),.23) * fract(atan(p.x,p.y)/6.3\n             + tan(length(ceil(c))*.2-iTime)*.1)/36.;\n    }\n}\n\n/* Original version\n\n// AA by https://www.shadertoy.com/user/GregRostami\n\nvec4 fC ( in vec2 fragCoord )\n{\n    vec2 c = (2. * fragCoord - iResolution.xy) / iResolution.y*8.+.5;\n    vec2 p = fract(c)-.5;\n    return vec4(vec3(step(dot(p,p),.2)*fract(atan(p.x,p.y)/6.3+((tan(length(floor(c)/5.)-iTime)))/10.)),2.);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 6.,\n        s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 381]], "test": "untested"}
{"id": "sd2yDw", "name": "Pottery Barn", "author": "eiffie", "description": "With the opening of the new expansive Egyptian Antiquities Museum the curator was worried it may look empty for the grand opening. A quick trip to the Pottery Barn the night before and problem solved.", "tags": ["soc", "pots"], "likes": 22, "viewed": 378, "published": 3, "date": "1643643307", "time_retrieved": "2024-07-30T17:06:13.014080", "image_code": "#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=0.6,shadowCone=0.5;\nmat2 rmat(float a){float sa=sin(a),ca=cos(a);return mat2(ca,sa,-sa,ca);}\nvec4 mcol=vec4(0);\nfloat rnd(float t){return fract(sin(t)*431.341);}\nfloat handle(vec3 p, float r){\n  if(r>.85)p.x=abs(p.x);else if(r>.6)p.x=-p.x;\n  p.x-=.11+r*.05;\n  p.y-=r*.4;\n  return length(vec2(length(p.xy)-.05,p.z))-0.005;\n}\nfloat vase(vec3 p){\n  float r=rnd(floor(p.x));\n  p.x=fract(p.x)-.5-r*.05;\n  p.z+=r*.2;\n  float m=length(p.xz);\n  float d=m-.1-sin(p.y*(3.+r*6.)-1.+r)*r*.08;\n  if(r<.1){\n    float t=(p.x+p.z)*20.,t0=fract(t);t=floor(t+r*100.);\n    d=m-.1-mix(rnd(t),rnd(t+1.),t0)*0.1;\n    r=.05;p.x+=r*100.;\n    p.y+=0.001*(sin(p.z*200.)+sin(p.x*30.+6.*sin(p.z*90.)));\n  }else if(r<.2){\n    d=max(abs(p.x)-.09-p.z*.3,abs(p.z)-.3);\n    r=.05;\n    p.y+=abs(p.x*.5)+(p.z>0.05?0.02:0.0);\n  }else if(r<.25){\n    d=min(abs(m-.065)-0.005,min(max(abs(p.x)-0.005-p.z*p.z*.4,abs(p.z+.15)-.1),max(abs(p.x)-0.1,abs(p.z+.06)-0.005-p.x*p.x)));\n    r=.05;\n  }else{\n    if(r<.4){\n      d=mix(d,m-.03,clamp(p.y*p.y*20.,0.,1.));r+=.4*fract(r*10.);\n    }else if(fract(r*100.)<.5){\n      d=min(d,handle(p,r));\n    }\n    d=abs(d)-0.01;\n  }\n  return max(abs(p.y)-r*.75,d);\n}\nfloat DE(in vec3 p){//vases\n float dW=1.-p.z,dF=max(-.6-p.z,p.y+.01);\n float dS=min(vase(p+vec3(10.5,0.,0.)),vase(p));\n float d=min(dS,min(dW,dF));\n if(mcol.x>0.){\n   if(d==dS){\n     float r=rnd(floor(p.x+.25));\n     float b=sign(sin(p.y*5.*r*6.*cos(p.y*17.*r)))*.5+.5;\n     if(r>.25 && r<.5 && fract(p.x*10.)>fract(p.z*10.))b=1.-b;\n     mcol+=vec4((.5+abs(sin(p*10.))*.5)*b,.25+.25*b);\n   }else if(d==dW)mcol.rgb+=vec3(0.8);else mcol+=vec4(.6,.6,.6,.2);\n }\n return d; \n}\nfloat DEL(in vec3 p){//lights\n p.x=abs(fract(p.x+.25)-.5);p.z-=.5;p.y-=1.;\n return length(p)-.01;\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<4;i++){\n  if(t>lightDist)break;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t)+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\nvec3 bg(vec3 rd){\n  float d=max(0.,rd.x+rd.y+rd.z);\n  return vec3(d*d*.25)+rd*.05;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=time*0.1;//camera, lighting and object setup\n vec3 ro=vec3(iTime,vec2(1.5,-2.)*(.85+.5*sin(iTime*.1))); \n vec3 rd=lookat(vec3(iTime+1.,0.,0.)-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*gl_FragCoord.xy-size.xy)/size.y,2.0)); \n focalDistance=min(length(ro)+0.001,1.0);\n aperture=0.007*focalDistance;\n vec3 rt=normalize(cross(vec3(0,1,0),rd)),up=cross(rd,rt);//just need to be perpendicular\n vec3 lightColor=vec3(1.0,0.5,0.25)*2.0;\n vec4 col=vec4(0.0);vec3 blm=vec3(0);//color accumulator, .w=alpha, bloom accum\n float t=0.0,mld=100.0,od,d0=1.,d,old,ld=100.,dt=0.,ot;//distance traveled, minimum light distance\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>15.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  od=d0;old=ld,dt=t-ot;ot=t;//save old distances for normal, light direction calc\n  d0=DE(ro+rd*t);\n  d=d0+0.33*rCoC;\n  ld=DEL(ro+rd*t);//the distance estimate to light\n  mld=min(mld,ld);//the minimum light distance along the march\n  if(d<rCoC){//if we are inside the sphere of confusion add its contribution\n   vec3 p=ro+rd*(t-dt);//back up to previos checkpoint\n   mcol=vec4(0.01);//collect color samples with normal deltas\n   float Drt=DE(p+rt*dt),Dup=DE(p+up*dt);\n   vec3 N=normalize(rd*(d0-od)+rt*(Drt-od)+up*(Dup-od));\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   Drt=DEL(p+rt*old);Dup=DEL(p+up*old);\n   vec3 L=-normalize(rd*(DEL(p+rd*old)-old)+rt*(Drt-old)+up*(Dup-old));\n   float lightStrength=1.0/(1.0+ld*ld*20.0);\n   if(L!=L)L=up;\n   vec3 scol=mcol.rgb*(0.4*(1.0+dot(N,L)+.2))*lightStrength;//average material color * diffuse lighting * attenuation\n   scol+=mcol.a*pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   mcol=vec4(0);//clear the color accumulator before shadows\n   scol*=FuzzyShadow(p,L,ld,shadowCone,rCoC);//now stop the shadow march at light distance\n   blm+=lightColor*exp(-mld*t*10.)*(1.0-col.w);//add a bloom around the light\n   mld=100.0;//clear the minimum light distance for the march\n   float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col=vec4(col.rgb+scol*alpha,clamp(col.w+alpha,0.0,1.0));//blend in the new color \n  }//move the minimum of the object and light distance\n  d=abs(fudgeFactor*min(d,ld+0.33*rCoC)*(0.8+0.2*rand2()));//add in noise to reduce banding and create fuzz\n  t+=d;\n }//mix in background color and remaining bloom\n t=min(15.,t);\n blm+=lightColor*exp(-mld*t*10.)*(1.0-col.w);///(1.0+mld*mld*3000.0\n col.rgb=mix(col.rgb,bg(rd),t/15.);\n fragColor = vec4(clamp(col.rgb+blm,0.0,1.0),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 5.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= 3.0; \n  else if(n<4.0)n= 4.0; \n  else if(n<5.0)n= 5.0; \n  else if(n<6.0)n= 3.0; \n  else if(n<7.0)n= 2.0; \n  else n=0.0;\n  return vec2(n,r); \n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,2.525,0.003);//silly fm synth instruments \n instr sitar=instr(2.0,.2,12.0,0.0,0.525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(500.0,1.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.0625)+nofs(b2*0.25)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n2+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y/(1.+abs(n0.x)*.25);\n   if(mod(i,1.)<1.){\n     a+=I(n0.x+93.0,time+Sin(t0*372.0),t0,stick)*n0.y*.1*cos(t0*6.);\n     a+=I(n0.x+79.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.));\n     a+=I(n0.x+84.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.));\n   } \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     a+=I(n1.x+53.,time,t1,epiano)*n1.y*.1; \n     a+=I(n1.x+52.,time,t1,epiano)*n1.y*.1; \n     a+=I(n1.x+48.,time,t1,epiano)*n1.y*.1; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     a+=I(n1.x+32.0,t1/bps+0.008*sin(t1*3.0),t1,bassdrum)*2.0;\n     a+=I(n2.x+31.0,t1/bps+0.008*sin(t1*2.0),t1,bassdrum)*2.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+52.0,time,t2,bass)*n2.y;\n       //a+=I(96.0,time,t2,stick)*n2.y*.25;   \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2yDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 135, 135, 188], [208, 208, 227, 227, 257], [258, 258, 288, 288, 419], [420, 420, 439, 439, 1254], [1255, 1255, 1275, 1282, 1726], [1727, 1727, 1748, 1756, 1826], [1828, 1828, 1861, 1923, 1987], [1988, 1988, 2017, 2017, 2102], [2103, 2103, 2144, 2144, 2177], [2261, 2261, 2275, 2363, 2457], [2458, 2458, 2539, 2539, 2764], [2765, 2765, 2782, 2782, 2849], [2850, 2850, 2907, 2907, 5634]], "test": "untested"}
{"id": "sdjyDw", "name": "Million Cube Solver", "author": "eiffie", "description": "This is done with a tip of the hat to kali who was first to do it.", "tags": ["rubiks"], "likes": 15, "viewed": 457, "published": 3, "date": "1643642807", "time_retrieved": "2024-07-30T17:06:13.958555", "image_code": "//million cube solver by eiffie\n//kali was the fist to do this in a shader. I just humbly\n//added the part that makes it A MILLION TIMES BETTER! :)\n\n#define rez iResolution\n#define pi 3.14159\nfloat nrnd(float r, float t){return fract((r+1.6713274)*(1.+floor(t)));}\nmat2 rmat(float a){float ca=cos(a),sa=sin(a);return mat2(ca,sa,-sa,ca);}\nfloat row(vec3 p,float x){p.x+=x;p=abs(p);return max(p.x-.05,max(p.y,p.z)-.15);}\nfloat time;\nfloat DE(in vec3 p){\n  vec3 s=sin(floor(p)+.1);\n  float rnd=fract(s.x+s.y+s.z);\n  p=fract(p)-.5;\n  float tim=time*(.5+.5*rnd);\n  rnd=nrnd(rnd,tim);\n  if(rnd<.66){p=p.yzx;if(rnd<.33)p=p.yzx;}\n  rnd=nrnd(rnd,tim);\n  s=p;s.yz=rmat(pi/2.*fract(tim))*s.yz;\n  return min(row(rnd<.33?s:p,0.),min(row(rnd>=.33 && rnd<.66?s:p,-.1),row(rnd>=.66?s:p,.1)));\n}\nvec3 color(in vec3 p,in float eps){\n  vec3 s=sin(floor(p)+.1),mcol=vec3(0);eps+=0.001;\n  float rnd=fract(s.x+s.y+s.z);\n  p=fract(p)-.5;\n  float tim=time*(.5+.5*rnd);\n  int n=int(floor(tim));\n  for(int i=n;i>=0;i--){\n    float r1=nrnd(rnd,float(i));\n    if(r1<.66){p=p.yzx;if(r1<.33)p=p.yzx;}\n    float r2=nrnd(r1,float(i)), x=p.x;//rotate middle\n    if(r2>=.66)x+=.1;//rotate neg side\n    else if(r2>=.33)x-=.1;//rotate pos side\n    if(abs(x)-.05<=eps)p.yz=(i==n?rmat(pi/2.*fract(tim)):mat2(0,1,-1,0))*p.yz;//rotate\n    if(r1<.66){p=p.zxy;if(r1<.33)p=p.zxy;}//unroll\n  }\n  s=abs(p);\n  float d0=max(s.x,max(s.y,s.z));\n  vec2 b=s.xy;\n  if(s.x==d0){mcol=vec3(1,1,p.x<0.?1:0);b=s.yz;}\n  else if(s.y==d0){mcol=vec3(1.,p.y<0.?.25:0.,0.);b=s.xz;}\n  else {mcol=vec3(0,1,0);if(p.z<0.)mcol=mcol.zxy;}\n  b=0.05-abs(mod(b-0.05,0.1)-0.05);\n  rnd=min(b.x,b.y);\n  rnd=smoothstep(0.,eps*2.,rnd);\n  return mcol*rnd;\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(iTime+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,px=1./rez.y;\n  vec3 L=normalize(vec3(0.4,0.5,-0.5)),C=vec3(0);\n  for(int i=0;i<99;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>70.0 || d<px*t)break;\n  }\n  if(d<px*t*5. && t<70.){\n    vec3 so=ro+rd*t;\n    C=color(so,DE(so));\n    vec3 N=normal(so,d);\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    C=(C*dif+fr*max(0.,dot(L,reflect(rd,N))))*exp(-t*.15);\n  }\n  return C/max(1.,iTime-60.);\n}\nvec3 path(float tm,float t){float a=tm*pi*0.1;return vec3(cos(a),sin(a),t);}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);time=max(0.,60.-iTime);float t=pow(time,1.3);\n vec3 ro=path(time,t),fw=normalize(path(time,t+1.)-ro);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,3.0));\n fragColor=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "int N[8]=int[8](0,7,-5,5,-3,3,-1,0);\nfloat freq(int n){\n  int m=n%12; \n  if(m!=7 && m%2>0)return 0.;\n  if(m==6 || m==8)m-=1;\n  return pow(2.,float(n)/12.);\n}\nvec2 mainSound(int samp, float time){\n  float t=time*16.,a=0.;t*=1.+pow(fract(t/8.)*fract(t/2.),15.+20.*fract(t/256.));\n  int bt=int(floor(t)),n=0,d=32;\n  for(int i=0;i<3;i++){\n    n+=N[int(bt/d)%8];\n    float f=float(i+1);\n    a+=fract(f*.3+freq(n)*t*f*6.6)-.5;\n    d/=4;\n  }  \n  vec2 v=vec2(a,(fract(a*(2.+floor(t/256.)/3.))-.5)*.75);\n  return clamp(v*.001*time,0.,.1)/max(1.,time-60.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 221, 221, 264], [265, 265, 284, 284, 337], [338, 338, 364, 364, 418], [431, 431, 451, 451, 778], [779, 779, 814, 814, 1679], [1680, 1680, 1709, 1719, 1855], [1867, 1867, 1893, 1893, 1960], [1961, 1961, 1990, 1990, 2453], [2454, 2454, 2482, 2482, 2530], [2531, 2531, 2552, 2552, 2650], [2651, 2651, 2708, 2708, 2956]], "test": "untested"}
{"id": "3tcBWj", "name": "Loading screen paint", "author": "jeyko", "description": "Old one", "tags": ["m"], "likes": 13, "viewed": 290, "published": 3, "date": "1643642623", "time_retrieved": "2024-07-30T17:06:15.048640", "image_code": "// Fork of \"Day 423 oops counting lol\" by jeyko. https://shadertoy.com/view/3lcBWB\n// 2021-02-15 08:33:03\n\n// Fork of \"Day 421\" by jeyko. https://shadertoy.com/view/ttcfzB\n// 2021-02-14 17:04:45\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.,1.2));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n       \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\nfloat noise(vec2 fragCoord){\n    int idx = iFrame/15;\n    return texture(iChannel0,(fragCoord + sin(float(idx)*20.)*10.)/256.,0.4)[idx%2];\n}\n\nfloat palIdx = 0.;\n\nconst float palA = 0.55;\nconst vec3 palB = 0.5*vec3(1.,.9,0.3);\nconst vec3 palC = vec3(1,1.5,3);\nconst float palD = 4.;\n\nvoid draw( vec2 uv, vec2 fragCoord,inout vec3 col, float d, vec2 grad, float palOffs, bool isPal, bool isXor){\n    \n    float n = cyclicNoise(vec3(uv,2)*92., false, floor(iTime*10.))*0.004;\n    float grain = noise(fragCoord);\n    float df = dFdx(uv.x)*1. + n*0.5;\n    \n    palIdx += palOffs + d*(0.2 + 1.*float(palIdx!=0.)) - smoothstep(0.04,0.0,abs(d))*0.1 + n*10. - grain*.1;\n    \n    vec3 c = pal(palA,palB,palC,palD,palIdx);\n    \n    d -= n;\n    \n    vec3 shadc = c*.9;\n    shadc.xz *= rot(0.2);\n    shadc.xy *= rot(.3);\n    \n    float dots =  smoothstep(-3.,5.,dot(grad,vec2(-1.)) - d*2.);\n    c = mix(c,shadc,\n        smoothstep(0.3 + dots,0.4 + dots,grain + d));\n    \n        //step(0.3+ smoothstep(-3.,5.,dot(grad,vec2(-1.)) - d*2.),noise(fragCoord)));\n    \n    if(isPal){\n        vec3 oldCPalled = pal(palA,palB,palC,palD,palIdx + length(col) )*(col + 0.5);\n    \n        \n        col = mix(col, oldCPalled*c, smoothstep(df,0.,d)); \n        \n    } else if(isXor){\n        //vec3 oldCPalled = pal(palA,palB,palC,palD,palIdx - length(col)*1. + palOffs)*mix(vec3(1.-length(col)),vec3(1),1.);\n        vec3 oldCPalled = max(col,0.);\n        float luma =  (oldCPalled.x+oldCPalled.y+oldCPalled.z)/3.;\n        \n        oldCPalled = 1. - oldCPalled;\n        \n        oldCPalled.xz *=rot(sin(smoothstep(0.5,0.,abs(d)*14.)*5.)*0.05);\n        oldCPalled = mix(oldCPalled,shadc,\n            smoothstep(0.3 + dots,0.5 + dots,grain + d*2.)*0.2);\n    \n        col = mix(col, oldCPalled, smoothstep(df,0.,d)); \n    \n    \n    } else {\n        \n        col = mix(col, c, smoothstep(df,0.,d)); \n    \n    }\n    \n}\n\nfloat envcnt = 0.;\n\nfloat getEnv(float t, float speed, float pa, float pb, float jumpAmt, bool cnt){\n    //return pow(sin((t - 0.5)*3.14),1.)*0.5 + 0.5;\n    t = clamp(t*speed,0.,1.);\n    \n    envcnt += float(t > 0.99 && cnt);\n    //t = smoothstep(0.,1.,t);\n    pa += 1.;\n    pb += 1.;\n    \n    float c = cos(t*3.14);\n    float a = 1.- ((pow(abs(c),pa)*sign(c))*0.5 + 0.5);\n    float b = 1.-((pow(abs(c),pb)*sign(c))*0.5 + 0.5);\n    \n    a = pow(sin(t*3.14/2.),pa);\n    b = 1.-pow(sin((-t + 1.)*3.14/2.),pb);\n    \n    b *= 1. + (\n            smoothstep(0.,1.,t) *smoothstep(0.99,0.7,t)*jumpAmt\n        );\n    return mix( a, b,t);\n}\n\n\nfloat text(vec2 p, float[1] chars, float spacing, float s) {\n\tp *= s;\n    p += vec2(1./16.,1./16.);\n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375*0.;\n    float char = chars[int(id.x)];\n    //char += 112.;\n    float t;\n    if( abs(id.y) < 1. && id.x >= 0. && id.x < 1. && mod(char, 1.) == 0. && char < 256.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - 0.5;\n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    }\n    return t;\n\t\n}\n\n\n\n#define sdfTrail(sdf,tpos,tdisp,variable, width, iTime)  {                           \\\n        vec2 circGrad = tpos(iTime - tdisp) - tpos(iTime - tdisp*2.) ;                     \\\n        circGrad *= rot(0.5*pi);                                              \\\n        vec3 circB =  sdf( p + tpos(iTime)  );                                \\\n        vec3 circBold = sdf( p + tpos(iTime - tdisp) ) + width*0.5;                         \\\n        vec2 rotUv = (p + tpos(iTime-0.1))*rot(-atan(circGrad.y,circGrad.x)); \\\n        circBold -= 9.*cyclicNoiseB(vec3(rotUv.x,1. +  floor(iTime*140.)*0.04,2)*142., false, floor(iTime*10.)*20.)*smoothstep(0.4,0.1,rotUv.y ) \\\n            *smoothstep(0.,0.9,length(circGrad))*0.1                          \\\n            * smoothstep(0.4,-0.3,circBold.x);                                \\\n        variable.x = opSmoothUnion(circB.x,circBold.x,0.2);                     \\\n    }\n    \n    #define getCircB(t) vec2(0.1 + sin((t)*2.5)*0.5,0. + sin((t)*4.)*0.2)\n    \n\n\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d*smoothstep(1.,0.,abs(d)/r) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define iTime mod(iTime,9.)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float env  = getEnv(iTime*1.      ,1.5,16.,3.,0.9,true);\n    float envb = getEnv(iTime*1. - 0.4,1.,1.,1.,0.9 ,true);\n    float envc = getEnv(iTime*1. - 1.2,1.5,2.,4.,0.2 ,true);\n    float envd = getEnv(iTime*1. - 1.5,0.4,1.,1.,0.4  ,true);\n    float enve = getEnv(iTime*1. - 3.5,1.,1.,1.,0.4  ,true);\n    float envf = getEnv(iTime*1. - 4. ,2.,1.,1.,0.4  ,true);\n    float envg = getEnv(iTime*1. - 4.5,1.,1.,1.,0.4  ,true);\n    float envh = getEnv(iTime*1. - 4.8,2.,1.,1.,0.4  ,true);\n    float envi = getEnv(iTime*1. - 5. ,1.5,1.,1.,0.4 ,true);\n    float envj = getEnv(iTime*1. - 6. ,1.5,1.,1.,0.4 ,true);\n    float envk = getEnv(iTime*1. - 7.5 ,1.5,1.,1.,0.4 ,true);\n    float envl = getEnv(iTime*1. - 7.4 ,1.5,1.,1.,0.4 ,true);\n    float envm = getEnv(iTime*1. - 7.9 ,1.5,1.,1.,0.4 ,true);\n    \n    vec3 col = vec3(0);\n\n    draw( uv, fragCoord, col, length(uv) - 4. + smoothstep(0.4,0.3,texture(iChannel1,uv*0.05).x)*2., normalize(uv), 3.7,false, false);\n    \n    vec2 p = uv;\n    \n    \n    //col = mix(col,1.-col,smoothstep(0.001,0.,text(uv - vec2(0.9,-0.35), float[1](81. + envcnt), 0., 0.4) ));\n    \n    palIdx += 1.4;\n    for(float i = 0.; i < 5.; i++){\n        p *= rot(pi/5.*2.);\n        vec3 c;\n        float w = 0.05 + sin(iTime + i)*0.;\n        #define sdfA(pos) sdgCircle( pos , w )\n\n        sdfTrail(sdfA,getCircB, 0.1, c, w,iTime + i*0.2);\n\n        draw( uv, fragCoord, col, c.x, c.yz, 0.1,false, false);\n\n    \n    }\n    //\n    \n    /*\n    #define getPlane(t) vec2(0.,0. + sin((t)*4.)*1.)\n    \n    w = 0. + sin(iTime)*0.;\n    #define sdfB(pos) vec3((p + pos).x + p.y,0.,0.)\n    \n    sdfTrail(sdfB,getCircB, 0., c, w);\n\n    draw( uv, fragCoord, col, c.x, c.yz, 1.1,false, true);\n    //\n    */\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*4.,2.)*0.2 ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.5);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 2;\n    \n    const float warp =.4;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat sdSq(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 255, 255, 1127]], "test": "untested"}
{"id": "NdjcWm", "name": "Rubber 4", "author": "ersh", "description": "Continuing to experiment with raymarching.", "tags": ["3d"], "likes": 3, "viewed": 125, "published": 3, "date": "1643636313", "time_retrieved": "2024-07-30T17:06:15.807611", "image_code": "#define LIMITED_BY    0    // 0: infinite;  1: circle;  2: square\n#define COLOR         1\n#define MESH          1\n#define MESH_COLOR    1\n#define SCALE         1.\n#define MAXDIST       10.\n#define STEP          0.1\n\nvec3 col(float x, float side) {\n#if COLOR\n  return vec3(clamp(x/2.+0.5,0.,1.), side, clamp(0.5-x/2.,0.,1.));\n#else\n  return vec3(clamp(1.-side, 0., 0.8));\n#endif\n}\n\nfloat h(vec2 p, float t) {\n    return sin(iTime*10. + tanh(iTime/10.)*10./pow(length(p.xy), 0.5))/length(p.xy);\n}\n\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n//#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))             // rotation hack                  \n\n#define PI       3.1415926\n#define R        iResolution\n#define H(pos)   h((pos)*SCALE, iTime)/5.\n#define INTERP_MIX(PREV, TARGET, CUR)   (TARGET-PREV)/(CUR-PREV)\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec3 D = normalize(vec3(I+I, -4.*R.y) - vec3(R.xy, 0.));    // ray direction\n    vec3 p = vec3(0,0,7);                                       // current ray pos\n\n    mat2 rot_yz, rot_xy;            // rotations\n    if (iMouse.x < 0.5) {\n      rot_yz = rot(-PI*(0.35 - (sin(iTime/6.)+1.)*0.06));\n      rot_xy = rot(PI/3. + iTime/10.);\n    } else {\n      vec2 M = (iMouse.xy / R.xy * vec2(1., -0.5) + vec2(0.5, 0.)) * 2. * PI;\n      rot_yz = rot(M.y);\n      rot_xy = rot(M.x);\n    }\n    p.yz *= rot_yz;  p.xy *= rot_xy;\n    D.yz *= rot_yz;  D.xy *= rot_xy;\n\n    // Walk the ray\n    float height, diff;\n    float heightprev = H(p.xy), diffprev = 0.;\n    vec3 pprev = p;\n    float dist, stp = STEP;      // distance traveled, step\n    for (dist = 0.;  dist < MAXDIST;  dist += stp, p += stp*D) {\n        height = H(p.xy);\n        diff = p.z - height;\n        if (\n#if LIMITED_BY == 1\n            length(p.xy) < 2. &&\n#elif LIMITED_BY == 2\n            abs(p.x) < 2. && abs(p.y) < 2. &&\n#endif\n            diff * diffprev < 0.)\n        {\n            // Crossed the surface\n            break;\n        }\n        heightprev = height;\n        pprev = p;\n        diffprev = diff;\n    }\n\n    if (dist < MAXDIST) {    // Crossed the surface\n        // interpolate the exact intersection pos\n        float interp = INTERP_MIX(diffprev, 0., diff);\n        vec3 pexact = mix(pprev, p, interp);\n        float heightexact = H(pexact.xy);\n\n        // sign: +1 = looking top-down, -1 = looking down-up\n        float sgn = sign(diffprev);\n\n        vec3 c = col(heightexact*2., (-sgn+1.)/4.) * (1.-(1. - sgn)/3.);\n#if MESH\n        //vec2 mesh = fract(pexact.xy*5.);\n        float mesh_thick = 0.015;      // 0.5 max\n        float mesh_density = 3.;      // 0.5 max\n        vec2 mesh = max(vec2(0), abs(fract(pexact.xy*mesh_density)-vec2(0.5)) - vec2(0.5*(1.-2.*mesh_thick)))/mesh_thick;\n        c = mix(c, vec3(MESH_COLOR), max(mesh.x, mesh.y));\n#endif\n\n        // Angle for shading\n        //float surface_angle = atan((heightexact - H((pexact.xy+vec2(0.001)))) / 0.0014);\n        vec2 shade = vec2(1,0) * rot_xy;\n        float surface_angle = atan((heightexact - H((pexact.xy + shade*0.001))) / 0.001);\n        c += sgn*(surface_angle/3.);\n\n        O = vec4(c * (MAXDIST - dist)/MAXDIST * 2., 0.);\n    } else {\n        O = vec4(0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 247, 247, 379], [381, 381, 407, 407, 494], [496, 496, 515, 515, 573]], "test": "untested"}
{"id": "ssBcDD", "name": "N-Sided Prism - Intersection", "author": "gelami", "description": "A generalized ray-prism intersector for N number of sides.\nReturns the near distance and the normal.\n\nClick and drag for interaction.\nMouse X position controls the rotation.\nMouse Y position controls the number of sides.", "tags": ["3d", "raytracing", "intersection", "prism", "intersector"], "likes": 14, "viewed": 318, "published": 3, "date": "1643608975", "time_retrieved": "2024-07-30T17:06:16.755078", "image_code": "\n// N-Sided Prism - Intersection\n// https://www.shadertoy.com/view/ssBcDD\n\n/**\n * A generalized ray-prism intersector for N number of sides.\n * Returns the near distance and the normal.\n *\n * Click and drag for interaction.\n * Mouse X position controls the rotation.\n * Mouse Y position controls the number of sides.\n * \n *   This shader computes the intersection by looping through each plane face\n * and checking whether it is a front or a back side, and assigning it to the\n * near or far intersection respectively.\n *   Then the hit mask is computed by comparing the near and far distances.\n * Is there a name for this property?)\n * \n *   For prisms with an even number of sides, it would be much more efficient\n * to use slab intersections instead, where the front and the backside is already known.\n * (i.e. Hexprism - intersection by iq: https://www.shadertoy.com/view/tljBWy)\n * \n *   I've been wondering if this can be applied to subdivisions of polyhedrons,\n * maybe with octahedrons or icosahedrons.\n *   Something like Geodesic tiling by tdhooper: https://www.shadertoy.com/view/llVXRd\n * but only with just planar faces.\n * \n *   Edit: I've just found out about this amazing shader.\n * Somebody has already done this 3 years ago T_T\n * Wish I'd seen it before writing all of these lol.\n * Looks like it's the same method but theirs is much more elegant. TT_TT\n * \n * Truncated Icosahedron by marian42: https://www.shadertoy.com/view/ltsfzN\n * \n**/\n\n#define MAX_SIDES 12\n\n#define AA 2\n\n#define MAX_DIST 1e3\n#define PI 3.14159265359\n\n#define rot2D(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec4 iPrism( vec3 ro, vec3 rd, float ra, float he, int si )\n{\n    vec4 tN = vec4(-MAX_DIST, 0, 0, 0);\n    float tF = MAX_DIST;\n    \n    float s = PI * 2. / float(si);\n    float a = PI / 2.;\n    \n    ra = ra * cos(s*0.5);\n    \n    for (int i = 0; i < MAX_SIDES + 2; i++)\n    {\n        if (i > si + 1)\n            break;\n        \n        vec3 nd = i < si ? vec3(cos(a), 0, sin(a)) : vec3(0, float(i - si)*2.-1., 0);\n        float c = dot(ro, nd) + (i < si ? ra : he);\n        float d = dot(rd, nd);\n        \n        float nt = -c / d > 0. ? -c / d : -MAX_DIST;\n        nt = d < 0. ? -nt : nt;\n        \n        if (nt > tN.x)\n            tN = vec4(nt, -nd);\n\n        if (d < 0. && -nt < tF)\n            tF = -nt;\n        \n        a += s;\n    }\n    \n    if (tN.x > tF) return vec4(MAX_DIST);\n\n    return tN;\n}\n\nmat3 getCamMat(vec3 ro, vec3 lo)\n{\n    vec3 w = normalize(lo - ro);\n    vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float t = iTime * 0.4;\n    vec3 ro = vec3(0, 1.2, 1.8);\n    vec3 lo = vec3(0, 0, 0);\n    \n    //ro.yz *= rot2D(iMouse.z > 0. ? m.y * PI+PI*2./3. : 0.);\n    ro.yz *= rot2D(sin(t)*.15);\n    ro.xz *= rot2D(iMouse.z > 0. ? m.x * 2.*PI : t);\n    \n    float fn = iMouse.z > 0. ? m.y : (cos(iTime*PI/2.5)*0.5+0.5);\n    int n = int(fn * float(MAX_SIDES - 3)*.9999 + 3.);\n    \n    mat3 cm = getCamMat(ro, lo);\n\n    vec3 tot = vec3(0);\n    \n    #if AA > 1\n    for( int p=0; p<AA; p++ )\n    for( int v=0; v<AA; v++ )\n    {\n        vec2 o = vec2(float(p),float(v)) / float(AA) - 0.5;\n        vec2 pv = (2.0 * (fragCoord+o) - iResolution.xy) / iResolution.y;\n    #else\n        vec2 pv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    #endif\n        \n        vec3 col = vec3(0);\n\n        vec3 rd = normalize(cm * vec3(pv, 1.5));\n\n        vec4 d = iPrism(ro, rd, .8, .8, n);\n\n        if (d.x < MAX_DIST)\n        {   \n            vec3 p = ro + rd*d.x;\n            vec3 n = d.yzw;\n            vec3 l = normalize(vec3(1., .6, .5));\n            \n            vec2 uv = abs(n.y) > .5 ? p.xz : vec2(atan(p.z, p.x)/PI*2., p.y*1.2);\n            \n            vec3 env = textureLod(iChannel0, reflect(rd, n), 3.).rgb*.6+.4;\n            float ch = mod(dot(floor(uv*2.5), vec2(1)), 2.)*.4+.6;\n            float dif = max(dot(n, l), .1);\n            col = vec3(.1, .2, .3)*.6 + vec3(.9, .8, .6)*dif*env*ch;\n        } else\n        {\n            col = vec3(0.12)*(1.-0.45*length(pv));\n        }\n\n        tot += col;\n    #if AA > 1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    tot = max(tot, vec3(0));\n    tot = tot / (1. + tot);\n    tot = pow(tot, vec3(1./2.2));\n    \n    tot += fract(sin(fragCoord.x*vec3(32,11,2)+fragCoord.y*vec3(3,31,21))*232.323)/255.;\n    \n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1601, 1601, 1662, 1662, 2406], [2408, 2408, 2442, 2442, 2594]], "test": "untested"}
{"id": "7sScDw", "name": "Make Finger Heart 2 your love", "author": "ololeecn", "description": "you can make a finger heart to your love by this shader. Just set iChannel0 a finger heart picture of you, nnd set iChannel1 a picture of your love.\nSay love loudly to him or her.", "tags": ["fingerheart"], "likes": 2, "viewed": 309, "published": 3, "date": "1643604665", "time_retrieved": "2024-07-30T17:06:17.547958", "image_code": "/*\n000 000 000\n001 101 100\n011 111 110 \n111 222 111\n111 222 111\n011 222 110\n001 111 100\n000 111 000\n000 010 000\n*/\n\n#define N 9\n#define CN N/3\n#define PINK vec3(0.945,0.62,0.761)\nint picMap[N*N] =int[](\n0,0,0,0,0,0,0,0,0,\n0,0,1,1,0,1,1,0,0,\n0,1,1,1,1,1,1,1,0,\n1,1,1,2,2,2,1,1,1,\n1,1,1,2,2,2,1,1,1,\n0,1,1,2,2,2,1,1,0,\n0,0,1,1,1,1,1,0,0,\n0,0,0,1,1,1,0,0,0,\n0,0,0,0,1,0,0,0,0);\n\n\n\n/*\nit will devide image to N*N parts.\n*/\nvec2 tri(vec2 x,float devide){\n    return mod(x,1.0/devide)*devide;\n}\n\n/*\n make picture more brightly\n*/\nvec4 whitening(vec4 inputColor,float fractor){\n    return log(inputColor*(fractor-1.0)+1.0)/log(fractor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int xindex = int(uv.x*float(N));\n    int yindex = (N-1) - int(uv.y*float(N));\n    int value = picMap[yindex*N+xindex];\n    fragColor = mix(whitening(texture(iChannel0,tri(uv,float(N))),4.0),vec4(PINK,1.0),smoothstep(float(value),0.8,1.0));\n    fragColor = mix(whitening(texture(iChannel1,tri(uv,float(N))),5.0),fragColor,step(float(value),1.0));\n\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sScDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 419, 449, 449, 488], [490, 524, 570, 570, 631], [634, 634, 691, 691, 1084]], "test": "untested"}
{"id": "NsBcDm", "name": "Refraction Thingy", "author": "SnoopethDuckDuck", "description": "click to move\n\nPlaying around with theartofcode's tutorial thingy, looks interesting when you point it at the light\n\n(messy code)", "tags": ["raymarching", "refraction", "glass", "diamond", "gem", "artofcode"], "likes": 11, "viewed": 282, "published": 3, "date": "1643598512", "time_retrieved": "2024-07-30T17:06:18.366769", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define sabs(x) sqrt(x*x+1e-2)\n#define pi 3.14159\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    vec3 op = p;\n    vec3 n = normalize(vec3(cos(iTime), 1, sin(iTime)));\n    //p += p.y;\n    float m = 0.2;\n    float time = 0. * iTime;\n   // p *= 0.7;\n    \n    for (float i = 0.; i < 4.; i++) {\n        time += 0.25 * p.y + -0.25 * iTime + pi/4.;\n       // p = sabs(1.15 * p) - m;\n        p = sabs(p) - m;\n        p.xy *= Rot(time + pi/3.);\n        p.zy *= Rot(time);\n        m *= 0.9;\n    }\n    \n    p.xz *= Rot(iTime*.1);\n    \n    //float d = sdBox(p, vec3(0.15)) - 0.0;\n    float d = length(p) - 0.25;\n    return 1.5 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3)*.7;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.05);\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n    col = pow(col, vec3(2.2));\n    \n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 1.05; // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        refOutside = pow(refOutside, vec3(2.2));\n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 reflTex = vec3(0);\n        \n        vec3 rdOut = vec3(0);\n        \n        float abb = .004;\n        \n        // red\n        rdOut = refract(rdIn, nExit, IOR-abb);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.r = texture(iChannel0, rdOut).r;\n        \n        // green\n        rdOut = refract(rdIn, nExit, IOR);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.g = texture(iChannel0, rdOut).g;\n        \n        // blue\n        rdOut = refract(rdIn, nExit, IOR+abb);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.b = texture(iChannel0, rdOut).b;\n        \n        reflTex = pow(reflTex, vec3(2.2));\n        \n        float dens = 0.1 * cos(pi * dot(rd, n));\n        float optDist = exp(-dIn*dens);\n        optDist = pow(optDist, 3.);\n        reflTex = reflTex*optDist;//*vec3(1., .05,.2);\n        \n        float fresnel = pow(1.+dot(rd, n), 3.);\n       // col = vec3(fresnel);\n        col = mix(reflTex, refOutside, fresnel);\n        //col *= n*.1+.9;\n        //col *= 1.5;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 137, 137, 199], [201, 201, 230, 230, 311], [314, 314, 337, 337, 866], [868, 868, 914, 914, 1130], [1132, 1132, 1156, 1156, 1346], [1348, 1348, 1398, 1398, 1589], [1591, 1591, 1648, 1648, 3865]], "test": "untested"}
{"id": "NsByDm", "name": "Stone Pathway", "author": "dankcatlord", "description": "This shader uses normals and parallax occlusion mapping to make a stone pathway.", "tags": ["normal", "pom"], "likes": 9, "viewed": 471, "published": 3, "date": "1643594524", "time_retrieved": "2024-07-30T17:06:19.298278", "image_code": "highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv = (fragCoord * 2.0 - iResolution.xy);\n    vec2 pos = vec2(iTime * 0.25 * iResolution.x, 0.0);\n\n    vec2 uv;\n\n    for (int i = 23; i >= 0; i--) {\n        float na = float(i) / 24.0;\n        vec2 nuv = tuv / (na * 0.125 + 0.875) + pos;\n        float nb = texture(iChannel0, nuv / iResolution.x).r;\n        \n        if (na <= nb) {\n            float pa = float(i+1) / 24.0;\n            vec2 puv = tuv / (pa * 0.125 + 0.875) + pos;\n            float pb = texture(iChannel0, puv / iResolution.x).r;\n            \n            float nc = na - nb;\n            float pc = pa - pb;\n            \n            uv = mix(nuv, puv, nc / (nc - pc));\n            \n            break;\n        }\n    }\n    \n    vec2 normal = vec2(\n        texture(iChannel0, (uv - vec2(1.0, 0.0)) / iResolution.x).r -\n        texture(iChannel0, (uv + vec2(1.0, 0.0)) / iResolution.x).r,\n        texture(iChannel0, (uv - vec2(0.0, 1.0)) / iResolution.x).r -\n        texture(iChannel0, (uv + vec2(0.0, 1.0)) / iResolution.x).r\n    ) * iResolution.x * 0.25;\n    \n    \n    vec3 col = texture(iChannel1, uv / iResolution.x).rgb * (dot(vec2(0.25,0.25), normal) * 0.25 + 0.75);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsByDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 71, 71, 1250]], "test": "untested"}
{"id": "NdBcWw", "name": "Eldritch dimension", "author": "pancakespeople", "description": "This place is just weird", "tags": ["spooky", "eldritch"], "likes": 4, "viewed": 220, "published": 3, "date": "1643583105", "time_retrieved": "2024-07-30T17:06:20.118086", "image_code": "float sdf(vec3 point) {\n    //float sphere = length(point-vec3(0.25, 1.25, 3.0))-0.5;\n    float plane = length(point.y-0.5 + cos(point.xz/2.0+iTime));\n    \n    return plane;\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float distMarched = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float dist = sdf(rayOrigin);\n        \n        rayOrigin += rayDir * dist;\n        distMarched += dist;\n        \n        if (distMarched < 0.01 || dist > 100.0) {\n            break;\n        }\n    }\n    \n    return distMarched;\n}\n\nvec3 getNormal(vec3 point) {\n    float dist = sdf(point);\n    vec3 norm = dist - vec3(\n        sdf(point - vec3(0.01, 0.0, 0.0)),\n        sdf(point - vec3(0.0, 0.01, 0.0)),\n        sdf(point - vec3(0.0, 0.0, 0.01))\n    );\n    return normalize(norm);\n}\n\nfloat getSpecular(vec3 point, vec3 lightPos, vec3 cameraPos) {\n    vec3 viewDir = normalize(cameraPos-point);\n    vec3 lightDir = normalize(lightPos-point);\n    vec3 reflectDir = reflect(-lightDir, getNormal(point));\n    return pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n}\n\nfloat getLight(vec3 point, vec3 cameraPos) {\n    vec3 normal = getNormal(point);\n    vec3 lightPos = cameraPos;\n    vec3 lightDir = normalize(lightPos-point);\n    return dot(normal, lightDir) + getSpecular(point, lightPos, cameraPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    vec3 cameraPos = vec3(0.0, 1.0, iTime);\n    vec3 rayDir = vec3(uv.x, uv.y/8.0, 1.0);\n\n    float dist = rayMarch(cameraPos, rayDir);\n    vec3 point = rayDir * dist + cameraPos;\n    \n    vec3 col = vec3(getLight(point, cameraPos));\n    col = mix(col, vec3(0.5, 0.0, 0.8), min(dist/500.0, 1.0));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 85, 175], [177, 177, 222, 222, 528], [530, 530, 558, 558, 781], [783, 783, 845, 845, 1059], [1061, 1061, 1105, 1105, 1297], [1299, 1299, 1356, 1356, 1752]], "test": "untested"}
{"id": "fdScWw", "name": "Sea Stars", "author": "wyatt", "description": "These are my sea star friends. Please don't tap the glass. ", "tags": ["seastars"], "likes": 45, "viewed": 472, "published": 3, "date": "1643580993", "time_retrieved": "2024-07-30T17:06:20.978785", "image_code": "// Fork of \"MPM dambreak\" by wyatt. https://shadertoy.com/view/NdSczm\n// 2022-01-30 22:14:48\n\n// Fork of \"Material Point Method\" by wyatt. https://shadertoy.com/view/fssyDs\n// 2022-01-26 19:42:56\n\nMain\n    vec4 c = C(U);\n    Q = 1.4-1.3*sin(c.w-4.*c.z/R.x+vec4(1,2,3,4));\n    Q = mix(.15*vec4(.5,.6,1,1),Q,c.w);\n    \n    if(U.x<3.||U.y<6.||R.x-U.x<3.||R.y-U.y<3.) Q *= 0.;\n    \n    //Q = D(U)/R.x/R.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n// How many stars\n#define N 5.\n\nfloat G (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat building(vec2 U) {\n    vec2 v = floor(U*N/(R*vec2(.64,1)));\n    U = mod(U*N,R*vec2(.64,1));\n    float n = floor(5.+8.*fract(.521*v.x+4123.341*v.y));\n    vec2 u = U-vec2(.3,.5)*R;\n    if (length(u)<.05*R.y) return 1.;\n    if (sin(n*atan(u.y,u.x))>2.1*length(u)/R.y) return 1.;\n    return 0.;\n\n}\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\nfloat _12(vec2 U) {\n    U = floor(U);\n    return U.x+U.y*R.x;\n}\nvec2 _21(float i) {\n    return .5+vec2(mod(i,R.x),floor(i/R.x));\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-.2/R.y);\n    \n    for (float x = -4.; x <= 4.; x ++) \n    for (float y = -4.; y <= 4.; y ++)\n    if (x!=0.||y!=0.) {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 c = C(Q.xy+u-.015);\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        float L = length(u);\n        f -= .01*c.w*u/L;\n        if ((l-L)<4.)  \n            f += 1e-1*r/l*(l-L)/L;\n    }\n    \n    Q.zw = mix(Q.zw,c.xy,.1);\n    Q.zw += f;\n    Q.xy += Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    //if (length(Q.zw)>2.) Q.zw = 2.*normalize(Q.zw);\n    \n    if (Q.y<1.) Q.zw *= 0.;\n    if (Q.x<1.) Q.zw *= 0.;\n    if (R.y-Q.y<1.) Q.zw *= 0.;\n    if (R.x-Q.x<1.) Q.zw *= 0.;\n\n    if (M.z>0.) Q.zw -= 1e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    vec4 d = D(U);\n    vec4 a = A(_21(d.x));\n    if (cell(a.xy-U)&&i<4\n        &&d.x!=Q.x&&d.x!=Q.y&&d.x!=Q.z&&d.x!=Q.w\n    ) Q[i]= d.x;\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    float w = 0.;\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        for (int k = 0; k < 4; k++) {\n            if (b[k]>0.) {\n                vec2 u = _21(b[k]);\n                vec4 a = A(u);\n                vec2 v = a.xy-U;\n                float e = G(length(v),2.);\n                w += e;\n                Q.xyz += vec3(a.zw,u.x)*e;\n                Q.w += G(length(v),1.2);\n            } else break;\n        }\n    }\n    if (w>0.) Q.xy /= w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    \n    if (I<1) Q = vec4(_12(U));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdScWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dXcWf", "name": "Implicit Terrain LOD Subdivision", "author": "paniq", "description": "Statelessly subdividing a 2D terrain space around the camera position (interactively represented by mouse position). The principle straightforwardly generalizes from 1D to higher dimensions.", "tags": ["terrain", "lod", "quadtree"], "likes": 17, "viewed": 588, "published": 3, "date": "1643564651", "time_retrieved": "2024-07-30T17:06:21.757702", "image_code": "const int MAXLEVEL = 8;\nint RES = 1 << MAXLEVEL;\n\nivec2 mouse() {\n    vec2 p = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    ivec2 ip = ivec2((p + 1.0)/2.0 * float(RES));\n    return ip;\n}\n\nivec3 pos2tile(ivec2 ip, int stp) {\n    return ivec3(ip >> stp, stp);\n}\n\nivec2 tile2pos(ivec3 tile) {\n    return tile.xy << tile.z;\n}\n\nbool subdivide1d(int p, int t, int S) {\n    S = S>>1;\n    t = (t - p)>>1; \n    t = ((t >= 0)?(t - 2 * S + 1):(- t - S));\n    return (t < 0);\n}\n\n// T = tile position [0 .. 1<<level]x[0 .. 1<<level], tile level 0..N\nbool subdivide2d(ivec3 T, ivec2 t) {    \n#if 0\n    // descend if tile contains point\n    t = (t >> T.z) - T.xy;\n    return max(abs(t.x),abs(t.y)) <= 0;\n#elif 0\n    // descend if 3x3 tile contains point\n    t = (t >> T.z) - T.xy;\n    return max(abs(t.x),abs(t.y)) <= 1;\n#else\n    // descend if distance to target falls below 1:2 threshold\n    int S = 1 << T.z;\n    ivec2 p = T.xy << T.z;    \n    return subdivide1d(p.x, t.x, S) && subdivide1d(p.y, t.y, S);\n#endif\n}\n\nvec3 viridis(float t) {\n    t = clamp(t, 0.0, 1.0);\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = fragCoord / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    if (max(abs(p.x),abs(p.y)) > 1.0)\n        return;\n    ivec2 ip = ivec2((p + 1.0)/2.0 * float(RES));\n    const int N = MAXLEVEL;\n    vec3 color = vec3(1.0);\n    int steps = 0;\n    float dist = 0.0;\n    int L = 3;\n    for (int i = 0; i <= N; ++i) {\n        ivec3 T = pos2tile(ip, N - i);\n        if (!subdivide2d(T, mouse())||(i+1 == N)) {\n            color = viridis(float(i)/float(N-1));\n            vec2 q0 = vec2(tile2pos(T))/float(RES)*2.0 - 1.0;\n            vec2 q1 = vec2(tile2pos(ivec3(T.xy+1,T.z)))/float(RES)*2.0 - 1.0;\n            vec2 c = (q1 + q0)/2.0;\n            vec2 h = (q1 - q0)/2.0;\n            float q = abs(max(abs(p.x - c.x), abs(p.y - c.y)) - h.x);\n            q = clamp(q*iResolution.y/2.0, 0.0, 1.0);\n            color *= vec3(q);\n            break;\n        }        \n    }    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 65, 65, 227], [229, 229, 264, 264, 300], [302, 302, 330, 330, 362], [364, 364, 403, 403, 506], [508, 578, 614, 614, 1042], [1044, 1044, 1067, 1067, 1750], [1752, 1752, 1808, 1808, 2741]], "test": "untested"}
{"id": "sd2yWW", "name": "Octahedron - Gradient 3D", "author": "Dain", "description": "Signed distance to an octahedon along with its analytic gradient\nDistance is from TheTurk's comment in https://www.shadertoy.com/view/wsSGDG\nJust added the gradient\n\nNorm is scaled into 0-1 range for visualization to verify signs", "tags": ["gradient", "normal", "analytic", "octahedron"], "likes": 6, "viewed": 244, "published": 3, "date": "1643562470", "time_retrieved": "2024-07-30T17:06:22.648321", "image_code": "\n//The floor shows the internal distance/gradient\n//Norm is scaled into 0-1 range for visualization to verify signs\n\n\n//Set to 1 to show numeric gradient to verify that it matches analytic\n#define SHOW_NUMERIC_GRADIENT 0\n\n//if 1 it scales norm into 0-1, if 0 it takes abs\n#define SHOW_FULL_NORM_RANGE 1\n\n//Signed distance to an octahedon along with its analytic gradient\n//Distance is from TheTurk's comment in https://www.shadertoy.com/view/wsSGDG\n//just added the gradient\nfloat sdgOctahedron(vec3 inP, float s, out vec3 norm) {    \n    vec3 p = abs(inP);\n    float m = (p.x + p.y + p.z - s) / 3.0;\n    vec3 o = p - m;\n    vec3 k = min(o, 0.0);\n    o = o + (k.x + k.y + k.z) * 0.5 - k * 1.5;\n    o = clamp(o, 0.0, s);     //our point on surface\n    \n    vec3 v = p - o;\n    \n    float v2 = dot(v,v);\n    float v2Rsqrt = inversesqrt(v2);\n    \n    //gradient, but need to flip signs because we are in the positive octant \n    //and then flip it again if inside\n    norm = (v * sign(inP)*sign(m)*v2Rsqrt);\n    \n    return v2*v2Rsqrt * sign(m);\n}\n\n            \n//Rest of code by mostly by paniq\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,1.0);\n}\n\nvec2 add_plane(vec3 p, vec2 m) {\n    return min2(plane(p),m);\n}\n\nvec2 doModelWithNorm( vec3 p, out vec3 norm) {\n\n    float Size = 1.5;\n   // float d = Tetrahedron(p, Size, 0.0);\n   float round = .8*abs(sin(iTime*.3));\n   float rad = abs(cos(iTime*.1))*.5 + .50;//,norm;\n    float d = sdgOctahedron(p, rad, norm )-round;\n    \n#if SHOW_NUMERIC_GRADIENT==1\n     const vec2 e = vec2(1,-1);\n     const float eps = 0.0002;\n     norm = normalize( e.xyy*sdgOctahedron( p + e.xyy*eps, rad, norm )  + \n                             e.yyx*sdgOctahedron( p + e.yyx*eps, rad, norm ) + \n                             e.yxy*sdgOctahedron( p + e.yxy*eps,rad, norm ) + \n                             e.xxx*sdgOctahedron( p + e.xxx*eps, rad, norm ));\n#endif\n\n#if SHOW_FULL_NORM_RANGE == 1\n    norm = norm*.5 + .5;\n #else\n    norm = abs(norm);\n#endif\n                             \n\t// d = min(d,length(p)-Size);//use to verify sphere size and tet match up\n    return add_plane(p, vec2(d,0.0));\n}\nvec2 doModel( vec3 p) {\nvec3 norm;\n    return doModelWithNorm(p, norm);\n}\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 norm,norm2;\n    float k = doModelWithNorm(pos,norm).y;\n    float d = doModelWithNorm(vec3(pos.x,0.0,pos.z),norm2).x;\n    \n    float w = abs(mod(d, 0.1)/0.1 - 0.5);\n    \n    vec4 objCOlor = vec4(0.1,.01,1.0,0.1);\n    objCOlor.xyz = norm;\n    return mix(objCOlor, //nor * 0.5 + 0.5,\n               vec4(norm2,0.0) * w,\n               clamp(k,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\tfloat cos_Ol = max(0.0, dot(nor, lig));\n    vec3 h = normalize(lig - rd);\n    float cos_Oh = max(0.0,dot(nor, h));\n    float dif = cos_Ol;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(0.8, 0.7, 0.6)*sha;\n    \n    lin += vec3(0.20,0.30,0.30);\n\n    \n    vec3 col = mal.rgb*lin;\n\n    // specular\n    col += cos_Ol * pow(cos_Oh,40.0);\n    \n    // envmap\n //   col += mal.w*Texture2D(iChannel0, reflect(rd,nor)).rgb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<80; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        \n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n        if(h <= 0.0){\n            break;\n        }\n        t +=abs(h);\n        if(t > 20.0){\n            break;\n        }\n      //  t += max(h, 0.;\n\t//\tt += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n  //  vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n   // vec3 ro, ta;\n    //doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n   // mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\t//vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x;\n    \n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col * 0.6); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2yWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 475, 530, 530, 1044], [1059, 1093, 1176, 1176, 1299], [1301, 1301, 1328, 1328, 1363], [1365, 1365, 1392, 1392, 1423], [1425, 1425, 1452, 1452, 1482], [1485, 1485, 1506, 1506, 1538], [1540, 1540, 1572, 1572, 1603], [1605, 1605, 1651, 1651, 2513], [2514, 2514, 2537, 2537, 2587], [2588, 2941, 2986, 2986, 3348], [3561, 3561, 3645, 3645, 4286], [4288, 4288, 4338, 4338, 4766], [4768, 4768, 4800, 4800, 5220], [5222, 5222, 5270, 5270, 5849], [5851, 5851, 5915, 5915, 6093], [6095, 6095, 6131, 6131, 6225], [6227, 6227, 6284, 6284, 8004]], "test": "untested"}
{"id": "fsjyDD", "name": "fake smoke", "author": "jorge2017a2", "description": "fake smoke", "tags": ["fakesmoke"], "likes": 14, "viewed": 381, "published": 3, "date": "1643553984", "time_retrieved": "2024-07-30T17:06:23.563874", "image_code": "//----------image\n//por jorge2017a2-\n//fake smoke\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\n//modificado por jfp\nfloat sdCylinderYZfbm( vec3 p, vec2 h )\n{\n vec2 q;\n    vec2 st = p.xy -vec2(0.0,5.0);\n    vec2 pos=vec2((iTime*5.0),-0.5+ 2.0*sin(iTime*5.0) ) ;\n    q.x = fbm(st+pos);\n     q.y = fbm(st+vec2(0.2,-0.5)*pos*q.x);\n      vec2 d = abs(vec2(length(p.yz+q+vec2(-0.5,-0.5)),p.x)) - h; \n   return min(max(d.x,d.y),0.0) + length(max(d,0.0)); \n}\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0); \n    vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   \n    p.y=p.y-5.0;\n    float d1a= sdCylinderYZ( p-vec3(0.0,5.0,0.0), vec2(2.0,5.0) );\n    float d1b= sdCylinderYZ( p-vec3(-1.0,5.0,0.0), vec2(1.8,5.2) );\n    float d2= sdCylinderXZ(p-vec3(5.0,0.0,0.0), vec2(2.0,7.5) );\n    float d1c= sdCylinderYZfbm( p-vec3(-15.0,5.0,0.0), vec2(1.7,10.0) );\n    \n    float duni= unionSDF(d1a, d2);\n    float dint= intersectSDF(d1a, d2);\n    duni= differenceSDF(duni, d1b);\n    res =opU3(res, vec3(duni,2.0,-1.0));\n    res =opU3(res, vec3(d1c,1.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-10.0, 120.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(-25.0,7.0,-10.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd=rotate_y(rd, radians(45.0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n\nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n///--------------------\n///referencia\n///https://www.shadertoy.com/view/NdKGzz\nfloat random(vec2 _st)\n{ return fract(sin(dot(_st.xy,vec2(0.630, 0.710))) *43759.329); }\n\nfloat noise(vec2 _st)\n{  vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 3\nfloat fbm(vec2 _st)\n{   float v = 0.01;\n    float a = 0.5;\n    vec2 shift = vec2(100.0, 100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n\n    for (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        v += a * noise(_st);\n        _st = _st*rot * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 551, 551, 646], [647, 647, 686, 686, 781], [782, 782, 821, 821, 916], [919, 940, 981, 981, 1274], [1277, 1277, 1324, 1324, 1351], [1352, 1352, 1395, 1395, 1422], [1423, 1423, 1471, 1471, 1499], [1501, 1501, 1537, 1537, 1582], [1584, 1584, 1618, 1618, 1714], [1715, 1715, 1749, 1749, 1840], [1841, 1841, 1875, 1875, 1966], [1968, 1968, 1993, 1993, 2640], [2642, 2642, 2666, 2666, 2828], [2830, 2830, 2879, 2879, 3510], [3512, 3512, 3548, 3548, 3793], [3795, 3795, 3832, 3832, 4091], [4093, 4093, 4176, 4176, 4745], [4748, 4748, 4841, 4841, 4971], [4973, 4973, 5005, 5005, 5202], [5204, 5252, 5280, 5280, 5468], [5470, 5470, 5517, 5517, 5743], [5745, 5745, 5838, 5838, 6175], [6178, 6178, 6205, 6205, 6294], [6296, 6296, 6354, 6354, 6402], [6405, 6405, 6428, 6428, 6546], [6548, 6548, 6579, 6579, 7291], [7295, 7295, 7352, 7352, 7870]], "test": "untested"}
{"id": "wsdfzs", "name": "Circles and Lines (kick)", "author": "kick", "description": "projecting 2D SDF on ray intersected planes.   The mouse does stuff.", "tags": ["sdf"], "likes": 12, "viewed": 391, "published": 3, "date": "1643524685", "time_retrieved": "2024-07-30T17:06:24.428561", "image_code": "#define texture texture2D\n#define ut iTime\n#define kPI 3.14159265\n#define khPI 1.57079633\n#define k3qPI 4.71238898\n#define k2PI 6.2831853\n#define kPIi 0.3183089\n#define k2PIi 0.1591549\n#define f(x) fract(x)\n#define l(x) length(x)\n#define c(x,y,z) clamp(x,y,z)\n#define p(x,y) pow(x,y)\n#define r(x) f(sin(x)*100000.0)\n#define n(x) normalize(x)\n#define v3 vec3(0)\n#define S(a,b,x) smoothstep(a,b,x)\n#define SS(x) smoothstep(0.,1.,x)\n#define SC(x,a,b) (smoothstep(0.,1.,(x-a)/(b-a))*(b-a)+a)\n\nfloat smoothMin(float x, float min) {\n  float k = (1.-min);\n  return SS((x - min)/k)*k+min;\n}\nfloat notch(float t, float a, float b, float w ) {\n  return smoothstep(b, b+w, t) + 1. - smoothstep(a-w, a, t );\n}\n\n#define SMin(x,m) smoothMin(x,m)\n#define inf 1e20\n\n#define m vec2(iMouse.xy/iResolution.xy)\n#define m2 (vec2(iMouse.xy/iResolution)*2.-1.)\n#define md ((m - 0.5) * 2.)\n#define time iTime\n\nfloat SCALE = 2.;\nfloat cameraDistance = 1.;\nfloat lineWidth;\n\n#define fill(x,f) (1. - smoothstep(0.,lineWidth*(f),(x)))\n#define stroke(x,f) (1. - smoothstep(0.,lineWidth*(f),abs(x)))\n#define glow(x,f) (1. - pow(smoothstep(0.,(f)*lineWidth,abs(x)),0.2))\n#define aglow(x,f) (1. - (smoothstep(0.,(f)*lineWidth,abs(x))))\n#define fillGlow(x,f) (1. - pow(smoothstep(0.,(f)*lineWidth,(x)),0.2))\n\n// Misc Functions\n\nvoid pR(inout vec2 p,float a) {\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec3 pal(float t) {\n  vec3 a=vec3(0.5,0.5,0.5),\n  b=vec3(0.5),\n  c=vec3(1),d=vec3(0,0.33,0.67);\n\treturn a+b*cos(6.2318*(c*t+d));\n}\n\n// 2D Functions\n\nfloat angle( vec2 p, vec2 c ) {\n  vec2 cp = p-c;\n  float a = atan( cp.y, cp.x );\n  a = mod(a + k2PI, k2PI);\n  return a;\n}\n\nvec2 polar2cart( float theta, float r ) {\n  float c = cos(theta), s = sin(theta);\n  return vec2(c*r, s*r);\n}\n\n// distance to line segment\nfloat sdSegment2( vec2 p, vec2 a, vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// distance between points\nfloat sdPoint2( vec2 p1, vec2 p2 ) {\n  return length( p1 - p2 );\n}\n\nfloat sdCircle( vec2 p, vec2 c, float r ) {\n  vec2 q = p;//-c.xy;\n  q = q-c.xy;\n  float d = length(q);\n  d = d - r;\n  return d;\n}\n\n// 3D Functions\n\nfloat sdPlane( vec3 ro, vec3 rd, vec4 p ) {\n\treturn -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3  co = o - c;\n\tvec3  n = cross(u,v);\n  float t = -dot(n,co)/dot(d,n);\n  float r =  dot(u,co + d*t);\n  float s =  dot(v,co + d*t);\n  return vec3(t,s,r);\n}\n\n// Procedural Textures\n\nfloat chex(vec2 uv)\n{\n  vec2 w = fwidth(uv) + 0.01;\n  vec2 i = 2.0*(abs(f((uv-0.5*w)*0.5)-0.5)-abs(f((uv+0.5*w)*0.5)-0.5))/w;\n  return 0.5 - 0.5*i.x*i.y;\n}\n\n// Shape creators\n\nfloat R = 01.25;\n\nvec4 randomLine( int i ) {\n  float aa = r(float(i)+0.31)*112.9;\n  vec4 l = vec4(r(aa+1.),r(aa+2.1), r(aa+3.8), r(aa+6.7));\n  l = l * 4. - 2.;\n  l *= R;\n  return l;\n}\n\nvec3 randomCircle( int i ) {\n  float aa = r(float(i)*0.001+0.233)*(12.);\n  vec3 c = vec3(-1.+2.*r(aa+1.),-1.+2.*r(aa+2.1),r(aa+3.8)+0.2);\n  c *= R;\n  return c;\n}\n\n/*\n\n WWWWW  WWWWW  WWWWW  WW   W  WWWWW\n W      W      W      W W  W  W\n WWWWW  W      WWW    W  W W  WWW\n     W  W      W      W   WW  W\n WWWWW  WWWWW  WWWWW  W    W  WWWWW\n\n*/\n\nvec2 center1 = vec2(0,0);\nvec2 center2d = vec2(0,-2);\nmat3 plane = mat3(\n  vec3(-1,-1,-1),\n  normalize(vec3(1,0,0)),\n  normalize(vec3(0,1,0))\n);\n\nvec3 sprouts( vec2 p ) {\n  float xRatio = 0.125;\n  float yRatio = 1.1;\n  p = 4. - p;\n  p = polar2cart(p.x*k2PI*xRatio, p.y*yRatio);\n  p = polar2cart(p.y*k2PI*xRatio, p.x*yRatio);\n  p = polar2cart(p.x*k2PI*xRatio, p.y*yRatio);\n  p = polar2cart(p.y*k2PI*xRatio, p.x*yRatio);\n  float a;\n  a = angle(p, center1);\n  a = l(p);\n  float ta = time*0.125;\n  float c = 0.;\n  vec2 q = polar2cart( -ta*k2PI, sin(time)+1.);\n  a = fract(a * k2PIi + ta);\n  a = SS(abs(a*2.-1.));\n  c += a;\n  vec3 col = vec3(c);\n  return col;\n}\n\nvec3 screen( vec3 col1, vec3 col2 ) {\n  return 1. - (1.-col1)*(1.-col2);\n}\n\nvec2 paraline( vec2 a, vec2 b, float t ) {\n  return mix(a,b,t);\n}\n\nfloat slidingGlow( vec2 p, vec4 line, float t ) {\n  float color = 0.;\n  vec2 lp = paraline(line.xy, line.zw, t );\n  float dp;\n  dp = sdPoint2(p,lp);\n  float d = sdSegment2(p, line.xy, line.zw);\n  color += glow(d*dp, 20.);\n  return color;\n}\n\n// float linePoint( vec2 p, vec4 line, float t ) {\n//   float color = 0.;\n//   vec2 lp = paraline(line.xy, line.zw, t );\n//   pR(lp, sin(time*0.7)*line.y);\n//   float dp;\n//   vec2 q = lp - p;\n//   dp = dot(q,q);\n//   color += glow(dp, 20.);\n//   return color;\n// }\n\nfloat doCircle( vec2 p, vec3 c ) {\n  vec2 cp = p-c.xy;\n  float d = dot(cp,cp) - c.z;\n  return glow( d, 50. );\n  // return glow( sdCircle(p, c.xy, c.z), 30. );\n}\n\n#define NUM_CIRCS 8\n#define NUM_LINES 5\n\nvec3 doCircles( vec2 p ) {\n  vec3 color = vec3(0);\n  int i = 0;\n  float d; vec3 c; vec4 l;\n  for( int i=0; i < NUM_CIRCS; i++ ) {\n    c = randomCircle(i);\n    pR(c.xy,time*c.y);\n    c.z *= sin(time*c.z)*0.5+0.7;\n    color = screen(color,doCircle( p, c ) * pal(c.z));\n  }\n  return color;\n}\n\nvec3 doLines( vec2 p ) {\n  vec3 color = vec3(0);\n  float t = sin(time)*0.5+0.5;\n  vec4 l;\n  for( int i=0; i < NUM_LINES; i++ ) {\n    l = randomLine(i);\n    pR(l.xy, time*l.x);\n    pR(l.zw, -time*l.z*0.1);\n    color = screen(color,slidingGlow( p, l, t ) * pal(length(l.xz)));\n  }\n  return color;\n}\n\nvec3 get2dColor( vec2 p ) {\n  p -= center2d;\n  vec3 color = vec3(0);\n  color += doCircles(p);\n  color += doLines(p);\n  // color = screen(color,sprouts(p.yx)*(-0.4+0.5*sin(time*0.33)));\n  return color;\n}\n\nvec3 getRayColor( vec3 ro, vec3 rd ) {\n  vec3 color = vec3(0);\n\n  vec3 pi = intersectCoordSys(ro, rd, plane[0], plane[1], plane[2] );\n  if( pi.x > 0. ) color += get2dColor(pi.zy);\n  pi = intersectCoordSys(ro, rd, plane[0], plane[2].yxz, vec3(0,1,0) );\n  // if( pi.x > 0. ) color = screen(color,get2dColor(pi.yz));\n  if( pi.x > 0. ) color += get2dColor(pi.yz);\n  return color;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nstruct Ray {\n  vec3 ro;\n  vec3 rd;\n};\n\nmat3 camMatrix( vec3 ff ) {\n  ff = normalize(ff);\n  vec3 uu = normalize(cross(ff, vec3(0,1,0)));\n  vec3 vv = cross(uu, ff);\n  return mat3(uu,vv,ff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  pR(plane[2].yz,m.x*k2PI);\n\n  float minD = min(iResolution.x, iResolution.y);\n  lineWidth = (0.0013*SCALE*(600./minD));\n\n  vec2 cartesian = 2.*(fragCoord-iResolution.xy*0.5) / minD;\n  vec2 q = fragCoord/iResolution.xy;\n\n  vec3 target = vec3(0,0,0);\n  vec3 camera = vec3(0,0,1);\n  mat3 cmat = camMatrix(target-camera);\n  float le = 1.;\n  vec3 rd = normalize(vec3(cartesian,le) * cmat);\n\n  // vec3 col = get2dColor( cartesian );\n  vec3 col = getRayColor( camera, rd );\n\n  // dithering\n  col += (1.0/255.0)*hash3(cartesian.x+13.3214*cartesian.y);\n\n  // col *= 1. - texture(u_tex0, q).rgb *0.2;\n  fragColor = vec4(col,1);\n}\n\n// void main() {\n//   mainImage(gl_FragColor, gl_FragCoord.xy);\n//   if( gl_FragCoord.y < 10. ) { gl_FragColor=vec4(pal(gl_FragCoord.x/iResolution.x),1.); }\n// }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 526, 526, 582], [583, 583, 633, 633, 697], [1295, 1295, 1326, 1326, 1363], [1365, 1365, 1384, 1384, 1495], [1514, 1514, 1545, 1545, 1635], [1637, 1637, 1678, 1678, 1745], [1747, 1775, 1819, 1819, 1932], [1934, 1961, 1997, 1997, 2027], [2029, 2029, 2072, 2072, 2158], [2177, 2177, 2220, 2220, 2266], [2268, 2268, 2340, 2340, 2499], [2525, 2525, 2546, 2546, 2680], [2719, 2719, 2745, 2745, 2884], [2886, 2886, 2914, 2914, 3047], [3374, 3374, 3398, 3398, 3884], [3886, 3886, 3923, 3923, 3960], [3962, 3962, 4004, 4004, 4027], [4029, 4029, 4078, 4078, 4268], [4537, 4537, 4571, 4571, 4697], [4740, 4740, 4766, 4766, 5028], [5030, 5030, 5054, 5054, 5326], [5328, 5328, 5355, 5355, 5530], [5532, 5532, 5570, 5570, 5909], [5911, 5911, 5934, 5934, 5990], [6031, 6031, 6058, 6058, 6181], [6183, 6183, 6240, 6240, 6861]], "test": "untested"}
{"id": "NsBcDD", "name": "Toroidal Disk Distance", "author": "demofox", "description": "Shows the distance field of a point on a \"toroidal disk\"\nmouse drag to choose source location\nhttps://blog.demofox.org/2022/01/29/distance-between-points-on-a-toroidal-disk/", "tags": ["distance"], "likes": 8, "viewed": 281, "published": 3, "date": "1643511499", "time_retrieved": "2024-07-30T17:06:25.532610", "image_code": "// walking past the end of the circle brings you back to the center, and vice versa\n// Assumes your points are in [0,1)^N with a disk center of (0.5, 0.5, ...)\nfloat DistanceUnitDiskTorroidal(vec2 v1, vec2 v2)\n{\n    // Calculate the distance between the points going through the disk.\n    // This is the \"internal\" distance.\n    float distanceInternal = length(v1 - v2);\n\n    // The external distance is the distance between the points if going through the center\n    // or past the edges.\n    // This is the sum of the distance between each point and either the circle edge or the\n    // circle center, whichever is closer.\n    float distanceExternal1 = length(v1 - 0.5f);\n    distanceExternal1 = min(distanceExternal1, 0.5 - distanceExternal1);\n\n    float distanceExternal2 = length(v2 - 0.5f);\n    distanceExternal2 = min(distanceExternal2, 0.5 - distanceExternal2);\n\n    float distanceExternal = distanceExternal1 + distanceExternal2;\n\n    // return whichever is less, between the internal and external distance.\n    return min(distanceInternal, distanceExternal);\n}\n\nvec2 UVToWorld(vec2 uv)\n{\n    uv.y = 0.5 + (uv.y - 0.5) * iResolution.y / iResolution.x;\n    uv = 0.5 + (uv - 0.5) * 2.0;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sourcePos = UVToWorld(iMouse.xy / iResolution.xy);\n    if (length(sourcePos - 0.5) > 0.5)\n        sourcePos = 0.5 + normalize(sourcePos - 0.5) * 0.5;\n    \n    vec2 pos = UVToWorld(fragCoord/iResolution.xy);\n    \n    if (length(pos - sourcePos) < 0.01)\n    {\n        fragColor = vec4(0.0, 0.0, 1.0 ,1.0);\n        return;    \n    }    \n\n    if (length(pos - 0.5) > 0.5)\n    {\n        fragColor = vec4(1.0, 1.0, 1.0 ,1.0);\n        return;\n    }\n\n    // Time varying pixel color\n    float dist = DistanceUnitDiskTorroidal(sourcePos, pos);\n    \n    // dist multiplied by 2 because the radius is 0.5, so that's the maximum distance.\n    // multiply by 2 to make the max distance be 1\n    vec3 col = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), dist * 2.0);\n    \n    col *= 0.75+0.25*(cos(6.28*20.0*dist));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// TODO: click to change where the source point is", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 211, 324, 1070], [1072, 1072, 1097, 1097, 1210], [1212, 1212, 1269, 1269, 2137]], "test": "untested"}
{"id": "NdByDW", "name": "bola bola", "author": "jorge2017a2", "description": "bola bola", "tags": ["bolabola"], "likes": 22, "viewed": 335, "published": 3, "date": "1643493942", "time_retrieved": "2024-07-30T17:06:27.587117", "image_code": "//----------image\n//por jorge2017a2-\n//bola bola---29-ene-2022\n//referencia\n//https://www.shadertoy.com/view/NdSyDW\n//https://www.shadertoy.com/view/Xls3D2\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n//https://www.shadertoy.com/view/NdSyDW\nfloat pathterrain(float x,float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}\n\n//https://www.shadertoy.com/view/Xls3D2\nfloat height(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    h -= sin(h*10.0)*.1;\n    return h;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n   float h1= pathterrain(p.x,p.z);\n    float planeDist1 = p.y+h1;\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    \n    //float h2= height(p.yz);\n    //float planeDist3 = p.x+30.0+h2; \n    //res =opU3(res, vec3(planeDist3,-1.0,9.0));\n    \n    float h3= height(p.yz);\n    float planeDist4 = 30.0-p.x+h3; \n    res =opU3(res, vec3(planeDist4,-1.0,9.0));\n    \n    float h4= height(p.xz);\n    float planeDist2 = 20.0-p.y+h4;  //piso sup\n    res =opU3(res, vec3(planeDist2,-1.0,7.0));\n   \n    vec3 pnew=vec3(p.x-5.0,p.y-2.0, p.z-itime);\n    float sds1=sdSphere(pnew, 2.0 );\n    res =opU3(res, vec3(sds1,2.0,-1.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        \n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-10.0, 120.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(-5.0,1.0,0.0+t);\n   float h1= pathterrain(ro.x,ro.z);\n   ro.y-=h1;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(90.0));\n   rd= rotate_x(rd, radians(5.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdByDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 653, 653, 674], [675, 675, 707, 707, 791], [793, 793, 840, 840, 867], [868, 868, 911, 911, 938], [939, 939, 987, 987, 1015], [1016, 1016, 1052, 1052, 1097], [1100, 1100, 1134, 1134, 1230], [1231, 1231, 1265, 1265, 1356], [1357, 1357, 1391, 1391, 1482], [1484, 1524, 1560, 1611, 1706], [1708, 1748, 1773, 1773, 1908], [1910, 1910, 1935, 1935, 2615], [2617, 2617, 2641, 2641, 2803], [2805, 2805, 2854, 2854, 3495], [3497, 3497, 3533, 3533, 3778], [3780, 3780, 3817, 3817, 4080], [4082, 4082, 4165, 4165, 4739], [4741, 4741, 4834, 4834, 4964], [4966, 4966, 4998, 4998, 5195], [5197, 5245, 5273, 5273, 5461], [5463, 5463, 5510, 5510, 5741], [5743, 5743, 5836, 5836, 6173], [6176, 6176, 6203, 6203, 6292], [6294, 6294, 6352, 6352, 6400], [6403, 6403, 6426, 6426, 6544], [6546, 6546, 6577, 6577, 7288], [7291, 7291, 7348, 7348, 7992]], "test": "untested"}
{"id": "fsSyDW", "name": "Gravity Heatmap", "author": "GDur", "description": "This shader calculates the force of gravity at each point/pixel of this texture.\nThe force is dependent on the position and mass of particles.\nThe denser the \"rings\" are, the stronger the gravity.", "tags": ["gravity", "heatmap"], "likes": 2, "viewed": 232, "published": 3, "date": "1643493191", "time_retrieved": "2024-07-30T17:06:28.473746", "image_code": "//  Function from Iigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c)\n{\n    vec3 m = mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0);\n    vec3 rgb = clamp(abs(m - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n\nfloat calculateGravityIntensity(in vec2 fragCoord, vec3[3] planets)\n{\n  // planet xy = coords\n  // planet z  = mass\n\n  float gravitationForce = 0.0;\n  for (int i = 0; i < 3; i++) {\n    vec3 p = planets[i];\n    vec2 diffVector = (p.xy - fragCoord);\n    float magnitudeSquared = dot(diffVector, diffVector);\n    // magnitude could be 0. Division by 0 is \"infinity\".\n    magnitudeSquared += .1;\n    float G = (sin(iTime/4.0) / 2.0 + 0.5)*.001;\n    // float G = 0.001 ;\n    gravitationForce -= (G * p.z) / (magnitudeSquared);\n  }\n  return gravitationForce;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float radius = length(iResolution.xy);\n  float massMultiplicator = radius * radius;\n\n  float sinT = 200.0 ; //* sin(iTime / 4.0);\n  float cosT = 200.0 ; //* cos(iTime / 4.0);\n  \n  vec3 planets[3];\n  planets[0] = vec3(iResolution.xy / 2.0, 9.0 * massMultiplicator);\n  planets[1] = vec3(iResolution.x / 2.0 + sinT * 2.0, iResolution.y / 2.0 + cosT * 1.5, 2.0 * massMultiplicator);\n  planets[2] = vec3(iResolution.x / 2.0 - sinT * 4.0, iResolution.y / 2.0, 13.0 * massMultiplicator);\n\n  float gravityIntensity = calculateGravityIntensity(fragCoord, planets);\n\n  // the force of gravity will have a huge range eg.: 1 to 10k\n  // here we use the tan function to let the colors repeat which creates the \"rings\"\n  // a lot of different variations would be possible\n  float max = 3.0;\n  float min = 1.0;\n  float gravitationForce = tan(gravityIntensity * 10.0) * 0.5;\n  if (gravitationForce < min) {\n    gravitationForce = min;\n  }\n  if (gravitationForce > max) {\n    gravitationForce = max;\n  }\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy * .8;\n  vec3 col2 = 0.5 + .5 * cos((iTime / 3.0 + gravitationForce) * .9 + uv.xyx + vec3(0, 2, 3));\n  fragColor = vec4(col2, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 99, 99, 293], [853, 853, 908, 908, 2117]], "test": "untested"}
{"id": "7djyD1", "name": "Stack game", "author": "FabriceNeyret2", "description": "1st base of the stack game:  click at the right moment !\nhttps://keygames.com/stack-games/\n\nNote that you can change the init slice shape ( to anything, even texture ) in buffA.\nuncomment line #19 and reset  :-)", "tags": ["game", "short"], "likes": 21, "viewed": 403, "published": 3, "date": "1643481846", "time_retrieved": "2024-07-30T17:06:29.241692", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === game mechanism in 2D view ==========\n// O.x = previous stored slice\n// O.y = current moving slice\n// O.w = try counter\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                                 // previous shape\n                                                              // move current slice\n    O.y = T(u - R.x/6.*sin(2.*iTime)*(mod(O.w,2.)<1.?vec2(1,0):vec2(0,1)) ).x;\n    \n    if (iMouse.w > 0.)                                        // --- on click\n        O.w++,                                                // try++\n        O.x *= O.y;                                           // slice intersection\n\n    vec2 U = ( 2.*u - R ) / R.y, A = abs(U);                  // --- init\n    if (iFrame<1) O.x = step( max(A.x,A.y), .25)              // draw square\n                     // step( length(U), .25)                 // disk instead of square\n                     // * 2.*texture(iChannel1,U).x           // with texture\n                        ;\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0, ivec2(U),0 )", "buffer_b_code": "// === 3D view + counter + stack ============================\n// as in buffA + O.z = stack.\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.*u - R ) / R.y, H = 32.*u/R;  U.y -= .3;\n //                            inverse(mat2(2,-2,1,1))\n    O = texture( iChannel1, U * mat2(1,2,-1,2)/4.*R.y/R +.5 ); // 3D view\n    if (u.x < 10. && H.y < O.w && fract(H.y) > .1 ) O++;       // try counter\n \n    O.z =   iFrame < 1  ? O.x                                  // init\n          : iMouse.w > 0.                                      // onclick\n              ? T(u+vec2(0,R.y/32.)).z + O.x                   //   stack\n              : T(u).z;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 54]], "test": "untested"}
{"id": "7d2cDz", "name": "Fork Falling Sa manthrax 836", "author": "manthrax", "description": "sand: click + drag: \nwall: left shift + click + drag:\nerase: space + click + drag:\n\nchange scale and brush radius in common tab\n\ntheres a bug where sometimes sand duplicates itself :)", "tags": ["simulation", "falling", "sand"], "likes": 5, "viewed": 283, "published": 3, "date": "1643472021", "time_retrieved": "2024-07-30T17:06:30.192151", "image_code": "float rand_n(float r, int n)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        r = fract(r * 100.0);\n    }\n    \n    return r;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord / scale);\n    Particle self = particle_at(coord);\n    \n    switch (self.type)\n    {\n        case SAND:\n        {\n            frag_color = vec4(\n                mix(0.9, 1.0, rand_n(self.shade, 1)), \n                mix(0.75, 0.8, rand_n(self.shade, 2)),\n                mix(0.5, 0.6, rand_n(self.shade, 3)), 1.0) * mix(0.7, 1.0, self.shade);\n            return;\n        } break;\n        \n        case WATER:\n        {\n            frag_color = vec4(\n                mix(0.0, 0.0, rand_n(self.shade, 1)), \n                mix(0.5, 0.2, rand_n(self.shade, 2)),\n                mix(0.9, 0.8, rand_n(self.shade, 3)), 1.0) * mix(0.7, 1.0, self.shade);\n            return;\n        } break;\n        \n        case WALL:\n        {\n            frag_color = vec4(\n                mix(0.3, 0.4, rand_n(self.shade, 1)), \n                mix(0.3, 0.4, rand_n(self.shade, 2)),\n                mix(0.3, 0.4, rand_n(self.shade, 3)), 1.0) * mix(0.7, 1.0, self.shade);\n            return;\n        } break;\n        \n        case AIR:\n        {\n            frag_color = vec4(0.6, 0.8, 1.0, 1.0);\n            return;\n        }\n    }\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// SETTINGS\nconst float scale        = 4.0;\nconst float brush_radius = 40.0;\n\n// COMMON\n#ifndef HW_PERFORMANCE\nuniform vec3      iResolution;\nuniform sampler2D iChannel0;\nuniform float     iTime;\nuniform int       iFrame;\n#endif\n\nint seed;\n\nfloat rand()\n{\n    int n = (seed++ << 13) ^ seed;\n    return float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483647.0;\n}\n\n#define INIT_SEED() \\\n    seed = int(iTime * frag_coord.x + frag_coord.y * iResolution.x); \\\n    seed = int(rand() * 2147483647.0) + iFrame;\n\nconst int AIR  = 0;\nconst int SAND = 1;\nconst int WALL = 2;\nconst int WATER = 3;\n\nstruct Particle\n{\n    int   type;\n    bool  has_moved_this_frame;\n    float shade;\n};\n\n#define IN_BOUNDS(coord) (0 <= (coord).x && (coord).x < int(iResolution.x / scale) && 0 <= (coord).y && (coord).y < int(iResolution.y / scale))\n#define NOT_IN_BOUNDS(coord) ((coord.x) < 0 || int(iResolution.x / scale) <= (coord.x) || (coord.y) < 0 || int(iResolution.y / scale) <= (coord.y))\n\n\nParticle particle_at(ivec2 coord)\n{\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return Particle(WALL, false, 0.0);\n    }\n    \n    vec4 data = texelFetch(iChannel0, coord, 0);\n    return Particle(\n        int(data.x),\n        bool(data.y),\n        data.z\n    );\n}\n\nvec4 to_vec4(Particle particle)\n{\n    return vec4(\n        float(particle.type),\n        float(particle.has_moved_this_frame),\n        particle.shade,\n        0.0\n    );\n}", "buffer_a_code": "float distance_to_line(vec2 a, vec2 b, vec2 p)\n{\n    // from iq: https://www.youtube.com/watch?v=PMltMdi1Wzg\n    float h = clamp(dot(p - a, b - a) / dot(b - a, b - a), 0.0, 1.0);\n    return length(p - mix(a, b, h));\n}\n\nconst float KEY_SPACE = 32.0;\nconst float KEY_LEFT_SHIFT = 16.0;\nconst float KEY_LEFT_CONTROL = 17.0;\n\n\nbool key_pressed(float key_code)\n{\n    return texture(iChannel2, vec2((key_code + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord);\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return;\n    }\n    \n    INIT_SEED();\n    \n    vec4 pMouse = texelFetch(iChannel1, ivec2(0, 0), 0);\n    \n    if (pMouse.z > 0.0)\n    {\n        if (iMouse.z > 0.0 && distance_to_line(pMouse.xy / scale, iMouse.xy / scale, vec2(coord)) < brush_radius)\n        {\n            frag_color = to_vec4(Particle(\n                (key_pressed(KEY_SPACE) ? AIR : key_pressed(KEY_LEFT_SHIFT) ? (key_pressed(KEY_LEFT_CONTROL) ? WATER:WALL) : SAND), \n                true, mix(0.7, 1.0, rand())\n            ));\n            return;\n        }\n    }\n    else\n    {\n        if (iMouse.z > 0.0 && distance(vec2(coord), iMouse.xy / scale) < brush_radius)\n        {\n            frag_color = to_vec4(Particle(\n                (key_pressed(KEY_SPACE) ? AIR : key_pressed(KEY_LEFT_SHIFT) ? WALL : SAND), \n                true, mix(0.7, 1.0, rand())\n            ));\n            return;\n        }\n    }\n    \n    Particle self = particle_at(coord);\n    \n    if(rand()>0.1)\n    \n    switch (self.type)\n    {\n        case WATER:\n        {\n            Particle below = particle_at(coord + ivec2(0, -1));\n            \n            if (below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n        } break;\n        \n        case SAND:\n        {\n            Particle below = particle_at(coord + ivec2(0, -1));\n            \n            if (below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n            if (below.type == WATER)\n            {\n                frag_color = to_vec4(Particle(WATER, true, 0.0));\n                return;\n            }\n            \n        } break;\n        \n        case AIR:\n        {\n            Particle above = particle_at(coord + ivec2(0, 1));\n            \n            if (above.type == SAND)\n            {\n                above.has_moved_this_frame = true;\n                frag_color = to_vec4(above);\n                return;\n            }\n            if (above.type == WATER)\n            {\n                above.has_moved_this_frame = true;\n                frag_color = to_vec4(above);\n                return;\n            }\n        } break;\n    }\n    \n    frag_color = to_vec4(Particle(self.type, false, self.shade));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord);\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return;\n    }\n    \n    Particle self = particle_at(coord);\n    \n    if (self.has_moved_this_frame)\n    {\n        frag_color = to_vec4(self);\n        return;\n    }\n    \n    INIT_SEED();\n    \n    int dir = int(rand() < 0.5) * 2 - 1;\n  \n    //if(rand()>0.5)\n    if(false)switch (self.type)\n    {\n        case WATER:\n        {\n            Particle below = particle_at(coord + ivec2(dir, -1));\n            \n            if (!below.has_moved_this_frame && below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n        } break;\n        \n        case SAND:\n        {\n            Particle below = particle_at(coord + ivec2(dir, -1));\n            \n            if (!below.has_moved_this_frame && below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n            if (!below.has_moved_this_frame && below.type == WATER)\n            {\n                frag_color = to_vec4(Particle(WATER, true, 0.0));\n                return;\n            }\n        } break;\n        \n        case AIR:\n        {\n            Particle above = particle_at(coord + ivec2(-dir, 1));\n            \n            if (!above.has_moved_this_frame){\n                if(above.type == SAND)\n                {\n                    above.has_moved_this_frame = true;\n                    frag_color = to_vec4(above);\n                    return;\n                }\n                if(above.type == WATER)\n                {\n                    above.has_moved_this_frame = true;\n                    frag_color = to_vec4(above);\n                    return;\n                }\n            }\n        } break;\n    }\n    \n    frag_color = to_vec4(self);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord);\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return;\n    }\n    \n    Particle self = particle_at(coord);\n    \n    if (self.has_moved_this_frame)\n    {\n        frag_color = to_vec4(self);\n        return;\n    }\n    \n    INIT_SEED();\n    rand();\n    \n    int dir = int(rand() >= 0.5) * 2 - 1;\n\n    //if(rand()>0.5)\n    switch (self.type)\n    {\n        case WATER:\n        {\n            Particle below = particle_at(coord + ivec2(dir, -1));\n               \n            if (!below.has_moved_this_frame && below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n            \n            Particle side = particle_at(coord + ivec2(-dir, 0));\n            if (!side.has_moved_this_frame && side.type == AIR)\n            {\n                side.has_moved_this_frame = true;\n                frag_color = to_vec4(side);\n                return;\n            }\n            \n        } break;\n        \n        case SAND:\n        {\n            Particle below = particle_at(coord + ivec2(dir, -1));\n            \n            if (!below.has_moved_this_frame && below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n            \n            if (!below.has_moved_this_frame && below.type == WATER)\n            {\n                frag_color = to_vec4(Particle(WATER,true, 0.0));\n                return;\n            }\n        } break;\n        \n        case AIR:\n        {\n            Particle above = particle_at(coord + ivec2(-dir, 1));\n            \n            if (!above.has_moved_this_frame && above.type == SAND)\n            {\n                above.has_moved_this_frame = true;\n                frag_color = to_vec4(above);\n                return;\n            }\n            \n            Particle side = particle_at(coord + ivec2(-dir, 0));\n            if (!side.has_moved_this_frame && side.type == WATER)\n            {\n                side.has_moved_this_frame = true;\n                frag_color = to_vec4(side);\n                return;\n            }\n            \n        } break;\n    }\n    \n    frag_color = to_vec4(self);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Save off last mouse cursor coordinate so it can form a line with the next cursor position\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    if (frag_coord == vec2(0.5, 0.5))\n    {\n        frag_color = iMouse;\n    }\n    else\n    {\n        frag_color = vec4(0.0);\n    }\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2cDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 125], [127, 127, 184, 184, 1331]], "test": "untested"}
{"id": "fdSyzR", "name": "Livecoding NOLAB - GaitLyrique ", "author": "z0rg", "description": "Livecoding shader performed during \"montre moi ton code\" event at la Gait Lyrique in Paris 20 January 2021\nhttps://gaite-lyrique.net/en/event/no-lab-montre-moi-ton-code", "tags": ["livecoding", "live", "gaitelyrique", "nolab", "montremoitoncode"], "likes": 6, "viewed": 212, "published": 3, "date": "1643469324", "time_retrieved": "2024-07-30T17:06:31.144605", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.) \n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n\tfloat fov = (sin(iTime*.25)*.3+.5)*2.;\n\tvec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n\tvec3 u = normalize(cross(rd, r));\n\treturn normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n\tif (a.x < b.x)\n\t\treturn a;\n\treturn b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n\tvec3 l =abs(p)-s;\n\treturn max(l.x, max(l.y, l.z));\n}\n\nvec2 map(vec3 p)\n{\n\tvec2 acc = vec2(1000., -1.);\n\tp.xy *= r2d(p.z*.05*length(p.xy)*.2);\n\n\tvec3 pshape = p;\n\tfloat repay = 10.;\n\tfloat repa = 5.;\n\tfloat repz = 20.;\n\tfloat idz = floor((pshape.z+repz*.5)/repz);\n\tpshape.z = mod(pshape.z+iTime*20.+repz*.5, repz)-repz*.5;\n\tpshape.y = mod(pshape.y+repay*.5, repay)-repay*.5;\n\tpshape.x += (sin(iTime+pshape.y*2.)+iTime);\n\tpshape.x = mod(pshape.x+repa*.5,repa)-repa*.5;\n\t//pshape.xy *= r2d(-.1*sign(p.x)+idz+iTime*.5);\n\tfloat shape = mix(_cube(pshape, vec3(.3*(sin(iTime)*.2+.5), 1., .1)), \n\tlength(pshape)-.5, \n\tsin(idz+iTime*.2));\n\tacc = _min(acc, vec2(shape, 0.));\n\n\tvec3 pshape2 = p+vec3(0.,0.,iTime*13.);\n\tvec3 rep2 = vec3(5.);\n\tpshape2 = mod(pshape2+rep2*.5, rep2)-rep2*.5;\n\tfloat shape2 = _cube(pshape2, vec3(.1));\n\tacc = _min(acc, vec2(shape2, 0.));\n\n\treturn acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n\tvec2 e = vec2(0.01, 0.);\n\treturn normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n\taccCol = vec3(0.);\n\tvec3 p = ro;\n\tfor (int i =0 ; i < 64; ++i)\n\t{\n\t\tvec2 res = map(p);\n\t\tif (res.x < 0.01)\n\t\t\treturn vec3(res.x, distance(p, ro), res.y);\n\t\taccCol += vec3(1., .2, .5*(sin(p.z*10.)*.5+.5)).zyx*(1.-sat(res.x/1.5))*.02;\n\t\tp+=rd*res.x;\n\t}\n\treturn vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n\tvec3 col = vec3(0.);\n\n\t\n\tvec3 ro = vec3(1.,sin(iTime),-15.);\n\tvec3 ta = vec3(0.,sin(iTime*.0125)*14.,0.);\n\tvec3 rd = normalize(ta-ro);\n\n\trd = getCam(rd, uv);\n\tvec3 res = trace(ro, rd, 128);\n\tif (res.y > 0.)\n\t{\n\t\tvec3 p = ro+rd*res.y;\n\t\tvec3 n = getNorm(p, res.x);\n\t\tcol = n*.5+.5;\n\t\tcol = vec3(0.8,0.4,0.3)*(1.-sat(res.y/30.));\n\t}\n\tcol += accCol;\n\treturn col;\n}\nfloat _sqr(vec2 uv, vec2 s)\n{\n\tvec2 l = abs(uv)-s;\n\treturn max(l.x, l.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n\tvec2 ouv = uv;\n\n\tuv -= vec2(.0);\n\tfloat a = atan(uv.y, uv.x);\n\tfloat stp = 3.14159265*2./(3.+mod(floor(iTime*.5), 5.));\n\tfloat b = mod(a+stp*.5,stp)-stp*.5;\n\tuv = vec2(sin(b), cos(b))*length(uv);\n\n\n\tvec3 col = rdr(uv);\n\n\tvec2 coords = mix(uv, ouv, sin(iTime))+vec2(iTime*.1,0.)*.1;\n\tfloat rep = .3;\n\tcoords.x = mod(coords.x+rep*.5, rep)-rep*.5;\nfloat shape = _sqr(coords, vec2(.05,.2));\ncol = mix(col, col.zxy, 1.-sat(shape*400.));\ncol = pow(col, vec3(1.));\ncol.xy *= r2d(iTime*1.5);\ncol.xz *= r2d(-iTime*1.25);\n\tfragColor = vec4(col*5., 1.0);\n\t//gl_FragColor = vec4(gl_FragCoord.xy / iResolution, cos(iTime), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSyzR.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[431, 431, 450, 450, 507], [509, 509, 540, 540, 708], [710, 710, 737, 737, 778], [780, 780, 809, 809, 863], [865, 865, 883, 883, 1681], [1683, 1683, 1714, 1714, 1823], [1837, 1837, 1878, 1878, 2151], [2153, 2153, 2172, 2172, 2535], [2536, 2536, 2565, 2565, 2611], [2612, 2612, 2669, 2669, 3348]], "test": "untested"}
{"id": "7djcWR", "name": "Creeping Waves", "author": "thesage1014", "description": "A simple experiment with using a buffer. Initially I was experimenting with game of life from the yt video https://www.youtube.com/watch?v=xh61Ol2X4GA", "tags": ["buffer"], "likes": 20, "viewed": 407, "published": 3, "date": "1643452812", "time_retrieved": "2024-07-30T17:06:31.978375", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col =  texture(iChannel0,uv).rgb;\n    \n    // Output to screen\n    col.r /= 2.; // value data stored in r, lighting in gb\n    col.r += col.b;\n    fragColor = vec4(col.brr,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SCANSIZE 2\nfloat DECAY = .9;\n// Adjust the decay if you adjust the scansize. Try 1 and .925. There are lots of wild effects with different\n// values\n//\n// It's funny how at scansize 1, there is this stable pattern where a black pixel will be surrounded by lit pixels.\n// Each frame, a given pixel adds the direction of nearby brigtness, so if it's surrounded, it will stay dark\n// because I'm using the length of the scan vector to estimate the brightness, which is zero when it's surrounded.\n\nvec2 ScanNeighbors(ivec2 p) {\n    vec2 dir = vec2(0.);\n    for (int y=-SCANSIZE; y<=SCANSIZE; y++) {\n        for (int x=-SCANSIZE; x<=SCANSIZE; x++) {\n            if(x==0 && y==0) continue;\n            dir += vec2(x,y)*texelFetch(iChannel1, p+ivec2(x,y), 0).r;\n        }\n    }\n    // returns the average direction of the nearby brigtness\n    return (dir);\n}\nvec3 iterate(ivec2 ifrag) {\n   //float DECAY = .89+sin(iTime*.5)*.02; // animating decay\n\n    vec3 col = vec3(0.);\n   // if(ifrag.y == int(iResolution.y/2.+10.*sin(iTime*2.))){  // sweeping line\n   //     col.r = 0.;\n   // } else {\n        vec3 tc = vec3(texelFetch(iChannel1, ifrag, 0).rgb);\n        \n        \n        vec2 dir = ScanNeighbors(ifrag);\n        vec2 lightDir = normalize( (vec2(sin(iTime),cos(iTime))));\n        tc.bg = vec2(smoothstep(-3.,3.,dot(dir, lightDir)));\n        tc.r += smoothstep(0.,7.*float(SCANSIZE*SCANSIZE),length(dir));\n        tc.r *= DECAY;\n        tc.g = smoothstep(.8,1.,DECAY);\n        col = clamp(tc,0.,1.);\n    //}\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 ifrag = ivec2(fragCoord);\n    vec3 col = vec3(0);\n    \n    if(iFrame <10) {\n        col = texture(iChannel0, uv).rgb;\n    } else {\n        col = iterate(ifrag);\n    }\n    \n    fragColor = vec4(col,1.0);\n    \n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 368]], "test": "untested"}
{"id": "NsjcDh", "name": "sound waterfall", "author": "tomviolin", "description": "Sound as a waterfall", "tags": ["musicvisualization"], "likes": 3, "viewed": 361, "published": 3, "date": "1643436067", "time_retrieved": "2024-07-30T17:06:33.030562", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n     fragColor = texture(iChannel0,vec2(exp(uv.x*.68)-1.,1.0-sqrt(1.0-uv.y)));\n     \n }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}", "buffer_a_code": "#define speed 6.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (uv.y > (iResolution.y-speed)/iResolution.y) {\n\n\n\n        float sound=texture(iChannel0,vec2(uv.x,0.25)).r;\n\n        //float signal=abs(sound-(uv.y))<5./iResolution.y?0.5:0.0;\n\n\n\n         fragColor = vec4(hsv2rgb(vec3(uv.x*0.5,1.,sound*(uv.x+0.5))),1.0);\n     } else {\n         fragColor = texture(iChannel1, vec2(uv.x,uv.y+speed/iResolution.y));\n     }\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 236]], "test": "untested"}
{"id": "7dBcW1", "name": "VHS mishmash", "author": "isaacchurchill", "description": "Practicing writing code with more of a stream of consciousness way of doing things, part 4", "tags": ["2d", "simple", "streamofconsciousness"], "likes": 3, "viewed": 275, "published": 3, "date": "1643417059", "time_retrieved": "2024-07-30T17:06:33.919186", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    if (col.x > 0.05) { // occasional wipe of plain color gradient\n        col.y = 0.2 + 0.3 * sin(iTime * 3.14159265 * 0.1); // slow cyclical color change over time\n        float z = col.x; // funny bar patterns\n        for (int i = 0; i < int(z * 4.0); i++) { // repeat # of times depending on starting red channel value\n            if (uv.y > 0.4) // top half of screen\n                col.xyz = mod(col.yzx, mod(iTime, uv.y + 3.0));\n            else // bottom half\n                col.xyz = mod(col.xzy, mod(iTime, uv.x + 3.0));\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 842]], "test": "untested"}
{"id": "ssByW1", "name": "Holey Thingy", "author": "SnoopethDuckDuck", "description": "lots of unnecessary code, artifacts at 0,y,0 top and bottom, idk how to remove", "tags": ["template"], "likes": 4, "viewed": 251, "published": 3, "date": "1643412452", "time_retrieved": "2024-07-30T17:06:34.816786", "image_code": "#define STEPS 512\n#define MAXDIST 128.\n#define SURFDIST 0.001\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat box(vec3 pos, vec3 size)\n{\n    vec3 q = abs(pos) - size;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\nfloat scene(vec3 p)\n{\n    p.xz *= Rot(-0.25 * iTime);\n    //p.xz *= Rot(3. * atan(p.x, p.z));\n    float d = box(p,vec3(1)) - 0.6;\n    d += 0.1 * sin(-2. * iTime + atan(p.x, p.z)*7. + p.y * 5.);\n    return 0.5 * d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    float d = scene(p);\n    return normalize(d - vec3(scene(p - e.xyy),scene(p - e.yxy),scene(p - e.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd, float z)\n{\n    float d = 0.;\n    vec3 p;\n    \n    for(int i = 0; i < STEPS; i++)\n    {\n        p = ro + rd * d;\n        float s = scene(p);\n        s *= z; d += s;\n        if(d > MAXDIST || s < SURFDIST) break;\n    }\n    \n    return d;\n}\n\nvec3 ray(vec3 p, vec3 l, vec2 uv, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 pixel(vec3 p, vec3 rd)\n{\n    vec3 n = normal(p);\n    float diffs = dot(n,-rd);\n    float diff = max(diffs,0.);\n    float fres = pow(1. - abs(diffs),4.);\n    float spec = pow(max(dot(reflect(-rd,n),rd),0.),40.);\n    return vec3(1) * (diff + fres) + spec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    float r = 5.;\n    float time = 0.1 * iTime;\n    vec3 ro = vec3(r * cos(time),.2 * cos(3. * iTime), r * sin(time));\n    vec3 rd = ray(ro,vec3(0),uv, 1.);\n    \n    \n    //Normal raymarching\n    float d0 = march(ro,rd, 1.);\n    vec3 p = ro + rd * d0;\n    vec3 n = normal(p);\n    \n    //Raymarch again, through the inside of the object, using inverted distance field\n    float d1 = march(p - n*0.01, rd, -1.); // -4.\n    \n    float dens = 40.;\n    float foff = 1.;\n    \n    float thick = 0.;//clamp(d1 / dens, 0.,1.);\n    //thick *= 0.5 + 0.5 * thc(4., 4. * n.y * pi);\n    \n    //foff = 0.5 + 0.5 * cos(n.y * pi);\n    //float blend = pow(thick, foff);\n    \n    float v = clamp(0.4 * d1, 0., 1.);\n    if (d0 < MAXDIST)\n        v = 1.-v;\n    \n   // v = smoothstep(0., 1., v);\n    vec3 e = vec3(v);\n    col =  pal(0.225 + 0.5 * n.y, e, e, e,  vec3(0.,0.33,0.66));\n    \n    //vec3 bg = vec3(col) + dot(rd, rd) * 0.28;\n    \n    //col = vec3(1.);\n    \n    // somehow adds \"lighting\", wasnt thinking when I wrote this\n    //col = mix(col, mix(vec3(0.), vec3(dot(rd,rd)), blend), blend);\n\n    //--------------------------------\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssByW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 146, 146, 242], [244, 244, 265, 265, 459], [461, 461, 482, 482, 620], [622, 622, 662, 662, 889], [891, 891, 935, 935, 1126], [1128, 1128, 1157, 1157, 1388], [1391, 1391, 1448, 1448, 2696]], "test": "untested"}
{"id": "7sScWh", "name": "Sea of Modulation", "author": "ruudhelderman", "description": "Just playing around with frequency modulation on a 2D surface. Inspired by old-school plasma effects.", "tags": ["plasma"], "likes": 2, "viewed": 262, "published": 3, "date": "1643407677", "time_retrieved": "2024-07-30T17:06:35.743309", "image_code": "const float time_offset = 0.0;\nconst float speed = 0.2;\nconst float horizon = 0.51;\nconst float elevation = 30.0;\nconst float contrast = 15.0;\nconst float fog = 0.5;\nconst float modulation1 = 1.2;\nconst float modulation2 = 2.0;\n\nmat2 rotate(float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;    // coordinates [-0.5, +0.5]\n    uv *= elevation / (horizon - uv.y);            // simple 3D projection\n    float t = (iTime + time_offset) * speed;       // time\n    \n    vec2 m = t + sin(uv + sin(uv * rotate(t) * modulation1));\n    float f = sin(length(m) * modulation2) * contrast / (elevation + uv.y * fog);\n\n    fragColor = vec4(0.5 + f, 0.0, 0.5 - f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sScWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 251, 251, 327], [329, 329, 386, 386, 801]], "test": "untested"}
{"id": "ssScWh", "name": "Volumetric Thingy", "author": "SnoopethDuckDuck", "description": "Messing with ideas from Drakyen (forked), and oneshade: https://www.shadertoy.com/view/wtVyRG\n\ncode is very very messy\n\n", "tags": ["template"], "likes": 7, "viewed": 456, "published": 3, "date": "1643406021", "time_retrieved": "2024-07-30T17:06:36.588050", "image_code": "#define STEPS 400\n#define MAXDIST 10.\n#define SURFDIST 0.01\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159\n\nvec3 pModSpherical(vec3 p, in vec2 r) {\n    vec2 a = pi / r;\n    float sc = 2.5 + thc(4., 8. * length(p) + iTime);\n    \n    float axz = mod(atan(p.z, p.x) + a.x, 2. * a.x) - a.x;\n    p.xz = length(p.xz) * vec2(thc(sc, axz), ths(sc, axz));\n    \n    float axy = mod(atan(p.y, p.x) + a.y, 2. * a.y) - a.y;\n    p.xy = length(p.xy) * vec2(thc(sc, axy), ths(sc, axy));\n    \n    return p;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    vec3 q = abs(pos) - size;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\nfloat scene(vec3 p)\n{\n\n    float time = p.y + 0.5 * iTime;\n    p.xz *= rot(time);\n    //p.yz *= rot(time);\n\n    p = pModSpherical(p, vec2(20. + 10. * thc(2., -time)));//vec2(18. + 8. * thc(2., time), \n                            //  18. + 8. * ths(2., time)));\n    //vec3 q = abs(p - vec3(2.0, 0.0, 0.0)) - 0.1;\n    //float boxes = max(q.x, max(q.y, q.z));\n    \n    float d = length(p - vec3(1.,0,0)) - 0.32;\n    \n   // p.xz *= rot(0.45 * iTime);\n    //float d = box(p, vec3(1.)) - 0.2; \n    \n    return 0.4 * d;\n}\n\nfloat scene2(vec3 p) {\n   // return box(p, vec3(0.4)) - 1.;\n    return length(p) - 1.;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    float d = scene(p);\n    return normalize(d - vec3(scene(p - e.xyy),scene(p - e.yxy),scene(p - e.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd, float z)\n{\n    float d = 0.;\n    vec3 p;\n    \n    for(int i = 0; i < STEPS; i++)\n    {\n        p = ro + rd * d;\n        float s = scene(p);\n        s *= z; d += s;\n        if(d > MAXDIST || s < SURFDIST) break;\n    }\n    \n    return d;\n}\n\nvec3 normal2(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    float d = scene2(p);\n    return normalize(d - vec3(scene2(p - e.xyy),scene2(p - e.yxy),scene2(p - e.yyx)));\n}\n\nfloat march2(vec3 ro, vec3 rd, float z) {\n    float d = 0.;\n    vec3 p;\n    \n    for(int i = 0; i < STEPS; i++) {\n        p = ro + rd * d;\n        float s = scene2(p);\n        s *= z; d += s;\n        if(d > MAXDIST || s < SURFDIST) break;\n    }\n    \n    return d;\n}\n\nvec3 ray(vec3 p, vec3 l, vec2 uv, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 pixel(vec3 p, vec3 rd)\n{\n    vec3 n = normal(p);\n    float diffs = dot(n,-rd);\n    float diff = max(diffs,0.);\n    float fres = pow(1. - abs(diffs),4.);\n    float spec = pow(max(dot(reflect(-rd,n),rd),0.),40.);\n    return vec3(1) * (diff + fres) + spec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = ray(ro,vec3(0),uv, 1.7);\n    \n    float d0 = march(ro,rd, 1.);\n    vec3 p = ro + rd * d0;\n    vec3 n = normal(p);\n    \n    // this is very scuffed\n    float d1 = march2(0.2 * p + n*0.01, rd, -1.);\n    \n    float dens = 1.5;\n    float foff = 0.5;\n    \n    float thick = clamp(d1 / dens, 0.,1.);\n    thick = smoothstep(0., 1., thick);\n    //thick *= thick;\n    //thick = pow(4. * thick * (1.- thick), 2.);\n    \n    float blend = pow(thick, foff);\n    \n    vec3 background = vec3(1.) + dot(rd,rd) * 2.8;\n    \n    col = vec3(0.4);\n    vec3 e = vec3(1.);\n   // col /= pal(0.2 * iTime - length(p), e, e, e, vec3(0.,0.33,0.66));\n    col = pal(0.32, e, e, e, vec3(0.,0.33,0.66));\n    col = mix(background, col, blend);\n\n    //--------------------------------\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\nfloat h21 (vec2 a, float sc) {\n    a = mod(a, sc);\n    return fract(sin(dot(a, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssScWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 170, 170, 514], [516, 516, 548, 548, 644], [646, 646, 667, 667, 1160], [1162, 1162, 1184, 1221, 1250], [1252, 1252, 1273, 1273, 1411], [1413, 1413, 1453, 1453, 1680], [1682, 1682, 1704, 1704, 1846], [1848, 1848, 1889, 1889, 2113], [2115, 2115, 2159, 2159, 2350], [2352, 2352, 2381, 2381, 2612], [2615, 2615, 2672, 2672, 3593]], "test": "untested"}
{"id": "7sBcDh", "name": "Jean Claude Van Damme ascends", "author": "tungster24", "description": "I don't know where, call 911...", "tags": ["jeanclaudevandamme"], "likes": 6, "viewed": 278, "published": 3, "date": "1643405366", "time_retrieved": "2024-07-30T17:06:37.454733", "image_code": "#define tex(a) texture(iChannel0,a).rgb\n//he is my god, jean claude van damme save the queen\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    vec2 v = (P/iResolution.xy);\n    vec4 c = texture(iChannel0,v);\n    float x,y,i;\n    for (i = 10.;i < 100.;i++) {\n        x += distance(tex(vec2(v.x-1./i,v.y)),tex(vec2(v.x+1./i,v.y)));\n        y += distance(tex(vec2(v.x,v.y-1./i)),tex(vec2(v.x,v.y+1./i)));\n    }\n    c += vec4(x,y,x+y,1.)/i;\n    C = vec4(c);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 93, 134, 134, 450]], "test": "untested"}
{"id": "7sjcWR", "name": "Angle Bisection Construction", "author": "oneshade", "description": "Animation of a ruler and straightedge construction to bisect an angle.", "tags": ["geometry", "angle", "bisection", "compass", "construction", "straightedge"], "likes": 30, "viewed": 258, "published": 3, "date": "1643382680", "time_retrieved": "2024-07-30T17:06:38.226669", "image_code": "#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\n\n// Transforms\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nvoid sketchArc(in vec2 uv, in float unit, inout vec3 color, in float radius, in float aperture, in float stop) {\n    if (stop < 0.0) uv.y = -uv.y, stop = -stop;\n    float theta = atan(uv.y, uv.x);\n    float alpha = smoothstep(aperture, aperture - 0.5, abs(theta - aperture));\n    alpha *= step(theta, stop);\n    drawSDF(abs(length(uv) - radius) - 0.001, vec4(vec3(0.0), alpha));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n    float time = 2.0 * iTime; // Speed up the animation\n\n    // Draw an arrow and mirror it on the left\n    vec2 arrowUv = vec2(abs(uv.x), uv.y);\n    drawSDF(sdLine(arrowUv, vec2(0.0, -1.0), vec2(1.0, 1.0)), vec4(vec3(0.0), 1.0));\n    drawSDF(sdLine(arrowUv, vec2(1.0, 1.0), vec2(1.05, 0.75)), vec4(vec3(0.0), 1.0));\n    drawSDF(sdLine(arrowUv, vec2(1.0, 1.0), vec2(0.77, 0.875)), vec4(vec3(0.0), 1.0));\n\n    // Draw an arc between the rays\n    vec2 compassUv = (uv - vec2(0.0, -1.0)) * Rotate2D(0.6);\n    float an1 = clamp(time - 1.0, 0.0, 4.0) / 2.0;\n    sketchArc(compassUv, unit, color, 1.5, 1.0, an1);\n    compassUv *= Rotate2D(an1);\n\n    // Move to left intersection\n    float move1 = clamp(time - 6.0, 0.0, 4.0) / 4.0;\n    compassUv -= vec2(-1.0, 2.0) / sqrt(5.0) * Rotate2D(2.6) * 1.5 * move1;\n\n    // Draw an arc at the left intersection\n    float an2 = -clamp(time - 11.0, 0.0, 4.0) / 2.0;\n    sketchArc(compassUv, unit, color, 1.5, 1.0, an2);\n    compassUv *= Rotate2D(an2);\n\n    // Move to right intersection\n    float move2 = clamp(time - 16.0, 0.0, 4.0) / 4.0;\n    compassUv -= vec2(2.0 / sqrt(5.0), 0.0) * Rotate2D(0.6) * 1.5 * move2;\n\n    // Draw an arc at the right intersection\n    float an3 = clamp(time - 21.0, 0.0, 4.0) / 2.0;\n    sketchArc(compassUv, unit, color, 1.5, 1.0, an3);\n    compassUv *= Rotate2D(an3);\n\n    // Turn to the intersection between the arcs\n    float an4 = -clamp(time - 26.0, 0.0, 2.0) / 2.0 * 0.55;\n    compassUv *= Rotate2D(an4);\n\n    // Trace a segment to the angle vertex\n    float move3 = clamp(time - 36.0, 0.0, 4.0) / 4.0;\n    compassUv -= vec2(0.0, -2.68) * Rotate2D(2.6 - 0.55) * move3;\n    if (time > 31.0) drawSDF(sdLine(uv, vec2(0.0, 1.67), vec2(0.0, 1.67 - move3 * 2.65)), vec4(vec3(0.0), 1.0));\n\n    // Move to the side\n    float move4 = clamp(time - 46.0, 0.0, 4.0) / 4.0;\n    compassUv -= vec2(2.15, 1.65) * Rotate2D(2.6 - 0.55) * move4;\n\n    // Compass legs\n    compassUv.x -= 0.75;\n    drawSDF(sdBox(compassUv, vec2(0.75, 0.05)), vec4(vec3(0.4), 1.0));\n\n    // Compass handle\n    drawSDF(length(compassUv) - 0.1, vec4(0.0, 0.0, 1.0, 1.0));\n    drawSDF(length(compassUv) - 0.05, vec4(vec3(0.0), 1.0));\n\n    // Compass point\n    drawSDF(length(compassUv - vec2(-0.75, 0.0)) - 0.05, vec4(vec3(0.0), 1.0));\n\n    // Compass pencil\n    compassUv.x -= 0.75;\n    drawSDF(length(compassUv) - 0.075, vec4(1.0, 0.8, 0.0, 1.0));\n    drawSDF(length(compassUv) - 0.025, vec4(vec3(0.0), 1.0));\n\n    // Straightedge\n    vec2 straightEdgeUv = uv;\n    float move5 = clamp(7.0 - abs(time - 38.0), 0.0, 4.0) / 4.0; // Move in, pause, move out\n    straightEdgeUv -= vec2(2.15, 0.35) * move5;\n    drawSDF(sdBox(straightEdgeUv - vec2(-2.5, 0.0), vec2(0.25, 1.5)), vec4(0.8, 0.5, 0.0, 1.0));\n\n    // Vignette (kinda)\n    uv = 2.0 * (fragCoord / iResolution.xy - 0.5);\n    color -= 0.15 * pow(length(uv), 4.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 107, 134, 134, 206], [208, 216, 263, 263, 371], [373, 373, 408, 408, 488], [490, 490, 602, 602, 870], [872, 872, 927, 946, 3969]], "test": "untested"}
{"id": "fdSyDh", "name": "Wobbly hexes", "author": "JennySchub", "description": "I know this is very inefficient :) feel free to optimize", "tags": ["wobble", "hexagon"], "likes": 7, "viewed": 299, "published": 3, "date": "1643380797", "time_retrieved": "2024-07-30T17:06:39.083379", "image_code": "#define PI 3.14159265359\n\nvec3 colMap(float v) {\n\n\tv=mod(v, PI+1.3)-.8;\t\n    return vec3(\n\t\tsin(sin(v-.6)),\n\t\tsin(sin(v)),\n\t\tsin(sin(v+.6))\n\t);\n\n} \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 realuv = (fragCoord/iResolution.xy - .5)*iResolution.xy/iResolution.xx*2.;\n    \n    float a = .1;\n    float sq3 = sqrt(3.);\n    float aM = 1./cos(PI/3.);\n    vec3 col = vec3(1.);\n    vec2 uv;\n    mat2 rot;\n    float tim = iTime * .3;\n    float sinus, cosinus,angle;\n    float count = (sin(iTime*.3)*.5+.53)*50.;\n    for(float i=0.; i<1.; i+=1./count){\n        angle=sin(i*.4*tim+tim)*PI;\n        sinus=sin(angle);\n        cosinus=cos(angle);\n        rot=mat2(cosinus, -sinus, sinus, cosinus);\n        uv=realuv*rot;\n        a=i;\n        col = vec3(\n            min(col.x, \n                (i+\n                    max(\n                        max(\n                            smoothstep(a,a+1./iResolution.y, abs(uv.y)),\n                            smoothstep(a*aM,a*aM+aM/iResolution.y, abs(uv.y+uv.x*sq3))\n                        ),\n                        smoothstep(a*aM,a*aM+aM/iResolution.y, abs(uv.y-uv.x*sq3))\n                    )\n                )\n            )        \n        );\n    }\n\n    // Output to screen\n    fragColor = vec4(colMap(col.x*(sin(iTime)*.5+1.)*2.+iTime).xzy,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 146], [148, 148, 205, 205, 1310]], "test": "untested"}
{"id": "7s2cDz", "name": "Additive Synthesis", "author": "Tech_", "description": "Playing around with sine waves ;D", "tags": ["additivesynthesis"], "likes": 5, "viewed": 262, "published": 3, "date": "1643375334", "time_retrieved": "2024-07-30T17:06:39.923133", "image_code": "#define ITERATIONS (int((sin(iTime) * 0.5 + 0.5) * 40.0) + 1)\n\nfloat pow2(float x) { return x * x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 3.0;\n\n    float saw = 0.0;\n    float square = 0.0;\n    float triangle = 0.0;\n    for (int i = 0; i < ITERATIONS; i++) \n    {\n        saw += sin(uv.x * 10.0 * float(i + 1)) / 8.0 / float(i + 1);\n        square += sin(uv.x * 10.0 * float(2 * i + 1)) / 8.0 / float(2 * i + 1);\n        triangle += sin(uv.x * 10.0 * float(2 * i + 1)) / 8.0 / pow2(float(2 * i + 1)) * (mod(float(i), 2.0) * 2.0 - 1.0);\n    }\n\n    // Time varying pixel color\n    vec3 col;\n    int cellID = int(floor(uv.y * 3.0));\n    float cellUv = fract(uv.y * 3.0);\n    \n    if      (cellID == 0) cellUv -= saw;\n    else if (cellID == 1) cellUv -= square;\n    else                  cellUv -= triangle;\n    \n    col += smoothstep(0.01, 0.005, abs(cellUv - 0.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2cDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 84, 84, 100], [102, 102, 159, 209, 1044]], "test": "untested"}
{"id": "fsjczw", "name": "basic shapes v1", "author": "ErinZ", "description": "basic shapes and motion blur", "tags": ["2d"], "likes": 3, "viewed": 344, "published": 3, "date": "1643354152", "time_retrieved": "2024-07-30T17:06:41.049124", "image_code": "#define BLUR 0.005\n\n//=============================================================================================\n//========================================SHAPES===============================================\n//=============================================================================================\n\n//  \nfloat circle( vec2 uv, vec2 o, float r, float blur){\n    float d = length(uv-o);\n    float c = smoothstep(r,r-blur,d);//AA\n    return c;\n}\n//1+ \nfloat lineVer(vec2 uv, vec2 p,float width, float blur){\nwidth/=2.;\nuv -= p;\nreturn smoothstep(-width-blur,-width,uv.x)*smoothstep(width+blur,width,uv.x);\n}\n//1+ \nfloat line(vec2 uv, vec2 p, float k, float width, float blur){\nwidth/=2.;\nuv -= p;\nfloat d = abs(k*uv.x-uv.y)/sqrt(k*k+1.);\nreturn smoothstep(-width-blur,-width,d)*smoothstep(width+blur,width,d);\n}\n//2 \nfloat line(vec2 uv, vec2 p1, vec2 p2, float width, float blur){\nwidth/=2.;blur/=2.;\nvec2 pa = uv-p1,ba = p2-p1;\nfloat h = dot(pa,ba)/dot(ba,ba);\nfloat d = length(pa-ba*h);\nreturn smoothstep(width+blur,width-blur,d);\n}\n//2 \nfloat segment(vec2 uv, vec2 p1, vec2 p2, float width, float blur){\nwidth/=2.;blur/=2.;\nvec2 pa = uv-p1,ba = p2-p1;\nfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\nfloat d = length(pa-ba*h);\nreturn smoothstep(width+blur,width-blur,d);\n}\n// a1a2 a1<a2 a1,a2[0,6.28]\nfloat arc(vec2 uv, vec2 o,float r,float a1,float a2, float width, float blur){\nuv -=o;\nwidth/=2.;blur/=2.;\nfloat ap =(uv.x>0.)?acos(uv.y/length(uv)):acos(-uv.y/length(uv))+3.14;//\nvec2 p1= vec2(sin(a1)*r,cos(a1)*r);\nvec2 p2= vec2(sin(a2)*r,cos(a2)*r);\nfloat d =(ap>a1&&ap<a2)?(abs(length(uv)-r)):\n                        min(length(uv-p1),length(uv-p2));\nreturn smoothstep(width+blur,width-blur,d);\n}\n//\nfloat triangle(vec2 uv,vec2 o,float a,float blur){\nuv -= o;\nuv.x = abs(uv.x)-a;\nconst float k = sqrt(3.);\nuv.y +=1./k*a;\nif(uv.x+k*uv.y >0.) uv=vec2(uv.x-k*uv.y,-k*uv.x-uv.y)/2.;\nuv.x -= clamp( uv.x, -2.0*a, 0.0 );\nfloat d = -length(uv)*sign(uv.y);\nreturn smoothstep(0.+blur,0.,d);\n}\n// \nfloat rectangle(vec2 uv,vec2 p1,vec2 p2,float blur){\nblur /= 2.;\nreturn smoothstep(p1.x-blur,p1.x+blur,uv.x)*\n       smoothstep(p2.x+blur,p2.x-blur,uv.x)*\n       smoothstep(p1.y+blur,p1.y-blur,uv.y)*\n       smoothstep(p2.y-blur,p2.y+blur,uv.y);\n}\n\n//=============================================================================================\n//======================================TRANSFORMATION=========================================\n//=============================================================================================\n\n// \nvec2 rotate(vec2 uv, vec2 p, float a){\nuv-=p;\nvec2 q;\nq.x = cos(a)*uv.x + sin(a)*uv.y;\nq.y = -sin(a)*uv.x + cos(a)*uv.y; \nq+=p;\nreturn q;\n}\n//\nvec2 bevel(vec2 p, float x,float y){\n    vec2 q;\n    q.x = p.x + p.y*x;\n    q.y = p.y +p.x*y;\n    return q;\n}\n//=============================================================================================\n//======================================FUNCTIONS==============================================\n//=============================================================================================\n\n//\nvec3 coordSystem(vec2 p){\n    vec3 col = vec3(0);\n    float c;\n    c =lineVer(p, vec2(0.,0.),0.003,BLUR);//y\n    c +=line(p, vec2(0.,0.), 0.,0.003,BLUR);//x\n    c +=lineVer(p, vec2(1.,0.),0.003,BLUR)*.3;//x=1\n    c +=lineVer(p, vec2(-1.,0.),0.003,BLUR)*.3;//x=-1\n    col +=c*vec3(.5,.8,.9);\n    col += vec3(circle(p,vec2(0.,0.),0.02,BLUR));//OriginalPt\n    col = mix(col,vec3(1,0.16,0.6),vec3(circle(p,vec2(0.,0.),0.015,BLUR)));\n    return col;\n}\nvec3 animate(vec2 p,float time){\n    vec3 col = vec3(0,0,1);\n       \n    float tt = mod(time,2.)/2.;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = ss*.8*sin(tt*6.28*3.0 + p.y*0.5)*exp(-tt*4.);\n    col += circle(p, vec2(-.5, ss*sin(time * 12.0) * 0.7 +.2), 0.1,BLUR);\n    col += circle(p, vec2(.5, ss*sin(time * 12.0) * 0.7), 0.1,BLUR);\n    \n    p = bevel(p,ss*(p.y+0.5),0.);\n\n    col += rectangle(p,vec2(-.3,.5),vec2(.3,-.5),BLUR);\n    col -= circle(p,vec2(-.06,.3),.05,BLUR*2.)*2.;\n    col -= circle(p,vec2(.06,.3),.05,BLUR*2.)*2.;\n    col -= segment(p,vec2(-.05,.3),vec2(.05,.3),.01,BLUR*2.)*2.;\n    col = clamp(col,0.,1.);\n    return col;\n}\n//=============================================================================================\n//========================================MAIN=================================================\n//=============================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //BackGround\n    vec3 col = vec3(0.);\n    //col +=coordSystem(p);\n    \n    //motionblur\n    float amount = 32.;\n    float timescale = .1;\n    vec3 blurcol=vec3(0.);\n    \n\tfor(int i = 0; i < int(amount); i++)\n\t{\n    blurcol += animate(p, iTime - float(i)*timescale/amount)/amount;\n\t}\n    col += blurcol;\n    \n    /*\n    vec2 p1 = vec2(-.5,0.);\n    vec2 p2 = vec2(.5,0.5);\n    vec2 p3 = vec2(.5,-0.5);\n    col +=lineVer(p, p1,0.0001,0.003);\n    col +=line(p, p1, 1.,0.0001,0.003);\n    col +=segment(p, p2,p3,0.2,0.005)*0.5;\n    col += vec3(arc(p, p1,0.3,.785,3.925,0.15,0.005));\n\n    //shapemask pts\n    float ptmask = circle(p,p1,0.02,0.005);\n    ptmask += circle(p,p2,0.02,0.005);\n    ptmask += circle(p,p3,0.02,0.005);\n    col = mix(col,vec3(1.),ptmask);\n    float ptmask2 = circle(p,p1,0.015,0.005);\n    ptmask2 += circle(p,p2,0.015,0.005);\n    ptmask2 += circle(p,p3,0.015,0.005);\n    col = mix(col,vec3(1,0.16,0.6),ptmask2);\n    */\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 332, 384, 384, 470], [471, 492, 547, 547, 647], [648, 669, 731, 731, 866], [867, 881, 944, 944, 1098], [1099, 1113, 1179, 1179, 1346], [1347, 1396, 1474, 1474, 1805], [1806, 1824, 1874, 1874, 2107], [2108, 2136, 2188, 2188, 2382], [2673, 2704, 2742, 2742, 2843], [2844, 2853, 2889, 2889, 2962], [3252, 3270, 3295, 3295, 3716], [3717, 3717, 3749, 3749, 4360], [4650, 4650, 4707, 4707, 5844]], "test": "untested"}
{"id": "7lcGDf", "name": "Fork Fork Fork  gchipunov 818", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation"], "likes": 1, "viewed": 216, "published": 3, "date": "1643349332", "time_retrieved": "2024-07-30T17:06:41.895859", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n\n  vec2 uv;\n  uv.x = 0.2*floor(iTime) + (r1-r2)*0.55;\n  uv.y = asin(sin(a1-a2))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-55.0*r1) + exp(-55.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.03,1.0,sin(228.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(fract(sqrt (col+w) +(col+w) / 1.1) ,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.5,0.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 783]], "test": "untested"}
{"id": "flc3Df", "name": "Fork Fork Fork  gchipunov 904", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 167, "published": 3, "date": "1643349321", "time_retrieved": "2024-07-30T17:06:42.710680", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/2.5 +col/ 5.0 +col2;//;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 612]], "test": "untested"}
{"id": "Ntc3Df", "name": "Fork Fork Fork  gchipunov 870", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 164, "published": 3, "date": "1643349310", "time_retrieved": "2024-07-30T17:06:43.475635", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/2.5 +col;//;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 601]], "test": "untested"}
{"id": "3tXfWN", "name": "zubnid alpha visualizer", "author": "gchipunov", "description": "123", "tags": ["test", "music", "alpha"], "likes": 0, "viewed": 190, "published": 3, "date": "1643349295", "time_retrieved": "2024-07-30T17:06:44.385203", "image_code": "#define bars 70.0\t\t\t\t// How many buckets to divide spectrum into\n#define barSize 1.0 / bars\t\t// Constant to avoid division in main loop\n#define barGap 0.1 * barSize\t// 0.1 represents gap on both sides, so a bar is\n#define sampleSize 2.0\t\t\t// How accurately to sample spectrum, must be a factor of 1.0\n#define PI 3.14159265359\n#define circleRadius 0.4;\n\n// used\n// https://www.shadertoy.com/view/XdX3z2\n\n// atan2 en lerp:\n// http://http.developer.nvidia.com/Cg/index_stdlib.html\n\n// colors\n// https://color.adobe.com/nl/Mijn-Kuler-thema-color-theme-4149936/?showPublished=true\n\n#define c1 vec4(0.24)\t\t\t\t// grey\n//#define c2 vec4(.71,.32,.36,1.0)\t// red\n#define c2 vec4(.71,.11,.11,1.0)\t// red\n//#define c3 vec4(.91,.64, .0,1.0)\t// yello\n#define c3 vec4(1.00,1.00, 1.00,1.0)\t// yello\n//#define c4 vec4(.27,.48,.44,1.0)\t// green\n#define c4 vec4(.21,.40,.91,1.0)\t// green\n#define c5 vec4(.21,.40,.91,1.0)\t// blue\n\n#define colorOnCenter c3\n#define colorOff c5\n#define colorOn c2\n    \n\nfloat lerp(float a, float b, float t)\n{\n  return a + t*(b-a);\n}\n\nvec4 lerp(vec4 a, vec4 b, float t)\n{\n  return a + t*(b-a);\n}\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.0) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.0) ? -t3 : t3;\n\n  return t3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / vec2(iResolution.y,iResolution.y);\n    \n    // calculate stuff\n    vec2 center = vec2((0.5*(iResolution.x/iResolution.y)),0.5);\n    float deltaYFromCenter = center.y - uv.y;\n    float deltaXFromCenter = center.x - uv.x;\n    \n    // create music map red (angle center)\n\tvec4 musicMap;\n    float angleFromCenter = atan2(deltaYFromCenter,deltaXFromCenter);  \n    musicMap.r = (angleFromCenter+PI)/(PI*2.0);\n    \n    // create music map blue (dist center)\n    float distFromCenter = sqrt((deltaYFromCenter*deltaYFromCenter)+(deltaXFromCenter*deltaXFromCenter));\n    float circleFromCenter = (distFromCenter*3.0);\n    circleFromCenter = circleFromCenter-circleRadius;\n    musicMap.b = circleFromCenter;\n    \n    if(musicMap.b < 0.0){\n        fragColor = colorOnCenter;\n    }else{\n\n        // use music map red\n        float musicChannelnput = texture( iChannel0, vec2( musicMap.r,0.0)).r;\n\n        // Get the starting x for this bar by rounding down\n        float barStart = floor(musicMap.r * bars) / bars;\n\n        // Sample spectrum in bar area, keep cumulative total\n        float intensity = 0.0;\n        for(float s = 0.0; s < barSize; s += barSize * sampleSize) {\n            intensity += texture(iChannel0, vec2(barStart + s, 0.0)).r;\n        }\n        intensity *= sampleSize;\n        if(musicMap.r - barStart < barGap || musicMap.r > barStart + barSize - barGap) {\n            intensity = 0.0;\n        }\n\n        // use music map blue\n        float onOff = musicMap.b-intensity;\n        onOff = clamp(onOff,-0.5,0.5); \n        onOff = floor(onOff+1.0);\n        fragColor = lerp(colorOn, colorOff,onOff);\n\n    }\n    // used to debug music map\n    // fragColor = musicMap;\n}\n\n\n", "image_inputs": [{"id": 23675, "src": "https://soundcloud.com/zubnid/sorry", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[980, 980, 1019, 1019, 1043], [1045, 1045, 1081, 1081, 1105], [1107, 1107, 1138, 1138, 1683], [1685, 1685, 1742, 1774, 3478]], "test": "untested"}
{"id": "Nl33Wf", "name": "Fork Fork Fork  gchipunov 243", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 166, "published": 3, "date": "1643349267", "time_retrieved": "2024-07-30T17:06:45.660793", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\nvec3 col5 = smoothstep(col2,col4,col3);\n\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 508]], "test": "untested"}
{"id": "sl33Df", "name": "Fork Fork Fork colorchipunov 015", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation", "color", "led", "strobe"], "likes": 1, "viewed": 218, "published": 3, "date": "1643349218", "time_retrieved": "2024-07-30T17:06:46.433726", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n\n  vec2 uv;\n  uv.x = 0.2*exp(iTime) + (r1-r2)*0.55;\n  uv.y = asin(sin(a1-a2))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-55.0*r1) + exp(-55.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.03,1.0,sin(228.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(fract(sqrt (col+w) +(col+w) / 1.1) ,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.5,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl33Df.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 781]], "test": "untested"}
{"id": "slcGDf", "name": "Fork Fork Defor gchipunov 578", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation"], "likes": 2, "viewed": 165, "published": 3, "date": "1643349169", "time_retrieved": "2024-07-30T17:06:47.365235", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n\n  vec2 uv;\n  uv.x = 0.2*iTime + (r1-r2)*0.55;\n  uv.y = asin(sin(a1-a2))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-55.0*r1) + exp(-55.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.03,1.0,sin(228.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(log2(sqrt (col+w) +(col+w) / 1.1) ,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.5,0.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 775]], "test": "untested"}
{"id": "fd2cWz", "name": "Alien landscape", "author": "pancakespeople", "description": "A creepy alien world", "tags": ["raymarching", "terrain", "alien"], "likes": 1, "viewed": 243, "published": 3, "date": "1643346087", "time_retrieved": "2024-07-30T17:06:48.266825", "image_code": "vec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat sdf(vec3 point) {\n    float plane = length(max(point.y, 0.0)) + fbm(point.xz/10.0)*10.0-0.5;\n    \n    return plane;\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float distMarched = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float dist = sdf(rayOrigin);\n        \n        rayOrigin += rayDir * dist;\n        distMarched += dist;\n        \n        if (distMarched < 0.01 || dist > 100.0) {\n            break;\n        }\n    }\n    \n    return distMarched;\n}\n\nvec3 getNormal(vec3 point) {\n    float dist = sdf(point);\n    vec3 norm = dist - vec3(\n        sdf(point - vec3(0.01, 0.0, 0.0)),\n        sdf(point - vec3(0.0, 0.01, 0.0)),\n        sdf(point - vec3(0.0, 0.0, 0.01))\n    );\n    return normalize(norm);\n}\n\nvec3 getColor(vec3 point) {\n    float n = fbm(point.xz*10.0)+0.5;\n    if (point.y > 0.6) {\n        return vec3(1.0) * n;\n    }\n    else if (point.y > 0.4) {\n        return vec3(0.0, 1.0, 0.0)*n;\n    }\n    else {\n        return vec3(0.0, 0.0, 1.0)*n;\n    }\n}\n\nfloat getSpecular(vec3 point, vec3 lightDir, vec3 cameraPos) {\n    vec3 viewDir = normalize(cameraPos-point);\n    vec3 reflectDir = reflect(-lightDir, getNormal(point));\n    return pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n}\n\nfloat getSpecularity(vec3 point) {\n    if (point.y < 0.4) {\n        return 2.0;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\n    vec3 cameraPos = vec3(0.0, 3.5+sin(iTime/5.0), iTime);\n    vec3 rayDir = vec3(uv.x+sin(iTime/5.0), uv.y-0.25, 1.0);\n    vec3 lightDir = vec3(0.5, 0.5, 0.7);\n    float dist = rayMarch(cameraPos, rayDir);\n    vec3 point = rayDir * dist + cameraPos;\n    vec3 normal = getNormal(point);\n    float light = dot(normal, lightDir);\n    float lightDist = rayMarch(point+normal*0.01, lightDir);\n    \n    if (lightDist < 90.0) {\n        light *= 0.1;\n    }\n    \n    vec3 col = vec3(light*vec3(0.7, 0.7, 1.0));\n    \n    col = mix(col, vec3(0.7, 0.7, 1.0), dist/100.0);\n    col = mix(col, vec3(0.0), point.y/10.0);\n    col *= getColor(point) + getSpecular(point, lightDir, cameraPos) * getSpecularity(point);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2cWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 159], [161, 246, 268, 268, 610], [612, 612, 631, 631, 889], [891, 891, 914, 914, 1014], [1016, 1016, 1061, 1061, 1367], [1369, 1369, 1397, 1397, 1620], [1622, 1622, 1649, 1649, 1879], [1881, 1881, 1943, 1943, 2110], [2112, 2112, 2146, 2146, 2215], [2217, 2217, 2274, 2324, 3143]], "test": "untested"}
{"id": "fd2yDR", "name": "walk and jump", "author": "jorge2017a2", "description": "walk and jump", "tags": ["walkandjump"], "likes": 8, "viewed": 247, "published": 3, "date": "1643337514", "time_retrieved": "2024-07-30T17:06:49.219278", "image_code": "//----------image\n//por jorge2017a2-\n//walk and jump--27-ene-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+5.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,8.0));\n    p.y=p.y-5.0;\n    p.z= opRep1D(p.z, 30.0 );\n    float sds1=sdSphere(p-vec3(0.0,5.0,-5.0), 4.0 );\n    res =opU3(res, vec3(sds1,2.0,-1.0));\n    float d1= sdBox( p, vec3(10.0,0.25,10.0) );\n    float d2= sdBox( p-vec3(0.0,5.0,10.0), vec3(10.0,0.25,10.0) );\n    p.x=abs(p.x)-15.0;\n    float d3= sdBox( p-vec3(0.0,0.0,0.0), vec3(5.0,10.0,5.0) );\n    float d4= sdTorus( p-vec3(0.0,12.0,0.0), vec2(2.0,0.5) );\n    \n    res =opU3(res, vec3(d1,-1.0,7.0));\n    res =opU3(res, vec3(d2,-1.0,7.0));\n    res =opU3(res, vec3(d3,-1.0,7.0));\n    res =opU3(res, vec3(d4,13.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 2.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n    {  float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= col;\n        return l1;\n    }\n    \n    if (id_material==8.0)\n    {  float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= col*vec3(0.5,0.5,1.0);\n        return l1;\n    }\n    \n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    //mObj.blnShadow=true;\n \tlight_pos1= vec3(-10.0, 140.0, -60.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 110.0, 60.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,17.0+10.0*abs(sin(t*0.25)),-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   float ang=mix(45.0,90.0,sin(t*0.125));\n   rd= rotate_x(rd, radians(ang));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "///modificado por jorge flores  v2\n///referencia\n///https://www.shadertoy.com/view/wt2GDz\n\n\n\n#define TAU (2.*3.1415926)\n\nfloat square(float t, float f) {\n   \tif (fract(t*f) > 0.5) return 1.0;\n    else return -1.0;\n}\n\nfloat sinwave(float t, float f) \n{ return sin(6.2831*f*t); }\n\nfloat saw(float t, float f) \n{ return fract(t*f); }\n\nfloat fractsaw(float t, float b, int o) {\n\tfloat s = 0.0;\n    for (int i, j = 0; i < o; i++, j *= 2) {\n    \ts += saw(t, b*float(j))/float(o);\n    }\n    return s;\n}\n\nfloat SawOsc(float t,float f, float m)\n{ return (2.*fract((f)*t+(m)/TAU)-1.); }    \n\nfloat saw_medv2(float t) \n{\n    float y = fract(t/20.0)*20.0;\n    if (y < 4.0) return 60.0;\n    if (y < 8.0) return 78.0;\n    if (y < 12.0) return 79.0;\n    if (y < 16.0) return 120.0;\n    if (y < 20.0) return 100.0;\n    return 0.0;\n}\n\nfloat Notasv3(float t) \n{\n    float y = fract(t/20.0)*20.0;\n    if (y < 4.0) return 160.0;\n    if (y < 8.0) return 178.0;\n    if (y < 12.0) return 179.0;\n    if (y < 16.0) return 120.0;\n    if (y < 20.0) return 200.0;\n    return 0.0;\n}\n\nvec2 mainSound( in int samp, float time )\n{   float s1a,s2a,s3a;\n    float s1b,s2b,s3b;\n    float time2=time*2.0;\n    s1b=square(time2, saw_medv2(time));\n    s2b=square(time2, saw_medv2(time)*0.5);\n    s3b=sinwave(time, saw_medv2(time)*1.0)*0.125;\n    float time3=time*2.15;    \n    float sa1= SawOsc(time3*1.125, Notasv3(time3), 0.5);\n    vec2 resp, res2;\n    res2=vec2((s1b+s2b+s3b+sa1))*0.125*fract(-time*4.0);\n    return res2;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2yDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[526, 526, 562, 562, 583], [584, 584, 616, 616, 700], [701, 701, 735, 735, 797], [799, 799, 846, 846, 873], [874, 874, 917, 917, 944], [945, 945, 993, 993, 1021], [1023, 1023, 1059, 1059, 1104], [1106, 1106, 1140, 1140, 1236], [1237, 1237, 1271, 1271, 1362], [1363, 1363, 1397, 1397, 1488], [1489, 1489, 1523, 1523, 1618], [1619, 1619, 1644, 1644, 2368], [2370, 2370, 2394, 2394, 2556], [2558, 2558, 2607, 2607, 3243], [3245, 3245, 3281, 3281, 3526], [3528, 3528, 3565, 3565, 3824], [3826, 3826, 3909, 3909, 4473], [4476, 4476, 4569, 4569, 4699], [4701, 4701, 4733, 4733, 4930], [4933, 4933, 4980, 4980, 5459], [5461, 5461, 5554, 5554, 5895], [5898, 5898, 5925, 5925, 6014], [6016, 6016, 6074, 6074, 6122], [6125, 6125, 6148, 6148, 6266], [6268, 6268, 6299, 6299, 7011], [7014, 7014, 7071, 7071, 7687]], "test": "untested"}
{"id": "NdScWR", "name": "Dual Paraboloids", "author": "4rknova", "description": "Mapping a cubemap to dual paraboloids and reconstruction of environment.\n\n- GPU Gems 3, Chapter 20, Table 20-2, Equations for Scaled Dual-Paraboloid Mapping\n- https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=923191", "tags": ["mapping"], "likes": 3, "viewed": 516, "published": 3, "date": "1643324609", "time_retrieved": "2024-07-30T17:06:50.015150", "image_code": "#define PI\t\t\t3.14159265359\n#define RADIAN\t\t180. / PI\n#define CAMERA_FOV\t60. * RADIAN\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\nvoid generate_ray(Camera c, out Ray r, in vec2 fragCoord)\n{\n\tfloat ratio = iResolution.x / iResolution.y;\n\n\tvec2  uv = (2.0 * fragCoord.xy / iResolution.xy - 1.)\n\t\t\t * vec2(ratio, 1.0);\n\t\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * .5)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\tr.d = normalize(tmat * r.d);\n}\n\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    vec2 uv = p / iResolution.xy;\n    \n    vec3 target = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * 0.5)));\n\tvec3 source = vec3(0,sin(iTime),0);\n    \n    Camera cam;\n\tcam.p = vec3(0., 0., 75.);\n\tcam.u = vec3(0., 1., 0.);\n    \n    #ifdef USE_MOUSE\n\tcam.t = vec3(iMouse.x / iResolution.x * 180. -90., \n\t        iMouse.y / iResolution.y * 180. -90., 0.);\n    #else\n\tcam.t = vec3( 360. * sin(mod(iTime * .64, 2. * PI)),\n                   90. * cos(mod(iTime * .43, 2. * PI)),\n                   25. * cos(mod(iTime * .20, 2. * PI)));\n    #endif\t\t   \n    \n    Ray ray;\n\tgenerate_ray(cam, ray, p);\n    \n    vec2 st = dir2uv(ray.d);\n    \n    vec3 sample_upper = texture(iChannel0, st).xyz;\n    vec3 sample_lower = texture(iChannel1, st).xyz;\n    \n    vec3 res = vec3(0);\n     \n    if (ray.d.z > 0.0) res = sample_upper;\n    else               res = sample_lower;\n    \n    c = vec4(res, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy * 2.0 - 1.0;\n    vec3 dir = uv2dir(uv, UPPER);        \n    vec3 res = texture(iChannel0, dir).xyz;\n    if (length(uv) > 1.01) res *= 0.5;\n    c = vec4(res, 1);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define UPPER (0.0)\n#define LOWER (1.0)\n\n// Formulas from https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=923191\n// and GPU Gems 3, Chapter 20, Table 20-2, Equations for Scaled Dual-Paraboloid\n// Mapping\n   \nvec3 uv2dir(vec2 uv, float side)\n{    \n    vec3 dir = vec3(uv, 0);\n    \n    float lsq = (uv.x * uv.x) + (uv.y * uv.y);\n    \n    if (side <= UPPER) dir.z =  0.5 - 0.5 * lsq;   \n    else               dir.z = -0.5 + 0.5 * lsq;\n    \n    return normalize(dir);\n}\n\nvec2 dir2uv(vec3 dir)\n{\n    float denom = 1.0 ;\n    \n    if (dir.z >= 0.0 ) denom /= (1.0 + dir.z);\n    else               denom /= (1.0 - dir.z); \n    \n    return 0.5* denom * dir.xy + 0.5; \n}", "buffer_b_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy * 2.0 - 1.0;\n    vec3 dir = uv2dir(uv, LOWER);        \n    vec3 res = texture(iChannel0, dir).xyz;\n    if (length(uv) > 1.01) res *= 0.5;\n    c = vec4(res, 1);\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdScWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 207, 207, 660], [663, 663, 702, 702, 1595]], "test": "untested"}
{"id": "NdBcWz", "name": "The Royal Standard", "author": "mla", "description": "After the lions, the Irish harp was straightforward (with some simplifications), so here is the complete Royal Standard of the United Kingdom. Each quarter rendered in a separate buffer.\n\nMouse to zoom, 'x' for progressive rendering,", "tags": ["bezier", "flag", "standard", "svg", "arms", "quartering"], "likes": 21, "viewed": 456, "published": 3, "date": "1643322325", "time_retrieved": "2024-07-30T17:06:51.248852", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Royal Standard of the United Kingdom, Matthew Arcus, mla. 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// https://en.wikipedia.org/wiki/Royal_Standard_of_the_United_Kingdom\n//\n// Composed of the Royal Arms of England, Scotland and Ireland, with\n// the Welsh left out:\n//\n// \"Wales is not represented in the Royal Standard, as its special\n// position as a Principality was recognised by the creation of the\n// Prince of Wales long before the incorporation of the quarterings\n// for Scotland and Ireland in the Royal Arms.\"\n//\n// according to https://www.royal.uk, who ought to know, I suppose.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The Standard used in Scotland has the lion rampant twice\n// instead of the three lions of England.\n//#define NORTHOFTHEBORDER\n#if !defined NORTHOFTHEBORDER\n#define channel1 iChannel1\n#define channel2 iChannel2\n#else\n#define channel1 iChannel2\n#define channel2 iChannel1\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy;\n    bvec2 quad = lessThan(uv,vec2(1));\n    // Each buffer only 1/4 rendered.\n    uv = 0.5*fract(uv);\n    if (all(quad)) fragColor = texture(iChannel0,uv);\n    else if (all(not(quad))) fragColor = texture(channel1,uv);\n    else fragColor = texture(channel2,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint points[] = uint[](\n1493175066u, 1404445083u, 1404445083u, 1315715099u, 1227700772u, 1227700772u, 1139620908u, 1313153382u, 1313153382u, 1486685856u, 1489963229u, 1489963229u, 1493175066u, \n1263613936u, 1207253306u, 1207253306u, 1150958212u, \n1429276968u, 1228218946u, 1228218946u, 1027226461u, 1083456453u, 1083456453u, 1139620908u, 1313153382u, 1313153382u, 1486685856u, 1457981412u, 1457981412u, 1429276968u, \n1202261078u, 1193807048u, 1185353017u, 1176964520u, 1249186602u, 1249186602u, 1321474220u, 1327175963u, 1337727279u, 1345001688u, 1352341632u, 1353586655u, 1347884912u, 1275072995u, 1275072995u, 1202261078u, \n1148784405u, 1140133764u, 1131483121u, 1122898011u, 1205737132u, 1205737132u, 1288576253u, 1294277996u, 1304829312u, 1312169257u, 1319443666u, 1320754225u, 1315052481u, 1231951211u, 1231951211u, 1148784405u, \n1093931449u, 1085018659u, 1076105867u, 1067193071u, 1161435678u, 1161435678u, 1255678286u, 1261380029u, 1271996881u, 1279271290u, 1286545699u, 1287856258u, 1282154514u, 1188042982u, 1188042982u, 1093931449u, \n1037112375u, 1027806361u, 1018565883u, 1009325398u, 1116085626u, 1116085626u, 1222845853u, 1228547597u, 1239098912u, 1246373321u, 1253713266u, 1255023825u, 1249256545u, 1143217228u, 1143217228u, 1037112375u, \n977737346u, 967841500u, 958076722u, 948311938u, 1069097144u, 1069097144u, 1189947886u, 1195649630u, 1206200946u, 1213540890u, 1220815299u, 1222125858u, 1216424115u, 1097080730u, 1097080730u, 977737346u, \n914495620u, 903813328u, 893196565u, 882645332u, 1019880394u, 1019880394u, 1157049920u, 1162817199u, 1173368515u, 1180642924u, 1187982868u, 1189227891u, 1183526148u, 1049043652u, 1049043652u, 914495620u, \n845617685u, 833493579u, 821434996u, 809573011u, 966928018u, 966928018u, 1124217489u, 1129919232u, 1140470548u, 1147810493u, 1155084902u, 1156395460u, 1150628181u, 998122933u, 998122933u, 845617685u, \n748821322u, 784867004u, 807673266u, 827726779u, 808851896u, 808851896u, 789977013u, 763631691u, 763631691u, 737286368u, 743053845u, 743053845u, 748821322u, \n791157035u, 828841311u, 852499882u, 879500245u, 853023185u, 853023185u, 826480590u, 808851580u, 808851580u, 791157035u, \n827070765u, 912269043u, 943594825u, 970005232u, 895555669u, 895555669u, 821171642u, 824121204u, 824121204u, 827070765u, \n894638290u, 939662171u, 1049173555u, 1054939297u, 996611888u, 996611888u, 938284479u, 916461384u, 916461384u, 894638290u, \n931141648u, 940710186u, 974068002u, 979573285u, \n944510701u, 986781440u, 1101667538u, 1109792031u, 1047598223u, 1047598223u, 985338879u, 964957558u, 964957558u, 944510701u, \n868423945u, 883169815u, 883169815u, 897915686u, \n814029241u, 822876741u, 832903871u, 833756101u, \n773069158u, 780409368u, 784866012u, 783227845u, \n915871757u, 908073409u, 874125927u, 838998045u, 845224512u, 785455976u, 782833566u, 790437219u, 720246717u, 715265728u, 713233874u, 713233874u, 711136484u, 798954843u, 798954843u, 886773202u, 901322480u, 901322480u, 915871757u, \n877401713u, 919345800u, 966203380u, 986584451u, 950736132u, 950736132u, 914822277u, 896144763u, 896144763u, 877401713u, \n1005196367u, 1115363077u, 1155667326u, 1158943312u, 1086788025u, 1086788025u, 1014632737u, 1009914552u, 1009914552u, 1005196367u, \n984290686u, 997070407u, 1010177806u, 1036588973u, \n912790836u, 994580366u, 1014764840u, 1028133625u, 972558898u, 972558898u, 916918636u, 914821968u, 914821968u, 912790836u, \n1040781763u, 1099240383u, 1194202160u, 1182142292u, 1128402643u, 1128402643u, 1074662994u, 1057755147u, 1057755147u, 1040781763u, \n1110512037u, 1080103158u, 1080103158u, 1049759816u, \n1021907712u, 1037308834u, 1052644353u, 1067979855u, \n951259785u, 1021252901u, 1054413581u, 1065684916u, 1011683128u, 1011683128u, 957746877u, 954470563u, 954470563u, 951259785u, \n1081282256u, 1236210081u, 1329204715u, 1351814065u, 1222642635u, 1222642635u, 1093536740u, 1087376730u, 1087376730u, 1081282256u, \n1093537233u, 1112542833u, 1128533591u, 1144720968u, \n970788824u, 1069617750u, 1086459760u, 1109527795u, 1038159137u, 1038159137u, 966790479u, 968822420u, 968822420u, 970788824u, \n1107364986u, 1253052242u, 1443498917u, 1495205539u, 1496778403u, 1496778403u, 1498416803u, 1315309284u, 1315309284u, 1132201766u, 1119816144u, 1119816144u, 1107364986u, \n1259277024u, 1219234598u, 1181617054u, 1127877311u, \n1148651959u, 1125714975u, 1114312489u, 984157641u, 979504088u, 979504088u, 974850535u, 1061751247u, 1061751247u, 1148651959u, \n1482426188u, 1471547670u, 1471547670u, 1460734688u, 1502023144u, 1554057965u, 1507002607u, 1542325930u, 1510147520u, 1482426188u, 1482426188u, 1482426188u, 1482426188u, \n1318126872u, 1416168766u, 1497171083u, 1588396892u, 1607598876u, 1615070189u, 1597703349u, 1484130769u, 1203243521u, 1163987121u, 1171130276u, 1171130276u, 1178338967u, 1248200152u, 1248200152u, 1318126872u, \n977537817u, 1070730332u, 1162676890u, 1194985399u, 1166214791u, 1166214791u, 1137509719u, 1055328070u, 1055328070u, 973146421u, 975374887u, 975374887u, 977537817u, \n982714778u, 1000933916u, 1021315604u, 1039469055u, \n1020595420u, 1007881412u, 994708678u, 984157227u, \n979898112u, 999558935u, 1004670811u, 1011290010u, \n967447012u, 978784848u, 992154206u, 1006309959u, \n932516965u, 946738381u, 960894154u, 975115445u, \n895096353u, 906696315u, 916395733u, 925243183u, \n798430627u, 807933548u, 808195929u, 806754381u, \n853546672u, 859838314u, 864032810u, 883693756u, \n753735027u, 760485528u, 760485528u, 767236030u, \n577969038u, 577968491u, 548411704u, 548411327u, 548410875u, 572069182u, 598414467u, 615650313u, 632164637u, 647827967u, 647827523u, 648023622u, 622333510u, 594480710u, 600837254u, 611847258u, 603065347u, 606735000u, 588122740u, 632031432u, 601163227u, 634651991u, 622133647u, 705364512u, 721421601u, 762971291u, 779683256u, 801048298u, 814155960u, 814155960u, 827198086u, 808848344u, 808848344u, 790498601u, 786435501u, 780144012u, 773590356u, 764808719u, 753798584u, 742526277u, 734203527u, 733614006u, 740561279u, 780276116u, 803738419u, 835457843u, 875959091u, 929631931u, 920390684u, 900662914u, 1002374272u, 1098056832u, 1189872768u, 1248134705u, 1338966897u, 1326384964u, 1247152194u, 1161824216u, 1115884315u, 985138521u, 985140202u, 992349570u, 998379283u, 976752664u, 983175449u, 981275146u, 958403280u, 952046588u, 937170142u, 917181843u, 880940972u, 842733366u, 806753864u, 780342681u, 756225307u, 732042886u, 794565598u, 720837775u, 755834876u, 792273807u, 841822452u, 1065759730u, 1099903972u, 1105803595u, 1030568024u, 657208659u, 577970249u, 577969038u, 577969038u, 577969038u, 577969038u, \n798099081u, 800196598u, 790825287u, 815860325u, 792660633u, 791153645u, 789712195u, 790170942u, 790170942u, 790629689u, 798821722u, 798821722u, 806948219u, 731386304u, 917245717u, 837946038u, 890898327u, 843711801u, 798099081u, 798099081u, 798099081u, 798099081u, \n814745676u, 830474637u, 840501998u, 815598708u, \n779224802u, 780536068u, 782895915u, 774507817u, \n623709769u, 640355913u, 640355913u, 657002057u, \n677774844u, 715064574u, 739444304u, 767624949u, \n681510645u, 708707859u, 733349716u, 758712314u, \n688196756u, 732564528u, 727124326u, 717883737u, 697567548u, 716376655u, 708971294u, 701565933u, 688196756u, 688196756u, 688196756u, 688196756u, 688196756u, \n610536535u, 615124061u, 617221228u, 620170361u, \n723127375u, 728370373u, 734465309u, 742722893u, \n634717509u, 715393393u, 671419162u, 675351397u, 679087019u, 689310503u, 693963438u, \n644286321u, 635701101u, 628164511u, 623118310u, \n624429123u, 634325059u, 639436982u, 645859572u, 639306042u, 633801110u, 623905173u, \n632296257u, 642519820u, 648155788u, 647631343u, \n740168055u, 722211383u, 712774437u, 709301298u, \n605361643u, 551950970u, 684203335u, 684202151u, \n626071602u, 625481964u, 630528284u, 638327068u, \n1264256599u, 1298925698u, 1340606118u, 1394607864u, \n1150093027u, 1157367645u, 1157367645u, 1164642263u, \n613491387u, 558245376u, 647571654u, 637217749u, 676211269u, 650454952u, 644752675u, 663430480u, 662841194u, 667429199u, 669985379u, 682830410u, 694430093u, 712125614u, 762981417u, 734275715u, 768420672u, 761735476u, 747382573u, 736044433u, 703145120u, 729162776u, 745415619u, 742140339u, 781723802u, 805251059u, 754722014u, 777987241u, 791553162u, 777791969u, 841033827u, 839133186u, 839133186u, 837232545u, 797320920u, 828973426u, 755638642u, 684532246u, 684532246u, 613491387u, \n673784576u, 678699884u, 685515855u, 692921685u, 691872876u, 683484035u, 693838490u, 683811533u, 683811533u, 673784576u, \n615981803u, 617227166u, 617227166u, 618472528u, \n737747479u, 756163143u, 762323612u, 768287474u, \n761667506u, 758390710u, 755310539u, 752885740u, 724836715u, 681386542u, 604905834u, 596910422u, 589308328u, 587997730u, 586621596u, 592061199u, 600056612u, 681583605u, 736568099u, 772415802u, 777134331u, 778707092u, 776282171u, 773857250u, 767958955u, 761667506u, 761667506u, 761667506u, 761667506u, \n627975466u, 614016915u, 655894221u, 651373293u, 0u );\nconst uvec2 boxes[] = uvec2[](\n  uvec2(1139607200u,1493187628u),\n  uvec2(1150957552u,1263614596u),\n  uvec2(1027212960u,1486699564u),\n  uvec2(1176964182u,1353586991u),\n  uvec2(1122897685u,1320754560u),\n  uvec2(1067192761u,1287856593u),\n  uvec2(1009325111u,1255024160u),\n  uvec2(948311682u,1222126194u),\n  uvec2(882645124u,1189228227u),\n  uvec2(809572885u,1156395796u),\n  uvec2(737286069u,827727548u),\n  uvec2(791156686u,879500714u),\n  uvec2(821171642u,970006259u),\n  uvec2(894637503u,1054940723u),\n  uvec2(931141648u,979573285u),\n  uvec2(944509951u,1109794002u),\n  uvec2(868423945u,897915686u),\n  uvec2(814029241u,833756101u),\n  uvec2(773069158u,784866245u),\n  uvec2(711136484u,915873123u),\n  uvec2(877401221u,986585736u),\n  uvec2(1005195553u,1158944517u),\n  uvec2(984290686u,1036588973u),\n  uvec2(912789868u,1028134798u),\n  uvec2(1040780882u,1194202160u),\n  uvec2(1049759816u,1110512037u),\n  uvec2(1021907712u,1067979855u),\n  uvec2(951258813u,1065686309u),\n  uvec2(1081281457u,1351815585u),\n  uvec2(1093537233u,1144721009u),\n  uvec2(966790387u,1109529174u),\n  uvec2(1107363491u,1498419026u),\n  uvec2(1127877311u,1259277214u),\n  uvec2(974850487u,1148653353u),\n  uvec2(1460733376u,1554058728u),\n  uvec2(1163985692u,1615071745u),\n  uvec2(973145431u,1194986588u),\n  uvec2(982714778u,1039469084u),\n  uvec2(984157227u,1020595420u),\n  uvec2(979898112u,1011290010u),\n  uvec2(967447012u,1006309982u),\n  uvec2(932516965u,975115469u),\n  uvec2(895096353u,925243183u),\n  uvec2(798430627u,808196173u),\n  uvec2(853546672u,883693756u),\n  uvec2(753735027u,767236030u),\n  uvec2(548405647u,1338980683u),\n  uvec2(731383097u,917246400u),\n  uvec2(814745676u,840502388u),\n  uvec2(774506210u,782896425u),\n  uvec2(623709769u,657002057u),\n  uvec2(677774590u,767624949u),\n  uvec2(681510419u,758712314u),\n  uvec2(688195900u,732564628u),\n  uvec2(610536535u,620170361u),\n  uvec2(723127375u,742722893u),\n  uvec2(634717509u,715393963u),\n  uvec2(623118189u,644286438u),\n  uvec2(623904835u,645859734u),\n  uvec2(632295919u,648155969u),\n  uvec2(709300599u,740168754u),\n  uvec2(551949803u,684203335u),\n  uvec2(625481778u,638327068u),\n  uvec2(1264256599u,1394608258u),\n  uvec2(1150093027u,1164642263u),\n  uvec2(558244210u,841034926u),\n  uvec2(673784474u,693839189u),\n  uvec2(615981803u,618472528u),\n  uvec2(737747479u,768287474u),\n  uvec2(586620843u,778707957u),\n  uvec2(614016298u,655895277u)\n);\nconst int paths[] = int[](\n  26,34,60,92,124,156,188,220,252,284,310,330,350,370,378,398,406,414,422,460,480,500,508,528,548,556,564,584,604,612,632,658,666,686,712,744,770,778,786,794,802,810,818,826,834,842,1024,1068,1076,1084,1092,1100,1108,1134,1142,1150,1164,1172,1186,1194,1202,1210,1218,1226,1234,1314,1334,1342,1350,1400,1408);\n\nconst int colors[boxes.length()] =\n  int[](1,0,1,2,2, 2,2,2,2,2, 1,1,1,1,0, 1,0,0,0,1, 1,1,0,1,1, 0,0,1,1,0, 1,1,0,1,1,\n        1,1,0,0,0, 0,0,0,0,0, 0,1,1,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 1,0,0,0,1, 0); \n\nvec3 getcolor(int i) {\n  vec3 col = vec3(1,0,1);\n  // Colors from Wikipedia SVG\n  if (i == 0) col = vec3(0x0a,0x26,0x62)/255.0;\n  if (i == 1) col = vec3(0xff,0xd2,0x14)/255.0;\n  if (i == 2) col = vec3(1);\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// The Royal Banner of Ireland, Matthew Arcus, mla. 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// https://en.wikipedia.org/wiki/Coat_of_arms_of_Ireland\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  //if (iFrame > 0 && iMouse.z <= 0.0) discard;\n  vec2 p = 2.0*fragCoord/iResolution.xy;\n  if (p.x > 1.0 || p.y > 1.0) discard;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p -= mouse;\n    p *= 0.25;\n    p += mouse;\n  }\n  p.y = 1.0-p.y;\n  p *= vec2(500,250);\n  vec3 col = getcolor(0);\n  float eps = 2.0; // Allow for line width \n  float px = fwidth(p.x);\n  float lwidth = 0.5;\n  int N = paths.length();\n  if (key(CHAR_X)) N = min(int(2.0*iTime),N); // Progressive effect\n  for (int i = 0; i < N; i++) {\n    vec4 box = decode(boxes[i]);\n    if ((p.x >= box.x-eps && p.x <= box.z+eps && p.y >= box.y-eps && p.y <= box.w+eps)) {\n      //assert(i != N-1); // With progressive drawing, show bounding boxes\n      int start = i == 0 ? 0 : paths[i-1];\n      int end = paths[i];\n      vec2 initpos = decode(points[start/2]);\n      vec2 p0 = initpos;\n      wind = 0;\n      float d = 1e8;\n      for (int j = start+2; j < end; j += 6) {\n        vec2 c0 = decode(points[(j+0)/2]);\n        vec2 c1 = decode(points[(j+2)/2]);\n        vec2 p1 = decode(points[(j+4)/2]);vec2(points[j+4],points[j+5]);\n        vec2 box1 = min(min(c0,c1),min(p0,p1))-eps;\n        vec2 box2 = max(max(c0,c1),max(p0,p1))+eps;\n        if (p.x < box1.x || p.y  < box1.y  || p.x > box2.x || p.y > box2.y) {\n          polywind(p,p0,p1);\n        } else {\n          d = min(d,bezier(p,mat4x2(p0,c0,c1,p1)));\n        }\n        p0 = p1;\n      }\n      polywind(p,p0,initpos); // Close curve if necessary\n      if (colors[i] != 0 && (wind&1) == 1) col = getcolor(colors[i]);;\n      col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = 1.0-col;\n  fragColor = vec4(col,1);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const uint points[] = uint[](\n995824862u, 997921960u, 997921960u, 1000019059u, 1002771626u, 1002771626u, 1005589728u, \n992285384u, 995234578u, 995234578u, 998249307u, 1000805147u, 1000805147u, 1003360987u, \n947001990u, 966138265u, 986192190u, 986192190u, 986192190u, 972888499u, 965220940u, 957553382u, 949230354u, 949230354u, 971905867u, 977214150u, 983833197u, 985209434u, 987109960u, 989207094u, 989207093u, 989207092u, 989207092u, 989207092u, 989207093u, 989207094u, 997202417u, 1008474551u, 1008474551u, 1008474551u, 997202417u, 989207094u, 989469255u, 991763190u, 989862719u, 987831179u, 980884448u, 988159013u, 995499114u, 1003166805u, 1003166805u, 1003166805u, 999693242u, 1016797970u, 999693242u, 1003166805u, 1003166805u, 1004477638u, 998186288u, 998186288u, 1026825487u, 1043078068u, 1043078068u, 1043078161u, 1040129291u, 1040129291u, 1051401455u, 1058413738u, 1061100637u, 1063722001u, 1066736519u, 1071389773u, 1076043027u, 1092361515u, 1092361515u, 1091902600u, 1091902600u, 1091378148u, 1098390673u, 1114381456u, 1121197191u, 1119558768u, 1119558768u, 1117985881u, 1119558768u, 1119558768u, 1121197191u, 1123097733u, 1124342914u, 1124342914u, 1110711280u, 1106385177u, 1119033993u, 1131682808u, 1150622458u, 1150622458u, 1133648606u, 1141316015u, 1141316015u, 1155930612u, 1160976682u, 1160976682u, 1137973485u, 1146296117u, 1146296117u, 1165629297u, 1169954487u, 1169954487u, 1146951347u, 1149310345u, 1145967924u, 1142625503u, 1144984750u, 1144984750u, 1161958595u, 1165300793u, 1165300793u, 1141969977u, 1140659003u, 1140658890u, 1140658777u, 1136005614u, 1135677855u, 1135219007u, 1140002964u, 1140002964u, 1140002964u, 1130631446u, 1122308386u, 1113985326u, 1116344440u, 1110380595u, 1104351215u, 1097731994u, 1088360342u, 1079054226u, 1081740955u, 1081740955u, 1081740955u, 1072041740u, 1066078029u, 1060114318u, 1056116626u, 1047793558u, 1039470490u, 1033768805u, 1021120483u, 1008472160u, 997527620u, 983830596u, 970199108u, 973541545u, 976556249u, 979505417u, 976228743u, 976228868u, 976228993u, 983503477u, 991498942u, 999494406u, 1008472770u, 1014174345u, 1019548243u, 1038619224u, 1040257625u, 1039012411u, 1038094876u, 1038029308u, 1038094876u, 1039012411u, 1040257625u, 1040388697u, 1040454233u, 1040454233u, 1041568346u, 1041568346u, 1042747994u, 1042813520u, 1042813520u, 1042879045u, 1042813520u, 1042813520u, 1042747994u, 1044189788u, 1044189788u, 1045697117u, 1044189788u, 1044189788u, 1042747994u, 1042616942u, 1042616942u, 1042485890u, 1047597781u, 1055331086u, 1055331086u, 1055331086u, 1047597781u, 1042485890u, 1042485890u, 1042485890u, 1042420355u, 1042027408u, 1049105463u, 1049105554u, 1049040098u, 1041110243u, 1041110243u, 1041110243u, 1003820259u, 993203421u, 982521048u, 984749337u, 984749455u, 984749574u, 978523691u, 978523691u, 989599292u, 992286219u, 994973152u, 997594549u, 1005131162u, 1014896074u, 1024660987u, 1037571525u, 1044649397u, 1051792805u, 1048188449u, 1048188449u, 1048188449u, 1040651981u, 1028658904u, 1016731362u, 1007818445u, 1000281907u, 995170168u, 986126225u, 978851760u, 981211069u, 981211069u, 983635914u, 981211069u, 981211069u, 978851760u, 975312830u, 972101582u, 970069989u, 963909675u, 936384647u, 920852501u, 920852501u, 919476472u, 938154264u, 938154264u, 949229869u, 934615487u, 926882315u, 922229393u, 915872453u, 916134600u, 916265673u, 916265673u, 917576405u, 917576405u, 918887137u, 920263384u, 920263384u, 921705168u, 920263384u, 920263384u, 918887137u, 918952674u, 918952674u, 919083747u, 918952674u, 918952674u, 918887137u, 917838567u, 917838567u, 916789997u, 922753799u, 934812446u, 947001990u, 947001990u, 947001990u, 947001990u, \n934615487u, 949229870u, 938154264u, 938154264u, 919476472u, 920852502u, 920852502u, 936384647u, 963909675u, 970069989u, 972101582u, 975312830u, 978851760u, 978655151u, 978655151u, 978524078u, 978524078u, 929896120u, 909579324u, 889328065u, 843518080u, 843518080u, 843518080u, 829362229u, 838340386u, 847318544u, 837881285u, 834080232u, 830279178u, 825560620u, 821366293u, 817106430u, 812846728u, 806227506u, 799608284u, 798231982u, 792071684u, 785976922u, 778374792u, 781258416u, 782044860u, 782110403u, 781717191u, 783945421u, 796987131u, 810225629u, 796987131u, 783945421u, 781717191u, 780734161u, 776867527u, 773197482u, 768020098u, 760483544u, 764219153u, 768020299u, 761401380u, 771756045u, 782176246u, 792989606u, 793514003u, 793972864u, 808587512u, 793514243u, 778375439u, 770838828u, 771756429u, 772739566u, 780276527u, 788271741u, 796332492u, 812388818u, 817107570u, 821826322u, 828445636u, 828445636u, 829756330u, 829756330u, 831067024u, 831067024u, 836047950u, 835720391u, 838210741u, 838210741u, 840701090u, 842536278u, 842536278u, 844371466u, 847189479u, 847189479u, 850073029u, 850859681u, 850859681u, 851711869u, 856364877u, 856364877u, 861017884u, 861017884u, 862066675u, 863377467u, 865867813u, 865867813u, 868358159u, 868358159u, 869996688u, 877992209u, 885463434u, 912333472u, 915872453u, 922229393u, 926882315u, 934615487u, 934615487u, 934615487u, 934615487u, \n810159696u, 815861471u, 815861471u, 821628783u, 815861471u, 815861471u, 810159696u, 810159696u, 810159696u, 810159696u, \n1040454233u, 1040454233u, 1040323161u, 1040257625u, 1040912999u, 1041633909u, 1042485890u, 1042616942u, 1042616942u, 1042747995u, 1041568346u, 1041568346u, 1040454233u, 1040454233u, 1040454233u, 1040454233u, \n916265674u, 916265674u, 916134600u, 915872453u, 914889421u, 913906387u, 912857815u, 912857815u, 914299618u, 916789997u, 917838567u, 917838567u, 918887137u, 917576405u, 917576405u, 916265674u, 916265674u, 916265674u, 916265674u, \n1089938112u, 1090658966u, 1090789995u, 1090593346u, 1089217090u, 1051206228u, 1039081988u, 1026695602u, 1004806585u, 990782038u, 976757491u, 951460772u, 939074257u, 935862938u, 934224489u, 933569087u, 931537350u, 937435523u, 937435523u, 937435523u, 901456395u, 925639513u, 899228600u, 884613738u, 884613738u, 884613738u, 877405132u, 897328128u, 915219503u, 930685976u, 930685976u, 930685976u, 912991596u, 891692375u, 891692375u, 900998677u, 931931403u, 931931403u, 930293092u, 933635529u, 933635529u, 959259862u, 961553929u, 963913532u, 964241180u, 968566604u, 972892029u, 979576895u, 966600763u, 953559095u, 938616830u, 928262138u, 917972982u, 885336135u, 878389222u, 871376773u, 862398276u, 861021903u, 859711066u, 854730314u, 850732622u, 846734930u, 839722614u, 842082019u, 842082019u, 841033508u, 838149913u, 850339751u, 850339751u, 862529589u, 850339751u, 850339751u, 838149913u, 837691160u, 837232405u, 836773648u, 832775911u, 823076523u, 821765900u, 820455277u, 822749121u, 820783090u, 818751522u, 816130099u, 816457855u, 816785612u, 812788126u, 820455842u, 828058022u, 828778825u, 840706385u, 852699481u, 873015609u, 864037262u, 855058915u, 844704255u, 843721288u, 842738320u, 847063676u, 851389056u, 855714436u, 859712193u, 860695289u, 861678386u, 868690782u, 870722285u, 872688252u, 874326475u, 883042754u, 892807608u, 896805411u, 896805411u, 903228076u, 908274412u, 911289079u, 911289079u, 911813267u, 919546485u, 927214168u, 931736234u, 933833438u, 935865107u, 940190580u, 949234569u, 949234569u, 948447989u, 956181239u, 963848953u, 967257003u, 981871568u, 981871568u, 982264693u, 987704155u, 993143618u, 995961605u, 996158181u, 996158181u, 997862306u, 1011755975u, 1011755975u, 1012476817u, 1017391950u, 1023027968u, 1025125083u, 1039477465u, 1053829847u, 1064446503u, 1064446503u, 1064446503u, 1046817408u, 1034168855u, 1021520302u, 1002841888u, 1053107778u, 1068115462u, 1076110860u, 1078535696u, 1078011196u, 1084498950u, 1089938112u, 1089938112u, 1089938112u, 1089938112u, \n834611185u, 826943401u, 821372892u, 821372892u, 821372892u, 826943401u, 834611185u, 842278969u, 851716246u, 851716246u, 851716246u, 842278969u, 834611185u, 834611185u, 834611185u, 834611185u, \n1331826582u, 1324289770u, 1316687367u, 1300303367u, 1300303367u, 1322519797u, 1303383075u, 1303383075u, 1297747345u, 1265241489u, 1201409425u, 1183649663u, 1189221211u, 1193547359u, 1241520098u, 1274091886u, 1302010561u, 1307712824u, 1307712824u, 1307581748u, 1307385136u, 1307188525u, 1293360153u, 1276845071u, 1255152515u, 1233197814u, 1250171303u, 1250171303u, 1204558433u, 1234836477u, 1234836477u, 1228872777u, 1228872777u, 1222843542u, 1204886872u, 1185553392u, 1185553392u, 1183587692u, 1208556916u, 1208556916u, 1161961293u, 1211899999u, 1211899999u, 1191911237u, 1221533254u, 1221533254u, 1229201346u, 1254497991u, 1254497991u, 1242177219u, 1222188364u, 1264459011u, 1306729658u, 1322393748u, 1274159619u, 1225859955u, 1173627202u, 1163927522u, 1154293379u, 1121328266u, 1121328266u, 1121262729u, 1121262729u, 1121197191u, 1114381456u, 1098390673u, 1091378148u, 1091902600u, 1091902600u, 1092361515u, 1092361515u, 1076043027u, 1071389773u, 1066736519u, 1063722001u, 1061100637u, 1058413738u, 1051401455u, 1040129291u, 1040129291u, 1043143697u, 1043143604u, 1043143604u, 1026825487u, 998186288u, 998186288u, 1004477638u, 1003166805u, 1003166805u, 995499114u, 988159013u, 980884448u, 987831179u, 989862719u, 991763190u, 989469255u, 989207094u, 987109960u, 985274970u, 983833197u, 977214150u, 971905867u, 949230354u, 949230354u, 957553382u, 965220940u, 972888499u, 986192190u, 986192190u, 986192190u, 966138265u, 947001990u, 934812446u, 922753799u, 916789997u, 916724461u, 916724461u, 916593390u, 898898767u, 848370983u, 848370983u, 826416621u, 809770651u, 786505427u, 763174668u, 750526127u, 738532938u, 726539749u, 728571563u, 728571563u, 728571626u, 728571626u, 728571688u, 728571814u, 743186261u, 751837045u, 760487829u, 731193427u, 715268203u, 699277444u, 707600661u, 711270677u, 714940693u, 715923713u, 720904546u, 725885379u, 731914679u, 737222986u, 742531293u, 753868988u, 760881284u, 767828043u, 768155776u, 768155885u, 768155994u, 763502990u, 756163027u, 748888600u, 758522420u, 762520136u, 766517852u, 768877169u, 771826353u, 774841074u, 781525693u, 781525443u, 781525192u, 790831300u, 798498903u, 806100970u, 806101124u, 805773585u, 805446046u, 807805363u, 813113787u, 818422211u, 824123815u, 827793657u, 831397963u, 843063432u, 843063432u, 846078120u, 850403480u, 850403480u, 848044087u, 853090274u, 853090274u, 857743472u, 871374964u, 871374964u, 868360219u, 873013190u, 873013190u, 880681108u, 896016500u, 896016500u, 892674087u, 894312370u, 894312370u, 899686435u, 909320182u, 909320182u, 904339349u, 908992276u, 908992276u, 916660186u, 929963958u, 929963958u, 923279112u, 933633776u, 939925288u, 946282337u, 955588392u, 955588392u, 964566792u, 966270853u, 966270853u, 966270853u, 976690985u, 984227572u, 988028633u, 992419535u, 996548302u, 995106466u, 995106466u, 993664631u, 995106466u, 995106466u, 996548302u, 1004216010u, 1010835172u, 1010835172u, 1010835172u, 1004216010u, 996548302u, 996679379u, 996679379u, 996875992u, 1010507851u, 1043472532u, 1059791032u, 1076109533u, 1087054206u, 1087054206u, 1087447429u, 1087447429u, 1087906189u, 1079648351u, 1056710509u, 1056710509u, 1056710509u, 1079648351u, 1087906189u, 1090462140u, 1090462140u, 1093083628u, 1090462140u, 1090462140u, 1087906189u, 1089479111u, 1090462212u, 1090658882u, 1090658882u, 1090789954u, 1090789954u, 1093280322u, 1093280322u, 1095836226u, 1093280322u, 1093280322u, 1090789954u, 1090789954u, 1090658882u, 1090658882u, 1090789996u, 1090658966u, 1089938112u, 1084498950u, 1078076732u, 1078535696u, 1079059985u, 1079453201u, 1079453201u, 1081812499u, 1081812499u, 1084171798u, 1081812499u, 1081812499u, 1079453201u, 1079453201u, 1079059985u, 1078535696u, 1078666832u, 1079453320u, 1081091764u, 1088169841u, 1115236559u, 1097935319u, 1080634079u, 1076243188u, 1078012919u, 1078012919u, 1080109866u, 1092758249u, 1092758249u, 1089416192u, 1098722437u, 1098722437u, 1096428467u, 1106389850u, 1106389850u, 1115368505u, 1131031532u, 1131031532u, 1119365995u, 1119365825u, 1119365655u, 1124346315u, 1131358796u, 1138371277u, 1150364365u, 1159342720u, 1168321076u, 1186605369u, 1186605571u, 1186605773u, 1189620490u, 1192962854u, 1196239682u, 1195584403u, 1189948396u, 1184312389u, 1179266254u, 1176644907u, 1173958024u, 1160654430u, 1155018253u, 1149316540u, 1138371976u, 1135029692u, 1131687409u, 1123364353u, 1128017458u, 1132670562u, 1132670651u, 1131687684u, 1130704716u, 1136996180u, 1134374821u, 1134374821u, 1139617588u, 1150824156u, 1139617588u, 1134374821u, 1134374821u, 1131687926u, 1126051826u, 1133654075u, 1141321859u, 1142370524u, 1150693560u, 1159016595u, 1161638068u, 1161965820u, 1162293573u, 1171272126u, 1174941997u, 1178611868u, 1177628626u, 1177300893u, 1176973161u, 1180970844u, 1186606892u, 1192242940u, 1201942223u, 1202597688u, 1203253153u, 1201287287u, 1205285007u, 1209282728u, 1214591156u, 1214918743u, 1215246330u, 1217605602u, 1223897042u, 1230254017u, 1235234741u, 1235562337u, 1235889932u, 1235234507u, 1225207499u, 1215246027u, 1214262971u, 1214262890u, 1214262809u, 1212231096u, 1224879532u, 1237527968u, 1250438535u, 1254436178u, 1254436178u, 1244409146u, 1240214758u, 1236020371u, 1229532318u, 1229532318u, 1229532318u, 1229794435u, 1236413557u, 1243098216u, 1264593981u, 1269312408u, 1269312408u, 1261054913u, 1254173563u, 1247292213u, 1244670775u, 1244670775u, 1244670775u, 1248013074u, 1257712402u, 1267477266u, 1278159505u, 1278159505u, 1278159505u, 1269049995u, 1265707611u, 1262430762u, 1258170882u, 1252207100u, 1252207100u, 1259284905u, 1268394398u, 1277503891u, 1283008794u, 1283008794u, 1283008794u, 1276193072u, 1269508349u, 1262823626u, 1252403423u, 1252403423u, 1252403423u, 1257318540u, 1268590724u, 1279928443u, 1291462669u, 1291462669u, 1291462669u, 1281959954u, 1276192724u, 1276192724u, 1263937379u, 1262429944u, 1260856972u, 1264199287u, 1261839938u, 1258890751u, 1247552916u, 1249191135u, 1249191135u, 1245521090u, 1234904396u, 1224222165u, 1205544596u, 1189029435u, 1189029435u, 1165174231u, 1173627674u, 1173627674u, 1334978083u, 1335828123u, 1336743872u, 1224415168u, 1210258422u, 1210258422u, 1186729501u, 1269305001u, 1269305001u, 1278611135u, 1271074672u, 1263472674u, 1262621153u, 1262621153u, 1262621153u, 1269895662u, 1275204045u, 1275204045u, 1277235719u, 1271468637u, 1265701555u, 1261704118u, 1273697378u, 1285690638u, 1311905054u, 1311905054u, 1311905054u, 1301222530u, 1306989531u, 1312756532u, 1318523663u, 1320292995u, 1320292995u, 1332745271u, 1357124453u, 1357124453u, 1340740313u, 1344279068u, 1347817824u, 1350504741u, 1350504649u, 1350504649u, 1369575604u, 1369575275u, 1369575275u, 1339363394u, 1331826582u, 1331826582u, 1331826582u, 1331826582u, \n1154625506u, 1149382684u, 1149382842u, 1149382842u, 1149382842u, 1149382684u, 1154625506u, 1159802792u, 1165176671u, 1165176671u, 1165176671u, 1159802792u, 1154625506u, 1154625506u, 1154625506u, 1154625506u, \n1276056033u, 1276056033u, 1276383662u, 1282216312u, 1288048962u, 1295913173u, 1297879168u, \n1307841736u, 1307841736u, 1284904123u, 1289425693u, \n1106978479u, 1106978479u, 1113008049u, 1135617953u, \n1203513120u, 1209149208u, 1209149208u, 1214850832u, 1214850832u, 1220814600u, 1220814680u, 1220814761u, 1220814842u, 1220814842u, \n843327092u, 843327092u, 828646783u, 810165826u, 810165826u, 824845890u, 829368034u, 834217733u, 834217733u, 839067431u, 840640263u, 840640263u, 842213096u, 842147560u, 839788185u, 843327092u, 843327092u, 843327092u, 843327092u, \n821372892u, 831858664u, 842803273u, 851716246u, \n816785465u, 811607973u, 790308782u, 790308782u, 798303954u, 821700390u, 821700390u, 821700390u, 821307270u, 821831604u, 822355939u, 816785465u, 816785465u, 816785465u, 816785465u, 816785465u, \n861809438u, 846801762u, 846146656u, 846146656u, 828320550u, 844376688u, 844376688u, 844376688u, 845490817u, 850668159u, 855911037u, 858532526u, 859581140u, 860629754u, 861809438u, 861809438u, 861809438u, 861809438u, 861809438u, \n816130164u, 816130164u, 784738323u, 785787284u, 785787284u, 799353037u, 815081770u, \n1134309285u, 1134309285u, 1139552051u, 1150758620u, \n1149382842u, 1149382842u, 1151938628u, 1157115913u, 1162358735u, 1165176671u, 1165176671u, \n1131753236u, 1115959050u, 1109012387u, 1109012387u, 1103572559u, 1127558692u, 1127558692u, 1127558692u, 1132473967u, 1132474008u, 1132474049u, 1131753236u, 1131753236u, 1131753236u, 1131753236u, 1131753236u, \n1129590795u, 1129590795u, 1108160756u, 1134375379u, 1134375379u, 1131557103u, 1141584038u, \n1166815556u, 1152790918u, 1159803517u, 1159803517u, 1130639851u, 1147220151u, 1147220151u, 1147220151u, 1152004293u, 1156657324u, 1161375890u, 1165242555u, 1165504743u, 1165766932u, 1166815556u, 1166815556u, 1166815556u, 1166815556u, 1166815556u, \n1232940973u, 1239101711u, 1216557424u, 1216557424u, 1224945898u, 1213345939u, 1213345939u, 1213345939u, 1215246435u, 1215246375u, 1215246316u, 1218654166u, 1222258639u, 1225863113u, 1232940973u, 1232940973u, 1232940973u, 1232940973u, 1232940973u, \n1086988670u, 1086988670u, 1076043996u, 1059725496u, 1043406996u, 1010442315u, 996810455u, \n938744089u, 938744089u, 960829766u, 978524296u, 996153290u, 1013454750u, 1031411614u, \n1003101269u, 1003101269u, 999627706u, 1016797970u, \n1091902450u, 1091902450u, 1086135128u, 1086134881u, \n1043078068u, 1043078068u, 1049303735u, 1049303584u, \n723853714u, 710877615u, 701899477u, 701899477u, 690233787u, 707862789u, 707862789u, 707862789u, 710091034u, 712974609u, 715858184u, 717955366u, 719397186u, 720839005u, 723853714u, 723853714u, 723853714u, 723853714u, 723853714u, \n771760817u, 758129385u, 753804272u, 753804272u, 744170262u, 755835440u, 755835440u, 755835440u, 759964212u, 763961934u, 767959656u, 769729171u, 771760817u, \n728505954u, 728505954u, 702553614u, 699866965u, 699866965u, 716513016u, 728506164u, \n807084426u, 804725278u, 804725278u, 802431665u, 802431665u, 813703752u, 817701307u, \n1112545835u, 1112545835u, 1117854043u, 1113397318u, \n1140922807u, 1140922807u, 1147607183u, 1125652418u, \n1146033974u, 1146033974u, 1134302968u, 1126504047u, \n1144525998u, 1144525998u, 1138693285u, 1132729412u, 1127814132u, 1119163334u, 1114510173u, \n1118376211u, 1118376211u, 1109266651u, 1094586557u, \n1043206312u, 1043206312u, 1032917007u, 1027149920u, 1021317296u, 1012863198u, 1019678982u, 1026494767u, 1029378333u, 1035538719u, 1041633569u, 1050349822u, 1043206312u, 1043206312u, 1043206312u, 1043206312u, \n1048908852u, 1013912620u, 1013912620u, 978916387u, 978916387u, 933893177u, 955191707u, 955191707u, 953750462u, 990581694u, 1027412926u, 1044386757u, 1044386757u, \n780538537u, 780538537u, 752489229u, 740495839u, 740495839u, 758780459u, 773001702u, \n765398948u, 765398948u, 743968580u, 734138268u, 734138268u, 740757171u, 763498201u, \n783355494u, 783355494u, 773918111u, 757206500u, 757206500u, 772345064u, 795676125u, \n823463457u, 823463457u, 820579625u, 805768401u, 805768401u, 824118435u, 836046304u, \n781323974u, 781323974u, 795676389u, 810225629u, \n1044976237u, 1044976237u, 1019744849u, 1014108809u, 1008472770u, 999494406u, 991498942u, 983503477u, 976163457u, 976163332u, 976163207u, 979505418u, 976490713u, 973476009u, 970199108u, 983830596u, 997462084u, 1008472160u, 1021120483u, 1033768805u, 1039404954u, 1047728022u, 1056051090u, 1060048782u, 1066012493u, 1072041741u, 1081675420u, 1081675420u, 1081675420u, 1079054226u, 1088360342u, 1097666458u, 1104351215u, 1110315059u, 1116278904u, 1113985326u, 1122308386u, 1130631446u, 1139937428u, 1139937428u, 1139937428u, 1135153471u, 1135612319u, 1136005614u, 1140593241u, 1140593354u, 1140593467u, 1141969977u, 1165235257u, 1165235257u, 1161893059u, 1144919215u, 1144919215u, 1142625503u, 1145967924u, 1149244809u, 1146951348u, 1169888952u, 1169888952u, 1165563761u, 1146296117u, 1146296117u, 1137973485u, 1160911146u, 1160911146u, 1155930612u, 1141250479u, 1141250479u, 1133648606u, 1150622458u, 1150622458u, 1131617273u, 1118968457u, 1106319641u, 1110645745u, 1124277378u, 1124277378u, 1100356803u, 1091312612u, 1091837064u, 1091837064u, 1092361516u, 1092361516u, 1076043027u, 1071389773u, 1066736519u, 1063722001u, 1061035102u, 1058413738u, 1051401455u, 1040063755u, 1040063755u, 1043078161u, 1043078068u, 1043078068u, 1026759951u, 998120752u, 998120752u, 1004477639u, 1003101269u, 1003101269u, 995499114u, 988159013u, 980818912u, 987831180u, 989797183u, 991828722u, 989141556u, 989141556u, \n1008474551u, 1008474551u, 990452244u, 983833197u, 977148614u, 971840331u, 949230354u, 949230354u, 957553382u, 965155404u, 972822963u, 986126654u, 986126654u, 986126654u, 966072729u, 947001990u, 929766236u, 916527859u, 916527859u, 920787644u, 925702679u, 934549951u, 949229870u, 938088728u, 938088728u, 919476472u, 920786966u, 920786966u, 936319111u, 963844139u, 970069989u, 976295839u, 992679834u, 1000281907u, 1007818445u, 1016665827u, 1028658904u, 1040651981u, 1048188449u, 1048188449u, 1048188449u, 1051727269u, 1044649397u, 1037505989u, 1024660987u, 1014896075u, 1005131162u, 997594549u, 994907616u, 992286219u, 989599292u, 978523692u, 978523692u, 984749574u, 984749455u, 984749337u, 982521048u, 993137886u, 1003820259u, 1041110243u, 1041110243u, 1041110243u, 1049040098u, 1049040018u, 1049105463u, 1041961872u, 1042420355u, \n978458542u, 978458542u, 929896120u, 909579324u, 889262529u, 843518080u, 843518080u, 843518080u, 829362229u, 838274850u, 847253008u, 837815749u, 834080232u, 830279178u, 825560620u, 821300757u, 817040894u, 812846728u, 806227506u, 799608284u, 798166446u, 792071684u, 785911386u, 778374792u, 781192880u, 784010968u, 778374866u, 773197482u, 768020098u, 760418008u, 764219153u, 767954763u, 761401380u, 771756045u, 782110710u, 792989606u, 793448467u, 793907328u, 808587512u, 793448707u, 778375439u, 770838828u, 771756429u, 772674030u, 780276527u, 788271741u, 796332492u, 812323282u, 817042034u, 821760786u, 828380100u, 828380100u, 829690794u, 829690794u, 831067024u, 831067024u, 836047950u, 835720391u, 838210741u, 838210741u, 840701090u, 842536278u, 842536278u, 844371466u, 847189479u, 847189479u, 850007493u, 850859681u, 850859681u, 851711869u, 856364877u, 856364877u, 861017884u, 861017884u, 862001139u, 863311931u, 865867813u, 865867813u, 868358159u, 868358159u, 869996688u, 877992209u, 885987731u, 916265674u, 916265674u, \n1079387665u, 1079387665u, 1071392249u, 1053042242u, 1002776352u, 1021454766u, 1034103319u, 1046751872u, 1064380967u, 1064380967u, 1064380967u, 1053764311u, 1039411929u, 1025059547u, 1022962432u, 1017326414u, 1012411281u, 1011690439u, 1011690439u, 997796770u, 996092645u, 996092645u, 995896069u, 993078082u, 987638619u, 982199157u, 981806032u, 981806032u, 967191467u, 963783418u, 956115703u, 948382453u, 949169033u, 949169033u, 940125045u, 935799571u, 933767902u, 931670698u, 927148632u, 919480949u, 911813267u, 911223543u, 911223543u, 908208876u, 903162540u, 896739875u, 896739875u, 892938679u, 882977218u, 874326476u, 872622716u, 870656749u, 868625246u, 861678386u, 860629753u, 859646657u, 855648900u, 851323520u, 846998140u, 842672784u, 843655752u, 844704255u, 854993379u, 863971726u, 872950073u, 852699481u, 840706385u, 828713289u, 828058022u, 820390306u, 812722590u, 816720076u, 816392319u, 816064563u, 818685986u, 820717554u, 822683585u, 820389741u, 821700364u, 823076523u, 832710375u, 836708112u, 840705848u, 842016483u, 842016483u, 839722614u, 846669394u, 850667086u, 854664778u, 859645530u, 861021903u, 862332740u, 871311237u, 878323686u, 885270599u, 917907446u, 928262138u, 938551294u, 953559095u, 966535227u, 979511359u, 972826493u, 968501068u, 964175644u, 963847996u, 961553929u, 959194326u, 933569993u, 933569993u, 930227556u, 931865867u, 931865867u, 900933141u, 891626839u, 891626839u, 912926060u, 930620440u, 930620440u, 930620440u, 915219503u, 897262592u, 877405132u, 884548202u, 884548202u, 884548202u, 899163064u, 925573977u, 901390859u, 937369987u, 937369987u, 937369987u, 931471814u, 933503551u, 934158953u, 935862938u, 939074257u, 951395236u, 976691955u, 990716502u, 1004741049u, 1026695602u, 1039016452u, 1051402838u, 1090724417u, 1090724417u, \n1010769636u, 1010769636u, 995172007u, 984162036u, 976625449u, 966205317u, 966205317u, 966205317u, 964501256u, 955522856u, 955522856u, 946216801u, 939859752u, 933568240u, 923213576u, 929898422u, 929898422u, 916594650u, 908926740u, 908926740u, 904273813u, 909254646u, 909254646u, 899620899u, 894246834u, 894246834u, 892608551u, 895950963u, 895950963u, 880615572u, 872947654u, 872947654u, 868294683u, 871309427u, 871309427u, 857677935u, 853024738u, 853024738u, 847978551u, 850337944u, 850337944u, 846012584u, 842997896u, 842997896u, 831332427u, 827728121u, 824058278u, 818356675u, 813048251u, 807739827u, 805380510u, 805708049u, 806035588u, 806035434u, 798433367u, 790765764u, 781459656u, 781459907u, 781460157u, 774775538u, 771760817u, 768746096u, 766452316u, 762454600u, 758456884u, 748823064u, 756097491u, 763437454u, 768090458u, 768090349u, 768090240u, 767762507u, 760815748u, 753803452u, 742465756u, 737157450u, 731849143u, 725819843u, 720839010u, 715858177u, 714875157u, 711205141u, 707535125u, 699211908u, 715202667u, 731127891u, 760422293u, 751771509u, 743120725u, 728506277u, 728506152u, 728506027u, 728506027u, 728506027u, 728506027u, 726474213u, 738467402u, 750460591u, 763109132u, 786439891u, 809705115u, 826351085u, 848305447u, 848305447u, 898833231u, 916593390u, \n1121328266u, 1121328266u, 1154227843u, 1163927522u, 1173561665u, 1225794419u, 1274094083u, 1322328212u, 1306729658u, 1264459011u, 1222122828u, 1242111683u, 1254432455u, 1254432455u, 1229135810u, 1221467718u, 1221467718u, 1191845701u, 1211834463u, 1211834463u, 1161895757u, 1208491380u, 1208491380u, 1183522156u, 1185553392u, 1185553392u, 1204821336u, 1222843542u, 1228807241u, 1228807241u, 1234770940u, 1234770940u, 1204492897u, 1250105767u, 1250105767u, 1233132278u, 1255086979u, 1276779535u, 1293294617u, 1307188525u, 1307319600u, 1307516212u, 1307712824u, 1307712824u, 1302010561u, 1274091886u, 1241454562u, 1193547359u, 1189221211u, 1183649663u, 1201409425u, 1265175953u, 1297681809u, 1303383075u, 1303383075u, 1322454261u, 1300237831u, 1300237831u, 1316687367u, 1324224234u, 1331761046u, 1339297858u, 1369509739u, 1369509739u, 1369510067u, 1350439113u, 1350439113u, 1350439204u, 1347752288u, 1344213532u, 1340674777u, 1357058917u, 1357058917u, 1332679735u, 1320227458u, 1320227458u, 1318458126u, 1312690996u, 1306923995u, 1301156994u, 1311773982u, 1311773982u, 1311773982u, 1285625102u, 1273631842u, 1261638581u, 1265636019u, 1271403101u, 1277170183u, 1275138509u, 1275138509u, 1269830125u, 1262555617u, 1262555617u, 1262555617u, 1263407138u, 1270943600u, 1278480062u, 1269173929u, 1269173929u, 1186663965u, 1210192886u, 1210192886u, 1224349631u, 1336678335u, 1335762587u, 1334912547u, 1173562138u, 1173562138u, 1165108695u, 1188963899u, 1188963899u, 1205413523u, 1224156629u, 1234773323u, 1245455554u, 1249125598u, 1249125598u, 1247421844u, 1258825215u, 1261774402u, 1264133750u, 1260791436u, 1262298871u, 1263871843u, 1276061652u, 1276061652u, 1281828882u, 1291397133u, 1291397133u, 1291397133u, 1279862907u, 1268525187u, 1257187467u, 1252337887u, 1252337887u, 1252337887u, 1262758089u, 1269442812u, 1276062000u, 1282943258u, 1282943258u, 1282943258u, 1277438355u, 1268328862u, 1259219369u, 1252141564u, 1252141564u, 1258105346u, 1262299690u, 1265642074u, 1268984459u, 1278093968u, 1278093968u, 1278093968u, 1267411729u, 1257646865u, 1247882001u, 1244539703u, 1244539703u, 1244539703u, 1247226677u, 1254108027u, 1260989376u, 1269181336u, 1269181336u, 1264528444u, 1243032679u, 1236348021u, 1229728898u, 1229466781u, 1229466781u, 1229466781u, 1235889299u, 1240149222u, 1244343609u, 1254305106u, 1254305106u, 1250307462u, 1237462432u, 1224813996u, 1212165560u, 1214131737u, 1214131818u, 1214131899u, 1215180491u, 1225141963u, 1235168971u, 1235824395u, 1235496800u, 1235169205u, 1230122945u, 1223831505u, 1217474529u, 1215180794u, 1214853207u, 1214525620u, 1209151655u, 1205153935u, 1201156215u, 1203187617u, 1202532152u, 1201876687u, 1192177403u, 1186541356u, 1180905308u, 1176907624u, 1177235357u, 1177563089u, 1178546331u, 1174876461u, 1171206590u, 1162228037u, 1161900284u, 1161572531u, 1158885523u, 1150562487u, 1142239452u, 1141256323u, 1133588538u, 1125920754u, 1131622390u, 1134243749u, 1136930644u, 1130573644u, 1131622147u, 1132605114u, 1132605026u, 1127951921u, 1123298817u, 1131621873u, 1134898620u, 1138240903u, 1149251004u, 1154887181u, 1160588894u, 1173892487u, 1176513835u, 1179200718u, 1184181316u, 1189882860u, 1195518867u, 1196174146u, 1192831782u, 1189554953u, 1186540237u, 1186540035u, 1186539833u, 1168190003u, 1159211648u, 1150233293u, 1138240205u, 1131293260u, 1124280778u, 1119300119u, 1119300289u, 1119300458u, 1130965996u, 1130965996u, 1115302968u, 1106324314u, 1106324314u, 1096297395u, 1098656901u, 1098656901u, 1089350656u, 1092627177u, 1092627177u, 1079978794u, 1077881846u, 1077881846u, 1076112116u, 1080568542u, 1097869782u, 1115171023u, 1088104305u, 1081026228u, 1073882616u, 1082795113u, 1089872576u, 1097015574u, 1056579437u, 1056579437u, \n3170970609u, 3166448673u, 3165072494u, 3165072572u, 3161009314u, 3155635343u, 3151113363u, 3156290752u, 3161468140u, 3161468240u, 3161468282u, 3159764405u, 3157405142u, 3170971094u, 3170971094u, 3184537046u, 3182177717u, 3180473722u, 3180473680u, 3180473580u, 3185650880u, 3190828179u, 3186306191u, 3180932258u, 3176869052u, 3176868974u, 3175492641u, 3170970609u, 3170970609u, 3170970609u, 3170970609u, \n610863775u, 610864498u, 652349060u, 668470670u, 680004830u, 676268770u, 639044263u, 645597958u, 648809344u, 644877245u, 637733930u, 615451482u, 615451232u, 600836704u, 600836704u, 586222176u, 586222426u, 563940394u, 556796861u, 552864640u, 556075783u, 562629287u, 525404898u, 521669854u, 533204366u, 549326468u, 590810482u, 590809759u, 600836767u, 600836767u, 610863775u, \n609225312u, 609225312u, 626003237u, 626003633u, 626003850u, 619450462u, 600838557u, 582226014u, 575672202u, 575671985u, 575671589u, 592448096u, 592448096u, 600836704u, 600836704u, 609225312u, \n1063192480u, 1063192303u, 1085474356u, 1092617857u, 1096550060u, 1093338890u, 1086785358u, 1124009765u, 1127744957u, 1116210496u, 1100088467u, 1058604385u, 1058604896u, 1048577888u, 1048577888u, 1038550880u, 1038550369u, 997065875u, 980944192u, 969409981u, 973145893u, 1010370382u, 1003816714u, 1000605356u, 1004537473u, 1011680820u, 1033963247u, 1033963424u, 1048577952u, 1048577952u, 1063192480u, \n1040189344u, 1040189344u, 1023411626u, 1023411346u, 1023411192u, 1029964642u, 1048576640u, 1067189090u, 1073742840u, 1073742994u, 1073743274u, 1056966560u, 1056966560u, 1048577952u, 1048577952u, 1040189344u, \n1048579584u, 1040387472u, 1038028000u, 1038027819u, 1030753383u, 1020988564u, 1012927626u, 1022168096u, 1031474108u, 1031473877u, 1031473779u, 1028393452u, 1024264608u, 1048578464u, 1048578464u, 1072892320u, 1068763628u, 1065683571u, 1065683669u, 1065683900u, 1074990112u, 1084230794u, 1076104340u, 1066404967u, 1059130411u, 1059130592u, 1056771472u, 1048579584u, 1048579584u, 1048579584u, 1048579584u, \n117835870u, 84280927u, 42272605u, 42272952u, 42273201u, 68487921u, 97520009u, 88476044u, 80546137u, 80546051u, 80545897u, 105908235u, 117508284u, 127862815u, 127862815u, 138151809u, 126551760u, 132711757u, 142804301u, 148440397u, 151782854u, 151586384u, 175178901u, 154206981u, 137888517u, 115147525u, 98502022u, 131991430u, 124913650u, 124913650u, 117835870u, \n121899129u, 121899129u, 77203257u, 58852897u, 48760199u, 43582635u, 41943808u, 69927705u, 84345704u, 94438402u, 112788762u, 133760964u, 133760964u, 127862815u, 127862815u, 121899129u, \n225316334u, 225905991u, 219417776u, 211029040u, 218958860u, 227937219u, 233180005u, 221776766u, 210504603u, 199822072u, 195234483u, 191171122u, 190581199u, 173411030u, 173411030u, 156175324u, 162663397u, 171117603u, 175639657u, 186322188u, 184421816u, 182783590u, 188943894u, 193727885u, 196087060u, 204475796u, 214371831u, 225316334u, 225316334u, 225316334u, 225316334u, \n169811929u, 217194457u, 235151954u, 219030344u, 207496184u, 174203839u, 170336647u, 176562667u, 184558108u, 188555744u, 195699059u, 182067231u, 165683231u, 165683008u, 165683008u, 165682785u, 182066785u, 195697933u, 188554400u, 184556644u, 176626837u, 170335481u, 174201537u, 207493768u, 219028280u, 235150382u, 217194151u, 169811623u, 169811776u, 169811776u, 169811929u, \n165683136u, 165683136u, 212148416u, 238100672u, 252321984u, 266215516u, 287121216u, 266214948u, 252321216u, 238099904u, 212147648u, 165682880u, 165682880u, 165683008u, 165683008u, 165683136u, \n58728256u, 66068163u, 77602463u, 89464479u, 85532208u, 82582940u, 83238176u, 90185133u, 96738875u, 111877691u, 118300219u, 127147532u, 132128205u, 132128576u, 132128576u, 132128947u, 127148148u, 118300741u, 111878213u, 96739397u, 90185939u, 83239264u, 82583781u, 85532752u, 89464801u, 77602785u, 66068413u, 58728256u, 58728256u, 58728256u, 58728256u, 0u );\nconst uvec2 boxes[] = uvec2[](\n  uvec2(995824755u,1005589728u),\n  uvec2(992285384u,1003361115u),\n  uvec2(915869339u,1169956144u),\n  uvec2(760483246u,978852549u),\n  uvec2(810159696u,821628783u),\n  uvec2(1040257625u,1042748034u),\n  uvec2(912857797u,918887149u),\n  uvec2(812786051u,1090792400u),\n  uvec2(821372841u,851716246u),\n  uvec2(699272227u,1369584062u),\n  uvec2(1149382495u,1165177018u),\n  uvec2(1276055680u,1297879521u),\n  uvec2(1284903709u,1307841736u),\n  uvec2(1106978479u,1135617969u),\n  uvec2(1203513096u,1220814842u),\n  uvec2(810165631u,843327271u),\n  uvec2(821372892u,851716246u),\n  uvec2(790308562u,822356025u),\n  uvec2(828320368u,861809760u),\n  uvec2(784738323u,816130452u),\n  uvec2(1134309084u,1150758821u),\n  uvec2(1149382495u,1165177018u),\n  uvec2(1103572516u,1132474275u),\n  uvec2(1108160523u,1141584339u),\n  uvec2(1130639506u,1166815869u),\n  uvec2(1213345709u,1239101808u),\n  uvec2(996810455u,1086988670u),\n  uvec2(938743710u,1031412038u),\n  uvec2(999627538u,1016798293u),\n  uvec2(1086134881u,1091902450u),\n  uvec2(1043077664u,1049303988u),\n  uvec2(690233605u,723854037u),\n  uvec2(744170032u,771761136u),\n  uvec2(699866638u,728506197u),\n  uvec2(802431370u,817701553u),\n  uvec2(1112545350u,1117854251u),\n  uvec2(1125652418u,1147607479u),\n  uvec2(1126504047u,1146033974u),\n  uvec2(1114510173u,1144525998u),\n  uvec2(1094586557u,1118376211u),\n  uvec2(1012862991u,1050349871u),\n  uvec2(933892507u,1048908857u),\n  uvec2(740495839u,780538637u),\n  uvec2(734138035u,765398948u),\n  uvec2(757206248u,795676262u),\n  uvec2(805768355u,836046369u),\n  uvec2(781323974u,810225629u),\n  uvec2(970198684u,1169890608u),\n  uvec2(916525699u,1051728732u),\n  uvec2(760417710u,978459338u),\n  uvec2(812720515u,1090726864u),\n  uvec2(699210478u,1010770674u),\n  uvec2(1056574499u,1369518526u),\n  uvec2(3151113201u,3190828502u),\n  uvec2(521669216u,680005252u),\n  uvec2(575670880u,626004381u),\n  uvec2(969409683u,1127745440u),\n  uvec2(1023410816u,1073743776u),\n  uvec2(1012926880u,1084231168u),\n  uvec2(42271493u,175180529u),\n  uvec2(41943808u,133761145u),\n  uvec2(156174799u,233180774u),\n  uvec2(165681800u,235152376u),\n  uvec2(165682624u,287121600u),\n  uvec2(58727712u,132129120u)\n);\nconst int paths[] = int[](\n  14,28,570,800,820,852,890,1216,1248,2288,2320,2334,2342,2350,2370,2408,2416,2448,2486,2500,2508,2522,2554,2568,2606,2644,2658,2672,2680,2688,2696,2734,2760,2774,2788,2796,2804,2812,2826,2834,2866,2892,2906,2920,2934,2948,2956,3174,3308,3478,3768,3980,4546,4608,4670,4702,4764,4796,4858,4920,4952,5014,5076,5108,5170);\n\nconst int colors[boxes.length()] =\n  int[](7,7,6,6,0, 0,0,6,0,6, 0,0,0,0,0, 8,0,8,8,8, 0,0,8,8,8, 8,0,0,0,0,\n        0,8,8,8,8, 0,0,0,0,0, 4,8,8,8,8, 8,0,0,0,0, 0,0,0,\n        6,6,6,6,6, 6,6,6,6,6, 6,6);\n\nvec3 getcolor(int i) {\n  vec3 col = vec3(1,0,1);\n  // Colors from Wikipedia SVG\n  if (i == 0) col = vec3(0xa0,0,0)/255.0;\n  if (i == 1) col = vec3(0x0a,0x26,0x62)/255.0;\n  if (i == 2) col = vec3(0xff,0xd1,0x28)/255.0;\n  if (i == 3) col = vec3(0xff,0xd2,0x14)/255.0;\n  if (i == 4) col = vec3(0);\n  if (i == 5) col = vec3(0xa0,0,0)/255.0;\n\n  if (i == 6) col = vec3(0xb4,0,0x1e)/255.0;\n  if (i == 7) col = vec3(1);\n  if (i == 8) col = vec3(0x1e,0x82,0xd2)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\n// The frame, easier to draw separately\nconst vec4 frame[] =\n  vec4[](vec4(36.500000,38.500122,463.500000,211.499939),\n         vec4(41.500000,43.500122,458.500000,206.499939),\n         vec4(26.500000,28.500122,473.500000,221.499939),\n         vec4(31.500000,33.500122,468.500000,216.499939));\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// The Royal Banner of Scotland, Matthew Arcus, mla. 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// https://en.wikipedia.org/wiki/Royal_arms_of_England, first used by Richard I\n// around 1198. This forms two quarters of what usually known as the Royal\n// Standard (but should really be the \"Royal Banner\").\n//\n// Filled cubic Bezier curves, taken from the Wikipedia SVG, drawn as sequences\n// of line segments, with some bounding boxes to stop things being too slow.\n// Using line segments makes it easy to compute filling with the usual winding\n// number calculation.\n//\n// Since the lions overlap slightly in the y-direction, we draw everything\n// twice in the overlapping region (which isn't wide). The code to do this\n// is a little ad hoc.\n//\n// I've tried various other speedups, but nothing that makes a huge amount of\n// difference (I get an adequate 37fps on my Intel box at 512x288). \n// Precalculating the segment bounding boxes doesn't help much & increases\n// the amount of static data considerably. Scanning all the bounding boxes\n// and making a list of boxes to revisit doesn't help much either.\n//\n// On Nvidia, omitting the const modifiers for the static data greatly increases\n// compilation time (which is about 4 seconds for GTX1650/Linux/FF).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = 2.0*fragCoord/iResolution.xy;\n  if (p.x > 1.0 || p.y > 1.0) discard;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p -= mouse;\n    p *= 0.25;\n    p += mouse;\n  }\n  //vec2 p = fragCoord/iResolution.xy;\n  //p *= 4.0;\n  p.y = 1.0-p.y;\n  p *= vec2(500,250);\n  vec3 col = getcolor(2);\n  float eps = 2.0; // Allow for line width \n  float px = fwidth(p.x);\n  float lwidth = 0.5;\n  int N = paths.length();\n  if (key(CHAR_X)) N = min(int(2.0*iTime),N); // Progressive effect\n  for (int i = 0; i < N; i++) {\n    if (i == 52) p = quarter(p);\n    vec4 box = decode(boxes[i]);\n    if ((p.x >= box.x-eps && p.x <= box.z+eps && p.y >= box.y-eps && p.y <= box.w+eps)) {\n      //assert(i != N-1); // With progressive drawing, show bounding boxes\n      int start = i == 0 ? 0 : paths[i-1];\n      int end = paths[i];\n      vec2 initpos = decode(points[start/2]); //vec2(points[start],points[start+1]);\n      vec2 p0 = initpos;\n      wind = 0;\n      float d = 1e8;\n      for (int j = start+2; j < end; j += 6) {\n        vec2 c0 = decode(points[(j+0)/2]);//vec2(points[j+0],points[j+1]);\n        vec2 c1 = decode(points[(j+2)/2]);//vec2(points[j+2],points[j+3]);\n        vec2 p1 = decode(points[(j+4)/2]);vec2(points[j+4],points[j+5]);\n        vec2 box1 = min(min(c0,c1),min(p0,p1))-eps;\n        vec2 box2 = max(max(c0,c1),max(p0,p1))+eps;\n        if (p.x < box1.x || p.y  < box1.y  || p.x > box2.x || p.y > box2.y) {\n          polywind(p,p0,p1);\n        } else {\n          d = min(d,bezier(p,mat4x2(p0,c0,c1,p1)));\n        }\n        p0 = p1;\n      }\n      polywind(p,p0,initpos); // Close curve if necessary\n      if (colors[i] != 0 && (wind&1) == 1) col = getcolor(colors[i]);;\n      col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n    }\n  }\n  // Draw frame\n  //p = quarter(p);\n  for (int i = 0; i < frame.length(); i+=2) {\n    vec4 outer = frame[i]; // (x0,y0,x1,y1)\n    vec4 inner = frame[i+1]; // (x0,y0,x1,y1)\n    if (inrect(p,outer) && !inrect(p,inner)) {\n      col = getcolor(6);\n    }\n  }\n  for (int i = 0; i < frame.length(); i++) {\n    vec4 rect = frame[i]; // (x0,y0,x1,y1)\n    col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.xy,rect.xw)-lwidth));\n    col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.xy,rect.zy)-lwidth));\n    //col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.zy,rect.zw)-lwidth));\n    //col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.xw,rect.zw)-lwidth));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = 1.0-col;\n  fragColor = vec4(col,1);\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const uint points[] = uint[](\n1023086715u, 1011159039u, 998510476u, 978587518u, 1008602819u, 1029115677u, 1051070385u, \n985666026u, 966398367u, 947196298u, 927928841u, 939593872u, 960761860u, 994513073u, \n1002115894u, 979178328u, 966398998u, 958076183u, 983110749u, 1002640464u, 1021908041u, \n1083577444u, 1081742612u, 1078334958u, 1067652746u, 1093473820u, 1107105133u, 1113855129u, \n1785270954u, 1759777642u, 1765676107u, 1771443499u, 1781535785u, 1793987495u, 1806504746u, \n161419226u, 137170948u, 120328394u, 105714012u, 129700117u, 148246786u, 163516753u, \n170003789u, 162860154u, 142805951u, 114298160u, 138218803u, 156831215u, 172035646u, \n203754858u, 197397685u, 189205519u, 173804453u, 195169197u, 215288779u, 218762517u, \n277875495u, 262474507u, 249629471u, 232590172u, 239602306u, 248187319u, 272763275u, \n259393533u, 250349361u, 237831859u, 221120151u, 237962775u, 256050653u, 280430337u, \n292881882u, 291898653u, 281609340u, 259589120u, 287114206u, 306512942u, 313001264u, \n341050963u, 345245127u, 350553419u, 348062817u, 362284183u, 367396171u, 362940036u, \n1838027821u, 1823085797u, 1826428346u, 1833440916u, 1841698230u, 1850021158u, 1858344109u, \n1954419137u, 1974407631u, 1986007417u, 1990398157u, 1969885389u, 1969885389u, 1949372621u, \n1922569334u, 1934300523u, 1953961237u, 1973621949u, 1958679702u, 1946096726u, 1941967806u, 1929843668u, 1923814421u, 1922569334u, 1922569334u, 1922569334u, 1922569334u, \n230626207u, 215815145u, 204674126u, 190780659u, 191370239u, 193860367u, 215093833u, \n1180503058u, 1179454798u, 1180044935u, 1225723757u, 1186533534u, 1127157977u, 1068503257u, 1037569649u, 1008799532u, 1007751385u, 996675788u, 991367272u, 973017192u, 961613928u, 944181908u, 998183572u, 972100989u, 1057625295u, 1072501611u, 1057232226u, 1124144509u, 1132401731u, 1147999248u, 1151603566u, 1159074544u, 1159271491u, 1153504497u, 1147934117u, 1183126904u, 1207374844u, 1227821685u, 1229460396u, 1221334176u, 1211176326u, 1260721568u, 1267209220u, 1273369189u, 1281823508u, 1283003351u, 1276646574u, 1313543271u, 1309545223u, 1326649931u, 1342575004u, 1375408661u, 1375408234u, 1375407833u, 1319964575u, 1319964177u, 1319963971u, 1340148952u, 1356598355u, 1343818658u, 1343818658u, 1331038961u, 1255738241u, 1255738241u, 1180503058u, 1180503058u, 1180503058u, 1180503058u, \n1007751385u, 1022693622u, 1033441533u, 1048383722u, \n998183572u, 1031738001u, 1031738001u, 1065292431u, \n829229832u, 959712008u, 1361708536u, 1458963960u, 1536951800u, 1610614452u, 1610614852u, 1610615377u, 1463159089u, 1405028657u, 1124534577u, 765791924u, 649792596u, 620564242u, 620564242u, 591335888u, 816322184u, 936971319u, 1186729015u, 1237453879u, 1299647990u, 1330449397u, 1410666918u, 1598885501u, 1730154109u, 1796148861u, 1831669545u, 1847595308u, 1725764012u, 1793528988u, 1832457197u, 1853625737u, 1875777101u, 1901794221u, 1911559533u, 1964774551u, 1940722243u, 1972113891u, 1959464894u, 1941966715u, 1963921181u, 1933577720u, 1893994051u, 1902906802u, 1904086279u, 1943997665u, 1923025872u, 1891175310u, 1852312528u, 1860963164u, 1869613746u, 1878264320u, 1802701172u, 1813974050u, 1784548386u, 1761676322u, 1765018356u, 1730153204u, 1679756020u, 1605832456u, 1440418462u, 1628310548u, 1669597185u, 1771243484u, 1729890121u, 1686898529u, 1641416831u, 1630209532u, 1583940878u, 1475151118u, 1342440718u, 1185089423u, 1127483279u, 1097926543u, 1075840599u, 1023346329u, 1035929391u, 1047267269u, 1046939739u, 1018562350u, 985138967u, 951650054u, 966985628u, 968558642u, 968362184u, 936576960u, 904857385u, 873072595u, 911476932u, 912460211u, 829229491u, \n598741454u, 608834190u, 607392630u, 606934106u, 586290292u, 576001058u, 566039500u, 555160846u, 539039009u, 521147709u, 521737377u, 521213089u, 519050245u, 505943323u, 482088370u, 457774468u, 464327864u, 460919857u, 456790960u, 445584571u, 430052736u, 402593156u, 404821243u, 408294521u, 402592716u, 385357163u, 361698635u, 339285380u, 346952940u, 350688341u, 347476926u, 323163325u, 298194222u, 268506315u, 279647345u, 290329617u, 294851421u, 276501477u, 238359623u, 245895837u, 236917858u, 196940743u, 195695209u, 170463967u, 138482114u, 158076797u, 130420367u, 163318705u, 191106421u, 207752368u, 229248064u, 229248468u, 229249221u, 344134288u, 373166054u, 342560900u, 314577093u, 300355370u, 313331474u, 326045426u, 333581892u, 290721476u, 276237830u, 277548180u, 289344693u, 300616880u, 309726226u, 293473406u, 286395281u, 303631169u, 259460228u, 260311428u, 270338368u, 230361191u, 263521907u, 287770281u, 270402969u, 330826615u, 332531246u, 360645954u, 387385010u, 359139289u, 320145775u, 370674970u, 386469338u, 419172201u, 457183229u, 501944351u, 541790220u, 541790220u, 581636090u, 590221540u, 590221540u, 598741454u, 598741454u, 598741454u, 598741454u, \n225579543u, 214700579u, 204214838u, 195695209u, \n230625608u, 202248455u, 186650498u, 158076797u, \n191106421u, 210898572u, 210898572u, 230625188u, \n270338368u, 280889567u, 287639925u, 295504324u, \n287770281u, 297928425u, 305072054u, 300550233u, \n332138076u, 334497415u, 339806053u, 338430058u, \n318116149u, 374673849u, 434573699u, 487461077u, \n602080847u, 613942485u, 639566649u, 637535933u, 654575007u, 672597368u, 658311087u, 679216794u, 688326519u, 667748776u, 696322303u, 693308623u, 659754122u, 668733093u, 656150753u, 629411609u, 650121366u, 608048000u, 590614847u, 572068614u, 553522152u, 534974806u, 513676166u, 470552824u, 496177026u, 467276044u, 463474240u, 492440795u, 492178644u, 492178644u, 491850957u, 466292010u, 485821126u, 502663917u, 504498822u, 502663752u, 505154066u, 473499998u, 501679463u, 529663811u, 535758181u, 544736360u, 561907319u, 576979933u, 595067983u, 602080847u, 602080847u, 602080847u, 602080847u, \n519243790u, 508495685u, 504105108u, 511838517u, \n658770601u, 676661796u, 669059963u, 661523421u, \n541722601u, 557254849u, 571214054u, 584517831u, 570034805u, 538643014u, 541722601u, 541722601u, 541722601u, 541722601u, \n568331043u, 580913912u, 591006500u, 597756866u, 592186414u, 583732351u, 573770947u, 573836344u, 576523182u, 568331043u, 568331043u, 568331043u, 568331043u, \n541265141u, 537464242u, 538447502u, 523243339u, 551161637u, 569184112u, 591269976u, 587075412u, 591924840u, 609095013u, 587796052u, 584322395u, 573377762u, 562629895u, 551947549u, 541265141u, 541265141u, 541265141u, 541265141u, \n548539647u, 548408969u, 544608127u, 540938430u, 560467932u, 572919728u, 595987904u, 586091916u, 579669288u, 574098617u, 566693100u, 558763282u, 548539647u, 548539647u, 548539647u, 548539647u, \n510987088u, 519506768u, 519506768u, 528026448u, 527437121u, 548736312u, 575147194u, 594546215u, 606998025u, 614272194u, 633146851u, 642780517u, 651168938u, \n1278413538u, 1307642584u, 1322584909u, 1330449397u, \n1851658771u, 1852379878u, 1845564208u, 1832326118u, \n1885868366u, 1885868648u, 1899303550u, 1901728681u, \n1909264578u, 1913065855u, 1909658190u, 1940197964u, \n1942687613u, 1928990585u, 1924272030u, 1916735415u, \n830016264u, 690227976u, 777586242u, 726598657u, 731972620u, 765068248u, 770573961u, 790103463u, 820642999u, 863241339u, 975832029u, 1232274802u, 1298859378u, 1417086322u, 1474691297u, 1543635318u, 1506411095u, 1479214178u, 1447298309u, 1506608389u, 1672610053u, 1746404263u, 1613103835u, 1507264676u, 1408370466u, 1415055233u, 1424951234u, 1440745421u, 1381304773u, 1349191514u, 1192298008u, 1119880579u, 1027671400u, 902301032u, 781059432u, 726075827u, 830015923u, \n1090720486u, 1083708157u, 1074336564u, 1071649663u, \n1124864841u, 1124733888u, 1127552015u, 1132467265u, \n648612487u, 627968613u, 616827358u, 609356079u, 598674168u, 622070850u, 648612487u, 648612487u, 648612487u, 648612487u);\nconst uvec2 boxes[] = uvec2[](\n  uvec2(978587331u,1051070587u),\n  uvec2(927928324u,994513417u),\n  uvec2(958075702u,1021908247u),\n  uvec2(1067652196u,1113855626u),\n  uvec2(1759777450u,1806505259u),\n  uvec2(105713626u,163516764u),\n  uvec2(114297791u,172035646u),\n  uvec2(173804453u,218762602u),\n  uvec2(232589707u,277875548u),\n  uvec2(221119965u,280430589u),\n  uvec2(259589086u,313001434u),\n  uvec2(341050465u,367396484u),\n  uvec2(1823085613u,1858344596u),\n  uvec2(1949372621u,1990398415u),\n  uvec2(1922569150u,1973622123u),\n  uvec2(190779977u,230626547u),\n  uvec2(944179953u,1375409573u),\n  uvec2(1007751385u,1048383741u),\n  uvec2(998183567u,1065292436u),\n  uvec2(591332622u,1972115080u),\n  uvec2(130417527u,608834994u),\n  uvec2(195695127u,225579625u),\n  uvec2(158076797u,230625608u),\n  uvec2(191106421u,230625188u),\n  uvec2(270338271u,295504324u),\n  uvec2(287770281u,305072217u),\n  uvec2(332138076u,339806314u),\n  uvec2(318116053u,487461305u),\n  uvec2(463471417u,696325096u),\n  uvec2(504104773u,519244085u),\n  uvec2(658770468u,676662237u),\n  uvec2(538642409u,584518261u),\n  uvec2(568331000u,597757123u),\n  uvec2(523242722u,609095768u),\n  uvec2(540937401u,595988670u),\n  uvec2(510987088u,651169319u),\n  uvec2(1278413528u,1330449397u),\n  uvec2(1832325651u,1852380134u),\n  uvec2(1885868366u,1901728681u),\n  uvec2(1909264578u,1940197966u),\n  uvec2(1916735353u,1942687671u),\n  uvec2(690225377u,1746406152u),\n  uvec2(1071649510u,1090720639u),\n  uvec2(1124733769u,1132467265u),\n  uvec2(598673711u,648612930u)\n);\nconst int paths[] = int[](\n  14,28,42,56,70,84,98,112,126,140,154,168,182,196,222,236,358,366,374,556,750,758,766,774,782,790,798,806,904,912,920,940,966,1004,1036,1062,1070,1078,1086,1094,1102,1176,1184,1192,1212);\n\nconst int colors[boxes.length()] =\n  int[](1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,1, 1,2,2,2,2, 2,0,0,0,0,\n        0,0,0,3,0, 0,4,4,5,1, 0,0,0,0,0, 2,3,0,0,4);\n\nvec3 getcolor(int i) {\n  vec3 col = vec3(1,0,1);\n  // Colors from Wikipedia SVG\n  if (i == 0) col = vec3(0xa0,0,0)/255.0;\n  if (i == 1) col = vec3(0x0a,0x26,0x62)/255.0;\n  if (i == 2) col = vec3(0xff,0xd1,0x28)/255.0;\n  if (i == 3) col = vec3(0xff,0xd2,0x14)/255.0;\n  if (i == 4) col = vec3(0);\n  if (i == 5) col = vec3(0xa0,0,0)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// The Royal Banner of England, Matthew Arcus, mla. 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// https://en.wikipedia.org/wiki/Royal_arms_of_England, first used by Richard I\n// around 1198. This forms two quarters of what usually known as the Royal\n// Standard (but should really be the \"Royal Banner\").\n//\n// zoom in with mouse\n// 'x' draws progressively\n//\n// Filled cubic Bezier curves, taken from the Wikipedia SVG, drawn as sequences\n// of line segments, with some bounding boxes to stop things being too slow.\n// Using line segments makes it easy to compute filling with the usual winding\n// number calculation.\n//\n// Since the lions overlap slightly in the y-direction, we draw everything\n// twice in the overlapping region (which isn't wide). The code to do this\n// is a little ad hoc.\n//\n// I've tried various other speedups, but nothing that makes a huge amount of\n// difference (I get an adequate 37fps on my Intel box at 512x288). \n// Precalculating the segment bounding boxes doesn't help much & increases\n// the amount of static data considerably. Scanning all the bounding boxes\n// and making a list of boxes to revisit doesn't help much either.\n//\n// [Looks like accessing large amounts of static data is slow, so I've\n// encoded all of the coordinate pairs as 16 bit fixed point integers,\n// packed into 32 bit uints. This gets FPS (on Intel) up to 60 at 512x288].\n//\n// On Nvidia, omitting the const modifiers for the static data greatly increases\n// compilation time (which is about 4 seconds for GTX1650/Linux/FF) [now less\n// than a second with the fixed point data change].\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = 2.0*fragCoord/iResolution.xy;\n  if (p.x > 1.0 || p.y > 1.0) discard;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p -= mouse;\n    p *= 0.25;\n    p += mouse;\n  }\n  p.y = 1.0-p.y;\n  p *= vec2(500,250);\n  vec3 col = getcolor(0);\n  float eps = 2.0; // Allow for line width \n  float px = fwidth(p.x);\n  float lwidth = 0.5;\n  // The lions overlap in the y direction, so draw twice, with a shift up,\n  // where necessary. This is a bit of a bodge\n  int M = 2;\n  if (p.y < 77.0) M = 1;\n  else if (p.y < 154.0) p.y -= 77.0;\n  else p.y -= 154.0;\n  if (p.y > 15.0) M = 1; // Draw twice only in a thin band\n  //assert(M == 1); // Check banding\n  for (int j = 0; j < M; j++, p.y += 77.0) {\n    int N = paths.length();\n    if (key(CHAR_X)) N = min(int(2.0*iTime),N); // Progressive effect\n    for (int i = 0; i < N; i++) {\n      vec4 box = decode(boxes[i]);\n      if (p.x >= box.x-eps && p.x <= box.z+eps && p.y >= box.y-eps && p.y <= box.w+eps) {\n        //assert(i != N-1); // With progressive drawing, show bounding boxes\n        int start = i == 0 ? 0 : paths[i-1];\n        int end = paths[i];\n        vec2 initpos = decode(points[start/2]); //vec2(points[start],points[start+1]);\n        vec2 p0 = initpos;\n        wind = 0;\n        float d = 1e8;\n        for (int j = start+2; j < end; j += 6) {\n          vec2 c0 = decode(points[(j+0)/2]);//vec2(points[j+0],points[j+1]);\n          vec2 c1 = decode(points[(j+2)/2]);//vec2(points[j+2],points[j+3]);\n          vec2 p1 = decode(points[(j+4)/2]);vec2(points[j+4],points[j+5]);\n          vec2 box1 = min(min(c0,c1),min(p0,p1))-eps;\n          vec2 box2 = max(max(c0,c1),max(p0,p1))+eps;\n          if (p.x < box1.x || p.y  < box1.y  || p.x > box2.x || p.y > box2.y) {\n            polywind(p,p0,p1);\n          } else {\n            d = min(d,bezier(p,mat4x2(p0,c0,c1,p1)));\n          }\n          p0 = p1;\n        }\n        polywind(p,p0,initpos); // Close curve if necessary\n        if (colors[i] != 0 && (wind&1) == 1) col = getcolor(colors[i]);;\n        col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n      }\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = 1.0-col;\n  fragColor = vec4(col,1);\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\n// The usual function, but also include segment in winding number computation\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  polywind(p,q,r);\n  p -= q; r -= q; // Relative to q\n  float t = dot(p,r)/dot(r,r);\n  t = clamp(t, 0.0, 1.0);\n  return length(p-t*r);\n}\n\nvec4 beziercoeff(int i, int N) {\n  // Matrix formulation due to Shane.\n  float t = float(i)/float(N);\n  float u = 1.0-t, t2 = t*t, u2 = u*u;\n  return vec4(u*u2,3.0*t*u2,3.0*u*t2,t*t2);\n}\n\n// Distance to Cubic Bezier.\n// Split the path into N subsegments.\nfloat bezier(vec2 p, mat4x2 m) {\n  // Since we spend most of the time deciding not to draw\n  // curves, the value of N doesn't seem to be time critical.\n  int N = 16;\n  vec2 q = m[0];\n  float d = 1e8;\n  for (int i = 1; i <= N; i++) {\n    vec2 r = m*beziercoeff(i,N);\n    d = min(d,segment(p,q,r));\n    q = r;\n  }\n  return d;\n}\n\nvec2 decode(uint n) {\n  return vec2(n>>16,n&0xffffu)/64.0;\n}\n\nvec4 decode(uvec2 p) {\n  return vec4(decode(p.x),decode(p.y));\n}\n\nbool inrect(vec2 p, vec4 rect) {\n  return p.x >= rect.x && p.x <= rect.z && p.y >= rect.y && p.y <= rect.w;\n}\n\nvec2 quarter(vec2 p) {\n  p -= vec2(250,125);\n  p = -abs(p);\n  p += vec2(250,125);\n  return p;\n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1097, 1097, 1149, 1199, 1506]], "test": "untested"}
{"id": "7dSyDR", "name": "Reaction Diffusion - 138 chars", "author": "benoitM", "description": "Fast and Dirty Reaction Diffusion using only mipmaps for the convolutions (blur and high pass filter)\nPlenty of artefacts due to mipmaps and the image init is really dirty (buffer B) ... but it works.\n\n\n", "tags": ["2d", "diffusion", "organic", "highpass", "onetweet", "golf", "reaction", "mipmaps"], "likes": 8, "viewed": 317, "published": 3, "date": "1643322227", "time_retrieved": "2024-07-30T17:06:52.063674", "image_code": "// Fork of \"Moving ReactDiff - 162c - fixed\" by benoitM. https://shadertoy.com/view/stG3z1\n// Now 134 chars < one tweet ;) -  Many Thanks to Xor & Fabrice Neyret for their tips\n\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n//     Fast & Simple & Dirty Reaction Diffusion Pattern                //\n//                                                                     //\n//             Copyright Benoit Marini - 01/2022                       //     \n//             License Creative Commons Attribution                    //\n//         NonCommercial-ShareAlike 3.0 Unported License.              //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// Inspired by https://www.youtube.com/watch?v=ga1xt5zkmPI             //\n// Trying to use only mipmaps for \"Kernel operations\", knowing that    //\n// mipmaps are far from gaussian blur...                               //\n// High pass filter from iq  (shadertoy.com/view/XsX3zj)               //\n// Noise in Buffer B is only here for initial pertubation              //\n//                                                                     //\n//                                                                     //  \n//  ////////  Buffer A  ////////            //////  Buffer B  //////   //\n//  //                        //       \\\\   //                    //   //\n//  // 1) High pass filter B  //   \\\\\\\\\\\\\\  // 1) Blur  A         //   //\n//  // 2) Threshold B         //   ///////  // 2) Add  noise      //   //\n//  //                        //       //   //                    //   //\n//  ////////////////////////////            ////////////////////////   //\n//                                                                     //\n//                /\\                                   ////            //\n//               //\\\\                                  ////            //\n//              ///\\\\\\                                 ////            //\n//               ////                                  ////            //\n//               //////////////////////////////////////////            //\n//               //////////////////////////////////////////            //\n//                                                     ////            //\n//                                                    \\\\\\///           //\n//                                                     \\\\//            //\n//                                                      \\/             //\n//                                                                     //\n//                                            //////   Image  //////   //\n//                                            //                  //   //\n//                                            //      Buffer A    //   //\n//                                            //                  //   //\n//                                            //////////////////////   //\n//                                                                     //        \n/////////////////////////////////////////////////////////////////////////  \n\n\nM\n    T);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////\n// high pass filter & threshold of Buffer B //\n//////////////////////////////////////////////\n\nM    \n    step( T,4.5) , T) );\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//////////////////////////////////////\n// blur buffer A +  perturbation    //\n//////////////////////////////////////\n\nM\n     T,3.5) * i.x * i.y; \n     //T,3.5) * i.y; // 134 char version but not working on all plateform\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 i ) { o=\n#define T texture(iChannel0,i/iResolution.xy*.99", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSyDR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "fsSyDz", "name": "MIPmap impulse response (via cub", "author": "FabriceNeyret2", "description": "Mouse control.\nVisualize the MIPmap LOD footprint of 1 pixel at mouse location (impulse response).\nCubeMap offers power-of-2 1024x1024 faces, so MIPmap is not buggy as in other buffers.\nBut: \n- only half floats\n- MaxLOD is bilinearly interpolated\n- no vfl", "tags": ["cubemap", "mipmap", "footprint"], "likes": 8, "viewed": 305, "published": 3, "date": "1643306353", "time_retrieved": "2024-07-30T17:06:53.292388", "image_code": "#define hue(v)  vec4( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) ,1 )\n\n\nvoid mainImage( out vec4 O, vec2 u ) \n{\n    vec2  U = ( 2.*u - R ) / R.y;\n    O-=O;\n    for( float l=0. ; l<=10.; l++ )   \n      O += (1.-O.a) * float ( M(U,l).w > 0. ) * hue(l/11.);   \n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    O-=O;\n    if ( D.z < max(abs(D.x),abs(D.y)) ) return;\n    U.y = 1024. - U.y;              // like buffA, but 1024 x 1024.\n    \n    vec2 M = length(iMouse.xy)>10. \n               ? iMouse.xy*1024./texelFetch(iChannel0,ivec2(0),0).xy\n               : 512.+512.*cos(iTime*vec2(.31,1));\n    O = vec4( 0,0,0, floor(U) == floor(M)  ); \n}", "cube_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R  iResolution.xy\n#define M(U,l)   textureLod( iChannel1, vec3(U,1), l  )   // access density map\n", "buffer_a_code": "// just to carry iResolution to CubeMap\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.xyz = iResolution;\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 111, 111, 259]], "test": "untested"}
{"id": "ss2czz", "name": "Lightness vs brilliance", "author": "bjornornorn", "description": "An animation switching between a metric inspired by brilliance/blackness and lightness (in Oklab), showing sRGB colors of max saturation next to grayscale colors of the same intensity.", "tags": ["brilliancelightness"], "likes": 5, "viewed": 690, "published": 3, "date": "1643303737", "time_retrieved": "2024-07-30T17:06:54.637791", "image_code": "vec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit, the limit of reflectance color intensity\n    // \n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 compute(float L, float hue, float sat)\n{\n    vec3 c;\n    c.x = L;\n    c.y = sat*cos(hue);\n    c.z = sat*sin(hue);\n    \n    float l_ = 0.0 + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = 0.0 - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = 0.0 - 0.0894841775f * c.y - 1.2914855480f * c.z;\n    \n    vec3 lms = vec3(l_,m_,s_);\n    \n    if (sat > 0.001)\n    {\n        vec2 CP = findCenterAndPurity(lms); \n\n        lms -= (0.5-0.5*cos(0.2*iTime*2.0*3.1415932))*(CP.x + 1.0*CP.y);   \n        //lms -= CP.x;\n        \n        lms += c.x;\n\n    }\n    else\n    {\n        lms += c.x;\n    }\n    \n    lms = lms*lms*lms;\n    \n    float l = lms.x;\n    float m = lms.y;\n    float s = lms.z;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n \n    //rgbResult *= c.x*c.x*c.x/dot(vec3(0.2126,0.7152,0.0722),rgbResult); \n    \n    return rgbResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float xx = (fragCoord.x / iResolution.x)*24.0;\n    float yy = (fragCoord.y / iResolution.x)*24.0+1.5;\n\n    float h = floor(xx)/24.0* 3.141592 * 2.;\n    float L = (iResolution.x/iResolution.y)*floor(yy)/24.0;\n    float C = -0.5*log(0.5+0.5*sin(iTime));\n\n    float C_guess = 1.0;\n    float C_max = 0.0;\n    \n    for (int i=0; i<2000; i++)\n    {\n        vec3 rgbTest = compute(L, h, C_guess*float(i)/2000.0);\n        float diff = length(rgbTest - clamp(rgbTest, 0., 1.));\n    \n        if(diff < 0.0001)\n        {\n            C_max = C_guess*float(i)/2000.0;\n        }\n    }\n    \n    vec3 rgb;\n    \n    rgb = compute(L, h, C_max);\n    \n    \n    fragColor.rgb = Srgb3(vec3(L*L*L));\n    //fragColor.rgb = Srgb3(vec3(0.2));\n    \n    if (((xx)-floor(xx)) > 0.25)\n    if (((xx)-floor(xx)) < 0.75)   \n    if (((yy)-floor(yy)) > 0.25)\n    if (((yy)-floor(yy)) < 0.75)\n        fragColor.rgb = Srgb3(rgb);  \n        \n    fragColor.a = 1.;\n    \n        \n    //fragColor = vec4(Srgb3(avgColor),1.);\n}", "image_inputs": [], "common_code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2czz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 174, 753], [755, 755, 800, 800, 1802], [1804, 1804, 1861, 1861, 2851]], "test": "untested"}
{"id": "fdSyWz", "name": "Distance 2D from 3 points arc", "author": "dizziCoding", "description": "first shader here, tips welcome", "tags": ["geometry"], "likes": 7, "viewed": 290, "published": 3, "date": "1643302296", "time_retrieved": "2024-07-30T17:06:55.612186", "image_code": "// Signed Distance to any 2D Arc\n// Color result from iq distance 2D\n// Geometry tips and formula from https://jeux.developpez.com/tutoriels/theorie-des-collisions/formes-complexes/#LI\n\n#define e 0.0004\n\nvec2 perpendicular (in vec2 v) {\n  return vec2 (-v.y, v.x);\n}\nfloat distSquared(in vec2 vec)\n{\n    return dot(vec, vec);\n}\nbool intersectLines(in vec2 A, in vec2 B, in vec2 O, in vec2 P, inout vec2 I)\n{\n\tvec2 AB = B - A;\n    vec2 OP = P - O;\n\n    float denom = AB.x*OP.y-AB.y*OP.x;\n\n    if(denom == 0.0)\n        return false;\n\n    float k = -(A.x*OP.y-O.x*OP.y-OP.x*A.y+OP.x*O.y)/ denom;\n    I = A + AB*k;\n\treturn true;\n}\n\nfloat sdArc(vec2 A, vec2 B, vec2 C, vec2 U) {\n    vec2 AC = C - A;\n    vec2 AB = B - A;\n    //det that tell wich side is B vs AC\n    float det = (AC.x * AB.y - AC.y * AB.x);\n    if(abs(det) >= e)\n    {\n        //find arc center D\n        float rayon;\n        vec2 D;\n        vec2 centerCordeAC = A + (AC / 2.0);\n        vec2 centerCordeAB = A + (AB / 2.0);\n        vec2 normalAC = perpendicular(AC);\n\n        if(intersectLines(centerCordeAC, centerCordeAC - normalAC, centerCordeAB, centerCordeAB - perpendicular(AB), D))\n        {\n            //find intersection (UD] vs circle D : E\n            vec2 E = D + normalize(U - D) * length(D-A);\n\n            //if E on arc, closest point = E, else closest point = A or C\n            vec2 AE = E - A;\n            float det2 = AC.x * AE.y - AC.y * AE.x;\n            if(sign(det2) == sign(det))// || det2 == 0.0)\n            {\n                //E is on arc\n                return length(E-U) * (dot(D-E,U-E) < 0.0 ? -1.1 : 1.1) * (dot(centerCordeAC - E,normalAC) > 0.0 ? -1.1 : 1.1);  \n            }else\n            {\n                //find the point of the same side of U vs D,D+normalAB\n                vec2 DU = U - D;\n                vec2 DA = A - D;\n                det2 = normalAC.x * DU.y - normalAC.y * DU.x;\n                float detA = normalAC.x * DA.y - normalAC.y * DA.x;\n                if(sign(det2) == sign(detA) || det2 == 0.0)\n                {\n                    //closest is A\n                    return length(U - A) * (dot(-DA,U-A) < 0.0 ? 1.1 : -1.1) * (dot(centerCordeAC - E,normalAC) > 0.0 ? -1.1 : 1.1);\n                }else\n                {\n                    //closest is C\n                    return length(U - C)* (dot(D-C,U-C) < 0.0 ? 1.1 : -1.1) * (dot(centerCordeAC - E,normalAC) > 0.0 ? -1.1 : 1.1);\n                }\n            }\n        }\n\n    }else\n    {\n        //A B C aligned\n        vec2 AU = U - A;\n        vec2 CU = U - C;\n        float pscal1 = dot(AC,AU);\n        float pscal2 = dot(CU,-AC);\n        if(dot(AB,AC) >=0.0 && dot(-AC,B-C) >=0.0)\n        {\n            //find closest pt to seg AC\n            if(pscal1 >= 0.0 && pscal2 >= 0.0)\n            {\n                return length(A + (AC * (pscal1 / distSquared(AC))) - U) * (dot(A+AC/2.0 - U,perpendicular(C-A)) > 0.0 ? 1.1 : -1.1);\n\n            }\n            else if(pscal1 < 0.0)\n            {\n                return length(AU)* (dot(A+AC/2.0 - U,perpendicular(C-A)) > 0.0 ? 1.1 : -1.1);\n            }\n            else\n            {\n                return length(CU)* (dot(A+AC/2.0 - U,perpendicular(C-A)) > 0.0 ? 1.1 : -1.1);\n            }\n        }else\n        {\n            //find closest pt to [A,A - CA) , [C,C-AC)\n            vec2 normalAC = perpendicular(AC);\n            vec2 D = A + AC / 2.0;\n            //find the point of the same side of U vs D+normalAB\n            vec2 DU = U - D;\n            vec2 DA = A - D;\n            float detU = normalAC.x * DU.y - normalAC.y * DU.x;\n            float detA = normalAC.x * DA.y - normalAC.y * DA.x;\n            if(sign(detU) == sign(detA) || detU == 0.0)\n            {\n                if(pscal1 >= 0.0)\n                {\n                    //closest is A\n                    return length(AU)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }else\n                {\n                    //closest is on [A,A - CA)\n                    vec2 CA = A - C;\n                    return length(A - (CA * (pscal1 / distSquared(CA))) - U)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }\n            }else\n            {\n                if(pscal2 >= 0.0)\n                {\n                    //closest is C\n                    return length(CU)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }else{\n                    //closest is on [C,C-AC)\n                    return length(C - (AC * (pscal2 / distSquared(AC))) - U)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 A = vec2(-0.5, 0.1+cos(iTime*0.5)*0.75);\n    vec2 B = vec2(-0.5+cos(iTime*0.25)*0.7, 0.1+sin(iTime*0.25)*0.7);\n    vec2 C = vec2(0.7 + sin(iTime)*1.0, -0.1+cos(iTime)*0.3);\n    \n    //edge case test\n    //vec2 A = vec2(1.0, 0.0);\n    //vec2 B = vec2(cos(iTime)*1.5, 0.0);\n    //vec2 C = vec2(-1.0,0.0);\n    \n    float d = sdArc(A,B,C, p);\n    float dots = min(min(length(A-p), length(B-p)), length(C-p));\n    d = mix(0.0, d, smoothstep(0.025, 0.035, dots));\n        \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-1.75*abs(d));\n\tcol *= 0.75 + 0.3*cos(125.0*d);\n\tcol = mix( col, vec3(0.6,0.9,1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 236, 236, 265], [266, 266, 298, 298, 326], [327, 327, 406, 406, 625], [627, 627, 672, 672, 4559], [4561, 4561, 4618, 4618, 5380]], "test": "untested"}
{"id": "fsBcDR", "name": "cumulated random lines", "author": "FabriceNeyret2", "description": "SPACE for contrast enhancement.\ntry #def hash = float hashf vs int hashi\nNot visible stat difference, but  float hash get artifacts after a few thousand lines.\n\nbetter use x64 acceleration ", "tags": ["random", "hash", "short"], "likes": 10, "viewed": 341, "published": 3, "date": "1643301446", "time_retrieved": "2024-07-30T17:06:56.586580", "image_code": "#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U) * R.x/2. / float(iFrame);  // normalize cumul\n    if ( keyToggle(32) ) O = (O-.5) *3. + .5;\n    \n    O = sqrt(O);                        // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash hashi  // hashi or hashf\n\nvec3 hashi( int v ) { // --- integer hash from https://www.shadertoy.com/view/XlXcW4\n    uint k = 1103515245U;  // GLIB C\n    uvec3 x = uvec3(v,k,k+uint(v));  // attention: v = uvec3(v) is horrible\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\nvec3 hashf(int v) { // --- float hash\n    return fract(sin(float(v) *vec3(127.1,311.7, 269.5)) *43758.5453123);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iFrame < 1 ) { O-=O; return; }\n    O.xyz = hash(iFrame);\n    vec2 p = O.xy*R/R.y,                         // choose a random line\n         d = cos( 6.28*O.z + vec2(0,1.57) );\n    O = T(U);\n    p -= U/R.y; p -= dot(p,d)*d;                 // vector distance to line\n    float l = length(p);\n    O += smoothstep( 1./R.y, 0., l );            // cumulates lines\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 106, 106, 269]], "test": "untested"}
{"id": "fdjcRm", "name": "The Royal Banner of Scotland", "author": "mla", "description": "The Banner of Arms of the Kingdom of Scotland, forming one quarter of the Royal Standard (or two quarters of the Standard used in Scotland itself).\n\n A little slower than the English banner, with twice as many curves", "tags": ["bezier", "flag", "fixedpoint", "svg", "arms", "jings", "crivens"], "likes": 13, "viewed": 367, "published": 3, "date": "1643293578", "time_retrieved": "2024-07-30T17:06:57.816292", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Royal Banner of Scotland, Matthew Arcus, mla. 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// Variation of https://www.shadertoy.com/view/fdXcDX - see there for further\n// details.\n//\n// https://en.wikipedia.org/wiki/Royal_Banner_of_Scotland, first recorded\n// use by Alexander II in 1222.\n//\n// Exploits rotational symmetry to speed things along, but slower than\n// the English banner as there are just more curves.\n//\n// Mouse to zoom, 'x' to draw progressively.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\n// The usual function, but also include segment in winding number computation\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  polywind(p,q,r);\n  p -= q; r -= q; // Relative to q\n  float t = dot(p,r)/dot(r,r);\n  t = clamp(t, 0.0, 1.0);\n  return length(p-t*r);\n}\n\nconst int nbeziercoeffs = 16;\nvec4 beziercoeff(int i) {\n  // Matrix formulation due to Shane.\n  const int N = nbeziercoeffs;\n  float t = float(i)/float(N);\n  float u = 1.0-t, t2 = t*t, u2 = u*u;\n  return vec4(u*u2,3.0*t*u2,3.0*u*t2,t*t2);\n}\n\n// Distance to Cubic Bezier.\n// Split the path into N subsegments.\nfloat bezier(vec2 p, mat4x2 m) {\n  // Since we spend most of the time deciding not to draw\n  // curves, the value of N doesn't seem to be time critical.\n  const int N = nbeziercoeffs;\n  vec2 q = m[0];\n  float d = 1e8;\n  for (int i = 1; i <= N; i++) {\n    vec2 r = m*beziercoeff(i);\n    d = min(d,segment(p,q,r));\n    q = r;\n  }\n  return d;\n}\n\nvec3 getcolor(int i) {\n  vec3 col = vec3(1,0,1);\n  // Colors from Wikipedia SVG\n  if (i == 0) col = vec3(0xa0,0,0)/255.0;\n  if (i == 1) col = vec3(0x0a,0x26,0x62)/255.0;\n  if (i == 2) col = vec3(0xff,0xd1,0x28)/255.0;\n  if (i == 3) col = vec3(0xff,0xd2,0x14)/255.0;\n  if (i == 4) col = vec3(0);\n  if (i == 5) col = vec3(0xa0,0,0)/255.0;\n\n  if (i == 6) col = vec3(0xb4,0,0x1e)/255.0;\n  if (i == 7) col = vec3(1);\n  if (i == 8) col = vec3(0x1e,0x82,0xd2)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvec2 decode(uint n) {\n  return vec2(n>>16,n&0xffffu)/64.0;\n}\n\nvec4 decode(uvec2 p) {\n  return vec4(decode(p.x),decode(p.y));\n}\n\nbool inrect(vec2 p, vec4 rect) {\n  return p.x >= rect.x && p.x <= rect.z && p.y >= rect.y && p.y <= rect.w;\n}\n\nvec2 quarter(vec2 p) {\n  p -= vec2(250,125);\n  p = -abs(p);\n  p += vec2(250,125);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = (fragCoord-0.0*iResolution.xy)/iResolution.xy;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p -= mouse;\n    p *= 0.25;\n    p += mouse;\n  }\n  //vec2 p = fragCoord/iResolution.xy;\n  //p *= 4.0;\n  p.y = 1.0-p.y;\n  p *= vec2(500,250);\n  vec3 col = getcolor(2);\n  float eps = 2.0; // Allow for line width \n  float px = fwidth(p.x);\n  float lwidth = 0.5;\n  int N = paths.length();\n  if (key(CHAR_X)) N = min(int(iTime),N); // Progressive effect\n  for (int i = 0; i < N; i++) {\n    if (i == 6) continue;\n    if (i == 52) p = quarter(p); // Draw the frame\n    vec4 box = decode(boxes[i]);\n    if ((p.x >= box.x-eps && p.x <= box.z+eps && p.y >= box.y-eps && p.y <= box.w+eps)) {\n      //assert(i != N-1); // With progressive drawing, show bounding boxes\n      int start = i == 0 ? 0 : paths[i-1];\n      int end = paths[i];\n      vec2 initpos = decode(points[start/2]); //vec2(points[start],points[start+1]);\n      vec2 p0 = initpos;\n      wind = 0;\n      float d = 1e8;\n      for (int j = start+2; j < end; j += 6) {\n        vec2 c0 = decode(points[(j+0)/2]);//vec2(points[j+0],points[j+1]);\n        vec2 c1 = decode(points[(j+2)/2]);//vec2(points[j+2],points[j+3]);\n        vec2 p1 = decode(points[(j+4)/2]);vec2(points[j+4],points[j+5]);\n        vec2 box1 = min(min(c0,c1),min(p0,p1))-eps;\n        vec2 box2 = max(max(c0,c1),max(p0,p1))+eps;\n        if (p.x < box1.x || p.y  < box1.y  || p.x > box2.x || p.y > box2.y) {\n          polywind(p,p0,p1);\n        } else {\n          d = min(d,bezier(p,mat4x2(p0,c0,c1,p1)));\n        }\n        p0 = p1;\n      }\n      polywind(p,p0,initpos); // Close curve if necessary\n      if (colors[i] != 0 && (wind&1) == 1) col = getcolor(colors[i]);;\n      col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n    }\n  }\n  // Draw frame\n  for (int i = 0; i < frame.length(); i+=2) {\n    vec4 outer = frame[i]; // (x0,y0,x1,y1)\n    vec4 inner = frame[i+1]; // (x0,y0,x1,y1)\n    if (inrect(p,outer) && !inrect(p,inner)) {\n      col = getcolor(6);\n    }\n  }\n  for (int i = 0; i < frame.length(); i++) {\n    vec4 rect = frame[i]; // (x0,y0,x1,y1)\n    col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.xy,rect.xw)-lwidth));\n    col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.xy,rect.zy)-lwidth));\n    //col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.zy,rect.zw)-lwidth));\n    //col = mix(vec3(0),col,smoothstep(0.0,px,segment(p,rect.xw,rect.zw)-lwidth));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = 1.0-col;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst uint points[] = uint[](\n995824862u, 997921960u, 997921960u, 1000019059u, 1002771626u, 1002771626u, 1005589728u, \n992285384u, 995234578u, 995234578u, 998249307u, 1000805147u, 1000805147u, 1003360987u, \n947001990u, 966138265u, 986192190u, 986192190u, 986192190u, 972888499u, 965220940u, 957553382u, 949230354u, 949230354u, 971905867u, 977214150u, 983833197u, 985209434u, 987109960u, 989207094u, 989207093u, 989207092u, 989207092u, 989207092u, 989207093u, 989207094u, 997202417u, 1008474551u, 1008474551u, 1008474551u, 997202417u, 989207094u, 989469255u, 991763190u, 989862719u, 987831179u, 980884448u, 988159013u, 995499114u, 1003166805u, 1003166805u, 1003166805u, 999693242u, 1016797970u, 999693242u, 1003166805u, 1003166805u, 1004477638u, 998186288u, 998186288u, 1026825487u, 1043078068u, 1043078068u, 1043078161u, 1040129291u, 1040129291u, 1051401455u, 1058413738u, 1061100637u, 1063722001u, 1066736519u, 1071389773u, 1076043027u, 1092361515u, 1092361515u, 1091902600u, 1091902600u, 1091378148u, 1098390673u, 1114381456u, 1121197191u, 1119558768u, 1119558768u, 1117985881u, 1119558768u, 1119558768u, 1121197191u, 1123097733u, 1124342914u, 1124342914u, 1110711280u, 1106385177u, 1119033993u, 1131682808u, 1150622458u, 1150622458u, 1133648606u, 1141316015u, 1141316015u, 1155930612u, 1160976682u, 1160976682u, 1137973485u, 1146296117u, 1146296117u, 1165629297u, 1169954487u, 1169954487u, 1146951347u, 1149310345u, 1145967924u, 1142625503u, 1144984750u, 1144984750u, 1161958595u, 1165300793u, 1165300793u, 1141969977u, 1140659003u, 1140658890u, 1140658777u, 1136005614u, 1135677855u, 1135219007u, 1140002964u, 1140002964u, 1140002964u, 1130631446u, 1122308386u, 1113985326u, 1116344440u, 1110380595u, 1104351215u, 1097731994u, 1088360342u, 1079054226u, 1081740955u, 1081740955u, 1081740955u, 1072041740u, 1066078029u, 1060114318u, 1056116626u, 1047793558u, 1039470490u, 1033768805u, 1021120483u, 1008472160u, 997527620u, 983830596u, 970199108u, 973541545u, 976556249u, 979505417u, 976228743u, 976228868u, 976228993u, 983503477u, 991498942u, 999494406u, 1008472770u, 1014174345u, 1019548243u, 1038619224u, 1040257625u, 1039012411u, 1038094876u, 1038029308u, 1038094876u, 1039012411u, 1040257625u, 1040388697u, 1040454233u, 1040454233u, 1041568346u, 1041568346u, 1042747994u, 1042813520u, 1042813520u, 1042879045u, 1042813520u, 1042813520u, 1042747994u, 1044189788u, 1044189788u, 1045697117u, 1044189788u, 1044189788u, 1042747994u, 1042616942u, 1042616942u, 1042485890u, 1047597781u, 1055331086u, 1055331086u, 1055331086u, 1047597781u, 1042485890u, 1042485890u, 1042485890u, 1042420355u, 1042027408u, 1049105463u, 1049105554u, 1049040098u, 1041110243u, 1041110243u, 1041110243u, 1003820259u, 993203421u, 982521048u, 984749337u, 984749455u, 984749574u, 978523691u, 978523691u, 989599292u, 992286219u, 994973152u, 997594549u, 1005131162u, 1014896074u, 1024660987u, 1037571525u, 1044649397u, 1051792805u, 1048188449u, 1048188449u, 1048188449u, 1040651981u, 1028658904u, 1016731362u, 1007818445u, 1000281907u, 995170168u, 986126225u, 978851760u, 981211069u, 981211069u, 983635914u, 981211069u, 981211069u, 978851760u, 975312830u, 972101582u, 970069989u, 963909675u, 936384647u, 920852501u, 920852501u, 919476472u, 938154264u, 938154264u, 949229869u, 934615487u, 926882315u, 922229393u, 915872453u, 916134600u, 916265673u, 916265673u, 917576405u, 917576405u, 918887137u, 920263384u, 920263384u, 921705168u, 920263384u, 920263384u, 918887137u, 918952674u, 918952674u, 919083747u, 918952674u, 918952674u, 918887137u, 917838567u, 917838567u, 916789997u, 922753799u, 934812446u, 947001990u, 947001990u, 947001990u, 947001990u, \n934615487u, 949229870u, 938154264u, 938154264u, 919476472u, 920852502u, 920852502u, 936384647u, 963909675u, 970069989u, 972101582u, 975312830u, 978851760u, 978655151u, 978655151u, 978524078u, 978524078u, 929896120u, 909579324u, 889328065u, 843518080u, 843518080u, 843518080u, 829362229u, 838340386u, 847318544u, 837881285u, 834080232u, 830279178u, 825560620u, 821366293u, 817106430u, 812846728u, 806227506u, 799608284u, 798231982u, 792071684u, 785976922u, 778374792u, 781258416u, 782044860u, 782110403u, 781717191u, 783945421u, 796987131u, 810225629u, 796987131u, 783945421u, 781717191u, 780734161u, 776867527u, 773197482u, 768020098u, 760483544u, 764219153u, 768020299u, 761401380u, 771756045u, 782176246u, 792989606u, 793514003u, 793972864u, 808587512u, 793514243u, 778375439u, 770838828u, 771756429u, 772739566u, 780276527u, 788271741u, 796332492u, 812388818u, 817107570u, 821826322u, 828445636u, 828445636u, 829756330u, 829756330u, 831067024u, 831067024u, 836047950u, 835720391u, 838210741u, 838210741u, 840701090u, 842536278u, 842536278u, 844371466u, 847189479u, 847189479u, 850073029u, 850859681u, 850859681u, 851711869u, 856364877u, 856364877u, 861017884u, 861017884u, 862066675u, 863377467u, 865867813u, 865867813u, 868358159u, 868358159u, 869996688u, 877992209u, 885463434u, 912333472u, 915872453u, 922229393u, 926882315u, 934615487u, 934615487u, 934615487u, 934615487u, \n810159696u, 815861471u, 815861471u, 821628783u, 815861471u, 815861471u, 810159696u, 810159696u, 810159696u, 810159696u, \n1040454233u, 1040454233u, 1040323161u, 1040257625u, 1040912999u, 1041633909u, 1042485890u, 1042616942u, 1042616942u, 1042747995u, 1041568346u, 1041568346u, 1040454233u, 1040454233u, 1040454233u, 1040454233u, \n916265674u, 916265674u, 916134600u, 915872453u, 914889421u, 913906387u, 912857815u, 912857815u, 914299618u, 916789997u, 917838567u, 917838567u, 918887137u, 917576405u, 917576405u, 916265674u, 916265674u, 916265674u, 916265674u, \n1089938112u, 1090658966u, 1090789995u, 1090593346u, 1089217090u, 1051206228u, 1039081988u, 1026695602u, 1004806585u, 990782038u, 976757491u, 951460772u, 939074257u, 935862938u, 934224489u, 933569087u, 931537350u, 937435523u, 937435523u, 937435523u, 901456395u, 925639513u, 899228600u, 884613738u, 884613738u, 884613738u, 877405132u, 897328128u, 915219503u, 930685976u, 930685976u, 930685976u, 912991596u, 891692375u, 891692375u, 900998677u, 931931403u, 931931403u, 930293092u, 933635529u, 933635529u, 959259862u, 961553929u, 963913532u, 964241180u, 968566604u, 972892029u, 979576895u, 966600763u, 953559095u, 938616830u, 928262138u, 917972982u, 885336135u, 878389222u, 871376773u, 862398276u, 861021903u, 859711066u, 854730314u, 850732622u, 846734930u, 839722614u, 842082019u, 842082019u, 841033508u, 838149913u, 850339751u, 850339751u, 862529589u, 850339751u, 850339751u, 838149913u, 837691160u, 837232405u, 836773648u, 832775911u, 823076523u, 821765900u, 820455277u, 822749121u, 820783090u, 818751522u, 816130099u, 816457855u, 816785612u, 812788126u, 820455842u, 828058022u, 828778825u, 840706385u, 852699481u, 873015609u, 864037262u, 855058915u, 844704255u, 843721288u, 842738320u, 847063676u, 851389056u, 855714436u, 859712193u, 860695289u, 861678386u, 868690782u, 870722285u, 872688252u, 874326475u, 883042754u, 892807608u, 896805411u, 896805411u, 903228076u, 908274412u, 911289079u, 911289079u, 911813267u, 919546485u, 927214168u, 931736234u, 933833438u, 935865107u, 940190580u, 949234569u, 949234569u, 948447989u, 956181239u, 963848953u, 967257003u, 981871568u, 981871568u, 982264693u, 987704155u, 993143618u, 995961605u, 996158181u, 996158181u, 997862306u, 1011755975u, 1011755975u, 1012476817u, 1017391950u, 1023027968u, 1025125083u, 1039477465u, 1053829847u, 1064446503u, 1064446503u, 1064446503u, 1046817408u, 1034168855u, 1021520302u, 1002841888u, 1053107778u, 1068115462u, 1076110860u, 1078535696u, 1078011196u, 1084498950u, 1089938112u, 1089938112u, 1089938112u, 1089938112u, \n834611185u, 826943401u, 821372892u, 821372892u, 821372892u, 826943401u, 834611185u, 842278969u, 851716246u, 851716246u, 851716246u, 842278969u, 834611185u, 834611185u, 834611185u, 834611185u, \n1331826582u, 1324289770u, 1316687367u, 1300303367u, 1300303367u, 1322519797u, 1303383075u, 1303383075u, 1297747345u, 1265241489u, 1201409425u, 1183649663u, 1189221211u, 1193547359u, 1241520098u, 1274091886u, 1302010561u, 1307712824u, 1307712824u, 1307581748u, 1307385136u, 1307188525u, 1293360153u, 1276845071u, 1255152515u, 1233197814u, 1250171303u, 1250171303u, 1204558433u, 1234836477u, 1234836477u, 1228872777u, 1228872777u, 1222843542u, 1204886872u, 1185553392u, 1185553392u, 1183587692u, 1208556916u, 1208556916u, 1161961293u, 1211899999u, 1211899999u, 1191911237u, 1221533254u, 1221533254u, 1229201346u, 1254497991u, 1254497991u, 1242177219u, 1222188364u, 1264459011u, 1306729658u, 1322393748u, 1274159619u, 1225859955u, 1173627202u, 1163927522u, 1154293379u, 1121328266u, 1121328266u, 1121262729u, 1121262729u, 1121197191u, 1114381456u, 1098390673u, 1091378148u, 1091902600u, 1091902600u, 1092361515u, 1092361515u, 1076043027u, 1071389773u, 1066736519u, 1063722001u, 1061100637u, 1058413738u, 1051401455u, 1040129291u, 1040129291u, 1043143697u, 1043143604u, 1043143604u, 1026825487u, 998186288u, 998186288u, 1004477638u, 1003166805u, 1003166805u, 995499114u, 988159013u, 980884448u, 987831179u, 989862719u, 991763190u, 989469255u, 989207094u, 987109960u, 985274970u, 983833197u, 977214150u, 971905867u, 949230354u, 949230354u, 957553382u, 965220940u, 972888499u, 986192190u, 986192190u, 986192190u, 966138265u, 947001990u, 934812446u, 922753799u, 916789997u, 916724461u, 916724461u, 916593390u, 898898767u, 848370983u, 848370983u, 826416621u, 809770651u, 786505427u, 763174668u, 750526127u, 738532938u, 726539749u, 728571563u, 728571563u, 728571626u, 728571626u, 728571688u, 728571814u, 743186261u, 751837045u, 760487829u, 731193427u, 715268203u, 699277444u, 707600661u, 711270677u, 714940693u, 715923713u, 720904546u, 725885379u, 731914679u, 737222986u, 742531293u, 753868988u, 760881284u, 767828043u, 768155776u, 768155885u, 768155994u, 763502990u, 756163027u, 748888600u, 758522420u, 762520136u, 766517852u, 768877169u, 771826353u, 774841074u, 781525693u, 781525443u, 781525192u, 790831300u, 798498903u, 806100970u, 806101124u, 805773585u, 805446046u, 807805363u, 813113787u, 818422211u, 824123815u, 827793657u, 831397963u, 843063432u, 843063432u, 846078120u, 850403480u, 850403480u, 848044087u, 853090274u, 853090274u, 857743472u, 871374964u, 871374964u, 868360219u, 873013190u, 873013190u, 880681108u, 896016500u, 896016500u, 892674087u, 894312370u, 894312370u, 899686435u, 909320182u, 909320182u, 904339349u, 908992276u, 908992276u, 916660186u, 929963958u, 929963958u, 923279112u, 933633776u, 939925288u, 946282337u, 955588392u, 955588392u, 964566792u, 966270853u, 966270853u, 966270853u, 976690985u, 984227572u, 988028633u, 992419535u, 996548302u, 995106466u, 995106466u, 993664631u, 995106466u, 995106466u, 996548302u, 1004216010u, 1010835172u, 1010835172u, 1010835172u, 1004216010u, 996548302u, 996679379u, 996679379u, 996875992u, 1010507851u, 1043472532u, 1059791032u, 1076109533u, 1087054206u, 1087054206u, 1087447429u, 1087447429u, 1087906189u, 1079648351u, 1056710509u, 1056710509u, 1056710509u, 1079648351u, 1087906189u, 1090462140u, 1090462140u, 1093083628u, 1090462140u, 1090462140u, 1087906189u, 1089479111u, 1090462212u, 1090658882u, 1090658882u, 1090789954u, 1090789954u, 1093280322u, 1093280322u, 1095836226u, 1093280322u, 1093280322u, 1090789954u, 1090789954u, 1090658882u, 1090658882u, 1090789996u, 1090658966u, 1089938112u, 1084498950u, 1078076732u, 1078535696u, 1079059985u, 1079453201u, 1079453201u, 1081812499u, 1081812499u, 1084171798u, 1081812499u, 1081812499u, 1079453201u, 1079453201u, 1079059985u, 1078535696u, 1078666832u, 1079453320u, 1081091764u, 1088169841u, 1115236559u, 1097935319u, 1080634079u, 1076243188u, 1078012919u, 1078012919u, 1080109866u, 1092758249u, 1092758249u, 1089416192u, 1098722437u, 1098722437u, 1096428467u, 1106389850u, 1106389850u, 1115368505u, 1131031532u, 1131031532u, 1119365995u, 1119365825u, 1119365655u, 1124346315u, 1131358796u, 1138371277u, 1150364365u, 1159342720u, 1168321076u, 1186605369u, 1186605571u, 1186605773u, 1189620490u, 1192962854u, 1196239682u, 1195584403u, 1189948396u, 1184312389u, 1179266254u, 1176644907u, 1173958024u, 1160654430u, 1155018253u, 1149316540u, 1138371976u, 1135029692u, 1131687409u, 1123364353u, 1128017458u, 1132670562u, 1132670651u, 1131687684u, 1130704716u, 1136996180u, 1134374821u, 1134374821u, 1139617588u, 1150824156u, 1139617588u, 1134374821u, 1134374821u, 1131687926u, 1126051826u, 1133654075u, 1141321859u, 1142370524u, 1150693560u, 1159016595u, 1161638068u, 1161965820u, 1162293573u, 1171272126u, 1174941997u, 1178611868u, 1177628626u, 1177300893u, 1176973161u, 1180970844u, 1186606892u, 1192242940u, 1201942223u, 1202597688u, 1203253153u, 1201287287u, 1205285007u, 1209282728u, 1214591156u, 1214918743u, 1215246330u, 1217605602u, 1223897042u, 1230254017u, 1235234741u, 1235562337u, 1235889932u, 1235234507u, 1225207499u, 1215246027u, 1214262971u, 1214262890u, 1214262809u, 1212231096u, 1224879532u, 1237527968u, 1250438535u, 1254436178u, 1254436178u, 1244409146u, 1240214758u, 1236020371u, 1229532318u, 1229532318u, 1229532318u, 1229794435u, 1236413557u, 1243098216u, 1264593981u, 1269312408u, 1269312408u, 1261054913u, 1254173563u, 1247292213u, 1244670775u, 1244670775u, 1244670775u, 1248013074u, 1257712402u, 1267477266u, 1278159505u, 1278159505u, 1278159505u, 1269049995u, 1265707611u, 1262430762u, 1258170882u, 1252207100u, 1252207100u, 1259284905u, 1268394398u, 1277503891u, 1283008794u, 1283008794u, 1283008794u, 1276193072u, 1269508349u, 1262823626u, 1252403423u, 1252403423u, 1252403423u, 1257318540u, 1268590724u, 1279928443u, 1291462669u, 1291462669u, 1291462669u, 1281959954u, 1276192724u, 1276192724u, 1263937379u, 1262429944u, 1260856972u, 1264199287u, 1261839938u, 1258890751u, 1247552916u, 1249191135u, 1249191135u, 1245521090u, 1234904396u, 1224222165u, 1205544596u, 1189029435u, 1189029435u, 1165174231u, 1173627674u, 1173627674u, 1334978083u, 1335828123u, 1336743872u, 1224415168u, 1210258422u, 1210258422u, 1186729501u, 1269305001u, 1269305001u, 1278611135u, 1271074672u, 1263472674u, 1262621153u, 1262621153u, 1262621153u, 1269895662u, 1275204045u, 1275204045u, 1277235719u, 1271468637u, 1265701555u, 1261704118u, 1273697378u, 1285690638u, 1311905054u, 1311905054u, 1311905054u, 1301222530u, 1306989531u, 1312756532u, 1318523663u, 1320292995u, 1320292995u, 1332745271u, 1357124453u, 1357124453u, 1340740313u, 1344279068u, 1347817824u, 1350504741u, 1350504649u, 1350504649u, 1369575604u, 1369575275u, 1369575275u, 1339363394u, 1331826582u, 1331826582u, 1331826582u, 1331826582u, \n1154625506u, 1149382684u, 1149382842u, 1149382842u, 1149382842u, 1149382684u, 1154625506u, 1159802792u, 1165176671u, 1165176671u, 1165176671u, 1159802792u, 1154625506u, 1154625506u, 1154625506u, 1154625506u, \n1276056033u, 1276056033u, 1276383662u, 1282216312u, 1288048962u, 1295913173u, 1297879168u, \n1307841736u, 1307841736u, 1284904123u, 1289425693u, \n1106978479u, 1106978479u, 1113008049u, 1135617953u, \n1203513120u, 1209149208u, 1209149208u, 1214850832u, 1214850832u, 1220814600u, 1220814680u, 1220814761u, 1220814842u, 1220814842u, \n843327092u, 843327092u, 828646783u, 810165826u, 810165826u, 824845890u, 829368034u, 834217733u, 834217733u, 839067431u, 840640263u, 840640263u, 842213096u, 842147560u, 839788185u, 843327092u, 843327092u, 843327092u, 843327092u, \n821372892u, 831858664u, 842803273u, 851716246u, \n816785465u, 811607973u, 790308782u, 790308782u, 798303954u, 821700390u, 821700390u, 821700390u, 821307270u, 821831604u, 822355939u, 816785465u, 816785465u, 816785465u, 816785465u, 816785465u, \n861809438u, 846801762u, 846146656u, 846146656u, 828320550u, 844376688u, 844376688u, 844376688u, 845490817u, 850668159u, 855911037u, 858532526u, 859581140u, 860629754u, 861809438u, 861809438u, 861809438u, 861809438u, 861809438u, \n816130164u, 816130164u, 784738323u, 785787284u, 785787284u, 799353037u, 815081770u, \n1134309285u, 1134309285u, 1139552051u, 1150758620u, \n1149382842u, 1149382842u, 1151938628u, 1157115913u, 1162358735u, 1165176671u, 1165176671u, \n1131753236u, 1115959050u, 1109012387u, 1109012387u, 1103572559u, 1127558692u, 1127558692u, 1127558692u, 1132473967u, 1132474008u, 1132474049u, 1131753236u, 1131753236u, 1131753236u, 1131753236u, 1131753236u, \n1129590795u, 1129590795u, 1108160756u, 1134375379u, 1134375379u, 1131557103u, 1141584038u, \n1166815556u, 1152790918u, 1159803517u, 1159803517u, 1130639851u, 1147220151u, 1147220151u, 1147220151u, 1152004293u, 1156657324u, 1161375890u, 1165242555u, 1165504743u, 1165766932u, 1166815556u, 1166815556u, 1166815556u, 1166815556u, 1166815556u, \n1232940973u, 1239101711u, 1216557424u, 1216557424u, 1224945898u, 1213345939u, 1213345939u, 1213345939u, 1215246435u, 1215246375u, 1215246316u, 1218654166u, 1222258639u, 1225863113u, 1232940973u, 1232940973u, 1232940973u, 1232940973u, 1232940973u, \n1086988670u, 1086988670u, 1076043996u, 1059725496u, 1043406996u, 1010442315u, 996810455u, \n938744089u, 938744089u, 960829766u, 978524296u, 996153290u, 1013454750u, 1031411614u, \n1003101269u, 1003101269u, 999627706u, 1016797970u, \n1091902450u, 1091902450u, 1086135128u, 1086134881u, \n1043078068u, 1043078068u, 1049303735u, 1049303584u, \n723853714u, 710877615u, 701899477u, 701899477u, 690233787u, 707862789u, 707862789u, 707862789u, 710091034u, 712974609u, 715858184u, 717955366u, 719397186u, 720839005u, 723853714u, 723853714u, 723853714u, 723853714u, 723853714u, \n771760817u, 758129385u, 753804272u, 753804272u, 744170262u, 755835440u, 755835440u, 755835440u, 759964212u, 763961934u, 767959656u, 769729171u, 771760817u, \n728505954u, 728505954u, 702553614u, 699866965u, 699866965u, 716513016u, 728506164u, \n807084426u, 804725278u, 804725278u, 802431665u, 802431665u, 813703752u, 817701307u, \n1112545835u, 1112545835u, 1117854043u, 1113397318u, \n1140922807u, 1140922807u, 1147607183u, 1125652418u, \n1146033974u, 1146033974u, 1134302968u, 1126504047u, \n1144525998u, 1144525998u, 1138693285u, 1132729412u, 1127814132u, 1119163334u, 1114510173u, \n1118376211u, 1118376211u, 1109266651u, 1094586557u, \n1043206312u, 1043206312u, 1032917007u, 1027149920u, 1021317296u, 1012863198u, 1019678982u, 1026494767u, 1029378333u, 1035538719u, 1041633569u, 1050349822u, 1043206312u, 1043206312u, 1043206312u, 1043206312u, \n1048908852u, 1013912620u, 1013912620u, 978916387u, 978916387u, 933893177u, 955191707u, 955191707u, 953750462u, 990581694u, 1027412926u, 1044386757u, 1044386757u, \n780538537u, 780538537u, 752489229u, 740495839u, 740495839u, 758780459u, 773001702u, \n765398948u, 765398948u, 743968580u, 734138268u, 734138268u, 740757171u, 763498201u, \n783355494u, 783355494u, 773918111u, 757206500u, 757206500u, 772345064u, 795676125u, \n823463457u, 823463457u, 820579625u, 805768401u, 805768401u, 824118435u, 836046304u, \n781323974u, 781323974u, 795676389u, 810225629u, \n1044976237u, 1044976237u, 1019744849u, 1014108809u, 1008472770u, 999494406u, 991498942u, 983503477u, 976163457u, 976163332u, 976163207u, 979505418u, 976490713u, 973476009u, 970199108u, 983830596u, 997462084u, 1008472160u, 1021120483u, 1033768805u, 1039404954u, 1047728022u, 1056051090u, 1060048782u, 1066012493u, 1072041741u, 1081675420u, 1081675420u, 1081675420u, 1079054226u, 1088360342u, 1097666458u, 1104351215u, 1110315059u, 1116278904u, 1113985326u, 1122308386u, 1130631446u, 1139937428u, 1139937428u, 1139937428u, 1135153471u, 1135612319u, 1136005614u, 1140593241u, 1140593354u, 1140593467u, 1141969977u, 1165235257u, 1165235257u, 1161893059u, 1144919215u, 1144919215u, 1142625503u, 1145967924u, 1149244809u, 1146951348u, 1169888952u, 1169888952u, 1165563761u, 1146296117u, 1146296117u, 1137973485u, 1160911146u, 1160911146u, 1155930612u, 1141250479u, 1141250479u, 1133648606u, 1150622458u, 1150622458u, 1131617273u, 1118968457u, 1106319641u, 1110645745u, 1124277378u, 1124277378u, 1100356803u, 1091312612u, 1091837064u, 1091837064u, 1092361516u, 1092361516u, 1076043027u, 1071389773u, 1066736519u, 1063722001u, 1061035102u, 1058413738u, 1051401455u, 1040063755u, 1040063755u, 1043078161u, 1043078068u, 1043078068u, 1026759951u, 998120752u, 998120752u, 1004477639u, 1003101269u, 1003101269u, 995499114u, 988159013u, 980818912u, 987831180u, 989797183u, 991828722u, 989141556u, 989141556u, \n1008474551u, 1008474551u, 990452244u, 983833197u, 977148614u, 971840331u, 949230354u, 949230354u, 957553382u, 965155404u, 972822963u, 986126654u, 986126654u, 986126654u, 966072729u, 947001990u, 929766236u, 916527859u, 916527859u, 920787644u, 925702679u, 934549951u, 949229870u, 938088728u, 938088728u, 919476472u, 920786966u, 920786966u, 936319111u, 963844139u, 970069989u, 976295839u, 992679834u, 1000281907u, 1007818445u, 1016665827u, 1028658904u, 1040651981u, 1048188449u, 1048188449u, 1048188449u, 1051727269u, 1044649397u, 1037505989u, 1024660987u, 1014896075u, 1005131162u, 997594549u, 994907616u, 992286219u, 989599292u, 978523692u, 978523692u, 984749574u, 984749455u, 984749337u, 982521048u, 993137886u, 1003820259u, 1041110243u, 1041110243u, 1041110243u, 1049040098u, 1049040018u, 1049105463u, 1041961872u, 1042420355u, \n978458542u, 978458542u, 929896120u, 909579324u, 889262529u, 843518080u, 843518080u, 843518080u, 829362229u, 838274850u, 847253008u, 837815749u, 834080232u, 830279178u, 825560620u, 821300757u, 817040894u, 812846728u, 806227506u, 799608284u, 798166446u, 792071684u, 785911386u, 778374792u, 781192880u, 784010968u, 778374866u, 773197482u, 768020098u, 760418008u, 764219153u, 767954763u, 761401380u, 771756045u, 782110710u, 792989606u, 793448467u, 793907328u, 808587512u, 793448707u, 778375439u, 770838828u, 771756429u, 772674030u, 780276527u, 788271741u, 796332492u, 812323282u, 817042034u, 821760786u, 828380100u, 828380100u, 829690794u, 829690794u, 831067024u, 831067024u, 836047950u, 835720391u, 838210741u, 838210741u, 840701090u, 842536278u, 842536278u, 844371466u, 847189479u, 847189479u, 850007493u, 850859681u, 850859681u, 851711869u, 856364877u, 856364877u, 861017884u, 861017884u, 862001139u, 863311931u, 865867813u, 865867813u, 868358159u, 868358159u, 869996688u, 877992209u, 885987731u, 916265674u, 916265674u, \n1079387665u, 1079387665u, 1071392249u, 1053042242u, 1002776352u, 1021454766u, 1034103319u, 1046751872u, 1064380967u, 1064380967u, 1064380967u, 1053764311u, 1039411929u, 1025059547u, 1022962432u, 1017326414u, 1012411281u, 1011690439u, 1011690439u, 997796770u, 996092645u, 996092645u, 995896069u, 993078082u, 987638619u, 982199157u, 981806032u, 981806032u, 967191467u, 963783418u, 956115703u, 948382453u, 949169033u, 949169033u, 940125045u, 935799571u, 933767902u, 931670698u, 927148632u, 919480949u, 911813267u, 911223543u, 911223543u, 908208876u, 903162540u, 896739875u, 896739875u, 892938679u, 882977218u, 874326476u, 872622716u, 870656749u, 868625246u, 861678386u, 860629753u, 859646657u, 855648900u, 851323520u, 846998140u, 842672784u, 843655752u, 844704255u, 854993379u, 863971726u, 872950073u, 852699481u, 840706385u, 828713289u, 828058022u, 820390306u, 812722590u, 816720076u, 816392319u, 816064563u, 818685986u, 820717554u, 822683585u, 820389741u, 821700364u, 823076523u, 832710375u, 836708112u, 840705848u, 842016483u, 842016483u, 839722614u, 846669394u, 850667086u, 854664778u, 859645530u, 861021903u, 862332740u, 871311237u, 878323686u, 885270599u, 917907446u, 928262138u, 938551294u, 953559095u, 966535227u, 979511359u, 972826493u, 968501068u, 964175644u, 963847996u, 961553929u, 959194326u, 933569993u, 933569993u, 930227556u, 931865867u, 931865867u, 900933141u, 891626839u, 891626839u, 912926060u, 930620440u, 930620440u, 930620440u, 915219503u, 897262592u, 877405132u, 884548202u, 884548202u, 884548202u, 899163064u, 925573977u, 901390859u, 937369987u, 937369987u, 937369987u, 931471814u, 933503551u, 934158953u, 935862938u, 939074257u, 951395236u, 976691955u, 990716502u, 1004741049u, 1026695602u, 1039016452u, 1051402838u, 1090724417u, 1090724417u, \n1010769636u, 1010769636u, 995172007u, 984162036u, 976625449u, 966205317u, 966205317u, 966205317u, 964501256u, 955522856u, 955522856u, 946216801u, 939859752u, 933568240u, 923213576u, 929898422u, 929898422u, 916594650u, 908926740u, 908926740u, 904273813u, 909254646u, 909254646u, 899620899u, 894246834u, 894246834u, 892608551u, 895950963u, 895950963u, 880615572u, 872947654u, 872947654u, 868294683u, 871309427u, 871309427u, 857677935u, 853024738u, 853024738u, 847978551u, 850337944u, 850337944u, 846012584u, 842997896u, 842997896u, 831332427u, 827728121u, 824058278u, 818356675u, 813048251u, 807739827u, 805380510u, 805708049u, 806035588u, 806035434u, 798433367u, 790765764u, 781459656u, 781459907u, 781460157u, 774775538u, 771760817u, 768746096u, 766452316u, 762454600u, 758456884u, 748823064u, 756097491u, 763437454u, 768090458u, 768090349u, 768090240u, 767762507u, 760815748u, 753803452u, 742465756u, 737157450u, 731849143u, 725819843u, 720839010u, 715858177u, 714875157u, 711205141u, 707535125u, 699211908u, 715202667u, 731127891u, 760422293u, 751771509u, 743120725u, 728506277u, 728506152u, 728506027u, 728506027u, 728506027u, 728506027u, 726474213u, 738467402u, 750460591u, 763109132u, 786439891u, 809705115u, 826351085u, 848305447u, 848305447u, 898833231u, 916593390u, \n1121328266u, 1121328266u, 1154227843u, 1163927522u, 1173561665u, 1225794419u, 1274094083u, 1322328212u, 1306729658u, 1264459011u, 1222122828u, 1242111683u, 1254432455u, 1254432455u, 1229135810u, 1221467718u, 1221467718u, 1191845701u, 1211834463u, 1211834463u, 1161895757u, 1208491380u, 1208491380u, 1183522156u, 1185553392u, 1185553392u, 1204821336u, 1222843542u, 1228807241u, 1228807241u, 1234770940u, 1234770940u, 1204492897u, 1250105767u, 1250105767u, 1233132278u, 1255086979u, 1276779535u, 1293294617u, 1307188525u, 1307319600u, 1307516212u, 1307712824u, 1307712824u, 1302010561u, 1274091886u, 1241454562u, 1193547359u, 1189221211u, 1183649663u, 1201409425u, 1265175953u, 1297681809u, 1303383075u, 1303383075u, 1322454261u, 1300237831u, 1300237831u, 1316687367u, 1324224234u, 1331761046u, 1339297858u, 1369509739u, 1369509739u, 1369510067u, 1350439113u, 1350439113u, 1350439204u, 1347752288u, 1344213532u, 1340674777u, 1357058917u, 1357058917u, 1332679735u, 1320227458u, 1320227458u, 1318458126u, 1312690996u, 1306923995u, 1301156994u, 1311773982u, 1311773982u, 1311773982u, 1285625102u, 1273631842u, 1261638581u, 1265636019u, 1271403101u, 1277170183u, 1275138509u, 1275138509u, 1269830125u, 1262555617u, 1262555617u, 1262555617u, 1263407138u, 1270943600u, 1278480062u, 1269173929u, 1269173929u, 1186663965u, 1210192886u, 1210192886u, 1224349631u, 1336678335u, 1335762587u, 1334912547u, 1173562138u, 1173562138u, 1165108695u, 1188963899u, 1188963899u, 1205413523u, 1224156629u, 1234773323u, 1245455554u, 1249125598u, 1249125598u, 1247421844u, 1258825215u, 1261774402u, 1264133750u, 1260791436u, 1262298871u, 1263871843u, 1276061652u, 1276061652u, 1281828882u, 1291397133u, 1291397133u, 1291397133u, 1279862907u, 1268525187u, 1257187467u, 1252337887u, 1252337887u, 1252337887u, 1262758089u, 1269442812u, 1276062000u, 1282943258u, 1282943258u, 1282943258u, 1277438355u, 1268328862u, 1259219369u, 1252141564u, 1252141564u, 1258105346u, 1262299690u, 1265642074u, 1268984459u, 1278093968u, 1278093968u, 1278093968u, 1267411729u, 1257646865u, 1247882001u, 1244539703u, 1244539703u, 1244539703u, 1247226677u, 1254108027u, 1260989376u, 1269181336u, 1269181336u, 1264528444u, 1243032679u, 1236348021u, 1229728898u, 1229466781u, 1229466781u, 1229466781u, 1235889299u, 1240149222u, 1244343609u, 1254305106u, 1254305106u, 1250307462u, 1237462432u, 1224813996u, 1212165560u, 1214131737u, 1214131818u, 1214131899u, 1215180491u, 1225141963u, 1235168971u, 1235824395u, 1235496800u, 1235169205u, 1230122945u, 1223831505u, 1217474529u, 1215180794u, 1214853207u, 1214525620u, 1209151655u, 1205153935u, 1201156215u, 1203187617u, 1202532152u, 1201876687u, 1192177403u, 1186541356u, 1180905308u, 1176907624u, 1177235357u, 1177563089u, 1178546331u, 1174876461u, 1171206590u, 1162228037u, 1161900284u, 1161572531u, 1158885523u, 1150562487u, 1142239452u, 1141256323u, 1133588538u, 1125920754u, 1131622390u, 1134243749u, 1136930644u, 1130573644u, 1131622147u, 1132605114u, 1132605026u, 1127951921u, 1123298817u, 1131621873u, 1134898620u, 1138240903u, 1149251004u, 1154887181u, 1160588894u, 1173892487u, 1176513835u, 1179200718u, 1184181316u, 1189882860u, 1195518867u, 1196174146u, 1192831782u, 1189554953u, 1186540237u, 1186540035u, 1186539833u, 1168190003u, 1159211648u, 1150233293u, 1138240205u, 1131293260u, 1124280778u, 1119300119u, 1119300289u, 1119300458u, 1130965996u, 1130965996u, 1115302968u, 1106324314u, 1106324314u, 1096297395u, 1098656901u, 1098656901u, 1089350656u, 1092627177u, 1092627177u, 1079978794u, 1077881846u, 1077881846u, 1076112116u, 1080568542u, 1097869782u, 1115171023u, 1088104305u, 1081026228u, 1073882616u, 1082795113u, 1089872576u, 1097015574u, 1056579437u, 1056579437u, \n3170970609u, 3166448673u, 3165072494u, 3165072572u, 3161009314u, 3155635343u, 3151113363u, 3156290752u, 3161468140u, 3161468240u, 3161468282u, 3159764405u, 3157405142u, 3170971094u, 3170971094u, 3184537046u, 3182177717u, 3180473722u, 3180473680u, 3180473580u, 3185650880u, 3190828179u, 3186306191u, 3180932258u, 3176869052u, 3176868974u, 3175492641u, 3170970609u, 3170970609u, 3170970609u, 3170970609u, \n610863775u, 610864498u, 652349060u, 668470670u, 680004830u, 676268770u, 639044263u, 645597958u, 648809344u, 644877245u, 637733930u, 615451482u, 615451232u, 600836704u, 600836704u, 586222176u, 586222426u, 563940394u, 556796861u, 552864640u, 556075783u, 562629287u, 525404898u, 521669854u, 533204366u, 549326468u, 590810482u, 590809759u, 600836767u, 600836767u, 610863775u, \n609225312u, 609225312u, 626003237u, 626003633u, 626003850u, 619450462u, 600838557u, 582226014u, 575672202u, 575671985u, 575671589u, 592448096u, 592448096u, 600836704u, 600836704u, 609225312u, \n1063192480u, 1063192303u, 1085474356u, 1092617857u, 1096550060u, 1093338890u, 1086785358u, 1124009765u, 1127744957u, 1116210496u, 1100088467u, 1058604385u, 1058604896u, 1048577888u, 1048577888u, 1038550880u, 1038550369u, 997065875u, 980944192u, 969409981u, 973145893u, 1010370382u, 1003816714u, 1000605356u, 1004537473u, 1011680820u, 1033963247u, 1033963424u, 1048577952u, 1048577952u, 1063192480u, \n1040189344u, 1040189344u, 1023411626u, 1023411346u, 1023411192u, 1029964642u, 1048576640u, 1067189090u, 1073742840u, 1073742994u, 1073743274u, 1056966560u, 1056966560u, 1048577952u, 1048577952u, 1040189344u, \n1048579584u, 1040387472u, 1038028000u, 1038027819u, 1030753383u, 1020988564u, 1012927626u, 1022168096u, 1031474108u, 1031473877u, 1031473779u, 1028393452u, 1024264608u, 1048578464u, 1048578464u, 1072892320u, 1068763628u, 1065683571u, 1065683669u, 1065683900u, 1074990112u, 1084230794u, 1076104340u, 1066404967u, 1059130411u, 1059130592u, 1056771472u, 1048579584u, 1048579584u, 1048579584u, 1048579584u, \n117835870u, 84280927u, 42272605u, 42272952u, 42273201u, 68487921u, 97520009u, 88476044u, 80546137u, 80546051u, 80545897u, 105908235u, 117508284u, 127862815u, 127862815u, 138151809u, 126551760u, 132711757u, 142804301u, 148440397u, 151782854u, 151586384u, 175178901u, 154206981u, 137888517u, 115147525u, 98502022u, 131991430u, 124913650u, 124913650u, 117835870u, \n121899129u, 121899129u, 77203257u, 58852897u, 48760199u, 43582635u, 41943808u, 69927705u, 84345704u, 94438402u, 112788762u, 133760964u, 133760964u, 127862815u, 127862815u, 121899129u, \n225316334u, 225905991u, 219417776u, 211029040u, 218958860u, 227937219u, 233180005u, 221776766u, 210504603u, 199822072u, 195234483u, 191171122u, 190581199u, 173411030u, 173411030u, 156175324u, 162663397u, 171117603u, 175639657u, 186322188u, 184421816u, 182783590u, 188943894u, 193727885u, 196087060u, 204475796u, 214371831u, 225316334u, 225316334u, 225316334u, 225316334u, \n169811929u, 217194457u, 235151954u, 219030344u, 207496184u, 174203839u, 170336647u, 176562667u, 184558108u, 188555744u, 195699059u, 182067231u, 165683231u, 165683008u, 165683008u, 165682785u, 182066785u, 195697933u, 188554400u, 184556644u, 176626837u, 170335481u, 174201537u, 207493768u, 219028280u, 235150382u, 217194151u, 169811623u, 169811776u, 169811776u, 169811929u, \n165683136u, 165683136u, 212148416u, 238100672u, 252321984u, 266215516u, 287121216u, 266214948u, 252321216u, 238099904u, 212147648u, 165682880u, 165682880u, 165683008u, 165683008u, 165683136u, \n58728256u, 66068163u, 77602463u, 89464479u, 85532208u, 82582940u, 83238176u, 90185133u, 96738875u, 111877691u, 118300219u, 127147532u, 132128205u, 132128576u, 132128576u, 132128947u, 127148148u, 118300741u, 111878213u, 96739397u, 90185939u, 83239264u, 82583781u, 85532752u, 89464801u, 77602785u, 66068413u, 58728256u, 58728256u, 58728256u, 58728256u, 0u );\nconst uvec2 boxes[] = uvec2[](\n  uvec2(995824755u,1005589728u),\n  uvec2(992285384u,1003361115u),\n  uvec2(915869339u,1169956144u),\n  uvec2(760483246u,978852549u),\n  uvec2(810159696u,821628783u),\n  uvec2(1040257625u,1042748034u),\n  uvec2(912857797u,918887149u),\n  uvec2(812786051u,1090792400u),\n  uvec2(821372841u,851716246u),\n  uvec2(699272227u,1369584062u),\n  uvec2(1149382495u,1165177018u),\n  uvec2(1276055680u,1297879521u),\n  uvec2(1284903709u,1307841736u),\n  uvec2(1106978479u,1135617969u),\n  uvec2(1203513096u,1220814842u),\n  uvec2(810165631u,843327271u),\n  uvec2(821372892u,851716246u),\n  uvec2(790308562u,822356025u),\n  uvec2(828320368u,861809760u),\n  uvec2(784738323u,816130452u),\n  uvec2(1134309084u,1150758821u),\n  uvec2(1149382495u,1165177018u),\n  uvec2(1103572516u,1132474275u),\n  uvec2(1108160523u,1141584339u),\n  uvec2(1130639506u,1166815869u),\n  uvec2(1213345709u,1239101808u),\n  uvec2(996810455u,1086988670u),\n  uvec2(938743710u,1031412038u),\n  uvec2(999627538u,1016798293u),\n  uvec2(1086134881u,1091902450u),\n  uvec2(1043077664u,1049303988u),\n  uvec2(690233605u,723854037u),\n  uvec2(744170032u,771761136u),\n  uvec2(699866638u,728506197u),\n  uvec2(802431370u,817701553u),\n  uvec2(1112545350u,1117854251u),\n  uvec2(1125652418u,1147607479u),\n  uvec2(1126504047u,1146033974u),\n  uvec2(1114510173u,1144525998u),\n  uvec2(1094586557u,1118376211u),\n  uvec2(1012862991u,1050349871u),\n  uvec2(933892507u,1048908857u),\n  uvec2(740495839u,780538637u),\n  uvec2(734138035u,765398948u),\n  uvec2(757206248u,795676262u),\n  uvec2(805768355u,836046369u),\n  uvec2(781323974u,810225629u),\n  uvec2(970198684u,1169890608u),\n  uvec2(916525699u,1051728732u),\n  uvec2(760417710u,978459338u),\n  uvec2(812720515u,1090726864u),\n  uvec2(699210478u,1010770674u),\n  uvec2(1056574499u,1369518526u),\n  uvec2(3151113201u,3190828502u),\n  uvec2(521669216u,680005252u),\n  uvec2(575670880u,626004381u),\n  uvec2(969409683u,1127745440u),\n  uvec2(1023410816u,1073743776u),\n  uvec2(1012926880u,1084231168u),\n  uvec2(42271493u,175180529u),\n  uvec2(41943808u,133761145u),\n  uvec2(156174799u,233180774u),\n  uvec2(165681800u,235152376u),\n  uvec2(165682624u,287121600u),\n  uvec2(58727712u,132129120u)\n);\nconst int paths[] = int[](\n  14,28,570,800,820,852,890,1216,1248,2288,2320,2334,2342,2350,2370,2408,2416,2448,2486,2500,2508,2522,2554,2568,2606,2644,2658,2672,2680,2688,2696,2734,2760,2774,2788,2796,2804,2812,2826,2834,2866,2892,2906,2920,2934,2948,2956,3174,3308,3478,3768,3980,4546,4608,4670,4702,4764,4796,4858,4920,4952,5014,5076,5108,5170);\n\nconst int colors[boxes.length()] =\n  int[](7,7,6,6,0, 0,6,6,0,6, 0,0,0,0,0, 8,0,8,8,8, 0,0,8,8,8, 8,0,0,0,0, 0,8,8,8,8, 0,0,0,0,0, 4,8,8,8,8, 8,0,0,0,0, 0,0,0,\n        6,6,6,6,6, 6,6,6,6,6, 6,6);\n\n// The frame, easier to draw separately\nconst vec4 frame[] =\n  vec4[](vec4(36.500000,38.500122,463.500000,211.499939),\n         vec4(41.500000,43.500122,458.500000,206.499939),\n         vec4(26.500000,28.500122,473.500000,221.499939),\n         vec4(31.500000,33.500122,468.500000,216.499939));", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[702, 733, 772, 807, 992], [994, 1072, 1111, 1111, 1248], [1280, 1280, 1305, 1343, 1490], [1492, 1559, 1591, 1711, 1900], [1902, 1902, 1924, 1924, 2405], [2407, 2407, 2428, 2428, 2467], [2469, 2469, 2491, 2491, 2533], [2535, 2535, 2567, 2567, 2644], [2646, 2646, 2668, 2668, 2741], [2743, 2743, 2800, 2800, 5323]], "test": "untested"}
{"id": "NdjyRm", "name": "Glass Mandelbrot", "author": "amhall", "description": "Looking through glass with the Mandelbrot set imprinted. Mouse to rotate the cubemap. See comments to speed up.", "tags": ["mouse", "mandelbrot", "triangle", "glass", "heightmap", "orbit", "trap", "refract"], "likes": 37, "viewed": 842, "published": 3, "date": "1643286499", "time_retrieved": "2024-07-30T17:06:58.718879", "image_code": "// Looking through glass with the Mandelbrot set imprinted. There's a few\n// approximations/corners cut to simplify things but it still looks good.\n\n// Performance boosters in order of importance: enable CIRCLEORBIT in buffer A,\n// reduce maxIters in buffer A, disable DISPERSE, disable FRESNEL.\n\n// Buffer A renders the heightmap, which is used here to calculate the surface normal\n// and have a field day from there.\n\n// Created by Anthony Hall\n\n\n// Refracts an individual beam for each color channel\n#define DISPERSE\n\n// Introduces some reflection according to (slightly modified) Fresnel equation\n#define FRESNEL\n\n// Index must be at least 1.0 as the shader is not designed to handle total internal\n// reflection. 1.52 is the refractive index of glass, disperse intensity is arbitrary\n// because the dispersion is not exactly physically modeled\nconst float refractiveIndex = 1.52;\nconst float disperseIntensity = 0.02;\n\n// This is inversely proportional to the max height of the heightmap, i.e. raising this\n// will treat the map as flatter\nconst float normalZScale = 5.0;\n\nconst float fov = radians(70.0);\n\nfloat convertHeight(vec2 rawHeight)\n{\n    return rawHeight.x + rawHeight.y / 1024.0;\n}\n\nvec3 getNormal(vec2 fragCoord, float height)\n{\n    float xSign = 2.0 * float(fragCoord.x < iResolution.x - 1.0) - 1.0;\n    float ySign = 2.0 * float(fragCoord.y < iResolution.y - 1.0) - 1.0;\n    float heightX = convertHeight(texelFetch(iChannel0, ivec2(fragCoord + vec2(xSign, 0)), 0).xy);\n    float heightY = convertHeight(texelFetch(iChannel0, ivec2(fragCoord + vec2(0, ySign)), 0).xy);\n    \n    float dx = xSign * (heightX - height);\n    float dy = ySign * (heightY - height);\n    return normalize(vec3(-dx, -dy, normalZScale / min(iResolution.x, iResolution.y))); // Correct against resolution\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The ray intersection is treated as if the glass is flat because doing\n    // otherwise is more expensive than it's worth\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float height = convertHeight(texelFetch(iChannel0, ivec2(fragCoord), 0).xy);\n    vec3 normal = getNormal(fragCoord, height);\n    \n    float effectMix = smoothstep(0.0, 3.0, iTime); // Strength of refraction/dispersion\n    float index = 1.0 + (refractiveIndex - 1.0) * effectMix;\n    \n    vec3 rayDir = normalize(vec3(uv * tan(fov / 2.0), -1.0));\n    vec3 refracted = refract(rayDir, normal, 1.0 / index);\n    \n    // Rotation/mouse input\n    float xyTheta;\n    float yzTheta;\n    float xzTheta;\n    if (iMouse.z > 0.0)\n    {\n        xyTheta = 0.0;\n        yzTheta = (iMouse.y / iResolution.y - 0.5) * pi;\n        xzTheta = (2.0 * iMouse.x / iResolution.x - 1.0) * pi;\n    }\n    else\n    {\n        xyTheta = -0.031 * iTime;\n        yzTheta = 0.45 - 0.05 * cos(0.11 * iTime);\n        xzTheta = -0.04 * iTime;\n    }\n    mat3 rayMat = xyRotate(xyTheta);\n    rayMat = yzRotate(yzTheta) * rayMat;\n    rayMat = xzRotate(xzTheta) * rayMat;\n    \n#ifdef DISPERSE\n    vec3 refractedG = refract(rayDir, normal,\n        1.0 / (index + effectMix * disperseIntensity));\n    vec3 refractedB = refract(rayDir, normal,\n        1.0 / (index + 2.0 * effectMix * disperseIntensity));\n#endif\n    \n#ifdef FRESNEL\n    // Fresnel for S polarization - It's already subtle, so it's hardly noticeable at\n    // all with any amount of P polarization reflectance factored in. Since it's subtle\n    // I also change the exponent to bring up the low values a bit\n    float cosIncident = abs(dot(rayDir, normal));\n    float cosRefracted = abs(dot(refracted, normal));\n    float reflectance = (cosIncident / index - cosRefracted)\n        / (cosIncident / index + cosRefracted);\n    reflectance = pow(abs(reflectance), 1.7); // 2.0 for scientific accuracy\n#endif\n    \n    refracted = rayMat * refracted;\n    \n#ifdef DISPERSE\n    refractedG = rayMat * refractedG;\n    refractedB = rayMat * refractedB;\n#endif\n    \n#ifdef FRESNEL\n\n#ifdef DISPERSE\n    vec3 transmitColor = vec3(\n        texture(iChannel1, refracted).r,\n        texture(iChannel1, refractedG).g,\n        texture(iChannel1, refractedB).b);\n#else\n    vec3 transmitColor = texture(iChannel1, refracted).rgb;\n#endif\n\n    vec3 reflected = rayMat * reflect(rayDir, normal);\n    vec3 reflectColor = texture(iChannel1, reflected).rgb;\n    vec3 color = mix(transmitColor, reflectColor, reflectance);\n    \n#else\n\n#ifdef DISPERSE\n    vec3 color = vec3(\n        texture(iChannel1, refracted).r,\n        texture(iChannel1, refractedG).g,\n        texture(iChannel1, refractedB).b);\n#else\n    vec3 color = texture(iChannel1, refracted).rgb;\n#endif\n\n#endif\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The buffer generates the heightmap of the Mandelbrot set by using smooth iteration\n// count with a little bit of orbit trapping to spice things up. Unfortunately I got\n// greedy with this whole shader and supersampling is too expensive.\n\n// Circular orbit trap is cheaper than triangular\n//#define CIRCLEORBIT\n\nconst float maxIters = 400.0;\n\n// This tool is always useful for finding interesting regions (with coordinates)\n// within double precision limits\n// https://sciencedemos.org.uk/mandelbrot.php\nconst vec2 zoomCenter = 0.5 * vec2(\n    -0.111792418416\t- 0.105212213568,\n    -0.902231313283 - 0.899972653438);\n\nvec2 cSquare(vec2 c)\n{\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\n// \"Triangular\" distance from origin (or circle with CIRCLEORBIT)\nfloat orbit(vec2 point)\n{\n#ifdef CIRCLEORBIT\n    return dot(point, point);\n#endif\n    point.y = abs(point.y);\n    return max(point.x, dot(point, vec2(-0.5, 0.5 * sqrt(3.0))));\n}\n\n// Returns iteration count and triangle orbit distance\nvec2 mandelbrot(vec2 C)\n{\n    vec2 z = C;\n    float zz; // z . z\n    float orbitDist = 100.0;\n    float iters;\n    const float bound = 32.0;\n    \n    // This optimizes the smooth iteration formula and brings it into the format I want\n    const float smoothIterOffset = -log2(log2(bound)) - 2.0;\n    \n    for (iters = 0.0; iters < maxIters; iters++)\n    {\n        z = cSquare(z) + C;\n        zz = dot(z, z);\n        if (zz >= bound * bound)\n            break;\n        orbitDist = min(orbitDist, orbit(z));\n    }\n    // See Inigo Quilez's article on smooth iteration count\n    // https://iquilezles.org/articles/msetsmooth\n    if (iters != maxIters)\n        iters -= (log2(log2(zz)) + smoothIterOffset);\n        \n    return vec2(iters, orbitDist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float smoothTime; // Time that smoothly transitions from 0 to normal speed\n    if (iTime < 2.0)\n        smoothTime = 0.25 * iTime * iTime;\n    else\n        smoothTime = iTime - 1.0;\n    float rotTime = 0.11 * smoothTime;\n    float zoom = exp2(-10.0 * (0.5 - 0.5 * cos(0.16 * iTime)));\n    \n    vec2 center = mix(zoomCenter, vec2(-0.6, 0.0), pow(zoom, 1.3));\n    vec2 point = center + 1.35 * rotate(rotTime) * uv * zoom;\n    vec2 result = mandelbrot(point);\n    \n#ifdef CIRCLEORBIT\n    float height = log2(result.x) / log2(maxIters)\n        + 0.05 * cos(2.0 * log2(result.y));\n#else\n    float height = log2(result.x) / log2(maxIters)\n        + 0.05 * cos(3.0 * log2(result.y));\n#endif\n    \n    // Half float smallest interval is 1/1024 when the value is between 1 and 2\n    // (max height is a little over 1)\n    // To get better resolution, the first channel is a quantized height value\n    // and the second channel is the fractional component between the steps\n    float h1 = floor(height * 1024.0) / 1024.0;\n    float h2 = fract(height * 1024.0);\n    fragColor = vec4(h1, h2, 1, 1);\n}", "buffer_a_inputs": [], "common_code": "const float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\nmat2 rotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat2(cs.x, cs.y, -cs.y, cs.x);\n}\n\nmat3 xyRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat3(\n        cs.x, cs.y, 0,\n        -cs.y, cs.x, 0,\n        0, 0, 1);\n}\n\nmat3 yzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat3(\n        1, 0, 0,\n        0, cs.x, cs.y,\n        0, -cs.y, cs.x);\n}\n\nmat3 xzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat3(\n        cs.x, 0, cs.y,\n        0, 1, 0,\n        -cs.y, 0, cs.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1112, 1112, 1149, 1149, 1198], [1200, 1200, 1246, 1246, 1799], [1801, 1801, 1858, 1986, 4681]], "test": "untested"}
{"id": "7d2yRw", "name": "contraction", "author": "FabriceNeyret2", "description": "opposite variant of https://shadertoy.com/view/Nd2yzm\nNote that we only manipulate the UV space. -> change the texture or video in Image buffer.", "tags": ["short", "parameterization", "destroy"], "likes": 14, "viewed": 450, "published": 3, "date": "1643275647", "time_retrieved": "2024-07-30T17:06:59.566613", "image_code": "// opposite variant of https://shadertoy.com/view/Nd2yzm\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    O = texture(iChannel2, O.xy ) * O.a;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iFrame < 1 ) { O = vec4(U/R,1,1); return; }\n    O = fract(sin(float(iFrame/1) *vec4(127.1,311.7, 269.5,183.3)) *43758.5453123);\n    vec2 p = O.xy,                              // choose a random line\n         d = cos( 6.28*O.z + vec2(0,1.57) );\n    U /= R;\n    p -=U; p -= dot(p,d)*d;                     // vector distance to line\n    float l = length(p);\n    U -= p/l / R;                               // move UVs asside the line\n    U = .5/R + U*(1.-1./R);\n    O = texture(iChannel0,U);\n    if (keyToggle(32))\n        O.a *= smoothstep( 0., 1./R.y, l );     // trace fracture\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2yRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 96, 96, 153]], "test": "untested"}
{"id": "Nd2yzm", "name": "fracturation", "author": "FabriceNeyret2", "description": "SPACE to draw the faults.    TAB for shrinking compensation.\n\nNote that we only manipulate the UV space. -> change the texture or video in Image buffer.\nsee opposite in https://www.shadertoy.com/view/7d2yRw", "tags": ["short", "parameterization", "destroy"], "likes": 27, "viewed": 539, "published": 3, "date": "1643274411", "time_retrieved": "2024-07-30T17:07:00.429306", "image_code": "// see opposite in https://www.shadertoy.com/view/7d2yRw\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    O = texture(iChannel2, O.xy ) * O.a;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iFrame < 1 ) { O = vec4(U/R,1,1); return; }\n    O = fract(sin(float(iFrame/1) *vec4(127.1,311.7, 269.5,183.3)) *43758.5453123);\n    vec2 p = O.xy,                              // choose a random line\n         d = cos( 6.28*O.z + vec2(0,1.57) );\n    U /= R;\n    p -=U; p -= dot(p,d)*d;                     // vector distance to line\n    float l = length(p);\n    U += p/l / R;                               // move UVs asside the line\n    if (keyToggle(9)) \n        U = -.5/R + U*(1.+1./R);                // optionnal compensation shriking\n    O = texture(iChannel0,U);\n    if (keyToggle(32))\n        O.a *= smoothstep( 0., 1./R.y, l );     // trace fracture\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2yzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 96, 96, 153]], "test": "untested"}
{"id": "ssBczm", "name": "Texture Stencil Library", "author": "davidar", "description": "Drop-in replacements for the texture function which automatically apply filters to the image. This demo uses it to implement a concise version of cornusammonis' Suture Fluid", "tags": ["sobel", "blur", "texture", "gradient", "derivative", "field", "vector", "gaussian", "difference", "stencil", "library", "laplacian", "finite"], "likes": 15, "viewed": 411, "published": 3, "date": "1643257606", "time_retrieved": "2024-07-30T17:07:01.292997", "image_code": "// Library code is in the Common tab\n// Demo of using it to reimplement Suture Fluid is in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // apply Sobel filter to Buffer B\n    vec4 dx = texGradX(iChannel0, uv);\n    vec4 dy = texGradY(iChannel0, uv);\n    fragColor = 10. * sqrt(dx*dx + dy*dy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Suture Fluid\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\nmat2 rotate2d(float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (iFrame < 10) {\n        fragColor = vec4(noise(16.0 * uv + 1.1), noise(16.0 * uv + 2.2), noise(16.0 * uv + 3.3), 0);\n        return;\n    }\n\n    float divergence = texture(iChannel0, uv).z;\n    divergence += .3 * texLapl(iChannel0, uv).z; // divergence smoothing\n    divergence += .2 * (texGradX(iChannel0, uv).x + texGradY(iChannel0, uv).y); // divergence update\n\n    vec2 stepSize = 6. / iResolution.xy;\n    vec2 velocity = texture(iChannel0, uv).xy;\n    vec2 advected = texBlur(iChannel0, uv - stepSize * velocity).xy;\n    advected += .05*texLapl(iChannel0, uv).xy;\n    advected -= .05*texture(iChannel0, uv).xy * divergence;\n    advected -= .80*texLapl(iChannel0, uv).z  * normz(velocity);\n\n    float curl = texGradX(iChannel0, uv).y - texGradY(iChannel0, uv).x;\n    advected *= rotate2d(2.4 * curl);\n\n    if (length(advected) > 1.) advected = normalize(advected);\n    divergence = clamp(divergence, -1., 1.);\n    fragColor.xyz = mix(texture(iChannel0, uv).xyz, vec3(advected, divergence), .2); // update smoothing\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* Texture Stencil Library https://www.shadertoy.com/view/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https://davidar.io/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. / vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n// Gaussian/binomial blur\n// https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n// Laplacian, optimal 9-point stencil\n// https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) / 6.;\n}\n\n// horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) / 8.;\n}\n\n// vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) / 8.;\n}\n\n\n\n\n\n// IQ's simplex noise:\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n", "buffer_b_code": "// Visualization of the system in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 norm = normalize(texture(iChannel0, uv).xyz);\n    fragColor.xyz = .5 + .6 * cross(norm, vec3(.5,-.4,.5)) + .1 * norm.z;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 158, 158, 364]], "test": "untested"}
{"id": "fd2cRw", "name": "Gradient Scan", "author": "oneshade", "description": ".", "tags": ["gradient", "scan"], "likes": 24, "viewed": 236, "published": 3, "date": "1643255721", "time_retrieved": "2024-07-30T17:07:04.274026", "image_code": "const float TAU = 6.28318530718;\n\n// Minimal required 2D autodiff\nvec3 sub(in vec3 f, in float g) { f.x -= g; return f; }\nvec3 mul(in vec3 f, in vec3 g) { return vec3(f.x * g.x, dot(f.xy, g.yx), dot(f.xz, g.zx)); }\nvec3 square(in vec3 f) { return vec3(f.x * f.x, 2.0 * f.x * f.yz); }\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvec3 f(in vec2 p) {\n    vec3 x = vec3(p.x, 1.0, 0.0), y = vec3(p.y, 0.0, 1.0);\n\n    vec3 res = vec3(1.0, 0.0, 0.0);\n    float n = 5.0;//mod(floor(0.5 * iTime), 6.0) + 1.0;\n    for (float k=0.0; k < n; k++) {\n        float an = TAU * k / n;\n        res = mul(res, square(sub(x, cos(an))) + square(sub(y, sin(an))));\n    }\n\n    return sub(res, 1.0);\n}\n\n#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec3 res = f(uv);\n    color.rg = normalize(res.yz);\n    drawSDF(res.x / length(res.yz), vec4(0.0, 0.0, 1.0, 0.5));\n\n    uv.y -= iTime;\n    float h = floor(uv.y) + 0.5;\n    //vec2 prev = vec2(-1.95, h) + 0.25 * normalize(f(vec2(-2.0, h + iTime)).yz);\n    for (float x=-2.0; x < 2.0; x += 0.05) {\n        //vec2 cur = vec2(x, h) + 0.25 * normalize(f(vec2(x, h + iTime)).yz);\n        vec2 p = vec2(x, h);\n        vec3 res = f(vec2(x, h + iTime));\n        drawSDF(sdLine(uv, vec2(x, h), vec2(x, h) + 0.5 * normalize(res.yz)), vec4(1.0));\n        //drawSDF(sdLine(uv, prev, cur), vec4(1.0));\n        //prev = cur;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2cRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 66, 99, 99, 121], [122, 122, 154, 154, 214], [215, 215, 239, 239, 283], [285, 285, 332, 332, 440], [442, 442, 461, 461, 791], [885, 885, 940, 940, 1735]], "test": "untested"}
{"id": "7dBczm", "name": "Cubefield (Game)", "author": "Plento", "description": "Recreation of the classic flash game. Started this a long time ago and kinda forgot about it. All it needed was hit detection. (Arrow keys to move, R to reset game.) Original game: https://www.cubefield.org.uk/ ", "tags": ["3d", "game", "cube", "field", "recreation", "cubefield", "flashgame"], "likes": 15, "viewed": 4865, "published": 3, "date": "1643255416", "time_retrieved": "2024-07-30T17:07:05.424949", "image_code": "// Fork of \"cubefield 5\" by Plento. https://shadertoy.com/view/Wd3SWM\n// 2022-01-27 01:59:38\n\n// By Cole Peterson (Plento)\n\n// A recreation of the classic flash game: https://www.cubefield.org.uk/\n\n/*\nControls:\n\nLeft and Right arrow keys (side movement)\nR to reset game.\n\n*/\n\n// How long can you go?\n\n\n// Main image\n\nfloat t(vec2 p){return texture(iChannel1, p).w;}\nvec4 t2(vec2 p){return texture(iChannel2, p);}\n\nfloat t0(){return texture(iChannel0, vec2(0.48, 0.03)).w;}\nfloat t1(){return texture(iChannel0, vec2(0.48, 0.03)).y;}\n\nvec4 letter(vec2 p, vec2 c){\n    vec2 p2 = p - .5;\n    p /= 16.;\n    p += (1. / 16.) * c;\n    vec4 col = t2(p);\n    col *= (1.-step(.3 / 16., abs(p2.x / 16.)));\n    col *= (1.-step(.4 / 16., abs(p2.y / 16.)));\n    return col;\n}\n\nfloat gameOver(vec2 p){\n    float c = 0.;\n    c += letter((p - vec2(.0, 0.5)) * 5., vec2(7., 11.)).x;\n    c += letter((p - vec2(.1, 0.5)) * 5., vec2(1., 11.)).x;\n    c += letter((p - vec2(.2, 0.5)) * 5., vec2(13., 11.)).x;\n    c += letter((p - vec2(.3, 0.5)) * 5., vec2(5., 11.)).x;\n    c += letter((p - vec2(.3, 0.2)) * 5., vec2(15., 11.)).x;\n    c += letter((p - vec2(.4, 0.2)) * 5., vec2(6., 10.)).x;\n    c += letter((p - vec2(.5, 0.2)) * 5., vec2(5., 11.)).x;\n    c += letter((p - vec2(.6, 0.2)) * 5., vec2(2., 10.)).x;\n    //c += letter((p - vec2(.7, 0.2)) * 5., vec2(1., 13.)).x;\n    return c;\n}\n\n\nfloat timer(vec2 p, float t, float stop){\n    float c = 0.;\n    \n    vec4 n = vec4(mod(floor(t), 10.), mod(floor(t / 10.), 10.),\n                mod(floor(t / 100.), 10.), mod(floor(t / 1000.), 10.));\n    \n    if(stop > 0.) n = vec4(0);\n    \n    c += letter((p - vec2(.5, 0.0)) * 5., vec2(n.x, 12.)).x;\n    c += letter((p - vec2(.4, 0.0)) * 5., vec2(n.y, 12.)).x;\n    c += letter((p - vec2(.3, 0.0)) * 5., vec2(n.z, 12.)).x;\n    c += letter((p - vec2(.2, 0.0)) * 5., vec2(n.w, 12.)).x;\n    \n    return c;\n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec4 bB = texture(iChannel1, uv);\n    vec4 bA = texture(iChannel0, uv);\n    vec3 col = bB.xyz;\n    \n    col = mix(col, vec3(.1), timer((uv - vec2(.67, 0.))*2.8, iTime - t1(), bA.w));\n    \n    if(bA.w > 0.){\n        uv.y += cos(uv.x*3. + iTime)*.11;\n        float dt = iTime - t0();\n        float t = clamp(0., 1., dt * 2.);\n        float a = t * gameOver(uv-vec2(.08, 0.5 - t*.4));\n        col = mix(col, vec3(0.8, 0.1, 0.), a);\n    }\n    col *= min(1., iTime*4.);\n    \n    f = vec4(col, 1.0);\n}\n\n\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Keyboard input + player values\n\nvec4 buf(vec2 p){return texture(iChannel1, p);   }\nfloat t(vec2 p){return texture(iChannel2, p).w;}\n\n// Check if player should be dead\nint playerState(){\n    float blft = t(vec2(0.48, 0.03));\n    float brgt = t(vec2(0.523, 0.03));\n    float ulft = t(vec2(0.48, 0.095));\n    float urgt = t(vec2(0.523, 0.095));\n    \n    if(ulft > 0. || urgt > 0. &&  (blft < 1. && brgt < 1.))\n        return 1;\n    else if(ulft < 1. && urgt < 1. &&  (blft > 0. || brgt > 0.))\n        return 0;\n    else\n        return 0;\n}\n\n// Will get time of death\nfloat t0(){return texture(iChannel1, vec2(0.48, 0.03)).w;}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n\tvec2 uv = u.xy / R.xy;\n    vec4 bA = buf(uv);\n    \n\tfloat pos = bA.x;\n    float tilt = bA.z;\n    float state = bA.w;\n    float resetTime = bA.y;\n    float RESET = texelFetch( iChannel0, ivec2(KEY_R, 0), 0 ).x;\n    \n    // Reset the game\n    if(RESET > 0.){\n        state = 0.;\n        pos = 0.; \n        tilt = 0.0;\n        resetTime = iTime;\n        f = vec4(pos, resetTime, tilt, state);\n        return;\n    }\n    \n    // Player is dead, \n    if(state != 0.0){\n        state = t0();\n        f = vec4(pos, resetTime, tilt, state);\n        return;\n    }\n    \n    // Save time of death\n    if(playerState() == 1) state = iTime;\n     \n       \n    float left = texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x;\n    float right = texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x;\n    float up = texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x;\n    float down = texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x;\n    \n    \n    pos += moveSpeed * right;\n    pos -= moveSpeed * left;\n    \n    \n    tilt += tiltspeed * right;\n    tilt += -1. * tiltspeed * left;\n    tilt -= 0.008 * sign(tilt);\n    tilt = clamp(tilt, -0.1, 0.1);\n    \n    // Init\n    if(iFrame < 5){\n    \tpos = 0.; \n        tilt = 0.0;\n        state = 0.0;\n        resetTime = 0.;\n    }\n    \n    f = vec4(pos, resetTime, tilt, state);\n}\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Raymarched graphics and death detection\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat triangle( in vec2 p ){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\n// Game speed\nfloat speed(float t){\n    t *= speedMultiplier;\n    return min((t + 12.) * (t + 12.) * acc, 1000.);\n}\n\n// Mat id cuz theres 3 seperate grids\nfloat mat = 0.;\nfloat md = 99.;\nvoid newmat(float d, float nm){\n    if(d < md){\n        md = d;\n        mat = nm;\n    }\n}\n\n// Distance field\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    vec3 p = rp - vec3(0., -.4, 0.);\n    vec3 p2 = rp - vec3(1.4, -.4, 4.);\n    vec3 p3 = rp - vec3(2.1, -.4, 4.);\n    \n    float id = floor(p.z / b);\n    float id2 = floor(p2.z / b);\n    float id3 = floor(p3.z / b);\n    \n    p.xz = mod(p.xz, b)-.5*vec2(b);\n    p2.xz = mod(p2.xz, b)-.5*vec2(b);\n    p3.xz = mod(p3.xz, b)-.5*vec2(b);\n    \n    p.x += (2.*hash11(id*100.)-1.) * 0.5;\n    p2.x += (2.*hash11(id2*500. + 44.4)-1.) * 0.5;\n    p3.x += (2.*hash11(id3*500. + 44.4)-1.) * 0.5;\n    \n    d = min(sdBox(p,vec3(0.15))-0.008, d);\n    newmat(d, 0.);\n    d = min(sdBox(p2,vec3(0.15))-0.008, d);\n    newmat(d, 1.);\n    d = min(length(rp)-0.05, d);\n    newmat(d, 2.);\n    \n    d = sub(sdBox(rp, vec3(12.)), d);\n\n    return d;\n}\n\nvec3 getNormal( in vec3 pos){\n    vec2 e = vec2(0.004, -0.004);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat edge(vec3 n){\n    float i = abs(dot(vec3(1., 0., 0.), n));\n    float j = abs(dot(vec3(0., 1., 0.), n));\n    float k = abs(dot(vec3(0., 0., 1.), n));\n    return i + j + k;\n}\n\nfloat t0(){return texture(iChannel0, vec2(0.48, 0.03)).w;}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv2 = uv;\n    \n    vec3 ro = vec3(0.0, 0.17, -7.);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec4 data = texture(iChannel0, u/R); // Player data\n    \n    float tilt = data.z;\n    if(abs(tilt) < .01) tilt = 0.0;\n    \n    // Move player and stuff\n    if(data.w == 0.) ro.z += speed(iTime - data.y);\n    else ro.z += speed(t0() - data.y);\n        \n    ro.x += data.x*3.;\n    \n    rd.xy*=rot(tilt);\n    uv*=rot(tilt);\n    \n    // Raymarch stuff\n    float d = 0., t = 0., md = 99., g = 0., ol = 0.;   \n    float asp = R.y / R.x;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \t   \n        md = min(md, d);\n        if(d < 0.002 || t > FAR){\n            break;\n        }\n        if(d >= md && abs(d) > .12){\n            ol += ss(.01, .018, md);\n            g++;\n        }\n        t += d * .85;\n    }\n    \n    ol /= max(g, .00001);\n    \n    vec3 p = ro+rd*t;\n    vec3 n = getNormal(p);\n    \n    vec3 bgcol = mix(vec3(0.65, 0.65, 0.7), vec3(.93), ss(0.0,0.009, uv.y+0.045)); // bg color\n    \n    float fade = ss(FAR-3.5, FAR, t);\n    \n    // Mat id because there's 3 offset grids\n    float of = 440.;\n    if(mat == 1.){\n        p.x -= 1.7;\n        of = 800.;\n    }\n    else if(mat == 2.){\n        p.x -= 2.1;\n        of = 544.4;\n    }\n    \n    vec2 id = floor(p.xz / vec2(b));\n    float h = 111. * (id.x*50. + id.y * 80.);\n    \n    vec3 cubecol = mix(vec3(0.9, 0.4, 0.0), vec3(0.9, 0.8, 0.0), hash11(h + 22. + of));\n    vec3 col = mix(cubecol, bgcol, fade);\n    \n    float ol2 = min(1.0, 1.-ss(1.0, 1.6, edge(n))+fade);\n    col *= ol;\n    col *= ol2;\n    \n    vec2 tv = uv+vec2(0.0, 0.45);\n    \n    // Death \"explode\" effect\n    if(data.w > 0.){\n        vec2 dir = normalize(vec2(0.0, 0.45) - uv);\n        float k = min((iTime - data.w) * .5, 0.11);\n        vec2 hh = u + iTime*(1.-step(.11, k));\n        vec2 h = dir * (1.-2.*hash22(hh)) * k;\n        tv += vec2(h.x*5., h.y*.3);\n    }\n    \n    col = mix(vec3(0.3), col, ss(0.0, 0.1, triangle((tv)*25.)));\n    \n    // 2D Hit box\n    float kill = (1.-step(.04, abs(uv2.x))) * (1.-step(.04, abs(uv2.y + .443)));\n    float death = 0.;\n    if(t < 3. && kill > 0.) death = 1.;\n    \n    col = mix(vec3(.25), col, ss(.8, .796, abs(uv2.x)));\n    //col += .2*vec3(kill); // show player hitbox\n    f = vec4(col, death);\n}\n\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// Game params\nconst float speedMultiplier = 1.0;\nconst float moveSpeed = 0.006;\nconst float tiltspeed = 0.015;\nconst float acc = 0.08;  // speed acceleration\n\nconst float b = 2.5; // grid space\n\nconst float FAR = 10.; // render distance\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_R  = 82;\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 333, 333, 365], [366, 366, 382, 382, 412], [414, 414, 425, 425, 472], [473, 473, 484, 484, 531], [533, 533, 561, 561, 760], [762, 762, 785, 785, 1363], [1366, 1366, 1407, 1407, 1872], [1876, 1876, 1916, 1916, 2479]], "test": "untested"}
{"id": "7sScRm", "name": "simple 2d cat face", "author": "snerp", "description": "click to have it look at the mouse, meow", "tags": ["face"], "likes": 5, "viewed": 227, "published": 3, "date": "1643250122", "time_retrieved": "2024-07-30T17:07:06.275674", "image_code": "// mit license\nvec4 faceCol = vec4(.22, .16, .11, 1.0);\nvec4 faceStripeCol = vec4(.32, .22, .11, 1.0);\nvec4 white = vec4(1, 1, 1, 1.0);\nvec4 eyeWhite = vec4(.95, .95, .95, 1.0);\nvec4 whiteShadow = vec4(.85, .8, .8, 1.0);\nvec4 black = vec4(0, 0, 0, 1.0);\nvec4 eyeBlue = vec4(0, .8, .9, 1.0);\nvec4 eyeYellow = vec4(.9, .8, 0, 1.0);\nvec4 mouthPink = vec4(.9, .4, .6, 1.0);\n\nbool oval(vec2 uv, vec2 center, vec2 scale) {\n    return (length((uv - center) / scale) < 1.0);\n}\n\nvec4 face(vec2 uv) {\n    if (oval(uv, vec2(.5), vec2(.49))\n    || (oval(uv, vec2(.85,.8), vec2(.19)) && oval(uv, vec2(.9,.75), vec2(.19)))\n    || (oval(uv, vec2(.15,.8), vec2(.19)) && oval(uv, vec2(.1,.75), vec2(.19)))) {\n        if (cos(15.0*(uv.y-abs(uv.x-.5))) > .4) return faceStripeCol;\n        return faceCol;\n    }\n    return vec4(0);\n}\n\nvec2 smileWarpEye(vec2 inp) {\n    inp.y -= .2 - 2.0* inp.x * inp.x;\n    return inp * vec2(1.0, .7);\n}\n\nvec4 leftEye(vec2 uv, vec2 pos, vec2 lookDir, float blink, float blinkmod, float angry, vec4 irisCol, vec2 scl) {\n    uv.y +=blinkmod*.2;\n    blink *= 1.0 - blinkmod;\n    vec2 off = uv - pos;\n    uv.y -=blinkmod*.2;\n    off = mix(off, smileWarpEye(off), blinkmod);\n    vec2 eyeAngle = normalize(vec2(-angry,1.0));\n    float mov = abs(dot(normalize(off), eyeAngle));\n    off *= (1.0 + mov*.2);\n    vec2 fulloff = off * (1.0 + mov*10.0);\n    vec2 fakeuv = pos + mix(fulloff, off, blink);\n    if (!oval(fakeuv, pos, scl * vec2(.195, .195))) return vec4(0);\n    if (!oval(fakeuv, pos + scl * vec2(.0,-.01), scl * vec2(.193, .193) * blink)) return black;\n    if (!oval(fakeuv, pos - scl * vec2(0.01,.02), scl * vec2(.19, .19) * blink)) return whiteShadow;\n    if (oval(uv, pos + scl * vec2(.08), scl * vec2(.04,.02))) return white;\n    if (oval(uv, pos - scl * vec2(.05), scl * vec2(.02,.02))) return white;\n    if (oval(uv, pos + scl * lookDir * 1.1, scl * vec2(.03, .06))) return black;\n    if (oval(uv, pos + scl * lookDir, scl * vec2(.08, .13))) return irisCol;\n    return eyeWhite;\n}\n\nvec4 rightEye(vec2 uv, vec2 pos, vec2 lookDir, float blink, float blinkmod, float angry, vec4 irisCol, vec2 scl) {\n    uv.y +=blinkmod*.2;\n    blink *= 1.0 - blinkmod;\n    vec2 off = uv - pos;\n    uv.y -=blinkmod*.2;\n    off = mix(off, smileWarpEye(off), blinkmod);\n    vec2 eyeAngle = normalize(vec2(angry,1.0));\n    float mov = abs(dot(normalize(off), eyeAngle));\n    off *= (1.0 + mov*.2);\n    vec2 fulloff = off * (1.0 + mov*10.0);\n    vec2 fakeuv = pos + mix(fulloff, off, blink);\n    if (!oval(fakeuv, pos, scl * vec2(.195, .195))) return vec4(0);\n    if (!oval(fakeuv, pos + scl * vec2(.0,-.01), scl * vec2(.193, .193)* blink)) return black;\n    if (!oval(fakeuv, pos - scl * vec2(-0.01,.02), scl * vec2(.19, .19) * blink)) return whiteShadow;\n    if (oval(uv, pos + scl * vec2(.08), scl * vec2(.04,.02))) return white;\n    if (oval(uv, pos - scl * vec2(.05), scl * vec2(.02,.02))) return white;\n    if (oval(uv, pos + scl * lookDir * 1.1, scl * vec2(.03, .06))) return black;\n    if (oval(uv, pos + scl * lookDir, scl * vec2(.08, .13))) return irisCol;\n    return eyeWhite;    \n}\n\nvec4 mouth(vec2 uv, vec2 pos, float Open, float smile) {\n    float open = Open*.15;\n    if(oval(uv, pos+vec2(.0,.025), vec2(.005, .04))) return black;\n    if(oval(uv, pos+vec2(.032,.0425), vec2(.015, .026))) return black;\n    if(oval(uv, pos+vec2(-.032,.0425), vec2(.015, .026))) return black;\n    if(oval(uv, pos+vec2(.0,.08), vec2(.06, .08))\n    && oval(uv, pos+vec2(.0,.05), vec2(.08, .05))) return mouthPink;\n    \n    float upper = clamp(smile*3.5, 0.2, 1.0);\n    float lower = clamp(smile*-3.5, 0.0, 1.0);\n    if (oval(uv, pos+vec2(.15,.03-.010 * upper+.02*lower), vec2(.14, .08-.08*lower))) return vec4(0);\n    if (oval(uv, pos+vec2(-.15,.03-.010 * upper+.02*lower), vec2(.14, .08-.08*lower))) return vec4(0);\n    if(!(oval(uv, pos+vec2(.03,-.14), vec2(.19, .12*lower))\n    || oval(uv, pos+vec2(-.03,-.14), vec2(.19, .12*lower))) ){\n    \n    if(oval(uv, pos+vec2(.12 - .041 * lower,-.010 - .071 * lower), vec2(.15, .08 +.04* lower))) return black;\n    if(oval(uv, pos+vec2(-.12 + .041 * lower,-.010 - .071 * lower), vec2(.15, .08+.04* lower))) return black;\n    }\n    \n    if(oval(uv, pos+vec2(.0,.08), vec2(.25, .10))) return vec4(0);\n    \n    if(oval(uv, pos+vec2(.0,.1-open), vec2(.15, .18 * Open))) {\n        if(oval(uv, pos+vec2(.07,-.04), vec2(.0125, .068))) return white;\n        if(oval(uv, pos+vec2(-.07,-.04), vec2(.0125, .068))) return white;\n        if(oval(uv, pos+vec2(.04,-open*1.4), vec2(.0125, .038))) return white;\n        if(oval(uv, pos+vec2(-.04,-open*1.4), vec2(.0125, .038))) return white;\n        return mouthPink;\n    }\n    if(oval(uv, pos+vec2(.0,.1-open), vec2(.16, .19 * Open))) return black;\n    return vec4(0);\n}\n\nvec4 witch_mouth(vec2 uv, vec2 pos, float Open, float smile) {\n\n    float open = Open*.15;\n    \n    if(oval(uv, pos+vec2(.0,.1 - .08*smile), vec2(.19, .08))) return vec4(0);\n    bool lower = oval(uv, pos+vec2(.0,-.12 - .08*smile), vec2(.19, .08));\n    if(!lower) {\n    if(oval(uv, pos+vec2(.0,-.01 + .02*smile), vec2(.19, .08))) return black;\n    }\n    \n    if (uv.y < pos.y || lower) {\n    if(oval(uv, pos+vec2(.0,.1-open), vec2(.15, .18 * Open))) {\n        return mouthPink;\n    }\n    if(oval(uv, pos+vec2(.0,.1-open), vec2(.16, .19 * Open))) return black;\n    }\n    return vec4(0);\n}\n\nvec4 add(vec4 col, vec4 col2) {\n    return mix(col, col2, col2.a);\n}\n\nvec4 map(vec2 uv, vec2 lookDir) {\n    vec4 col;\n    float smile = cos(iTime);\n    col = face(uv);\n    \n    float n = 16.2;\n    float blink = .03 + .5*abs(n+n*.75*(sin(iTime*2.0) + sin(iTime * 1.4)));\n    \n    float blinkMod = max(0.0, smile);\n    blink = (clamp(blink, 0.00001, 1.0));\n    col = add(col, leftEye(uv, vec2(.75, .6), lookDir*.15, blink, blinkMod, 0.0, eyeBlue, vec2(1.0)));\n    col = add(col, rightEye(uv, vec2(.25, .6), lookDir*.15, blink, blinkMod, 0.0, eyeYellow, vec2(1.0)));\n    col = add(col, mouth(uv, vec2(.5, .35), 0.75+0.25*cos(3.70*iTime), smile));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0)/iResolution.xy;\n    vec2 uv = fragCoord * aspect;\n    vec2 mouseDir = iMouse.xy/iResolution.xy*2.0-1.0;//iMouse.xy * aspect - vec2(.9, .6);\n    // Output to screen\n    fragColor = map(uv-vec2(.35,0.0), mouseDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sScRm.jpg", "access": "api", "license": "mit", "functions": [[371, 371, 416, 416, 468], [470, 470, 490, 490, 813], [815, 815, 844, 844, 916], [918, 918, 1031, 1031, 2001], [2003, 2003, 2117, 2117, 3090], [3092, 3092, 3148, 3148, 4740], [4742, 4742, 4804, 4804, 5328], [5330, 5330, 5361, 5361, 5398], [5400, 5400, 5433, 5433, 5996], [5999, 5999, 6056, 6106, 6378]], "test": "untested"}
{"id": "sdBczm", "name": "Color Wallpaper", "author": "BeardThings", "description": "Simple color sketch", "tags": ["simple", "sketch", "playful"], "likes": 13, "viewed": 340, "published": 3, "date": "1643248452", "time_retrieved": "2024-07-30T17:07:07.053595", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sphr(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a=iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.y += sin(iTime+uv.x*6.0)*0.2;\n    \n    bool hit = false;\n    for(float f=0.; f<64.; f+=1.)\n    {\n        float t=f/64.*(3.14*2.-0.1);\n        hit = hit || sphr(uv-vec2(sin(t),cos(t))*sin(iTime+3.14*(0.0125*f)),0.01)<0.;\n    }\n    \n    fragColor = hit ? (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4))).rgbr : vec4(0.);\n    fragColor += textureLod(iChannel0, ((fragCoord)/iResolution.xy), 2.5)*0.99;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 142]], "test": "untested"}
{"id": "flyXD3", "name": "destroy a square", "author": "ml", "description": "Genuary2022 Day 5: \"Destroy a square.\"\n\nIt's a little bit hacky (the blur/blob effect will look different on different resolutions).", "tags": ["genuary", "genuary2022"], "likes": 6, "viewed": 268, "published": 3, "date": "1643247221", "time_retrieved": "2024-07-30T17:07:07.969147", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TAU 6.2831853071 \n#define sqaureSize 0.8\n\nbool inSquare(vec2 uv){\n    return max(abs(uv.x), abs(uv.y)) < sqaureSize*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy-vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    if(iFrame == 0){\n        float v = inSquare(uv) ? 0. : 1.;\n        fragColor = inSquare(uv) ? vec4(hash33(vec3(iFrame, (uv+vec2(1., 1.))*100.)), 1.) : vec4(vec3(0.), 1.);\n        return;\n    }\n    \n    float angle = hash12(vec2(iFrame, 0.))*TAU;\n    vec2 p1 = (hash22(vec2(iFrame, 1.))-vec2(0.5))*sqaureSize;\n    vec2 p2 = p1+vec2(cos(angle),sin(angle));\n    \n    \n    float lineSide = ((p2.x - p1.x) * (uv.y - p1.y) - (p2.y - p1.y) * (uv.x - p1.x));\n        \n    float angle2 = angle + sign(lineSide)* TAU*0.25;\n    \n    if(hash12(vec2(iFrame, 3.)) < 0.5) angle2 += TAU*0.5;\n    \n    float movement =  0.0038;//0.002+0.01*  hash12(vec2(iFrame, 5.));\n        \n    if(hash12(vec2(iFrame, 6.)) < 0.8) movement = 0.5/iResolution.x;//0.0001;//hash12(vec2(iFrame, 6.))\n    \n    vec2 colPos = uv +movement*vec2(cos(angle2), sin(angle2));\n    \n    float lineSide2 = ((p2.x - p1.x) * (colPos.y - p1.y) - (p2.y - p1.y) * (colPos.x - p1.x));\n    \n    \n    colPos.x *= iResolution.y/iResolution.x;\n    colPos += vec2(0.5, 0.5);\n    \n    //float j = 0.01;\n    //colPos += (vec2(j)*hash23(vec3(iFrame, fragCoord))-vec2(j*0.5))/iResolution.xy;\n    \n    vec4 textureCol = texture(iChannel0, colPos);\n    vec4 currentCol = texture(iChannel0, uv);\n    \n    if(sign(lineSide) != sign(lineSide2)){\n        if(textureCol != vec4(0.) || abs(lineSide) < movement*0.8){\n            float r = hash12(vec2(iFrame, 4.));\n            //random rgb\n            vec3 randRgb = hash32(vec2(iFrame, 2.));\n            vec3 col = randRgb;//floor(randRgb+vec3(0.5));\n            if(r < 0.25) col = vec3(0.);\n            //else if(r <.2) col = vec3(0.);\n\n            fragColor = vec4(col, 1.);//vec4(0.2, 0.98, 0.05, 1.);\n            return;\n        }\n    }\n    \n    fragColor = smoothstep(0., 1., textureCol);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define seed 55.\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p += seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    p.x += seed;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3.x += seed;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    p += seed;\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    p.x += seed;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3.x += seed;\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   p += seed;\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    p.x += seed;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3.x += seed;\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    p += seed;\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    p.x += seed;\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    p.x += seed;\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4.x += seed;\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]], "test": "untested"}
{"id": "ssSczw", "name": "Big Bang sim", "author": "wyatt", "description": "inspired by ersh could be better but I like how it looks around 9 seconds", "tags": ["bigbang"], "likes": 25, "viewed": 552, "published": 3, "date": "1643235794", "time_retrieved": "2024-07-30T17:07:08.852784", "image_code": "// Fork of \"MPM dambreak\" by wyatt. https://shadertoy.com/view/NdSczm\n// 2022-01-26 21:42:50\n\n// Fork of \"Material Point Method\" by wyatt. https://shadertoy.com/view/fssyDs\n// 2022-01-26 19:42:56\n\nMain\n    vec4 c = C(U);\n    Q = 1.-sin(c.w-4.*c.z/R.x+vec4(1,2,3,4));\n    Q *= c.w;\n    \n    Q += .01*D(U).wwww;\n    Q = (atan(Q));\n    if(U.x<3.||U.y<6.||R.x-U.x<3.||R.y-U.y<3.) Q *= 0.;\n    //Q = D(U).xxxx/R.x/R.y;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\nfloat G (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat building(vec2 U) {\n    \n    return 1.;\n\n}\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\nfloat _12(vec2 U) {\n    U = floor(U);\n    return U.x+U.y*R.x;\n}\nvec2 _21(float i) {\n    return .5+vec2(mod(i,R.x),floor(i/R.x));\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n    \n    vec2 u = U-.5*R;\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = .0*u/(1.+dot(u,u));\n    \n    for (float x = -2.; x <= 2.; x ++) \n    for (float y = -2.; y <= 2.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 c = C(Q.xy+vec2(x,y));\n        vec4 d = D(Q.xy+vec2(x,y));\n        f -= .01*(.07*c.w*c.w-4.*d.w)*vec2(x,y)/(x*x+y*y);\n    }\n    \n    //if (length(f)>.1) f = .1*normalize(f);\n    Q.zw = mix(Q.zw,c.xy,.005);\n    Q.zw += f;\n    Q.xy += Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.zw *= 0.;\n    if (Q.x<1.) Q.zw *= 0.;\n    if (R.y-Q.y<1.) Q.zw *= 0.;\n    if (R.x-Q.x<1.) Q.zw *= 0.;\n\n    if (M.z>0.) Q.zw -= 1e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        Q.zw = .5*vec2(-u.y,u.x)/(1.+length(u));\n        Q.zw -= 1.*u/(1.+length(u));\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    vec4 d = D(U);\n    vec4 a = A(d.xy);\n    float o = d.y;//_12(d.xy);\n    if (cell(U-a.xy)&&i<4) Q[i++]= o;\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    float w = 0.;\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        for (int k = 0; k < 4; k++) {\n            if (b[k]>0.) {\n                vec2 u = _21(b[k]);\n                vec4 a = A(u);\n                vec2 v = a.xy-U;\n                float e = G(length(v),1.);\n                w += e;\n                Q.xyz += vec3(a.zw,u.x)*e;\n                Q.w += G(length(v),1.);\n            } else break;\n        }\n    }\n    if (w>0.) Q.xy /= w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void X (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid Y (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n\n}\nMain\n    vec4 c = C(U);\n    Q.w = c.w;\n    float m = 0.;\n    for (float x = -3.; x <= 3.; x++)\n    for (float y = -3.; y <= 3.; y++)\n    {\n        vec4 c = C(U+vec2(x,y));\n        m += D(U+vec2(x,y)+c.xy*c.w).w/49.;\n    }\n    \n    Q.w = .02*Q.w+.997*m;\n    \n    if (U.x<3.||R.x-U.x<3.||U.y<3.||R.y-U.y<3.)\n        Q.w *= 0.;\n\n    Q.xy = D(U).xy;\n    if (I%12==0) \n        Q.x = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        X(U,Q,D(U+vec2(0,k)));\n        X(U,Q,D(U+vec2(k,0)));\n        X(U,Q,D(U-vec2(0,k)));\n        X(U,Q,D(U-vec2(k,0)));\n    }\n        \n        Y(U,Q,Q.yxzw);\n        Y(U,Q,D(U+vec2(0,1)));\n        Y(U,Q,D(U+vec2(1,0)));\n        Y(U,Q,D(U-vec2(0,1)));\n        Y(U,Q,D(U-vec2(1,0)));\n        Y(U,Q,D(U+vec2(0,2)));\n        Y(U,Q,D(U+vec2(2,0)));\n        Y(U,Q,D(U-vec2(0,2)));\n        Y(U,Q,D(U-vec2(2,0)));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dByzw", "name": "Multiple Neighborhood CA 2", "author": "SlackermanzCA", "description": "Continuous Multiple Neighborhood Cellular Automata", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 7, "viewed": 334, "published": 3, "date": "1643234411", "time_retrieved": "2024-07-30T17:07:10.048587", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   4086443839u, 803560891u, 3521573439u, 155586747u, \n    2355529581u, 3804082561u, 1278181521u, 1198599219u, \n    790900093u, 2043079403u, 72510135u, 329989440u, \n    1205735441u, 1165390975u, 1863025477u, 1552315409u, \n    1460749058u, 1961704519u, 1063988442u, 304586942u, \n    1969173229u, 623707175u, 2719649363u, 533620173u, \n    734380903u, 1866742626u, 69847740u, 779938642u, \n    3928012151u, 1597352029u, 1939485308u, 1599391651u, \n    824038858u, 498247516u, 609160531u, 634145519u, \n    2022645937u, 4285315796u, 87513080u, 246410766u, \n    1160189374u, 688725303u, 1266836767u, 670912482u, \n    2162941226u, 1742659144u, 481786434u, 3618106514u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1067687164u, 1122344419u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nstruct ConvData {\n\tvec4 \tvalue;\n\tfloat \ttotal;\n};\n\n\nConvData ring( float r ) {\n\n\tconst float psn = 32768.0;\n\n\tfloat tot = 0.0;\n\tvec4  val = vec4(0.0,0.0,0.0,0.0);\n\n\tfloat sq2\t= sqrt(2.0);\n\n\tfloat o_0 = r + 0.5;\n\tfloat o_1 = sq2 * o_0;\n\tfloat o_2 = o_1 / 2.0;\n\tfloat o_3 = sqrt( o_0*o_0 - r*r );\n\tfloat o_4 = o_2 - ( floor(o_2) + 0.5 );\n\tfloat o_5 = floor( o_2 ) + floor( o_4 );\n\n\tfloat i_0 = r - 0.5;\n\tfloat i_1 = sq2 * i_0;\n\tfloat i_2 = i_1 / 2.0;\n\tfloat i_3 = sqrt( i_0*i_0 - r*r );\n\tfloat i_4 = i_2 - ( floor(i_2) + 1.0 );\n\tfloat i_5 = floor( i_2 ) + floor( i_4 );\n\n\tfloat d_0 = ( i_5 ) + 1.0 - ( o_5 );\n\n\tfor(float i = 1.0; i < floor( i_2 ) + 1.0 - d_0; i++) {\n\n\t\tfloat j_0 = sqrt( o_0*o_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_1 = sqrt( i_0*i_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_2 = ( 1.0 - abs( sign ( (floor( i_2 ) + 1.0) - i ) ) );\n\n\t\tfor(float j = floor( j_1 ) + j_2; j < floor( j_0 ); j++) {\n\t\t\tval += floor(gdv(ivec2( i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1), i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1), i), txdata) * psn);\n\t\t\ttot += 8.0 * psn; } }\n\n//\tOrthagonal\n\tval += floor(gdv(ivec2( r, 0), txdata) * psn);\n\tval += floor(gdv(ivec2( 0,-r), txdata) * psn);\n\tval += floor(gdv(ivec2(-r,-0), txdata) * psn);\n\tval += floor(gdv(ivec2(-0, r), txdata) * psn);\n\ttot += 4.0 * psn;\n\n//\tDiagonal\n//\tTODO This is not quite perfect\n\tfloat k_0 = r;\n\tfloat k_1 = sq2 * k_0;\n\tfloat k_2 = k_1 / 2.0;\n\tfloat k_3 = sqrt( k_0*k_0 - r*r );\n\tfloat k_4 = k_2 - ( floor(k_2) + 1.0 );\n\tfloat k_5 = floor( k_2 ) + floor( k_4 );\n\n\tfloat dist = round(k_2);\n\n\tif( sign( o_4 ) == -1.0 ) {\n\t//\tval += gdv(ivec2( (floor(o_5)+1), floor(o_5)+1), txdata);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\ttot += 4.0 * psn; }\n\n\treturn ConvData( val, tot ); }\n\n\nvec4 conv( float r ) {\n\tConvData nh = ring( r );\n\treturn \tnh.value / nh.total; }\n    \nvec4 bitmake(ConvData[MAX_RADIUS] rings, uint bits, uint of) {\n\tvec4  sum = vec4(0.0,0.0,0.0,0.0);\n\tfloat tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings[i].value; tot += rings[i].total; } }\n\treturn sum / tot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tConvData[MAX_RADIUS] nh_rings_m;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) { nh_rings_m[i] = ring(float(i+1u)); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  80.0 *  128.0;\n\tconst\tfloat \tn  \t\t= mnp *  80.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub[2],  ub[3],\n\t\tub[4],  ub[5],  ub[6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tvec4[12] smnca_res = vec4[12](res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c);\n\n\tvec4 conv1 = conv(1.0);\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n                \n\t\tvec4 nhv = bitmake( nh_rings_m, nb[i/2u], (i & 1u) * 16u );\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 0u) && nhv[cho] <= utp( ur[i], 8u, 1u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * res_c[chm]; }\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 2u) && nhv[cho] <= utp( ur[i], 8u, 3u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * res_c[chm]; } }\n\n\tuvec4 dev_idx = uvec4(0u,0u,0u,0u);\n    \n\tvec4 dev = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < 6u; i++) {\n\t\tvec4 smnca_res_temp = abs(res_c - smnca_res[i]);\n\t\tif(smnca_res_temp[0] > dev[0]) { dev_idx[0] = i; dev[0] = smnca_res_temp[0]; }\n\t\tif(smnca_res_temp[1] > dev[1]) { dev_idx[1] = i; dev[1] = smnca_res_temp[1]; }\n\t\tif(smnca_res_temp[2] > dev[2]) { dev_idx[2] = i; dev[2] = smnca_res_temp[2]; }\n\t\tif(smnca_res_temp[3] > dev[3]) { dev_idx[3] = i; dev[3] = smnca_res_temp[3]; } }\n\n\tres_v[0] = smnca_res[dev_idx[0]][0];\n\tres_v[1] = smnca_res[dev_idx[1]][1];\n\tres_v[2] = smnca_res[dev_idx[2]][2];\n\tres_v[3] = smnca_res[dev_idx[3]][3];\n\n    res_c = ((res_v + (conv1 * (s*2.13333))) / (1.0 + (s*2.13333)))- 0.01 * s;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dByzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]], "test": "untested"}
{"id": "ssBcRw", "name": "columns and flags", "author": "jorge2017a2", "description": "columns and flags", "tags": ["columnsandflags"], "likes": 5, "viewed": 202, "published": 3, "date": "1643233042", "time_retrieved": "2024-07-30T17:07:11.049910", "image_code": "//----------image\n//por jorge2017a2-\n///columns and flags\n//26-ene-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 Bloque1(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    float r1, r2, he;\n    r1=3.0; r2=2.0; he=5.0;\n    float d1= sdTrapezoid( p.xy,r1,r2,he );\n    float d2= sdTrapezoid( p.zy,r1,r2,he );\n    float d3= sdBox( p, vec3(4.5,6.0,4.5) );\n    float d4= sdBox( p-vec3(0.0,5.25,0.0), vec3(2.5,0.25,2.5) );\n    float dif=intersectSDF(d1,d3);\n    dif=intersectSDF(dif,d2);\n    res =opU3(res, vec3(dif,100.0,-1.0));\n    res =opU3(res, vec3(d4,1.0,-1.0));\n    return res;\n}\n\nvec3 Bloque2(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    float r1, r2, he;\n    r1=2.0; r2=1.5; he=5.0;\n    float d1= sdTrapezoid( p.xy,r1,r2,he );\n    float d2= sdTrapezoid( p.zy,r1,r2,he );\n    float d3= sdBox( p, vec3(4.5,6.0,4.5) );\n    float d4= sdBox( p-vec3(0.0,5.25,0.0), vec3(2.0,0.25,2.0) );\n    float d5= sdBox( p-vec3(0.0,7.5,0.0), vec3(0.25,2.0,0.25) );\n    float d6= sdBox( p-vec3(3.0,9.0,0.0), vec3(3.0,1.0,0.25) );\n    float dif=intersectSDF(d1,d3);\n    dif=intersectSDF(dif,d2);\n    res =opU3(res, vec3(dif,4.0,-1.0));\n    res =opU3(res, vec3(d4,1.0,-1.0));\n    res =opU3(res, vec3(d5,1.0,-1.0));\n    res =opU3(res, vec3(d6,2.0,-1.0));\n    return res;\n}\n\nvec3 FiguraFull(vec3 p)\n{ vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    vec3 re1=Bloque1(p);\n    vec3 re2=Bloque2(p-vec3(0.0,10.5,0.0));\n    res =opU3(res, re1);\n    res =opU3(res, re2);\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   p.y=p.y-5.0;\n    p.x= opRep1D(p.x, 20.0 );\n    p.z= opRep1D(p.z, 20.0 );\n    vec3 re1= FiguraFull(p);\n    res =opU3(res, re1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n\n    float minDist = 9999.0; \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{ float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\t\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4,0.2,1.0);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n    \n    float mov=100.0*sin(iTime);\n \tlight_pos1= vec3(-10.0, 140.0+mov, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 100.0+mov, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   \n   vec3 ro=vec3(10.0,7.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 568, 568, 589], [590, 590, 622, 622, 706], [708, 708, 755, 755, 782], [783, 783, 826, 826, 853], [854, 854, 902, 902, 930], [931, 969, 1005, 1005, 1050], [1053, 1053, 1078, 1078, 1097], [1098, 1098, 1123, 1123, 1142], [1143, 1143, 1179, 1179, 1207], [1209, 1209, 1274, 1274, 1584], [1586, 1586, 1608, 1608, 2069], [2071, 2071, 2093, 2093, 2759], [2761, 2761, 2786, 2786, 2970], [2972, 2972, 2997, 2997, 3280], [3282, 3282, 3306, 3306, 3468], [3470, 3470, 3519, 3519, 4146], [4148, 4148, 4184, 4184, 4429], [4431, 4431, 4468, 4468, 4740], [4742, 4742, 4825, 4825, 5399], [5401, 5401, 5450, 5450, 5530], [5532, 5532, 5625, 5625, 5755], [5757, 5757, 5789, 5789, 5986], [5988, 6036, 6064, 6064, 6260], [6262, 6262, 6309, 6309, 6535], [6537, 6537, 6630, 6630, 7118], [7121, 7121, 7148, 7148, 7237], [7239, 7239, 7297, 7297, 7345], [7347, 7347, 7370, 7370, 7488], [7490, 7490, 7521, 7521, 8233], [8236, 8236, 8293, 8293, 8863]], "test": "untested"}
{"id": "NdSczm", "name": "MPM dambreak", "author": "wyatt", "description": "every method has advantages and disadvantages... maybe I should just go outside and play in a stream", "tags": ["mpm"], "likes": 18, "viewed": 494, "published": 3, "date": "1643230350", "time_retrieved": "2024-07-30T17:07:11.945515", "image_code": "// Fork of \"Material Point Method\" by wyatt. https://shadertoy.com/view/fssyDs\n// 2022-01-26 19:42:56\n\nMain\n    vec4 c = C(U);\n    Q = 1.-sin(c.w-4.*c.z/R.x+vec4(1,2,3,4));\n    Q *= c.w;\n    \n    if(U.x<3.||U.y<6.||R.x-U.x<3.||R.y-U.y<3.) Q *= 0.;\n    \n    //Q = D(U)/R.x/R.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\nfloat erf(in float x) {\n    //x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\nfloat G (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat building(vec2 U) {\n    \n    if (U.x<.5*R.x) return 1.;\n    return 0.;\n\n}\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\nfloat _12(vec2 U) {\n    U = floor(U);\n    return U.x+U.y*R.x;\n}\nvec2 _21(float i) {\n    return .5+vec2(mod(i,R.x),floor(i/R.x));\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-.2/R.y);\n    \n    for (float x = -2.; x <= 2.; x ++) \n    for (float y = -2.; y <= 2.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 cc = C(Q.xy+vec2(x,y));\n        f -= .05*c.w*cc.w*(cc.w-1.)*vec2(x,y)/(x*x+y*y);\n    }\n    \n    if (length(f)>.1) f = .1*normalize(f);\n    Q.zw = mix(Q.zw,c.xy,.5);\n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.zw *= 0.;\n    if (Q.x<1.) Q.zw *= 0.;\n    if (R.y-Q.y<1.) Q.zw *= 0.;\n    if (R.x-Q.x<1.) Q.zw *= 0.;\n\n    if (M.z>0.) Q.zw -= 1e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    vec4 d = D(U);\n    vec4 a = A(_21(d.x));\n    if (cell(a.xy-U)&&i<4\n        &&d.x!=Q.x&&d.x!=Q.y&&d.x!=Q.z&&d.x!=Q.w\n    ) Q[i]= d.x;\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    float w = 0.;\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        float s = 1.;\n        float n = dot(vec4(b.x>0.,b.y>0.,b.z>0.,b.w>0.),vec4(1));\n        for (int k = 0; k < 4; k++) {\n            if (b[k]>0.) {\n                vec2 u = _21(b[k]);\n                vec4 a = A(u);\n                vec2 v = a.xy-U;\n                float e = G(length(v),s);\n                w += e;\n                Q.xyz += vec3(a.zw,u.x)*e;\n                Q.w += e;\n            } else break;\n        }\n    }\n    if (w>0.) Q.xy /= w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    \n    if (I<1) Q = vec4(_12(U));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssSyRD", "name": "Spinning Discs", "author": "byt3_m3chanic", "description": "Based on something animated I saw in a C4D group. Need to figure a better way for the math/timing - brute force based on mod of time/direction. ", "tags": ["raymarching", "animation", "looping"], "likes": 20, "viewed": 360, "published": 3, "date": "1643224986", "time_retrieved": "2024-07-30T17:07:12.930881", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Spinning Discs | Motion Replication\n    01/26/22 @byt3_m3chanic \n    \n    Based on something animated I saw in a C4D group. Need to figure a better\n    way for the math/timing - brute force based on mod of time.\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n#define MAX_DIST    175.\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat capp( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nvec3 hp,hitPoint;\nfloat tmod,ga1,ga2,ga3,ga4,ga5,ga6,ga7,ga8,ga9,ga10,ga11,ga12;\nmat2 er1,er2,er3,er4,er5,er6,er7,er8,er9,er10,er11,er12;\nmat2 dr1,dr2,dr3;\n\nfloat getcap(vec3 p, float h) {\n    float c1 = capp(p,1.5,h);  \n    p.x=abs(p.x)-2.;\n    return max(c1,-capp(p,1.5,h*2.));\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p+=vec3(1.35,2.2,-.25);\n    \n    vec3 pd = p-vec3(0,0,1);\n    pd.xz*=dr1;\n    float r1 = getcap(pd,1.5);\n    if(r1<res.x) {\n        res = vec2(r1,1.);\n        hp=pd;\n    }\n    \n    pd = p-vec3(2,-.25,1);\n    pd.xz*=dr2;\n    float r2 = getcap(pd,1.);\n    if(r2<res.x) {\n        res = vec2(r2,2.);\n        hp=pd;\n    }\n     \n    pd = p-vec3(-2,-.25,1); \n    pd.xz*=dr3;\n    float r3 = getcap(pd,.75);\n    if(r3<res.x) {\n        res = vec2(r3,3.);\n        hp=pd;\n    }\n\n    vec3 pxa = vec3(p.x,p.y,p.z-1.);\n    vec3 pxb = vec3(p.x,p.y,p.z-1.);\n    vec3 pxc = vec3(p.x+3.,p.y,p.z-1.);\n    vec3 pxd = vec3(p.x-3.,p.y,p.z-1.);\n\n    if(tmod<1.){\n    // move center\n        pxa.xz*=er1;\n        pxb.xz*=er1;\n        pxa.x+=1.;\n        pxb.x-=1.;\n    } else if(tmod<2.){\n    // move right\n        pxa = vec3(p.x-2.,p.y,p.z-1.);\n        pxd = vec3(p.x-2.,p.y,p.z-1.);\n        pxb = vec3(p.x+1.,p.y,p.z-1.);\n        pxc = vec3(p.x+3.,p.y,p.z-1.);\n        pxa.xz*=er2;\n        pxd.xz*=er2;\n        pxa.x+=1.;\n        pxd.x-=1.;\n    } else if(tmod<3.){\n    // move left\n        pxa = vec3(p.x-3.,p.y,p.z-1.);\n        pxd = vec3(p.x-1.,p.y,p.z-1.);\n        pxb = vec3(p.x+2.,p.y,p.z-1.);\n        pxc = vec3(p.x+2.,p.y,p.z-1.);\n        pxb.xz*=er3;\n        pxc.xz*=er3;\n        pxb.x-=1.;\n        pxc.x+=1.;       \n        \n    } else if(tmod<4.){\n    // move center\n        pxa = vec3(p.x-3.,p.y,p.z-1.);\n        pxb = vec3(p.x+3.,p.y,p.z-1.);\n        pxc = vec3(p.x,p.y,p.z-1.);\n        pxd = vec3(p.x,p.y,p.z-1.);\n        pxc.xz*=er4;\n        pxd.xz*=er4;\n        pxc.x+=1.; \n        pxd.x-=1.;\n    } else if(tmod<5.){\n    // move right\n        pxb = vec3(p.x+3.,p.y,p.z-1.);\n        pxc = vec3(p.x-2.,p.y,p.z-1.);\n        pxa = vec3(p.x-2.,p.y,p.z-1.);\n        pxd = vec3(p.x+1.,p.y,p.z-1.);\n        pxa.xz*=er5;\n        pxc.xz*=er5;\n        pxa.x-=1.; \n        pxc.x+=1.;\n        \n    } else if(tmod<6.){\n    // move left\n        pxc = vec3(p.x-3.,p.y,p.z-1.);\n        pxa = vec3(p.x-1.,p.y,p.z-1.);\n        pxb = vec3(p.x+2.,p.y,p.z-1.);\n        pxd = vec3(p.x+2.,p.y,p.z-1.);\n        pxd.xz*=er6;\n        pxb.xz*=er6;\n        pxd.x-=1.; \n        pxb.x+=1.;\n    } else if(tmod<7.){\n    // move center\n        pxc = vec3(p.x-3.,p.y,p.z-1.);\n        pxd = vec3(p.x+3.,p.y,p.z-1.);\n        pxb = vec3(p.x,p.y,p.z-1.);\n        pxa = vec3(p.x,p.y,p.z-1.);\n        pxb.xz*=er7;\n        pxa.xz*=er7;\n        pxb.x+=1.;\n        pxa.x-=1.;\n    } else if(tmod<8.){\n    // move right\n        pxd = vec3(p.x+3.,p.y,p.z-1.);\n        pxa = vec3(p.x+1.,p.y,p.z-1.);\n        pxc = vec3(p.x-2.,p.y,p.z-1.);\n        pxb = vec3(p.x-2.,p.y,p.z-1.);\n        pxc.xz*=er8;\n        pxb.xz*=er8;\n        pxc.x-=1.;\n        pxb.x+=1.;\n    } else if(tmod<9.){\n    // move left\n        pxd = vec3(p.x+2.,p.y,p.z-1.);\n        pxa = vec3(p.x+2.,p.y,p.z-1.);\n        pxc = vec3(p.x-1.,p.y,p.z-1.);\n        pxb = vec3(p.x-3.,p.y,p.z-1.);\n        pxa.xz*=er9;\n        pxd.xz*=er9;\n        pxa.x-=1.;\n        pxd.x+=1.;\n    } else if(tmod<10.){\n     // move center\n        pxd = vec3(p.x,p.y,p.z-1.);\n        pxc = vec3(p.x,p.y,p.z-1.);\n        pxa = vec3(p.x+3.,p.y,p.z-1.);\n        pxb = vec3(p.x-3.,p.y,p.z-1.);\n        pxc.xz*=er10;\n        pxd.xz*=er10;\n        pxc.x-=1.;\n        pxd.x+=1.;\n    } else if(tmod<11.){\n    // move right\n        pxd = vec3(p.x-2.,p.y,p.z-1.);\n        pxb = vec3(p.x-2.,p.y,p.z-1.);\n        pxc = vec3(p.x+1.,p.y,p.z-1.);\n        pxa = vec3(p.x+3.,p.y,p.z-1.);\n        pxb.xz*=er11;\n        pxd.xz*=er11;\n        pxb.x-=1.;\n        pxd.x+=1.;\n    } else if(tmod<12.){\n    // move left\n        pxd = vec3(p.x-3.,p.y,p.z-1.);\n        pxb = vec3(p.x-1.,p.y,p.z-1.);\n        pxc = vec3(p.x+2.,p.y,p.z-1.);\n        pxa = vec3(p.x+2.,p.y,p.z-1.);\n        pxa.xz*=er12;\n        pxc.xz*=er12;\n        pxa.x+=1.;\n        pxc.x-=1.;\n    }   \n    \n    float s8 = length(pxa-vec3(0,1.95,0))-.35;\n    if(s8<res.x) {\n        res = vec2(s8,8.);\n        hp=pxa;\n    }\n    pxa.x=abs(pxa.x)+1.025;\n    float d1 = capp(pxa,1.5,1.5);\n    if(d1<res.x) {\n        res = vec2(d1,4.);\n        hp=pxa;\n    }\n    \n    float s3 = length(pxb-vec3(0,1.05,0))-.15;\n    if(s3<res.x) {\n        res = vec2(s3,9.);\n        hp=pxb;\n    }\n    pxb.x=abs(pxb.x)+1.025;\n    float d3 = capp(pxb,1.5,.75);\n    if(d3<res.x) {\n        res = vec2(d3,5.);\n        hp=pxb;\n    }\n    \n    float s2 = length(pxc-vec3(0,.15,0))-.25;\n    if(s2<res.x) {\n        res = vec2(s2,6.);\n        hp=pxc;\n    }\n    pxc.x=abs(pxc.x)+1.025;\n    float d2 = capp(pxc+vec3(0,.35,0),1.5,.15);\n    if(d2<res.x) {\n        res = vec2(d2,7.);\n        hp=pxc;\n    }  \n    \n    float s4 = length(pxd-vec3(0,.35,0))-.2;\n    if(s4<res.x) {\n        res = vec2(s4,4.);\n        hp=pxd;\n    }\n    pxd.x=abs(pxd.x)+1.025;\n    float d4 = capp(pxd+vec3(0,.25,0),1.5,.25);\n    if(d4<res.x) {\n        res = vec2(d4,8.);\n        hp=pxd;\n    }\n    \n    float fx = p.y+.5;\n    if(fx<res.x) {\n        res = vec2(fx,0.);\n        hp=p;\n    }\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<1e-4) hit = true;\n        d += i<32? t.x*=.8:t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>65.) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 hue(float t){ \n    const vec3 d = vec3(0.365,0.910,0.067);\n    return .55 + .35*cos(PI2*t*(vec3(.95,.97,.98)*d)); \n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 100);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(-1.5,8,-2.5);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        float t=.25;\n        for( int i =0; i<16; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n        float px = fwidth(hitPoint.x);\n        \n        if(m==0.) {\n            float scale = 1.;\n            \n            vec2 uv = fract(hitPoint.xz*scale)-.5;\n            vec2 id= floor(hitPoint.xz*scale);\n            \n            float hs =hash21(id);\n            h=vec3(0.45);\n            ref=h;\n\n            float chk = mod(id.x+id.y,2.) * 2.-1.;\n            if(chk>.5) {\n                h=hue(hs);\n                ref=h;\n            }\n        }\n        \n        if(m==1.) {\n           h=vec3(0.004,0.322,0.616);\n           vec2 f = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n           f.x=fract(f.x*12.)-.5;\n           float c = length(f-vec2(0,.5))-.25;\n           c=smoothstep(.011+px,px,abs(abs(abs(c)-.1)-.05)-.02);\n           if(length(hitPoint.xz)>1.495) h=mix(h,vec3(1),c);\n           ref = h*.5;\n        }\n        \n        if(m==2.) {\n           h=vec3(0.518,0.545,0.518);\n           vec2 f = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n\n           f.x=fract(f.x*12.)-.5;\n           float sw = .5-.15*sin(f.x*PI2);\n           float c = length(f.y-sw)-.1;\n           \n           c=smoothstep(.011+px,px,abs(abs(abs(c)-.1)-.05)-.015);\n           if(length(hitPoint.xz)>1.495) h=mix(h,vec3(1),c);\n           ref = h*.5;\n        }\n        \n        if(m==3.) {\n           h=vec3(0.925,0.557,0.827);\n           vec2 f = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n           f=fract(f*vec2(24.,6.))-.5;\n           if(length(hitPoint.xz)>1.495) {\n           if(f.x*f.y>0.) h=vec3(.2);\n           }\n           ref = h*.15;\n        }\n        \n        if(m==4.) {\n            h=vec3(0.188,0.188,0.188);\n            ref = h*.15;\n        }\n        if(m==5.) {\n            h=vec3(0.675,0.784,0.867);\n            ref = h;\n        }\n        if(m==6.) {\n            h=vec3(0.278,0.529,0.761);\n            ref = h*.25;\n        }\n        if(m==7.) {\n            h=vec3(0.690,0.690,0.690);\n            ref = h*.5;\n        }\n        if(m==8.) {\n            h=vec3(0.859,0.694,0.541);\n            ref = h*.65;\n        }\n        if(m==9.) {\n            h=vec3(0.910,0.808,0.710);\n            ref = h*.25;\n        }\n        if(m==10.) {\n            h=vec3(0.859,0.694,0.541);\n            ref = h*.5;\n        }\n        RC = h * diff + min(spec,shdw);\n        if(bnc<1) RC = mix(RC,vec3(.05), 1.-exp(-.0025*d*d*d));\n        \n        ro = p+n*.002;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.149,0.157,0.173);\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tmod = mod(T*.5,12.);\n    if(tmod<1.){\n        float t1 = lsp(0.0, 1.0, tmod);\n        ga1 = eoc(t1);\n        ga1 = ga1*ga1*ga1;\n        er1=rot(ga1*PI);\n    } else if(tmod<2.){\n        float t2 = lsp(1.0, 2.0, tmod);\n        ga2 = eoc(t2);\n        ga2 = ga2*ga2*ga2;\n        er2=rot(-ga2*PI);\n    } else if(tmod<3.){\n        float t3 = lsp(2.0, 3.0, tmod);\n        ga3 = eoc(t3);\n        ga3 = ga3*ga3*ga3;\n        er3=rot(ga3*PI);\n    } else if(tmod<4.){\n        float t4 = lsp(3.0, 4.0, tmod);\n        ga4 = eoc(t4);\n        ga4 = ga4*ga4*ga4;\n        er4=rot(-ga4*PI);\n    } else if(tmod<5.){\n        float t5 = lsp(4.0, 5.0, tmod);\n        ga5 = eoc(t5);\n        ga5 = ga5*ga5*ga5;\n        er5=rot(ga5*PI);\n    } else if(tmod<6.){\n        float t6 = lsp(5.0, 6.0, tmod);\n        ga6 = eoc(t6);\n        ga6 = ga6*ga6*ga6;\n        er6=rot(-ga6*PI);\n    } else if(tmod<7.){\n        float t7 = lsp(6.0, 7.0, tmod);\n        ga7 = eoc(t7);\n        ga7 = ga7*ga7*ga7;\n        er7=rot(ga7*PI);\n    } else if(tmod<8.){\n        float t8 = lsp(7.0, 8.0, tmod);\n        ga8 = eoc(t8);\n        ga8 = ga8*ga8*ga8;\n        er8=rot(-ga8*PI);\n    } else if(tmod<9.){\n        float t9 = lsp(8.0, 9.0, tmod);\n        ga9 = eoc(t9);\n        ga9 = ga9*ga9*ga9;\n        er9=rot(ga9*PI);\n    } else if(tmod<10.){\n        float t10 = lsp(9.0,10.0, tmod);\n        ga10 = eoc(t10);\n        ga10 = ga10*ga10*ga10;\n        er10=rot(-ga10*PI);\n    } else if(tmod<11.){\n        float t11 = lsp(10.0,11.0, tmod);\n        ga11 = eoc(t11);\n        ga11 = ga11*ga11*ga11;\n        er11=rot(ga11*PI);\n    } else if(tmod<12.){\n        float t12 = lsp(11.0,12.0, tmod);\n        ga12 = eoc(t12);\n        ga12 = ga12*ga12*ga12; \n        er12=rot(-ga12*PI);\n    }   \n  \n    dr1=rot((ga1*PI)+(-ga4*PI)+(ga7*PI)+(-ga10*PI));\n    dr2=rot((-ga2*PI)+(ga5*PI)+(-ga8*PI)+(ga11*PI));\n    dr3=rot((ga3*PI)+(-ga6*PI)+(ga9*PI)+(-ga12*PI));\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 5.5;\n    vec3 ro = vec3(uv*zoom,-zoom-2.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    mat2 rx =rot(.78);\n    mat2 ry =rot(-.78);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    C = mix(C,vec3(.05), 1.-exp(-.00015*fA*fA*fA));\n    C = mix(C,FC,smoothstep(0.,1.,f*0.015));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSyRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[520, 520, 541, 541, 603], [604, 604, 623, 623, 668], [669, 669, 705, 705, 740], [741, 741, 760, 760, 785], [787, 787, 827, 827, 934], [1102, 1102, 1133, 1133, 1226], [1228, 1228, 1246, 1246, 6247], [6249, 6324, 6354, 6354, 6593], [6595, 6595, 6668, 6668, 6929], [6931, 6931, 6949, 6949, 7052], [7054, 7054, 7137, 7137, 10482], [10525, 10525, 10566, 10566, 13175]], "test": "untested"}
{"id": "7sjyRD", "name": "Star systems evolution in 3d 2", "author": "ersh", "description": "Star dynamics in 3d. Mass conservation guaranteed.", "tags": ["simulation"], "likes": 27, "viewed": 445, "published": 3, "date": "1643207023", "time_retrieved": "2024-07-30T17:07:13.715782", "image_code": "// (C) Copyright 2021 by Yury Ershov\n\n// https://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics\n\n#define PALETTE        0    // 0=fire, 1=blue, 2=green\n\nvec3 col(float x) {\n  return vec3(\n#if PALETTE == 0\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n#elif PALETTE == 1\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x, 0., 1./3.)\n#elif PALETTE == 2\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.)\n#endif\n   ) * 3.;\n}\n\nvec2 I3to2(in vec3 I3, in vec3 R3) {\n    I3 = floor(clamp(I3, vec3(0), R3-1.));\n    float offset = I3.x + I3.y*R3.x + I3.z*R3.x*R3.y;\n    vec2 I2;\n    I2.x = mod(offset, R2.x);\n    I2.y = floor(offset/R2.x);\n    return I2;\n}\n\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c,-s,s,c); }\n\n#define START_DIST   2.5\n#define FOV          5.\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if (sdBox(I - BUTTON_ORIGIN, BUTTON_SZ) <= 0.) {\n        O = vec4(0,0,1. - step(0.5, iMouse.z)*step(0., -sdButton)*0.5,1);\n        vec2 inner_sz = BUTTON_SZ - 2.;\n        float sdf = min(sdEquilateralTriangle(-(I - BUTTON_ORIGIN - vec2(3,0)).yx/inner_sz.y)*inner_sz.y,\n                        sdBox(I - BUTTON_ORIGIN + vec2(inner_sz.y,0), vec2(2,inner_sz.y)));\n        O.rgb = mix(O.rgb, vec3(1,1,1), smoothstep(1., -1., sdf));\n        return;\n    }\n\n    O = vec4(0,0,0,1);\n    mat2 rot_yz, rot_xy;            // rotations\n    if (iMouse.x < 0.5 || sdButton <= 0.) {\n      // https://graphtoy.com/?f1(x,t)=(floor(x/5)+smoothstep(0,1,fract(x/5)*10))*0.5&v1=true&f2(x,t)=&v2=false&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,7.451055876709886\n      rot_xy = rot(-(floor(iTime/7.)+smoothstep(0.,1.,fract(iTime/7.)*10.))*0.5);\n      rot_yz = rot(PI*0.40 + (floor(iTime/11.)+smoothstep(0.,1.,fract(iTime/11.)*10.)));\n    } else {\n      vec2 M = (iMouse.xy / R2.xy * vec2(1., -0.5) + vec2(0.5, 0.)) * 2. * PI;\n      rot_yz = rot(-M.y);\n      rot_xy = rot(-M.x);\n    }\n    vec3 p = vec3(0,0,START_DIST);                                       // current ray pos\n    p.yz *= rot_yz;  p.xy *= rot_xy;\n\n    vec3 D = normalize(vec3(I+I, -FOV*R2.y) - vec3(R2.xy, 0.));    // ray direction\n    D.yz *= rot_yz;  D.xy *= rot_xy;\n\n    vec3 R3 = Res2to3(R2.xy);\n    float scale2 = R3.x;\n    float c = 0.;\n    float n_c = 0.;\n    float st = 0.5/R3.z;\n    int n_steps = int(3./st);\n    vec3 st1 = st * D;\n    int n;\n    float axis = 99.;\n    for (p += D*(START_DIST - 1.5), n = 0; n < n_steps; n++, p += st1) {\n        vec3 coord = (p + 0.5) * scale2;\n        if (coord.x >= 0. && coord.y >= 0. && coord.z >= 0. &&\n            coord.x < R3.x && coord.y < R3.y && coord.z < R3.z) {\n            c += T(coord).a;\n            n_c++;\n#define SDF_AXIS(XX)   distance(coord.XX + coord.XX, R3.XX)\n            axis = min(\n                    min(axis, SDF_AXIS(xy)),\n                    min(SDF_AXIS(yz), SDF_AXIS(xz)));\n#define SDF_EDGE(XX)   distance(mod(coord.XX+coord.XX + R3.XX, R3.XX+R3.XX), R3.XX)\n            axis = min(\n                    min(axis, SDF_EDGE(xy)),\n                    min(SDF_EDGE(yz), SDF_EDGE(zx)));\n        }\n    }\n\n\tif (n_c > 0.) {\n        O.rgb = col(log(c*10000./n_c)/12.);\n        if (iMouse.z > 0.5) O.rgb = mix(O.rgb, vec3(1), smoothstep(1., 0., axis)/2.);\n    }\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define WALLS_BOUNCE   3          //   0: no bounce;  1: cube  2: sphere  3:wrap\n#define RANGE          5.\n\nconst float dt = 1.;\nconst float G = 0.01;\nconst float m_epsilon = 0.000001;\nconst float speed_rnd = 0.08;\nconst float center_gravity = 0.0008;\n\nvec2 vclamp(vec2 v) {\n    float l = length(v);\n    return l < 10. ? v : v/l;\n}\nvec3 vclamp3(vec3 v) {\n    float l = length(v);\n    return l < 10. ? v : v/l;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 position)\n{\n    vec3 p3 = vec3(position) + iTime * 500. + 50.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat overlapping_area(vec2 l1, vec2 r1, vec2 l2, vec2 r2) {\n    float x_dist = min(r1.x, r2.x) - max(l1.x, l2.x);\n    float y_dist = min(r1.y, r2.y) - max(l1.y, l2.y);\n    return x_dist > 0. && y_dist > 0. ? x_dist * y_dist : 0.;\n}\nfloat overlapping_volume(vec3 l1, vec3 r1, vec3 l2, vec3 r2) {\n    float x_dist = min(r1.x, r2.x) - max(l1.x, l2.x);\n    float y_dist = min(r1.y, r2.y) - max(l1.y, l2.y);\n    float z_dist = min(r1.z, r2.z) - max(l1.z, l2.z);\n    return x_dist > 0. && y_dist > 0. && z_dist > 0. ? x_dist * y_dist * z_dist : 0.;\n}\n\nvec2 randomizespeed(vec2 v) {\n    return vec2(v.x + (hash12(fract(v)*1573.32)-0.5)*speed_rnd,\n                v.y + (hash12(fract(v)*178362.78)-0.5)*speed_rnd);\n}\nvec3 randomizespeed(vec3 v) {\n    return vec3(v.x + (hash13(fract(v)*1573.32)-0.5)*speed_rnd,\n                v.y + (hash13(fract(v)*178362.78)-0.5)*speed_rnd,\n                v.z + (hash13(fract(v)*9573.234)-0.5)*speed_rnd);\n}\n\n\nvoid I2to3(in vec2 I, in vec3 R3, out vec3 I3) {\n    I = floor(I);\n    //I -= 0.5;\n    float offset = I.x + I.y*R2.x;\n    I3.x = mod(offset, R3.x);\n    I3.y = mod(floor(offset/R3.x), R3.y);\n    I3.z = min(floor(offset/R3.x/R3.y), R3.z-1.);\n}\nvec2 I3to2(in vec3 I3, in vec3 R3) {\n    I3 = floor(clamp(I3, vec3(0), R3-1.));\n    float offset = I3.x + I3.y*R3.x + I3.z*R3.x*R3.y;\n    vec2 I2;\n    I2.x = mod(offset, R2.x);\n    I2.y = floor(offset/R2.x);\n    return I2;\n}\n\n// Gas dynamics layer\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I2, R3 = Res2to3(R2.xy), I3);\n#if WALLS_BOUNCE != 3\n    //if (I3.x < 1.5 || I3.y < 1.5 || I3.z < 1.5 || I3.x > R3.x-1.5 || I3.y > R3.y-1.5 || I3.z > R3.z-1.5) { O=vec4(0.); return; }\n    if (any(lessThan(I3, vec3(1.5))) || any(greaterThan(I3, R3-vec3(1.5)))) { O=vec4(0.); return; }\n#endif\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        float r3 = distance(I3, R3/2.);\n        float r2 = distance(I3.xy, R3.xy/2.);\n        float init_r = R3.x/5.;\n        if (r3 < init_r) {\n            vec3 uv = I3 / R3;\n//            O = vec4(-(uv.y - 0.5)*init_r/(r2+1.)*17.,\n//                     (uv.x - 0.5)*init_r/(r2+1.)*17.,\n//                     (hash13(I3)-0.5)*2.,\n//                     hash12(I3.xy)*(init_r-r3)*0.8);\n            vec3 I3c = I3 - R3/2.;\n            vec2 v = pow(2.*G*init_r*init_r*init_r/7./init_r/length(I3c.xy), 0.5) * I3c.xy;\n            O = vec4(-v.y, v.x,\n                     (hash13(I3)-0.5)*2.,\n                     hash12(I3.xy)*(init_r-r3)*0.8);\n        } else {\n//            O = vec4(0.0,0.0,0.0,hash13(I3)*1000.*m_epsilon);\n            O = vec4(0.0);\n        }\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n    vec3 speed0 = pt0.rgb;\n    float mass0 = pt0.a;\n    vec3 f = vec3(0.);\n    vec3 p = vec3(0.);\n    float mass2 = 0.;\n\n    vec3 sh;\n#define RMIN           (-RANGE)\n#define RMAX           (RANGE+0.5)\n    for (sh.z = RMIN; sh.z < RMAX; sh.z+=1.) for (sh.y = RMIN; sh.y < RMAX; sh.y+=1.) for (sh.x = RMIN; sh.x < RMAX; sh.x+=1.) {\n        float l = length(sh);\n        vec3 coord1 = I3 + sh;\n        vec4 pt1 = T(\n#if WALLS_BOUNCE == 3\n            mod(coord1 + R3, R3)\n#else\n            coord1\n#endif\n        );\n        vec3 speed1 = pt1.rgb;\n        float mass1 = pt1.a;\n\n        if (l > 2.1) {    // must be 0.5 but bigger number prevents from collapsing into 2x2 dots.\n            // Gravity, acceleration\n            f += sh/l * mass0*mass1/l/l;\n        }\n\n        // speed: mass transfer, impulse change:\n        vec3 coord_next = coord1 + speed1 * dt;\n        float overlap = overlapping_volume(I3, I3+vec3(1.), coord_next, coord_next+vec3(1.));\n        float dm = mass1 * overlap;\n        mass2 += dm;\n        p += speed1 * dm;\n    }\n\n    // Slight gravity towards the center to compensate the inability to feel further than 10 pts.\n    vec3 to_c = R3/2. - I3;\n    to_c = length(to_c) < 3. ? vec3(0.) : normalize(to_c)*center_gravity;\n\n    O.a = mass2 > m_epsilon ? mass2 : 0.;\n    O.xyz =\n        mass2 > m_epsilon ?\n        vclamp3(randomizespeed(p/mass2 + dt * G*f/(mass0 > m_epsilon ? mass0 : mass2) + dt*to_c)) : vec3(0.);\n#if WALLS_BOUNCE == 1\n#define BOUNCE(X)    if (I3.X <= 11.) { if (O.X < 0.) O.X = abs(O.X)/2.; } else if (I3.X >= R3.X - 12.) { if (O.X > 0.) O.X = -abs(O.X)/2.; }\n    BOUNCE(x)\n    BOUNCE(y)\n    BOUNCE(z)\n#elif WALLS_BOUNCE == 2\n    I3 -= R3/2.;\n    if (length(I3) > R3.x/2.-10. && dot(I3, O.xyz) > 0.) {\n        O.xyz = reflect(O.xyz, normalize(I3));\n    }\n#endif\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// (C) Copyright 2021 by Yury Ershov\n\nconst vec2 BUTTON_SZ = vec2(14, 7);\nconst vec2 BUTTON_ORIGIN = BUTTON_SZ + 1.;\n\n#define R2       iResolution\n#define T(P)     texelFetch(iChannel0, ivec2(I3to2(P, R3)), 0)\n#define PI       3.14159265359\n\nvec3 Res2to3(in vec2 R2) {\n    return vec3(floor(pow(R2.x*R2.y, 1./3.)));  // 1200 / 80 = 13\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssjcRD", "name": "a basic checkerboard", "author": "ErinZ", "description": "basic checkerboard", "tags": ["checkerboard", "cineshader"], "likes": 4, "viewed": 4445, "published": 3, "date": "1643206078", "time_retrieved": "2024-07-30T17:07:14.543568", "image_code": "float checkerboard(vec2 coord, float size){\n    vec2 pos = floor(coord/size); \n    return mod(pos.x+pos.y,2.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord += iTime*50.0;\n    float size = 30.;\n    float c = checkerboard(fragCoord,size);\n    fragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 113], [114, 114, 171, 171, 301]], "test": "untested"}
{"id": "7s2yRD", "name": "ColourFlow", "author": "intrakits", "description": "I wanted to use a colouring to control the flow of stuff.", "tags": ["mouse", "fluid", "flow", "userinput"], "likes": 2, "viewed": 250, "published": 3, "date": "1643203909", "time_retrieved": "2024-07-30T17:07:15.490038", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texture(iChannel0, fragCoord/iResolution.xy);\n    //fragColor = vec4(abs(c.xy)*1.0f, abs(c.z)*100.0f, c.w);\n    \n    vec3 col = vec3(iqnoise(fragCoord/iResolution.xy*scale, irr, .2));\n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = 0.;\n        col.y=1.;\n    }\n    else{\n        col=vec3(0.);\n        col.x=1.;\n        col.y = 0.;\n    }\n    c.xyz= mix(c.xyz,col,.4);\n    fragColor = vec4(c.xyz,1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 t = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 r = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 b = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 l = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(iqnoise(uv*scale, irr, .2));\n    col.z=0.;\n\n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = r.x*delta;\n        col.y=r.x;\n    }\n    else{\n        col=vec3(0.);\n        col.x=b.y;\n        col.y = b.y*delta;\n    }\n    \n    fragColor = vec4(col.xy,0,1);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// advection & boundary & control\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = texelFetch(iChannel0, ivec2(fragCoord), 0);  \n    \n    float d = length((fragCoord/iResolution.xy)-(iMouse.xy/iResolution.xy));\n    float r = .02;\n    float blur = .001;\n    vec3 col =  vec3(smoothstep(r,r-blur,d));\n    \n    vec4 a = texture(iChannel0, (fragCoord)/iResolution.xy);\n    col += a.xyz;\n    fragColor = vec4(col,1);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 t = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 r = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 b = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 l = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(iqnoise(uv*scale, irr, .2));\n    col.z=0.;\n    \n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = r.x*delta;\n        col.y=b.y;\n    }\n    else{\n        col=vec3(0.);\n        col.x=r.x;\n        col.y = b.y*delta;\n    }\n   \n /*   col = vec3(iqnoise(uv*30., irr, .2));\n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = 0.;\n        col.y=1.;\n    }\n    else{\n        col=vec3(0.);\n        col.x=1.;\n        col.y = 0.;\n    }*/\n    fragColor = vec4(col.xy,0,1);\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float irr = 0.9;\nfloat delta = 0.999;\nfloat scale = 10.;\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2yRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 477]], "test": "untested"}
{"id": "7d2yRD", "name": "CATS with basic shapes", "author": "ErinZ", "description": "cat shader", "tags": ["2d"], "likes": 7, "viewed": 335, "published": 3, "date": "1643203376", "time_retrieved": "2024-07-30T17:07:16.557185", "image_code": "#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\n//  \nfloat circle( vec2 uv, vec2 p, float r, float blur){\n    p.x *=iResolution.x/iResolution.y;\n    uv.x *= iResolution.x/iResolution.y;//\n    float d = length(uv-p);\n    float c = smoothstep(r,r-blur,d);//AA\n    return c;\n}\n//2 \nfloat segment(vec2 uv, vec2 p1, vec2 p2, float width, float blur){\nwidth/=2.;blur/=2.;\nvec2 pa = uv-p1,ba = p2-p1;\npa.x*= iResolution.x/iResolution.y;\nba.x*= iResolution.x/iResolution.y;\nfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\nfloat d = length(pa-ba*h);\nreturn smoothstep(width+blur,width-blur,d);\n}\n// a1a2 a1<a2 a1,a2[0,6.28]\nfloat arc(vec2 uv, vec2 o,float r,float a1,float a2, float width, float blur){\nuv -=o;\nwidth/=2.;blur/=2.;\nuv.x*= iResolution.x/iResolution.y;\nfloat ap =(uv.x>0.)?acos(uv.y/length(uv)):acos(-uv.y/length(uv))+3.14;//\nvec2 p1= vec2(sin(a1)*r,cos(a1)*r);\nvec2 p2= vec2(sin(a2)*r,cos(a2)*r);\nfloat d =(ap>a1&&ap<a2)?(abs(length(uv)-r)):\n                        min(length(uv-p1),length(uv-p2));\nreturn smoothstep(width+blur,width-blur,d);\n}\n//\nfloat triangle(vec2 uv,vec2 o,float a,float blur){\nuv -= o;\nuv.x = abs(uv.x*iResolution.x/iResolution.y)-a;\nconst float k = sqrt(3.);\nuv.y +=1./k*a;\nif(uv.x+k*uv.y >0.) uv=vec2(uv.x-k*uv.y,-k*uv.x-uv.y)/2.;\nuv.x -= clamp( uv.x, -2.0*a, 0.0 );\nfloat d = -length(uv)*sign(uv.y);\nreturn smoothstep(0.+blur,0.,d);\n}\n// \nfloat rectangle(vec2 uv,vec2 p1,vec2 p2,float blur){\nblur /= 2.;\nuv.x *=iResolution.x/iResolution.y;\np1.x *=iResolution.x/iResolution.y;\np2.x *=iResolution.x/iResolution.y;\nreturn smoothstep(p1.x-blur,p1.x+blur,uv.x)*\n       smoothstep(p2.x+blur,p2.x-blur,uv.x)*\n       smoothstep(p1.y+blur,p1.y-blur,uv.y)*\n       smoothstep(p2.y-blur,p2.y+blur,uv.y);\n}\n//\nvec2 rotate(vec2 uv, vec2 p, float a){\nuv-=p;\nuv.x *= iResolution.x/iResolution.y;\nvec2 q;\nq.x = cos(a)*uv.x + sin(a)*uv.y;\nq.y = -sin(a)*uv.x + cos(a)*uv.y; \nq.x /=iResolution.x/iResolution.y;\nq+=p;\nreturn q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.1;\n    vec2 uvl = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    if(fract(iTime/2.)<0.33){\n    //color theme 1\n    //BackGround\n    vec3 c1 = vec3(1.,0.4,0.);\n    vec3 c2 = vec3(1.,0.,0.4);\n    vec3 col = mix(c2,c1,uv.y);\n    \n    //Colormask\n    float bmask = circle(uv,vec2(0.4,0.6),0.13,0.005);//head\n    bmask += circle(uv,vec2(0.5,0.45),0.21,0.005);//body\n    bmask *= smoothstep(0.28,0.285,uv.y); //butt\n\n    float wmask = segment(uv, vec2(.401,.60), vec2(.41,.56), 0.04, 0.005);//nose\n    wmask += circle(uv,vec2(.405,.53),0.025,0.005);//mouth\n    wmask += circle(uv,vec2(.425,.545),0.025,0.005);//mouth\n    wmask += rectangle(uv,vec2(.365,.56),vec2(.385,.55),0.005);//righteye\n    wmask += rectangle(rotate(uv,vec2(.435,.598),-2.4),vec2(.425,.603),vec2(.445,.593),0.005);//lefteye\n    bmask += triangle(rotate(uv,vec2(.35,.69),2.7),vec2(.35,.69),0.05,0.005);//rightear\n    bmask += triangle(rotate(uv,vec2(.43,.715),-.15),vec2(.43,.715),0.05,0.005);//leftear\n    \n    wmask += circle(uv,vec2(.42,.3),0.03,0.005);//foot\n    bmask += segment(uv, vec2(.595,.45), vec2(.595,.2), 0.08, 0.005);//tail1\n    bmask += arc(uv, vec2(.53,.2),.115,1.57,4.2,0.08, 0.005);//tail2\n    wmask += arc(uv, vec2(.53,.2),.115,4.2,4.71,0.08, 0.005);//tail3\n    \n    bmask = clamp(bmask,0.,1.);\n    wmask = clamp(wmask,0.,1.);\n    col = mix(col,vec3(0.),bmask);\n    col = mix(col,vec3(1.),wmask);\n    fragColor = vec4(col+logo(uvl),1.0);\n    }\n    else if(fract(iTime/2.)<0.67){\n    //color theme 2\n    //BackGround\n    vec3 c1 = vec3(.15,.15,.75);\n    vec3 c2 = vec3(.1,.2,1);\n    vec3 col = mix(c1,c2,uv.y);\n    \n    //Colormask\n    float bmask = circle(uv,vec2(0.4,0.6),0.13,0.005);//head\n    float rmask = triangle(rotate(uv,vec2(.35,.69),2.7),vec2(.35,.69),0.05,0.005);//rightear\n    rmask += triangle(rotate(uv,vec2(.43,.715),-.15),vec2(.43,.715),0.05,0.005);//leftear\n    rmask = clamp(rmask-circle(uv,vec2(0.4,0.6),0.13,0.04),0.,1.);\n    rmask += circle(uv,vec2(0.402,0.58),0.11,0.09)*0.8;\n    bmask += circle(uv,vec2(0.5,0.45),0.21,0.005);//body\n    bmask *= smoothstep(0.28,0.285,uv.y); //butt\n\n    rmask += segment(uv, vec2(.401,.60), vec2(.41,.56), 0.04, 0.005);//nose\n    rmask += circle(uv,vec2(.405,.53),0.025,0.005);//mouth\n    rmask += circle(uv,vec2(.425,.545),0.025,0.005);//mouth\n    float wmask = rectangle(uv,vec2(.365,.56),vec2(.385,.55),0.005);//righteye\n    wmask += rectangle(rotate(uv,vec2(.435,.598),-2.4),vec2(.425,.603),vec2(.445,.593),0.005);//lefteye\n\n    \n    \n    \n    rmask += circle(uv,vec2(.42,.3),0.03,0.005);//foot\n    bmask += segment(uv, vec2(.595,.45), vec2(.595,.2), 0.08, 0.005);//tail1\n    bmask += arc(uv, vec2(.53,.2),.115,1.57,2.,0.08, 0.005);//tail2\n    float a = circle(uv,vec2(.6,.2),0.15,0.08);\n    a *= clamp(bmask,0.,1.);\n    rmask +=a;\n    rmask += arc(uv, vec2(.53,.2),.115,1.57,4.71,0.08, 0.005);//tail3\n    \n    bmask = clamp(bmask,0.,1.);\n    wmask = clamp(wmask,0.,1.);\n    rmask = clamp(rmask,0.,1.);\n    col = mix(col,vec3(.93,.83,.7),bmask);\n    //col = mix(col,vec3(.65,.5,.4),rmask);\n    col = mix(col,vec3(.25,.15,.15),rmask);\n    col = mix(col,vec3(0.),wmask);\n    fragColor = vec4(col+logo(uvl),1.0);\n    }\n    else{\n    //color theme 3\n    //BackGround\n    vec3 c1 = vec3(1.,0.7,0.2);\n    vec3 c2 = vec3(.8,1,0.4);\n    vec3 col = mix(c2,c1,uv.y);\n    \n    //Colormask\n    float omask = circle(uv,vec2(0.4,0.6),0.13,0.005);//head\n    omask += circle(uv,vec2(0.5,0.45),0.21,0.005);//body\n    omask *= smoothstep(0.28,0.285,uv.y); //butt\n\n    float wmask = segment(uv, vec2(.401,.60), vec2(.41,.56), 0.04, 0.005);//nose\n    wmask += circle(uv,vec2(.405,.53),0.025,0.005);//mouth\n    wmask += circle(uv,vec2(.425,.545),0.025,0.005);//mouth\n    float bmask = triangle(rotate(uv,vec2(.35,.69),2.7),vec2(.35,.69),0.05,0.005);//rightear\n    bmask += triangle(rotate(uv,vec2(.43,.715),-.15),vec2(.43,.715),0.05,0.005);//leftear\n    wmask += triangle(rotate(uv,vec2(.35,.69),2.7),vec2(.34,.70),0.02,0.005);//rightear\n    wmask += triangle(rotate(uv,vec2(.43,.715),-.15),vec2(.43,.695),0.02,0.005);//leftear\n    bmask += rectangle(uv,vec2(.365,.56),vec2(.385,.55),0.005);//righteye\n    bmask += rectangle(rotate(uv,vec2(.435,.598),-2.4),vec2(.425,.603),vec2(.445,.593),0.005);//lefteye\n    \n    bmask += segment(uv, vec2(.38,.64), vec2(.41,.65), 0.015, 0.005);//wang\n    bmask += segment(uv, vec2(.374,.658), vec2(.41,.67), 0.015, 0.005);\n    bmask += segment(uv, vec2(.379,.620), vec2(.415,.632), 0.015, 0.005);\n    bmask += segment(uv, vec2(.392,.663), vec2(.397,.626), 0.015, 0.005);\n    \n    wmask += circle(uv,vec2(.42,.3),0.03,0.005);//foot\n    omask += segment(uv, vec2(.595,.45), vec2(.595,.2), 0.08, 0.005);//tail1\n    omask += arc(uv, vec2(.53,.2),.115,1.57,4.2,0.08, 0.005);//tail2\n    bmask += arc(uv, vec2(.53,.2),.115,4.2,4.71,0.08, 0.005);//tail3\n    \n    float str = arc(uv, vec2(0.4,0.6),.15,1.1,2.2,0.04, 0.005);//stripes\n    str += arc(rotate(uv,vec2(.4,.3),-0.25), vec2(0.4,0.6),.15,.8,2.1,0.04, 0.005);\n    str += arc(rotate(uv,vec2(.4,.3),-0.4), vec2(0.4,0.6),.18,.8,1.8,0.04, 0.005);\n    for(float i=0.;i<5.;i++){\n    str += arc(rotate(uv,vec2(.53,.2),i*(0.4)+1.), vec2(.467,.23),.05,1.8,4.4,0.02, 0.005);}//tail stripes\n    str*=omask;\n    bmask += str;\n    \n    \n    omask = clamp(omask,0.,1.);\n    wmask = clamp(wmask,0.,1.);\n    bmask = clamp(bmask,0.,1.);\n    col = mix(col,vec3(1.,.5,0.),omask);\n    col = mix(col,vec3(.3,.1,0.),bmask);\n    col = mix(col,vec3(1.),wmask);\n\n    fragColor = vec4(col+logo(uvl),1.0);\n    }\n}\nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2yRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 100, 152, 152, 338], [339, 353, 419, 419, 658], [659, 708, 786, 786, 1153], [1154, 1172, 1222, 1222, 1483], [1484, 1512, 1564, 1564, 1866], [1867, 1888, 1926, 1926, 2099], [2101, 2101, 2158, 2208, 7757], [7758, 7758, 7778, 7778, 8167]], "test": "untested"}
{"id": "NdjyRh", "name": "ISPH + separable Poisson filters", "author": "davidar", "description": "ISPH on left vs SPH on right. Updated to use a smaller and faster Poisson solver, plus some other param tweaks for better performance. Speed up 8x with the shadertoy browser plugin", "tags": ["filter", "fluid", "particles", "poisson", "gaussian", "ca", "sph", "separable", "divergence", "svd"], "likes": 15, "viewed": 572, "published": 3, "date": "1643177406", "time_retrieved": "2024-07-30T17:07:17.508642", "image_code": "/*\n\nBuffer A implements the reintegration tracking algorithm, and calculates velocity divergence\n\nBuffers B and C calculate fluid pressure using the two-pass Poisson solver described in\n    \"Fast Eulerian Fluid Simulation In Games Using Poisson Filters\"\n    https://www.shahinrabbani.ca/torch2pd.html\n\nSolutions are initialised with a Gaussian blur of the previous solution\n\nIt's essentially a less accurate version (uses only a single SVD component) of the method used in\n    \"Fast Separable Poisson SVD\"\n    https://www.shadertoy.com/view/wsVyzD\n\nBuffer D implements incompressible SPH, by adding additional forces based on the pressure gradient, loosely based on:\n- ISPH: https://doi.org/10.1016/j.cpc.2018.01.005\n- IISPH: https://interactivecomputergraphics.github.io/SPH-Tutorial/slides/02_incompressibility.pdf\n\n*/\n\n//#define DEBUG\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    col = hue(P.M.x) * P.M.x / fluid_rho;\n    \n#ifdef DEBUG\n    col *= .5;\n    if(pos.x < .25*R.x) {\n        float divV = P.divV;\n        float d = 100. * divV;\n        if (divV == 0. && P.M.x > 0.) col.b = 1.;\n        if (d > 0.) col.g += abs(d);\n        if (d < 0.) col.r += abs(d);\n    } else if(pos.x < .5*R.x) {\n        float p = 300. * texel(ch1, pos).x;\n        if (p > 0.) col.g += abs(p);\n        if (p < 0.) col.r += abs(p);\n        if (P.divV == 0. && P.M.x > 0.) col.b = 1.;\n    }\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926536\n\n// https://youtu.be/_3eyPUyqluc?t=355\nconst float poisson_filter[7] = float[](\n    .57843719174,\n    .36519596949,\n    .23187988879,\n    .14529589353,\n    .08816487385,\n    .05184872885,\n    .02906462467\n);\n\nfloat gaussian(float w, float s) {\n    return exp(-(w*w) / (2.*s*s)) / (s * sqrt(2.*PI));\n}\n\n\n// reintegration tracking stuff\n#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho .52\n\nfloat Pf(vec2 rho)\n{\n    return 0.05*rho.x*(pow(rho.x/(fluid_rho - .02), 2.) - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    vec2 r = R * vec2(.5,1);\n    p = mod(p,r);\n    float bound = -sdBox(p - r*0.5, r*vec2(0.49, 0.49));\n    float box = sdBox(Rot(0.*time)*(p - r*vec2(0.5, 0.6)) , r*vec2(0.05, 0.01));\n    float drain = -sdBox(p - r*vec2(0.5, 0.7), r*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n    float divV; // not a property of the particle, but the centre of the cell the particle is in\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M.x = data.z;\n    P.M.y = 1.;\n    P.divV = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    P.V = clamp(P.V, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M.x, P.divV);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n", "buffer_a_code": "//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    float divV = 0., divX = 0.;\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n        \n        // compute divergence\n        vec2 dx = P0.X - pos;\n        vec2 gradG = G(dx) * dx;\n        divV += P0.M.x * dot(P0.V, gradG); // velocity divergence\n        divX += P0.M.x * dot(dx, gradG); // position divergence\n    }\n    \n    if(divX < 1.6) { // free surface\n        P.divV = 0.;\n    } else {\n        P.divV = divV;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        P.X = pos;\n        P.V = vec2(0);\n        P.M = vec2(0);\n        if(pos.y < .2*R.y) P.M = vec2(fluid_rho, 1);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Poisson solver - horizontal pass\n\nfloat rhs(vec2 pos) { // rhs of the poisson equation\n    vec4 data = texelFetch(iChannel0, ivec2(pos), 0);\n    particle P0 = getParticle(data, pos);\n    if (P0.divV == 0.) return 0.;\n    return -mix(P0.divV, fluid_rho - P0.M.x, .05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 0., g = 0.;\n    for (int i = -6; i <= 6; i++) {\n        vec2 pos = fragCoord + vec2(i,0);\n        p += poisson_filter[abs(i)] * rhs(pos);\n        g += gaussian(float(i), 3.) * texelFetch(iChannel2, ivec2(pos), 0).x;\n    }\n\tfragColor = vec4(p, g, 0, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Poisson solver - vertical pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 0., g = 0.;\n    for (int j = -6; j <= 6; j++) {\n        vec4 pass1 = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(0,j), 0);\n        p += poisson_filter[abs(j)] * pass1.x;\n        g += gaussian(float(j), 3.) * pass1.y;\n    }\n\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    particle P = getParticle(data, fragCoord);\n    if(P.M.x == 0. || P.divV == 0.) {\n        // Dirichlet boundary condition\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(g + p);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define COMPRESSIBLE (pos.x > .5*R.x)\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    float pressure = texture(iChannel2, P.X/R).x;\n    \n    //Compute the SPH force\n    vec2 F = vec2(0);\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        dx /= 2.;\n        \n        float pressure0 = texture(iChannel2, P0.X/R).x;\n        vec2 gradG = G(dx) * dx / 4.;\n        F -= mix(Pf(P.M) + Pf(P0.M), pressure0 - pressure, COMPRESSIBLE ? 0. : .5) * gradG;\n    }\n    \n    //gravity\n    F.y -= .0015 * P.M.x;\n\n    if(Mouse.z > 0.)\n    {\n        vec2 r = R * vec2(.5,1);\n        Mouse = mod(Mouse, r.xyxy);\n        vec2 dm = (Mouse.xy - Mouse.zw) / R.y; \n        vec2 dx = (mod(P.X, r) - Mouse.xy) / (R.y/100.);\n        F += dm * G(dx);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    if(vdotN > 0.) P.V += N.xy * abs(vdotN);\n\n    if(N.z < 0. || pos.x < 2. || pos.x > R.x-2. || abs(pos.x - .5*R.x) < 2.)\n        P.M = P.V = vec2(0);\n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.) ? v : 1.;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(pos - R*vec2(.1 + .3*hash32(vec2(iFrame)).z, 0.9)) < 50e-3*R.y && iFrame%500 < 1) \n    {\n        P.X = pos;\n        P.V = vec2(0, -1);\n        P.M = vec2(fluid_rho, 0.);\n    }\n    \n    if(length(pos - R*vec2(.6 + .3*hash32(vec2(iFrame)).z, 0.9)) < 50e-3*R.y && iFrame%500 < 1) \n    {\n        P.X = pos;\n        P.V = vec2(0, -1);\n        P.M = vec2(fluid_rho, 0.);\n    }\n\n    U = saveParticle(P, pos);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[905, 905, 950, 950, 1597]], "test": "untested"}
{"id": "fs2yRW", "name": "Cosine Gold Gradient", "author": "CWBudde1", "description": "A gold gradient calculated by a cosine color function", "tags": ["gradient", "palette", "cosine", "gold"], "likes": 1, "viewed": 257, "published": 3, "date": "1643172224", "time_retrieved": "2024-07-30T17:07:18.354380", "image_code": "/*\nvec3 palette( in float t ) {\n  vec3 a = vec3(0.884, 0.608, 0.190);\n  vec3 b = vec3(0.057, 0.131, -0.107);\n  vec3 c = vec3(9.257, -8.914, -9.496);\n  vec3 d = vec3(6.177, -0.306, -3.760);\n  return a + b*cos( c*t+d );\n}\n*/\n\nvec3 palette( in float t ) {\n  vec3 a = vec3(0.882, 0.615, 0.183);\n  vec3 b = vec3(0.114, -0.136, -0.098);\n  vec3 c = vec3(7.288, 7.938, 9.912);\n  vec3 d = vec3(1.009, 10.31, -2.84);\n  return a + b*cos( c*t+d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = palette(uv.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2yRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 252, 252, 437], [439, 439, 496, 546, 707]], "test": "untested"}
{"id": "fsScz1", "name": "phoenixsdas", "author": "cxm", "description": "phoenixsdas", "tags": ["sand", "cineshader"], "likes": 3, "viewed": 2094, "published": 3, "date": "1643165981", "time_retrieved": "2024-07-30T17:07:19.242006", "image_code": "\n#define rot( a ) mat2( cos(a), sin(a), -sin(a), cos(a) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n\n    vec3 col;\n    \n    float t = iTime + 3., i;\n    \n    uv -= .5;\n    uv *= rot( t );\n    uv += .5;\n    \n    while( i++ < 4. ){\n        uv.x += cos( ( uv.x, i ) * uv.y ) + sin( atan( uv.x - .5, uv.y - .5 ) ) - t * .5;\n        uv.y -= sin( i * mod( uv.x, .4 ) * .2 ) + mod( uv.x, .05 ) - t * .5;\n    }\n    \n\n    col += smoothstep( uv.x, uv.y, dot( sin(uv.x), uv.y ) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsScz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 116, 628]], "test": "untested"}
{"id": "sdBczD", "name": "Raymarched planet on a plane", "author": "pancakespeople", "description": "My first time using raymarching in a shader, it's probably wildly inefficient but whatever.", "tags": ["raymarching", "planet"], "likes": 5, "viewed": 239, "published": 3, "date": "1643164963", "time_retrieved": "2024-07-30T17:07:20.084753", "image_code": "vec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat getSphereRadius(vec3 point) {\n    return 0.25*fbm(point.xy*5.0)+0.5;\n}\n\nfloat getAtmosRadius(vec3 point) {\n    point.x += iTime/6.0;\n    return 0.25*fbm(point.xy*5.0)+0.5;\n}\n\nfloat sphereAndPlane(vec3 point) {\n    vec3 spherePos = vec3(0.0, 1.0, -2.0);\n    float sphereRadius = getSphereRadius(point);//+(0.5*fbm(point.xy/3.0));\n    //float sphereRadius = 0.1*fbm(point.xy*10.0)+0.5;\n    \n    float sphereDist = length(point-spherePos)-sphereRadius;\n    float planeDist = length(point.y-0.5);\n    \n    return min(sphereDist, planeDist);\n}\n\nfloat atmosphere(vec3 point) {\n    vec3 spherePos = vec3(0.0, 1.0, -2.0);\n    float sphereRadius = getAtmosRadius(point)+0.1;\n    float sphereDist = length(point-spherePos)-sphereRadius;\n    return sphereDist;\n}\n\nfloat rayMarch(vec3 rayPoint, vec3 rayDir) {\n    float distMarched = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float dist = sphereAndPlane(rayPoint);\n        rayPoint += dist * rayDir;\n        distMarched += dist;\n        \n        if (dist < 0.01 || dist > 100.0) {\n            break;\n        }\n    }\n    return distMarched;\n}\n\nfloat rayMarchAtmosphere(vec3 rayPoint, vec3 rayDir) {\n    float distMarched = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float dist = atmosphere(rayPoint);\n        rayPoint += dist * rayDir;\n        distMarched += dist;\n        \n        if (dist < 0.01 || dist > 100.0) {\n            break;\n        }\n    }\n    return distMarched;\n}\n\nvec3 getNormal(vec3 point) {\n    float dist = sphereAndPlane(point);\n    vec3 norm = dist - vec3(\n        sphereAndPlane(point - vec3(0.01, 0.0, 0.0)),\n        sphereAndPlane(point - vec3(0.0, 0.01, 0.0)),\n        sphereAndPlane(point - vec3(0.0, 0.0, 0.01))\n    );\n    return normalize(norm);\n}\n\nvec3 getAtmosNormal(vec3 point) {\n    float dist = atmosphere(point);\n    vec3 norm = dist - vec3(\n        atmosphere(point = vec3(0.01, 0.0, 0.0)),\n        atmosphere(point - vec3(0.0, 0.01, 0.0)),\n        atmosphere(point - vec3(0.0, 0.0, 0.01))\n    );\n    return normalize(norm);\n}\n\nvec3 getColor(vec3 point) {\n    float radius = length(vec3(0.0, 1.0, -2.0)-point);\n    float polarity = point.y-1.0;\n    if (radius > 0.5) {\n        if (radius > 0.515) {\n            return vec3(1.0);\n        }\n        else {\n            return vec3(0.0, 1.0, 0.0) + smoothstep(0.15, 0.2, abs(polarity)) * vec3(1.0, 0.0, 1.0);\n        }\n    }\n    else {\n        return vec3(0.0, 0.0, 1.0) + smoothstep(0.1, 0.5, abs(polarity)) * vec3(1.0, 1.0, 0.0);\n    }\n}\n\nfloat getSpecularity(vec3 point) {\n    float radius = length(vec3(0.0, 1.0, -2.0)-point);\n    if (radius < 0.5) {\n        return 2.0;\n    }\n    else {\n        return 1.0;\n    }\n}\n\nfloat getSpecular(vec3 point, vec3 lightPos, vec3 cameraPos) {\n    vec3 viewDir = normalize(cameraPos-point);\n    vec3 lightDir = normalize(lightPos-point);\n    vec3 reflectDir = reflect(-lightDir, getNormal(point));\n    return pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\n    vec3 cameraPos = vec3(0.0, 1.0, -4.0);\n    vec3 cameraDir = vec3(0.0);\n    vec3 rayDir = vec3(uv.x, uv.y, 1.0);\n    \n    vec3 lightPos = vec3(cos(iTime/4.0)*2.0, 1.0, sin(iTime/4.0)*5.0);\n    \n    float dist = rayMarch(cameraPos, rayDir + cameraDir);\n    vec3 hit = rayDir * dist + cameraPos;\n    \n    vec3 normal = getNormal(hit);\n    vec3 lightDir = normalize(lightPos-hit);\n    \n    vec3 col = vec3(0.0);\n    \n    float light = clamp(dot(lightDir, normal), 0.0, 1.0);\n\n    float shadow = rayMarch(hit+normal*0.1, lightDir);\n\n    if (shadow < length(lightPos-hit)) {\n        light *= 0.1;\n    }\n    \n    col = vec3(light) * (getColor(hit) + getSpecular(hit, lightPos, cameraPos) * getSpecularity(hit));\n    \n    float atmosDist = rayMarchAtmosphere(cameraPos, rayDir + cameraDir);\n    vec3 atmosPoint = rayDir * atmosDist + cameraPos;\n    float surfAtmosDist = rayMarch(atmosPoint, normalize(vec3(0.0, 1.0, -2.0)-atmosPoint));\n    \n    if (surfAtmosDist < 1.0) {\n        vec3 atmosNormal = getAtmosNormal(atmosPoint);\n        vec3 atmosLightDir = normalize(lightPos-atmosPoint);\n        float atmosLight = dot(atmosLightDir, atmosNormal);\n        col += smoothstep(0.1, 0.2, surfAtmosDist) * atmosLight;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 159], [161, 246, 268, 268, 610], [612, 612, 631, 631, 889], [891, 891, 926, 926, 967], [969, 969, 1003, 1003, 1070], [1072, 1072, 1106, 1106, 1435], [1437, 1437, 1467, 1467, 1648], [1650, 1650, 1694, 1694, 1988], [1990, 1990, 2044, 2044, 2334], [2336, 2336, 2364, 2364, 2631], [2633, 2633, 2666, 2666, 2917], [2919, 2919, 2946, 2946, 3376], [3378, 3378, 3412, 3412, 3556], [3558, 3558, 3620, 3620, 3834], [3836, 3836, 3893, 3893, 5209]], "test": "untested"}
{"id": "ssScRD", "name": "Particle Network", "author": "ruudhelderman", "description": "Based on a popular animated canvas drawing; I was just curious what it would be like to implement this in GLSL.\nFirst accumulating polar coordinates of all nearby particles in an array. Then scanning this 'ring' for opposites.", "tags": ["particles"], "likes": 20, "viewed": 587, "published": 3, "date": "1643163477", "time_retrieved": "2024-07-30T17:07:21.001303", "image_code": "const int number_of_particles = 250;\nconst int number_of_buckets = 32;\nconst float brightness_particle = -50000.0;\nconst float brightness_wire = -500.0;\nconst float cutoff = 0.01;\nconst float speed = 0.04;\nconst float time_offset = 999.0;\nconst vec3 color = vec3(0.0, -0.3, -0.6);\n\nconst int half_of_buckets = number_of_buckets / 2;\nconst float bucket_angle_ratio = float(half_of_buckets) / 3.14159265359;\n\nconst float angle = 1.2;\nconst mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat ring[number_of_buckets];\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float average_resolution = 0.5 * (iResolution.x + iResolution.y);\n    vec2 pole = fragCoord / average_resolution - 0.5;\n    vec2 particle = vec2(speed * (time_offset + iTime), 0);\n    float brightness = 0.0;\n    \n    for (int i = 0; i < number_of_particles; i++)\n    {\n        vec2 partial_wire = fract((particle *= rotate) - pole) - 0.5;\n        float radius = dot(partial_wire, partial_wire);\n        \n        if (radius < cutoff)\n        {\n            float radial_brightness = exp(radius * brightness_wire);\n            float bucket = bucket_angle_ratio * (atan(partial_wire.y, partial_wire.x) + 7.0);\n            float leaking_brightness = radial_brightness * fract(bucket);\n            int b = int(bucket);\n            \n            ring[b % number_of_buckets] += radial_brightness - leaking_brightness;\n            ring[(b+1) % number_of_buckets] += leaking_brightness;\n\n            brightness += exp(radius * brightness_particle);\n        }\n    }\n\n    for (int i = 0; i < half_of_buckets; i++)\n    {\n        brightness += ring[i] * ring[i + half_of_buckets];\n    }\n\n    fragColor = vec4(color + brightness, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssScRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 595, 595, 1721]], "test": "untested"}
{"id": "7sSyzW", "name": "helical staircase", "author": "sympou", "description": "I was trying to find the SDF of an helical staircaise, and I saw that dr2 has found a way to do it (amongst other great things) ! (there is also a version by FabriceNeyret2)\nhere it is, a bit simplified, and with parameters.\nnot exact, but works great :)", "tags": ["sdfhelixstairs"], "likes": 11, "viewed": 288, "published": 3, "date": "1643156511", "time_retrieved": "2024-07-30T17:07:22.069447", "image_code": "// derived from :\n\n// \"Melange\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// https://www.shadertoy.com/view/slKXD3\n\n#define PI 3.1415926535\n\nfloat sdHelixStairs( in vec3 p) {\n\n    // parameters :\n \n    float stairsNum = 2.;\n    float slabNum = 40.; // number of slabs per rotation\n    float rotDir = 1.; //1. or -1.\n\n    float height = 10.;\n    float axisWidth = 9.;\n    float underSlab = .5;\n    float slabWidth = 2.;\n        \n    float ang = height * atan (p.x, p.z) / PI * rotDir;\n    float len = length(p.xz);\n        \n    vec2 h2 = height / vec2(slabNum*.5,stairsNum);\n\n    p.xy = vec2(ang - p.y, ang + p.y)*0.5;\n    p.xy = mod(p.xy, h2);\n\n    p.x  = min(p.x, h2.x - p.x);\n    p.y -= h2.y*0.5;\n    \n    float y1 = max( p.y - p.x, -(p.y + underSlab)*2. );\n    float z1 = abs( len - axisWidth ) - slabWidth;\n    \n    //smoother sdf\n    //if (y1>0. && z1>0.) { return length(vec2(y1,z1)); }\n    \n    return max(y1,z1);\n    \n}\n\nfloat getVal ( in vec3 p ) {\n    return sdHelixStairs(p);\n}\n\nfloat rayMarch( vec3 ro, vec3 rd) {\n\n    float t = 0.;\n    int i = 0;\n\n    while ( i<100 && t<999. ) {\n        float r = abs( getVal( ro + rd*t ) );\n        if ( r <= 0.001*t ) break;\n        t += r;\n        i ++;\n    }\n    \n    if (t>999.) { return -1.; }\n\n    return t;\n}\n\nvec3 distance_field_normal(vec3 pos) {\n    vec2 eps = vec2(0.0001,0.0);\n    float nx = getVal(pos + eps.xyy);\n    float ny = getVal(pos + eps.yxy);\n    float nz = getVal(pos + eps.yyx);\n    return normalize(vec3(nx, ny, nz)-getVal(pos));\n}\n\n\n//ambient occlusion\n//https://www.shadertoy.com/view/MtlBWB\nconst vec3 sq = 1./vec3(sqrt(2.),sqrt(3.),sqrt(4.));\nconst float eps = 0.125;\nconst vec3 eps2 = eps*vec3(2.,3.,4.);\nfloat ao(vec3 p, vec3 n) {\n    \n    float c1 = float(abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z));\n    float c2 = float(abs(n.y) < abs(n.z));\n    float c3 = c2 - c2*c1;\n    \n    vec3 t = vec3(c1, c3, 1. - c1 - c3);\n    vec3 u = cross(n, t);\n    vec3 v = cross(n, u);    \n    \n    vec3 epn = eps2[2]*n + p;\n    \n    float occ  = max(getVal(p + eps*n),0.0);\n          occ += max(getVal(p + eps*u),0.0);\n          occ += max(getVal(p - eps*u),0.0);\n          occ += max(getVal(p + eps*v),0.0);\n          occ += max(getVal(p - eps*v),0.0);\n    \n    occ += (max(getVal(epn + eps2[2]*u),0.0)\n        +   max(getVal(epn - eps2[2]*u),0.0)\n        +   max(getVal(epn + eps2[2]*v),0.0)\n        +   max(getVal(epn - eps2[2]*v),0.0))*0.5;\n\n    occ += max(getVal(p + eps2[0]*n)*sq[0],0.0);\n    occ += max(getVal(p + eps2[1]*n)*sq[1],0.0);\n    occ += max(getVal(epn          )*sq[2],0.0);\n\n    return max(1.0 - 1.0/(1.0+2.0*occ), 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (m.x==0. && m.y==0.) { m = vec2(.5,.87); }\n\n    //rotation of the object\n    float time2 = iTime*0.125;\n    mat3 rot = mat3(sin(time2),0., cos(time2),  0.,1.,0., cos(time2),0.,-sin(time2));\n\n    //ray origin + direction\n    vec3 ro = vec3(0., 0., 30. );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd.yz *= mat2(cos(0.4),sin(0.4),-sin(0.4),cos(0.4));\n\n    vec3 ro2 = ro*rot;\n    vec3 rd2 = rd*rot;\n\n    //output color\n    vec3 col = vec3(0.0);\n    \n    \n    //distance to the object\n    float dist = rayMarch( ro2, rd2 );\n\n    vec3 objPos;\n    float tmin = 1e10;\n\n    // if we touch the object :\n    if (dist>0.0) {\n\n        tmin = min(tmin,dist);\n        vec3 hit = ro2 + rd2*dist;\n        vec3 normals = distance_field_normal(hit);        \n        objPos = ro2 + tmin*rd2;\n        \n        float diffuse = mix(normals.y,1.,0.65);\n        float ao = ao(objPos, normals);\n\n        col = vec3(0.8,0.8,1.)*diffuse*ao ;\n    }\n    \n    //signed distance field viewer\n    //inspired by tdhooper : https://www.shadertoy.com/view/MstcWs\n\n    float offset = (m.y-0.5)*25.;\n    if (tmin>9999. || (rot*objPos).z + offset < 0.) {\n        \n        vec3 planeHit = ro2 - rd2*(ro.z+offset)/rd.z;\n\n        float sdf = getVal(planeHit);\n        \n        vec3 view = vec3(0.2,0.,1.)*mod(sdf, 0.5)/(1.+sdf*0.1);\n        \n\n        col = mix(col, view, m.x*0.75 );\n    }\n    \n\n    fragColor = vec4( sqrt(col.rgb), 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSyzW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[200, 200, 233, 254, 986], [988, 988, 1016, 1016, 1047], [1049, 1049, 1084, 1084, 1322], [1324, 1324, 1362, 1362, 1563], [1742, 1742, 1768, 1768, 2664], [2668, 2668, 2725, 2725, 4238]], "test": "untested"}
{"id": "fdBcRD", "name": "prison sphere", "author": "jorge2017a2", "description": "prison sphere", "tags": ["3d", "raymarching", "sound", "prisonsphere"], "likes": 19, "viewed": 330, "published": 3, "date": "1643146068", "time_retrieved": "2024-07-30T17:07:22.909201", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nfloat tau = atan(1.0) * 8.0;\nvec3 opAngRep( vec3 p, float a )\n{   vec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 opAngRepFull( vec3 p, float numItem )\n{   return opAngRep(p, tau / numItem); }\n\nvec3 Paredes2(vec3 p, vec3 p0a, float ancho)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    vec3 prep= opAngRepFull(p,9.0 );\n    float d1= sdBox(prep, vec3(ancho+2.0,0.2,ancho+3.0));\n    float d2=sdSphere(p0a-vec3(0.0,3.0,0.0), ancho );\n    float d3=sdSphere(p0a-vec3(0.0,3.0,0.0), ancho-2.0 );\n    float d4=sdSphere(p0a-vec3(0.0,3.0,0.0), ancho+3.0 );\n    float dif=differenceSDF(d2, d3);\n    dif=differenceSDF(d1,dif);\n    dif=intersectSDF(dif,d4);\n    dif=differenceSDF(dif,d2);\n    //res =opU3(res, vec3(dif,1.0,-1.0));\n    res =opU3(res, vec3(dif,100.0,-1.0));\n    return res;\n}\n\nvec3 EsferaFull(vec3 p,  float ancho)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    float d1=sdSphere(p-vec3(0.0,5.0,0.0), ancho );\n    float d2=sdSphere(p-vec3(0.0,5.0,0.0), ancho-2.0 );\n    p.y= opRep1D(p.y,2.0 );\n    float d3=sdBox( p, vec3(ancho,0.5,ancho) );\n    float dif= differenceSDF(d1, d2);\n    dif= differenceSDF(dif, d3);\n    res =opU3(res, vec3(dif,2.0,-1.0));\n    vec3 pr2= Paredes2(p0.zxy-vec3(0.0,0.0,0.0),p0, ancho);\n    res =opU3(res, pr2);\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float ancho=15.0;\n    p= rotate_y(p,radians(iTime*10.0));\n    mObj.phit=p;\n    vec3 e1= EsferaFull(p,ancho);\n    ancho=35.0;\n    p= rotate_y(p0,radians(-iTime*20.0));\n    vec3 e2= EsferaFull(p,ancho);\n    res =opU3(res, e1);\n    res =opU3(res, e2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0 ,t = 0.; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n      float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    {   \n        vec3 ptmp=mObj.phit;\n        p= rotate_y(ptmp,radians(iTime*10.0));\n        nor= rotate_y(nor,radians(iTime*10.0));\n        //p= ptmp;\n        vec3 col=tex3D(iChannel0, p/16., nor); return col*2.0; \n    }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color)); colobj=coltex; }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd; mObj.ro=ro;\n   vec3 p;\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        //col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n\n \tlight_pos1= vec3(-10.0, 20.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0+8.0*sin(t),-30.0+2.5*cos(t));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "///modificado por jorge flores\n///referencia\n///https://www.shadertoy.com/view/wt2GDz\n\nfloat square(float t, float f) {\n   \tif (fract(t*f) > 0.5) return 1.0;\n    else return -1.0;\n}\n\nfloat sinwave(float t, float f) {\n\treturn sin(6.2831*f*t);\n}\n\nfloat saw(float t, float f) {\n\treturn fract(t*f);\n}\n\nfloat fractsaw(float t, float b, int o) {\n\tfloat s = 0.0;\n    for (int i, j = 0; i < o; i++, j *= 2) {\n    \ts += saw(t, b*float(j))/float(o);\n    }\n    return s;\n}\n\n\n\nfloat saw_medv2(float t) \n{\n    float y = fract(t/20.0)*20.0;\n    if (y < 4.0) return 60.0;\n    if (y < 8.0) return 78.0;\n    if (y < 12.0) return 79.0;\n    if (y < 16.0) return 120.0;\n    if (y < 20.0) return 100.0;\n    return 0.0;\n}\n\nvec2 mainSound( in int samp, float time )\n{   float s1a,s2a,s3a;\n    float s1b,s2b,s3b;\n    float time2=time*2.0;\n    \n    s1b=square(time2, saw_medv2(time));\n    s2b=square(time2, saw_medv2(time)*0.5);\n    \n    s3b=sinwave(time, saw_medv2(time)*1.0)*0.125;\n    vec2 resp, res2;\n    res2=vec2((s1b+s2b+s3b))*0.125*fract(-time*4.0);\n    return res2;\n    \n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 533, 533, 554], [555, 555, 587, 587, 671], [673, 717, 764, 764, 791], [792, 792, 835, 835, 862], [863, 863, 911, 911, 939], [940, 978, 1014, 1014, 1059], [1060, 1060, 1094, 1094, 1185], [1216, 1216, 1250, 1250, 1419], [1421, 1421, 1465, 1465, 1504], [1506, 1506, 1552, 1552, 2097], [2099, 2099, 2138, 2138, 2585], [2587, 2587, 2612, 2612, 2971], [2973, 2973, 2997, 2997, 3159], [3161, 3161, 3210, 3210, 3830], [3832, 3832, 3869, 3869, 4142], [4144, 4144, 4227, 4227, 4803], [4805, 4805, 4854, 4854, 5091], [5093, 5093, 5186, 5186, 5316], [5318, 5318, 5350, 5350, 5547], [5549, 5549, 5642, 5642, 5950], [5952, 5952, 5983, 5983, 6693], [6696, 6696, 6753, 6753, 7244]], "test": "untested"}
{"id": "7d2yz1", "name": "Machine DNA", "author": "eiffie", "description": "When Ed got the maintenance job on Alpha station he thought how hard can it be changing light bulbs?", "tags": ["soc", "del"], "likes": 47, "viewed": 863, "published": 3, "date": "1643126481", "time_retrieved": "2024-07-30T17:07:23.771895", "image_code": "#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=0.6;//,shadowCone=0.5;\nmat2 rmat(float a){float sa=sin(a),ca=cos(a);return mat2(ca,sa,-sa,ca);}\nvec3 mcol=vec3(0);\nconst float mr=0.16, mxr=1.0; \nconst vec4 scale=vec4(-2.0,-2.0,-2.0,2.0); \nvec4 p0=vec4(3.,0.76,1.12,0.2);//0.32,.76\nfloat lightPos; \nvec2 DE(in vec3 z0){//amazing surface by kali/tglad with mods\n p0.x=cos((iTime+z0.y)*0.05)*3.5;\n z0.xz=z0.xz*rmat(z0.y*0.07);\n z0.y=abs(mod(z0.y,4.0)-2.0);\n vec4 z = vec4(z0,1.0); float dL=100.;\n for (int n = 0; n < 4; n++) { \n  if(z.x<z.z)z.xz=z.zx; \n  z.xy=clamp(z.xy, -1.0, 1.0) *2.0-z.xy; \n  z*=scale/clamp(max(dot(z.xy,z.xy),dot(z.xz,z.xz)),mr,mxr); \n  z+=p0; \n  if(n==1)dL=length(z.xyz+vec3(0.5,lightPos,0.5))/z.w;\n } \n if(mcol.x>0.)mcol+=vec3(0.6)+sin(z.xyz*0.1)*0.4; \n z.xyz=abs(z.xyz)-vec3(1.4,32.8,0.7); \n return vec2(max(z.x,max(z.y,z.z))/z.w,dL); \n} \n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 bg(vec3 rd){\n  float d=max(0.,rd.x+rd.y+rd.z);\n  return vec3(d*d*.25)+rd*.05;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=time*0.1;//camera, lighting and object setup\n lightPos=sin(tim*20.0)*5.; \n vec3 ro=vec3(cos(tim),tim*2.0,sin(tim))*5.0; \n vec3 rd=lookat(vec3(-ro.x,5.0,-ro.z),vec3(0.0,1.0,1.0))*normalize(vec3((2.0*gl_FragCoord.xy-size.xy)/size.y,2.0)); \n focalDistance=min(length(ro)+0.001,1.0);\n aperture=0.007*focalDistance;\n vec3 rt=normalize(cross(vec3(0,1,0),rd)),up=cross(rd,rt);//just need to be perpendicular\n vec3 lightColor=vec3(1.0,0.5,0.25)*2.0;\n vec4 col=vec4(0.0);vec3 blm=vec3(0);//color accumulator, .w=alpha, bloom accum\n vec2 D;//for surface and light dist\n float t=0.0,mld=100.0,od,d=1.,old,ld=100.,dt=0.,ot;//distance traveled, minimum light distance\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>15.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  od=D.x;old=D.y,dt=t-ot;ot=t;//save old distances for normal, light direction calc\n  D=DE(ro+rd*t);\n  d=D.x+0.33*rCoC;\n  ld=D.y;//the distance estimate to light\n  mld=min(mld,ld);//the minimum light distance along the march\n  if(d<rCoC){//if we are inside the sphere of confusion add its contribution\n   vec3 p=ro+rd*(t-dt);//back up to previos checkpoint\n   mcol=vec3(0.01);//collect color samples with normal deltas\n   vec2 Drt=DE(p+rt*dt),Dup=DE(p+up*dt);\n   vec3 N=normalize(rd*(D.x-od)+rt*(Drt.x-od)+up*(Dup.x-od));\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   vec3 L=-normalize(rd*(D.y-old)+rt*(Drt.y-old)+up*(Dup.y-old));\n   if(L!=L)L=up;\n   float lightStrength=1.0/(1.0+ld*ld*20.0);\n   vec3 scol=mcol*(0.4*(1.0+dot(N,L)+.2))*lightStrength;//average material color * diffuse lighting * attenuation\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   mcol=vec3(0);//clear the color accumulator before shadows\n   //scol*=FuzzyShadow(p,L,ld,shadowCone,rCoC);//now stop the shadow march at light distance\n   blm+=lightColor*exp(-mld*t*10.)*(1.0-col.w);//add a bloom around the light\n   mld=100.0;//clear the minimum light distance for the march\n   float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col=vec4(col.rgb+scol*alpha,clamp(col.w+alpha,0.0,1.0));//blend in the new color \n  }//move the minimum of the object and light distance\n  d=abs(fudgeFactor*min(d,ld+0.33*rCoC)*(0.8+0.2*rand2()));//add in noise to reduce banding and create fuzz\n  t+=d;\n }//mix in background color and remaining bloom\n t=min(15.,t);\n blm+=lightColor*exp(-mld*t*10.)*(1.0-col.w);///(1.0+mld*mld*3000.0\n col.rgb=mix(col.rgb,bg(rd),t/15.);\n fragColor = vec4(clamp(col.rgb+blm,0.0,1.0),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 3.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 5.0; \n  else if(n<3.0)n= -4.0; \n  else if(n<4.0)n= 4.0; \n  else if(n<5.0)n= -5.0; \n  else if(n<6.0)n= 3.0; \n  else if(n<7.0)n= 2.0; \n  else n=0.0;\n  return vec2(n,r); \n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//pentatonic minor\n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,1.5,0.001);//silly fm synth instruments \n instr sitar=instr(2.0,.2,8.0,0.0,0.5,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(500.0,1.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.0625)+nofs(b2*0.25)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n2+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y/(1.+abs(n0.x)*.25);\n   if(mod(i,1.)<1.){\n     a+=I(n0.x+93.0,time+Sin(t0*372.0),t0,stick)*n0.y*.1;\n     a+=I(n0.x+67.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.)*.25);\n     a+=I(n0.x+72.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.)*.25);\n   } \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+65.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+64.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+60.,time,t1,epiano)*n1.y*.125; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     a+=I(n1.x+32.0,t1/bps+0.008*sin(t1*3.0),t1,bassdrum)*2.0;\n     a+=I(n2.x+31.0,t1/bps+0.008*sin(t1*2.0),t1,bassdrum)*2.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+52.0,time,t2,bass)*n2.y;\n       a+=I(96.0,time,t2,stick)*n2.y*.25;\n       \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2yz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 119, 138, 138, 191], [345, 345, 365, 406, 906], [909, 909, 942, 1004, 1068], [1069, 1069, 1098, 1098, 1194], [1195, 1195, 1236, 1236, 1269], [1353, 1353, 1367, 1455, 1549], [1550, 1550, 1567, 1567, 1634], [1635, 1635, 1692, 1692, 4409]], "test": "untested"}
{"id": "7djcR1", "name": "Fork Fork Fire  zovox 343", "author": "zovox", "description": "It is just a spin off from https://www.shadertoy.com/view/XsXSWS applying some distortion\n\nNow with 3D simplex noise. Looks real AF.", "tags": ["fire"], "likes": 5, "viewed": 299, "published": 3, "date": "1643122599", "time_retrieved": "2024-07-30T17:07:24.823084", "image_code": "// This is just a spin off from https://www.shadertoy.com/view/XsXSWS applying some distortion and minor tweaks\n\n#define timeScale \t\t\tiTime * 1.0\n#define fireMovement \t\tvec2(-0.01, -0.5)\n#define distortionMovement\tvec2(-0.01, -0.3)\n#define normalStrength\t\t40.0\n#define distortionStrength\t0.1\n\n// #define DEBUG_NORMAL\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    // x0 = x0 - 0.0 + 0.0 * C.xxx;\n    // x1 = x0 - i1 + 1.0 * C.xxx;\n    // x2 = x0 - i2 + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm ( in vec2 p ) {\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    vec3 p2 = vec3(p, timeScale);\n    f  = 0.5000*snoise(p2); p2.xy = m*p2.xy;\n    f += 0.2500*snoise(p2); p2.xy = m*p2.xy;\n    f += 0.1250*snoise(p2); p2.xy = m*p2.xy;\n    f += 0.0625*snoise(p2); p2.xy = m*p2.xy;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\n/** DISTORTION **/\nvec3 bumpMap(vec2 uv) { \n    vec2 s = 1. / iResolution.xy;\n    float p =  fbm(uv);\n    float h1 = fbm(uv + s * vec2(1., 0));\n    float v1 = fbm(uv + s * vec2(0, 1.));\n       \n   \tvec2 xy = (p - vec2(h1, v1)) * normalStrength;\n    return vec3(xy + .5, 1.);\n}\n\n/** MAIN **/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 normal = bumpMap(uv * vec2(1.0, 0.3) + distortionMovement * timeScale);\n    \n    #ifdef DEBUG_NORMAL\n    \tfragColor = vec4(normal, 1.0);\n    \treturn;\n    #endif\n    \n    vec2 displacement = clamp((normal.xy - .5) * distortionStrength, -1., 1.);\n    uv += displacement; \n    \n    vec2 uvT = (uv * vec2(1.0, 0.5)) + timeScale * fireMovement;\n    float n = pow(fbm(8.0 * uvT), 1.0);    \n    \n    float gradient = pow(1.0 - uv.y, 2.0) * 5.;\n    float finalNoise = n * gradient;\n    \n    vec3 color = finalNoise * vec3(2.*n, 2.*n*n*n, n*n*n*n);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 394, 394, 445], [447, 447, 468, 468, 519], [521, 521, 543, 543, 582], [584, 584, 606, 606, 2212], [2214, 2214, 2235, 2235, 2286], [2288, 2288, 2310, 2310, 2349], [2351, 2351, 2379, 2379, 2433], [2435, 2435, 2457, 2457, 4715], [4717, 4717, 4742, 4742, 5058], [5060, 5079, 5102, 5102, 5336], [5338, 5351, 5408, 5408, 6033]], "test": "untested"}
{"id": "fsXyDX", "name": "Genuary 2022 - Day21", "author": "z0rg", "description": "My participation to genuary 2022\nCombine two (or more) of your pieces from previous days to make a new piece.\nIt's heavy as hell I might optimize it later\nCode is messy I know :p\nhttps://www.shadertoy.com/view/NsfyWj\nhttps://www.shadertoy.com/view/fslyzl", "tags": ["architecture", "genuary", "2022"], "likes": 11, "viewed": 376, "published": 3, "date": "1643116454", "time_retrieved": "2024-07-30T17:07:25.923143", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .8\n#define GLOW_OPACITY .4\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x,max(l.y, l.z));\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\n// Thanks IQ\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// Thanks IQ\nfloat _rsqr(vec2 uv, vec2 s, float r)\n{\n    vec2 l = abs(uv)-s;\n    return min(length(max(l, 0.)+min(max(l.x, l.y), 0.))-r, max(l.x, l.y));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Below code is taken from https://www.shadertoy.com/view/slKGzy\n//noise from iq's www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fracNoise(vec2 uv){\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat fr  = 0.5000*noise( uv ); \n    uv = m*uv;\n\tfr += 0.2500*noise( uv ); uv = m*uv;\n\tfr += 0.1250*noise( uv ); uv = m*uv;\n\tfr += 0.0625*noise( uv ); uv = m*uv;\n    fr = 0.5 + 0.5*fr;\n    return fr;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GROUND_MAT 0.\n#define WALL_MAT 1.\n#define BACK_LEFT_WALL 2.\n#define FRONT_LEFT_WALL 3.\n#define CEILING_MAT 4.\n#define RIGHT_WALL_MAT 5.\n#define FEET_MAT 6.\n#define SCREEN_MAT 7.\n#define BUTTON_MAT 8.\n#define BORDER_MAT 9.\n#define TV_MAT 10.\n#define GRID_MAT 11.\n\n\nstruct matProp\n{\n    vec3 SpecularColor;\n    vec3 DiffuseColor;\n    float Glossiness;\n    vec3 EmissionColor;\n};\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\n\nvec2 map(vec3 p)\n{\n\n    vec2 acc = vec2(10000., -1.);\n    \n    acc = _min(acc, vec2(-p.y, GROUND_MAT));\n    float wallth = .2;\n    // RightWall\n    float rightWall = _cube(p-vec3(1.,0.,0.), vec3(wallth,5., 10.));\n    rightWall = max(rightWall, -(_sqr(p.zy-vec2(-1.,-2.2), vec2(.5,1.3))));\n    rightWall = max(rightWall, -(_sqr(p.zy-vec2(-3.,-2.2), vec2(.5,1.3))));\n    acc = _min(acc, vec2(rightWall, RIGHT_WALL_MAT));\n    \n    float gridRep = 0.3;\n    vec3 pGrid = p;\n    vec3 pGrid2 = p;\n    pGrid.y = mod(pGrid.y+gridRep*.5, gridRep)-gridRep*.5;\n    pGrid2.z = mod(pGrid2.z+gridRep*.5, gridRep)-gridRep*.5;\n    float rightWindowGrids = _cube(pGrid-vec3(1.,0.,0.), vec3(.025,.025,5.));\n    rightWindowGrids = min(rightWindowGrids, _cube(pGrid2-vec3(1.,0.,0.), vec3(.025,5.,.025)));\n    acc = _min(acc, vec2(rightWindowGrids, WALL_MAT));\n    \n    // Left nearest wall\n    float leftNearWall = _cube(p-vec3(-4.,0.,-2.), vec3(3.,5., wallth));\n    leftNearWall = max(leftNearWall, -(length(p.xy-vec2(-2.2,-1.5))-0.7));\n    leftNearWall = max(leftNearWall, -(_sqr(p.xy-vec2(-2.2,-3.), vec2(.2,.5))));\n    acc = _min(acc, vec2(leftNearWall, FRONT_LEFT_WALL));\n   \n    // Back wall\n    acc = _min(acc, vec2(_cube(p-vec3(-2.,0.,0.), vec3(3.,5., wallth)), BACK_LEFT_WALL));\n    \n    acc = _min(acc, vec2(max(p.y+4.5, p.x-.8), CEILING_MAT));\n    \n    vec3 ptv = p-vec3(-2.,-0.7,-2.5);\n    float tv = _cube(ptv, vec3(0.5,0.4,0.3));\n    \n    acc = _min(acc, vec2(tv, TV_MAT));\n\n    vec3 pfeet = ptv;\n    pfeet.xy *= r2d(.2*sign(pfeet.x));\n    pfeet.z = abs(pfeet.z);\n    pfeet.x = abs(pfeet.x);\n    pfeet -= vec3(.3,0.,0.1);\n    float feet = max(length(pfeet.xz)-.02, -pfeet.y);\n    acc = _min(acc, vec2(feet, FEET_MAT));\n    \n    \n    float border = _cucube(ptv-vec3(-0.35,0.,-.11), vec3(.1,.35,.2), vec3(.01));\n    acc = _min(acc, vec2(border, BORDER_MAT));\n\n    float repgrid = .03;\n    vec3 pgrid = ptv-vec3(-0.35,0.,-.11);\n    pgrid.y = mod(pgrid.y+repgrid*.5, repgrid)-repgrid*.5;\n    float grid = _cube(pgrid, vec3(.1,.01,.22));\n    grid = max(max(grid, -p.y-.8), p.y+.4);\n    acc = _min(acc, vec2(grid, GRID_MAT));\n\n    float bordertv = _cucube(ptv-vec3(0.,0.,-.02), vec3(0.5,0.4,0.3), vec3(.01));\n    acc = _min(acc, vec2(bordertv, BORDER_MAT));\n\n    vec3 pbtn = ptv-vec3(-0.35,-0.25,-.3);\n    float btn = max(length(pbtn.xy)-.05, abs(pbtn.z)-.05);\n    acc = _min(acc, vec2(btn, BUTTON_MAT));\n\n    vec3 pscreen = ptv-vec3(0.125,0.,-.3);\n    float screen = max(_rsqr(pscreen.xy, vec2(.28,.27), .05), abs(pbtn.z)-.02);\n    acc = _min(acc, vec2(screen, SCREEN_MAT));\n\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps, float maxDist)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        /*if (res.y == FLAME_MAT)\n        accLight += vec3(0.941,0.376,0.000)*(1.-sat(res.x/.05))*.05;*/\n        p+= rd*res.x*.25;//*.0125;\n    }\n    return vec3(( distance(p, ro) < maxDist ? -1. : -2.));\n}\n\nfloat getShadow(vec3 ro, vec3 lpos, int steps)\n{\n    float maxDist = distance(ro, lpos);\n    vec3 rd = -normalize(lpos-ro);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return 0.;\n        p+= rd*res.x*.125;\n    }\n    return float(distance(p, ro) > maxDist);\n}\nvec3 getEnv(vec3 rd)\n{\n    return vec3(0.);\n    //return 5.*texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz*vec3(0.941,1.000,1.000);//*.25;\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float stars = pow(texture(iChannel0, uv*5.*vec2(2.,1.)).x, 10.)*sat(-rd.y);\n    vec3 back = mix(vec3(0.910,0.671,0.588), vec3(0.176,0.180,0.345)*.75, pow(sat(-rd.y*2.+.2), .3)); \n    back += vec3(0.455,0.871,0.925)*pow(sat(-(rd.x-2.1)*.4+rd.y*2.),1.2)*.5;\n    back += vec3(0.733,0.416,0.208)*pow(sat(-(rd.x-1.9)*.4+rd.y*2.),3.);\n    back *= 1.-sat(length((uv-vec2(.75,0.1))*.5*vec2(2.,2.)));\n    return back+ vec3(1.)*stars+vec3(.2,.4,.7)*stars*1.;\n}\n\nmatProp getMat(float idMat, vec3 p, vec3 n)\n{\n    matProp mat;\n    mat.SpecularColor = vec3(.05);\n    mat.DiffuseColor = n*.5+.5;\n    mat.Glossiness = .7;\n    \n    mat.EmissionColor = vec3(0.);\n    \n    if (idMat == GROUND_MAT)\n    {\n        mat.DiffuseColor = vec3(.6)*pow(texture(iChannel3, p.xz*r2d(PI*.5)*1.).x,.25);\n        mat.SpecularColor = vec3(1.);\n        mat.Glossiness = 1.;\n    }\n    if (idMat == FRONT_LEFT_WALL)\n    {\n        mat.DiffuseColor = vec3(0.898,0.600,0.263);\n    }\n    if (idMat == RIGHT_WALL_MAT)\n    {\n        mat.DiffuseColor = vec3(1.000,0.478,0.514);\n    }\n    if (idMat == BACK_LEFT_WALL)\n    {\n        mat.DiffuseColor = vec3(0.149,0.329,0.259);\n    }\n    if (idMat == BORDER_MAT)\n    {\n        mat.DiffuseColor = vec3(.1);\n        mat.SpecularColor = vec3(.5);\n        mat.Glossiness = .8;\n    }\n    if (idMat == FEET_MAT)\n    {\n        mat.DiffuseColor = vec3(.1);\n        mat.SpecularColor = vec3(.5);\n        mat.Glossiness = .8;\n    }\n    if (idMat == BUTTON_MAT)\n    {\n        mat.DiffuseColor = vec3(.1);\n    }\n    if (idMat == GRID_MAT)\n    {\n        mat.DiffuseColor = vec3(.2);\n        mat.SpecularColor = vec3(.5);\n        mat.Glossiness = .5;\n    }\n    if (idMat == TV_MAT)\n    {\n        mat.DiffuseColor = texture(iChannel0, p.xz).xxx*vec3(0.361,0.255,0.200);\n    }\n    if (idMat == SCREEN_MAT)\n    {\n        mat.DiffuseColor = mat.SpecularColor = vec3(0.);\n        mat.EmissionColor = 5.*texture(iChannel2, (p.xy*vec2(1.,-1.)+vec2(.2,-0.05))).xyz;\n    }\n    return mat;\n}\n\n\nvec3 getDirectLighting(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    matProp mat = getMat(res.z, p, n);\n    vec3 col = vec3(0.);//n*.5+.5;\n    vec3 lpos = vec3(-40.,15.,-10.)*.35+1.*(vec3(rand(), rand(), rand())-.5);\n    vec3 ldir= p-lpos;\n    vec3 lcol = vec3(0.384,0.812,0.996)*1.;\n    vec3 h = normalize(rd+ldir);\n\n    float ndotl = sat(dot(n, normalize(ldir)));\n    \n    col += mat.DiffuseColor*.15;\n\n    if (getShadow(p+n*0.01,  lpos, 256) > 0.5)\n    {\n        vec3 spec = lcol*mat.SpecularColor*pow(sat(dot(n,h)), mat.Glossiness);\n        vec3 remainingLight = max(lcol-spec, vec3(0.));\n        col += spec+mat.DiffuseColor*ndotl*remainingLight;\n    }\n    col += mat.EmissionColor;\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float xpos = sin(iTime*0.+.5)*2.2;\n    float offy = -.85;\n    float zoff = 5.9;\n    //uv *= r2d(.25);\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.008*0.;\n    vec3 ro = vec3(-5.,-1.7,-8.1)*.9+dof;\n    vec3 ta = vec3(0.5,-.7,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*0.0025;\n    vec3 res = trace(ro, rd, 4096*2, 15.);\n    float maxdist = 20.;\n    float dist = maxdist;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getDirectLighting(res, rd, p, n);\n        //col += accLight;\n        if (true)\n        {\n            vec3 lastCol = col;\n            for (int i = 0; i < 3; ++i)\n            {\n                \n                matProp mat = getMat(res.z, p, n);\n                float doSpec = sat((rand()-0.5)*400.0); // 0 or 1\n                \n                float spec = mat.Glossiness;\n                vec3 glossSamplePos = normalize(vec3(rand(), rand(), rand())-.5)*spec;\n                vec3 refl = normalize(reflect(rd, n)+spec+glossSamplePos);\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), doSpec);\n            \n                if (dot(refl, n) < 0.0 && doSpec < 0.5)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl, 4096*2, 7.);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    vec3 retCol = getDirectLighting(resrefl, refl, prefl, nrefl);\n                    col += retCol;\n                    lastCol = retCol;\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    if (res.x != -1.)\n                        col += getEnv(refl)*mix(mat.DiffuseColor, mat.SpecularColor, doSpec);\n                    break;\n                }\n                \n                rd = refl;\n            }\n\n\n        }\n    col = mix(col, vec3(0.), sat(exp(-dist*.05-.1)));\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float scaleF = 1.;\n    uv *= scaleF;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75/scaleF);\n    vec3 col = rdr(uv+off);\n    col *= vec3(0.800,0.980,1.000);\n    //col = sat(col);\n    // Thanks IQ https://www.shadertoy.com/view/Xd2fzR\n    // gain\n    col *= 2.9/(1.0+col);\n    // burn the highlights\n    float g = dot(col,vec3(0.3333));\n    col = mix( col, vec3(g), min(g*0.2,1.0) );\n    // gamma\n    col = pow( col, vec3(0.84545) );\n    \n    \n    //col = pow(col, vec3(.9));\n    col = sat(col);\n    col *= 1.-sat(length(uv*2.)-.5);\n    if (iFrame > 1)\n        col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz,  .8);\n         //col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col,  1.0 / float(iFrame + 1));\n   \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec2 reptour = vec2(50.);\n    \n    vec3 ptour = p;\n    ptour.xz = clamp(ptour.xz, vec2(-175.), vec2(175.));\n    ptour.xz = mod(ptour.xz+reptour*.5,reptour)-reptour*.5;\n    acc = _min(acc, vec2(_cube(ptour, vec3(1.,55.,1.)), 1.));\n    \n    vec2 rep = vec2(5.);\n    vec3 sz = vec3(.2);\n    vec3 psee = p;\n    vec2 id = floor((psee.xz+rep*.5)/rep);\n    float h = sin(id.x+iTime)\n    +sin(id.x*.5+id.y*.25+iTime*.35)*2.\n    +sin(id.x+id.y+iTime*.75)*.5\n    +sin((id.x-id.y)*10.+iTime*.75)*.25;\n    psee.xz = mod(psee.xz+.5*rep, rep)-rep*.5;\n    psee.y -= h;\n    acc = _min(acc, vec2(_cube(psee, sz), 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        accLight += sat(mix(vec3(0.533,0.294,0.725), vec3(0.486,0.996,0.800), p.y))\n        *(1.-sat(res.x/1.5))*.1;\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    vec2 coords = vec2(atan(rd.z, rd.x), acos(rd.y));\n    return sat(vec3(0.737,0.882,0.835)\n    *fracNoise(coords+vec2(iTime*.01, sin(iTime*.125)*.1))\n    *pow(fracNoise(coords*.1+iTime*0.01),2.)\n    *sat(pow(1.-sat(abs(dot(rd, vec3(0.,1.,0.)))),25.)+.2)*3.)*2.;\n\n    float cloud = texture(iChannel0, coords*.1).x*\n    texture(iChannel0, coords*.01+iTime*.001).x;\n    return sat(pow(cloud, 1.)-0.)*\n    vec3(1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    if (res.z == 1.)\n    {\n        col = vec3(.1);\n    }\n    if (res.z == 0.)\n    {\n        col = mix(vec3(0.533,0.294,0.725), vec3(0.486,0.996,0.800), p.y);\n    }\n    return sat(col);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(sin(iTime*.25)*15.,-15.+5.*sin(iTime*.25),-35.);\n    vec3 ta = vec3(cos(iTime*.15)*55.,-10.,sin(iTime*.15)*5.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n\n    vec3 glow = accLight;\n    float dist = 100.;\n    float py = 5.;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        py = p.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        vec3 refl = normalize(reflect(rd, n));\n        refl = normalize(refl+(fracNoise(p.xy)-.5)*.05);\n        vec3 resrefl = trace(p+n*0.01,refl, 128);\n        vec3 reflCol = getEnv(refl);\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n            reflCol = getMat(resrefl, refl, prefl, nrefl);\n        }\n        col+= reflCol;\n    }\n    else\n        col = getEnv(rd);\n    col += glow;\n    col = mix(col, vec3(0.,0.,0.), sat(1.-exp(-py*0.5+1.5)));        \n    col = mix(col, vec3(0.,0.,0.), sat(1.-exp(-dist*0.01+.5)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    col *= 1.5/(1.+col); \n    col = pow(col, vec3(1.4545));\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXyDX.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1180]], "test": "untested"}
{"id": "Ns2yz1", "name": "sparklin'", "author": "python273", "description": "-", "tags": ["sdf"], "likes": 6, "viewed": 236, "published": 3, "date": "1643115113", "time_retrieved": "2024-07-30T17:07:26.970343", "image_code": "#define PI 3.1415926\n#define hPI 1.5707963\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    //vec2 muv = (iMouse.xy - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 muv = vec2(sin(iTime / 2.) / 19., sin(iTime / 4.) / 19.);\n    //vec2 muv = vec2(0., -0.1);\n\n    float c1 = distance(uv, muv + vec2(0.,    sin(mod(iTime + PI * rand(floor(99. + iTime / 7. )), hPI))) * 1.4) + 0.02;\n    float c2 = distance(uv, muv + vec2(-0.07, sin(mod(iTime + PI * rand(floor(33. + iTime / 11.)), hPI))) * 1.4) + 0.02;\n    float c3 = distance(uv, muv + vec2(0.06,  sin(mod(iTime + PI * rand(floor(22. + iTime / 13.)), hPI))) * 1.4) + 0.02;\n    float c4 = distance(uv, muv + vec2(-0.11, sin(mod(iTime + PI * rand(floor(11. + iTime / 17.)), hPI))) * 1.4) + 0.02;\n    float c5 = distance(uv, muv + vec2(0.09,  sin(mod(iTime + PI * rand(floor(66. + iTime / 5. )), hPI))) * 1.4) + 0.02;\n\n    float c0a = atan(uv.y - muv.y, uv.x - muv.x);\n    float c0 = (\n        (distance(uv, muv) - 0.15)\n        + cos(iTime * -2.0 + c0a * 7.0 ) / (40. + abs(sin(iTime * 2.0)) * 80.0)\n        + cos(iTime *  1.2 + c0a * 11.0) / (60. + abs(sin(iTime * 3.0)) * 70.0)\n        + cos(iTime * -0.4 + c0a * 13.0) / (70. + abs(sin(iTime * 4.0)) * 60.0)\n        + cos(iTime *  1.6 + c0a * 17.0) / (90. + abs(sin(iTime * 5.0)) * 50.0)\n        + cos(iTime * -0.7 + c0a * 29.0) / (90. + abs(sin(iTime * 7.0)) * 40.0)\n        + cos(iTime *  0.2 + c0a * 59.0) / (200. + abs(sin(iTime * 11.0)) * 10.0)\n        + cos(iTime * -3.1 + c0a * 113.) / (380. + abs(sin(iTime * 2.0)) * 150.0)\n    );\n\n    float a = (\n        opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(\n            c0, c1, 0.2), c2, 0.2), c3, 0.2), c4, 0.2), c5, 0.2)\n    );\n\n    fragColor = vec4(\n        smoothstep(0.062, 0., a),\n        smoothstep(0.032, 0., a),\n        smoothstep(0.002, 0., a),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2yz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 66, 66, 114], [117, 117, 169, 169, 268], [271, 271, 328, 328, 2191]], "test": "untested"}
{"id": "Ns2cz1", "name": "TV Effect [ppxxll]", "author": "robclouth", "description": "TV Effect", "tags": ["2d", "postpro", "vigneting", "ppxxll"], "likes": 0, "viewed": 562, "published": 3, "date": "1643112808", "time_retrieved": "2024-07-30T17:07:28.140215", "image_code": "/*\n@title TV Effect\n@author Inigo Quilez\n*/\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = 0.5 + (q-0.5)*(0.9 + 0.1*sin(0.2*iTime));\n\n    vec3 oricol = texture( iChannel0, vec2(q.x,1.0-q.y) ).xyz;\n    vec3 col;\n\n    col.r = texture(iChannel0,vec2(uv.x+0.003,-uv.y)).x;\n    col.g = texture(iChannel0,vec2(uv.x+0.000,-uv.y)).y;\n    col.b = texture(iChannel0,vec2(uv.x-0.003,-uv.y)).z;\n\n    col = clamp(col*0.5+0.5*col*col*1.2,0.0,1.0);\n\n    col *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);\n\n    col *= vec3(0.95,1.05,0.95);\n\n    col *= 0.9+0.1*sin(10.0*iTime+uv.y*1000.0);\n\n    col *= 0.99+0.01*sin(110.0*iTime);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2cz1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[170, 170, 227, 227, 845]], "test": "untested"}
{"id": "NsGGR3", "name": "Summer2021", "author": "deni_de", "description": "Summer 2021", "tags": ["rays"], "likes": 5, "viewed": 277, "published": 3, "date": "1643111116", "time_retrieved": "2024-07-30T17:07:29.112615", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// \n    vec3 sky = vec3(0.1,0.7,1.0);                     //  \n    vec3 horizont = vec3(1.0,1.0,1.0);                //  \n    vec3 sun = vec3(1.0,1.0,0.7);                     //  \n    vec3 beach = vec3(1.0,0.9,0.6);                   //  \n    vec3 water = vec3(0.01,0.5,0.9);                  //  \n    \n//  \n    vec2 uv = fragCoord/iResolution.xy;               //   \n//------------------------------------------------------------------------------------------------------------\n    vec2 pos = uv - vec2(0.5,0.8);                    //   \n//------------------------------------------------------------------------------------------------------------\n    float flip_t = abs(sin(iTime))+ 0.7;              //  ,     \n//------------------------------------------------------------------------------------------------------------\n    vec2 specUV = uv;                                                      //    \n    specUV.y *= 2.21;\n    float specMask = smoothstep(0.2,0.41,length(specUV - vec2(0.5,0.67))); //   \n//------------------------------------------------------------------------------------------------------------\n    float d = length(pos) * 1.5;                                           //   \n//------------------------------------------------------------------------------------------------------------\n    float e = 0.1  + .05 * cos(atan(pos.x,pos.y) * 21.0);                  //     \n//------------------------------------------------------------------------------------------------------------\n    float sunMask = smoothstep(e,e + 5.1 * (flip_t * 0.05),d);             //                                             \n//------------------------------------------------------------------------------------------------------------\n    float sinPosY = pos.y + sin(pos.x * 50.0 + iTime) * 0.01  * texture(iChannel0,uv + iTime * 0.01).r;    //  Y   \n    float waterfoam = 1.0 - smoothstep(0.001,0.03 + (0.001 * flip_t),abs(sinPosY +0.77 - (0.1 * flip_t))); //  \n    waterfoam *= texture(iChannel1,uv * 2.0 ).r * texture(iChannel2,uv * 2.0).r * 5.5;                     //  * \n//------------------------------------------------------------------------------------------------------------\n    float waterMask = smoothstep(0.05,0.06,abs(pos.y + 0.44));                    //  ()\n    waterMask *= smoothstep(0.1,0.11,abs(pos.y + 0.55) * flip_t);                 //   \n//------------------------------------------------------------------------------------------------------------\n    float beachMask = abs(smoothstep(0.1,0.11,-pos.y - 0.4));                     //  \n//------------------------------------------------------------------------------------------------------------\n    vec2 uv_water = uv;                                     //   \n    uv_water.x *= 0.001 * flip_t;                           //     \n//------------------------------------------------------------------------------------------------------------\n    //      \n    float m = texture(iChannel0, uv_water * 5.0 + iTime * 0.05).r \n    * texture(iChannel0, uv - uv_water * 5.0 - iTime * 0.001).r;\n    \n    water = mix(pow(water,vec3(0.3)),horizont,m);\n//------------------------------------------------------------------------------------------------------------\n    //         \n    beach = mix(beach,beach - 0.2, texture(iChannel1, vec2(uv.x * 0.03,uv.y * 1.4)).r) - (-0.7 + texture(iChannel1,uv * 5.0).r) * 0.5;\n//------------------------------------------------------------------------------------------------------------\n    //   \n    float a = water.r * ((1.0 -  specMask)) * (1.0 - waterMask); \n//------------------------------------------------------------------------------------------------------------\n\n// \n    vec3 col = vec3(0.0);                                                  //    \n    \n    sky = mix(horizont,sky,uv.y -0.1);                                     //    \n    sky = mix(sun,sky,sunMask);                                            //    \n    col = sky;                                                             //    \n    col = mix(col,beach, beachMask);                                       //    \n    col = mix(water,col, waterMask);                                       //    \n    col = mix(col,sun,a);                                                  //  \n    col = mix(col,horizont, waterfoam);                                    //  \n    \n// \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 79, 5798]], "test": "untested"}
{"id": "Nsjyzh", "name": "Exact Newton-Raphson (JK)", "author": "oneshade", "description": "Convoluted ridiculousness for the fun of it.\nSolving x' = -f(x)/f'(x)\n(exact solution is f^-1(c*e^-t))", "tags": ["iterative", "exact", "newtonraphson"], "likes": 5, "viewed": 173, "published": 3, "date": "1643093714", "time_retrieved": "2024-07-30T17:07:30.093991", "image_code": "#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 6.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 6.0;\n    float unit = 12.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Axes\n    drawSDF(abs(uv.x), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(uv.y), vec3(0.0, 0.0, 1.0));\n\n    // Plot of x^2 - 2\n    float y = uv.x * uv.x - 2.0;\n    float slope = 2.0 * uv.x;\n    drawSDF(abs(uv.y - y) / sqrt(slope * slope + 1.0), vec3(1.0));\n\n    // Roots\n    drawSDF(length(vec2(abs(uv.x) - sqrt(2.0), uv.y)) - 0.08, vec3(0.0, 1.0, 0.0));\n\n    // Plot \"solution\"\n    float t = mod(iTime, 3.0);\n    float x0 = 8.0 * fract(475.241 * cos(376.584 * floor(iTime / 3.0) + 674.485)) - 4.0;\n    float x = sign(x0) * sqrt((x0 * x0 - 2.0) * exp(-t) + 2.0);\n    drawSDF(length(uv - vec2(x, 0.0)) - 0.08, vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsjyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 135, 135, 1029]], "test": "untested"}
{"id": "7sByRh", "name": "Fork Clouds BigSadge 832", "author": "BigSadge", "description": "I didn't make this, needed to fork for looking glass", "tags": ["procedural", "3d", "raymarching", "volumetric", "lod", "vr"], "likes": 1, "viewed": 317, "published": 3, "date": "1643064979", "time_retrieved": "2024-07-30T17:07:31.264861", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n\n// Volumetric clouds. Not physically correct in any way - \n// it does the wrong extintion computations and also\n// works in sRGB instead of linear RGB color space. No\n// shadows are computed, no scattering is computed. It is\n// a volumetric raymarcher than samples an fBM and tweaks\n// the colors to make it look good.\n//\n// Lighting is done with only one extra sample per raymarch\n// step instead of using 3 to compute a density gradient,\n// by using this directional derivative technique:\n//\n// https://iquilezles.org/articles/derivative\n\n\n// 0: one 3d texture lookup\n// 1: two 2d texture lookups with hardware interpolation\n// 2: two 2d texture lookups with software interpolation\n#define NOISE_METHOD 1\n\n// 0: no LOD\n// 1: yes LOD\n#define USE_LOD 1\n\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n#if NOISE_METHOD==0\n    x = p + f;\n    return textureLod(iChannel2,(x+0.5)/32.0,0.0).x*2.0-1.0;\n#endif\n#if NOISE_METHOD==1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n#if NOISE_METHOD==2\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n}\n\nfloat map( in vec3 p, int oct )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n    float g = 0.5+0.5*noise( q*0.3 );\n    \n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    #if USE_LOD==1\n    if( oct>=2 ) \n    #endif\n    f += 0.25000*noise( q ); q = q*2.23;\n    #if USE_LOD==1\n    if( oct>=3 )\n    #endif\n    f += 0.12500*noise( q ); q = q*2.41;\n    #if USE_LOD==1\n    if( oct>=4 )\n    #endif\n    f += 0.06250*noise( q ); q = q*2.62;\n    #if USE_LOD==1\n    if( oct>=5 )\n    #endif\n    f += 0.03125*noise( q ); \n    \n    f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    return 1.5*f - 0.5 - p.y;\n}\n\nconst vec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\nconst int kDiv = 1; // make bigger for higher quality\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n    // bounding planes\t\n    const float yb = -3.0;\n    const float yt =  0.6;\n    float tb = (yb-ro.y)/rd.y;\n    float tt = (yt-ro.y)/rd.t;\n\n    // find tigthest possible raymarching segment\n    float tmin, tmax;\n    if( ro.y>yt )\n    {\n        // above top plane\n        if( tt<0.0 ) return vec4(0.0); // early exit\n        tmin = tt;\n        tmax = tb;\n    }\n    else\n    {\n        // inside clouds slabs\n        tmin = 0.0;\n        tmax = 60.0;\n        if( tt>0.0 ) tmax = min( tmax, tt );\n        if( tb>0.0 ) tmax = min( tmax, tb );\n    }\n    \n    // dithered near distance\n    float t = tmin + 0.1*texelFetch( iChannel1, px&1023, 0 ).x;\n    \n    // raymarch loop\n\tvec4 sum = vec4(0.0);\n    for( int i=0; i<190*kDiv; i++ )\n    {\n       // step size\n       float dt = max(0.05,0.02*t/float(kDiv));\n\n       // lod\n       #if USE_LOD==0\n       const int oct = 5;\n       #else\n       int oct = 5 - int( log2(1.0+t*0.5) );\n       #endif\n       \n       // sample cloud\n       vec3 pos = ro + t*rd;\n       float den = map( pos,oct );\n       if( den>0.01 ) // if inside\n       {\n           // do lighting\n           float dif = clamp((den - map(pos+0.3*sundir,oct))/0.3, 0.0, 1.0 );\n           vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(1.0,0.6,0.3)*dif;\n           vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n           col.xyz *= lin;\n           // fog\n           col.xyz = mix(col.xyz,bgcol, 1.0-exp2(-0.075*t));\n           // composite front to back\n           col.w    = min(col.w*8.0*dt,1.0);\n           col.rgb *= col.a;\n           sum += col*(1.0-sum.a);\n       }\n       // advance ray\n       t += dt;\n       // until far clip or full opacity\n       if( t>tmax || sum.a>0.99 ) break;\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\n    // background sky\n    vec3 col = vec3(0.76,0.75,0.86);\n    col -= 0.6*vec3(0.90,0.75,0.95)*rd.y;\n\tcol += 0.2*vec3(1.00,0.60,0.10)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    // tonemap\n    col = smoothstep(0.15,1.1,col);\n \n    return vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}\n\n #define QAA\t2                                     \n\n\n\nconst float\tsideAngle = radians(35.0);\n\nconst float\thorizontalAngle = radians(14.0);\n\nconst float\tcameraSize = 2.0;\n\nconst float\taspectRatio = 0.75;\n\nconst vec3  \tVROffset = vec3(0, 0, 1);\n\nfloat quiltColumns\t=\t8.;\n\nfloat quiltRows\t\t=\t6.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    vec4\taccColor = vec4(0.);\n\n    for( int m = 0; m < QAA; m++ )\n\n    for( int n = 0; n < QAA; n++ )\n\n    {\n\n        // pixel coordinates\n\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\n\t\t\n\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\n\t\tvec2\tfract = fract(coord);\n\n\t\tvec2\tfloor = floor(coord);\n\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\n\t\t\n\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\n\t\t\n\n\t\tvec3\tdir = normalize(screenPos - camPos);\n\n\t\tvec4\tcolor;\n\n\t\tmainVR(color, fragCoord, camPos - VROffset, dir);\n\n\t\taccColor += clamp(color, 0.0, 1.0);\n\n\t}\n\n\tfragColor = accColor / float(QAA*QAA);\n\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sByRh.jpg", "access": "api", "license": "proprietary-license", "functions": [[1399, 1399, 1425, 1425, 2156], [2855, 2855, 2924, 2948, 4696], [4698, 4698, 4750, 4750, 4927], [4929, 4929, 4981, 4981, 5439], [5441, 5441, 5535, 5535, 5609], [5906, 5906, 5964, 5964, 7029]], "test": "untested"}
{"id": "fsByzh", "name": "fast radial-filter convolution", "author": "FabriceNeyret2", "description": "for radial symmetric large filters, we can use MIPmap integration per rings to get the convolution almost for free, even for not separable kernels ( some blocks keep visible ).\n\nmore precise & costly for separables:  https://www.shadertoy.com/view/WtKfD3", "tags": ["filter", "convolution", "integration", "gpmipmap"], "likes": 10, "viewed": 532, "published": 3, "date": "1643048552", "time_retrieved": "2024-07-30T17:07:32.053752", "image_code": "// variant of https://shadertoy.com/view/fsjczz\n\n//#define weight(d)   1.\n  #define weight(d)   1./( (d)*(d) )\n//#define weight(d)   exp(-.5*(d)*(d) / 16. )\n\n\nvoid mainImage( out vec4 O, vec2 u ) // =========================================\n{   \n    float t = iTime/4., L;\n    vec2  U = ( 2.*u - R ) / R.y, a,\n          p = length(iMouse.xy) > 10. \n                ? ( 2.*iMouse.xy - R ) / R.y\n                : vec2( .7*cos(t) +.2*sin(7.*t), .5*sin(1.3*t) + .2*cos( 6.1*t) );\n  //L = length(U-p);\n    a = abs(U-p), L = max(a.x,a.y);\n    L = floor(log2(1024.*L));\n    O = texture(iChannel1, vec3(U,1) ).wwww;     // draw image\n    \n    // -----------------------------------------------\n    float w=0.; \n  \n    vec4 P = M(p, 0. ); \n        \n    for( float l=1. ; l<=10.; l++ ) {            // compute convolution per rings\n        P =   M(U, l  ) *exp2(2.*l)\n            - M(U,l-1.) *exp2(2.*(l-1.));\n        P *= weight( exp2(l-.443) );             // filter\n        w += P.w;\n     } \n\n   O.r += .5*w;\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// ===== w: density to sample x,y: moments ============\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    if ( D.z < max(abs(D.x),abs(D.y)) ) return;\n    U.y = 1024. - U.y;                 // like buffA, but 1024 x 1024.\n    \n    O = texture( iChannel0, U/1024. ); // source image\n    float d = clamp( 1.4*(O.r - .07*O.g), 0.,1.);\n  //d = step( .25, d );\n  //d = step( R.x/2., U.x);\n  //d *= d;\n    O = vec4( 0,0, 0, d );             // ( image )\n  //O = vec4( (U/512.-1.)*d, 0, d );   // ( x,y moments, 0, density )\n}", "cube_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R  iResolution.xy\n#define M(U,l)   textureLod( iChannel1, vec3(U,1), l  )   // access density map\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsByzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 242, 242, 1004]], "test": "untested"}
{"id": "NdSyRh", "name": "TicTacUbe", "author": "eiffie", "description": "Challenge: Using the rules in the code can you end the game in a tie?\nBigger challenge: Create an AI that can beat you. (unless random Xs can beat you, then welcome to the club).", "tags": ["tictactoe", "rubiks"], "likes": 9, "viewed": 294, "published": 3, "date": "1643039110", "time_retrieved": "2024-07-30T17:07:32.923427", "image_code": "//tictacube demo by eiffie\n//A fun little tictactoe game with a Rubik's cube and dry erase marker.\n//Each turn consists of one optional rotation and then an X/O mark.\n//To win, by getting 3 in a row, you can only rotate OR mark, not both.\n\n//An AI with a look ahead of 4 turns would have to analyze 5,226,454,388,736\n//moves so you get a crappy demo instead.\n\n#define rez iResolution\n#define pi 3.14159\nvec2 vmax(vec2 v1,vec2 v2){return (v1.x>v2.x)?v1:v2;}\nvec2 vmin(vec2 v1,vec2 v2){return (v1.x<v2.x)?v1:v2;}\nfloat sgn(float x){return x<0.?0.:1.;}\nmat2 rmat(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 mcol=vec3(-1.0);\nint R[14]=int[14](0,0,0,2,1,2,4,6,0,0,1,5,1,3);\nint F[14]=int[14](25,22,44,6,46,45,41,4,5,43,1,42,27,0);\nfloat DE(in vec3 p){\n  vec3 pS=p-vec3(sign(p.x),0.,0.);\n  float tim=iTime*.125+1.;\n  int n=int(min(15.,floor(tim)));\n  for(int i=0;i<n;i++){\n    float t=(i<n-1)?1.:min(fract(tim)*6.,1.);\n    if(R[i]>0){\n      if(R[i]<4){\n        float a=pi;\n        if(R[i]==1)a=-pi/2.;else if(R[i]==2)a=pi/2.;\n        p.yz=p.yz*rmat(a*t);\n      }else{\n        float a=0.;\n        if(p.x<0.){\n          if(R[i]==5)a=-pi/2.;\n          else if(R[i]==6)a=pi/2.;\n        }else if(R[i]==4)a=pi/2.;\n        pS.yz=pS.yz*rmat(a*t);\n      }\n    }\n    \n  }\n  vec2 v=vec2(abs(p.x)-.5,sgn(p.x));\n  v=vmax(v,vec2(abs(p.y)-1.5,2.+sgn(p.y)));\n  v=vmax(v,vec2(abs(p.z)-1.5,4.+sgn(p.z)));\n  vec2 v2=vec2(abs(pS.x)-.5,sgn(pS.x));\n  v2=vmax(v2,vec2(abs(pS.y)-1.5,2.+sgn(pS.y)));\n  v2=vmax(v2,vec2(abs(pS.z)-1.5,4.+sgn(pS.z)));\n  v=vmin(v,v2);\n  if(mcol.x>-1.){\n    int k=20;\n    if(v.x==v2.x){k+=(p.x<0.)?-20:20;p=pS;}\n    pS=p;pS.y=-pS.y;\n    if(v.y<2.){mcol+=vec3(1.,(sign(p.x)+1.)*.25,0.);pS.xy=pS.yz+5.;}\n    else if(v.y<4.){\n      pS.xy=pS.xz;if(p.y<0.){k+=6;mcol+=vec3(0,1,0);}else mcol+=vec3(0,0,1);\n    }else {\n      k+=p.z>0.?3:9;mcol+=vec3(1.,(sign(p.z)+1.)*.5,1.);\n    }\n    k+=int(floor(pS.y+2.5));\n    p=pS;if(abs(p.y)>.5)p.y-=sign(p.y);\n    for(int i=0;i<n;i++){\n      float t=(i<n-1)?1.:min(fract(tim),.5)*2.;\n      if(t<1.)continue;\n      if(F[i]==k){\n        float g=1.;\n        if(i%2>0){g=abs(length(p.xy)-.3);\n        }else{\n          p=abs(p);\n          g=abs(p.x-p.y)+max(0.,max(p.x,p.y)-.3);\n        }\n        mcol*=smoothstep(0.0,0.02,g);\n      }\n    }\n    pS=fract(pS)-.5;\n    pS=abs(pS);\n    mcol*=pow(min(pS.x,pS.y)*2.,.1);\n  }\n  return v.x;\n}\n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat bounce=1.;\nvec3 sky(vec3 rd, vec3 L){\n  vec3 c= abs(rd)*.2+0.3*dot(rd,L)+0.3;\n  for(float i=0.;i<5.;i+=1.){\n    vec2 p=vec2(sin(i*.1+iTime),sin(i*.1+1.+iTime*.7));\n    c+=bounce*5.*vec3(0,1,0)*exp(-abs(dot(p,rd.xz))*1000.);\n  }\n  return clamp(c,0.,1.);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(iTime+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd,in float dL){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n  if(d>dL)break;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,pd,os,px=1./rez.y;\n  vec3 L=normalize(vec3(0.4,0.5,0.5)),C=vec3(0);\n  float refl=1.;\n  for(int j=0;j<4;j++){\n    mcol=vec3(0);d=1.0,pd=10.0,os=0.0; //estimated,prev distance, overstep\n    for(int i=0;i<30;i++){\n      d=DE(ro+rd*t);\n      if(d>os){  //we have NOT stepped over anything \n        os=0.5*d*d/pd;//calc overstep based on ratio of this step to last \n        t+=d+os; //add in the overstep \n        pd=d; //save this step length for next calc \n      }else{  //we MAY have stepped over something \n        os*=0.5; //bisect overstep \n        t-=os; //back up \n        if(os>0.001)d=px*t*2.; //don't bail unless the overstep was small (and d of course) \n        else t+=d+os;//we are going to bail so add in this last distance \n      }\n      if(t>70.0 || d<px*t)break;\n    }\n    if(d<px*t && t<70.){\n      mcol.x=0.0;\n      vec3 so=ro+rd*t;\n      vec3 N=normal(so,d);\n      mcol*=.25;\n      refl*=.25;\n      vec3 scol=mcol;mcol.x=-1.;\n      float dif=0.75+0.25*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=0.5+0.5*ShadAO(so,L,1.);\n      bounce*=bounce*bounce*bounce+8.;\n      scol=(scol*dif+fr*sky(reflect(rd,N),L))*shad;\n      C=clamp(C+scol*refl,0.,1.);\n      ro+=rd*(t-px*t);rd=reflect(rd,N);t=px*t*2.;\n    }\n  }\n  return C+sky(rd,L)*refl;\n}\nvec3 path(float t){float a=t*pi/2.-1.,x=cos(a)*5.;return vec3(x+1.,-sin(a)*5.,max(0.5,10.-iTime*.125)+abs(x));}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n vec3 ro=path(iTime*.5),fw=normalize(-ro);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,3.0));\n fragColor=vec4(scene(ro,rd),2.0);\n}", "image_inputs": [], "sound_code": "#define bps 8.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 5.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= -1.0; \n  else if(n<4.0)n= 0.0; \n  else if(n<5.0)n= -5.0; \n  else if(n<6.0)n= -4.0; \n  else if(n<7.0)n= 4.0; \n  else n=0.0;\n  return vec2(n,r); \n}\nfloat harm(float t){//a harmonic progression series\n  t=mod(t/32.,6.);\n  if(t<1.)t=7.;\n  else if(t<2.)t=3.;\n  else if(t<3.)t=4.;\n  else if(t<4.)t=8.;\n  else if(t<5.)t=5.;\n  else t=2.;\n  return t;\n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,2.333,0.001);//silly fm synth instruments \n //instr sitar=instr(30.0,1.,4.0,0.0,0.2525,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n //instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,epiano)*n0.y;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+60.0+harm(tim),time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,epiano)*n2.y; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 430, 430, 456], [457, 457, 484, 484, 510], [511, 511, 530, 530, 549], [550, 550, 569, 569, 612], [740, 740, 760, 760, 2374], [2376, 2376, 2405, 2415, 2551], [2569, 2569, 2595, 2595, 2812], [2824, 2824, 2850, 2850, 2917], [2919, 2919, 2968, 2968, 3119], [3120, 3120, 3149, 3149, 4482], [4483, 4483, 4502, 4502, 4594], [4595, 4595, 4616, 4616, 4714], [4715, 4715, 4772, 4772, 4962]], "test": "untested"}
{"id": "ss2cRz", "name": "3D Twirly Things", "author": "SnoopethDuckDuck", "description": "playing around with more cylinder stretching stuff\n\ncouldnt get a nice background working - most code is from TheArtOfCode", "tags": ["raymarching", "template", "artofcode"], "likes": 16, "viewed": 458, "published": 3, "date": "1643036921", "time_retrieved": "2024-07-30T17:07:33.921757", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    vec2 uv = p.xz;\n   \n    uv *= Rot(0.18 * p.y + 0.18 * cos(1.5 * iTime + 2. * p.y + 0.2 * dot(uv, uv)));\n    uv = abs(uv) - 1.6;\n    \n    float time = iTime + 2. * p.y;\n    float sc = 2.; //length(uv) * 32.;\n    \n    float r = 0.05;\n    //r += 0.05 * cos(4. * length(uv));\n    float sp = 1.;\n    float n = 7.;\n    float d = 100.;\n    for (float i = 0.; i < n; i++) {\n        float e = (i/n) * pi;\n        vec2 p = 0.5 * cos(time + e + 0.25 * pi * cos(iTime + 2. * e)) * vec2(cos(e), sin(e));\n        d = smin(d, length(uv - p) - 0.1 - 0.05 * cos(iTime + 10. * p.y + e));\n    }\n\n    return 0.7 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n   // vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    dif = 0.2 + 0.8 * dif * step(length(lightPos-p), d);\n   // if(d<length(lightPos-p)) dif = 0.;\n    \n    return dif;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = 0.5 + 0.5 * rd.y;\n   // k = smoothstep(0., 1., k);\n    \n    vec3 e = vec3(1.);\n    vec3 col = pal(0.9 * rd.y - 0.08, vec3(k), e, vec3(k), 1.15 * vec3(0.,0.33,0.66));\n    \n    //col = mix(col, vec3(1.), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float l = 0.5 + 0.5 * thc(3., 0.5 * iTime);\n\n    float r = 5.;\n    float time = 0.25 * iTime;\n    vec3 ro = vec3(r * cos(time), 0. * iTime, r * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.2);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float ambient = .3;\n        float difPower = .4;\n        //float dif = max(dot(n, normalize(vec3(1,2,3))), 0.);\n       // col = vec3(dif*difPower + ambient);\n\n        //float dif2 = GetLight(p, vec3(0.));\n       // col *= 1. * vec3(dif2);\n\n        //col *= texture(iChannel0,r).rgb;\n        float k = 0.5;\n        col = vec3(smoothstep(-k, k, r.y -n.y));\n        //col = clamp(col, 0., 1.);\n\n        vec3 e = vec3(1.);\n        col *= pal(r.y * 0.25, col, e, col, 1.15 *vec3(0.,0.33,0.66));\n        col *= 0.9 + 0.1 * h21(p.xz);\n        //col += mix(col, Bg(rd), 0.58* length(n.xz));\n    }\n    else { \n      //  col = Bg(rd);\n      /*\n       float d = length(uv);\n       float k = 1./iResolution.y;\n       float s = smoothstep(-k, k, -abs(d-0.4) + 0.01);\n       col = vec3(s);\n       */\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2cRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 124, 124, 186], [188, 188, 217, 217, 298], [300, 300, 323, 323, 926], [928, 928, 962, 962, 1173], [1175, 1175, 1199, 1199, 1389], [1391, 1391, 1441, 1441, 1632], [1634, 1634, 1673, 1764, 2040], [2042, 2042, 2060, 2060, 2298], [2300, 2300, 2357, 2357, 3801]], "test": "untested"}
{"id": "7s2yRz", "name": "10-1 SphereSDF", "author": "ccc9527", "description": "SDF,ray marching", "tags": ["raymarching", "sdf"], "likes": 1, "viewed": 238, "published": 3, "date": "1643030315", "time_retrieved": "2024-07-30T17:07:34.791432", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n#define sphere vec4(0,1,6,2)\n\n//1\nfloat sphereSDF(vec3 samplePoint)\n{\n    return length(samplePoint-sphere.xyz)-sphere.w;\n}\n/**\n* \n* eye: \n* marchingDirection: \n* start: \n* end: \n* RayMarch\n*/\nfloat shortDistanceToSurface(vec3 eye,vec3 marchingDirection)\n{\n    float depth = 0.0;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++)\n    {\n        vec3 p = eye+depth*marchingDirection;\n        float dist = sphereSDF(p);\n        depth+=dist;\n        if(dist<EPSILON || depth>MAX_DIST) break;\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0,1.0,0.0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    \n    float dist = shortDistanceToSurface(ro,rd);\n    \n    if(dist>MAX_DIST) return;\n    \n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    \n    vec3 point = ro + rd * dist;\n    vec3 lightPos = vec3(0.0,5.0,4.0);\n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    vec3 lightDir = normalize(lightPos-point);\n    \n    vec3 normal = normalize(point-sphere.xyz);\n    \n    float normalDotLight = clamp(dot(normal, lightDir), 0.0, 1.0);\n    fragColor = mix(vec4(0.1, 0.1, 0.1, 1.0), fragColor, normalDotLight);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2yRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 221, 256, 256, 310], [311, 512, 575, 575, 824], [826, 826, 883, 883, 1531]], "test": "untested"}
{"id": "fsjczz", "name": "summing density by distance", "author": "FabriceNeyret2", "description": "complex integral calculation for (almost free) using smart MIPmaps (i.e. General Purpose MIPmap).\npick location with mouse.\nred: average density in rings\nblue: center of mass of density in rings.", "tags": ["integration", "moments", "gpmipmap"], "likes": 11, "viewed": 385, "published": 3, "date": "1643020033", "time_retrieved": "2024-07-30T17:07:35.714963", "image_code": "float line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n//#define N(v) normalize(v)\n#define N(v) (v)/max(abs(v).x,abs(v).y)\n\nvoid mainImage( out vec4 O, vec2 u ) // =========================================\n{   \n    float t = iTime/4., L;\n    vec2  U = ( 2.*u - R ) / R.y, \n          p = length(iMouse.xy) > 10. \n                ? ( 2.*iMouse.xy - R ) / R.y\n                : vec2( .7*cos(t) +.2*sin(7.*t), .5*sin(1.3*t) + .2*cos( 6.1*t) );\n  //L = length(U-p);\n    L = max(abs(U-p).x,abs(U-p).y);\n    L = floor(log2(1024.*L));\n    O-=O;  \n    O.g += texture(iChannel1, vec3(U,1) ).w;        // draw green density\n    \n    // -----------------------------------------------\n    float k = 1.1478, S; \n    \n    vec4 P = M(p, 0. );                     // optional: contrib of the central pixel\n    if ( L == 0. ) O.r += P.w;\n    if (length(U-P.xy/P.w) < .1 ) O.b++; \n        \n    for( float l=1. ; l<=10.; l++ ) {               // compute total moment and density on rings\n        P =   M(p, l  ) *exp2(2.*l)\n            - M(p,l-1.) *exp2(2.*(l-1.));\n        S = exp2(2.*l) - exp2(2.*(l-1.));\n        if ( L == l ) O.r += P.w / S;               // show density in ring\n        if (length(U-P.xy/P.w) < .05 ) O.b++;       // show center of mass of ring\n     // O.b += smoothstep(3./R.y,0., line(U, p+vec2(0,2.*exp2(l-.5)/1024.), P.xy/P.w ) );\n        O.b += smoothstep(3./R.y,0., line(U, p+2.*exp2(l-.5)/1024.*N(P.xy/P.w-p), P.xy/P.w ) );\n    } \n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// ===== w: density to sample x,y: moments ============\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    if ( D.z < max(abs(D.x),abs(D.y)) ) return;\n    U.y = 1024. - U.y;              // like buffA, but 1024 x 1024.\n    \n    float d = texture( iChannel0, (U-0.*iMouse.xy)/1024. ,4.).r; // green density\n    d = step( .25, d );\n  //d = step( R.x/2., U.x);\n  //d *= d;\n    O = vec4( (U/512.-1.)*d, 0, d ); // ( x,y moments, 0, density )\n}", "cube_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R  iResolution.xy\n#define M(U,l)   textureLod( iChannel1, vec3(U,1), l  )   // access density map\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 207], [277, 277, 360, 360, 1595]], "test": "untested"}
{"id": "sdlcWX", "name": "Raymarcher - Volumetrics", "author": "SpinningCube", "description": "A modification of my raymarcher with simple volumetrics. No proper volumetric lighting yet, however. Check the newer version: [url=https://www.shadertoy.com/view/7lyBWc]https://www.shadertoy.com/view/7lyBWc[/url]", "tags": ["3d", "raymarching", "volumetric"], "likes": 3, "viewed": 303, "published": 3, "date": "1642997880", "time_retrieved": "2024-07-30T17:07:36.824995", "image_code": "/*\n\nRaymarcher - Volumetrics\n\nUses a constant step size, and samples from a 3D layered noise texture.\n\n\nFilmic Transform curve by milesWaugh\n\n*/\n\nconst int maxSteps = 256;\nconst float epsilon = 0.01;\nconst float pi = 3.1415926536;\nconst float focalLength = 0.7;\nconst float renderDist = 8000.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\nfloat rayDensity;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfRoughness;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\n//vec3 ambient = 1.5*vec3(0.2, 0.5, 1.);\nvec3 ambient = vec3(0.2);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n//struct ray {\n\n// SDFs\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance(ray, pos ) - radius;\n}\n\nfloat SphereVolume( vec3 ray, vec3 pos, float radius, float density ) {\n    return density * max(0., (radius - distance(ray, pos))/radius);\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float roughness ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfRoughness = roughness * roughness;\n        }\n    }\n}\n\nfloat Noise3D(vec3 pos) {\n    int layers = 6;\n    float noise = 0.;\n    for (int i = 1; i <= layers; i++) {\n        float scale = pow(2., float(i));\n        noise += 1./scale * texture(iChannel0, 0.008*pos*scale).r;\n    }\n    \n    return noise/(1. - pow(2.,-float(layers)));\n}\n\nvec2 scene( vec3 ray, float renderDist ) {\n\n    float density = 0.;\n    \n    SDE = renderDist;\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/5.)*sinVector)+0.5);\n    \n    //addSDF( Ground( ray, -2.5), colx, 1.5, 0.03 );\n    addSDF( Sphere( ray, vec3(0.), 2.), 0.4 * vec3(0.2,1.,0.2), 1.5, 0.1 );\n    \n    density += SphereVolume( ray, vec3(0.), 12., 7. * pow(Noise3D(ray + iTime + 1./60. * vec3(0.5, 1, 0.5)), 8.));\n    \n    return vec2(SDE, density);\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ).x + \n                      k.yyx * scene( p + k.yyx*h, renderDist ).x + \n                      k.yxy * scene( p + k.yxy*h, renderDist ).x + \n                      k.xxx * scene( p + k.xxx*h, renderDist ).x);\n    \n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    rayDensity = 0.;\n    float firstStepSize = 0.1;\n    float secondStepSize = 0.001;\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n        \n        rayDensity += scene( ray, renderDist ).y*firstStepSize;\n        \n        //rayLength += SDE;\n        rayLength += firstStepSize;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < epsilon ) {\n            for ( int i = 0; i <= maxSteps; i++ ) {\n        \n                scene( ray, renderDist );\n                rayLength -= secondStepSize;\n                ray = rayDir * rayLength + start;\n                if (SDE >= 0.) {\n                    break;\n                }\n            }\n            if ( SDE < epsilon ) {\n                return vec4(1., ray);\n            }\n            else {\n                return vec4(0., ray);\n            }\n        }\n    }\n    return vec4(0., ray);\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    directionalLight( ray, rayDir, normalize(vec3(-1,1,-2)), surfNormal, 3., 0. );\n}\n\nvec3 filmicTransform(vec3 color) {\n    //return color;\n    return vec3(1. - (1./(5. * pow(color.x, 2.) + 1.)),\n                1. - (1./(5. * pow(color.y, 2.) + 1.)),\n                1. - (1./(5. * pow(color.z, 2.) + 1.)));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    //fog = fog*fog;\n    //fog = fog*fog;\n    //vec3 finalCol = (diffuse * surfCol) + (ambient * surfCol) + specular;\n    float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n    vec3 finalCol = mix(surfCol * (diffuse + ambient), vec3(specular) + ambient, f);\n    finalCol = mix(finalCol, ambient, fog);\n    \n    return finalCol;\n}\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sinTime = 0.5*sin(1.*iTime)+0.5;\n    //camera = vec3(10.*sinTime, 2.*sinTime, 10.*sinTime);\n    //camera = vec3(0.);\n    camera = vec3(0, 0, -20);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    \n    //\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);\n    \n    if(iMouse.xy == vec2(0.)){\n        mouse = vec2(0.);\n    }    \n    \n    camera.yz *= rotate(pi * -mouse.y);\n    camera.xz *= rotate(2. * pi * -mouse.x);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    float cameraRayDensity = rayDensity;\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n    \n    col = filmicTransform( col * exp(-cameraRayDensity) );\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 541, 584, 584, 627], [654, 654, 704, 704, 747], [749, 749, 820, 820, 890], [892, 892, 927, 927, 951], [953, 953, 1022, 1022, 1213], [1215, 1215, 1240, 1240, 1491], [1493, 1493, 1535, 1535, 1988], [1990, 1990, 2017, 2017, 2396], [2398, 2398, 2479, 2479, 3488], [3490, 3490, 3534, 3534, 3647], [3649, 3649, 3761, 3761, 4150], [4152, 4152, 4243, 4243, 4387], [4389, 4389, 4447, 4447, 4532], [4534, 4534, 4568, 4588, 4759], [4761, 4761, 4836, 4836, 4977], [4979, 4979, 5034, 5034, 5528], [5530, 5530, 5552, 5552, 5646], [5648, 5648, 5705, 5705, 6906]], "test": "untested"}
{"id": "fsjczR", "name": "pink dance 2d", "author": "jorge2017a2", "description": "pink dance 2d", "tags": ["2d", "bezier", "draw"], "likes": 9, "viewed": 367, "published": 3, "date": "1642996206", "time_retrieved": "2024-07-30T17:07:37.738552", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(3.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.0001,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nvec3 hacerMano(vec2 p, vec3 col)\n{\nvec2 pc1p1=vec2(.314,.692);\nvec2 pc1p2=vec2(.262,.748);\nvec2 pc1p3=vec2(.292,.748);\n\nvec2 pc2p1=vec2(.292,.748);\nvec2 pc2p2=vec2(.318,.732);\nvec2 pc2p3=vec2(.336,.717);\n\nvec2 pc3p1=vec2(.336,.714);\nvec2 pc3p2=vec2(.310,.764);\nvec2 pc3p3=vec2(.332,.776);\n\nvec2 pc4p1=vec2(.336,.776);\nvec2 pc4p2=vec2(.350,.744);\nvec2 pc4p3=vec2(.360,.728);\n\nvec2 pc5p1=vec2(.360,.726);\nvec2 pc5p2=vec2(.356,.771);\nvec2 pc5p3=vec2(.360,.794);\n\nvec2 pc6p1=vec2(.360,.791);\nvec2 pc6p2=vec2(.372,.800);\nvec2 pc6p3=vec2(.392,.735);\n\nvec2 pc7p1=vec2(.314,.692);\nvec2 pc7p2=vec2(.370,.655);\nvec2 pc7p3=vec2(.386,.678);\n\nvec2 pc8p1=vec2(.388,.680);\nvec2 pc8p2=vec2(.425,.710);\nvec2 pc8p3=vec2(.392,.732);\n\nfloat d1= sdBezier(p,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(p,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(p,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(p,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(p,pc7p1,pc7p2,pc7p3);\nfloat d8= sdBezier(p,pc8p1,pc8p2,pc8p3);\ncol=DrawFigBorde(vec3(0.0),col,d1);\ncol=DrawFigBorde(vec3(0.0),col,d2);\ncol=DrawFigBorde(vec3(0.0),col,d3);\ncol=DrawFigBorde(vec3(0.0),col,d4);\ncol=DrawFigBorde(vec3(0.0),col,d5);\ncol=DrawFigBorde(vec3(0.0),col,d6);\ncol=DrawFigBorde(vec3(0.0),col,d7);\ncol=DrawFigBorde(vec3(0.0),col,d8);\nreturn col;\n}\n\nvec3 HacerBrazo(vec2 p, vec3 col)\n{   vec2 a1, b1,a2, b2;\n    vec2 a3,b3,a4,b4;\n    \n    a1=vec2(0.0,0.15);\n    b1=vec2(0.15,0.0);\n    float db1= sdSegment(p-vec2(0.05,0.5), a1,b1);\n    a2=b1;\n    b2=a2+vec2(0.15,-0.05);\n    float db2= sdSegment(p-vec2(0.05,0.5), a2, b2);\n    \n    vec2 mov=vec2(-0.05,-0.025);\n    a3=vec2(0.0,0.15)+mov;\n    b3=vec2(0.15,0.0)+mov;\n    float db3= sdSegment(p-vec2(0.05,0.5), a3,b3);\n    a4=b3;\n    b4=a4+vec2(0.15,-0.05);\n    float db4= sdSegment(p-vec2(0.05,0.5), a4,b4);\n    \n    \n    vec3 colbrazo=vec3(0.0);\n    col=DrawFigBorde(colbrazo,col,db1); //brazo\n    col=DrawFigBorde(colbrazo,col,db2); //brazo\n    col=DrawFigBorde(colbrazo,col,db3); //brazo\n    col=DrawFigBorde(colbrazo,col,db4); //brazo\n   return col;     \n}   \n\nvec3 RostroRosita(vec2 p, vec3 col)\n{\n vec2 p0=p;   \n//resolucion=x=497,   y441\n//c=Curva; p= puntos control\nvec2 pc1p1=vec2(.207,.726);\nvec2 pc1p2=vec2(.304,.812);\nvec2 pc1p3=vec2(.306,.705);\n\nvec2 pc2p1=vec2(.286,.803);\nvec2 pc2p2=vec2(.354,.830);\nvec2 pc2p3=vec2(.404,.789);\n\nvec2 pc3p1=vec2(.445,.531);\nvec2 pc3p2=vec2(.495,.692);\nvec2 pc3p3=vec2(.406,.787);\n\nvec2 pc4p1=vec2(.187,.558);\nvec2 pc4p2=vec2(.328,.397);\nvec2 pc4p3=vec2(.447,.533);\n\nvec2 pc5p1=vec2(.191,.551);\nvec2 pc5p2=vec2(.147,.730);\nvec2 pc5p3=vec2(.286,.805);\n\nvec2 pc6p1=vec2(.306,.705);\nvec2 pc6p2=vec2(.356,.837);\nvec2 pc6p3=vec2(.340,.676);\n\nvec2 pc7p1=vec2(.338,.678);\nvec2 pc7p2=vec2(.416,.805);\nvec2 pc7p3=vec2(.394,.662);\n\nvec2 pc8p1=vec2(.394,.664);\nvec2 pc8p2=vec2(.445,.721);\nvec2 pc8p3=vec2(.465,.639);\n\nvec2 pc9p1=vec2(.227,.624);\nvec2 pc9p2=vec2(.239,.689);\nvec2 pc9p3=vec2(.278,.685);\n\nvec2 pc10p1=vec2(.278,.685);\nvec2 pc10p2=vec2(.310,.662);\nvec2 pc10p3=vec2(.290,.610);\n\nvec2 pc11p1=vec2(.334,.594);\nvec2 pc11p2=vec2(.360,.660);\nvec2 pc11p3=vec2(.376,.639);\n\nvec2 pc12p1=vec2(.374,.642);\nvec2 pc12p2=vec2(.410,.619);\nvec2 pc12p3=vec2(.388,.578);\n\nvec2 pc13p1=vec2(.247,.540);\nvec2 pc13p2=vec2(.272,.499);\nvec2 pc13p3=vec2(.310,.497);\n\nvec2 pc14p1=vec2(.314,.494);\nvec2 pc14p2=vec2(.372,.510);\nvec2 pc14p3=vec2(.378,.537);\n\nvec2 pc15p1=vec2(.296,.587);\nvec2 pc15p2=vec2(.274,.560);\nvec2 pc15p3=vec2(.300,.558);\n\nvec2 pc16p1=vec2(.300,.560);\nvec2 pc16p2=vec2(.322,.551);\nvec2 pc16p3=vec2(.322,.576);\n\n float t=iTime;\n    float t1=mod(t,0.5);\n    float t2=mod(t,1.0);\n    if (t1<t2)\n    p=vec2(-p.x+0.7,p.y);\n\nfloat d1= sdBezier(p,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(p,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(p,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(p,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(p,pc7p1,pc7p2,pc7p3);\nfloat d8= sdBezier(p,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(p,pc9p1,pc9p2,pc9p3);\nfloat d10= sdBezier(p,pc10p1,pc10p2,pc10p3);\nfloat d11= sdBezier(p,pc11p1,pc11p2,pc11p3);\nfloat d12= sdBezier(p,pc12p1,pc12p2,pc12p3);\nfloat d13= sdBezier(p,pc13p1,pc13p2,pc13p3);\nfloat d14= sdBezier(p,pc14p1,pc14p2,pc14p3);\nfloat d15= sdBezier(p,pc15p1,pc15p2,pc15p3);\nfloat d16= sdBezier(p,pc16p1,pc16p2,pc16p3);\n\ncol=DrawFigBorde(vec3(0.0),col,d2); //cabeza\ncol=DrawFigBorde(vec3(0.0),col,d3);//cabeza\ncol=DrawFigBorde(vec3(0.0),col,d4); //cabeza\ncol=DrawFigBorde(vec3(0.0),col,d5); //cabeza\ncol=DrawFigBorde(vec3(0.0),col,d1); //pelo\ncol=DrawFigBorde(vec3(0.0),col,d6); //pelo\ncol=DrawFigBorde(vec3(0.0),col,d7); //pelo\ncol=DrawFigBorde(vec3(0.0),col,d8);  //pelo\ncol=DrawFigBorde(vec3(0.0),col,d9); //ojo der 1\ncol=DrawFigBorde(vec3(0.0),col,d10); //ojo der 2\ncol=DrawFigBorde(vec3(0.0),col,d11); //ojo izq 1 \ncol=DrawFigBorde(vec3(0.0),col,d12); //ojo izq 2\ncol=DrawFigBorde(vec3(0.0),col,d13);  //boca 1\ncol=DrawFigBorde(vec3(0.0),col,d14);  //boca 2\ncol=DrawFigBorde(vec3(0.0),col,d15); //nariz 1\ncol=DrawFigBorde(vec3(0.0),col,d16); //nariz 2\n    \n    p=p0;\n    if (t1<t2)\n    {   col= HacerBrazo(p-vec2(0.05,-0.05), col);\n        col=hacerMano(p-vec2(-0.29,-0.1), col);\n        \n        col= HacerBrazo(vec2(-p.x,-p.y)-vec2(-0.7,-0.83), col);\n        col=hacerMano(vec2(-p.x,-p.y)-vec2(-1.04,-0.88), col);\n     } \n    else\n    {   col= HacerBrazo(vec2(-p.x,p.y)-vec2(-0.7,-0.03), col);\n        col=hacerMano(vec2(-p.x,p.y)-vec2(-1.04,-0.08), col);\n        \n        col= HacerBrazo(vec2(p.x,-p.y)-vec2(-0.005,-0.83), col);\n        col=hacerMano(vec2(p.x,-p.y)-vec2(-0.35,-0.88), col);\n    } \n    p=p0;\n        \n    float dcuerpo= sdBox(p-vec2(0.35,0.3), vec2(0.05,0.15) );\n    float dcuello= sdBox(p-vec2(0.34,0.45), vec2(0.015,0.025) );\n    col=DrawFigBorde(vec3(0.0),col,dcuerpo); \n    col=DrawFigBorde(vec3(1.0,0.0,0.0),col,dcuello); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=0.5;\n    uv*=esc;\n    vec2 uv0=uv;\n    //vec3 col=vec3(0.0,0.1,0.8);\n    vec3 col=vec3(1.0);\n    col= RostroRosita(uv-vec2(-0.4,-0.3), col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n", "sound_code": "//referencia  gaziya\n//https://www.shadertoy.com/view/XsVBzt\n\n#define A 0.125\n#define PI 3.141592654\n\nfloat noise(float time)\n{ return  (fract(sin(time*99.)*50000.0)*2.0-1.0); }\n\n  //original\nfloat kick(float time) \n{  return sin(6.283 * 50.0 * time - 10.0 * exp( -70.0 * time ))*exp(-time*1.6);  }\n\n///modificado por jfp\nfloat bass(float time) \n{ return sin(6.283 * 60.0 * time - 10.0 * exp( -70.0 * time ))*exp(-time*0.56); }\n\nfloat snare(float time) \n{  return noise(time)*max(0.0,1.0-min(0.85,time*4.25)-(time-0.25)*0.3); }\n\nfloat hihat(float time) \n{  return noise(time)*exp(-time*150.0); }\n\nfloat saw(float phase) \n{   float s = 0.0;\n    for (int k = 1; k <= 8; k++) \n     {  s += (sin(2.0*PI*float(k)*phase) / float(k)); }\n    return (1.0/2.0) - (1.0/PI)*s - 0.5;\n}\n\nfloat sawNota(float time,  float freq )\n{   /// FM\n    return  saw(time*freq) *exp(-3.*time);\n}   \n\nfloat sequence(int s,float time)\n{\n  float n =mod(time,A);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/A)-i)%16&1)==1)break;\n    n+=A;\n  }\n  return n;\n}\n\nvec2 mainSound( in int samp, float time )\n{   float t1=mod(time,3.0);\n    float t2=mod(time,6.0);\n    float t1a=mod(time,6.0);\n    float t2a=mod(time,12.0);\n       \n    float s1,s2;\n    if(t1a<t2a)\n    {\n        s1=0.2 * sawNota(sequence(0x1505,time+t1a),440.0);\n        s1+=0.2 * sawNota(sequence(0x8505,time),600.0);\n        s1+=0.2 * sawNota(sequence(0x0225,time),750.0);\n        s1/=2.0;\n    }\n    else\n    {   s1+=0.2 * sawNota(sequence(0x3895,time),40.0 );\n        s1+=0.2 * sawNota(sequence(0x5465,time),140.0 );\n        s1/=2.0;\n    }\n    \n    if(t1<t2)\n        s2=0.2 * bass(sequence(0x1505,time));\n    else\n        s2=0.2 * bass(sequence(0x4895,time));\n    \n    return vec2(\n                 s1 + s2+\n                 0.2 * snare(sequence(0x1010,time))+\n                 0.4 * kick(sequence(0x4082,time))+\n                 0.2 * hihat(sequence(0x5555,time))\n                 );\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 337, 337, 382], [388, 388, 435, 435, 462], [463, 463, 506, 506, 533], [534, 534, 582, 582, 610], [613, 613, 685, 685, 811], [813, 813, 875, 875, 1006], [1008, 1008, 1089, 1089, 1217], [1219, 1219, 1276, 1276, 1346], [1348, 1348, 1410, 1410, 1475], [1477, 1477, 1545, 1545, 1613], [1615, 1615, 1679, 1679, 1750], [1753, 1753, 1790, 1790, 1864], [1866, 1866, 1901, 1901, 1924], [1926, 1926, 1978, 1978, 2094], [2098, 2098, 2132, 2132, 3442], [3444, 3444, 3479, 3479, 4202], [4207, 4207, 4244, 4244, 8043], [8045, 8045, 8102, 8102, 8448]], "test": "untested"}
{"id": "sdlcW8", "name": "1024x1024 Pipelined FFT", "author": "Flyguy", "description": "Uses the cubemap buffer to compute a 1024x1024 FFT by pipelining 10 FFT stages (5x horizontal, 5x vertical) with 4 samples per stage.", "tags": ["fft", "cubemap", "frequency", "fourier"], "likes": 10, "viewed": 410, "published": 3, "date": "1642991866", "time_retrieved": "2024-07-30T17:07:38.668067", "image_code": "#define SPLIT 0\n#define MAGNITUDE 1\n#define PHASE 2\n\n#define VIEW_MODE SPLIT\n\nvec3 rainbow(float x)\n{\n    vec3 col = vec3(0);\n    col.r = cos(x * tau - (0.0/3.0)*tau);\n    col.g = cos(x * tau - (1.0/3.0)*tau);\n    col.b = cos(x * tau - (2.0/3.0)*tau);\n    \n    return col * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat cubeRes = float(textureSize(iChannel0,0).x);\n    \n    #if(VIEW_MODE == SPLIT)\n        vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*cubeRes);\n        uvIn.x = reverseBits(uvIn.x, ceil(log2(float(cubeRes))));\n        vec2 fftIn = textureCubeFace(iChannel0,0., uvIn/cubeRes).xy;\n\n        vec2 uvFFT = mod(uv.yx-0.5, 1.);\n        vec2 fftHV = textureCubeFace(iChannel0,5., uvFFT).zw;\n        \n        fragColor = (side == 0.) ? vec4(length(fftIn)) : \n                                   vec4(log(0.1+fftHV.x)/log(cubeRes*cubeRes));                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n    \n    #if(VIEW_MODE == MAGNITUDE)\n        vec2 uv = floor(fragCoord.xy) / iResolution.y;\n        uv.x -= (iResolution.x/iResolution.y-1.0)/2.;\n        float clip = step(uv.x,1.0)*step(0.0,uv.x);\n        uv = mod(uv.yx-0.5, 1.);\n        vec2 fftHV = textureCubeFace(iChannel0,5., uv).zw;\n        fragColor = vec4(log(0.1+fftHV.x)/log(cubeRes*cubeRes));\n        fragColor *= clip;\n    #endif\n    \n    #if(VIEW_MODE == PHASE)\n        vec2 uv = floor(fragCoord.xy) / iResolution.y;\n        uv.x -= (iResolution.x/iResolution.y-1.0)/2.;\n        float clip = step(uv.x,1.0)*step(0.0,uv.x);\n        uv = mod(uv.yx-0.5, 1.);\n        vec2 fftHV = textureCubeFace(iChannel0,5., uv).zw;\n        fragColor = vec4(rainbow(fftHV.y),0);\n        fragColor *= clip;\n    #endif\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// -- Constants --\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n// -- Math Functions --\n\n//Complex multiply\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(dot(a,b*vec2(1,-1)), dot(a,b.yx));\n}\n\n//Reverse 0 to 'n' in integer 'x'\nfloat reverseBits(float x, const float n)\n{\n    int r = 0;\n    int xi = int(x);\n    for(int i = 0;i < int(n);i++)\n    {\n        r = r << 1 | (xi & 1);\n        xi >>= 1;\n    }\n    return float(r);\n}\n\n/*\nButterfly operation\n\n(x0)____________(+)_(xy)\n            \\  /\n             \\/\n             /\\\n(x1)_W(i,n)_/__\\(-)_(zw)\n\nxy = x0 + W(i,n)*x1\nzw = x0 - W(i,n)*x1\n\n*/\nvec4 butterfly(vec2 x0, vec2 x1, float i, float n)\n{\n    float a = -floor(i)*tau/floor(n);\n    vec2 w = vec2(cos(a),sin(a));\n    x1 = cmul(x1, w);\n    return vec4(x0 + x1, x0 - x1);\n}\n\n// -- Windowing Functions --\n\n//Rectangular window\nfloat Rectangle(float i, float N)\n{\n    return 1.0;\n}\n\n//Hann Window\nfloat Hann(float i, float N)\n{\n    float w = sin((pi*floor(i))/floor(N));\n    return w*w;\n}\n\n//Triangular window\nfloat Triangle(float i, float N)\n{\n    return 1.0-abs(2.0*floor(i)/floor(N) - 1.0);\n}\n\n// -- Cubemap Sampling Helper Functions --\n\n//Converts a ray direction to uv coords (xy, normalized) & a face id (z, 0-5).\n//for the cubemap face it's pointing to.\nvec3 rayToFace(vec3 rd)\n{\n    vec3 asign = sign(rd);\n    rd = abs(rd);\n    float amax = max(max(rd.x,rd.y),rd.z);\n    \n    vec3 face = (rd.x == amax) ? vec3(asign.yz*rd.yz, floor(1.+.5*asign.x)) :\n                (rd.y == amax) ? vec3(asign.xz*rd.xz, floor(3.+.5*asign.y)) :\n                (rd.z == amax) ? vec3(asign.xy*rd.xy, floor(5.+.5*asign.z)) : \n                                 vec3(0,0,-1);\n    face.xy = .5+.5*(face.xy/amax);\n    face.xy = floor(face.xy*1024.)/1024.; \n    return face;\n}\n\n//opposite of rayToFace\n//Converts normalized uv coords & a face id to a ray direction\n//for cubemap sampling\nvec3 faceToRay(vec3 face)\n{\n    face.xy = (face.xy) + 0.5/1024.;\n    vec3 rd = vec3(2.0*fract(face.xy)-1.0, sign(mod(face.z,2.)-.5));\n    rd = (face.z <= 1.) ? rd.zxy :\n         (face.z <= 3.) ? rd.xzy :\n         (face.z <= 5.) ? rd.xyz :\n                          vec3(0);\n    return normalize(rd);\n}\n\n//Sample a cubemap face (0-5) with normalized uv coords.\nvec4 textureCubeFace(samplerCube cube, float face, vec2 uv)\n{\n    //uv+=0.5/float(textureSize(cube,0));\n    vec3 rd = faceToRay(vec3(uv,floor(face)));\n    return texture(cube, rd, 0.0).rgba;  \n}\n\n", "cube_a_code": "const float fftSize = 1024.;\nconst float numStages = ceil(log2(float(fftSize)));\n\n//Input Windowing Function (Rectangle/Triangle/Hann)\n#define WINDOW_FUNCTION Hann\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 face = rayToFace(rd);\n    vec2 uv = floor(face.xy*fftSize);\n\n    float idx = uv.x;\n    float stage = face.z;\n    vec4 cout = vec4(0.0); \n    \n    if(stage == 0.)\n    {\n        //XY = Horizonal FFT Input (Channel 1)\n        //Input image is mapped 1:1 into the input buffer with no scaling.\n        //Input image centered in the 1024x1024 buffer.\n        vec2 tres = iChannelResolution[1].xy;\n        vec2 tuv = vec2(reverseBits(uv.x, numStages), uv.y);\n        tuv = tuv - vec2(fftSize/2.) + vec2(tres/2.);\n        \n        vec3 col = texelFetch(iChannel1, ivec2(tuv), 0).rgb;\n        \n        cout.xy = vec2((col.x+col.y+col.z)/3.0, 0);\n        cout.xy *= WINDOW_FUNCTION(tuv.x, tres.x);\n        cout.xy *= WINDOW_FUNCTION(tuv.y, tres.y);\n        \n        //ZW = Vertical FFT Input (Horizontal FFT output rotated 90deg)\n        uv.x = float(reverseBits(uv.x, numStages));\n        cout.zw = textureCubeFace(iChannel0, 5.0, uv.yx/fftSize).xy;\n    }\n    else\n    {\n        //2x Horizontal 4-sample FFTs on XY & ZW components\n        float stage1Size = exp2(float(stage)*2.);\n        float stage0Size = stage1Size/2.;\n\n        float offs = floor(idx / stage1Size)*stage1Size;\n        idx -= offs;\n        \n        float w0 = mod(idx, stage0Size/2.);\n        float w1 = mod(idx, stage1Size/2.);\n        \n        vec4 soffs = vec4(offs + w0 + vec4(0,1,2,3)*stage0Size/2.);\n        vec4 x0 = textureCubeFace(iChannel0, stage-1., vec2(soffs[0], uv.y) / fftSize);\n        vec4 x1 = textureCubeFace(iChannel0, stage-1., vec2(soffs[1], uv.y) / fftSize);\n        vec4 x2 = textureCubeFace(iChannel0, stage-1., vec2(soffs[2], uv.y) / fftSize);\n        vec4 x3 = textureCubeFace(iChannel0, stage-1., vec2(soffs[3], uv.y) / fftSize);\n\n        vec4 y0y1_H = butterfly(x0.xy, x1.xy, w0, stage0Size);\n        vec4 y2y3_H = butterfly(x2.xy, x3.xy, w0, stage0Size);\n\n        vec4 y0y1_V = butterfly(x0.zw, x1.zw, w0, stage0Size);\n        vec4 y2y3_V = butterfly(x2.zw, x3.zw, w0, stage0Size);\n        \n        vec4 z0z1_H, z0z1_V;\n        \n        if(mod(idx, stage0Size) < stage0Size/2.)\n        {\n            z0z1_H = butterfly(y0y1_H.xy, y2y3_H.xy, w1, stage1Size);            \n            z0z1_V = butterfly(y0y1_V.xy, y2y3_V.xy, w1, stage1Size);\n        }\n        else\n        {\n            z0z1_H = butterfly(y0y1_H.zw, y2y3_H.zw, w1, stage1Size);            \n            z0z1_V = butterfly(y0y1_V.zw, y2y3_V.zw, w1, stage1Size);\n        }\n        \n        cout = (idx < stage1Size/2.) ? vec4(z0z1_H.xy,z0z1_V.xy): \n                                       vec4(z0z1_H.zw,z0z1_V.zw);\n    }\n    \n    if(face.z == 5.) //Convert to magnitude/phase on last stage of vertical FFT\n    {\n        cout.zw = vec2(length(cout.zw), atan(cout.w, cout.z)/pi + 0.5);\n    } \n    \n    fragColor = vec4(cout);\n}\n\n\n", "cube_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 101, 101, 286], [288, 288, 345, 345, 1894]], "test": "untested"}
{"id": "NdjyRR", "name": "Stone Bridge", "author": "wyatt", "description": "stone simulation", "tags": ["jfa"], "likes": 51, "viewed": 583, "published": 3, "date": "1642991420", "time_retrieved": "2024-07-30T17:07:39.570654", "image_code": "// Fork of \"Water Hammer\" by wyatt. https://shadertoy.com/view/sdSyzR\n// 2022-01-24 01:09:34\n\n// Fork of \"Material Point Method\" by wyatt. https://shadertoy.com/view/fssyDs\n// 2022-01-23 20:24:27\n\nMain\n    \n    vec4 b = B(U);\n    vec4 a = A(b.xy);\n    vec4 d = D(2.*b.xy);\n    vec4 c = C(U);\n    Q = mix(vec4(0),d*(.5+a),clamp(c.w,0.,1.));\n    \n\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define pi 3.14159265359\n\nfloat building(vec2 U) {\n    \n    if (U.y<.8*R.y&&\n        U.y>sqrt(abs(.8*R.y*.8*R.y-(U.x-.5*R.x)*(U.x-.5*R.x)))-200.)\n        return 1.;\n    return 0.;\n\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-.3/R.y);\n    for (float x = -4.; x <= 4.; x ++) \n    for (float y = -4.; y <= 4.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 c = C(Q.xy+vec2(x,y));\n        vec4 b = B(Q.xy+vec2(x,y));\n        vec4 a = A(b.xy);\n        \n        vec2 u = abs(Q.xy+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5)continue;\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        if (l<1.||l>6.) continue;\n        float L = length(U-b.xy);\n        if ((l-L)<.2*L*d.x)  \n            f += 2e-1*r*(l-L)/l/l/L;\n        else f -= 1e-3*r/l;\n    }\n    Q.zw = c.xy;\n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.y=1., Q.w *= -1.;\n    if (Q.x<1.) Q.x=1., Q.z *= -1.;\n    if (R.y-Q.y<1.) Q.y=R.y-1., Q.w *= -1.;\n    if (R.x-Q.x<1.) Q.x=R.x-1., Q.z *= -1.;\n\n    if (M.z>0.&&U.x>.5*R.x) Q.zw -= 3e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1||(U.x<.5)) {\n    \n        Q = vec4(U,0,0);\n   }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    vec4 w = vec4(0);\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        vec4 a = A(b.xy);\n        vec4 d = D(b.xy);\n        vec2 v = a.xy-U;\n        vec4 e = 1./(1.+vec4(12,12,0,6)*(x*x+y*y));\n        vec2 u = abs(U+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5) continue;\n        \n        w += e;\n        Q += vec4(a.zw,d.w,1)*e;\n    }\n    if (w.x>0.) Q.xy /= w.x;\n    if (w.y>0.) Q.z /= w.y;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n   vec4 n = D(2.*U+vec2(0,3));\n   vec4 e = D(2.*U+vec2(3,0));\n   vec4 s = D(2.*U-vec2(0,3));\n   vec4 w = D(2.*U-vec2(3,0));\n   vec4 m = .25*(n+e+s+w);\n   Q = D(2.*U);\n\n    Q = vec4(1)*exp(-10.*abs(e.x-w.x)-10.*abs(n.x-s.x));\n\n}", "buffer_d_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdtGDj", "name": "distfunct", "author": "Kitesurf_m8s", "description": "dgdgd", "tags": ["distfunc"], "likes": 1, "viewed": 209, "published": 3, "date": "1642988577", "time_retrieved": "2024-07-30T17:07:40.461272", "image_code": "float sstep(float g, float a, float b){\n    float t = min(max((g-a)/(b-a),0.),1.);\n    return t*t*(3.-2.*t);\n}\n\nvec3 rwb(float g){\n    float R = max(min(min(1.+g,1.),2.-g),0.);\n    float G = max(1.-abs(g),0.);\n    float B = max(min(min(1.-g,1.),2.+g),0.);\n    return vec3(R,G,B);\n}\n\nfloat f(float x, float y){\n    return (y-sin(4.*x))/length(vec2(4.*cos(4.*x),1.));\n}\nfloat f2(float x, float y){\n\tvec2 df = vec2( f(x+0.01,y)-f(x-0.01,y), f(x,y+0.01)-f(x,y-0.01))/0.02;\n    \n    return f(x,y)/length(df);  \n}\n\nfloat f3(float x, float y){\n\tvec2 df2 = vec2( f2(x+0.01,y)-f2(x-0.01,y), f2(x,y+0.01)-f2(x,y-0.01))/0.02;\n    return f2(x,y)/length(df2);\n}\n\nfloat f4(float x, float y){\n\tvec2 df3 = vec2( f3(x+0.01,y)-f3(x-0.01,y), f3(x,y+0.01)-f3(x,y-0.01))/0.02;\n    return f3(x,y)/length(df3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 X = 3.*(fragCoord/(iResolution.y)- vec2(0.5*(iResolution.x)/(iResolution.y),0.5));\n\tfloat x = X.x;\n    float y = X.y;\n    \n    vec2 df4 = vec2( f4(x+0.01,y)-f4(x-0.01,y), f4(x,y+0.01)-f4(x,y-0.01))/0.02;\n    \n    float g = f4(x,y)/length(df4);\n    //g = f2(x,y);\n    \n    vec3 col = rwb(10.*g);\n    \n    // Axes\n    if(x<0.01 && x>-0.01 || y<0.01 && y>-0.01) col *= 0.;\n    if((x-1.)<0.01 && (x-1.)>-0.01 && y<0.1 && y>-0.1) col *= 0.5;\n    if((x+1.)<0.01 && (x+1.)>-0.01 && y<0.1 && y>-0.1) col *= 0.5;\n    if((x)<0.1 && (x)>-0.1 && (y-1.)<0.01 && (y-1.)>-0.01) col *= 0.5;\n    if((x)<0.1 && (x)>-0.1 && (y+1.)<0.01 && (y+1.)>-0.01) col *= 0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 110], [112, 112, 130, 130, 281], [283, 283, 309, 309, 367], [368, 368, 395, 395, 507], [509, 509, 536, 536, 648], [650, 650, 677, 677, 789], [791, 791, 848, 848, 1566]], "test": "untested"}
{"id": "7sSyzR", "name": "dambreak 3", "author": "Kitesurf_m8s", "description": "khgcf", "tags": ["cahnhilliard"], "likes": 2, "viewed": 174, "published": 3, "date": "1642988445", "time_retrieved": "2024-07-30T17:07:41.391785", "image_code": "// Fork of \"dambreak 2\" by Kitesurf_m8s. https://shadertoy.com/view/sdBcRR\n// 2022-01-23 22:42:17\n\n// Fork of \"dambreak\" by Kitesurf_m8s. https://shadertoy.com/view/7dfyWf\n// 2022-01-23 21:35:20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*(res.x-1.0));\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = (vec3(0.5+1.*(res.w-0.5),0.5+10.*(res.y/res.x),0.5+10.*(res.z/res.x)));\n    \n    vec4 res = texelFetch(iChannel0,p,0);\n    vec3 col = (0.5+0.5*res.w)*vec3(0.5+8.*res.yz/res.x,1.0);\n    //vec3 col = vec3(0.5+8.*res.yz/res.x,1.0);\n    //vec3 col = vec3(0.9*res.x);\n    //vec3 col = vec3(0.7+30.*prs(res.x,res.w/res.x));\n    \n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*res.yz,res.w);\n\n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*(res.yz),10.*(res.x-1.0));\n    \n    //vec4 res = texelFetch(iChannel1,p,0);\n    //vec3 col = res.xyz;\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 uu = texture(iChannel0,uv+vec2(0.,2.)/iResolution.xy);\n    vec4 u = texture(iChannel0,uv+vec2(0.,1.)/iResolution.xy);\n    vec4 c = texture(iChannel0,uv+vec2(0.,0.)/iResolution.xy);\n    vec4 d = texture(iChannel0,uv+vec2(0.,-1.)/iResolution.xy);\n    vec4 dd = texture(iChannel0,uv+vec2(0.,-2.)/iResolution.xy);\n    vec4 ll = texture(iChannel0,uv+vec2(-2.,0.)/iResolution.xy);\n    vec4 l = texture(iChannel0,uv+vec2(-1.,0.)/iResolution.xy);\n    vec4 r = texture(iChannel0,uv+vec2(1.,0.)/iResolution.xy);\n    vec4 rr = texture(iChannel0,uv+vec2(2.,0.)/iResolution.xy);\n    vec4 ul = texture(iChannel0,uv+vec2(-1.,1.)/iResolution.xy);\n    vec4 ur = texture(iChannel0,uv+vec2(1.,1.)/iResolution.xy);\n    vec4 dl = texture(iChannel0,uv+vec2(-1.,-1.)/iResolution.xy);\n    vec4 dr = texture(iChannel0,uv+vec2(1.,-1.)/iResolution.xy);\n    \n    vec4 res = c;\n    res -= 0.9*CFL*(20.*D4(c)+(D4(uu)+D4(dd)+D4(ll)+D4(rr))+2.0*(D4(ul)+D4(ur)+D4(dl)+D4(dr))-8.0*(D4(u)+D4(d)+D4(l)+D4(r)));\n    res -= 0.9*CFL*((1./12.)*(Fx(ll)-Fx(rr))-(2./3.)*(Fx(l)-Fx(r)));\n    res -= 0.9*CFL*((1./12.)*(Fy(dd)-Fy(uu))-(2./3.)*(Fy(d)-Fy(u)));\n    \n    res += 0.9*CFL*((-1./12.)*(D2(ll)+D2(rr)+D2(uu)+D2(dd))+(4./3.)*(D2(l)+D2(r)+D2(u)+D2(d))-(5.)*D2(c));\n    \n    \n    \n    //res.z -= 0.9*CFL*0.0001*c.w/(c.x+0.001);\n    res.z -= 0.9*CFL*0.0002*c.x;\n    \n    \n    vec4 map = texelFetch(iChannel2,p,0);\n    if(map.x>0.5){\n        //res.x -= 0.5*(res.x-1.0);\n        res.y *= 0.9;\n        res.z *= 0.9;\n        //res.w = min(1.0,max(0.,res.w));\n    }\n    \n    fragColor = res;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 uu = texture(iChannel0,uv+vec2(0.,2.)/iResolution.xy);\n    vec4 u = texture(iChannel0,uv+vec2(0.,1.)/iResolution.xy);\n    vec4 c = texture(iChannel0,uv+vec2(0.,0.)/iResolution.xy);\n    vec4 d = texture(iChannel0,uv+vec2(0.,-1.)/iResolution.xy);\n    vec4 dd = texture(iChannel0,uv+vec2(0.,-2.)/iResolution.xy);\n    vec4 ll = texture(iChannel0,uv+vec2(-2.,0.)/iResolution.xy);\n    vec4 l = texture(iChannel0,uv+vec2(-1.,0.)/iResolution.xy);\n    vec4 r = texture(iChannel0,uv+vec2(1.,0.)/iResolution.xy);\n    vec4 rr = texture(iChannel0,uv+vec2(2.,0.)/iResolution.xy);\n    vec4 ul = texture(iChannel0,uv+vec2(-1.,1.)/iResolution.xy);\n    vec4 ur = texture(iChannel0,uv+vec2(1.,1.)/iResolution.xy);\n    vec4 dl = texture(iChannel0,uv+vec2(-1.,-1.)/iResolution.xy);\n    vec4 dr = texture(iChannel0,uv+vec2(1.,-1.)/iResolution.xy);\n    \n    vec4 res = texelFetch(iChannel1,p,0);\n    res -= CFL*(20.*D4(c)+(D4(uu)+D4(dd)+D4(ll)+D4(rr))+2.0*(D4(ul)+D4(ur)+D4(dl)+D4(dr))-8.0*(D4(u)+D4(d)+D4(l)+D4(r)));\n    res -= CFL*((1./12.)*(Fx(ll)-Fx(rr))-(2./3.)*(Fx(l)-Fx(r)));\n    res -= CFL*((1./12.)*(Fy(dd)-Fy(uu))-(2./3.)*(Fy(d)-Fy(u)));\n    \n    res += CFL*((-1./12.)*(D2(ll)+D2(rr)+D2(uu)+D2(dd))+(4./3.)*(D2(l)+D2(r)+D2(u)+D2(d))-(5.)*D2(c));\n    \n    //res.z -= CFL*0.0001*c.w/(c.x+0.001);\n    res.z -= CFL*0.0002*c.x;\n    \n    vec4 map = texelFetch(iChannel2,p,0);\n    if(iFrame <2){\n        if(map.z>0.5){\n            res.x = 1.0;\n            res.y = 0.0;\n            res.z = 0.0;\n            res.w = 1.0;\n        }\n        else{\n            res.x = 0.01;\n            res.y = 0.0;\n            res.z = 0.0;\n            res.w = 0.0;\n        }\n    }\n    if(map.x>0.5){\n        //res.x -= 0.5*(res.x-1.0);\n        res.y *= 0.9;\n        res.z *= 0.9;\n        //res.w = min(1.0,max(0.,res.w));\n    }\n\n    fragColor = res;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define biharm 0.02\n#define CFL 0.05\n#define sharpen 0.1\n\nfloat prs(float rho, float alpha){\n    return 1.0*(rho-(0.05+0.95*alpha));\n    //return 1.0*(rho/(0.8*alpha+0.2)-1.0);\n}\n\n//Flux function x part\nvec4 Fx(vec4 a){\n    vec4 res;\n    res.x = a.y;\n    res.y = a.y*a.y/(a.x+0.001) + prs(a.x, a.w/a.x);\n    res.z = a.z*a.y/(a.x+0.001);\n    res.w = a.w*a.y/(a.x+0.001);\n    return res;\n}\n//Flux function y part\nvec4 Fy(vec4 a){\n    vec4 res;\n    res.x = a.z;\n    res.y = a.y*a.z/(a.x+0.001);\n    res.z = a.z*a.z/(a.x+0.001) + prs(a.x, a.w/a.x);\n    res.w = a.w*a.z/(a.x+0.001);\n    return res;\n}\n\n//Flux for Laplacian\nvec4 D2(vec4 a){\n    vec4 res = vec4(0.);\n    res.y = 0.01*a.y/(a.x+0.001);\n    res.z = 0.01*a.z/(a.x+0.001);\n    //Cahn-Hilliard\n    float alpha = a.w/(a.x+0.001);\n    res.w = 0.02*(alpha-3.0*alpha*alpha+2.0*alpha*alpha*alpha);\n    return res;\n    \n}\n\n//Flux for Harmonic operator \"Laplacian*Laplacian\"\nvec4 D4(vec4 a){\n    vec4 res =vec4(0.);\n    res.x = 6.0*prs(a.x, a.w/a.x);\n    res.y = a.y/(a.x+0.001);\n    res.z = a.z/(a.x+0.001);\n    res.w = a.w/(a.x+0.001);\n    return biharm*res;\n}\n", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.x;\n    \n    vec4 res = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    if(iFrame<1){\n        if (fragCoord.x<3.\n         || fragCoord.x>(iResolution.x-3.)\n         || fragCoord.y<3.\n         || fragCoord.y>(iResolution.y-3.)){\n            res.x = 1.0;\n        }\n        \n        if (fragCoord.x>=0.0*(iResolution.x-3.)\n         && fragCoord.x<0.6*(iResolution.x-3.)\n         && fragCoord.y>=0.0*(iResolution.y-3.)\n         && fragCoord.y<0.4*(iResolution.y-3.)){\n            res.z = 1.0;\n        }\n        \n        if (true &&\n            fragCoord.x>=0.7*(iResolution.x-3.)\n         && fragCoord.x<0.8*(iResolution.x-3.)\n         && fragCoord.y>=0.0*(iResolution.y-3.)\n         && fragCoord.y<0.1*(iResolution.y-3.)){\n            res.x = 1.0;\n            res.z = 0.0;\n        }\n    }\n    \n    if(iMouse.z > 0.){\n        vec2 d2 = fragCoord-iMouse.xy;\n        if(dot(d2,d2) < 100.){\n            if(texelFetch(iChannel3,ivec2(37,1),0).y>0.){\n                res.z = 0.0;\n            }else{\n                res.z = 1.0;\n            }\n        }\n    }\n\n    fragColor = vec4(res);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 253, 253, 1075]], "test": "untested"}
{"id": "sdBcRR", "name": "dambreak 2", "author": "Kitesurf_m8s", "description": "khgcf", "tags": ["cahnhilliard"], "likes": 2, "viewed": 188, "published": 3, "date": "1642988436", "time_retrieved": "2024-07-30T17:07:42.227550", "image_code": "// Fork of \"dambreak\" by Kitesurf_m8s. https://shadertoy.com/view/7dfyWf\n// 2022-01-23 21:35:20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*(res.x-1.0));\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = (vec3(0.5+1.*(res.w-0.5),0.5+10.*(res.y/res.x),0.5+10.*(res.z/res.x)));\n    \n    vec4 res = texelFetch(iChannel0,p,0);\n    vec3 col = 2.*res.w*vec3(0.5+5.*res.yz/res.x,1.0);\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*res.yz,res.w);\n\n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*(res.yz),10.*(res.x-1.0));\n    \n    //vec4 res = texelFetch(iChannel1,p,0);\n    //vec3 col = res.xyz;\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 uu = texture(iChannel0,uv+vec2(0.,2.)/iResolution.xy);\n    vec4 u = texture(iChannel0,uv+vec2(0.,1.)/iResolution.xy);\n    vec4 c = texture(iChannel0,uv+vec2(0.,0.)/iResolution.xy);\n    vec4 d = texture(iChannel0,uv+vec2(0.,-1.)/iResolution.xy);\n    vec4 dd = texture(iChannel0,uv+vec2(0.,-2.)/iResolution.xy);\n    vec4 ll = texture(iChannel0,uv+vec2(-2.,0.)/iResolution.xy);\n    vec4 l = texture(iChannel0,uv+vec2(-1.,0.)/iResolution.xy);\n    vec4 r = texture(iChannel0,uv+vec2(1.,0.)/iResolution.xy);\n    vec4 rr = texture(iChannel0,uv+vec2(2.,0.)/iResolution.xy);\n    vec4 ul = texture(iChannel0,uv+vec2(-1.,1.)/iResolution.xy);\n    vec4 ur = texture(iChannel0,uv+vec2(1.,1.)/iResolution.xy);\n    vec4 dl = texture(iChannel0,uv+vec2(-1.,-1.)/iResolution.xy);\n    vec4 dr = texture(iChannel0,uv+vec2(1.,-1.)/iResolution.xy);\n    \n    vec4 res = c;\n    res -= 0.9*CFL*(20.*D4(c)+(D4(uu)+D4(dd)+D4(ll)+D4(rr))+2.0*(D4(ul)+D4(ur)+D4(dl)+D4(dr))-8.0*(D4(u)+D4(d)+D4(l)+D4(r)));\n    res -= 0.9*CFL*((1./12.)*(Fx(ll)-Fx(rr))-(2./3.)*(Fx(l)-Fx(r)));\n    res -= 0.9*CFL*((1./12.)*(Fy(dd)-Fy(uu))-(2./3.)*(Fy(d)-Fy(u)));\n    \n    res += 0.9*CFL*((-1./12.)*(D2(ll)+D2(rr)+D2(uu)+D2(dd))+(4./3.)*(D2(l)+D2(r)+D2(u)+D2(d))-(5.)*D2(c));\n    \n    \n    \n    res.z -= 0.9*CFL*0.0001*c.w/(c.x+0.001);\n    //res.z -= 0.9*CFL*0.0001*c.x;\n    \n    \n    vec4 map = texelFetch(iChannel2,p,0);\n    if(map.x>0.5){\n        //res.x -= 0.5*(res.x-1.0);\n        res.y *= 0.;\n        res.z *= 0.;\n        //res.w = min(1.0,max(0.,res.w));\n    }\n    \n    fragColor = res;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 uu = texture(iChannel0,uv+vec2(0.,2.)/iResolution.xy);\n    vec4 u = texture(iChannel0,uv+vec2(0.,1.)/iResolution.xy);\n    vec4 c = texture(iChannel0,uv+vec2(0.,0.)/iResolution.xy);\n    vec4 d = texture(iChannel0,uv+vec2(0.,-1.)/iResolution.xy);\n    vec4 dd = texture(iChannel0,uv+vec2(0.,-2.)/iResolution.xy);\n    vec4 ll = texture(iChannel0,uv+vec2(-2.,0.)/iResolution.xy);\n    vec4 l = texture(iChannel0,uv+vec2(-1.,0.)/iResolution.xy);\n    vec4 r = texture(iChannel0,uv+vec2(1.,0.)/iResolution.xy);\n    vec4 rr = texture(iChannel0,uv+vec2(2.,0.)/iResolution.xy);\n    vec4 ul = texture(iChannel0,uv+vec2(-1.,1.)/iResolution.xy);\n    vec4 ur = texture(iChannel0,uv+vec2(1.,1.)/iResolution.xy);\n    vec4 dl = texture(iChannel0,uv+vec2(-1.,-1.)/iResolution.xy);\n    vec4 dr = texture(iChannel0,uv+vec2(1.,-1.)/iResolution.xy);\n    \n    vec4 res = texelFetch(iChannel1,p,0);\n    res -= CFL*(20.*D4(c)+(D4(uu)+D4(dd)+D4(ll)+D4(rr))+2.0*(D4(ul)+D4(ur)+D4(dl)+D4(dr))-8.0*(D4(u)+D4(d)+D4(l)+D4(r)));\n    res -= CFL*((1./12.)*(Fx(ll)-Fx(rr))-(2./3.)*(Fx(l)-Fx(r)));\n    res -= CFL*((1./12.)*(Fy(dd)-Fy(uu))-(2./3.)*(Fy(d)-Fy(u)));\n    \n    res += CFL*((-1./12.)*(D2(ll)+D2(rr)+D2(uu)+D2(dd))+(4./3.)*(D2(l)+D2(r)+D2(u)+D2(d))-(5.)*D2(c));\n    \n    res.z -= CFL*0.0001*c.w/(c.x+0.001);\n    //res.z -= CFL*0.0001*c.x;\n    \n    vec4 map = texelFetch(iChannel2,p,0);\n    if(iFrame <2){\n        if(map.z>0.5){\n            res.x = 1.0;\n            res.y = 0.0;\n            res.z = 0.0;\n            res.w = 1.0;\n        }\n        else{\n            res.x = 1.0;\n            res.y = 0.0;\n            res.z = 0.0;\n            res.w = 0.0;\n        }\n    }\n    if(map.x>0.5){\n        //res.x -= 0.5*(res.x-1.0);\n        res.y *= 0.;\n        res.z *= 0.;\n        //res.w = min(1.0,max(0.,res.w));\n    }\n\n    fragColor = res;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define biharm 0.01\n#define CFL 0.45\n#define sharpen 0.1\n\n//Flux function x part\nvec4 Fx(vec4 a){\n    vec4 res;\n    res.x = a.y;\n    res.y = a.y*a.y/(a.x+0.001) + 1.0*(a.x-1.);\n    res.z = a.z*a.y/(a.x+0.001);\n    res.w = a.w*a.y/(a.x+0.001);\n    return res;\n}\n//Flux function y part\nvec4 Fy(vec4 a){\n    vec4 res;\n    res.x = a.z;\n    res.y = a.y*a.z/(a.x+0.001);\n    res.z = a.z*a.z/(a.x+0.001) + 1.0*(a.x-1.);\n    res.w = a.w*a.z/(a.x+0.001);\n    return res;\n}\n\n//Flux for Laplacian\nvec4 D2(vec4 a){\n    vec4 res = vec4(0.);\n    res.y = 0.002*a.y/(a.x+0.001);\n    res.z = 0.002*a.z/(a.x+0.001);\n    //Cahn-Hilliard\n    float alpha = a.w/(a.x+0.001);\n    // this should be set to 0.05\n    res.w = 0.00*(alpha-3.0*alpha*alpha+2.0*alpha*alpha*alpha);\n    return res;\n    \n}\n\n//Flux for Harmonic operator \"Laplacian*Laplacian\"\nvec4 D4(vec4 a){\n    vec4 res =vec4(0.);\n    res.x = a.x;\n    res.y = a.y/(a.x+0.001);\n    res.z = a.z/(a.x+0.001);\n    res.w = a.w/(a.x+0.001);\n    return biharm*res;\n}\n", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.x;\n    \n    vec4 res = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    if(iFrame<1){\n        if (fragCoord.x<3.\n         || fragCoord.x>(iResolution.x-3.)\n         || fragCoord.y<3.\n         || fragCoord.y>(iResolution.y-3.)){\n            res.x = 1.0;\n        }\n        \n        if (fragCoord.x>=0.45*(iResolution.x-3.)\n         && fragCoord.x<0.55*(iResolution.x-3.)\n         && fragCoord.y>=0.2*(iResolution.y-3.)\n         && fragCoord.y<1.0*(iResolution.y-3.)){\n            res.z = 1.0;\n        }\n        \n        if (true &&\n            fragCoord.x>=0.7*(iResolution.x-3.)\n         && fragCoord.x<0.8*(iResolution.x-3.)\n         && fragCoord.y>=0.0*(iResolution.y-3.)\n         && fragCoord.y<0.1*(iResolution.y-3.)){\n            res.x = 1.0;\n            res.z = 0.0;\n        }\n    }\n    \n    if(iMouse.z > 0.){\n        vec2 d2 = fragCoord-iMouse.xy;\n        if(dot(d2,d2) < 100.){\n            if(texelFetch(iChannel3,ivec2(37,1),0).y>0.){\n                res.z = 0.0;\n            }else{\n                res.z = 1.0;\n            }\n        }\n    }\n\n    fragColor = vec4(res);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 827]], "test": "untested"}
{"id": "7dfyWf", "name": "dambreak", "author": "Kitesurf_m8s", "description": "khgcf", "tags": ["cahnhilliard"], "likes": 3, "viewed": 201, "published": 3, "date": "1642988428", "time_retrieved": "2024-07-30T17:07:43.016563", "image_code": "// Fork of \"paintdrip\" by Kitesurf_m8s. https://shadertoy.com/view/NdsyD2\n// 2022-01-21 17:13:13\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*(res.x-1.0));\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = (vec3(0.5+1.*(res.w-0.5),0.5+10.*(res.y/res.x),0.5+10.*(res.z/res.x)));\n    \n    vec4 res = texelFetch(iChannel0,p,0);\n    vec3 col = res.w*vec3(0.5+10.*res.yz/res.x,1.0);\n    \n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*res.yz,res.w);\n\n    //vec4 res = texelFetch(iChannel0,p,0);\n    //vec3 col = vec3(0.5+10.*(res.yz),10.*(res.x-1.0));\n    \n    //vec4 res = texelFetch(iChannel1,p,0);\n    //vec3 col = res.xyz;\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    vec4 rr = texelFetch(iChannel0,p+ivec2(2,0),0);\n    vec4 r = texelFetch(iChannel0,p+ivec2(1,0),0);\n    vec4 c = texelFetch(iChannel0,p+ivec2(0,0),0);\n    vec4 l = texelFetch(iChannel0,p+ivec2(-1,0),0);\n    vec4 ll = texelFetch(iChannel0,p+ivec2(-2,0),0);\n    vec4 uu = texelFetch(iChannel0,p+ivec2(0,2),0);\n    vec4 u = texelFetch(iChannel0,p+ivec2(0,1),0);\n    vec4 d = texelFetch(iChannel0,p+ivec2(0,-1),0);\n    vec4 dd = texelFetch(iChannel0,p+ivec2(0,-2),0);\n    vec4 ur = texelFetch(iChannel0,p+ivec2(1,1),0);\n    vec4 dr = texelFetch(iChannel0,p+ivec2(1,-1),0);\n    vec4 ul = texelFetch(iChannel0,p+ivec2(-1,1),0);\n    vec4 dl = texelFetch(iChannel0,p+ivec2(-1,-1),0);\n    \n    vec4 res = c;\n    res -= 0.9*CFL*(20.*D4(c)+(D4(uu)+D4(dd)+D4(ll)+D4(rr))+2.0*(D4(ul)+D4(ur)+D4(dl)+D4(dr))-8.0*(D4(u)+D4(d)+D4(l)+D4(r)));\n    res -= 0.9*CFL*((1./12.)*(Fx(ll)-Fx(rr))-(2./3.)*(Fx(l)-Fx(r)));\n    res -= 0.9*CFL*((1./12.)*(Fy(dd)-Fy(uu))-(2./3.)*(Fy(d)-Fy(u)));\n    \n    res += 0.9*CFL*((-1./12.)*(D2(ll)+D2(rr)+D2(uu)+D2(dd))+(4./3.)*(D2(l)+D2(r)+D2(u)+D2(d))-(5.)*D2(c));\n    \n    \n    \n    res.z -= 0.9*CFL*0.0005*c.w/(c.x+0.001);\n    //res.z -= 0.9*CFL*0.0001*c.x;\n    \n    \n    vec4 map = texelFetch(iChannel2,p,0);\n    if(map.x>0.5){\n        //res.x -= 0.05*(res.x-1.0);\n        res.y = 0.;\n        res.z = 0.;\n        res.w = min(1.0,max(0.,res.w));\n    }\n    \n    fragColor = res;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    ivec2 p = ivec2(fragCoord);\n    \n    vec4 rr = texelFetch(iChannel0,p+ivec2(2,0),0);\n    vec4 r = texelFetch(iChannel0,p+ivec2(1,0),0);\n    vec4 c = texelFetch(iChannel0,p+ivec2(0,0),0);\n    vec4 l = texelFetch(iChannel0,p+ivec2(-1,0),0);\n    vec4 ll = texelFetch(iChannel0,p+ivec2(-2,0),0);\n    vec4 uu = texelFetch(iChannel0,p+ivec2(0,2),0);\n    vec4 u = texelFetch(iChannel0,p+ivec2(0,1),0);\n    vec4 d = texelFetch(iChannel0,p+ivec2(0,-1),0);\n    vec4 dd = texelFetch(iChannel0,p+ivec2(0,-2),0);\n    vec4 ur = texelFetch(iChannel0,p+ivec2(1,1),0);\n    vec4 dr = texelFetch(iChannel0,p+ivec2(1,-1),0);\n    vec4 ul = texelFetch(iChannel0,p+ivec2(-1,1),0);\n    vec4 dl = texelFetch(iChannel0,p+ivec2(-1,-1),0);\n    \n    vec4 res = texelFetch(iChannel1,p,0);\n    res -= CFL*(20.*D4(c)+(D4(uu)+D4(dd)+D4(ll)+D4(rr))+2.0*(D4(ul)+D4(ur)+D4(dl)+D4(dr))-8.0*(D4(u)+D4(d)+D4(l)+D4(r)));\n    res -= CFL*((1./12.)*(Fx(ll)-Fx(rr))-(2./3.)*(Fx(l)-Fx(r)));\n    res -= CFL*((1./12.)*(Fy(dd)-Fy(uu))-(2./3.)*(Fy(d)-Fy(u)));\n    \n    res += CFL*((-1./12.)*(D2(ll)+D2(rr)+D2(uu)+D2(dd))+(4./3.)*(D2(l)+D2(r)+D2(u)+D2(d))-(5.)*D2(c));\n    \n    res.z -= CFL*0.0005*c.w/(c.x+0.001);\n    //res.z -= CFL*0.0001*c.x;\n    \n    vec4 map = texelFetch(iChannel2,p,0);\n    if(iFrame <2){\n        if(map.z>0.5){\n            res.x = 1.0;\n            res.y = 0.0;\n            res.z = 0.0;\n            res.w = 0.7;\n        }\n        else{\n            res.x = 1.0;\n            res.y = 0.0;\n            res.z = 0.0;\n            res.w = 0.0;\n        }\n    }\n    if(map.x>0.5){\n        //res.x -= 0.05*(res.x-1.0);\n        res.y = 0.;\n        res.z = 0.;\n        res.w = min(1.0,max(0.,res.w));\n    }\n\n    fragColor = res;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define biharm 0.01\n#define CFL 0.5\n#define sharpen 0.1\n\n\nvec4 Fx(vec4 a){\n    vec4 res;\n    res.x = a.y;\n    res.y = a.y*a.y/(a.x+0.001) + 1.0*(a.x-1.);\n    res.z = a.z*a.y/(a.x+0.001);\n    res.w = a.w*a.y/(a.x+0.001);\n    return res;\n}\n\nvec4 Fy(vec4 a){\n    vec4 res;\n    res.x = a.z;\n    res.y = a.y*a.z/(a.x+0.001);\n    res.z = a.z*a.z/(a.x+0.001) + 1.0*(a.x-1.);\n    res.w = a.w*a.z/(a.x+0.001);\n    return res;\n}\n\nvec4 D2(vec4 a){\n    vec4 res = vec4(0.);\n    res.y = 0.001*a.y/(a.x+0.001);\n    res.z = 0.001*a.z/(a.x+0.001);\n    float alpha = a.w/(a.x+0.001);\n    res.w = 0.00*(alpha-3.0*alpha*alpha+2.0*alpha*alpha*alpha);\n    return res;\n    \n}\n\nvec4 D4(vec4 a){\n    vec4 res =vec4(0.);\n    res.x = a.x;\n    res.y = a.y/(a.x+0.001);\n    res.z = a.z/(a.x+0.001);\n    res.w = a.w/(a.x+0.001);\n    return biharm*res;\n}\n", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.x;\n    \n    vec4 res = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    if(iFrame<1){\n        if (fragCoord.x<10.\n         || fragCoord.x>(iResolution.x-10.)\n         || fragCoord.y<10.\n         || fragCoord.y>(iResolution.y-10.)){\n            res.x = 1.0;\n        }\n        if (false &&\n            fragCoord.x>=0.7*(iResolution.x-3.)\n         && fragCoord.x<0.8*(iResolution.x-3.)\n         && fragCoord.y>=0.5*(iResolution.y-3.)\n         && fragCoord.y<0.6*(iResolution.y-3.)){\n            res.x = 1.0;\n        }\n        \n        if (fragCoord.x>=0.0*(iResolution.x-3.)\n         && fragCoord.x<0.6*(iResolution.x-3.)\n         && fragCoord.y>=0.0*(iResolution.y-3.)\n         && fragCoord.y<0.5*(iResolution.y-3.)){\n            res.z = 1.0;\n        }\n    }\n    \n    if(iMouse.z > 0.){\n        vec2 d2 = fragCoord-iMouse.xy;\n        if(dot(d2,d2) < 100.){\n            if(texelFetch(iChannel3,ivec2(37,1),0).y>0.){\n                res.z = 0.0;\n            }else{\n                res.z = 1.0;\n            }\n        }\n    }\n\n    fragColor = vec4(res);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 826]], "test": "untested"}
{"id": "7dSyzR", "name": "Metabols", "author": "aferriss", "description": "particles? Metaballs?", "tags": ["metaballs", "particles", "aa", "smoothstep", "poof", "softedge"], "likes": 9, "viewed": 283, "published": 3, "date": "1642987360", "time_retrieved": "2024-07-30T17:07:43.785385", "image_code": "\n#define n 3.0\n\nfloat random (float i){\n return fract(sin(i*43.0)*4790.234);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 tc = uv;\n    float aspect = iResolution.x / iResolution.y;\n\t\n\n    vec4 c = vec4(0.0);\n    for(float i =1.0; i<n; i++){\n        float r = random(i);\n        float r2 = random(i+n*1.0);\n        float r3 = random(i+n*2.0);\n        float r4 = random(i+n*3.0);\n        float r5 = random(i+n*4.0);\n        \n        //vec2 p = uv - vec2(aspect * 0.5, 0.5) - vec2(sin(iTime * 0.5 + r * 30.0), cos(float(i*10) + iTime * 0.25 + r * 40.0)) * r;\n        vec2 p = uv - vec2(aspect * 0.5, 0.5);\n        \n        float pct = i / n;\n\n        p.x -= sin(pct * 6.28 + iTime * 0.2) * 0.4;\n        p.y -= cos(pct * 6.28 + iTime * 0.2) * 0.4;\n\n        vec4 col = vec4(r2, r3, r4, r5 / dot(p, p) * 2.0);\n        col.rgb *= col.a * col.a;\n        //col.rgb = pow(col.rgb, vec3(1.6));\n        \n        c += col;\n    }\n    \n    c.rgb = normalize(c.rgb);\n\n    fragColor = vec4(c);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 39, 39, 81], [83, 83, 140, 140, 1047]], "test": "untested"}
{"id": "ssByRz", "name": "Convection", "author": "wyatt", "description": "Material point method (uses gaussian interpolation to go between grid and particles) ", "tags": ["mpm"], "likes": 21, "viewed": 412, "published": 3, "date": "1642983506", "time_retrieved": "2024-07-30T17:07:44.566297", "image_code": "// Fork of \"Material Point Method\" by wyatt. https://shadertoy.com/view/fssyDs\n// 2022-01-24 00:02:17\n\nMain\n    \n    vec4 b = B(U);\n    vec4 a = A(b.xy);\n    vec4 d = D(b.xy);\n    vec4 c = C(U);\n    Q = 2.*d*exp(-.5*length(U-a.xy));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define pi 3.14159265359\n\nfloat building(vec2 U) {\n    \n    if (length(U-vec2(.5,.8)*R)<.4*R.x) return 1.;\n    \n    if (length(U-vec2(.5,.2)*R)<.4*R.x) return 1.;\n    \n    return 0.;\n\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-2./R.y*sign(U.y-.5*R.y));\n    \n    for (float x = -2.; x <= 2.; x ++) \n    for (float y = -2.; y <= 2.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 c = C(Q.xy+vec2(x,y));\n        vec4 b = B(Q.xy+vec2(x,y));\n        vec4 dd = D(b.xy+vec2(x,y));\n        f -= .03*c.w*(c.w-.6)*vec2(x,y)/(x*x+y*y);\n        f -= 0.01*c.w*abs(dd.x-d.x)*vec2(x,y)/sqrt(x*x+y*y);\n    }\n    \n    if (length(f)>1.) f = normalize(f);\n    Q.zw = c.xy;\n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.y=1., Q.w *= -1.;\n    if (Q.x<1.) Q.x=1., Q.z *= -1.;\n    if (R.y-Q.y<1.) Q.y=R.y-1., Q.w *= -1.;\n    if (R.x-Q.x<1.) Q.x=R.x-1., Q.z *= -1.;\n\n    if (M.z>0.) Q.zw -= 3e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    vec4 w = vec4(0);\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        vec4 a = A(b.xy);\n        vec4 d = D(b.xy);\n        vec2 v = a.xy-U;\n        vec4 e = 1./(1.+vec4(8,8,0,4)*(x*x+y*y));\n        vec2 u = abs(U+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5) continue;\n        \n        w += e;\n        Q += vec4(a.zw,d.w,1)*e;\n    }\n    if (w.x>0.) Q.xy /= w.x;\n    if (w.y>0.) Q.z /= w.y;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n   vec4 a = A(U);\n   Q = D(U);\n   if (I<1) Q = 1.+sin(1.75+.5*3.1*U.y/R.y+vec4(1,2,3,4)),Q.w=0.;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssByRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdSyRz", "name": "Little Spinny Blobs", "author": "SnoopethDuckDuck", "description": "small little shader, trying to make it 3D but might give up", "tags": ["e"], "likes": 2, "viewed": 204, "published": 3, "date": "1642982101", "time_retrieved": "2024-07-30T17:07:45.460905", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  \n    \n    float time = 0.25 * iTime;\n   // time += thc(40000000., iResolution.y * uv.x);\n    float sc = 2.; //length(uv) * 32.;\n    \n    float r = 0.05;\n    //r += 0.05 * cos(4. * length(uv));\n    float sp = 0.45;\n    float n = 11.;\n    float d = 100.;\n    for (float i = 0.; i < n; i++) {\n        float e = (i/n) * pi;\n        vec2 p = sp * thc(sc, time + e) * vec2(cos(e), sin(e));\n        d = smin(d, length(uv - p));\n    }\n    d -= r;\n   \n    float k = 0.5/iResolution.y;\n    float s = smoothstep(-k, k, -d);\n    \n    vec3 col = vec3(s);\n    \n    fragColor = vec4(col, 1.);\n   // fragColor = vec4( 1. - d/fwidth(d) );\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n// (SdSmoothMin) stolen from here: https://www.shadertoy.com/view/MsfBzB\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 748]], "test": "untested"}
{"id": "ssBcRR", "name": "fork temple v2", "author": "jorge2017a2", "description": "fork temple v2", "tags": ["forktemplev2"], "likes": 10, "viewed": 269, "published": 3, "date": "1642974692", "time_retrieved": "2024-07-30T17:07:46.225860", "image_code": "//----------image\n//por jorge2017a2-\n//referencia\n//https://www.shadertoy.com/view/tsySDw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n    \n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\n\n///https://www.shadertoy.com/view/tsySDw\nfloat sdCylinderY2d(vec3 p, float r)\n{  return length(p.xz)-r;}\nfloat sdCylinderZ2d(vec3 p, float r)\n{  return length(p.xy)-r;}\nfloat sdCylinderX2d(vec3 p, float r)\n{  return length(p.zy)-r;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{ return dot(p, n.xyz) + n.w; }\n\n//Hexagonal Prism - exact---IQ\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3 Copula(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    float d1= sdCylinderZ2d(p, 8.0);\n    float d2= sdCylinderX2d( p, 8.0);\n    float d3= sdCylinderXZ(p-vec3(0.0,3.0,0.0), vec2(15.0,6.0) );\n    float d4 = sdPlane(p-vec3(0.0,-1.0,0.0), vec4(0.0, -1.0, 0.0, 0.0)); \n    float dfin= unionSDF(d1, d2);\n    dfin= differenceSDF(d4,dfin);\n    dfin= intersectSDF(d3,dfin);\n    p.x=abs(p.x)-10.0;\n    p.z=abs(p.z)-8.7;\n    float d5= sdHexPrism( p.xzy-vec3(0.0,0.0,-7.0), vec2(1.5,6.2) );\n    float d6=sdTorus(p, vec2(3.0,0.5) );\n    res =opU3(res, vec3(dfin,8.0,-1.0));\n    res =opU3(res, vec3(d5,-1.0,10.0));\n    res =opU3(res, vec3(d6,4.0,-1.0));\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   \n    p.y=p.y-5.0;\n    p.x= opRep1D(p.x, 25.0 );\n    p.z= opRep1D(p.z, 30.0 );\n    \n    vec3 res2= Copula(p-vec3(0.0,8.0,0.0));\n    res =opU3(res, res2); \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;   \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n        \n    if (id_material==10.0)\n        {   //col=vec3(1.0,0.0,0.0);\n            col=getColor(13);\n            vec3 mat = vec3(0.3, 0.6, 1.0);\n\t\t\tfloat f = smoothstep(0.1, 0.101, mod(length(sin(floor(p.xy*2.0))), 0.3));\n\t\t\tmat = mix(mat, vec3(1.0, 1.0, 1.0), 1.0 - f);\n\t\t\tcol *= mat;\n            return col;\n        }        \n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 linear2srgb(vec3 c) \n{\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;float b = 0.03;\n    float c = 2.43;float d = 0.59;\n    float e = 0.14;return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n    float t1=mod(iTime, 1.0);\n    float t2=mod(iTime, 2.0);\n    \n    if (t1<t2) \n    {   light_pos1= vec3(-10.0*sin(t), 15.0, -10.0*cos(t*2.0) ); light_color1=vec3( 1.0,0.0,0.0 );\n        light_pos2= vec3(10.0*cos(t*0.5), 10.0, -10.0*sin(t*3.0) ); light_color2 =vec3( 0.0,1.0,0.0 ); \n        light_pos1.x= opRep1D(light_pos1.x, 5.0 ); \n        light_pos1.z= opRep1D(light_pos1.z, 10.0 ); \n    } \n    else\n    {    light_pos1= vec3(-10.0, 15.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n         light_pos2= vec3(10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    }\n   vec3 ro=vec3(0.0,7.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[551, 551, 583, 583, 667], [668, 668, 702, 702, 764], [765, 765, 804, 804, 899], [900, 900, 939, 939, 1034], [1035, 1035, 1074, 1074, 1169], [1176, 1176, 1211, 1211, 1235], [1238, 1279, 1317, 1317, 1342], [1343, 1343, 1381, 1381, 1406], [1407, 1407, 1445, 1445, 1470], [1472, 1516, 1563, 1563, 1590], [1591, 1591, 1634, 1634, 1661], [1662, 1662, 1710, 1710, 1738], [1739, 1777, 1813, 1813, 1858], [1859, 1924, 1958, 1958, 2054], [2055, 2055, 2089, 2089, 2180], [2181, 2181, 2215, 2215, 2306], [2307, 2307, 2341, 2341, 2436], [2438, 2438, 2469, 2469, 2499], [2501, 2532, 2568, 2568, 2841], [2844, 2844, 2865, 2865, 3523], [3525, 3525, 3550, 3550, 3859], [3861, 3861, 3885, 3885, 4047], [4049, 4049, 4098, 4098, 4765], [4768, 4768, 4804, 4804, 5049], [5051, 5051, 5088, 5088, 5357], [5359, 5359, 5442, 5442, 6018], [6020, 6020, 6113, 6113, 6243], [6245, 6245, 6277, 6277, 6474], [6476, 6524, 6552, 6552, 6740], [6742, 6742, 6789, 6789, 7345], [7347, 7347, 7440, 7440, 7770], [7772, 7772, 7799, 7799, 7909], [7911, 7911, 7969, 7969, 8021], [8023, 8023, 8046, 8046, 8171], [8173, 8173, 8204, 8204, 8916], [8919, 8919, 8976, 8976, 9928]], "test": "untested"}
{"id": "sdSyzR", "name": "Water Hammer", "author": "wyatt", "description": "Solid and Liquids interacting", "tags": ["jfa"], "likes": 36, "viewed": 575, "published": 3, "date": "1642974437", "time_retrieved": "2024-07-30T17:07:46.996798", "image_code": "// Fork of \"Material Point Method\" by wyatt. https://shadertoy.com/view/fssyDs\n// 2022-01-23 20:24:27\n\nMain\n    \n    vec4 b = B(U);\n    vec4 a = A(b.xy);\n    vec4 d = D(b.xy);\n    vec4 c = C(U);\n    Q = mix(vec4(.8),d,smoothstep(2.,1.,length(U-a.xy)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define pi 3.14159265359\n\nfloat building(vec2 U) {\n    \n    if (U.y<.9*R.y&&abs(U.x-.3*R.x)<25.)\n        return 1.;\n    \n    if (U.x>.5*R.x&&U.y<.8*R.y\n        &&mod(U.x+U.y,6.)<3.)\n        return 1.;\n    return 0.;\n\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-.5/R.y);\n    \n    for (float x = -3.; x <= 3.; x ++) \n    for (float y = -3.; y <= 3.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 c = C(Q.xy+vec2(x,y));\n        vec4 b = B(Q.xy+vec2(x,y));\n        vec4 a = A(b.xy);\n        \n        if (U.x<.5*R.x) {\n            vec2 u = abs(Q.xy+vec2(x,y)-a.xy);\n            if (u.x>.5||u.y>.5)continue;\n            vec2 r = a.xy-Q.xy;\n            float l = length(r);\n            if (l<1.||l>6.) continue;\n            float L = length(U-b.xy);\n            if ((l-L)<.08*L) \n                f += 3e-1*r*(l-L)/l/L/l;\n        }\n        else {\n            f -= .05*c.w*(c.w-2.)*vec2(x,y)/(x*x+y*y);\n        } \n    }\n\n    Q.zw = mix(Q.zw,c.xy,.3);\n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.y=1., Q.w *= -1.;\n    if (Q.x<1.) Q.x=1., Q.z *= -1.;\n    if (R.y-Q.y<1.) Q.y=R.y-1., Q.w *= -1.;\n    if (R.x-Q.x<1.) Q.x=R.x-1., Q.z *= -1.;\n\n    if (M.z>0.&&U.x>.5*R.x) Q.zw -= 3e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1||(U.x<.5*R.x&&U.y<2.)) {\n    \n        Q = vec4(U,0,0);\n        if (U.x>.5*R.x) Q.w = -.2;\n   }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    vec4 w = vec4(0);\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        vec4 a = A(b.xy);\n        vec4 d = D(b.xy);\n        vec2 v = a.xy-U;\n        vec4 e = 1./(1.+vec4(1)*(x*x+y*y));\n        vec2 u = abs(U+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5) continue;\n        \n        w += e;\n        Q += vec4(a.zw,d.w,1)*e;\n    }\n    if (w.x>0.) Q.xy /= w.x;\n    if (w.y>0.) Q.z /= w.y;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n   vec4 a = A(U);\n   Q = D(U);\n   if (I<1) Q = .5+.5*sin(1.8*3.1*U.x/R.x+vec4(1,2,3,4)),Q.w=0.;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftVXz3", "name": "RGB Dithering (genuary2022 2)", "author": "ml", "description": "blue noise dithering. each pixel has an r,g and b value of 0 or 1.", "tags": ["genuary", "genuary2022"], "likes": 4, "viewed": 350, "published": 3, "date": "1642953755", "time_retrieved": "2024-07-30T17:07:47.764745", "image_code": "\n\nfloat threshold(float Y, float t){\n    return Y < t ? 0. : 1.;\n}\n\nvec3 thresholdRgb(vec3 col, vec3 t){\n\n    //float diffR = col.r - t.r; \n    //float diffG = col.g - t.g; \n    //float diffB = col.b - t.b; \n    \n    //if(diffR > 0. && diffG > 0. && diffB > 0.) return vec3(1.);\n    \n    //if(diffR > diffG && diffR > diffB){\n    //    return vec3(threshold(col.r, t.r), 0., 0.);\n    //}else if(diffG > diffR && diffG > diffB){\n    //    return vec3(0., threshold(col.g, t.g), 0.);\n    //}else{\n    //    return vec3(0., 0., threshold(col.b, t.b));\n    //}\n    \n    return vec3(threshold(col.r, t.r), threshold(col.g, t.g), threshold(col.b, t.b));\n}\n\nfloat halfThreshold(float Y){\n    return Y < 0.5 ? 0. : 1.;\n}\n\n\nfloat randomThreshold(float Y, vec2 fragCoord){\n    return Y < hash12(fragCoord) ? 0. : 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    //float n = 30.;\n  \n    //vec2 fc = floor(fragCoord/n*2.)*n/2.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv.x *=iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 imgCol = texture(iChannel0, uv).rgb;\n\n    float Y = luminance(imgCol);\n        \n    vec3 t = texture(iChannel1, fragCoord/1024.).rgb;\n    \n    vec3 outCol = thresholdRgb(imgCol, t);\n    \n    //vec3(threshold(Y, t.r));\n    \n    // Output to screen\n    fragColor = vec4(outCol, 1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//https://stackoverflow.com/a/56678483\n\nfloat sRGBtoLin(float colorChannel) {\n        // Send this function a decimal sRGB gamma encoded color value\n        // between 0.0 and 1.0, and it returns a linearized value.\n\n    if ( colorChannel <= 0.04045 ) {\n        return colorChannel / 12.92;\n    } else {\n        return pow((( colorChannel + 0.055)/1.055),2.4);\n    }\n    \n}\n\nfloat luminance(vec3 col){\n    float Y = (0.2126 * sRGBtoLin(col.r) + 0.7152 * sRGBtoLin(col.g) + 0.0722 * sRGBtoLin(col.b));\n    return Y;\n}\n\nfloat YtoLstar(float Y) {\n     // Send this function a luminance value between 0.0 and 1.0,\n      // and it returns L* which is \"perceptual lightness\"\n\n    if ( Y <= 0.008856)  {\n        return Y * 903.3; \n    } else {\n        return pow(Y,1./3.) * 116. - 16.;\n    }\n    \n\n}\n\nfloat percievedLightness(vec3 col){\n    return YtoLstar(luminance(col));\n}\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 36, 36, 66], [68, 68, 104, 556, 649], [651, 651, 680, 680, 712], [715, 715, 762, 762, 808], [810, 810, 867, 990, 1407]], "test": "untested"}
{"id": "fslyWs", "name": "Caustic LBM", "author": "davidar", "description": "Rendering ndel's lattice Boltzmann implementation with approximate caustics", "tags": ["refraction", "water", "light", "fluid", "caustics", "laplacian", "lbm", "shallow"], "likes": 19, "viewed": 715, "published": 3, "date": "1642937751", "time_retrieved": "2024-07-30T17:07:48.768062", "image_code": "// Approximating caustic intensity with Laplacian of water surface\n// valid for gently curved surfaces\n// https://doi.org/10.1088/2040-8986/aa6c4e\n// https://michaelberryphysics.files.wordpress.com/2013/06/berry497.pdf\n\n#define R iResolution\n\nfloat height(float x, float y) {\n    return texture(iChannel0, vec2(x,y)/iResolution.xy).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x, y = fragCoord.y;\n    float i = 4., z = 200.;\n\n    // view refraction\n    float dx = height(x+i,y) - height(x-i,y);\n    float dy = height(x,y+i) - height(x,y-i);\n    x += 5. * clamp(50. * dx, -1., 1.) + 100. * (x/R.x - 0.5);\n    y += 5. * clamp(50. * dy, -1., 1.) + 100. * (y/R.y - 0.5);\n\n    float laplacian = -3. * height(x, y)\n        + .5 * (height(x+i, y) + height(x, y+i) + height(x-i, y) + height(x, y-i))\n        + .25 * (height(x+i, y+i) + height(x-i, y+i) + height(x-i, y-i) + height(x+i, y-i));\n    vec3 n = vec3(1.2, 1.3, 1.4); // refractive index, with chromatic aberration\n    fragColor.rgb = 1. - (n - 1.) * z * laplacian; // caustic intensity\n    fragColor.rgb *= .3;\n\n    // border\n    fragColor = mix(fragColor, vec4(1), smoothstep(15., 5., x));\n    fragColor = mix(fragColor, vec4(1), smoothstep(15., 5., y));\n    fragColor = mix(fragColor, vec4(1), smoothstep(R.x - 15., R.x - 5., x));\n    fragColor = mix(fragColor, vec4(1), smoothstep(R.y - 15., R.y - 5., y));\n\n    fragColor.rgb *= vec3(.8,.9,1); // water absorption\n    fragColor.rgb += vec3(1, .9, .8) * clamp(10. * (dx + dy), 0., 1.); // reflection\n\n    fragColor = pow(fragColor, vec4(1./2.2)); // gamma\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\n#define G 0.01\n\nfloat fbm( in vec3 x )\n{\n    float H = .5;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        t += a*simplex3d(f*x);\n        f *= 2.0;\n        a *= exp2(-H);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //relaxation time\n    float w = 1.95;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //int LatSizeX = 200;\n    //int LatSizeY = 200;\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy); //if 0, reinitialise\n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        rho += .05 * fbm(vec3(fragCoord/iResolution.x, 0)*8.0+8.0);\n        vx = vy = 0.0;\n        //add a small disk near the entrance\n      //  if( distance(vec2(LatSizeX/2,LatSizeY/2),vec2(ix,iy)) < 10.0 )\n      //      rho = 1.1;\n        float sq_term = (vx*vx+vy*vy);\n        f0 = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        f1 = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        f2 = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        f3 = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        f4 = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        f5 = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        f6 = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        f7 = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        f8 = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        //velocity cap for stability\n        float norm = sqrt(vx*vx+vy*vy);\n        if(norm>0.2)\n        {\n            vx *= 0.2/norm;\n            vy *= 0.2/norm;\n        }\n\n        //mouse motion\n        float t = 1.5 + .0002 * iTime;\n        for(int i = 0; i < 10; i++) {\n            vec2 m = iResolution.xy * fract(vec2(fbm(vec3(t,1,i)), fbm(vec3(1,t,i))) * 2. + .5);\n            if(i == 0 && iMouse.z>0.) m = iMouse.xy;\n            vec2 dx = m/2. - vec2(ix,iy);\n            float h = exp(-dot(dx,dx)/16.);\n            rho = mix(rho, .8, h);\n            w = mix(w, 1., h);\n        }\n\n        float sq_term = (vx*vx+vy*vy);\n        float f0eq = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        float f1eq = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f2eq = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f3eq = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f4eq = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f5eq = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f6eq = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f7eq = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        float f8eq = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = (1.-w) * f0 + w * f0eq;\n        f1 = (1.-w) * f1 + w * f1eq;\n        f2 = (1.-w) * f2 + w * f2eq;\n        f3 = (1.-w) * f3 + w * f3eq;\n        f4 = (1.-w) * f4 + w * f4eq;\n        f5 = (1.-w) * f5 + w * f5eq;\n        f6 = (1.-w) * f6 + w * f6eq;\n        f7 = (1.-w) * f7 + w * f7eq;\n        f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n        //fragColor.rgb = vec3(1.0,0.0,0.0);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n        //fragColor.rgb = vec3(0.0,1.0,0.0);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n        //fragColor.rgb = vec3(0.0,0.0,1.0);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,vx,vy);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright  2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n", "buffer_b_code": "// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/*\nComparison of three bicubic filter kernels. B=Spline, Catmull-Rom and \"recommended\", as described\nin this article: http://http.developer.nvidia.com/GPUGems/gpugems_ch24.html\n\nDone the naive way with 16 samples rather than the smart way of performing bilinear filters. For\nthe fast way to do it, see Dave Hoskins' shader: https://www.shadertoy.com/view/4df3Dn\n\n\n// Mitchell Netravali Reconstruction Filter\n// B = 1,   C = 0   - cubic B-spline\n// B = 1/3, C = 1/3 - recommended\n// B = 0,   C = 1/2 - Catmull-Rom spline\n//\n// ca = {  12 - 9*B - 6*C,  -18 + 12*B + 6*C, 0, 6 - 2*B  } / 6;\n// cb = {  -B - 6*C, 6*B + 30*C, -12*B - 48*C, 8*B + 24*C } / 6;\n*/\n\n//-----------------------------------------------------------------------------------------\n\nconst vec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nconst vec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nconst vec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nconst vec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nconst vec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n        \nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca = RE_A, cb = RE_B;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n#define SAM(a,b) texelFetch(tex, 1 + 2 * (ivec2(i) + ivec2(a,b)), 0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t, vec2 res )\n{\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture_Bicubic(iChannel0, fragCoord/iResolution.xy, iResolution.xy/2.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 275, 275, 336], [338, 338, 395, 395, 1604]], "test": "untested"}
{"id": "NdscDs", "name": "Lightning strikes", "author": "pancakespeople", "description": "Lightning in clouds. Boom, crackle, rumble.", "tags": ["lightning", "storm"], "likes": 11, "viewed": 467, "published": 3, "date": "1642933581", "time_retrieved": "2024-07-30T17:07:49.539001", "image_code": "\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat random(float x) {\n    return fract(sin(28572.0*x+56847.0));\n}\n\nfloat strike(float cycleTime, float strikeTime) {\n    return abs(1.0 / (cycleTime - strikeTime)) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 np = vec2(uv.x, uv.y);\n    float numStrikes = 5.0;\n    float cycle = floor(iTime / 10.0);\n    \n    vec3 col = vec3(0.0);\n    \n    for (float i = 0.0; i < numStrikes; i++) {\n        float radius = length(uv) * fbm(np+(100.0*i)+(100.0*cycle*i)) * 20.0;\n        float strikeTime = random(i+cycle)*8.0+1.0;\n        col += max(abs(0.1 / (radius - 0.25)) * vec3(0.7, 0.8, 1.0) * strike(mod(iTime, 10.0), strikeTime), 0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdscDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 160], [162, 247, 269, 269, 611], [613, 613, 632, 632, 890], [892, 892, 915, 915, 959], [961, 961, 1010, 1010, 1066], [1068, 1068, 1125, 1175, 1725]], "test": "untested"}
{"id": "fslcDs", "name": "easy DoF", "author": "takahiroando", "description": "based on\nhttps://www.youtube.com/watch?v=E0dsqlajCM4\nhttps://www.shadertoy.com/view/WtSfWK", "tags": ["dof"], "likes": 1, "viewed": 184, "published": 3, "date": "1642933075", "time_retrieved": "2024-07-30T17:07:50.580217", "image_code": "float sphere(vec3 p) {\n    return length(p) - 2.0;\n}\n\n\nvec3 repeat(vec3 p) {\n    return mod(p, 8.0) - 4.0;\n}\n\nfloat map(vec3 p) {\n    return sphere(repeat(p));\n    }\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    float hit = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        float d = map(ro);\n        ro += d * rd;\n        if (abs(d) < 0.0001) {\n            hit = 1.0;\n            break;\n        }\n    }\n    return vec4(ro, hit);\n}\n\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(123.45, 678.90))) * 987654.321);\n    }\n   \nvec3 normal(vec3 p) {\n    mat3 m = mat3(p, p, p) - mat3(0.01);\n    return normalize(map(p) - vec3(map(m[0]), map(m[1]), map(m[2])));\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord -  iResolution.xy) / min(iResolution.x, iResolution.y);\n    // time += 0.01 * random()\n    float blur = uv.x > 0.0 ? 0.01 : 0.0;\n    float t = iTime;\n    vec3 ro = vec3(5.0, 0.0, -10.0 * t);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    if (uv.x > 0.0) {\n        float focal_dist = 4.0;\n        vec3 fp = ro + rd * focal_dist;\n        ro.xy += 0.05 * hash(uv);// + iTime);\n        rd = normalize(fp - ro);\n    }\n\n    vec4 hit = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    float col = hit.w > 0.0 ? max(dot(normal(hit.xyz), light), 0.0) : 0.0;\n    //col = hash(uv);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslcDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 52], [55, 55, 76, 76, 108], [110, 110, 129, 129, 165], [167, 167, 200, 200, 423], [425, 425, 446, 446, 519], [524, 524, 545, 545, 662], [665, 665, 722, 772, 1463]], "test": "untested"}
{"id": "fssyDs", "name": "Material Point Method", "author": "wyatt", "description": "Material point method (uses gaussian interpolation to go between grid and particles) ", "tags": ["mpm"], "likes": 51, "viewed": 991, "published": 3, "date": "1642927389", "time_retrieved": "2024-07-30T17:07:51.481807", "image_code": "Main\n    \n    vec4 b = B(U);\n    vec4 a = A(b.xy);\n    vec4 d = D(b.xy);\n    vec4 c = C(U);\n    Q = 2.*d*exp(-1.*length(U-a.xy));\n    Q -= .2*c.wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define pi 3.14159265359\n\nfloat building(vec2 U) {\n    \n    if (length(U-vec2(.8,.5)*R)<.15*R.x) return 1.;\n    \n    if (length(U-vec2(.2,.5)*R)<.15*R.x) return 1.;\n    \n    return 0.;\n\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-1./R.y);\n    \n    for (float x = -3.; x <= 3.; x ++) \n    for (float y = -3.; y <= 3.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 c = C(Q.xy+vec2(x,y));\n        f -= .08*c.w*(c.w-1.)*vec2(x,y)/(x*x+y*y);\n    }\n    \n    if (length(f)>1.) f = normalize(f);\n    Q.zw = mix(Q.zw,c.xy,.5);\n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.y=1., Q.w *= -1.;\n    if (Q.x<1.) Q.x=1., Q.z *= -1.;\n    if (R.y-Q.y<1.) Q.y=R.y-1., Q.w *= -1.;\n    if (R.x-Q.x<1.) Q.x=R.x-1., Q.z *= -1.;\n\n    if (M.z>0.) Q.zw -= 3e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    vec4 w = vec4(0);\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        vec4 a = A(b.xy);\n        vec4 d = D(b.xy);\n        vec2 v = a.xy-U;\n        vec4 e = 1./(1.+vec4(8,8,0,4)*(x*x+y*y));\n        vec2 u = abs(U+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5) continue;\n        \n        w += e;\n        Q += vec4(a.zw,d.w,1)*e;\n    }\n    if (w.x>0.) Q.xy /= w.x;\n    if (w.y>0.) Q.z /= w.y;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n   vec4 a = A(U);\n   Q = D(U);\n   if (I<1) Q = .5+sin(2.*3.1*U.x/R.x+vec4(1,2,3,4)),Q.w=0.;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdfyDs", "name": "Incompressible SPH", "author": "davidar", "description": "Rough implementation of something like ISPH/IISPH on left; vanilla SPH on right. Better volume preservation, but can cause some odd artefacts (probably my fault, not a faithful impl)", "tags": ["fluid", "particles", "poisson", "ca", "sph", "divergence"], "likes": 13, "viewed": 430, "published": 3, "date": "1642902787", "time_retrieved": "2024-07-30T17:07:52.773354", "image_code": "// ISPH: https://doi.org/10.1016/j.cpc.2018.01.005\n// IISPH: https://interactivecomputergraphics.github.io/SPH-Tutorial/slides/02_incompressibility.pdf\n\n//#define DEBUG\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    col = vec4(P.M.x);\n    \n#ifdef DEBUG\n    if(pos.x < .25*R.x) {\n        float divV = P.divV;\n        float d = 100. * divV;\n        if (divV == 0. && P.M.x > 0.) col.b = 1.;\n        if (d > 0.) col.g += abs(d);\n        if (d < 0.) col.r += abs(d);\n    } else if(pos.x < .5*R.x) {\n        float p = -3. * texel(ch1, pos).x;\n        if (p > 0.) col.g += abs(p);\n        if (p < 0.) col.r += abs(p);\n        if (P.divV == 0. && P.M.x > 0.) col.b = 1.;\n    }\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    return 0.05*rho.x*(pow(rho.x/fluid_rho, 2.) - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    vec2 r = R * vec2(.5,1);\n    p = mod(p,r);\n    float bound = -sdBox(p - r*0.5, r*vec2(0.49, 0.49));\n    //return min(bound, .4*R.y);\n    float box = sdBox(Rot(0.*time)*(p - r*vec2(0.5, 0.6)) , r*vec2(0.05, 0.01));\n    float drain = -sdBox(p - r*vec2(0.5, 0.7), r*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    //p = fract(2.*p);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n    float divV; // not a property of the particle, but the centre of the cell the particle is in\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M.x = data.z;\n    P.M.y = 1.;\n    P.divV = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    P.V = clamp(P.V, vec2(-0.5), vec2(0.5));\n    //if(P.M.x == 0.) P.V = vec2(0);\n    return vec4(encode(P.X), encode(P.V), P.M.x, P.divV);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n", "buffer_a_code": "//diffusion amount\n#define dif 1.12\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n*/\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    float divV = 0., divX = 0.;\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -6, 6) range(j, -6, 6)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n        \n        // compute divergence\n        vec2 dx = P0.X - pos;\n        vec2 gradG = G(dx) * dx;\n        divV += P0.M.x * dot(P0.V, gradG); // velocity divergence\n        divX += P0.M.x * dot(dx, gradG); // position divergence\n    }\n    \n    if(bN(pos).z < border_h) divX = 10.; // solid boundary\n    if(divX < 1.7) divV = 0.; // free surface\n    P.divV = divV;\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        P.X = pos;\n        P.V = vec2(0);\n        P.M = vec2(0);\n        if(pos.y < .2*R.y) P.M = vec2(fluid_rho, 1);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by Robert Schuetze - trirop/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/MdSczK\n\n// Pressure solver (density invariance)\n\nfloat rhs(int x,int y){\n    vec2 p = gl_FragCoord.xy+vec2(x,y);\n\tvec4 data = texture(iChannel2,p/iResolution.xy);\n    particle P = getParticle(data, gl_FragCoord.xy);\n    return fluid_rho - P.M.x;\n}\n\n// 1/|x| - like distribution (RHS = right hand side = div(v))\nfloat TwentyStepRHS( void ){\n    float p = 0.;\n    p+=1.*rhs(-19,0);\n    p+=19.*rhs(-18,-1);\n    p+=4.*rhs(-18,0);\n    p+=19.*rhs(-18,1);\n    p+=171.*rhs(-17,-2);\n    p+=72.*rhs(-17,-1);\n    p+=377.*rhs(-17,0);\n    p+=72.*rhs(-17,1);\n    p+=171.*rhs(-17,2);\n    p+=969.*rhs(-16,-3);\n    p+=612.*rhs(-16,-2);\n    p+=3521.*rhs(-16,-1);\n    p+=1360.*rhs(-16,0);\n    p+=3521.*rhs(-16,1);\n    p+=612.*rhs(-16,2);\n    p+=969.*rhs(-16,3);\n    p+=3876.*rhs(-15,-4);\n    p+=3264.*rhs(-15,-3);\n    p+=20587.*rhs(-15,-2);\n    p+=12040.*rhs(-15,-1);\n    p+=34121.*rhs(-15,0);\n    p+=12040.*rhs(-15,1);\n    p+=20587.*rhs(-15,2);\n    p+=3264.*rhs(-15,3);\n    p+=3876.*rhs(-15,4);\n    p+=11628.*rhs(-14,-5);\n    p+=12240.*rhs(-14,-4);\n    p+=84524.*rhs(-14,-3);\n    p+=66432.*rhs(-14,-2);\n    p+=206531.*rhs(-14,-1);\n    p+=111044.*rhs(-14,0);\n    p+=206531.*rhs(-14,1);\n    p+=66432.*rhs(-14,2);\n    p+=84524.*rhs(-14,3);\n    p+=12240.*rhs(-14,4);\n    p+=11628.*rhs(-14,5);\n    p+=27132.*rhs(-13,-6);\n    p+=34272.*rhs(-13,-5);\n    p+=259012.*rhs(-13,-4);\n    p+=256160.*rhs(-13,-3);\n    p+=874636.*rhs(-13,-2);\n    p+=636608.*rhs(-13,-1);\n    p+=1296593.*rhs(-13,0);\n    p+=636608.*rhs(-13,1);\n    p+=874636.*rhs(-13,2);\n    p+=256160.*rhs(-13,3);\n    p+=259012.*rhs(-13,4);\n    p+=34272.*rhs(-13,5);\n    p+=27132.*rhs(-13,6);\n    p+=50388.*rhs(-12,-7);\n    p+=74256.*rhs(-12,-6);\n    p+=614516.*rhs(-12,-5);\n    p+=733376.*rhs(-12,-4);\n    p+=2752228.*rhs(-12,-3);\n    p+=2539344.*rhs(-12,-2);\n    p+=5691972.*rhs(-12,-1);\n    p+=3802112.*rhs(-12,0);\n    p+=5691972.*rhs(-12,1);\n    p+=2539344.*rhs(-12,2);\n    p+=2752228.*rhs(-12,3);\n    p+=733376.*rhs(-12,4);\n    p+=614516.*rhs(-12,5);\n    p+=74256.*rhs(-12,6);\n    p+=50388.*rhs(-12,7);\n    p+=75582.*rhs(-11,-8);\n    p+=127296.*rhs(-11,-7);\n    p+=1155388.*rhs(-11,-6);\n    p+=1616160.*rhs(-11,-5);\n    p+=6672148.*rhs(-11,-4);\n    p+=7480032.*rhs(-11,-3);\n    p+=18513100.*rhs(-11,-2);\n    p+=15789824.*rhs(-11,-1);\n    p+=26001936.*rhs(-11,0);\n    p+=15789824.*rhs(-11,1);\n    p+=18513100.*rhs(-11,2);\n    p+=7480032.*rhs(-11,3);\n    p+=6672148.*rhs(-11,4);\n    p+=1616160.*rhs(-11,5);\n    p+=1155388.*rhs(-11,6);\n    p+=127296.*rhs(-11,7);\n    p+=75582.*rhs(-11,8);\n    p+=92378.*rhs(-10,-9);\n    p+=175032.*rhs(-10,-8);\n    p+=1747226.*rhs(-10,-7);\n    p+=2803840.*rhs(-10,-6);\n    p+=12751388.*rhs(-10,-5);\n    p+=16859024.*rhs(-10,-4);\n    p+=46169052.*rhs(-10,-3);\n    p+=48243200.*rhs(-10,-2);\n    p+=88069168.*rhs(-10,-1);\n    p+=68625984.*rhs(-10,0);\n    p+=88069168.*rhs(-10,1);\n    p+=48243200.*rhs(-10,2);\n    p+=46169052.*rhs(-10,3);\n    p+=16859024.*rhs(-10,4);\n    p+=12751388.*rhs(-10,5);\n    p+=2803840.*rhs(-10,6);\n    p+=1747226.*rhs(-10,7);\n    p+=175032.*rhs(-10,8);\n    p+=92378.*rhs(-10,9);\n    p+=92378.*rhs(-9,-10);\n    p+=194480.*rhs(-9,-9);\n    p+=2144142.*rhs(-9,-8);\n    p+=3882736.*rhs(-9,-7);\n    p+=19495658.*rhs(-9,-6);\n    p+=29726528.*rhs(-9,-5);\n    p+=90216308.*rhs(-9,-4);\n    p+=112093952.*rhs(-9,-3);\n    p+=228013680.*rhs(-9,-2);\n    p+=219617664.*rhs(-9,-1);\n    p+=312737680.*rhs(-9,0);\n    p+=219617664.*rhs(-9,1);\n    p+=228013680.*rhs(-9,2);\n    p+=112093952.*rhs(-9,3);\n    p+=90216308.*rhs(-9,4);\n    p+=29726528.*rhs(-9,5);\n    p+=19495658.*rhs(-9,6);\n    p+=3882736.*rhs(-9,7);\n    p+=2144142.*rhs(-9,8);\n    p+=194480.*rhs(-9,9);\n    p+=92378.*rhs(-9,10);\n    p+=75582.*rhs(-8,-11);\n    p+=175032.*rhs(-8,-10);\n    p+=2144142.*rhs(-8,-9);\n    p+=4324320.*rhs(-8,-8);\n    p+=24056318.*rhs(-8,-7);\n    p+=41569528.*rhs(-8,-6);\n    p+=140048558.*rhs(-8,-5);\n    p+=202185728.*rhs(-8,-4);\n    p+=459561168.*rhs(-8,-3);\n    p+=532099904.*rhs(-8,-2);\n    p+=850585168.*rhs(-8,-1);\n    p+=743089408.*rhs(-8,0);\n    p+=850585168.*rhs(-8,1);\n    p+=532099904.*rhs(-8,2);\n    p+=459561168.*rhs(-8,3);\n    p+=202185728.*rhs(-8,4);\n    p+=140048558.*rhs(-8,5);\n    p+=41569528.*rhs(-8,6);\n    p+=24056318.*rhs(-8,7);\n    p+=4324320.*rhs(-8,8);\n    p+=2144142.*rhs(-8,9);\n    p+=175032.*rhs(-8,10);\n    p+=75582.*rhs(-8,11);\n    p+=50388.*rhs(-7,-12);\n    p+=127296.*rhs(-7,-11);\n    p+=1747226.*rhs(-7,-10);\n    p+=3882736.*rhs(-7,-9);\n    p+=24056318.*rhs(-7,-8);\n    p+=46448688.*rhs(-7,-7);\n    p+=174151978.*rhs(-7,-6);\n    p+=286712448.*rhs(-7,-5);\n    p+=729241528.*rhs(-7,-4);\n    p+=991865088.*rhs(-7,-3);\n    p+=1792109680.*rhs(-7,-2);\n    p+=1907533696.*rhs(-7,-1);\n    p+=2460787216.*rhs(-7,0);\n    p+=1907533696.*rhs(-7,1);\n    p+=1792109680.*rhs(-7,2);\n    p+=991865088.*rhs(-7,3);\n    p+=729241528.*rhs(-7,4);\n    p+=286712448.*rhs(-7,5);\n    p+=174151978.*rhs(-7,6);\n    p+=46448688.*rhs(-7,7);\n    p+=24056318.*rhs(-7,8);\n    p+=3882736.*rhs(-7,9);\n    p+=1747226.*rhs(-7,10);\n    p+=127296.*rhs(-7,11);\n    p+=50388.*rhs(-7,12);\n    p+=27132.*rhs(-6,-13);\n    p+=74256.*rhs(-6,-12);\n    p+=1155388.*rhs(-6,-11);\n    p+=2803840.*rhs(-6,-10);\n    p+=19495658.*rhs(-6,-9);\n    p+=41569528.*rhs(-6,-8);\n    p+=174151978.*rhs(-6,-7);\n    p+=321877248.*rhs(-6,-6);\n    p+=917173928.*rhs(-6,-5);\n    p+=1436202848.*rhs(-6,-4);\n    p+=2939586856.*rhs(-6,-3);\n    p+=3736940032.*rhs(-6,-2);\n    p+=5531327920.*rhs(-6,-1);\n    p+=5284992064.*rhs(-6,0);\n    p+=5531327920.*rhs(-6,1);\n    p+=3736940032.*rhs(-6,2);\n    p+=2939586856.*rhs(-6,3);\n    p+=1436202848.*rhs(-6,4);\n    p+=917173928.*rhs(-6,5);\n    p+=321877248.*rhs(-6,6);\n    p+=174151978.*rhs(-6,7);\n    p+=41569528.*rhs(-6,8);\n    p+=19495658.*rhs(-6,9);\n    p+=2803840.*rhs(-6,10);\n    p+=1155388.*rhs(-6,11);\n    p+=74256.*rhs(-6,12);\n    p+=27132.*rhs(-6,13);\n    p+=11628.*rhs(-5,-14);\n    p+=34272.*rhs(-5,-13);\n    p+=614516.*rhs(-5,-12);\n    p+=1616160.*rhs(-5,-11);\n    p+=12751388.*rhs(-5,-10);\n    p+=29726528.*rhs(-5,-9);\n    p+=140048558.*rhs(-5,-8);\n    p+=286712448.*rhs(-5,-7);\n    p+=917173928.*rhs(-5,-6);\n    p+=1623903168.*rhs(-5,-5);\n    p+=3762860920.*rhs(-5,-4);\n    p+=5593339456.*rhs(-5,-3);\n    p+=9567332872.*rhs(-5,-2);\n    p+=11195845888.*rhs(-5,-1);\n    p+=13625875600.*rhs(-5,0);\n    p+=11195845888.*rhs(-5,1);\n    p+=9567332872.*rhs(-5,2);\n    p+=5593339456.*rhs(-5,3);\n    p+=3762860920.*rhs(-5,4);\n    p+=1623903168.*rhs(-5,5);\n    p+=917173928.*rhs(-5,6);\n    p+=286712448.*rhs(-5,7);\n    p+=140048558.*rhs(-5,8);\n    p+=29726528.*rhs(-5,9);\n    p+=12751388.*rhs(-5,10);\n    p+=1616160.*rhs(-5,11);\n    p+=614516.*rhs(-5,12);\n    p+=34272.*rhs(-5,13);\n    p+=11628.*rhs(-5,14);\n    p+=3876.*rhs(-4,-15);\n    p+=12240.*rhs(-4,-14);\n    p+=259012.*rhs(-4,-13);\n    p+=733376.*rhs(-4,-12);\n    p+=6672148.*rhs(-4,-11);\n    p+=16859024.*rhs(-4,-10);\n    p+=90216308.*rhs(-4,-9);\n    p+=202185728.*rhs(-4,-8);\n    p+=729241528.*rhs(-4,-7);\n    p+=1436202848.*rhs(-4,-6);\n    p+=3762860920.*rhs(-4,-5);\n    p+=6397998208.*rhs(-4,-4);\n    p+=12613706776.*rhs(-4,-3);\n    p+=17743206112.*rhs(-4,-2);\n    p+=25824041560.*rhs(-4,-1);\n    p+=26826818560.*rhs(-4,0);\n    p+=25824041560.*rhs(-4,1);\n    p+=17743206112.*rhs(-4,2);\n    p+=12613706776.*rhs(-4,3);\n    p+=6397998208.*rhs(-4,4);\n    p+=3762860920.*rhs(-4,5);\n    p+=1436202848.*rhs(-4,6);\n    p+=729241528.*rhs(-4,7);\n    p+=202185728.*rhs(-4,8);\n    p+=90216308.*rhs(-4,9);\n    p+=16859024.*rhs(-4,10);\n    p+=6672148.*rhs(-4,11);\n    p+=733376.*rhs(-4,12);\n    p+=259012.*rhs(-4,13);\n    p+=12240.*rhs(-4,14);\n    p+=3876.*rhs(-4,15);\n    p+=969.*rhs(-3,-16);\n    p+=3264.*rhs(-3,-15);\n    p+=84524.*rhs(-3,-14);\n    p+=256160.*rhs(-3,-13);\n    p+=2752228.*rhs(-3,-12);\n    p+=7480032.*rhs(-3,-11);\n    p+=46169052.*rhs(-3,-10);\n    p+=112093952.*rhs(-3,-9);\n    p+=459561168.*rhs(-3,-8);\n    p+=991865088.*rhs(-3,-7);\n    p+=2939586856.*rhs(-3,-6);\n    p+=5593339456.*rhs(-3,-5);\n    p+=12613706776.*rhs(-3,-4);\n    p+=20720283328.*rhs(-3,-3);\n    p+=35988002440.*rhs(-3,-2);\n    p+=47530295680.*rhs(-3,-1);\n    p+=57901756420.*rhs(-3,0);\n    p+=47530295680.*rhs(-3,1);\n    p+=35988002440.*rhs(-3,2);\n    p+=20720283328.*rhs(-3,3);\n    p+=12613706776.*rhs(-3,4);\n    p+=5593339456.*rhs(-3,5);\n    p+=2939586856.*rhs(-3,6);\n    p+=991865088.*rhs(-3,7);\n    p+=459561168.*rhs(-3,8);\n    p+=112093952.*rhs(-3,9);\n    p+=46169052.*rhs(-3,10);\n    p+=7480032.*rhs(-3,11);\n    p+=2752228.*rhs(-3,12);\n    p+=256160.*rhs(-3,13);\n    p+=84524.*rhs(-3,14);\n    p+=3264.*rhs(-3,15);\n    p+=969.*rhs(-3,16);\n    p+=171.*rhs(-2,-17);\n    p+=612.*rhs(-2,-16);\n    p+=20587.*rhs(-2,-15);\n    p+=66432.*rhs(-2,-14);\n    p+=874636.*rhs(-2,-13);\n    p+=2539344.*rhs(-2,-12);\n    p+=18513100.*rhs(-2,-11);\n    p+=48243200.*rhs(-2,-10);\n    p+=228013680.*rhs(-2,-9);\n    p+=532099904.*rhs(-2,-8);\n    p+=1792109680.*rhs(-2,-7);\n    p+=3736940032.*rhs(-2,-6);\n    p+=9567332872.*rhs(-2,-5);\n    p+=17743206112.*rhs(-2,-4);\n    p+=35988002440.*rhs(-2,-3);\n    p+=57958224640.*rhs(-2,-2);\n    p+=91565303500.*rhs(-2,-1);\n    p+=109719615760.*rhs(-2,0);\n    p+=91565303500.*rhs(-2,1);\n    p+=57958224640.*rhs(-2,2);\n    p+=35988002440.*rhs(-2,3);\n    p+=17743206112.*rhs(-2,4);\n    p+=9567332872.*rhs(-2,5);\n    p+=3736940032.*rhs(-2,6);\n    p+=1792109680.*rhs(-2,7);\n    p+=532099904.*rhs(-2,8);\n    p+=228013680.*rhs(-2,9);\n    p+=48243200.*rhs(-2,10);\n    p+=18513100.*rhs(-2,11);\n    p+=2539344.*rhs(-2,12);\n    p+=874636.*rhs(-2,13);\n    p+=66432.*rhs(-2,14);\n    p+=20587.*rhs(-2,15);\n    p+=612.*rhs(-2,16);\n    p+=171.*rhs(-2,17);\n    p+=19.*rhs(-1,-18);\n    p+=72.*rhs(-1,-17);\n    p+=3521.*rhs(-1,-16);\n    p+=12040.*rhs(-1,-15);\n    p+=206531.*rhs(-1,-14);\n    p+=636608.*rhs(-1,-13);\n    p+=5691972.*rhs(-1,-12);\n    p+=15789824.*rhs(-1,-11);\n    p+=88069168.*rhs(-1,-10);\n    p+=219617664.*rhs(-1,-9);\n    p+=850585168.*rhs(-1,-8);\n    p+=1907533696.*rhs(-1,-7);\n    p+=5531327920.*rhs(-1,-6);\n    p+=11195845888.*rhs(-1,-5);\n    p+=25824041560.*rhs(-1,-4);\n    p+=47530295680.*rhs(-1,-3);\n    p+=91565303500.*rhs(-1,-2);\n    p+=151053077920.*rhs(-1,-1);\n    p+=226056661220.*rhs(-1,0);\n    p+=151053077920.*rhs(-1,1);\n    p+=91565303500.*rhs(-1,2);\n    p+=47530295680.*rhs(-1,3);\n    p+=25824041560.*rhs(-1,4);\n    p+=11195845888.*rhs(-1,5);\n    p+=5531327920.*rhs(-1,6);\n    p+=1907533696.*rhs(-1,7);\n    p+=850585168.*rhs(-1,8);\n    p+=219617664.*rhs(-1,9);\n    p+=88069168.*rhs(-1,10);\n    p+=15789824.*rhs(-1,11);\n    p+=5691972.*rhs(-1,12);\n    p+=636608.*rhs(-1,13);\n    p+=206531.*rhs(-1,14);\n    p+=12040.*rhs(-1,15);\n    p+=3521.*rhs(-1,16);\n    p+=72.*rhs(-1,17);\n    p+=19.*rhs(-1,18);\n    p+=1.*rhs(0,-19);\n    p+=4.*rhs(0,-18);\n    p+=377.*rhs(0,-17);\n    p+=1360.*rhs(0,-16);\n    p+=34121.*rhs(0,-15);\n    p+=111044.*rhs(0,-14);\n    p+=1296593.*rhs(0,-13);\n    p+=3802112.*rhs(0,-12);\n    p+=26001936.*rhs(0,-11);\n    p+=68625984.*rhs(0,-10);\n    p+=312737680.*rhs(0,-9);\n    p+=743089408.*rhs(0,-8);\n    p+=2460787216.*rhs(0,-7);\n    p+=5284992064.*rhs(0,-6);\n    p+=13625875600.*rhs(0,-5);\n    p+=26826818560.*rhs(0,-4);\n    p+=57901756420.*rhs(0,-3);\n    p+=109719615760.*rhs(0,-2);\n    p+=226056661220.*rhs(0,-1);\n    p+=492400873280.*rhs(0,0);\n    p+=226056661220.*rhs(0,1);\n    p+=109719615760.*rhs(0,2);\n    p+=57901756420.*rhs(0,3);\n    p+=26826818560.*rhs(0,4);\n    p+=13625875600.*rhs(0,5);\n    p+=5284992064.*rhs(0,6);\n    p+=2460787216.*rhs(0,7);\n    p+=743089408.*rhs(0,8);\n    p+=312737680.*rhs(0,9);\n    p+=68625984.*rhs(0,10);\n    p+=26001936.*rhs(0,11);\n    p+=3802112.*rhs(0,12);\n    p+=1296593.*rhs(0,13);\n    p+=111044.*rhs(0,14);\n    p+=34121.*rhs(0,15);\n    p+=1360.*rhs(0,16);\n    p+=377.*rhs(0,17);\n    p+=4.*rhs(0,18);\n    p+=1.*rhs(0,19);\n    p+=19.*rhs(1,-18);\n    p+=72.*rhs(1,-17);\n    p+=3521.*rhs(1,-16);\n    p+=12040.*rhs(1,-15);\n    p+=206531.*rhs(1,-14);\n    p+=636608.*rhs(1,-13);\n    p+=5691972.*rhs(1,-12);\n    p+=15789824.*rhs(1,-11);\n    p+=88069168.*rhs(1,-10);\n    p+=219617664.*rhs(1,-9);\n    p+=850585168.*rhs(1,-8);\n    p+=1907533696.*rhs(1,-7);\n    p+=5531327920.*rhs(1,-6);\n    p+=11195845888.*rhs(1,-5);\n    p+=25824041560.*rhs(1,-4);\n    p+=47530295680.*rhs(1,-3);\n    p+=91565303500.*rhs(1,-2);\n    p+=151053077920.*rhs(1,-1);\n    p+=226056661220.*rhs(1,0);\n    p+=151053077920.*rhs(1,1);\n    p+=91565303500.*rhs(1,2);\n    p+=47530295680.*rhs(1,3);\n    p+=25824041560.*rhs(1,4);\n    p+=11195845888.*rhs(1,5);\n    p+=5531327920.*rhs(1,6);\n    p+=1907533696.*rhs(1,7);\n    p+=850585168.*rhs(1,8);\n    p+=219617664.*rhs(1,9);\n    p+=88069168.*rhs(1,10);\n    p+=15789824.*rhs(1,11);\n    p+=5691972.*rhs(1,12);\n    p+=636608.*rhs(1,13);\n    p+=206531.*rhs(1,14);\n    p+=12040.*rhs(1,15);\n    p+=3521.*rhs(1,16);\n    p+=72.*rhs(1,17);\n    p+=19.*rhs(1,18);\n    p+=171.*rhs(2,-17);\n    p+=612.*rhs(2,-16);\n    p+=20587.*rhs(2,-15);\n    p+=66432.*rhs(2,-14);\n    p+=874636.*rhs(2,-13);\n    p+=2539344.*rhs(2,-12);\n    p+=18513100.*rhs(2,-11);\n    p+=48243200.*rhs(2,-10);\n    p+=228013680.*rhs(2,-9);\n    p+=532099904.*rhs(2,-8);\n    p+=1792109680.*rhs(2,-7);\n    p+=3736940032.*rhs(2,-6);\n    p+=9567332872.*rhs(2,-5);\n    p+=17743206112.*rhs(2,-4);\n    p+=35988002440.*rhs(2,-3);\n    p+=57958224640.*rhs(2,-2);\n    p+=91565303500.*rhs(2,-1);\n    p+=109719615760.*rhs(2,0);\n    p+=91565303500.*rhs(2,1);\n    p+=57958224640.*rhs(2,2);\n    p+=35988002440.*rhs(2,3);\n    p+=17743206112.*rhs(2,4);\n    p+=9567332872.*rhs(2,5);\n    p+=3736940032.*rhs(2,6);\n    p+=1792109680.*rhs(2,7);\n    p+=532099904.*rhs(2,8);\n    p+=228013680.*rhs(2,9);\n    p+=48243200.*rhs(2,10);\n    p+=18513100.*rhs(2,11);\n    p+=2539344.*rhs(2,12);\n    p+=874636.*rhs(2,13);\n    p+=66432.*rhs(2,14);\n    p+=20587.*rhs(2,15);\n    p+=612.*rhs(2,16);\n    p+=171.*rhs(2,17);\n    p+=969.*rhs(3,-16);\n    p+=3264.*rhs(3,-15);\n    p+=84524.*rhs(3,-14);\n    p+=256160.*rhs(3,-13);\n    p+=2752228.*rhs(3,-12);\n    p+=7480032.*rhs(3,-11);\n    p+=46169052.*rhs(3,-10);\n    p+=112093952.*rhs(3,-9);\n    p+=459561168.*rhs(3,-8);\n    p+=991865088.*rhs(3,-7);\n    p+=2939586856.*rhs(3,-6);\n    p+=5593339456.*rhs(3,-5);\n    p+=12613706776.*rhs(3,-4);\n    p+=20720283328.*rhs(3,-3);\n    p+=35988002440.*rhs(3,-2);\n    p+=47530295680.*rhs(3,-1);\n    p+=57901756420.*rhs(3,0);\n    p+=47530295680.*rhs(3,1);\n    p+=35988002440.*rhs(3,2);\n    p+=20720283328.*rhs(3,3);\n    p+=12613706776.*rhs(3,4);\n    p+=5593339456.*rhs(3,5);\n    p+=2939586856.*rhs(3,6);\n    p+=991865088.*rhs(3,7);\n    p+=459561168.*rhs(3,8);\n    p+=112093952.*rhs(3,9);\n    p+=46169052.*rhs(3,10);\n    p+=7480032.*rhs(3,11);\n    p+=2752228.*rhs(3,12);\n    p+=256160.*rhs(3,13);\n    p+=84524.*rhs(3,14);\n    p+=3264.*rhs(3,15);\n    p+=969.*rhs(3,16);\n    p+=3876.*rhs(4,-15);\n    p+=12240.*rhs(4,-14);\n    p+=259012.*rhs(4,-13);\n    p+=733376.*rhs(4,-12);\n    p+=6672148.*rhs(4,-11);\n    p+=16859024.*rhs(4,-10);\n    p+=90216308.*rhs(4,-9);\n    p+=202185728.*rhs(4,-8);\n    p+=729241528.*rhs(4,-7);\n    p+=1436202848.*rhs(4,-6);\n    p+=3762860920.*rhs(4,-5);\n    p+=6397998208.*rhs(4,-4);\n    p+=12613706776.*rhs(4,-3);\n    p+=17743206112.*rhs(4,-2);\n    p+=25824041560.*rhs(4,-1);\n    p+=26826818560.*rhs(4,0);\n    p+=25824041560.*rhs(4,1);\n    p+=17743206112.*rhs(4,2);\n    p+=12613706776.*rhs(4,3);\n    p+=6397998208.*rhs(4,4);\n    p+=3762860920.*rhs(4,5);\n    p+=1436202848.*rhs(4,6);\n    p+=729241528.*rhs(4,7);\n    p+=202185728.*rhs(4,8);\n    p+=90216308.*rhs(4,9);\n    p+=16859024.*rhs(4,10);\n    p+=6672148.*rhs(4,11);\n    p+=733376.*rhs(4,12);\n    p+=259012.*rhs(4,13);\n    p+=12240.*rhs(4,14);\n    p+=3876.*rhs(4,15);\n    p+=11628.*rhs(5,-14);\n    p+=34272.*rhs(5,-13);\n    p+=614516.*rhs(5,-12);\n    p+=1616160.*rhs(5,-11);\n    p+=12751388.*rhs(5,-10);\n    p+=29726528.*rhs(5,-9);\n    p+=140048558.*rhs(5,-8);\n    p+=286712448.*rhs(5,-7);\n    p+=917173928.*rhs(5,-6);\n    p+=1623903168.*rhs(5,-5);\n    p+=3762860920.*rhs(5,-4);\n    p+=5593339456.*rhs(5,-3);\n    p+=9567332872.*rhs(5,-2);\n    p+=11195845888.*rhs(5,-1);\n    p+=13625875600.*rhs(5,0);\n    p+=11195845888.*rhs(5,1);\n    p+=9567332872.*rhs(5,2);\n    p+=5593339456.*rhs(5,3);\n    p+=3762860920.*rhs(5,4);\n    p+=1623903168.*rhs(5,5);\n    p+=917173928.*rhs(5,6);\n    p+=286712448.*rhs(5,7);\n    p+=140048558.*rhs(5,8);\n    p+=29726528.*rhs(5,9);\n    p+=12751388.*rhs(5,10);\n    p+=1616160.*rhs(5,11);\n    p+=614516.*rhs(5,12);\n    p+=34272.*rhs(5,13);\n    p+=11628.*rhs(5,14);\n    p+=27132.*rhs(6,-13);\n    p+=74256.*rhs(6,-12);\n    p+=1155388.*rhs(6,-11);\n    p+=2803840.*rhs(6,-10);\n    p+=19495658.*rhs(6,-9);\n    p+=41569528.*rhs(6,-8);\n    p+=174151978.*rhs(6,-7);\n    p+=321877248.*rhs(6,-6);\n    p+=917173928.*rhs(6,-5);\n    p+=1436202848.*rhs(6,-4);\n    p+=2939586856.*rhs(6,-3);\n    p+=3736940032.*rhs(6,-2);\n    p+=5531327920.*rhs(6,-1);\n    p+=5284992064.*rhs(6,0);\n    p+=5531327920.*rhs(6,1);\n    p+=3736940032.*rhs(6,2);\n    p+=2939586856.*rhs(6,3);\n    p+=1436202848.*rhs(6,4);\n    p+=917173928.*rhs(6,5);\n    p+=321877248.*rhs(6,6);\n    p+=174151978.*rhs(6,7);\n    p+=41569528.*rhs(6,8);\n    p+=19495658.*rhs(6,9);\n    p+=2803840.*rhs(6,10);\n    p+=1155388.*rhs(6,11);\n    p+=74256.*rhs(6,12);\n    p+=27132.*rhs(6,13);\n    p+=50388.*rhs(7,-12);\n    p+=127296.*rhs(7,-11);\n    p+=1747226.*rhs(7,-10);\n    p+=3882736.*rhs(7,-9);\n    p+=24056318.*rhs(7,-8);\n    p+=46448688.*rhs(7,-7);\n    p+=174151978.*rhs(7,-6);\n    p+=286712448.*rhs(7,-5);\n    p+=729241528.*rhs(7,-4);\n    p+=991865088.*rhs(7,-3);\n    p+=1792109680.*rhs(7,-2);\n    p+=1907533696.*rhs(7,-1);\n    p+=2460787216.*rhs(7,0);\n    p+=1907533696.*rhs(7,1);\n    p+=1792109680.*rhs(7,2);\n    p+=991865088.*rhs(7,3);\n    p+=729241528.*rhs(7,4);\n    p+=286712448.*rhs(7,5);\n    p+=174151978.*rhs(7,6);\n    p+=46448688.*rhs(7,7);\n    p+=24056318.*rhs(7,8);\n    p+=3882736.*rhs(7,9);\n    p+=1747226.*rhs(7,10);\n    p+=127296.*rhs(7,11);\n    p+=50388.*rhs(7,12);\n    p+=75582.*rhs(8,-11);\n    p+=175032.*rhs(8,-10);\n    p+=2144142.*rhs(8,-9);\n    p+=4324320.*rhs(8,-8);\n    p+=24056318.*rhs(8,-7);\n    p+=41569528.*rhs(8,-6);\n    p+=140048558.*rhs(8,-5);\n    p+=202185728.*rhs(8,-4);\n    p+=459561168.*rhs(8,-3);\n    p+=532099904.*rhs(8,-2);\n    p+=850585168.*rhs(8,-1);\n    p+=743089408.*rhs(8,0);\n    p+=850585168.*rhs(8,1);\n    p+=532099904.*rhs(8,2);\n    p+=459561168.*rhs(8,3);\n    p+=202185728.*rhs(8,4);\n    p+=140048558.*rhs(8,5);\n    p+=41569528.*rhs(8,6);\n    p+=24056318.*rhs(8,7);\n    p+=4324320.*rhs(8,8);\n    p+=2144142.*rhs(8,9);\n    p+=175032.*rhs(8,10);\n    p+=75582.*rhs(8,11);\n    p+=92378.*rhs(9,-10);\n    p+=194480.*rhs(9,-9);\n    p+=2144142.*rhs(9,-8);\n    p+=3882736.*rhs(9,-7);\n    p+=19495658.*rhs(9,-6);\n    p+=29726528.*rhs(9,-5);\n    p+=90216308.*rhs(9,-4);\n    p+=112093952.*rhs(9,-3);\n    p+=228013680.*rhs(9,-2);\n    p+=219617664.*rhs(9,-1);\n    p+=312737680.*rhs(9,0);\n    p+=219617664.*rhs(9,1);\n    p+=228013680.*rhs(9,2);\n    p+=112093952.*rhs(9,3);\n    p+=90216308.*rhs(9,4);\n    p+=29726528.*rhs(9,5);\n    p+=19495658.*rhs(9,6);\n    p+=3882736.*rhs(9,7);\n    p+=2144142.*rhs(9,8);\n    p+=194480.*rhs(9,9);\n    p+=92378.*rhs(9,10);\n    p+=92378.*rhs(10,-9);\n    p+=175032.*rhs(10,-8);\n    p+=1747226.*rhs(10,-7);\n    p+=2803840.*rhs(10,-6);\n    p+=12751388.*rhs(10,-5);\n    p+=16859024.*rhs(10,-4);\n    p+=46169052.*rhs(10,-3);\n    p+=48243200.*rhs(10,-2);\n    p+=88069168.*rhs(10,-1);\n    p+=68625984.*rhs(10,0);\n    p+=88069168.*rhs(10,1);\n    p+=48243200.*rhs(10,2);\n    p+=46169052.*rhs(10,3);\n    p+=16859024.*rhs(10,4);\n    p+=12751388.*rhs(10,5);\n    p+=2803840.*rhs(10,6);\n    p+=1747226.*rhs(10,7);\n    p+=175032.*rhs(10,8);\n    p+=92378.*rhs(10,9);\n    p+=75582.*rhs(11,-8);\n    p+=127296.*rhs(11,-7);\n    p+=1155388.*rhs(11,-6);\n    p+=1616160.*rhs(11,-5);\n    p+=6672148.*rhs(11,-4);\n    p+=7480032.*rhs(11,-3);\n    p+=18513100.*rhs(11,-2);\n    p+=15789824.*rhs(11,-1);\n    p+=26001936.*rhs(11,0);\n    p+=15789824.*rhs(11,1);\n    p+=18513100.*rhs(11,2);\n    p+=7480032.*rhs(11,3);\n    p+=6672148.*rhs(11,4);\n    p+=1616160.*rhs(11,5);\n    p+=1155388.*rhs(11,6);\n    p+=127296.*rhs(11,7);\n    p+=75582.*rhs(11,8);\n    p+=50388.*rhs(12,-7);\n    p+=74256.*rhs(12,-6);\n    p+=614516.*rhs(12,-5);\n    p+=733376.*rhs(12,-4);\n    p+=2752228.*rhs(12,-3);\n    p+=2539344.*rhs(12,-2);\n    p+=5691972.*rhs(12,-1);\n    p+=3802112.*rhs(12,0);\n    p+=5691972.*rhs(12,1);\n    p+=2539344.*rhs(12,2);\n    p+=2752228.*rhs(12,3);\n    p+=733376.*rhs(12,4);\n    p+=614516.*rhs(12,5);\n    p+=74256.*rhs(12,6);\n    p+=50388.*rhs(12,7);\n    p+=27132.*rhs(13,-6);\n    p+=34272.*rhs(13,-5);\n    p+=259012.*rhs(13,-4);\n    p+=256160.*rhs(13,-3);\n    p+=874636.*rhs(13,-2);\n    p+=636608.*rhs(13,-1);\n    p+=1296593.*rhs(13,0);\n    p+=636608.*rhs(13,1);\n    p+=874636.*rhs(13,2);\n    p+=256160.*rhs(13,3);\n    p+=259012.*rhs(13,4);\n    p+=34272.*rhs(13,5);\n    p+=27132.*rhs(13,6);\n    p+=11628.*rhs(14,-5);\n    p+=12240.*rhs(14,-4);\n    p+=84524.*rhs(14,-3);\n    p+=66432.*rhs(14,-2);\n    p+=206531.*rhs(14,-1);\n    p+=111044.*rhs(14,0);\n    p+=206531.*rhs(14,1);\n    p+=66432.*rhs(14,2);\n    p+=84524.*rhs(14,3);\n    p+=12240.*rhs(14,4);\n    p+=11628.*rhs(14,5);\n    p+=3876.*rhs(15,-4);\n    p+=3264.*rhs(15,-3);\n    p+=20587.*rhs(15,-2);\n    p+=12040.*rhs(15,-1);\n    p+=34121.*rhs(15,0);\n    p+=12040.*rhs(15,1);\n    p+=20587.*rhs(15,2);\n    p+=3264.*rhs(15,3);\n    p+=3876.*rhs(15,4);\n    p+=969.*rhs(16,-3);\n    p+=612.*rhs(16,-2);\n    p+=3521.*rhs(16,-1);\n    p+=1360.*rhs(16,0);\n    p+=3521.*rhs(16,1);\n    p+=612.*rhs(16,2);\n    p+=969.*rhs(16,3);\n    p+=171.*rhs(17,-2);\n    p+=72.*rhs(17,-1);\n    p+=377.*rhs(17,0);\n    p+=72.*rhs(17,1);\n    p+=171.*rhs(17,2);\n    p+=19.*rhs(18,-1);\n    p+=4.*rhs(18,0);\n    p+=19.*rhs(18,1);\n    p+=1.*rhs(19,0);\n    return p/1099511627776.;\n}\n\nfloat p0c(int x,int y){\n    vec2 p = gl_FragCoord.xy+vec2(x,y);\n\treturn texture(iChannel1,p/iResolution.xy).x;\n}\n\n// Gaussian - like redistribution of the previously calculated pressure p0c\nfloat TwentyStepPressure( void ){\n    float p = 0.;\n    p+=1.*p0c(-20,0);\n    p+=20.*p0c(-19,-1);\n    p+=20.*p0c(-19,1);\n    p+=190.*p0c(-18,-2);\n    p+=400.*p0c(-18,0);\n    p+=190.*p0c(-18,2);\n    p+=1140.*p0c(-17,-3);\n    p+=3800.*p0c(-17,-1);\n    p+=3800.*p0c(-17,1);\n    p+=1140.*p0c(-17,3);\n    p+=4845.*p0c(-16,-4);\n    p+=22800.*p0c(-16,-2);\n    p+=36100.*p0c(-16,0);\n    p+=22800.*p0c(-16,2);\n    p+=4845.*p0c(-16,4);\n    p+=15504.*p0c(-15,-5);\n    p+=96900.*p0c(-15,-3);\n    p+=216600.*p0c(-15,-1);\n    p+=216600.*p0c(-15,1);\n    p+=96900.*p0c(-15,3);\n    p+=15504.*p0c(-15,5);\n    p+=38760.*p0c(-14,-6);\n    p+=310080.*p0c(-14,-4);\n    p+=920550.*p0c(-14,-2);\n    p+=1299600.*p0c(-14,0);\n    p+=920550.*p0c(-14,2);\n    p+=310080.*p0c(-14,4);\n    p+=38760.*p0c(-14,6);\n    p+=77520.*p0c(-13,-7);\n    p+=775200.*p0c(-13,-5);\n    p+=2945760.*p0c(-13,-3);\n    p+=5523300.*p0c(-13,-1);\n    p+=5523300.*p0c(-13,1);\n    p+=2945760.*p0c(-13,3);\n    p+=775200.*p0c(-13,5);\n    p+=77520.*p0c(-13,7);\n    p+=125970.*p0c(-12,-8);\n    p+=1550400.*p0c(-12,-6);\n    p+=7364400.*p0c(-12,-4);\n    p+=17674560.*p0c(-12,-2);\n    p+=23474025.*p0c(-12,0);\n    p+=17674560.*p0c(-12,2);\n    p+=7364400.*p0c(-12,4);\n    p+=1550400.*p0c(-12,6);\n    p+=125970.*p0c(-12,8);\n    p+=167960.*p0c(-11,-9);\n    p+=2519400.*p0c(-11,-7);\n    p+=14728800.*p0c(-11,-5);\n    p+=44186400.*p0c(-11,-3);\n    p+=75116880.*p0c(-11,-1);\n    p+=75116880.*p0c(-11,1);\n    p+=44186400.*p0c(-11,3);\n    p+=14728800.*p0c(-11,5);\n    p+=2519400.*p0c(-11,7);\n    p+=167960.*p0c(-11,9);\n    p+=184756.*p0c(-10,-10);\n    p+=3359200.*p0c(-10,-8);\n    p+=23934300.*p0c(-10,-6);\n    p+=88372800.*p0c(-10,-4);\n    p+=187792200.*p0c(-10,-2);\n    p+=240374016.*p0c(-10,0);\n    p+=187792200.*p0c(-10,2);\n    p+=88372800.*p0c(-10,4);\n    p+=23934300.*p0c(-10,6);\n    p+=3359200.*p0c(-10,8);\n    p+=184756.*p0c(-10,10);\n    p+=167960.*p0c(-9,-11);\n    p+=3695120.*p0c(-9,-9);\n    p+=31912400.*p0c(-9,-7);\n    p+=143605800.*p0c(-9,-5);\n    p+=375584400.*p0c(-9,-3);\n    p+=600935040.*p0c(-9,-1);\n    p+=600935040.*p0c(-9,1);\n    p+=375584400.*p0c(-9,3);\n    p+=143605800.*p0c(-9,5);\n    p+=31912400.*p0c(-9,7);\n    p+=3695120.*p0c(-9,9);\n    p+=167960.*p0c(-9,11);\n    p+=125970.*p0c(-8,-12);\n    p+=3359200.*p0c(-8,-10);\n    p+=35103640.*p0c(-8,-8);\n    p+=191474400.*p0c(-8,-6);\n    p+=610324650.*p0c(-8,-4);\n    p+=1201870080.*p0c(-8,-2);\n    p+=1502337600.*p0c(-8,0);\n    p+=1201870080.*p0c(-8,2);\n    p+=610324650.*p0c(-8,4);\n    p+=191474400.*p0c(-8,6);\n    p+=35103640.*p0c(-8,8);\n    p+=3359200.*p0c(-8,10);\n    p+=125970.*p0c(-8,12);\n    p+=77520.*p0c(-7,-13);\n    p+=2519400.*p0c(-7,-11);\n    p+=31912400.*p0c(-7,-9);\n    p+=210621840.*p0c(-7,-7);\n    p+=813766200.*p0c(-7,-5);\n    p+=1953038880.*p0c(-7,-3);\n    p+=3004675200.*p0c(-7,-1);\n    p+=3004675200.*p0c(-7,1);\n    p+=1953038880.*p0c(-7,3);\n    p+=813766200.*p0c(-7,5);\n    p+=210621840.*p0c(-7,7);\n    p+=31912400.*p0c(-7,9);\n    p+=2519400.*p0c(-7,11);\n    p+=77520.*p0c(-7,13);\n    p+=38760.*p0c(-6,-14);\n    p+=1550400.*p0c(-6,-12);\n    p+=23934300.*p0c(-6,-10);\n    p+=191474400.*p0c(-6,-8);\n    p+=895142820.*p0c(-6,-6);\n    p+=2604051840.*p0c(-6,-4);\n    p+=4882597200.*p0c(-6,-2);\n    p+=6009350400.*p0c(-6,0);\n    p+=4882597200.*p0c(-6,2);\n    p+=2604051840.*p0c(-6,4);\n    p+=895142820.*p0c(-6,6);\n    p+=191474400.*p0c(-6,8);\n    p+=23934300.*p0c(-6,10);\n    p+=1550400.*p0c(-6,12);\n    p+=38760.*p0c(-6,14);\n    p+=15504.*p0c(-5,-15);\n    p+=775200.*p0c(-5,-13);\n    p+=14728800.*p0c(-5,-11);\n    p+=143605800.*p0c(-5,-9);\n    p+=813766200.*p0c(-5,-7);\n    p+=2864457024.*p0c(-5,-5);\n    p+=6510129600.*p0c(-5,-3);\n    p+=9765194400.*p0c(-5,-1);\n    p+=9765194400.*p0c(-5,1);\n    p+=6510129600.*p0c(-5,3);\n    p+=2864457024.*p0c(-5,5);\n    p+=813766200.*p0c(-5,7);\n    p+=143605800.*p0c(-5,9);\n    p+=14728800.*p0c(-5,11);\n    p+=775200.*p0c(-5,13);\n    p+=15504.*p0c(-5,15);\n    p+=4845.*p0c(-4,-16);\n    p+=310080.*p0c(-4,-14);\n    p+=7364400.*p0c(-4,-12);\n    p+=88372800.*p0c(-4,-10);\n    p+=610324650.*p0c(-4,-8);\n    p+=2604051840.*p0c(-4,-6);\n    p+=7161142560.*p0c(-4,-4);\n    p+=13020259200.*p0c(-4,-2);\n    p+=15868440900.*p0c(-4,0);\n    p+=13020259200.*p0c(-4,2);\n    p+=7161142560.*p0c(-4,4);\n    p+=2604051840.*p0c(-4,6);\n    p+=610324650.*p0c(-4,8);\n    p+=88372800.*p0c(-4,10);\n    p+=7364400.*p0c(-4,12);\n    p+=310080.*p0c(-4,14);\n    p+=4845.*p0c(-4,16);\n    p+=1140.*p0c(-3,-17);\n    p+=96900.*p0c(-3,-15);\n    p+=2945760.*p0c(-3,-13);\n    p+=44186400.*p0c(-3,-11);\n    p+=375584400.*p0c(-3,-9);\n    p+=1953038880.*p0c(-3,-7);\n    p+=6510129600.*p0c(-3,-5);\n    p+=14322285120.*p0c(-3,-3);\n    p+=21157921200.*p0c(-3,-1);\n    p+=21157921200.*p0c(-3,1);\n    p+=14322285120.*p0c(-3,3);\n    p+=6510129600.*p0c(-3,5);\n    p+=1953038880.*p0c(-3,7);\n    p+=375584400.*p0c(-3,9);\n    p+=44186400.*p0c(-3,11);\n    p+=2945760.*p0c(-3,13);\n    p+=96900.*p0c(-3,15);\n    p+=1140.*p0c(-3,17);\n    p+=190.*p0c(-2,-18);\n    p+=22800.*p0c(-2,-16);\n    p+=920550.*p0c(-2,-14);\n    p+=17674560.*p0c(-2,-12);\n    p+=187792200.*p0c(-2,-10);\n    p+=1201870080.*p0c(-2,-8);\n    p+=4882597200.*p0c(-2,-6);\n    p+=13020259200.*p0c(-2,-4);\n    p+=23273713320.*p0c(-2,-2);\n    p+=28210561600.*p0c(-2,0);\n    p+=23273713320.*p0c(-2,2);\n    p+=13020259200.*p0c(-2,4);\n    p+=4882597200.*p0c(-2,6);\n    p+=1201870080.*p0c(-2,8);\n    p+=187792200.*p0c(-2,10);\n    p+=17674560.*p0c(-2,12);\n    p+=920550.*p0c(-2,14);\n    p+=22800.*p0c(-2,16);\n    p+=190.*p0c(-2,18);\n    p+=20.*p0c(-1,-19);\n    p+=3800.*p0c(-1,-17);\n    p+=216600.*p0c(-1,-15);\n    p+=5523300.*p0c(-1,-13);\n    p+=75116880.*p0c(-1,-11);\n    p+=600935040.*p0c(-1,-9);\n    p+=3004675200.*p0c(-1,-7);\n    p+=9765194400.*p0c(-1,-5);\n    p+=21157921200.*p0c(-1,-3);\n    p+=31031617760.*p0c(-1,-1);\n    p+=31031617760.*p0c(-1,1);\n    p+=21157921200.*p0c(-1,3);\n    p+=9765194400.*p0c(-1,5);\n    p+=3004675200.*p0c(-1,7);\n    p+=600935040.*p0c(-1,9);\n    p+=75116880.*p0c(-1,11);\n    p+=5523300.*p0c(-1,13);\n    p+=216600.*p0c(-1,15);\n    p+=3800.*p0c(-1,17);\n    p+=20.*p0c(-1,19);\n    p+=1.*p0c(0,-20);\n    p+=400.*p0c(0,-18);\n    p+=36100.*p0c(0,-16);\n    p+=1299600.*p0c(0,-14);\n    p+=23474025.*p0c(0,-12);\n    p+=240374016.*p0c(0,-10);\n    p+=1502337600.*p0c(0,-8);\n    p+=6009350400.*p0c(0,-6);\n    p+=15868440900.*p0c(0,-4);\n    p+=28210561600.*p0c(0,-2);\n    p+=34134779536.*p0c(0,0);\n    p+=28210561600.*p0c(0,2);\n    p+=15868440900.*p0c(0,4);\n    p+=6009350400.*p0c(0,6);\n    p+=1502337600.*p0c(0,8);\n    p+=240374016.*p0c(0,10);\n    p+=23474025.*p0c(0,12);\n    p+=1299600.*p0c(0,14);\n    p+=36100.*p0c(0,16);\n    p+=400.*p0c(0,18);\n    p+=1.*p0c(0,20);\n    p+=20.*p0c(1,-19);\n    p+=3800.*p0c(1,-17);\n    p+=216600.*p0c(1,-15);\n    p+=5523300.*p0c(1,-13);\n    p+=75116880.*p0c(1,-11);\n    p+=600935040.*p0c(1,-9);\n    p+=3004675200.*p0c(1,-7);\n    p+=9765194400.*p0c(1,-5);\n    p+=21157921200.*p0c(1,-3);\n    p+=31031617760.*p0c(1,-1);\n    p+=31031617760.*p0c(1,1);\n    p+=21157921200.*p0c(1,3);\n    p+=9765194400.*p0c(1,5);\n    p+=3004675200.*p0c(1,7);\n    p+=600935040.*p0c(1,9);\n    p+=75116880.*p0c(1,11);\n    p+=5523300.*p0c(1,13);\n    p+=216600.*p0c(1,15);\n    p+=3800.*p0c(1,17);\n    p+=20.*p0c(1,19);\n    p+=190.*p0c(2,-18);\n    p+=22800.*p0c(2,-16);\n    p+=920550.*p0c(2,-14);\n    p+=17674560.*p0c(2,-12);\n    p+=187792200.*p0c(2,-10);\n    p+=1201870080.*p0c(2,-8);\n    p+=4882597200.*p0c(2,-6);\n    p+=13020259200.*p0c(2,-4);\n    p+=23273713320.*p0c(2,-2);\n    p+=28210561600.*p0c(2,0);\n    p+=23273713320.*p0c(2,2);\n    p+=13020259200.*p0c(2,4);\n    p+=4882597200.*p0c(2,6);\n    p+=1201870080.*p0c(2,8);\n    p+=187792200.*p0c(2,10);\n    p+=17674560.*p0c(2,12);\n    p+=920550.*p0c(2,14);\n    p+=22800.*p0c(2,16);\n    p+=190.*p0c(2,18);\n    p+=1140.*p0c(3,-17);\n    p+=96900.*p0c(3,-15);\n    p+=2945760.*p0c(3,-13);\n    p+=44186400.*p0c(3,-11);\n    p+=375584400.*p0c(3,-9);\n    p+=1953038880.*p0c(3,-7);\n    p+=6510129600.*p0c(3,-5);\n    p+=14322285120.*p0c(3,-3);\n    p+=21157921200.*p0c(3,-1);\n    p+=21157921200.*p0c(3,1);\n    p+=14322285120.*p0c(3,3);\n    p+=6510129600.*p0c(3,5);\n    p+=1953038880.*p0c(3,7);\n    p+=375584400.*p0c(3,9);\n    p+=44186400.*p0c(3,11);\n    p+=2945760.*p0c(3,13);\n    p+=96900.*p0c(3,15);\n    p+=1140.*p0c(3,17);\n    p+=4845.*p0c(4,-16);\n    p+=310080.*p0c(4,-14);\n    p+=7364400.*p0c(4,-12);\n    p+=88372800.*p0c(4,-10);\n    p+=610324650.*p0c(4,-8);\n    p+=2604051840.*p0c(4,-6);\n    p+=7161142560.*p0c(4,-4);\n    p+=13020259200.*p0c(4,-2);\n    p+=15868440900.*p0c(4,0);\n    p+=13020259200.*p0c(4,2);\n    p+=7161142560.*p0c(4,4);\n    p+=2604051840.*p0c(4,6);\n    p+=610324650.*p0c(4,8);\n    p+=88372800.*p0c(4,10);\n    p+=7364400.*p0c(4,12);\n    p+=310080.*p0c(4,14);\n    p+=4845.*p0c(4,16);\n    p+=15504.*p0c(5,-15);\n    p+=775200.*p0c(5,-13);\n    p+=14728800.*p0c(5,-11);\n    p+=143605800.*p0c(5,-9);\n    p+=813766200.*p0c(5,-7);\n    p+=2864457024.*p0c(5,-5);\n    p+=6510129600.*p0c(5,-3);\n    p+=9765194400.*p0c(5,-1);\n    p+=9765194400.*p0c(5,1);\n    p+=6510129600.*p0c(5,3);\n    p+=2864457024.*p0c(5,5);\n    p+=813766200.*p0c(5,7);\n    p+=143605800.*p0c(5,9);\n    p+=14728800.*p0c(5,11);\n    p+=775200.*p0c(5,13);\n    p+=15504.*p0c(5,15);\n    p+=38760.*p0c(6,-14);\n    p+=1550400.*p0c(6,-12);\n    p+=23934300.*p0c(6,-10);\n    p+=191474400.*p0c(6,-8);\n    p+=895142820.*p0c(6,-6);\n    p+=2604051840.*p0c(6,-4);\n    p+=4882597200.*p0c(6,-2);\n    p+=6009350400.*p0c(6,0);\n    p+=4882597200.*p0c(6,2);\n    p+=2604051840.*p0c(6,4);\n    p+=895142820.*p0c(6,6);\n    p+=191474400.*p0c(6,8);\n    p+=23934300.*p0c(6,10);\n    p+=1550400.*p0c(6,12);\n    p+=38760.*p0c(6,14);\n    p+=77520.*p0c(7,-13);\n    p+=2519400.*p0c(7,-11);\n    p+=31912400.*p0c(7,-9);\n    p+=210621840.*p0c(7,-7);\n    p+=813766200.*p0c(7,-5);\n    p+=1953038880.*p0c(7,-3);\n    p+=3004675200.*p0c(7,-1);\n    p+=3004675200.*p0c(7,1);\n    p+=1953038880.*p0c(7,3);\n    p+=813766200.*p0c(7,5);\n    p+=210621840.*p0c(7,7);\n    p+=31912400.*p0c(7,9);\n    p+=2519400.*p0c(7,11);\n    p+=77520.*p0c(7,13);\n    p+=125970.*p0c(8,-12);\n    p+=3359200.*p0c(8,-10);\n    p+=35103640.*p0c(8,-8);\n    p+=191474400.*p0c(8,-6);\n    p+=610324650.*p0c(8,-4);\n    p+=1201870080.*p0c(8,-2);\n    p+=1502337600.*p0c(8,0);\n    p+=1201870080.*p0c(8,2);\n    p+=610324650.*p0c(8,4);\n    p+=191474400.*p0c(8,6);\n    p+=35103640.*p0c(8,8);\n    p+=3359200.*p0c(8,10);\n    p+=125970.*p0c(8,12);\n    p+=167960.*p0c(9,-11);\n    p+=3695120.*p0c(9,-9);\n    p+=31912400.*p0c(9,-7);\n    p+=143605800.*p0c(9,-5);\n    p+=375584400.*p0c(9,-3);\n    p+=600935040.*p0c(9,-1);\n    p+=600935040.*p0c(9,1);\n    p+=375584400.*p0c(9,3);\n    p+=143605800.*p0c(9,5);\n    p+=31912400.*p0c(9,7);\n    p+=3695120.*p0c(9,9);\n    p+=167960.*p0c(9,11);\n    p+=184756.*p0c(10,-10);\n    p+=3359200.*p0c(10,-8);\n    p+=23934300.*p0c(10,-6);\n    p+=88372800.*p0c(10,-4);\n    p+=187792200.*p0c(10,-2);\n    p+=240374016.*p0c(10,0);\n    p+=187792200.*p0c(10,2);\n    p+=88372800.*p0c(10,4);\n    p+=23934300.*p0c(10,6);\n    p+=3359200.*p0c(10,8);\n    p+=184756.*p0c(10,10);\n    p+=167960.*p0c(11,-9);\n    p+=2519400.*p0c(11,-7);\n    p+=14728800.*p0c(11,-5);\n    p+=44186400.*p0c(11,-3);\n    p+=75116880.*p0c(11,-1);\n    p+=75116880.*p0c(11,1);\n    p+=44186400.*p0c(11,3);\n    p+=14728800.*p0c(11,5);\n    p+=2519400.*p0c(11,7);\n    p+=167960.*p0c(11,9);\n    p+=125970.*p0c(12,-8);\n    p+=1550400.*p0c(12,-6);\n    p+=7364400.*p0c(12,-4);\n    p+=17674560.*p0c(12,-2);\n    p+=23474025.*p0c(12,0);\n    p+=17674560.*p0c(12,2);\n    p+=7364400.*p0c(12,4);\n    p+=1550400.*p0c(12,6);\n    p+=125970.*p0c(12,8);\n    p+=77520.*p0c(13,-7);\n    p+=775200.*p0c(13,-5);\n    p+=2945760.*p0c(13,-3);\n    p+=5523300.*p0c(13,-1);\n    p+=5523300.*p0c(13,1);\n    p+=2945760.*p0c(13,3);\n    p+=775200.*p0c(13,5);\n    p+=77520.*p0c(13,7);\n    p+=38760.*p0c(14,-6);\n    p+=310080.*p0c(14,-4);\n    p+=920550.*p0c(14,-2);\n    p+=1299600.*p0c(14,0);\n    p+=920550.*p0c(14,2);\n    p+=310080.*p0c(14,4);\n    p+=38760.*p0c(14,6);\n    p+=15504.*p0c(15,-5);\n    p+=96900.*p0c(15,-3);\n    p+=216600.*p0c(15,-1);\n    p+=216600.*p0c(15,1);\n    p+=96900.*p0c(15,3);\n    p+=15504.*p0c(15,5);\n    p+=4845.*p0c(16,-4);\n    p+=22800.*p0c(16,-2);\n    p+=36100.*p0c(16,0);\n    p+=22800.*p0c(16,2);\n    p+=4845.*p0c(16,4);\n    p+=1140.*p0c(17,-3);\n    p+=3800.*p0c(17,-1);\n    p+=3800.*p0c(17,1);\n    p+=1140.*p0c(17,3);\n    p+=190.*p0c(18,-2);\n    p+=400.*p0c(18,0);\n    p+=190.*p0c(18,2);\n    p+=20.*p0c(19,-1);\n    p+=20.*p0c(19,1);\n    p+=1.*p0c(20,0);\n    return p/1099511627776.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{ \n    if(C.x > .5*iResolution.x) return;\n    vec4 data = texel(ch2, C);\n    particle P = getParticle(data, C);\n    fragColor = vec4(0);\n    \n    if(P.M.x == 0.) return;\n    \n    //float divV = rhs(0,0);\n    //float divX = texel(ch0, C).y;\n    if(P.divV == 0.) return; // free surface\n    \n    float p = TwentyStepRHS()+TwentyStepPressure();\n    //if(C.x < 1. || C.y < 1. || C.x > iResolution.x-1. || C.y > iResolution.y-1.) p = 0.;\n    fragColor = vec4(p,0,0,1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by Robert Schuetze - trirop/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/MdSczK\n\n// Pressure solver (velocity divergence)\n\nfloat rhs(int x,int y){\n    vec2 p = gl_FragCoord.xy+vec2(x,y);\n\tvec4 data = texture(iChannel2,p/iResolution.xy);\n    particle P = getParticle(data, gl_FragCoord.xy);\n    return P.divV;\n}\n\n// 1/|x| - like distribution (RHS = right hand side = div(v))\nfloat TwentyStepRHS( void ){\n    float p = 0.;\n    p+=1.*rhs(-19,0);\n    p+=19.*rhs(-18,-1);\n    p+=4.*rhs(-18,0);\n    p+=19.*rhs(-18,1);\n    p+=171.*rhs(-17,-2);\n    p+=72.*rhs(-17,-1);\n    p+=377.*rhs(-17,0);\n    p+=72.*rhs(-17,1);\n    p+=171.*rhs(-17,2);\n    p+=969.*rhs(-16,-3);\n    p+=612.*rhs(-16,-2);\n    p+=3521.*rhs(-16,-1);\n    p+=1360.*rhs(-16,0);\n    p+=3521.*rhs(-16,1);\n    p+=612.*rhs(-16,2);\n    p+=969.*rhs(-16,3);\n    p+=3876.*rhs(-15,-4);\n    p+=3264.*rhs(-15,-3);\n    p+=20587.*rhs(-15,-2);\n    p+=12040.*rhs(-15,-1);\n    p+=34121.*rhs(-15,0);\n    p+=12040.*rhs(-15,1);\n    p+=20587.*rhs(-15,2);\n    p+=3264.*rhs(-15,3);\n    p+=3876.*rhs(-15,4);\n    p+=11628.*rhs(-14,-5);\n    p+=12240.*rhs(-14,-4);\n    p+=84524.*rhs(-14,-3);\n    p+=66432.*rhs(-14,-2);\n    p+=206531.*rhs(-14,-1);\n    p+=111044.*rhs(-14,0);\n    p+=206531.*rhs(-14,1);\n    p+=66432.*rhs(-14,2);\n    p+=84524.*rhs(-14,3);\n    p+=12240.*rhs(-14,4);\n    p+=11628.*rhs(-14,5);\n    p+=27132.*rhs(-13,-6);\n    p+=34272.*rhs(-13,-5);\n    p+=259012.*rhs(-13,-4);\n    p+=256160.*rhs(-13,-3);\n    p+=874636.*rhs(-13,-2);\n    p+=636608.*rhs(-13,-1);\n    p+=1296593.*rhs(-13,0);\n    p+=636608.*rhs(-13,1);\n    p+=874636.*rhs(-13,2);\n    p+=256160.*rhs(-13,3);\n    p+=259012.*rhs(-13,4);\n    p+=34272.*rhs(-13,5);\n    p+=27132.*rhs(-13,6);\n    p+=50388.*rhs(-12,-7);\n    p+=74256.*rhs(-12,-6);\n    p+=614516.*rhs(-12,-5);\n    p+=733376.*rhs(-12,-4);\n    p+=2752228.*rhs(-12,-3);\n    p+=2539344.*rhs(-12,-2);\n    p+=5691972.*rhs(-12,-1);\n    p+=3802112.*rhs(-12,0);\n    p+=5691972.*rhs(-12,1);\n    p+=2539344.*rhs(-12,2);\n    p+=2752228.*rhs(-12,3);\n    p+=733376.*rhs(-12,4);\n    p+=614516.*rhs(-12,5);\n    p+=74256.*rhs(-12,6);\n    p+=50388.*rhs(-12,7);\n    p+=75582.*rhs(-11,-8);\n    p+=127296.*rhs(-11,-7);\n    p+=1155388.*rhs(-11,-6);\n    p+=1616160.*rhs(-11,-5);\n    p+=6672148.*rhs(-11,-4);\n    p+=7480032.*rhs(-11,-3);\n    p+=18513100.*rhs(-11,-2);\n    p+=15789824.*rhs(-11,-1);\n    p+=26001936.*rhs(-11,0);\n    p+=15789824.*rhs(-11,1);\n    p+=18513100.*rhs(-11,2);\n    p+=7480032.*rhs(-11,3);\n    p+=6672148.*rhs(-11,4);\n    p+=1616160.*rhs(-11,5);\n    p+=1155388.*rhs(-11,6);\n    p+=127296.*rhs(-11,7);\n    p+=75582.*rhs(-11,8);\n    p+=92378.*rhs(-10,-9);\n    p+=175032.*rhs(-10,-8);\n    p+=1747226.*rhs(-10,-7);\n    p+=2803840.*rhs(-10,-6);\n    p+=12751388.*rhs(-10,-5);\n    p+=16859024.*rhs(-10,-4);\n    p+=46169052.*rhs(-10,-3);\n    p+=48243200.*rhs(-10,-2);\n    p+=88069168.*rhs(-10,-1);\n    p+=68625984.*rhs(-10,0);\n    p+=88069168.*rhs(-10,1);\n    p+=48243200.*rhs(-10,2);\n    p+=46169052.*rhs(-10,3);\n    p+=16859024.*rhs(-10,4);\n    p+=12751388.*rhs(-10,5);\n    p+=2803840.*rhs(-10,6);\n    p+=1747226.*rhs(-10,7);\n    p+=175032.*rhs(-10,8);\n    p+=92378.*rhs(-10,9);\n    p+=92378.*rhs(-9,-10);\n    p+=194480.*rhs(-9,-9);\n    p+=2144142.*rhs(-9,-8);\n    p+=3882736.*rhs(-9,-7);\n    p+=19495658.*rhs(-9,-6);\n    p+=29726528.*rhs(-9,-5);\n    p+=90216308.*rhs(-9,-4);\n    p+=112093952.*rhs(-9,-3);\n    p+=228013680.*rhs(-9,-2);\n    p+=219617664.*rhs(-9,-1);\n    p+=312737680.*rhs(-9,0);\n    p+=219617664.*rhs(-9,1);\n    p+=228013680.*rhs(-9,2);\n    p+=112093952.*rhs(-9,3);\n    p+=90216308.*rhs(-9,4);\n    p+=29726528.*rhs(-9,5);\n    p+=19495658.*rhs(-9,6);\n    p+=3882736.*rhs(-9,7);\n    p+=2144142.*rhs(-9,8);\n    p+=194480.*rhs(-9,9);\n    p+=92378.*rhs(-9,10);\n    p+=75582.*rhs(-8,-11);\n    p+=175032.*rhs(-8,-10);\n    p+=2144142.*rhs(-8,-9);\n    p+=4324320.*rhs(-8,-8);\n    p+=24056318.*rhs(-8,-7);\n    p+=41569528.*rhs(-8,-6);\n    p+=140048558.*rhs(-8,-5);\n    p+=202185728.*rhs(-8,-4);\n    p+=459561168.*rhs(-8,-3);\n    p+=532099904.*rhs(-8,-2);\n    p+=850585168.*rhs(-8,-1);\n    p+=743089408.*rhs(-8,0);\n    p+=850585168.*rhs(-8,1);\n    p+=532099904.*rhs(-8,2);\n    p+=459561168.*rhs(-8,3);\n    p+=202185728.*rhs(-8,4);\n    p+=140048558.*rhs(-8,5);\n    p+=41569528.*rhs(-8,6);\n    p+=24056318.*rhs(-8,7);\n    p+=4324320.*rhs(-8,8);\n    p+=2144142.*rhs(-8,9);\n    p+=175032.*rhs(-8,10);\n    p+=75582.*rhs(-8,11);\n    p+=50388.*rhs(-7,-12);\n    p+=127296.*rhs(-7,-11);\n    p+=1747226.*rhs(-7,-10);\n    p+=3882736.*rhs(-7,-9);\n    p+=24056318.*rhs(-7,-8);\n    p+=46448688.*rhs(-7,-7);\n    p+=174151978.*rhs(-7,-6);\n    p+=286712448.*rhs(-7,-5);\n    p+=729241528.*rhs(-7,-4);\n    p+=991865088.*rhs(-7,-3);\n    p+=1792109680.*rhs(-7,-2);\n    p+=1907533696.*rhs(-7,-1);\n    p+=2460787216.*rhs(-7,0);\n    p+=1907533696.*rhs(-7,1);\n    p+=1792109680.*rhs(-7,2);\n    p+=991865088.*rhs(-7,3);\n    p+=729241528.*rhs(-7,4);\n    p+=286712448.*rhs(-7,5);\n    p+=174151978.*rhs(-7,6);\n    p+=46448688.*rhs(-7,7);\n    p+=24056318.*rhs(-7,8);\n    p+=3882736.*rhs(-7,9);\n    p+=1747226.*rhs(-7,10);\n    p+=127296.*rhs(-7,11);\n    p+=50388.*rhs(-7,12);\n    p+=27132.*rhs(-6,-13);\n    p+=74256.*rhs(-6,-12);\n    p+=1155388.*rhs(-6,-11);\n    p+=2803840.*rhs(-6,-10);\n    p+=19495658.*rhs(-6,-9);\n    p+=41569528.*rhs(-6,-8);\n    p+=174151978.*rhs(-6,-7);\n    p+=321877248.*rhs(-6,-6);\n    p+=917173928.*rhs(-6,-5);\n    p+=1436202848.*rhs(-6,-4);\n    p+=2939586856.*rhs(-6,-3);\n    p+=3736940032.*rhs(-6,-2);\n    p+=5531327920.*rhs(-6,-1);\n    p+=5284992064.*rhs(-6,0);\n    p+=5531327920.*rhs(-6,1);\n    p+=3736940032.*rhs(-6,2);\n    p+=2939586856.*rhs(-6,3);\n    p+=1436202848.*rhs(-6,4);\n    p+=917173928.*rhs(-6,5);\n    p+=321877248.*rhs(-6,6);\n    p+=174151978.*rhs(-6,7);\n    p+=41569528.*rhs(-6,8);\n    p+=19495658.*rhs(-6,9);\n    p+=2803840.*rhs(-6,10);\n    p+=1155388.*rhs(-6,11);\n    p+=74256.*rhs(-6,12);\n    p+=27132.*rhs(-6,13);\n    p+=11628.*rhs(-5,-14);\n    p+=34272.*rhs(-5,-13);\n    p+=614516.*rhs(-5,-12);\n    p+=1616160.*rhs(-5,-11);\n    p+=12751388.*rhs(-5,-10);\n    p+=29726528.*rhs(-5,-9);\n    p+=140048558.*rhs(-5,-8);\n    p+=286712448.*rhs(-5,-7);\n    p+=917173928.*rhs(-5,-6);\n    p+=1623903168.*rhs(-5,-5);\n    p+=3762860920.*rhs(-5,-4);\n    p+=5593339456.*rhs(-5,-3);\n    p+=9567332872.*rhs(-5,-2);\n    p+=11195845888.*rhs(-5,-1);\n    p+=13625875600.*rhs(-5,0);\n    p+=11195845888.*rhs(-5,1);\n    p+=9567332872.*rhs(-5,2);\n    p+=5593339456.*rhs(-5,3);\n    p+=3762860920.*rhs(-5,4);\n    p+=1623903168.*rhs(-5,5);\n    p+=917173928.*rhs(-5,6);\n    p+=286712448.*rhs(-5,7);\n    p+=140048558.*rhs(-5,8);\n    p+=29726528.*rhs(-5,9);\n    p+=12751388.*rhs(-5,10);\n    p+=1616160.*rhs(-5,11);\n    p+=614516.*rhs(-5,12);\n    p+=34272.*rhs(-5,13);\n    p+=11628.*rhs(-5,14);\n    p+=3876.*rhs(-4,-15);\n    p+=12240.*rhs(-4,-14);\n    p+=259012.*rhs(-4,-13);\n    p+=733376.*rhs(-4,-12);\n    p+=6672148.*rhs(-4,-11);\n    p+=16859024.*rhs(-4,-10);\n    p+=90216308.*rhs(-4,-9);\n    p+=202185728.*rhs(-4,-8);\n    p+=729241528.*rhs(-4,-7);\n    p+=1436202848.*rhs(-4,-6);\n    p+=3762860920.*rhs(-4,-5);\n    p+=6397998208.*rhs(-4,-4);\n    p+=12613706776.*rhs(-4,-3);\n    p+=17743206112.*rhs(-4,-2);\n    p+=25824041560.*rhs(-4,-1);\n    p+=26826818560.*rhs(-4,0);\n    p+=25824041560.*rhs(-4,1);\n    p+=17743206112.*rhs(-4,2);\n    p+=12613706776.*rhs(-4,3);\n    p+=6397998208.*rhs(-4,4);\n    p+=3762860920.*rhs(-4,5);\n    p+=1436202848.*rhs(-4,6);\n    p+=729241528.*rhs(-4,7);\n    p+=202185728.*rhs(-4,8);\n    p+=90216308.*rhs(-4,9);\n    p+=16859024.*rhs(-4,10);\n    p+=6672148.*rhs(-4,11);\n    p+=733376.*rhs(-4,12);\n    p+=259012.*rhs(-4,13);\n    p+=12240.*rhs(-4,14);\n    p+=3876.*rhs(-4,15);\n    p+=969.*rhs(-3,-16);\n    p+=3264.*rhs(-3,-15);\n    p+=84524.*rhs(-3,-14);\n    p+=256160.*rhs(-3,-13);\n    p+=2752228.*rhs(-3,-12);\n    p+=7480032.*rhs(-3,-11);\n    p+=46169052.*rhs(-3,-10);\n    p+=112093952.*rhs(-3,-9);\n    p+=459561168.*rhs(-3,-8);\n    p+=991865088.*rhs(-3,-7);\n    p+=2939586856.*rhs(-3,-6);\n    p+=5593339456.*rhs(-3,-5);\n    p+=12613706776.*rhs(-3,-4);\n    p+=20720283328.*rhs(-3,-3);\n    p+=35988002440.*rhs(-3,-2);\n    p+=47530295680.*rhs(-3,-1);\n    p+=57901756420.*rhs(-3,0);\n    p+=47530295680.*rhs(-3,1);\n    p+=35988002440.*rhs(-3,2);\n    p+=20720283328.*rhs(-3,3);\n    p+=12613706776.*rhs(-3,4);\n    p+=5593339456.*rhs(-3,5);\n    p+=2939586856.*rhs(-3,6);\n    p+=991865088.*rhs(-3,7);\n    p+=459561168.*rhs(-3,8);\n    p+=112093952.*rhs(-3,9);\n    p+=46169052.*rhs(-3,10);\n    p+=7480032.*rhs(-3,11);\n    p+=2752228.*rhs(-3,12);\n    p+=256160.*rhs(-3,13);\n    p+=84524.*rhs(-3,14);\n    p+=3264.*rhs(-3,15);\n    p+=969.*rhs(-3,16);\n    p+=171.*rhs(-2,-17);\n    p+=612.*rhs(-2,-16);\n    p+=20587.*rhs(-2,-15);\n    p+=66432.*rhs(-2,-14);\n    p+=874636.*rhs(-2,-13);\n    p+=2539344.*rhs(-2,-12);\n    p+=18513100.*rhs(-2,-11);\n    p+=48243200.*rhs(-2,-10);\n    p+=228013680.*rhs(-2,-9);\n    p+=532099904.*rhs(-2,-8);\n    p+=1792109680.*rhs(-2,-7);\n    p+=3736940032.*rhs(-2,-6);\n    p+=9567332872.*rhs(-2,-5);\n    p+=17743206112.*rhs(-2,-4);\n    p+=35988002440.*rhs(-2,-3);\n    p+=57958224640.*rhs(-2,-2);\n    p+=91565303500.*rhs(-2,-1);\n    p+=109719615760.*rhs(-2,0);\n    p+=91565303500.*rhs(-2,1);\n    p+=57958224640.*rhs(-2,2);\n    p+=35988002440.*rhs(-2,3);\n    p+=17743206112.*rhs(-2,4);\n    p+=9567332872.*rhs(-2,5);\n    p+=3736940032.*rhs(-2,6);\n    p+=1792109680.*rhs(-2,7);\n    p+=532099904.*rhs(-2,8);\n    p+=228013680.*rhs(-2,9);\n    p+=48243200.*rhs(-2,10);\n    p+=18513100.*rhs(-2,11);\n    p+=2539344.*rhs(-2,12);\n    p+=874636.*rhs(-2,13);\n    p+=66432.*rhs(-2,14);\n    p+=20587.*rhs(-2,15);\n    p+=612.*rhs(-2,16);\n    p+=171.*rhs(-2,17);\n    p+=19.*rhs(-1,-18);\n    p+=72.*rhs(-1,-17);\n    p+=3521.*rhs(-1,-16);\n    p+=12040.*rhs(-1,-15);\n    p+=206531.*rhs(-1,-14);\n    p+=636608.*rhs(-1,-13);\n    p+=5691972.*rhs(-1,-12);\n    p+=15789824.*rhs(-1,-11);\n    p+=88069168.*rhs(-1,-10);\n    p+=219617664.*rhs(-1,-9);\n    p+=850585168.*rhs(-1,-8);\n    p+=1907533696.*rhs(-1,-7);\n    p+=5531327920.*rhs(-1,-6);\n    p+=11195845888.*rhs(-1,-5);\n    p+=25824041560.*rhs(-1,-4);\n    p+=47530295680.*rhs(-1,-3);\n    p+=91565303500.*rhs(-1,-2);\n    p+=151053077920.*rhs(-1,-1);\n    p+=226056661220.*rhs(-1,0);\n    p+=151053077920.*rhs(-1,1);\n    p+=91565303500.*rhs(-1,2);\n    p+=47530295680.*rhs(-1,3);\n    p+=25824041560.*rhs(-1,4);\n    p+=11195845888.*rhs(-1,5);\n    p+=5531327920.*rhs(-1,6);\n    p+=1907533696.*rhs(-1,7);\n    p+=850585168.*rhs(-1,8);\n    p+=219617664.*rhs(-1,9);\n    p+=88069168.*rhs(-1,10);\n    p+=15789824.*rhs(-1,11);\n    p+=5691972.*rhs(-1,12);\n    p+=636608.*rhs(-1,13);\n    p+=206531.*rhs(-1,14);\n    p+=12040.*rhs(-1,15);\n    p+=3521.*rhs(-1,16);\n    p+=72.*rhs(-1,17);\n    p+=19.*rhs(-1,18);\n    p+=1.*rhs(0,-19);\n    p+=4.*rhs(0,-18);\n    p+=377.*rhs(0,-17);\n    p+=1360.*rhs(0,-16);\n    p+=34121.*rhs(0,-15);\n    p+=111044.*rhs(0,-14);\n    p+=1296593.*rhs(0,-13);\n    p+=3802112.*rhs(0,-12);\n    p+=26001936.*rhs(0,-11);\n    p+=68625984.*rhs(0,-10);\n    p+=312737680.*rhs(0,-9);\n    p+=743089408.*rhs(0,-8);\n    p+=2460787216.*rhs(0,-7);\n    p+=5284992064.*rhs(0,-6);\n    p+=13625875600.*rhs(0,-5);\n    p+=26826818560.*rhs(0,-4);\n    p+=57901756420.*rhs(0,-3);\n    p+=109719615760.*rhs(0,-2);\n    p+=226056661220.*rhs(0,-1);\n    p+=492400873280.*rhs(0,0);\n    p+=226056661220.*rhs(0,1);\n    p+=109719615760.*rhs(0,2);\n    p+=57901756420.*rhs(0,3);\n    p+=26826818560.*rhs(0,4);\n    p+=13625875600.*rhs(0,5);\n    p+=5284992064.*rhs(0,6);\n    p+=2460787216.*rhs(0,7);\n    p+=743089408.*rhs(0,8);\n    p+=312737680.*rhs(0,9);\n    p+=68625984.*rhs(0,10);\n    p+=26001936.*rhs(0,11);\n    p+=3802112.*rhs(0,12);\n    p+=1296593.*rhs(0,13);\n    p+=111044.*rhs(0,14);\n    p+=34121.*rhs(0,15);\n    p+=1360.*rhs(0,16);\n    p+=377.*rhs(0,17);\n    p+=4.*rhs(0,18);\n    p+=1.*rhs(0,19);\n    p+=19.*rhs(1,-18);\n    p+=72.*rhs(1,-17);\n    p+=3521.*rhs(1,-16);\n    p+=12040.*rhs(1,-15);\n    p+=206531.*rhs(1,-14);\n    p+=636608.*rhs(1,-13);\n    p+=5691972.*rhs(1,-12);\n    p+=15789824.*rhs(1,-11);\n    p+=88069168.*rhs(1,-10);\n    p+=219617664.*rhs(1,-9);\n    p+=850585168.*rhs(1,-8);\n    p+=1907533696.*rhs(1,-7);\n    p+=5531327920.*rhs(1,-6);\n    p+=11195845888.*rhs(1,-5);\n    p+=25824041560.*rhs(1,-4);\n    p+=47530295680.*rhs(1,-3);\n    p+=91565303500.*rhs(1,-2);\n    p+=151053077920.*rhs(1,-1);\n    p+=226056661220.*rhs(1,0);\n    p+=151053077920.*rhs(1,1);\n    p+=91565303500.*rhs(1,2);\n    p+=47530295680.*rhs(1,3);\n    p+=25824041560.*rhs(1,4);\n    p+=11195845888.*rhs(1,5);\n    p+=5531327920.*rhs(1,6);\n    p+=1907533696.*rhs(1,7);\n    p+=850585168.*rhs(1,8);\n    p+=219617664.*rhs(1,9);\n    p+=88069168.*rhs(1,10);\n    p+=15789824.*rhs(1,11);\n    p+=5691972.*rhs(1,12);\n    p+=636608.*rhs(1,13);\n    p+=206531.*rhs(1,14);\n    p+=12040.*rhs(1,15);\n    p+=3521.*rhs(1,16);\n    p+=72.*rhs(1,17);\n    p+=19.*rhs(1,18);\n    p+=171.*rhs(2,-17);\n    p+=612.*rhs(2,-16);\n    p+=20587.*rhs(2,-15);\n    p+=66432.*rhs(2,-14);\n    p+=874636.*rhs(2,-13);\n    p+=2539344.*rhs(2,-12);\n    p+=18513100.*rhs(2,-11);\n    p+=48243200.*rhs(2,-10);\n    p+=228013680.*rhs(2,-9);\n    p+=532099904.*rhs(2,-8);\n    p+=1792109680.*rhs(2,-7);\n    p+=3736940032.*rhs(2,-6);\n    p+=9567332872.*rhs(2,-5);\n    p+=17743206112.*rhs(2,-4);\n    p+=35988002440.*rhs(2,-3);\n    p+=57958224640.*rhs(2,-2);\n    p+=91565303500.*rhs(2,-1);\n    p+=109719615760.*rhs(2,0);\n    p+=91565303500.*rhs(2,1);\n    p+=57958224640.*rhs(2,2);\n    p+=35988002440.*rhs(2,3);\n    p+=17743206112.*rhs(2,4);\n    p+=9567332872.*rhs(2,5);\n    p+=3736940032.*rhs(2,6);\n    p+=1792109680.*rhs(2,7);\n    p+=532099904.*rhs(2,8);\n    p+=228013680.*rhs(2,9);\n    p+=48243200.*rhs(2,10);\n    p+=18513100.*rhs(2,11);\n    p+=2539344.*rhs(2,12);\n    p+=874636.*rhs(2,13);\n    p+=66432.*rhs(2,14);\n    p+=20587.*rhs(2,15);\n    p+=612.*rhs(2,16);\n    p+=171.*rhs(2,17);\n    p+=969.*rhs(3,-16);\n    p+=3264.*rhs(3,-15);\n    p+=84524.*rhs(3,-14);\n    p+=256160.*rhs(3,-13);\n    p+=2752228.*rhs(3,-12);\n    p+=7480032.*rhs(3,-11);\n    p+=46169052.*rhs(3,-10);\n    p+=112093952.*rhs(3,-9);\n    p+=459561168.*rhs(3,-8);\n    p+=991865088.*rhs(3,-7);\n    p+=2939586856.*rhs(3,-6);\n    p+=5593339456.*rhs(3,-5);\n    p+=12613706776.*rhs(3,-4);\n    p+=20720283328.*rhs(3,-3);\n    p+=35988002440.*rhs(3,-2);\n    p+=47530295680.*rhs(3,-1);\n    p+=57901756420.*rhs(3,0);\n    p+=47530295680.*rhs(3,1);\n    p+=35988002440.*rhs(3,2);\n    p+=20720283328.*rhs(3,3);\n    p+=12613706776.*rhs(3,4);\n    p+=5593339456.*rhs(3,5);\n    p+=2939586856.*rhs(3,6);\n    p+=991865088.*rhs(3,7);\n    p+=459561168.*rhs(3,8);\n    p+=112093952.*rhs(3,9);\n    p+=46169052.*rhs(3,10);\n    p+=7480032.*rhs(3,11);\n    p+=2752228.*rhs(3,12);\n    p+=256160.*rhs(3,13);\n    p+=84524.*rhs(3,14);\n    p+=3264.*rhs(3,15);\n    p+=969.*rhs(3,16);\n    p+=3876.*rhs(4,-15);\n    p+=12240.*rhs(4,-14);\n    p+=259012.*rhs(4,-13);\n    p+=733376.*rhs(4,-12);\n    p+=6672148.*rhs(4,-11);\n    p+=16859024.*rhs(4,-10);\n    p+=90216308.*rhs(4,-9);\n    p+=202185728.*rhs(4,-8);\n    p+=729241528.*rhs(4,-7);\n    p+=1436202848.*rhs(4,-6);\n    p+=3762860920.*rhs(4,-5);\n    p+=6397998208.*rhs(4,-4);\n    p+=12613706776.*rhs(4,-3);\n    p+=17743206112.*rhs(4,-2);\n    p+=25824041560.*rhs(4,-1);\n    p+=26826818560.*rhs(4,0);\n    p+=25824041560.*rhs(4,1);\n    p+=17743206112.*rhs(4,2);\n    p+=12613706776.*rhs(4,3);\n    p+=6397998208.*rhs(4,4);\n    p+=3762860920.*rhs(4,5);\n    p+=1436202848.*rhs(4,6);\n    p+=729241528.*rhs(4,7);\n    p+=202185728.*rhs(4,8);\n    p+=90216308.*rhs(4,9);\n    p+=16859024.*rhs(4,10);\n    p+=6672148.*rhs(4,11);\n    p+=733376.*rhs(4,12);\n    p+=259012.*rhs(4,13);\n    p+=12240.*rhs(4,14);\n    p+=3876.*rhs(4,15);\n    p+=11628.*rhs(5,-14);\n    p+=34272.*rhs(5,-13);\n    p+=614516.*rhs(5,-12);\n    p+=1616160.*rhs(5,-11);\n    p+=12751388.*rhs(5,-10);\n    p+=29726528.*rhs(5,-9);\n    p+=140048558.*rhs(5,-8);\n    p+=286712448.*rhs(5,-7);\n    p+=917173928.*rhs(5,-6);\n    p+=1623903168.*rhs(5,-5);\n    p+=3762860920.*rhs(5,-4);\n    p+=5593339456.*rhs(5,-3);\n    p+=9567332872.*rhs(5,-2);\n    p+=11195845888.*rhs(5,-1);\n    p+=13625875600.*rhs(5,0);\n    p+=11195845888.*rhs(5,1);\n    p+=9567332872.*rhs(5,2);\n    p+=5593339456.*rhs(5,3);\n    p+=3762860920.*rhs(5,4);\n    p+=1623903168.*rhs(5,5);\n    p+=917173928.*rhs(5,6);\n    p+=286712448.*rhs(5,7);\n    p+=140048558.*rhs(5,8);\n    p+=29726528.*rhs(5,9);\n    p+=12751388.*rhs(5,10);\n    p+=1616160.*rhs(5,11);\n    p+=614516.*rhs(5,12);\n    p+=34272.*rhs(5,13);\n    p+=11628.*rhs(5,14);\n    p+=27132.*rhs(6,-13);\n    p+=74256.*rhs(6,-12);\n    p+=1155388.*rhs(6,-11);\n    p+=2803840.*rhs(6,-10);\n    p+=19495658.*rhs(6,-9);\n    p+=41569528.*rhs(6,-8);\n    p+=174151978.*rhs(6,-7);\n    p+=321877248.*rhs(6,-6);\n    p+=917173928.*rhs(6,-5);\n    p+=1436202848.*rhs(6,-4);\n    p+=2939586856.*rhs(6,-3);\n    p+=3736940032.*rhs(6,-2);\n    p+=5531327920.*rhs(6,-1);\n    p+=5284992064.*rhs(6,0);\n    p+=5531327920.*rhs(6,1);\n    p+=3736940032.*rhs(6,2);\n    p+=2939586856.*rhs(6,3);\n    p+=1436202848.*rhs(6,4);\n    p+=917173928.*rhs(6,5);\n    p+=321877248.*rhs(6,6);\n    p+=174151978.*rhs(6,7);\n    p+=41569528.*rhs(6,8);\n    p+=19495658.*rhs(6,9);\n    p+=2803840.*rhs(6,10);\n    p+=1155388.*rhs(6,11);\n    p+=74256.*rhs(6,12);\n    p+=27132.*rhs(6,13);\n    p+=50388.*rhs(7,-12);\n    p+=127296.*rhs(7,-11);\n    p+=1747226.*rhs(7,-10);\n    p+=3882736.*rhs(7,-9);\n    p+=24056318.*rhs(7,-8);\n    p+=46448688.*rhs(7,-7);\n    p+=174151978.*rhs(7,-6);\n    p+=286712448.*rhs(7,-5);\n    p+=729241528.*rhs(7,-4);\n    p+=991865088.*rhs(7,-3);\n    p+=1792109680.*rhs(7,-2);\n    p+=1907533696.*rhs(7,-1);\n    p+=2460787216.*rhs(7,0);\n    p+=1907533696.*rhs(7,1);\n    p+=1792109680.*rhs(7,2);\n    p+=991865088.*rhs(7,3);\n    p+=729241528.*rhs(7,4);\n    p+=286712448.*rhs(7,5);\n    p+=174151978.*rhs(7,6);\n    p+=46448688.*rhs(7,7);\n    p+=24056318.*rhs(7,8);\n    p+=3882736.*rhs(7,9);\n    p+=1747226.*rhs(7,10);\n    p+=127296.*rhs(7,11);\n    p+=50388.*rhs(7,12);\n    p+=75582.*rhs(8,-11);\n    p+=175032.*rhs(8,-10);\n    p+=2144142.*rhs(8,-9);\n    p+=4324320.*rhs(8,-8);\n    p+=24056318.*rhs(8,-7);\n    p+=41569528.*rhs(8,-6);\n    p+=140048558.*rhs(8,-5);\n    p+=202185728.*rhs(8,-4);\n    p+=459561168.*rhs(8,-3);\n    p+=532099904.*rhs(8,-2);\n    p+=850585168.*rhs(8,-1);\n    p+=743089408.*rhs(8,0);\n    p+=850585168.*rhs(8,1);\n    p+=532099904.*rhs(8,2);\n    p+=459561168.*rhs(8,3);\n    p+=202185728.*rhs(8,4);\n    p+=140048558.*rhs(8,5);\n    p+=41569528.*rhs(8,6);\n    p+=24056318.*rhs(8,7);\n    p+=4324320.*rhs(8,8);\n    p+=2144142.*rhs(8,9);\n    p+=175032.*rhs(8,10);\n    p+=75582.*rhs(8,11);\n    p+=92378.*rhs(9,-10);\n    p+=194480.*rhs(9,-9);\n    p+=2144142.*rhs(9,-8);\n    p+=3882736.*rhs(9,-7);\n    p+=19495658.*rhs(9,-6);\n    p+=29726528.*rhs(9,-5);\n    p+=90216308.*rhs(9,-4);\n    p+=112093952.*rhs(9,-3);\n    p+=228013680.*rhs(9,-2);\n    p+=219617664.*rhs(9,-1);\n    p+=312737680.*rhs(9,0);\n    p+=219617664.*rhs(9,1);\n    p+=228013680.*rhs(9,2);\n    p+=112093952.*rhs(9,3);\n    p+=90216308.*rhs(9,4);\n    p+=29726528.*rhs(9,5);\n    p+=19495658.*rhs(9,6);\n    p+=3882736.*rhs(9,7);\n    p+=2144142.*rhs(9,8);\n    p+=194480.*rhs(9,9);\n    p+=92378.*rhs(9,10);\n    p+=92378.*rhs(10,-9);\n    p+=175032.*rhs(10,-8);\n    p+=1747226.*rhs(10,-7);\n    p+=2803840.*rhs(10,-6);\n    p+=12751388.*rhs(10,-5);\n    p+=16859024.*rhs(10,-4);\n    p+=46169052.*rhs(10,-3);\n    p+=48243200.*rhs(10,-2);\n    p+=88069168.*rhs(10,-1);\n    p+=68625984.*rhs(10,0);\n    p+=88069168.*rhs(10,1);\n    p+=48243200.*rhs(10,2);\n    p+=46169052.*rhs(10,3);\n    p+=16859024.*rhs(10,4);\n    p+=12751388.*rhs(10,5);\n    p+=2803840.*rhs(10,6);\n    p+=1747226.*rhs(10,7);\n    p+=175032.*rhs(10,8);\n    p+=92378.*rhs(10,9);\n    p+=75582.*rhs(11,-8);\n    p+=127296.*rhs(11,-7);\n    p+=1155388.*rhs(11,-6);\n    p+=1616160.*rhs(11,-5);\n    p+=6672148.*rhs(11,-4);\n    p+=7480032.*rhs(11,-3);\n    p+=18513100.*rhs(11,-2);\n    p+=15789824.*rhs(11,-1);\n    p+=26001936.*rhs(11,0);\n    p+=15789824.*rhs(11,1);\n    p+=18513100.*rhs(11,2);\n    p+=7480032.*rhs(11,3);\n    p+=6672148.*rhs(11,4);\n    p+=1616160.*rhs(11,5);\n    p+=1155388.*rhs(11,6);\n    p+=127296.*rhs(11,7);\n    p+=75582.*rhs(11,8);\n    p+=50388.*rhs(12,-7);\n    p+=74256.*rhs(12,-6);\n    p+=614516.*rhs(12,-5);\n    p+=733376.*rhs(12,-4);\n    p+=2752228.*rhs(12,-3);\n    p+=2539344.*rhs(12,-2);\n    p+=5691972.*rhs(12,-1);\n    p+=3802112.*rhs(12,0);\n    p+=5691972.*rhs(12,1);\n    p+=2539344.*rhs(12,2);\n    p+=2752228.*rhs(12,3);\n    p+=733376.*rhs(12,4);\n    p+=614516.*rhs(12,5);\n    p+=74256.*rhs(12,6);\n    p+=50388.*rhs(12,7);\n    p+=27132.*rhs(13,-6);\n    p+=34272.*rhs(13,-5);\n    p+=259012.*rhs(13,-4);\n    p+=256160.*rhs(13,-3);\n    p+=874636.*rhs(13,-2);\n    p+=636608.*rhs(13,-1);\n    p+=1296593.*rhs(13,0);\n    p+=636608.*rhs(13,1);\n    p+=874636.*rhs(13,2);\n    p+=256160.*rhs(13,3);\n    p+=259012.*rhs(13,4);\n    p+=34272.*rhs(13,5);\n    p+=27132.*rhs(13,6);\n    p+=11628.*rhs(14,-5);\n    p+=12240.*rhs(14,-4);\n    p+=84524.*rhs(14,-3);\n    p+=66432.*rhs(14,-2);\n    p+=206531.*rhs(14,-1);\n    p+=111044.*rhs(14,0);\n    p+=206531.*rhs(14,1);\n    p+=66432.*rhs(14,2);\n    p+=84524.*rhs(14,3);\n    p+=12240.*rhs(14,4);\n    p+=11628.*rhs(14,5);\n    p+=3876.*rhs(15,-4);\n    p+=3264.*rhs(15,-3);\n    p+=20587.*rhs(15,-2);\n    p+=12040.*rhs(15,-1);\n    p+=34121.*rhs(15,0);\n    p+=12040.*rhs(15,1);\n    p+=20587.*rhs(15,2);\n    p+=3264.*rhs(15,3);\n    p+=3876.*rhs(15,4);\n    p+=969.*rhs(16,-3);\n    p+=612.*rhs(16,-2);\n    p+=3521.*rhs(16,-1);\n    p+=1360.*rhs(16,0);\n    p+=3521.*rhs(16,1);\n    p+=612.*rhs(16,2);\n    p+=969.*rhs(16,3);\n    p+=171.*rhs(17,-2);\n    p+=72.*rhs(17,-1);\n    p+=377.*rhs(17,0);\n    p+=72.*rhs(17,1);\n    p+=171.*rhs(17,2);\n    p+=19.*rhs(18,-1);\n    p+=4.*rhs(18,0);\n    p+=19.*rhs(18,1);\n    p+=1.*rhs(19,0);\n    return p/1099511627776.;\n}\n\nfloat p0c(int x,int y){\n    vec2 p = gl_FragCoord.xy+vec2(x,y);\n\treturn texture(iChannel1,p/iResolution.xy).x;\n}\n\n// Gaussian - like redistribution of the previously calculated pressure p0c\nfloat TwentyStepPressure( void ){\n    float p = 0.;\n    p+=1.*p0c(-20,0);\n    p+=20.*p0c(-19,-1);\n    p+=20.*p0c(-19,1);\n    p+=190.*p0c(-18,-2);\n    p+=400.*p0c(-18,0);\n    p+=190.*p0c(-18,2);\n    p+=1140.*p0c(-17,-3);\n    p+=3800.*p0c(-17,-1);\n    p+=3800.*p0c(-17,1);\n    p+=1140.*p0c(-17,3);\n    p+=4845.*p0c(-16,-4);\n    p+=22800.*p0c(-16,-2);\n    p+=36100.*p0c(-16,0);\n    p+=22800.*p0c(-16,2);\n    p+=4845.*p0c(-16,4);\n    p+=15504.*p0c(-15,-5);\n    p+=96900.*p0c(-15,-3);\n    p+=216600.*p0c(-15,-1);\n    p+=216600.*p0c(-15,1);\n    p+=96900.*p0c(-15,3);\n    p+=15504.*p0c(-15,5);\n    p+=38760.*p0c(-14,-6);\n    p+=310080.*p0c(-14,-4);\n    p+=920550.*p0c(-14,-2);\n    p+=1299600.*p0c(-14,0);\n    p+=920550.*p0c(-14,2);\n    p+=310080.*p0c(-14,4);\n    p+=38760.*p0c(-14,6);\n    p+=77520.*p0c(-13,-7);\n    p+=775200.*p0c(-13,-5);\n    p+=2945760.*p0c(-13,-3);\n    p+=5523300.*p0c(-13,-1);\n    p+=5523300.*p0c(-13,1);\n    p+=2945760.*p0c(-13,3);\n    p+=775200.*p0c(-13,5);\n    p+=77520.*p0c(-13,7);\n    p+=125970.*p0c(-12,-8);\n    p+=1550400.*p0c(-12,-6);\n    p+=7364400.*p0c(-12,-4);\n    p+=17674560.*p0c(-12,-2);\n    p+=23474025.*p0c(-12,0);\n    p+=17674560.*p0c(-12,2);\n    p+=7364400.*p0c(-12,4);\n    p+=1550400.*p0c(-12,6);\n    p+=125970.*p0c(-12,8);\n    p+=167960.*p0c(-11,-9);\n    p+=2519400.*p0c(-11,-7);\n    p+=14728800.*p0c(-11,-5);\n    p+=44186400.*p0c(-11,-3);\n    p+=75116880.*p0c(-11,-1);\n    p+=75116880.*p0c(-11,1);\n    p+=44186400.*p0c(-11,3);\n    p+=14728800.*p0c(-11,5);\n    p+=2519400.*p0c(-11,7);\n    p+=167960.*p0c(-11,9);\n    p+=184756.*p0c(-10,-10);\n    p+=3359200.*p0c(-10,-8);\n    p+=23934300.*p0c(-10,-6);\n    p+=88372800.*p0c(-10,-4);\n    p+=187792200.*p0c(-10,-2);\n    p+=240374016.*p0c(-10,0);\n    p+=187792200.*p0c(-10,2);\n    p+=88372800.*p0c(-10,4);\n    p+=23934300.*p0c(-10,6);\n    p+=3359200.*p0c(-10,8);\n    p+=184756.*p0c(-10,10);\n    p+=167960.*p0c(-9,-11);\n    p+=3695120.*p0c(-9,-9);\n    p+=31912400.*p0c(-9,-7);\n    p+=143605800.*p0c(-9,-5);\n    p+=375584400.*p0c(-9,-3);\n    p+=600935040.*p0c(-9,-1);\n    p+=600935040.*p0c(-9,1);\n    p+=375584400.*p0c(-9,3);\n    p+=143605800.*p0c(-9,5);\n    p+=31912400.*p0c(-9,7);\n    p+=3695120.*p0c(-9,9);\n    p+=167960.*p0c(-9,11);\n    p+=125970.*p0c(-8,-12);\n    p+=3359200.*p0c(-8,-10);\n    p+=35103640.*p0c(-8,-8);\n    p+=191474400.*p0c(-8,-6);\n    p+=610324650.*p0c(-8,-4);\n    p+=1201870080.*p0c(-8,-2);\n    p+=1502337600.*p0c(-8,0);\n    p+=1201870080.*p0c(-8,2);\n    p+=610324650.*p0c(-8,4);\n    p+=191474400.*p0c(-8,6);\n    p+=35103640.*p0c(-8,8);\n    p+=3359200.*p0c(-8,10);\n    p+=125970.*p0c(-8,12);\n    p+=77520.*p0c(-7,-13);\n    p+=2519400.*p0c(-7,-11);\n    p+=31912400.*p0c(-7,-9);\n    p+=210621840.*p0c(-7,-7);\n    p+=813766200.*p0c(-7,-5);\n    p+=1953038880.*p0c(-7,-3);\n    p+=3004675200.*p0c(-7,-1);\n    p+=3004675200.*p0c(-7,1);\n    p+=1953038880.*p0c(-7,3);\n    p+=813766200.*p0c(-7,5);\n    p+=210621840.*p0c(-7,7);\n    p+=31912400.*p0c(-7,9);\n    p+=2519400.*p0c(-7,11);\n    p+=77520.*p0c(-7,13);\n    p+=38760.*p0c(-6,-14);\n    p+=1550400.*p0c(-6,-12);\n    p+=23934300.*p0c(-6,-10);\n    p+=191474400.*p0c(-6,-8);\n    p+=895142820.*p0c(-6,-6);\n    p+=2604051840.*p0c(-6,-4);\n    p+=4882597200.*p0c(-6,-2);\n    p+=6009350400.*p0c(-6,0);\n    p+=4882597200.*p0c(-6,2);\n    p+=2604051840.*p0c(-6,4);\n    p+=895142820.*p0c(-6,6);\n    p+=191474400.*p0c(-6,8);\n    p+=23934300.*p0c(-6,10);\n    p+=1550400.*p0c(-6,12);\n    p+=38760.*p0c(-6,14);\n    p+=15504.*p0c(-5,-15);\n    p+=775200.*p0c(-5,-13);\n    p+=14728800.*p0c(-5,-11);\n    p+=143605800.*p0c(-5,-9);\n    p+=813766200.*p0c(-5,-7);\n    p+=2864457024.*p0c(-5,-5);\n    p+=6510129600.*p0c(-5,-3);\n    p+=9765194400.*p0c(-5,-1);\n    p+=9765194400.*p0c(-5,1);\n    p+=6510129600.*p0c(-5,3);\n    p+=2864457024.*p0c(-5,5);\n    p+=813766200.*p0c(-5,7);\n    p+=143605800.*p0c(-5,9);\n    p+=14728800.*p0c(-5,11);\n    p+=775200.*p0c(-5,13);\n    p+=15504.*p0c(-5,15);\n    p+=4845.*p0c(-4,-16);\n    p+=310080.*p0c(-4,-14);\n    p+=7364400.*p0c(-4,-12);\n    p+=88372800.*p0c(-4,-10);\n    p+=610324650.*p0c(-4,-8);\n    p+=2604051840.*p0c(-4,-6);\n    p+=7161142560.*p0c(-4,-4);\n    p+=13020259200.*p0c(-4,-2);\n    p+=15868440900.*p0c(-4,0);\n    p+=13020259200.*p0c(-4,2);\n    p+=7161142560.*p0c(-4,4);\n    p+=2604051840.*p0c(-4,6);\n    p+=610324650.*p0c(-4,8);\n    p+=88372800.*p0c(-4,10);\n    p+=7364400.*p0c(-4,12);\n    p+=310080.*p0c(-4,14);\n    p+=4845.*p0c(-4,16);\n    p+=1140.*p0c(-3,-17);\n    p+=96900.*p0c(-3,-15);\n    p+=2945760.*p0c(-3,-13);\n    p+=44186400.*p0c(-3,-11);\n    p+=375584400.*p0c(-3,-9);\n    p+=1953038880.*p0c(-3,-7);\n    p+=6510129600.*p0c(-3,-5);\n    p+=14322285120.*p0c(-3,-3);\n    p+=21157921200.*p0c(-3,-1);\n    p+=21157921200.*p0c(-3,1);\n    p+=14322285120.*p0c(-3,3);\n    p+=6510129600.*p0c(-3,5);\n    p+=1953038880.*p0c(-3,7);\n    p+=375584400.*p0c(-3,9);\n    p+=44186400.*p0c(-3,11);\n    p+=2945760.*p0c(-3,13);\n    p+=96900.*p0c(-3,15);\n    p+=1140.*p0c(-3,17);\n    p+=190.*p0c(-2,-18);\n    p+=22800.*p0c(-2,-16);\n    p+=920550.*p0c(-2,-14);\n    p+=17674560.*p0c(-2,-12);\n    p+=187792200.*p0c(-2,-10);\n    p+=1201870080.*p0c(-2,-8);\n    p+=4882597200.*p0c(-2,-6);\n    p+=13020259200.*p0c(-2,-4);\n    p+=23273713320.*p0c(-2,-2);\n    p+=28210561600.*p0c(-2,0);\n    p+=23273713320.*p0c(-2,2);\n    p+=13020259200.*p0c(-2,4);\n    p+=4882597200.*p0c(-2,6);\n    p+=1201870080.*p0c(-2,8);\n    p+=187792200.*p0c(-2,10);\n    p+=17674560.*p0c(-2,12);\n    p+=920550.*p0c(-2,14);\n    p+=22800.*p0c(-2,16);\n    p+=190.*p0c(-2,18);\n    p+=20.*p0c(-1,-19);\n    p+=3800.*p0c(-1,-17);\n    p+=216600.*p0c(-1,-15);\n    p+=5523300.*p0c(-1,-13);\n    p+=75116880.*p0c(-1,-11);\n    p+=600935040.*p0c(-1,-9);\n    p+=3004675200.*p0c(-1,-7);\n    p+=9765194400.*p0c(-1,-5);\n    p+=21157921200.*p0c(-1,-3);\n    p+=31031617760.*p0c(-1,-1);\n    p+=31031617760.*p0c(-1,1);\n    p+=21157921200.*p0c(-1,3);\n    p+=9765194400.*p0c(-1,5);\n    p+=3004675200.*p0c(-1,7);\n    p+=600935040.*p0c(-1,9);\n    p+=75116880.*p0c(-1,11);\n    p+=5523300.*p0c(-1,13);\n    p+=216600.*p0c(-1,15);\n    p+=3800.*p0c(-1,17);\n    p+=20.*p0c(-1,19);\n    p+=1.*p0c(0,-20);\n    p+=400.*p0c(0,-18);\n    p+=36100.*p0c(0,-16);\n    p+=1299600.*p0c(0,-14);\n    p+=23474025.*p0c(0,-12);\n    p+=240374016.*p0c(0,-10);\n    p+=1502337600.*p0c(0,-8);\n    p+=6009350400.*p0c(0,-6);\n    p+=15868440900.*p0c(0,-4);\n    p+=28210561600.*p0c(0,-2);\n    p+=34134779536.*p0c(0,0);\n    p+=28210561600.*p0c(0,2);\n    p+=15868440900.*p0c(0,4);\n    p+=6009350400.*p0c(0,6);\n    p+=1502337600.*p0c(0,8);\n    p+=240374016.*p0c(0,10);\n    p+=23474025.*p0c(0,12);\n    p+=1299600.*p0c(0,14);\n    p+=36100.*p0c(0,16);\n    p+=400.*p0c(0,18);\n    p+=1.*p0c(0,20);\n    p+=20.*p0c(1,-19);\n    p+=3800.*p0c(1,-17);\n    p+=216600.*p0c(1,-15);\n    p+=5523300.*p0c(1,-13);\n    p+=75116880.*p0c(1,-11);\n    p+=600935040.*p0c(1,-9);\n    p+=3004675200.*p0c(1,-7);\n    p+=9765194400.*p0c(1,-5);\n    p+=21157921200.*p0c(1,-3);\n    p+=31031617760.*p0c(1,-1);\n    p+=31031617760.*p0c(1,1);\n    p+=21157921200.*p0c(1,3);\n    p+=9765194400.*p0c(1,5);\n    p+=3004675200.*p0c(1,7);\n    p+=600935040.*p0c(1,9);\n    p+=75116880.*p0c(1,11);\n    p+=5523300.*p0c(1,13);\n    p+=216600.*p0c(1,15);\n    p+=3800.*p0c(1,17);\n    p+=20.*p0c(1,19);\n    p+=190.*p0c(2,-18);\n    p+=22800.*p0c(2,-16);\n    p+=920550.*p0c(2,-14);\n    p+=17674560.*p0c(2,-12);\n    p+=187792200.*p0c(2,-10);\n    p+=1201870080.*p0c(2,-8);\n    p+=4882597200.*p0c(2,-6);\n    p+=13020259200.*p0c(2,-4);\n    p+=23273713320.*p0c(2,-2);\n    p+=28210561600.*p0c(2,0);\n    p+=23273713320.*p0c(2,2);\n    p+=13020259200.*p0c(2,4);\n    p+=4882597200.*p0c(2,6);\n    p+=1201870080.*p0c(2,8);\n    p+=187792200.*p0c(2,10);\n    p+=17674560.*p0c(2,12);\n    p+=920550.*p0c(2,14);\n    p+=22800.*p0c(2,16);\n    p+=190.*p0c(2,18);\n    p+=1140.*p0c(3,-17);\n    p+=96900.*p0c(3,-15);\n    p+=2945760.*p0c(3,-13);\n    p+=44186400.*p0c(3,-11);\n    p+=375584400.*p0c(3,-9);\n    p+=1953038880.*p0c(3,-7);\n    p+=6510129600.*p0c(3,-5);\n    p+=14322285120.*p0c(3,-3);\n    p+=21157921200.*p0c(3,-1);\n    p+=21157921200.*p0c(3,1);\n    p+=14322285120.*p0c(3,3);\n    p+=6510129600.*p0c(3,5);\n    p+=1953038880.*p0c(3,7);\n    p+=375584400.*p0c(3,9);\n    p+=44186400.*p0c(3,11);\n    p+=2945760.*p0c(3,13);\n    p+=96900.*p0c(3,15);\n    p+=1140.*p0c(3,17);\n    p+=4845.*p0c(4,-16);\n    p+=310080.*p0c(4,-14);\n    p+=7364400.*p0c(4,-12);\n    p+=88372800.*p0c(4,-10);\n    p+=610324650.*p0c(4,-8);\n    p+=2604051840.*p0c(4,-6);\n    p+=7161142560.*p0c(4,-4);\n    p+=13020259200.*p0c(4,-2);\n    p+=15868440900.*p0c(4,0);\n    p+=13020259200.*p0c(4,2);\n    p+=7161142560.*p0c(4,4);\n    p+=2604051840.*p0c(4,6);\n    p+=610324650.*p0c(4,8);\n    p+=88372800.*p0c(4,10);\n    p+=7364400.*p0c(4,12);\n    p+=310080.*p0c(4,14);\n    p+=4845.*p0c(4,16);\n    p+=15504.*p0c(5,-15);\n    p+=775200.*p0c(5,-13);\n    p+=14728800.*p0c(5,-11);\n    p+=143605800.*p0c(5,-9);\n    p+=813766200.*p0c(5,-7);\n    p+=2864457024.*p0c(5,-5);\n    p+=6510129600.*p0c(5,-3);\n    p+=9765194400.*p0c(5,-1);\n    p+=9765194400.*p0c(5,1);\n    p+=6510129600.*p0c(5,3);\n    p+=2864457024.*p0c(5,5);\n    p+=813766200.*p0c(5,7);\n    p+=143605800.*p0c(5,9);\n    p+=14728800.*p0c(5,11);\n    p+=775200.*p0c(5,13);\n    p+=15504.*p0c(5,15);\n    p+=38760.*p0c(6,-14);\n    p+=1550400.*p0c(6,-12);\n    p+=23934300.*p0c(6,-10);\n    p+=191474400.*p0c(6,-8);\n    p+=895142820.*p0c(6,-6);\n    p+=2604051840.*p0c(6,-4);\n    p+=4882597200.*p0c(6,-2);\n    p+=6009350400.*p0c(6,0);\n    p+=4882597200.*p0c(6,2);\n    p+=2604051840.*p0c(6,4);\n    p+=895142820.*p0c(6,6);\n    p+=191474400.*p0c(6,8);\n    p+=23934300.*p0c(6,10);\n    p+=1550400.*p0c(6,12);\n    p+=38760.*p0c(6,14);\n    p+=77520.*p0c(7,-13);\n    p+=2519400.*p0c(7,-11);\n    p+=31912400.*p0c(7,-9);\n    p+=210621840.*p0c(7,-7);\n    p+=813766200.*p0c(7,-5);\n    p+=1953038880.*p0c(7,-3);\n    p+=3004675200.*p0c(7,-1);\n    p+=3004675200.*p0c(7,1);\n    p+=1953038880.*p0c(7,3);\n    p+=813766200.*p0c(7,5);\n    p+=210621840.*p0c(7,7);\n    p+=31912400.*p0c(7,9);\n    p+=2519400.*p0c(7,11);\n    p+=77520.*p0c(7,13);\n    p+=125970.*p0c(8,-12);\n    p+=3359200.*p0c(8,-10);\n    p+=35103640.*p0c(8,-8);\n    p+=191474400.*p0c(8,-6);\n    p+=610324650.*p0c(8,-4);\n    p+=1201870080.*p0c(8,-2);\n    p+=1502337600.*p0c(8,0);\n    p+=1201870080.*p0c(8,2);\n    p+=610324650.*p0c(8,4);\n    p+=191474400.*p0c(8,6);\n    p+=35103640.*p0c(8,8);\n    p+=3359200.*p0c(8,10);\n    p+=125970.*p0c(8,12);\n    p+=167960.*p0c(9,-11);\n    p+=3695120.*p0c(9,-9);\n    p+=31912400.*p0c(9,-7);\n    p+=143605800.*p0c(9,-5);\n    p+=375584400.*p0c(9,-3);\n    p+=600935040.*p0c(9,-1);\n    p+=600935040.*p0c(9,1);\n    p+=375584400.*p0c(9,3);\n    p+=143605800.*p0c(9,5);\n    p+=31912400.*p0c(9,7);\n    p+=3695120.*p0c(9,9);\n    p+=167960.*p0c(9,11);\n    p+=184756.*p0c(10,-10);\n    p+=3359200.*p0c(10,-8);\n    p+=23934300.*p0c(10,-6);\n    p+=88372800.*p0c(10,-4);\n    p+=187792200.*p0c(10,-2);\n    p+=240374016.*p0c(10,0);\n    p+=187792200.*p0c(10,2);\n    p+=88372800.*p0c(10,4);\n    p+=23934300.*p0c(10,6);\n    p+=3359200.*p0c(10,8);\n    p+=184756.*p0c(10,10);\n    p+=167960.*p0c(11,-9);\n    p+=2519400.*p0c(11,-7);\n    p+=14728800.*p0c(11,-5);\n    p+=44186400.*p0c(11,-3);\n    p+=75116880.*p0c(11,-1);\n    p+=75116880.*p0c(11,1);\n    p+=44186400.*p0c(11,3);\n    p+=14728800.*p0c(11,5);\n    p+=2519400.*p0c(11,7);\n    p+=167960.*p0c(11,9);\n    p+=125970.*p0c(12,-8);\n    p+=1550400.*p0c(12,-6);\n    p+=7364400.*p0c(12,-4);\n    p+=17674560.*p0c(12,-2);\n    p+=23474025.*p0c(12,0);\n    p+=17674560.*p0c(12,2);\n    p+=7364400.*p0c(12,4);\n    p+=1550400.*p0c(12,6);\n    p+=125970.*p0c(12,8);\n    p+=77520.*p0c(13,-7);\n    p+=775200.*p0c(13,-5);\n    p+=2945760.*p0c(13,-3);\n    p+=5523300.*p0c(13,-1);\n    p+=5523300.*p0c(13,1);\n    p+=2945760.*p0c(13,3);\n    p+=775200.*p0c(13,5);\n    p+=77520.*p0c(13,7);\n    p+=38760.*p0c(14,-6);\n    p+=310080.*p0c(14,-4);\n    p+=920550.*p0c(14,-2);\n    p+=1299600.*p0c(14,0);\n    p+=920550.*p0c(14,2);\n    p+=310080.*p0c(14,4);\n    p+=38760.*p0c(14,6);\n    p+=15504.*p0c(15,-5);\n    p+=96900.*p0c(15,-3);\n    p+=216600.*p0c(15,-1);\n    p+=216600.*p0c(15,1);\n    p+=96900.*p0c(15,3);\n    p+=15504.*p0c(15,5);\n    p+=4845.*p0c(16,-4);\n    p+=22800.*p0c(16,-2);\n    p+=36100.*p0c(16,0);\n    p+=22800.*p0c(16,2);\n    p+=4845.*p0c(16,4);\n    p+=1140.*p0c(17,-3);\n    p+=3800.*p0c(17,-1);\n    p+=3800.*p0c(17,1);\n    p+=1140.*p0c(17,3);\n    p+=190.*p0c(18,-2);\n    p+=400.*p0c(18,0);\n    p+=190.*p0c(18,2);\n    p+=20.*p0c(19,-1);\n    p+=20.*p0c(19,1);\n    p+=1.*p0c(20,0);\n    return p/1099511627776.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{ \n    if(C.x > .5*iResolution.x) return;\n    vec4 data = texel(ch2, C);\n    particle P = getParticle(data, C);\n    fragColor = vec4(0);\n    \n    if(P.M.x == 0.) return;\n    \n    float divV = rhs(0,0);\n    //float divX = texel(ch0, C).y;\n    if(divV == 0.) return; // free surface\n    \n    float p = TwentyStepRHS()+TwentyStepPressure();\n    //if(C.x < 1. || C.y < 1. || C.x > iResolution.x-1. || C.y > iResolution.y-1.) p = 0.;\n    fragColor = vec4(p,0,0,1);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define COMPRESSIBLE (pos.x > .5*R.x)\n#define IISPH 0.1\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    float pressure = -texture(iChannel2, P.X/R).x;\n    float dpressure = -texture(iChannel1, P.X/R).x;\n    //if(P.M.x > 1.) pressure += P.M.x - 1.;\n    \n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    //vec3 avgV = vec3(0.);\n    range(i, -6, 6) range(j, -6, 6)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        dx /= 2.;\n        //float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        //F -= 0.5*G(1.*dx)*avgP*dx;\n        //avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n        \n        float pressure0 = -texture(iChannel2, P0.X/R).x;\n        float dpressure0 = -texture(iChannel1, P0.X/R).x;\n        //if(P0.M.x > 1.) pressure0 += P0.M.x - 1.;\n        vec2 gradG = G(dx) * dx / 4.;\n        F -= mix(Pf(P.M) + Pf(P0.M), mix(pressure0 - pressure, dpressure0 - dpressure, .1), COMPRESSIBLE ? 0. : .5) * gradG;\n    }\n    //avgV.xy /= avgV.z;\n\n    //viscosity\n    //F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F.y -= .0015 * P.M.x;\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    if(vdotN > 0.) P.V += N.xy * abs(vdotN);\n    //P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.M = P.V = vec2(0.);\n    \n    if(pos.x < 10. || pos.x > R.x-10. || abs(pos.x - .5*R.x) < 10.) P.M = P.V = vec2(0.);\n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(pos - R*vec2(.1 + .3*hash32(vec2(iFrame)).z, 0.9)) < 50e-3*R.y && iFrame%500 < 1) \n    {\n        P.X = pos;\n        P.V = vec2(0, -1);\n        P.M = vec2(fluid_rho, 0.);\n    }\n    \n    if(length(pos - R*vec2(.6 + .3*hash32(vec2(iFrame)).z, 0.9)) < 50e-3*R.y && iFrame%500 < 1) \n    {\n        P.X = pos;\n        P.V = vec2(0, -1);\n        P.M = vec2(fluid_rho, 0.);\n    }\n\n    U = saveParticle(P, pos);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 215, 215, 827]], "test": "untested"}
{"id": "7dlcWf", "name": "Having fun shader3", "author": "MinimilisticBits", "description": "sgsdg", "tags": ["sdgsdg"], "likes": 37, "viewed": 699, "published": 3, "date": "1642887151", "time_retrieved": "2024-07-30T17:07:53.558255", "image_code": "\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\nvec3 blur(vec2 uv, float r){\nvec3 c = vec3(0.);\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec4 c2 = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyzw;\n     vec3 col = c2.xyz;\n     col = clamp(col,0.,1.);\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec4 c2 = texture(iChannel0, (p+coords)/iResolution.xy).xyzw;\n    vec3 c = c2.xyz / (c2.w+1.);\n    //c = c*c *1.8;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec3 col = texture(iChannel0, uv).xyz;\n    // Output to screen\n    vec2 p = (uv*2.0-1.0);\n    vec3 col = blur(uv, length(p*p*p*p*p*p*p*3.));\n    float off = texture(iChannel0, uv).w;\n     vec3 rad;\n    vec2 offset2 = (fragCoord - iResolution.xy/2.)*1.;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,15.-length(uv*2.0-1.)*1.5, float(i)/20.)*1.;\n       rad.x += texture(iChannel0, (offset+offset2*0.024)/iResolution.xy).x;\n       rad.y += texture(iChannel0, (offset)/iResolution.xy).y;\n       rad.z += texture(iChannel0, (offset-offset2*0.024)/iResolution.xy).z;\n\n    }\n    rad /= 16.;\n    \n    col += rad*0.3;\n    col = clamp(col, 0., 1.);\n     col = vec3(1.)-exp(-.3*col);\n\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.3)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.2,1.2);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\ncol = pow(col, vec3(1.9))*1.8;\n//col = pow(col, vec3(0.7,0.8,0.9));\ncol = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float ring(vec2 p, vec2 s){\nreturn length(normalize(p)*s.x - p)-s.y;\n}\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x,a.y);\n}\n\nvec3 pal(float es, vec3 a){\nreturn 0.5 + 0.5*cos(2.0*3.14159*es + a);\n}\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat g = c;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\n\n//NOT MY CODE\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n/////////////\n\nfloat escape = 0.;\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n           escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\nfloat jb3(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n            escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\n  float DEmine(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\nfor(int i = 0; i < 7; i++){\np*=4.79;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\nfloat m = length(p.xyz);\n\np/=dot(p.xyz,p.xyz)+mod(m, 1.);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\n\nreturn length(p.xyz)/p.w;\n}\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = .1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\n\nfloat de22( vec3 p ){\n\n    vec3 CSize = vec3(1., 1.7, 1.);\n    p = p.xzy;\n    float scale = 1.1;\n    escape = 0.;\n    for( int i=0; i < 8;i++ ){\n      p = 2.0*clamp(p, -CSize, CSize) - p;\n      float r2 = dot(p,p+sin(p.z*.3));\n      float k = max((2.)/(r2), .5);\n      p *= k; scale *= k;\n      escape += exp(-0.2*dot(p,p));\n    }\n    float l = length(p.xy);\n    float rxy = l - 1.0;\n    float n = l * p.z;\n    rxy = max(rxy, (n) / 8.);\n    return (rxy) / abs(scale);\n  }\n/////////////////////////////////////\nfloat DEeerr(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               // p.xyz = abs(p.xyz);\n\n        //box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.,1.0));\n        p.xyz=abs(p.xyz)-vec3(3.5,.5,3.3);\n       //p*=1.2;\np.yxz -= sin(float(i)*1.)*0.9;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\nfloat newde(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\np.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\np.xy = (p.x > p.y)?p.yx:p.xy;\n\nfor(int i = 0; i < 12; i++){\n//p = abs(p);\n//p.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\n//p.xy = (p.x > p.y)?p.yx:p.xy;\n\np.xyz = mod(p.xyz-1., 2.)-1.;\np *= 1.1/clamp(dot(p.xyz,p.xyz),0.,1.2);\n//p.xyz -= vec3(2.,0.4,0.6);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\np/=p.w;\nreturn abs(p.x)*0.25;\n}\n\nfloat fractal(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.4+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.5,1.));\n        p.xyz-=vec3(0.2+rndf(seed)*0.2,0.6-rndf(seed)*0.3,2.3);\n        p*=1.2-rndf(seed)*0.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\n\nfloat fractal_de46(vec3 p){\n p = mod(p, 6.)-3.;\n    float s = 2.;\n    float e = 0.;\n    escape = 0.;\n    for(int j=0;++j<7;){\n        p.xz=abs(p.xz)-2.3,\n        p.z>p.x?p=p.zyx:p,\n        p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.y=.9-abs(p.y-.4),\n        e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n        2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n        p=e*p-vec3(7,1,1),\n        s*=e;\n        escape+=exp(-0.2*dot(p,p));\n        }\n    return length(p)/s;\n}\n\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin( iTime + 6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\n\nvec3 lens(vec2 p, vec2 mouse,inout uint k){\nvec3 col = vec3(exp(-20.*length(mouse-p)));\ncol += exp(-20.*length(-mouse*rndf(k)*0.5-p));\ncol += exp(-ring(-mouse*0.4-p, vec2(0.7, 0.01))*20.)\n*sin(texture(iChannel0, normalize(p*rndf(k))).x);\ncol *= pal(exp(-length(-mouse*rndf(k)*0.9-p)), vec3(0.9,0.6,0.8));\nfor(int i = 0;i < 5; i++){\ncol += exp(-ring(mouse*2.*(0.1+float(i)/5.0)-p, vec2(0.1-float(i)/15.0, 0.001*float(i+1)))*20.);\n}\ncol *= pal(length(mouse*rndf(k)-p), vec3(0.9,0.6,0.8))*1.;//\n//col += exp(-length(mouse-p))*vec3(0.9,0.6,0.2)\n//*sin(texture(iChannel0, normalize(mouse-p)).x)*exp(-length(mouse-p)*5.)*2.;\ncol += exp(-ring(mouse*0.5-p, vec2(0.9,0.01))*20.)*0.4;\n//col *= pal(length(mouse-p)*1., vec3(0.9,0.4,0.9));\ncol += exp(-(abs(box(-mouse*rndf(k)-p, vec2(0.1)))+0.2)*20.);\ncol += exp(-(jb3(vec3(p*12.,iTime*0.3))/10.)*1000.)*0.7;\ncol += exp(-jb3((vec3(p*10.,iTime*0.1))/10.)*10000.);\ncol += exp(-(abs(min(min(box(-mouse*0.6-p, vec2(0.9, 0.5)) , box(rot(-mouse*0.6-p, 45.), vec2(0.9,0.5))),\nbox(rot(-mouse*0.6-p, 125.), vec2(0.9,0.5))))-0.001)*70.)\n*pal(length(-mouse*0.6-p), vec3(0.9,0.5,0.2))*0.6;\ncol *= pal(escape, vec3(0.9,0.6,0.8)+iTime)*0.5*pal(length(-mouse*0.6-p), vec3(0.9,0.5,0.8))*12.;\n\nvec2 res = voronoi(p*1.);\ncol += palette(res.x+res.y+iTime, vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2))*0.64;\n    \n\ncol += exp(-voronoi(p).x*200.)*4.;\ncol *= pal(escape, vec3(0.9,0.6,0.2));\ncol *= pal(length(mouse-p), vec3(0.9,0.5,0.2)+iTime)*2.;\nreturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ///NOT MY CODE///\n    uint r = uint(uint(fragCoord.x) * uint(1973) \n    + uint(fragCoord.y) * uint(9277) \n    + uint(iFrame) * uint(26699)) | uint(1);\n    \n    ///////////////\n    \n    \nuv = uv * 2.0 - 1.0;\nuv.x *= 1.3;\nuv.y /= 1.3;\nuv *= 1.5;\n    // Time varying pixel color\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 15; i++){\n    uint k = uint(i+1);\n        float offset = rndf(k);\n        col += lens(rot(uv*(rndf(k)+0.04), offset*iTime), vec2(cos(offset*2.*3.14159+iTime), sin(offset*2.*3.14159-iTime)), k)*offset*0.2;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 38, 61, 61, 215], [252, 252, 280, 280, 779], [783, 783, 813, 813, 1321], [1323, 1323, 1380, 1430, 2633]], "test": "untested"}
{"id": "NsfyDs", "name": "optimized grid neighborhood", "author": "FabriceNeyret2", "description": "People usually check the central cell + the 8 neighbors.\nBut you can eval only 3 neighbors, chosen depending on the side the current pixel is in the central cell.\n\nclick to see the full Voronoi. small parts are missed.\n", "tags": ["voronoi", "grid", "worley", "tuto", "loopless"], "likes": 20, "viewed": 455, "published": 3, "date": "1642878319", "time_retrieved": "2024-07-30T17:07:54.329194", "image_code": "#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define rot 1   // 1 : additionnal displacement + rotation\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    \n    vec2 R = iResolution.xy,\n         U = 10.*u/iResolution.y + iTime, \n         I = floor(U), F = fract(U), P,H,S,A;\n    float d = 1e9;\n    \n#if 0                                 // --- the classical 9-cells loop\n    for( int k=0; k<9; k++) {   \n        P = vec2(k%3,k/3)-1.;         // variant: P = I+...; P+= hash(P) - U\n        H = hash(I+P);                // random point in cell\n        A = hash(I+P+.5);             // for random rotation\n  #if rot    \n        A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11));\n        P += .1+.8*H -F + A;\n  #else\n        P += H - F;\n  #endif\n        d = min(d, dot(P,P) );\n    }\n\n#else                                 // --- the alternate 4-cells loop\n/* // loopless form\n#define C(i,j) P = vec2(i,j); H = hash(I+P); A = hash(I+P+.5);     \\\n               A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11)); \\\n               P += rot>0 ?.1+.8*H - F + A : H - F;                \\\n               d = min(d, dot(P,P) );\n    C(0,0);\n    S = sign(F-.5);                   // neighbors can win only on the side the pixel is in the cell\n    C(S.x,0); C(0,S.y); C(S.x,S.y); \n*/ \n    S = sign(F-.5);                   // <<\n    for( int k=0; k<4; k++) {         // << only changes compare to 9-cells\n        P = S*vec2(k%2,k/2);          // <<\n        H = hash(I+P);                // random point in cell\n        A = hash(I+P+.5);             // for random rotation\n  #if rot    \n        A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11));\n        P += .1+.8*H -F + A;\n  #else\n        P += H - F;\n  #endif\n        d = min(d, dot(P,P) );\n    }\n\n#endif\n\n    O = vec4( iMouse.z>0. \n                ? sqrt(d)                                  // show Vorono\n                : smoothstep( 15./R.y,0., sqrt(d)-.3 )  ); // show dots\n    O.rg += .2*mod(I,2.);                                  // show tiling\n // O += .2* ( .6 + .6 * cos( 6.3*hash(I).x  + vec4(0,23,21,0)  ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 176, 176, 2090]], "test": "untested"}
{"id": "NdfcDs", "name": "fork temple", "author": "jorge2017a2", "description": "fork temple\nhttps://www.shadertoy.com/view/tsySDw\n AMAZE Ray Marching Workshop\n", "tags": ["forktemple"], "likes": 6, "viewed": 227, "published": 3, "date": "1642878037", "time_retrieved": "2024-07-30T17:07:55.102127", "image_code": "//----------image\n//por jorge2017a2-\n//https://www.shadertoy.com/view/tsySDw\n//AMAZE Ray Marching Workshop Created by enci in 2019-11-19\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n#define MAX_FLT  65504.0\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///https://www.shadertoy.com/view/tsySDw\nfloat sdCylinderY(vec3 p, vec3 c)\n{  return length(p.xz-c.xy)-c.z;}\nfloat sdCylinderZ(vec3 p, vec3 c)\n{  return length(p.xy-c.xy)-c.z;}\nfloat sdCylinderX(vec3 p, vec3 c)\n{  return length(p.zy-c.xy)-c.z;}\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n    { float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvoid opRepeat(inout float coor, float repeat)\n    { coor = mod(coor + repeat * 0.5, repeat) - repeat * 0.5;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{ return dot(p, n.xyz) + n.w; }\n\nfloat floorSdf(vec3 pos)\n{ pos.y+= 1.0;\n  pos.x=opRep1D(pos.x, 5.5);\n  pos.z=opRep1D(pos.z, 5.5);\n  return sdRoundBox(pos, vec3(2.5, 0.25, 2.5), 0.5);\n}\n\n///https://www.shadertoy.com/view/tsySDw\nfloat opUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nfloat ceilingSdf(vec3 pos)\n{ pos -= vec3(6.0, 6.0, 6.0);\n  float b = sdPlane(pos, vec4(0.0, -1.0, 0.0, 0.0)); \n  const float repeat = 12.0;\n  opRepeat(pos.x, repeat);\n  opRepeat(pos.z, repeat);\n  float cz = sdCylinderZ(pos, vec3(0.0, 0.0, 5.0));\n  float cx = sdCylinderX(pos, vec3(0.0, 0.0, 5.0));\n  float c = min(cz, cx);   \n  return differenceSDF(b,c);\n}\n\nfloat pillarsSdf(vec3 pos)\n{ const float repeat = 12.0;\n  opRepeat(pos.x, repeat);\n  opRepeat(pos.z, repeat);\n float d = 9999.9;\n  float pillar = sdBox(pos, vec3(1.0, 8.0, 1.0));\n  float base = sdBox(pos, vec3(1.5, 0.5, 1.5));  \n  float base2 = sdBox(pos-vec3(0.0,-8.0,0.0), vec3(1.5, 0.5, 1.5));  \n  float top = sdBox(pos - vec3(0.0, 4.5, 0.0), vec3(1.25, 0.2, 1.25));\n  d = opUnionStairs(pillar, base, 0.5, 3.0);\n  d = opUnionStairs(d, base2, 0.5, 3.0);\n  d = opUnionStairs(d, top, 0.3, 2.0);\n  return d;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n    p.xyz=p.zyx;\n    vec3 p0=p;\n    p.y+=7.5;\n    float d1= floorSdf(p);\n    res =opU3(res, vec3(d1,18,-1.0));\n    p=p0;\n    res =opU3(res, vec3(pillarsSdf(p),2.0,-1.0));\n    res =opU3(res, vec3(ceilingSdf(p-vec3(0.0,0.0,0.0)),2.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n        {  vec3 coltex=getColorTextura(p, n, int( id_color));colobj=coltex;\t}\n   return colobj;\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,step(vec3(0.0031308), c));}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvec3 ACESFilm(vec3 x)\n{   float a = 2.51;float b = 0.03;\n    float c = 2.43;float d = 0.59;\n    float e = 0.14;return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        \n        light_pos1.x-=opRep1D(light_pos1.x, 10.0 );\n        light_pos2.x-=opRep1D(light_pos2.x, 10.0 );\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        //col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        //col.xyz=vec3((col.x+col.y+col.z)/3.0);\n        col.xyz= vec3(col.x*0.299 + col.y*0.587 +col.z*0.114);\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec2 barrelDistortion(vec2 uv, float k)\n{ float rd = length(uv);    \n  float ru = rd * (1.0 + k * rd * rd);\n  uv /= rd;  uv *= ru;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv = barrelDistortion(uv, 0.25);\n    \n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n        //mObj.blnShadow=false;\n        mObj.blnShadow=true;        \n \tlight_pos1= vec3(-10.0, 10.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, -20.0, 20.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n       vec3 ro=vec3(6.0,-6.0,-10.0+t);\n       vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(-20.0));\n        light_pos1+=ro;\n        light_pos2+=ro;\n        vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfcDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 621, 657, 657, 678], [679, 679, 711, 711, 795], [796, 796, 842, 842, 929], [931, 972, 1007, 1007, 1039], [1040, 1040, 1075, 1075, 1107], [1108, 1108, 1143, 1143, 1175], [1177, 1177, 1224, 1224, 1251], [1252, 1252, 1295, 1295, 1322], [1323, 1323, 1371, 1371, 1399], [1401, 1401, 1440, 1440, 1485], [1486, 1486, 1537, 1537, 1594], [1595, 1660, 1694, 1694, 1790], [1791, 1791, 1825, 1825, 1916], [1917, 1917, 1951, 1951, 2042], [2044, 2044, 2075, 2075, 2105], [2107, 2107, 2133, 2133, 2259], [2261, 2302, 2359, 2359, 2470], [2472, 2472, 2500, 2500, 2828], [2830, 2830, 2858, 2858, 3338], [3340, 3340, 3365, 3365, 3659], [3661, 3661, 3685, 3685, 3847], [3849, 3849, 3898, 3898, 4529], [4532, 4532, 4568, 4568, 4813], [4815, 4815, 4852, 4852, 5126], [5128, 5128, 5211, 5211, 5784], [5786, 5786, 5835, 5835, 6078], [6080, 6080, 6173, 6173, 6303], [6305, 6305, 6337, 6337, 6534], [6536, 6536, 6629, 6629, 6931], [6933, 6933, 6960, 6960, 7047], [7049, 7049, 7107, 7107, 7159], [7161, 7161, 7184, 7184, 7307], [7309, 7309, 7340, 7340, 8279], [8281, 8281, 8322, 8322, 8426], [8428, 8428, 8485, 8485, 9113]], "test": "untested"}
{"id": "fdXcDl", "name": "Closest icosahedron vertices", "author": "tdhooper", "description": "Closest icosahedron vertices", "tags": ["icosahedron", "polyhedra"], "likes": 21, "viewed": 422, "published": 3, "date": "1642862167", "time_retrieved": "2024-07-30T17:07:55.867082", "image_code": "// Most of this is from https://www.shadertoy.com/view/ttycWW\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// iq https://www.shadertoy.com/view/4sXXRN\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\nfloat boolSign(float v) {\n    return max(0., sign(v)) * 2. - 1.;\n}\n\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3                           v = vec3(PHI,1,0);\n    if (ap.x+ap.z*PHI > dot(ap,v)) v = vec3(1,0,PHI);\n    if (ap.z+ap.y*PHI > dot(ap,v)) v = vec3(0,PHI,1);\n    return v * 0.52573111 * boolSign(p);\n}\n\n// A vertex for the closest icosahedron face,\n// not necessary the closet vertex\n// from https://www.shadertoy.com/view/XtKSWc\nvec3 icosahedronVertexApprox(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI, 1, 0);\n    vec3 plane = vec3(1, PHI, -PHI - 1.);\n    if (dot(ap, plane) < 0.) {\n        v = vec3(1, 0, PHI);\n    }\n    return v * 0.52573111 * boolSign(p);\n}\n\n// Closest dodecahedron vertex\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI);\n    vec3 v2 = vec3(0, 1, PHI + 1.);\n    vec3 v3 = v2.yzx;\n    vec3 v4 = v2.zxy;\n    if (dot(ap,v2) > dot(ap,v)) v = v2;\n    if (dot(ap,v3) > dot(ap,v)) v = v3;\n    if (dot(ap,v4) > dot(ap,v)) v = v4;\n    return v * 0.35682209 * boolSign(p);\n}\n\n// If you don't need the verts ordered closest to furthest\n#define ALLOW_ANY_ORDER\n\n// Closest icosahedron face center, and face verts\nvoid icosahedronFaceAndVerts(vec3 p, out vec3 face, out vec3 a, out vec3 b, out vec3 c) {\n    \n    #ifdef ALLOW_ANY_ORDER\n        vec3 iv = icosahedronVertexApprox(p);\n    #else\n        vec3 iv = icosahedronVertex(p);\n    #endif\n    \n    vec3 dv = dodecahedronVertex(p);\n    \n    float r = PI * 2. / 3.;\n    \n    #ifndef ALLOW_ANY_ORDER\n        float side = boolSign(dot(p, cross(iv, dv)));\n        r *= side;\n    #endif\n    \n    vec3 iv2 = erot(iv, dv, -r);\n    vec3 iv3 = erot(iv, dv, r);\n    \n    face = dv * 0.794654; // Inradius of a unit bounded icosahedron\n    a = iv;\n    b = iv2;\n    c = iv3;\n}\n\n\nvec4 opU(vec4 a, vec4 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nstruct Model {\n    float d;\n    vec3 col;\n};\n\nModel map(vec3 p) {\n    vec3 col = vec3(.1);\n    \n    vec4 res = vec4(1e12, 0, 0, 0);\n    \n    // All faces and verts\n    \n    vec3 iv = icosahedronVertex(p);\n    vec3 dv = dodecahedronVertex(p) * 0.794654;\n    res = opU(res, vec4(length(p - dv) - .05, vec3(.2)));\n    res = opU(res, vec4(length(p - iv) - .1, vec3(.2)));\n    \n    // Cursor\n    \n    float t = iTime;\n    vec3 p2 = vec3(sin(t), cos(t), sin(t * .5)) * 1.3;\n    res = opU(res, vec4(length(p - p2) - .05, vec3(1)));\n    \n    // Closest face and vert to cursor\n    \n    vec3 face, a, b, c;\n    icosahedronFaceAndVerts(p2, face, a, b, c);\n    res = opU(res, vec4(length(p - face) - .06, vec3(1,0,1)));\n    res = opU(res, vec4(length(p - a) - .11, vec3(1,0,0)));\n    res = opU(res, vec4(length(p - b) - .11, vec3(0,1,0)));\n    res = opU(res, vec4(length(p - c) - .11, vec3(0,0,1)));\n    res = opU(res, vec4(udTriangle(a, b, c, p) - .01, vec3(.3,.1,.3)));\n    \n    return Model(res.x, res.yzw);\n}\n\n/*\n// Stress test\nModel map(vec3 p) {\n    Model m = Model(1e12, vec3(0));\n    for (int i = 0; i < 1000; i++) {\n        Model m2 = map2(p);\n        if (m2.d < m.d) {\n            m = m2;\n        }\n    }\n    return m;\n}\n*/\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,5);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.x <= 0.) {\n        im = vec2(.6,.3);\n    }\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 2.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        model = map(rayPosition);\n        dist = model.d;\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        col *= dot(vec3(0,1,0), nor) * .5 + .75;\n        float fog = 1. - exp((rayLength - 4.5) * -2.);\n        col = mix(col, bgcol, clamp(fog, 0., 1.));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 89, 89, 108], [110, 154, 221, 221, 873], [876, 886, 918, 918, 963], [965, 1041, 1079, 1079, 1141], [1199, 1199, 1224, 1224, 1265], [1267, 1267, 1290, 1290, 1336], [1338, 1368, 1400, 1400, 1627], [1629, 1756, 1794, 1794, 1997], [1999, 2030, 2063, 2063, 2352], [2438, 2489, 2578, 2578, 3092], [3095, 3095, 3121, 3121, 3182], [3230, 3230, 3249, 3249, 4185], [4408, 4477, 4503, 4503, 4704], [4706, 4706, 4756, 4756, 4899], [4901, 4901, 4958, 4958, 6270]], "test": "untested"}
{"id": "sssyDf", "name": "Fork Fork Neon  Irbis 377", "author": "Irbis", "description": "Neon effect (simple additive-composition)", "tags": ["2d"], "likes": 5, "viewed": 258, "published": 3, "date": "1642854438", "time_retrieved": "2024-07-30T17:07:56.818538", "image_code": "float stepping(float t){\n    if(t<0.)return -1.+pow(1.+t,1.2);\n    else return 1.-pow(1.-t,1.2);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    uv = normalize(uv) * length(uv);\n    for(int i=0;i<12;i++){\n        float t = iTime/4. + float(i)*3.141592/12.*(5.+1.*stepping(sin(iTime*0.2)));\n        vec2 p = vec2(cos(t),sin(t));\n        p *= cos(iTime/4. + float(i)*3.141592*cos(iTime/128.));\n        vec3 col = cos(vec3(0,1,-1)*3.141592*2./3.+3.141925*(iTime/1024.+float(i)/5.)) * 0.5 + 0.5;\n        fragColor += vec4(0.05/length(uv-p*0.9)*col,1.0);\n    }\n    fragColor.xyz = pow(fragColor.xyz,vec3(3.));\n    fragColor.w = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 98], [99, 99, 156, 156, 726]], "test": "untested"}
{"id": "fdXcDX", "name": "The Royal Banner of England", "author": "mla", "description": "[url]https://en.wikipedia.org/wiki/Royal_arms_of_England[/url]: first used by Richard I around 1198.\n\nFilled cubic Bezier curves, taken from the Wikipedia SVG, drawn as sequences of line segments, with some bounding boxes to stop things being too slow.", "tags": ["bezier", "flag", "fixedpoint", "svg", "arms"], "likes": 14, "viewed": 403, "published": 3, "date": "1642847716", "time_retrieved": "2024-07-30T17:07:57.874714", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Royal Banner of England, Matthew Arcus, mla. 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// https://en.wikipedia.org/wiki/Royal_arms_of_England, first used by Richard I\n// around 1198. This forms two quarters of what usually known as the Royal\n// Standard (but should really be the \"Royal Banner\").\n//\n// zoom in with mouse\n// 'x' draws progressively\n//\n// Filled cubic Bezier curves, taken from the Wikipedia SVG, drawn as sequences\n// of line segments, with some bounding boxes to stop things being too slow.\n// Using line segments makes it easy to compute filling with the usual winding\n// number calculation.\n//\n// Since the lions overlap slightly in the y-direction, we draw everything\n// twice in the overlapping region (which isn't wide). The code to do this\n// is a little ad hoc.\n//\n// I've tried various other speedups, but nothing that makes a huge amount of\n// difference (I get an adequate 37fps on my Intel box at 512x288). \n// Precalculating the segment bounding boxes doesn't help much & increases\n// the amount of static data considerably. Scanning all the bounding boxes\n// and making a list of boxes to revisit doesn't help much either.\n//\n// [Looks like accessing large amounts of static data is slow, so I've\n// encoded all of the coordinate pairs as 16 bit fixed point integers,\n// packed into 32 bit uints. This gets FPS (on Intel) up to 60 at 512x288].\n//\n// On Nvidia, omitting the const modifiers for the static data greatly increases\n// compilation time (which is about 4 seconds for GTX1650/Linux/FF) [now less\n// than a second with the fixed point data change].\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\n// The usual function, but also include segment in winding number computation\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  polywind(p,q,r);\n  p -= q; r -= q; // Relative to q\n  float t = dot(p,r)/dot(r,r);\n  t = clamp(t, 0.0, 1.0);\n  return length(p-t*r);\n}\n\n#if 0\n// Precalculated coefficients for Bezier curves\n// On Intel anyway, faster to calculate as we go though.\nconst vec4 beziercoeffs[] =\n  vec4[](vec4(1,0,0,0),\n         vec4(0.823975,0.164795,0.0109863,0.000244141),\n         vec4(0.669922,0.287109,0.0410156,0.00195312),\n         vec4(0.536377,0.371338,0.0856934,0.0065918),\n         vec4(0.421875,0.421875,0.140625,0.015625),\n         vec4(0.324951,0.443115,0.201416,0.0305176),\n         vec4(0.244141,0.439453,0.263672,0.0527344),\n         vec4(0.177979,0.415283,0.322998,0.0837402),\n         vec4(0.125,0.375,0.375,0.125),\n         vec4(0.0837402,0.322998,0.415283,0.177979),\n         vec4(0.0527344,0.263672,0.439453,0.244141),\n         vec4(0.0305176,0.201416,0.443115,0.324951),\n         vec4(0.015625,0.140625,0.421875,0.421875),\n         vec4(0.0065918,0.0856934,0.371338,0.536377),\n         vec4(0.00195312,0.0410156,0.287109,0.669922),\n         vec4(0.000244141,0.0109863,0.164795,0.823975),\n         vec4(0,0,0,1));\nconst int nbeziercoeffs = beziercoeffs.length();\nvec4 beziercoeff(int i) {\n  return beziercoeffs[i];\n}\n#else\nconst int nbeziercoeffs = 16;\nvec4 beziercoeff(int i) {\n  // Matrix formulation due to Shane.\n  const int N = nbeziercoeffs;\n  float t = float(i)/float(N);\n  float u = 1.0-t, t2 = t*t, u2 = u*u;\n  return vec4(u*u2,3.0*t*u2,3.0*u*t2,t*t2);\n}\n#endif\n\n// Distance to cubic Bezier curve.\n// Split the path into N subsegments.\nfloat bezier(vec2 p, mat4x2 m) {\n  // Since we spend most of the time deciding not to draw\n  // curves, the value of N doesn't seem to be time critical.\n  const int N = nbeziercoeffs;\n  vec2 q = m[0];\n  float d = 1e8;\n  for (int i = 1; i <= N; i++) {\n    vec2 r = m*beziercoeff(i);\n    d = min(d,segment(p,q,r));\n    q = r;\n  }\n  return d;\n}\n\nvec3 getcolor(int i) {\n  vec3 col = vec3(1,0,1);\n  // Colors from Wikipedia SVG\n  if (i == 0) col = vec3(0xa0,0,0)/255.0;\n  if (i == 1) col = vec3(0x0a,0x26,0x62)/255.0;\n  if (i == 2) col = vec3(0xff,0xd1,0x28)/255.0;\n  if (i == 3) col = vec3(0xff,0xd2,0x14)/255.0;\n  if (i == 4) col = vec3(0);\n  if (i == 5) col = vec3(0xa0,0,0)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvec2 decode(uint n) {\n  return vec2(n>>16,n&0xffffu)/64.0;\n}\n\nvec4 decode(uvec2 p) {\n  return vec4(decode(p.x),decode(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = fragCoord/iResolution.xy;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p -= mouse;\n    p *= 0.25;\n    p += mouse;\n  }\n  p.y = 1.0-p.y;\n  p *= vec2(500,250);\n  vec3 col = getcolor(0);\n  float eps = 2.0; // Allow for line width \n  float px = fwidth(p.x);\n  float lwidth = 0.5;\n  // The lions overlap in the y direction, so draw twice, with a shift up,\n  // where necessary. This is a bit of a bodge\n  int M = 2;\n  if (p.y < 77.0) M = 1;\n  else if (p.y < 154.0) p.y -= 77.0;\n  else p.y -= 154.0;\n  if (p.y > 15.0) M = 1; // Draw twice only in a thin band\n  //assert(M == 1); // Check banding\n  for (int j = 0; j < M; j++, p.y += 77.0) {\n    int N = paths.length();\n    if (key(CHAR_X)) N = min(int(2.0*iTime)%60,N); // Progressive effect\n    for (int i = 0; i < N; i++) {\n      vec4 box = decode(boxes[i]);\n      if (p.x >= box.x-eps && p.x <= box.z+eps && p.y >= box.y-eps && p.y <= box.w+eps) {\n        //assert(i != N-1); // With progressive drawing, show bounding boxes\n        int start = i == 0 ? 0 : paths[i-1];\n        int end = paths[i];\n        vec2 initpos = decode(points[start/2]); //vec2(points[start],points[start+1]);\n        vec2 p0 = initpos;\n        wind = 0;\n        float d = 1e8;\n        for (int j = start+2; j < end; j += 6) {\n          vec2 c0 = decode(points[(j+0)/2]);//vec2(points[j+0],points[j+1]);\n          vec2 c1 = decode(points[(j+2)/2]);//vec2(points[j+2],points[j+3]);\n          vec2 p1 = decode(points[(j+4)/2]);vec2(points[j+4],points[j+5]);\n          vec2 box1 = min(min(c0,c1),min(p0,p1))-eps;\n          vec2 box2 = max(max(c0,c1),max(p0,p1))+eps;\n          if (p.x < box1.x || p.y  < box1.y  || p.x > box2.x || p.y > box2.y) {\n            polywind(p,p0,p1);\n          } else {\n            d = min(d,bezier(p,mat4x2(p0,c0,c1,p1)));\n          }\n          p0 = p1;\n        }\n        polywind(p,p0,initpos); // Close curve if necessary\n        if (colors[i] != 0 && (wind&1) == 1) col = getcolor(colors[i]);;\n        col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n      }\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = 1.0-col;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst uint points[] = uint[](\n1023086715u, 1011159039u, 998510476u, 978587518u, 1008602819u, 1029115677u, 1051070385u, \n985666026u, 966398367u, 947196298u, 927928841u, 939593872u, 960761860u, 994513073u, \n1002115894u, 979178328u, 966398998u, 958076183u, 983110749u, 1002640464u, 1021908041u, \n1083577444u, 1081742612u, 1078334958u, 1067652746u, 1093473820u, 1107105133u, 1113855129u, \n1785270954u, 1759777642u, 1765676107u, 1771443499u, 1781535785u, 1793987495u, 1806504746u, \n161419226u, 137170948u, 120328394u, 105714012u, 129700117u, 148246786u, 163516753u, \n170003789u, 162860154u, 142805951u, 114298160u, 138218803u, 156831215u, 172035646u, \n203754858u, 197397685u, 189205519u, 173804453u, 195169197u, 215288779u, 218762517u, \n277875495u, 262474507u, 249629471u, 232590172u, 239602306u, 248187319u, 272763275u, \n259393533u, 250349361u, 237831859u, 221120151u, 237962775u, 256050653u, 280430337u, \n292881882u, 291898653u, 281609340u, 259589120u, 287114206u, 306512942u, 313001264u, \n341050963u, 345245127u, 350553419u, 348062817u, 362284183u, 367396171u, 362940036u, \n1838027821u, 1823085797u, 1826428346u, 1833440916u, 1841698230u, 1850021158u, 1858344109u, \n1954419137u, 1974407631u, 1986007417u, 1990398157u, 1969885389u, 1969885389u, 1949372621u, \n1922569334u, 1934300523u, 1953961237u, 1973621949u, 1958679702u, 1946096726u, 1941967806u, 1929843668u, 1923814421u, 1922569334u, 1922569334u, 1922569334u, 1922569334u, \n230626207u, 215815145u, 204674126u, 190780659u, 191370239u, 193860367u, 215093833u, \n1180503058u, 1179454798u, 1180044935u, 1225723757u, 1186533534u, 1127157977u, 1068503257u, 1037569649u, 1008799532u, 1007751385u, 996675788u, 991367272u, 973017192u, 961613928u, 944181908u, 998183572u, 972100989u, 1057625295u, 1072501611u, 1057232226u, 1124144509u, 1132401731u, 1147999248u, 1151603566u, 1159074544u, 1159271491u, 1153504497u, 1147934117u, 1183126904u, 1207374844u, 1227821685u, 1229460396u, 1221334176u, 1211176326u, 1260721568u, 1267209220u, 1273369189u, 1281823508u, 1283003351u, 1276646574u, 1313543271u, 1309545223u, 1326649931u, 1342575004u, 1375408661u, 1375408234u, 1375407833u, 1319964575u, 1319964177u, 1319963971u, 1340148952u, 1356598355u, 1343818658u, 1343818658u, 1331038961u, 1255738241u, 1255738241u, 1180503058u, 1180503058u, 1180503058u, 1180503058u, \n1007751385u, 1022693622u, 1033441533u, 1048383722u, \n998183572u, 1031738001u, 1031738001u, 1065292431u, \n829229832u, 959712008u, 1361708536u, 1458963960u, 1536951800u, 1610614452u, 1610614852u, 1610615377u, 1463159089u, 1405028657u, 1124534577u, 765791924u, 649792596u, 620564242u, 620564242u, 591335888u, 816322184u, 936971319u, 1186729015u, 1237453879u, 1299647990u, 1330449397u, 1410666918u, 1598885501u, 1730154109u, 1796148861u, 1831669545u, 1847595308u, 1725764012u, 1793528988u, 1832457197u, 1853625737u, 1875777101u, 1901794221u, 1911559533u, 1964774551u, 1940722243u, 1972113891u, 1959464894u, 1941966715u, 1963921181u, 1933577720u, 1893994051u, 1902906802u, 1904086279u, 1943997665u, 1923025872u, 1891175310u, 1852312528u, 1860963164u, 1869613746u, 1878264320u, 1802701172u, 1813974050u, 1784548386u, 1761676322u, 1765018356u, 1730153204u, 1679756020u, 1605832456u, 1440418462u, 1628310548u, 1669597185u, 1771243484u, 1729890121u, 1686898529u, 1641416831u, 1630209532u, 1583940878u, 1475151118u, 1342440718u, 1185089423u, 1127483279u, 1097926543u, 1075840599u, 1023346329u, 1035929391u, 1047267269u, 1046939739u, 1018562350u, 985138967u, 951650054u, 966985628u, 968558642u, 968362184u, 936576960u, 904857385u, 873072595u, 911476932u, 912460211u, 829229491u, \n598741454u, 608834190u, 607392630u, 606934106u, 586290292u, 576001058u, 566039500u, 555160846u, 539039009u, 521147709u, 521737377u, 521213089u, 519050245u, 505943323u, 482088370u, 457774468u, 464327864u, 460919857u, 456790960u, 445584571u, 430052736u, 402593156u, 404821243u, 408294521u, 402592716u, 385357163u, 361698635u, 339285380u, 346952940u, 350688341u, 347476926u, 323163325u, 298194222u, 268506315u, 279647345u, 290329617u, 294851421u, 276501477u, 238359623u, 245895837u, 236917858u, 196940743u, 195695209u, 170463967u, 138482114u, 158076797u, 130420367u, 163318705u, 191106421u, 207752368u, 229248064u, 229248468u, 229249221u, 344134288u, 373166054u, 342560900u, 314577093u, 300355370u, 313331474u, 326045426u, 333581892u, 290721476u, 276237830u, 277548180u, 289344693u, 300616880u, 309726226u, 293473406u, 286395281u, 303631169u, 259460228u, 260311428u, 270338368u, 230361191u, 263521907u, 287770281u, 270402969u, 330826615u, 332531246u, 360645954u, 387385010u, 359139289u, 320145775u, 370674970u, 386469338u, 419172201u, 457183229u, 501944351u, 541790220u, 541790220u, 581636090u, 590221540u, 590221540u, 598741454u, 598741454u, 598741454u, 598741454u, \n225579543u, 214700579u, 204214838u, 195695209u, \n230625608u, 202248455u, 186650498u, 158076797u, \n191106421u, 210898572u, 210898572u, 230625188u, \n270338368u, 280889567u, 287639925u, 295504324u, \n287770281u, 297928425u, 305072054u, 300550233u, \n332138076u, 334497415u, 339806053u, 338430058u, \n318116149u, 374673849u, 434573699u, 487461077u, \n602080847u, 613942485u, 639566649u, 637535933u, 654575007u, 672597368u, 658311087u, 679216794u, 688326519u, 667748776u, 696322303u, 693308623u, 659754122u, 668733093u, 656150753u, 629411609u, 650121366u, 608048000u, 590614847u, 572068614u, 553522152u, 534974806u, 513676166u, 470552824u, 496177026u, 467276044u, 463474240u, 492440795u, 492178644u, 492178644u, 491850957u, 466292010u, 485821126u, 502663917u, 504498822u, 502663752u, 505154066u, 473499998u, 501679463u, 529663811u, 535758181u, 544736360u, 561907319u, 576979933u, 595067983u, 602080847u, 602080847u, 602080847u, 602080847u, \n519243790u, 508495685u, 504105108u, 511838517u, \n658770601u, 676661796u, 669059963u, 661523421u, \n541722601u, 557254849u, 571214054u, 584517831u, 570034805u, 538643014u, 541722601u, 541722601u, 541722601u, 541722601u, \n568331043u, 580913912u, 591006500u, 597756866u, 592186414u, 583732351u, 573770947u, 573836344u, 576523182u, 568331043u, 568331043u, 568331043u, 568331043u, \n541265141u, 537464242u, 538447502u, 523243339u, 551161637u, 569184112u, 591269976u, 587075412u, 591924840u, 609095013u, 587796052u, 584322395u, 573377762u, 562629895u, 551947549u, 541265141u, 541265141u, 541265141u, 541265141u, \n548539647u, 548408969u, 544608127u, 540938430u, 560467932u, 572919728u, 595987904u, 586091916u, 579669288u, 574098617u, 566693100u, 558763282u, 548539647u, 548539647u, 548539647u, 548539647u, \n510987088u, 519506768u, 519506768u, 528026448u, 527437121u, 548736312u, 575147194u, 594546215u, 606998025u, 614272194u, 633146851u, 642780517u, 651168938u, \n1278413538u, 1307642584u, 1322584909u, 1330449397u, \n1851658771u, 1852379878u, 1845564208u, 1832326118u, \n1885868366u, 1885868648u, 1899303550u, 1901728681u, \n1909264578u, 1913065855u, 1909658190u, 1940197964u, \n1942687613u, 1928990585u, 1924272030u, 1916735415u, \n830016264u, 690227976u, 777586242u, 726598657u, 731972620u, 765068248u, 770573961u, 790103463u, 820642999u, 863241339u, 975832029u, 1232274802u, 1298859378u, 1417086322u, 1474691297u, 1543635318u, 1506411095u, 1479214178u, 1447298309u, 1506608389u, 1672610053u, 1746404263u, 1613103835u, 1507264676u, 1408370466u, 1415055233u, 1424951234u, 1440745421u, 1381304773u, 1349191514u, 1192298008u, 1119880579u, 1027671400u, 902301032u, 781059432u, 726075827u, 830015923u, \n1090720486u, 1083708157u, 1074336564u, 1071649663u, \n1124864841u, 1124733888u, 1127552015u, 1132467265u, \n648612487u, 627968613u, 616827358u, 609356079u, 598674168u, 622070850u, 648612487u, 648612487u, 648612487u, 648612487u);\nconst uvec2 boxes[] = uvec2[](\n  uvec2(978587331u,1051070587u),\n  uvec2(927928324u,994513417u),\n  uvec2(958075702u,1021908247u),\n  uvec2(1067652196u,1113855626u),\n  uvec2(1759777450u,1806505259u),\n  uvec2(105713626u,163516764u),\n  uvec2(114297791u,172035646u),\n  uvec2(173804453u,218762602u),\n  uvec2(232589707u,277875548u),\n  uvec2(221119965u,280430589u),\n  uvec2(259589086u,313001434u),\n  uvec2(341050465u,367396484u),\n  uvec2(1823085613u,1858344596u),\n  uvec2(1949372621u,1990398415u),\n  uvec2(1922569150u,1973622123u),\n  uvec2(190779977u,230626547u),\n  uvec2(944179953u,1375409573u),\n  uvec2(1007751385u,1048383741u),\n  uvec2(998183567u,1065292436u),\n  uvec2(591332622u,1972115080u),\n  uvec2(130417527u,608834994u),\n  uvec2(195695127u,225579625u),\n  uvec2(158076797u,230625608u),\n  uvec2(191106421u,230625188u),\n  uvec2(270338271u,295504324u),\n  uvec2(287770281u,305072217u),\n  uvec2(332138076u,339806314u),\n  uvec2(318116053u,487461305u),\n  uvec2(463471417u,696325096u),\n  uvec2(504104773u,519244085u),\n  uvec2(658770468u,676662237u),\n  uvec2(538642409u,584518261u),\n  uvec2(568331000u,597757123u),\n  uvec2(523242722u,609095768u),\n  uvec2(540937401u,595988670u),\n  uvec2(510987088u,651169319u),\n  uvec2(1278413528u,1330449397u),\n  uvec2(1832325651u,1852380134u),\n  uvec2(1885868366u,1901728681u),\n  uvec2(1909264578u,1940197966u),\n  uvec2(1916735353u,1942687671u),\n  uvec2(690225377u,1746406152u),\n  uvec2(1071649510u,1090720639u),\n  uvec2(1124733769u,1132467265u),\n  uvec2(598673711u,648612930u)\n);\n\nconst int paths[] = int[](\n  14,28,42,56,70,84,98,112,126,140,154,168,182,196,222,236,358,366,374,556,750,758,766,774,782,790,798,806,904,912,920,940,966,1004,1036,1062,1070,1078,1086,1094,1102,1176,1184,1192,1212);\n\nconst int colors[boxes.length()] =\n  int[](1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,1, 1,2,2,2,2, 2,0,0,0,0, 0,0, 0,3,0,0,4,4,5,1, 0,0,0,0,0, 2,3,0,0,4);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1829, 1860, 1899, 1934, 2119], [2121, 2199, 2238, 2238, 2375], [3715, 3788, 3820, 3940, 4129], [4131, 4131, 4153, 4153, 4511], [4513, 4513, 4534, 4534, 4573], [4575, 4575, 4597, 4597, 4639], [4641, 4641, 4698, 4698, 6844]], "test": "untested"}
{"id": "sdsyDX", "name": "Playing around shader2", "author": "MinimilisticBits", "description": "sgs", "tags": ["sdfsdg"], "likes": 41, "viewed": 1162, "published": 3, "date": "1642847595", "time_retrieved": "2024-07-30T17:07:58.680559", "image_code": "\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\nvec3 blur(vec2 uv, float r){\nvec3 c = vec3(0.);\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec4 c2 = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyzw;\n     vec3 col = c2.xyz;\n     col = clamp(col,0.,1.);\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec4 c2 = texture(iChannel0, (p+coords)/iResolution.xy).xyzw;\n    vec3 c = c2.xyz / (c2.w+1.);\n    //c = c*c *1.8;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec3 col = texture(iChannel0, uv).xyz;\n    // Output to screen\n    vec3 col = blur2(uv, length((uv*2.0-1.0)*3.));\n    float off = texture(iChannel0, uv).w;\n     vec3 rad;\n    vec2 offset2 = (fragCoord - iResolution.xy/2.)*1.;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,15.-length(uv*2.0-1.)*1.5, float(i)/20.)*1.;\n       rad.x += texture(iChannel0, (offset+offset2*0.044)/iResolution.xy).x;\n       rad.y += texture(iChannel0, (offset)/iResolution.xy).y;\n       rad.z += texture(iChannel0, (offset-offset2*0.044)/iResolution.xy).z;\n\n    }\n    rad /= 16.;\n    \n    col += rad*0.4;\n    col = clamp(col, 0., 1.);\n     col = vec3(1.)-exp(-1.4*col);\n\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.4)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.2,1.2);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\ncol = pow(col, vec3(1.5))*1.8;\n//col = pow(col, vec3(0.7,0.8,0.9));\ncol = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float ring(vec2 p, vec2 s){\nreturn length(normalize(p)*s.x - p)-s.y;\n}\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x,a.y);\n}\n\nvec3 pal(float es, vec3 a){\nreturn 0.5 + 0.5*cos(2.0*3.14159*es + a);\n}\n\nvec2 rot(vec2 p, float s){\nfloat l = length(p);\np/=l;\nfloat ang = (p.y < 0.)?2.0*3.14159 - acos(p.x):acos(p.x);\nang += s;\nreturn l*vec2(cos(ang), sin(ang));\n}\n\n//NOT MY CODE\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n/////////////\n\nfloat escape = 0.;\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n           escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\nfloat jb3(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n            escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\n  float DEmine(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\nfor(int i = 0; i < 7; i++){\np*=4.79;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\nfloat m = length(p.xyz);\n\np/=dot(p.xyz,p.xyz)+mod(m, 1.);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\n\nreturn length(p.xyz)/p.w;\n}\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = .1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\n\nfloat de22( vec3 p ){\n    vec3 CSize = vec3(1., 1.7, 1.);\n    p = p.xzy;\n    float scale = 1.1;\n    for( int i=0; i < 8;i++ ){\n      p = 2.0*clamp(p, -CSize, CSize) - p;\n      float r2 = dot(p,p+sin(p.z*.3));\n      float k = max((2.)/(r2), .5);\n      p *= k; scale *= k;\n    }\n    float l = length(p.xy);\n    float rxy = l - 1.0;\n    float n = l * p.z;\n    rxy = max(rxy, (n) / 8.);\n    return (rxy) / abs(scale);\n  }\n/////////////////////////////////////\nfloat DEeerr(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               // p.xyz = abs(p.xyz);\n\n        //box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.,1.0));\n        p.xyz=abs(p.xyz)-vec3(3.5,.5,3.3);\n       //p*=1.2;\np.yxz -= sin(float(i)*1.)*0.9;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\nfloat newde(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\np.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\np.xy = (p.x > p.y)?p.yx:p.xy;\n\nfor(int i = 0; i < 12; i++){\n//p = abs(p);\n//p.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\n//p.xy = (p.x > p.y)?p.yx:p.xy;\n\np.xyz = mod(p.xyz-1., 2.)-1.;\np *= 1.1/clamp(dot(p.xyz,p.xyz),0.,1.2);\n//p.xyz -= vec3(2.,0.4,0.6);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\np/=p.w;\nreturn abs(p.x)*0.25;\n}\n\nfloat fractal(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.4+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.5,1.));\n        p.xyz-=vec3(0.2+rndf(seed)*0.2,0.6-rndf(seed)*0.3,2.3);\n        p*=1.2-rndf(seed)*0.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\n\nfloat fractal_de46(vec3 p){\n    float s = 2.;\n    float e = 0.;\n    escape = 0.;\n    for(int j=0;++j<7;){\n        p.xz=abs(p.xz)-2.3,\n        p.z>p.x?p=p.zyx:p,\n        p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.y=.9-abs(p.y-.4),\n        e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n        2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n        p=e*p-vec3(7,1,1),\n        s*=e;\n        escape+=exp(-0.2*dot(p,p));\n        }\n    return length(p)/s;\n}\n\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel1, (p+0.5)/256.0, 0.0 ).xy;\n}\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin(6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\n\nvec3 lens(vec2 p, vec2 mouse,inout uint k){\nvec3 col = vec3(exp(-20.*length(mouse-p)));\ncol += exp(-20.*length(-mouse*rndf(k)*0.5-p));\ncol += exp(-ring(-mouse*0.4-p, vec2(0.7, 0.01))*20.)\n*sin(texture(iChannel0, normalize(p*rndf(k))).x);\ncol *= pal(exp(-length(-mouse*rndf(k)*0.9-p)), vec3(0.9,0.6,0.2));\nfor(int i = 0;i < 5; i++){\ncol += exp(-ring(mouse*2.*(0.1+float(i)/5.0)-p, vec2(0.1-float(i)/15.0, 0.001*float(i+1)))*20.);\n}\ncol *= pal(length(mouse*rndf(k)-p), vec3(0.9,0.2,0.2))*0.8;//\n//col += exp(-length(mouse-p))*vec3(0.9,0.6,0.2)\n//*sin(texture(iChannel0, normalize(mouse-p)).x)*exp(-length(mouse-p)*5.)*2.;\ncol += exp(-ring(mouse*0.5-p, vec2(0.9,0.01))*20.)*0.4;\n//col *= pal(length(mouse-p)*1., vec3(0.9,0.4,0.9));\ncol += exp(-(abs(box(-mouse*rndf(k)-p, vec2(0.1)))+0.2)*20.);\ncol += exp(-jb3((vec3(p*1.,iTime*0.1))/12.)*10000.);\ncol *= pal(escape, vec3(0.9,0.6,0.2));\n\ncol += exp(-voronoi(p).x*200.);\ncol *= pal(escape, vec3(0.9,0.6,0.2));\ncol *= pal(length(mouse-p), vec3(0.9,0.5,0.2));\nreturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ///NOT MY CODE///\n    uint r = uint(uint(fragCoord.x) * uint(1973) \n    + uint(fragCoord.y) * uint(9277) \n    + uint(iFrame) * uint(26699)) | uint(1);\n    \n    ///////////////\n    \n    \nuv = uv * 2.0 - 1.0;\nuv.x *= 1.3;\nuv.y /= 1.3;\nuv *= 4.5;\n    // Time varying pixel color\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 10; i++){\n    uint k = uint(i+1);\n        float offset = rndf(k);\n        col += lens(rot(uv*(rndf(k)+0.04), offset*iTime), vec2(cos(offset*2.*3.14159+iTime), sin(offset*2.*3.14159-iTime)), k)*offset*0.4;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float dd = 0.9;\nfloat fal = 1.;\nfloat off2 = 2.;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 38, 61, 61, 215], [252, 252, 280, 280, 779], [783, 783, 813, 813, 1321], [1323, 1323, 1380, 1430, 2607]], "test": "untested"}
{"id": "7sscDX", "name": "Points Mirror", "author": "ololeecn", "description": "Points Mirror", "tags": ["mirror"], "likes": 0, "viewed": 209, "published": 3, "date": "1642845605", "time_retrieved": "2024-07-30T17:07:59.552230", "image_code": "#define N 4.0\nvec2 tri(vec2 x){\n    return mod(x,1.0/N)*N;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor= texture(iChannel0,tri(uv));\n\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sscDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 31, 31, 60], [62, 62, 119, 119, 205]], "test": "untested"}
{"id": "NdscDf", "name": "Playing around shader", "author": "MinimilisticBits", "description": "sdg", "tags": ["sdfsdg"], "likes": 184, "viewed": 11645, "published": 3, "date": "1642825588", "time_retrieved": "2024-07-30T17:08:00.321173", "image_code": "\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\nvec3 blur(vec2 uv, float r){\nvec3 c = vec3(0.);\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec4 c2 = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyzw;\n     vec3 col = c2.xyz;\n     col = clamp(col,0.,1.);\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec4 c2 = texture(iChannel0, (p+coords)/iResolution.xy).xyzw;\n    vec3 c = c2.xyz / (c2.w+1.);\n    //c = c*c *1.8;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec3 col = texture(iChannel0, uv).xyz;\n    // Output to screen\n    vec3 col = blur2(uv, length((uv*2.0-1.0)*5.));\n    float off = texture(iChannel0, uv).w;\n     vec3 rad;\n    vec2 offset2 = (fragCoord - iResolution.xy/2.)*1.;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,15.-length(uv*2.0-1.)*1.5, float(i)/20.)*1.;\n       rad.x += texture(iChannel0, (offset+offset2*0.034)/iResolution.xy).x;\n       rad.y += texture(iChannel0, (offset)/iResolution.xy).y;\n       rad.z += texture(iChannel0, (offset-offset2*0.034)/iResolution.xy).z;\n\n    }\n    rad /= 16.;\n    \n    col += rad*0.8;\n    col = clamp(col, 0., 1.);\n     col = vec3(1.)-exp(-1.3*col);\n\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.4)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.1);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\ncol = pow(col, vec3(1.5))*1.8;\n//col = pow(col, vec3(0.7,0.8,0.9));\ncol = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float ring(vec2 p, vec2 s){\nreturn length(normalize(p)*s.x - p)-s.y;\n}\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x,a.y);\n}\n\nvec3 pal(float es, vec3 a){\nreturn 0.5 + 0.5*cos(2.0*3.14159*es + a);\n}\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat g = c;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\n\n//NOT MY CODE\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n/////////////\n\nfloat escape = 0.;\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n           escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\nfloat jb3(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n            escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\n  float DEmine(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\nfor(int i = 0; i < 7; i++){\np*=4.79;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\nfloat m = length(p.xyz);\n\np/=dot(p.xyz,p.xyz)+mod(m, 1.);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\n\nreturn length(p.xyz)/p.w;\n}\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = .1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\n\nfloat de22( vec3 p ){\n    vec3 CSize = vec3(1., 1.7, 1.);\n    p = p.xzy;\n    float scale = 1.1;\n    for( int i=0; i < 8;i++ ){\n      p = 2.0*clamp(p, -CSize, CSize) - p;\n      float r2 = dot(p,p+sin(p.z*.3));\n      float k = max((2.)/(r2), .5);\n      p *= k; scale *= k;\n    }\n    float l = length(p.xy);\n    float rxy = l - 1.0;\n    float n = l * p.z;\n    rxy = max(rxy, (n) / 8.);\n    return (rxy) / abs(scale);\n  }\n/////////////////////////////////////\nfloat DEeerr(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               // p.xyz = abs(p.xyz);\n\n        //box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.,1.0));\n        p.xyz=abs(p.xyz)-vec3(3.5,.5,3.3);\n       //p*=1.2;\np.yxz -= sin(float(i)*1.)*0.9;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\nfloat newde(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\np.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\np.xy = (p.x > p.y)?p.yx:p.xy;\n\nfor(int i = 0; i < 12; i++){\n//p = abs(p);\n//p.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\n//p.xy = (p.x > p.y)?p.yx:p.xy;\n\np.xyz = mod(p.xyz-1., 2.)-1.;\np *= 1.1/clamp(dot(p.xyz,p.xyz),0.,1.2);\n//p.xyz -= vec3(2.,0.4,0.6);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\np/=p.w;\nreturn abs(p.x)*0.25;\n}\n\nfloat fractal(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.4+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.5,1.));\n        p.xyz-=vec3(0.2+rndf(seed)*0.2,0.6-rndf(seed)*0.3,2.3);\n        p*=1.2-rndf(seed)*0.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\n\nfloat fractal_de46(vec3 p){\n    float s = 2.;\n    float e = 0.;\n    escape = 0.;\n    for(int j=0;++j<7;){\n        p.xz=abs(p.xz)-2.3,\n        p.z>p.x?p=p.zyx:p,\n        p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.y=.9-abs(p.y-.4),\n        e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n        2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n        p=e*p-vec3(7,1,1),\n        s*=e;\n        escape+=exp(-0.2*dot(p,p));\n        }\n    return length(p)/s;\n}\n\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel1, (p+0.5)/256.0, 0.0 ).xy;\n}\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin(6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\n\nvec3 lens(vec2 p, vec2 mouse,inout uint k){\nvec3 col = vec3(exp(-20.*length(mouse-p)));\ncol += exp(-20.*length(-mouse*rndf(k)*0.5-p));\ncol += exp(-ring(-mouse*0.4-p, vec2(0.7, 0.01))*20.)\n*sin(texture(iChannel0, normalize(p*rndf(k))).x);\ncol *= pal(exp(-length(-mouse*rndf(k)*0.9-p)), vec3(0.9,0.5,0.9));\nfor(int i = 0;i < 5; i++){\ncol += exp(-ring(mouse*2.*(0.1+float(i)/5.0)-p, vec2(0.1-float(i)/15.0, 0.001*float(i+1)))*20.);\n}\ncol *= pal(length(mouse*rndf(k)-p), vec3(0.9,0.5,0.4))*0.4;//\n//col += exp(-length(mouse-p))*vec3(0.9,0.6,0.2)\n//*sin(texture(iChannel0, normalize(mouse-p)).x)*exp(-length(mouse-p)*5.)*2.;\n//col += exp(-length(mouse-p)*10.)*2.;\n//col *= pal(length(-mouse-p)*10., vec3(0.9,0.4,0.9));\ncol += exp(-(abs(box(-mouse*rndf(k)-p, vec2(0.1)))+0.2)*20.);\ncol += exp(-jb3((vec3(p*2.,iTime*0.4))/2.)*1000.);\ncol *= pal(escape, vec3(0.9,0.4,0.2));\n\ncol += exp(-voronoi(p).x*200.);\ncol *= pal(escape, vec3(0.9,0.4,0.2));\n\nreturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ///NOT MY CODE///\n    uint r = uint(uint(fragCoord.x) * uint(1973) \n    + uint(fragCoord.y) * uint(9277) \n    + uint(iFrame) * uint(26699)) | uint(1);\n    \n    ///////////////\n    \n    \nuv = uv * 2.0 - 1.0;\nuv.x *= 1.3;\nuv.y /= 1.3;\nuv *= 3.5;\n    // Time varying pixel color\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 15; i++){\n    uint k = uint(i+1);\n        float offset = rndf(k);\n        col += lens(rot(uv*(rndf(k)+0.04), offset*iTime), vec2(cos(offset*2.*3.14159+iTime), sin(offset*2.*3.14159-iTime)), k)*offset*0.4;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdscDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 38, 61, 61, 215], [252, 252, 280, 280, 779], [783, 783, 813, 813, 1321], [1323, 1323, 1380, 1430, 2607]], "test": "untested"}
{"id": "fslcDS", "name": "Trippy Triangle", "author": "Tater", "description": "I left some camera controls as a define if you want to break the illusion :) ", "tags": ["3d", "raymarching", "penrose", "impossible", "penrosetriangle"], "likes": 293, "viewed": 9210, "published": 3, "date": "1642819492", "time_retrieved": "2024-07-30T17:08:01.151951", "image_code": "#define STEPS 250.0\n#define MDIST 100.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n\n//Comment to remove triangle wobble\n#define WOBBLE \n\n//ADJUST AA HERE\n#define AA 1.0\n\n//Camera Control\n//#define CAM\n\n//based on ideas from \n//https://www.shadertoy.com/view/fsVSzw\n//https://www.shadertoy.com/view/MscSDB\n//https://www.shadertoy.com/view/3ddGzn\n#define h13(n) fract((n)*vec3(12.9898,78.233,45.6114)*43758.5453123)\nvec2 vor(vec2 v, vec3 p, vec3 s){\n    p = abs(fract(p-s)-0.5);\n    float a = max(p.x,max(p.y,p.z));\n    float b = min(v.x,a);\n    float c = max(v.x,min(v.y,a));\n    return vec2(b,c);\n}\n\nfloat vorMap(vec3 p){\n    vec2 v = vec2(5.0);\n    v = vor(v,p,h13(0.96));\n    p.xy*=rot(1.2);\n    v = vor(v,p,h13(0.55));\n    p.yz*=rot(2.);\n    v = vor(v,p,h13(0.718));\n    p.zx*=rot(2.7);\n    v = vor(v,p,h13(0.3));\n    return v.y-v.x; \n}\n\n//box sdf\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat va = 0.; //voronoi animations\nfloat sa = 0.; //size change animation\nfloat rlg; //global ray length\nbool hitonce = false; //for tracking complications with the voronoi \n\n\n//I put quite a lot of effort into making the normals inside the voronoi correct but \n//in the end the normals are only partially correct and I barely used them, however\n//the code is still messy from my failed attempt :)\nvec2 map(vec3 p, vec3 n){\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    vec3 po = p;\n    vec3 no = n;\n    p-=n;\n    float len = 9.5;\n    len+=sa;\n    float len2 = len-1.0;\n    p.x-=(len/2.0);\n    a.x = box(p,vec3(1,1,len));\n    a.x = min(a.x,box(p-vec3(0,len2,len2),vec3(1,len,1)));\n    a.x = min(a.x,box(p-vec3(-len2,0,-len2),vec3(len,1,1)));\n    float tip = box(p-vec3(len2,len2*2.0,len2),vec3(len2,1,1));   \n    float cut = (p.xz*=rot(pi/4.0-0.15)).y;\n    tip = max(-cut+len2/2.0,tip);\n    a.x = min(a.x,tip);\n    b.x = tip;\n    a.x-=0.4;\n    p = po;\n    p.xz*=rot(pi/4.0);\n    p.xy*=rot(-0.9553155);\n    po = p;\n    n.xz*=rot(pi/4.0);\n    n.xy*=rot(-0.9553155);\n    p.xz-=n.xy;\n    p.xz*=rot(-iTime*0.3);\n    if(hitonce)a.x = max(a.x,-vorMap(vec3(p.x,p.z,rlg+n.z)*0.35+3.)+va*1.6);\n    p = po;\n    b.y = 3.0;\n    p-=n;\n    p.xz*=rot(pi/6.0);\n    p.x+=1.75;\n    p.z+=0.4;\n    po = p;\n    for(float i = 0.; i<3.; i++){ //blocks\n        b.y+=i;\n        p.xz*=rot((2.0*pi/3.0)*i);\n        float t = (iTime+i*((2.0*pi)/9.0))*3.;\n        p.y-=35.-50.*step(sin(t),0.);\n        p.x+=4.5;\n        p.xy*=rot(t);\n        p.x-=4.5;\n        p.xz*=rot(t);\n        b.x = box(p,vec3(1.5,.5,.5))-0.25;\n        a = (a.x<b.x)?a:b;\n        p = po;\n    }\n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.0001,0);\n    return normalize(map(p,vec3(0)).x-vec3(\n    map(p,e.xyy).x,\n    map(p,e.yxy).x,\n    map(p,e.yyx).x));\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    uv.x-=0.025;\n    vec2 uv2 = uv;\n    vec2 uv3 = uv;\n    \n    //Calculating the animation for the size wobble and voronoi crumble\n    uv2.y-=0.1;\n    uv2*=rot(iTime*1.25);\n    float ang =atan(uv2.x,uv2.y)/(pi*2.)+0.5;\n    float range = 0.175;\n    #ifdef WOBBLE\n    sa = sin(ang*pi*2.+iTime*2.5)*0.3;\n    #endif\n    ang = smoothstep(0.0,range,ang)*smoothstep(0.0,range,1.0-ang);\n    va = (1.0-ang)*0.175;\n    uv*=rot(-pi/6.0);\n    \n    vec3 ro = vec3(5,5,5)*6.5;\n    \n    #ifdef CAM\n    if(iMouse.z>0.){\n        ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n        ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }    \n    #endif\n    \n    //maybe there is an easier way to make an orthographic target camera\n    //but this is what I figured out\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f+uv.x*r+uv.y*cross(f,r);\n    ro+=(rd-f)*17.0;\n    rd=f;\n\n    vec3 p = ro;\n    float rl = 0.;\n    vec2 d= vec2(0);\n    float shad = 0.;\n    float rlh = 0.;\n    float i2 = 0.; \n    \n    //Spaghetified raymarcher \n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*rl;\n        d = map(p, vec3(0));\n        rl+=d.x;\n        if((d.x)<0.0001){\n            shad = i2/STEPS;\n            if(hitonce)break;\n            hitonce = true;\n            rlh = rl;\n        }\n        if(rl>MDIST||(!hitonce&&i>STEPS-2.)){\n            d.y = 0.;\n            break;\n        }\n        rlg = rl-rlh;\n        if(hitonce&&rlg>3.0){hitonce = false; i2 = 0.;}  \n        if(hitonce)i2++;\n    }\n    //Color Surface\n    if(d.y>0.0){\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 ld = normalize(vec3(0,1,0));\n        float spec = pow(max(0.,dot(r,ld)),13.0);\n\n        //Color the triangle\n        vec3 n2 = n*0.65+0.35;\n        col += mix(vec3(1,0,0),vec3(0,1,0),sat(uv3.y*1.1))*n2.r;\n        uv3*=rot(-(2.0*pi)/3.0);\n        col += mix(vec3(0,1.0,0),vec3(0,0,1),sat(uv3.y*1.1))*n2.g;\n        uv3*=rot(-(2.0*pi)/3.0);\n        col += mix(vec3(0,0,1),vec3(1,0,0),sat(uv3.y*1.1))*n2.b;\n        \n\n        \n        //NuSan SSS\n        float sss=0.5;\n        float sssteps = 10.;\n        for(float i=1.; i<sssteps; ++i){\n            float dist = i*0.2;\n            sss += smoothstep(0.,1.,map(p+ld*dist,vec3(0)).x/dist)/(sssteps*1.5);\n        }\n        sss = clamp(sss,0.0,1.0);\n        \n        //blackle AO\n        #define AO(a,n,p) smoothstep(-a,a,map(p,-n*a).x)\n        float ao = AO(1.9,n,p)*AO(3.,n,p)*AO(7.,n,p);\n        \n        //Apply AO on the triangle\n        if(rlg<0.001){\n            col*=mix(ao,1.0,0.2);\n        }\n        //Color the inside of the crumbled bits \n        else {\n            col = vec3(0.2-shad);\n        }\n        //Color the moving blocks\n        if(d.y>1.0){\n            col = (n*0.6+0.4)*vec3(sss)+spec;\n        }\n        //a bit of gamma correction\n        col = pow(col,vec3(0.7));\n    }\n    //Color Background\n    else{\n        vec3 bg = mix(vec3(0.345,0.780,0.988),vec3(0.361,0.020,0.839),length(uv));\n        col = bg;\n    }\n    fragColor = vec4(col,1.0);\n}\n\n//External AA, (I compacted it for fun)\nvoid mainImage(out vec4 O,vec2 C){\n    float px=1./AA,i,j;vec4 cl2,cl;\n    if(AA==1.){render(cl,C);O=cl;return;}\n    for(i=0.;i<AA +min(iTime,0.0);i++){for(j=0.;j<AA;j++){\n    vec2 C2 = vec2(C.x+px*i,C.y+px*j);\n    render(cl2,C2);cl+=cl2;\n    rlg=0.; hitonce = false;\n    }}cl/=AA*AA;O=cl;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[477, 477, 510, 510, 661], [663, 663, 684, 684, 902], [904, 914, 940, 940, 1023], [1203, 1425, 1450, 1450, 2680], [2681, 2681, 2699, 2699, 2835], [2837, 2837, 2888, 2888, 6031], [6033, 6073, 6107, 6107, 6364]], "test": "untested"}
{"id": "fsscWf", "name": "Soothing Movement ", "author": "byt3_m3chanic", "description": "Saw this done in Blender / Geometry nodes and wanted to see if I could make it in a shader! [url]https://twitter.com/frktnv/status/1484167941025316867[/url]", "tags": ["raymarching", "reflection", "spheres", "replication"], "likes": 32, "viewed": 424, "published": 3, "date": "1642817782", "time_retrieved": "2024-07-30T17:08:02.156266", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Soothing Movement | Twitter Replication\n    01/18/22 @byt3_m3chanic \n    \n    Saw this done in Blender / Geometry nodes and wanted to see if \n    I could make it in a shader! https://twitter.com/frktnv/status/1484167941025316867\n\n    Using ABS to mirror movement - not sure I have it totally correct. Still stumped on\n    how to do the coloring as in the tweet... but I like the movement.\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n#define MAX_DIST    175.\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat capp( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nvec3 hp,hitPoint;\nfloat tmod,ga1,ga2,ga3,ga4,ga5;\nmat2 rpi,rnp,rg1,rg2,rg3,rg4,rg1a,rg2a,rg3a,rg4a;\n\nconst float scale = 4.;\nconst float quad = scale/2.;\nconst float cell = quad/2.;\nconst float spce = cell/2.;\nconst vec2 l = vec2(scale,scale);\nconst vec2 s = l*2.;\n\nvec2 map(vec3 q3) {\n    q3.y+=1.5;\n    q3.x+=T*.4;\n    vec2 res = vec2(1e5,0.);\n\n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    \n    float ld=1e5,lf=1e5,lb=1e5,bx=1e5;\n    \n    // Multi Tap distance map picked up from @Shane\n    // https://www.shadertoy.com/view/WtffDS\n    for(int i = 0; i<4; i++) {\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\t// Block center.\n        p = q3.xz - ct*s;\t\t\t\t// Local coordinates. \n        ip = floor(p/s) + .5;\t\t\t// Local tile ID. \n        p -= (ip)*s; \t\t\t\t\t// New local position.\t\t   \n        vec2 idi = (ip + ct)*s;\t\t\t// Correct position & tile ID.\n\n        vec3 q = vec3(p.x,q3.y,p.y);\n\n        vec3 q1 = vec3(p.x+cell,q3.y,p.y+cell);\n        q1.xz=abs(abs(q1.xz)-scale)-quad;\n \n        if(tmod<1.){\n            q1.z+=ga1*quad;\n            q1.yz*=rg2;\n        }else if(tmod<2.){\n            q1.z+=quad;\n            q1.x+=ga2*quad;\n            q1.yz*=rnp;\n            q1.yx*=rg3;\n\n        }else if(tmod<3.){\n            q1.z-=quad;\n            q1.x-=quad;\n            q1.z+=ga3*quad;\n            q1.yz*=rg2a;\n        } else {\n            q1.x+=quad;\n            q1.x-=ga4*quad;\n            q1.yx*=rpi;\n            q1.yx*=rg3a;\n        }\n\n        float s1 = length(q1)-.65;\n\n        s1=max(box(q1+vec3(spce,0,spce),vec3(.5,1,.5)),s1);\n        ld = min(ld,s1);\n\n        if(ld<res.x) {\n            res = vec2(ld,1.);hp=q1;\n        }\n\n        q.xz=abs(abs(q.xz)-quad)-cell;\n        lb = min( capp(q,.05,1.), bx); \n        lb = min( capp(q,.05,1.), lb);\n    }\n\n    if(lb<res.x) {\n        res = vec2(lb,5.);\n        hp=q3;\n    }\n        \n    float fx = q3.y+.575;\n    if(fx<res.x) {\n        res = vec2(fx,6.);\n        hp=q3;\n    }\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        t.x *= .8;\n        if(t.x<1e-4) hit = true;\n        d += t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>175.) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 128);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-1.5,8,-2.5);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        float t=.025;\n        for( int i =0; i<16; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h * .9;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 11.);\n        fresnel = mix(.0, .9, fresnel);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n\n        \n        if(m==1.) {\n           vec2 uv = fract((hitPoint.xz+cell)*spce)-.5;\n           //vec2 id = floor((hitPoint.xz+cell)/quad);\n           h=vec3(0.004,0.322,0.616);\n           \n           //if(mod(id.x+id.y,2.)<1.) h = (fl.x<fl.y)?vec3(0.180,0.761,0.216):vec3(0.180,0.569,0.761);\n           float cir=length(uv)-.25;\n           cir=abs(abs(abs(abs(cir)-.04)-.02)-.01)-.0045;\n           \n           cir=smoothstep(.0011,.001,cir);\n           h=mix(h,vec3(1.000,0.584,0.000),cir);\n           ref = clamp(h-fresnel,vec3(0),vec3(1));\n        }\n        if(m==5.) {\n            h=vec3(.3);\n            ref = clamp(vec3(.3)-fresnel,vec3(0),vec3(1));\n        }\n\n        if(m==6.) {\n            vec2 uv = fract(hitPoint.xz*.5)-.5;\n            h=vec3(0.796,0.737,0.584);\n            ref=vec3(.0);\n            if(uv.x*uv.y>0.) {\n                h = vec3(.2);\n                ref = clamp(h-fresnel,vec3(0),vec3(1));\n           }\n        }\n\n\n        RC = h * diff + min(spec,shdw);\n        if(bnc<2) RC = mix(RC,vec3(.05), 1.-exp(-.0025*d*d*d));\n        \n        ro = p+n*.1;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.149,0.157,0.173);\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tmod = mod(T*.5,4.);\n    float t1 = lsp(0.0, 1.0, tmod);\n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n\n    float t2 = lsp(1.0, 2.0, tmod);\n    ga2 = eoc(t2);\n    ga2 = ga2*ga2*ga2;\n    \n    float t3 = lsp(2.0, 3.0, tmod);\n    ga3 = eoc(t3);\n    ga3 = ga3*ga3*ga3;\n\n    float t4 = lsp(3.0, 4.0, tmod);\n    ga4 = eoc(t4);\n    ga4 = ga4*ga4*ga4;\n    \n    rpi = rot(PI);\n    rnp = rot(-PI);\n\n    rg2 = rot(-ga1*PI);\n    rg3 = rot(ga2*PI);\n\n    rg2a = rot(-ga3*PI);\n    rg3a = rot(ga4*PI);\n\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 5.;\n    vec3 ro = vec3(uv*zoom,-zoom-2.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    mat2 rx =rot(.58);\n    mat2 ry =rot(-.68);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    C = mix(C,vec3(.05), 1.-exp(-.00015*fA*fA*fA));\n    C = mix(C,FC,smoothstep(0.,1.,f*0.015));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsscWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[696, 696, 717, 717, 779], [780, 780, 799, 799, 844], [846, 846, 882, 882, 917], [918, 918, 937, 937, 962], [964, 964, 991, 991, 1078], [1079, 1079, 1119, 1119, 1226], [3300, 3375, 3405, 3405, 3644], [3646, 3646, 3719, 3719, 3986], [3988, 3988, 4071, 4071, 6245], [6288, 6288, 6329, 6329, 7527]], "test": "untested"}
{"id": "fslyDf", "name": "3D Noise thing", "author": "SnoopethDuckDuck", "description": "click to move\n\nkinda needs to run at 60fps to look half decent", "tags": ["raymarching", "template", "artofcode"], "likes": 15, "viewed": 364, "published": 3, "date": "1642814862", "time_retrieved": "2024-07-30T17:08:03.014971", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .0002\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    vec3 op = p;\n    float sc = 1.;\n    float sc2 = 4.;\n    // 2. * pi gives a fixed shape, smaller values will move\n    float time = pi * h21(p.xy) - iTime;\n    p.xy *= Rot(sc * (op.z - op.y) + sc2 * op.x + time);\n    p.yz *= Rot(sc * (op.x - op.z) + sc2 * op.y - time);\n    p.zx *= Rot(sc * (op.y - op.x) + sc2 * op.z + time);\n    \n    float c = cos(10. * p.y - 2. * iTime);\n    float r1 = 1. + 0.5 * c;\n    float r2 = 0.5 + 0.5 * c;\n    float d1 = length(p.xz) - r1;\n    float d2 = length(vec2(d1, p.y)) - r2;\n    \n    return 0.2 * d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.2);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        //vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 4. * vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslyDf.jpg", "access": "api", "license": "mit", "functions": [[1476, 1476, 1495, 1495, 1557], [1559, 1559, 1582, 1582, 2123], [2125, 2125, 2159, 2159, 2370], [2372, 2372, 2396, 2396, 2586], [2588, 2588, 2638, 2638, 2829], [2831, 2831, 2888, 2888, 3503]], "test": "untested"}
{"id": "fslcWf", "name": "Climate Simulation", "author": "pancakespeople", "description": "A totally accurate simulation of the climate of an island.", "tags": ["simulation", "world", "weather", "climate"], "likes": 2, "viewed": 240, "published": 3, "date": "1642810731", "time_retrieved": "2024-07-30T17:08:03.861707", "image_code": "vec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xy;\n    \n    // Change these coordinates to generate a new island\n    vec2 world = vec2(853.0, 285.0);\n\n    vec3 col = vec3(0.0);\n    float n = fbm(uv*2.0+world)+0.5;\n    float islandN = fbm(uv+world+100.0);\n    float radius = length(uv);\n    float distFromEquator = distance(uv.y, sin(iTime / 6.0) / 6.0);\n    float hemisphere = 1.0;\n    if (uv.y < 0.0) {\n        hemisphere = -1.0;\n    }\n    \n    vec2 tempUv = vec2(uv.x - iTime / 24.0 * hemisphere, uv.y);\n    float temperature = noise(tempUv * 2.0) * 0.5 + 0.5 * 0.25 / distFromEquator;\n    \n    if (n < 0.25 || radius + islandN > 0.5) {\n        vec2 waterUv = vec2(uv.x - iTime / 20.0 * hemisphere, uv.y);\n        vec2 waterUv2 = vec2(uv.x + 100.0 - iTime / 10.0 * hemisphere, uv.y + 100.0);\n        \n        float waterNoise = (noise(waterUv * 50.0) * 0.25 + 0.75) + noise(waterUv2 * 50.0) * 0.25 + 0.75;\n        col = mix(vec3(0.0, 0.0, 1.0), vec3(1.0), 0.05 / max(temperature, 0.1)) * waterNoise;\n    }\n    else {\n        if (n > 0.5) {\n            col = mix(vec3(0.75, 0.75, 0.75), vec3(1.0), 0.5 / max(temperature/2.0, 0.1)) * n + 0.25;\n        }\n        else {\n            col = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0) * n + 0.25, n*2.0 - temperature);\n            col = mix(col, vec3(0.5, 0.0, 0.0), 0.5 - temperature);\n            col = mix(col, vec3(1.0), 0.2 / max(temperature, 0.1));\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(temperature);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 159], [161, 246, 268, 268, 610], [612, 612, 631, 631, 890], [893, 893, 950, 950, 2454]], "test": "untested"}
{"id": "NdlcWf", "name": "Rubber 3", "author": "ersh", "description": "Continuing to experiment with raymarching. I'm going to be using this as a template for exploring 3D data and graphs.", "tags": ["3d"], "likes": 6, "viewed": 246, "published": 3, "date": "1642809886", "time_retrieved": "2024-07-30T17:08:04.893947", "image_code": "#define LIMITED_BY    2    // 0: infinite;  1: circle;  2: square\n#define COLOR         0\n#define MESH          1\n#define MESH_COLOR    0\n#define SCALE         3.\n#define MAXDIST       10.\n#define STEP          0.1\n\n//https://graphtoy.com/?f1(x,t)=sin(x+t)*sin(x/5-t*4)&v1=false&f2(x,t)=f1(x/2,t/2)*1.3-f1(x-1,t-5)&v2=false&f3(x,t)=f2(x/2,t/2)*1.3-f1(x-1,t-5)&v3=false&f4(x,t)=f3(x,t)*(0.5+f1(x-3,t*3-5)/2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,21.258732000000105\nfloat f1(float x, float t) { return sin(x+t)*sin(x/5.-t*4.); }\nfloat f2(float x, float t) { return f1(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f3(float x, float t) { return f2(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f4(float x, float t) { return f3(x,t)*(0.5+f1(x/3.4-3.,t*2.-5.)/2.); }\n\nvec3 col(float x, float side) {\n#if COLOR\n  return vec3(clamp(x/2.+0.5,0.,1.), side, clamp(0.5-x/2.,0.,1.));\n#else\n  return vec3(clamp(1.-side, 0., 0.8));\n#endif\n}\n\nfloat h(vec2 p, float t) {\n    return\n        f4(p.x, t) + f4(p.y + 42.123, t/1.321+31.32) +\n        f4(p.x, t) * f4(p.y + 42.123, t/1.321+31.32)/3.;\n}\n\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n//#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))             // rotation hack                  \n\n#define PI       3.1415926\n#define R        iResolution\n#define H(pos)   h((pos)*SCALE, iTime)/5.\n#define INTERP_MIX(PREV, TARGET, CUR)   (TARGET-PREV)/(CUR-PREV)\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec3 D = normalize(vec3(I+I, -4.*R.y) - vec3(R.xy, 0.));    // ray direction\n    vec3 p = vec3(0,0,7);                                       // current ray pos\n\n    mat2 rot_yz, rot_xy;            // rotations\n    if (iMouse.z < 0.5) {\n      rot_yz = rot(-PI*(0.35 + (sin(iTime/6.)+1.)*0.06));\n      rot_xy = rot(PI/3. + iTime/10.);\n    } else {\n      vec2 M = (iMouse.xy / R.xy * vec2(1., -0.5) + vec2(0.5, 0.)) * 2. * PI;\n      rot_yz = rot(M.y);\n      rot_xy = rot(M.x);\n    }\n    p.yz *= rot_yz;  p.xy *= rot_xy;\n    D.yz *= rot_yz;  D.xy *= rot_xy;\n\n    // Walk the ray\n    float height, diff;\n    float heightprev = H(p.xy), diffprev = 0.;\n    vec3 pprev = p;\n    float dist, stp = STEP;      // distance traveled, step\n    for (dist = 0.;  dist < MAXDIST;  dist += stp, p += stp*D) {\n        height = H(p.xy);\n        diff = p.z - height;\n        if (\n#if LIMITED_BY == 1\n            length(p.xy) < 2. &&\n#elif LIMITED_BY == 2\n            abs(p.x) < 2. && abs(p.y) < 2. &&\n#endif\n            diff * diffprev < 0.)\n        {\n            // Crossed the surface\n            break;\n        }\n        heightprev = height;\n        pprev = p;\n        diffprev = diff;\n    }\n\n    if (dist < MAXDIST) {    // Crossed the surface\n        // interpolate the exact intersection pos\n        float interp = INTERP_MIX(diffprev, 0., diff);\n        vec3 pexact = mix(pprev, p, interp);\n        float heightexact = H(pexact.xy);\n\n        // sign: +1 = looking top-down, -1 = looking down-up\n        float sgn = sign(diffprev);\n\n        vec3 c = col(heightexact*2., (-sgn+1.)/4.) * (1.-(1. - sgn)/3.);\n#if MESH\n        //vec2 mesh = fract(pexact.xy*5.);\n        float mesh_thick = 0.015;      // 0.5 max\n        float mesh_density = 3.;      // 0.5 max\n        vec2 mesh = max(vec2(0), abs(fract(pexact.xy*mesh_density)-vec2(0.5)) - vec2(0.5*(1.-2.*mesh_thick)))/mesh_thick;\n        c = mix(c, vec3(MESH_COLOR), max(mesh.x, mesh.y));\n#endif\n\n        // Angle for shading\n        //float surface_angle = atan((heightexact - H((pexact.xy+vec2(0.001)))) / 0.0014);\n        vec2 shade = vec2(1,0) * rot_xy;\n        float surface_angle = atan((heightexact - H((pexact.xy + shade*0.001))) / 0.001);\n        c += sgn*(surface_angle/3.);\n\n        O = vec4(c * (MAXDIST - dist)/MAXDIST * 2., 0.);\n    } else {\n        O = vec4(0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 491, 519, 519, 553], [554, 554, 582, 582, 624], [625, 625, 653, 653, 695], [696, 696, 724, 724, 772], [774, 774, 805, 805, 937], [939, 939, 965, 965, 1090], [1092, 1092, 1111, 1111, 1169]], "test": "untested"}
{"id": "fsscDX", "name": "Disaster", "author": "wyatt", "description": "A meteor strikes downtown...", "tags": ["jfa"], "likes": 34, "viewed": 454, "published": 3, "date": "1642808838", "time_retrieved": "2024-07-30T17:08:05.995003", "image_code": "Main\n    \n    vec4 b = B(U);\n    vec4 a = A(b.xy);\n    \n    Q = vec4(0)+step(length(U-a.xy),.75);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n\nfloat building(vec2 U) {\n    if (U.y<10.) return 0.;\n    if (length(U-vec2(.9)*R)<.02*R.x) return 1.;\n    float r = U.x/R.x*30.-15.;\n    float x = round(U.x/R.x*30.)-15.;\n    \n    float y = exp(-x*x/40.)*(1.5+sin(10.*x));\n    if (abs(r-x)>.3+.5*sin(x)) return 0.;\n    if (U.y/R.y < .4*y) return 1.;\n    else return 0.;\n\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n\n    vec2 f = vec2(0,-4e-4);\n    \n    for (float x = -5.; x <= 5.; x ++) \n    for (float y = -5.; y <= 5.; y ++) {\n        vec4 b = B(Q.xy+vec2(x,y));\n        vec4 a = A(b.xy);\n        vec2 u = abs(Q.xy+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5)continue;\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        if (l<1.||l>6.) continue;\n        float L = length(U-b.xy);\n        if ((l-L)<.1*L||L>5.) \n            f += 3e-1*r*(l-L)/l/L/l;\n    }\n    \n    if (length(f)>1.) f = normalize(f);\n    \n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<30.) Q.zw *= .8;\n    \n    if (Q.y<10.) Q.y=10., Q.zw *= 0.;\n\n    if (M.z>0.) Q.zw += 3e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n         if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n        XY(U,Q,vec4(Q.xy+vec2(x,y),0,0));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n\n    vec2 f = vec2(0,-4e-4);\n    \n    for (float x = -5.; x <= 5.; x ++) \n    for (float y = -5.; y <= 5.; y ++) {\n        vec4 b = B(Q.xy+vec2(x,y));\n        vec4 a = A(b.xy);\n        vec2 u = abs(Q.xy+vec2(x,y)-a.xy);\n        if (u.x>.5||u.y>.5)continue;\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        if (l<1.||l>6.) continue;\n        float L = length(U-b.xy);\n        if ((l-L)<.1*L||L>5.) \n            f += 3e-1*r*(l-L)/l/L/l;\n    }\n    \n    if (length(f)>1.) f = normalize(f);\n    \n    Q.zw += f;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<30.) Q.zw *= .8;\n    \n    if (Q.y<10.) Q.y=10., Q.zw *= 0.;\n\n    if (M.z>0.) Q.zw += 3e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n         if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n        XY(U,Q,vec4(Q.xy+vec2(x,y),0,0));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsscDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dXyDf", "name": "Super Collider #6 [Iters / Bass]", "author": "Yusef28", "description": "I first learned of the super collider tutorials from athibaul in the comments of his featured sahder \"Techno Song (sound)\"\nhttps://www.shadertoy.com/view/sls3WM\nThe link to those tutorials is in those comments, and in the sound tab of this shader.", "tags": ["pulse", "wave", "super", "collider", "supercollider"], "likes": 8, "viewed": 275, "published": 3, "date": "1642805669", "time_retrieved": "2024-07-30T17:08:06.922523", "image_code": "\n#define LETTER_SIZE 1./16.\n#define STEP_SIZE 1./8.\n#define FIRST_LETTER 64.\n#define FIRST_NUMBER 48.\n\nvec2 numToCoord(float a){\n    return vec2( mod(a,16.), 15.-floor(a/16.) );\n}\n\nvec3 C(vec2 uv, vec2 start, inout float moveX,float num){\n    moveX += STEP_SIZE/2.3;\n    if(uv.x < start.x           || \n       uv.x > start.x+STEP_SIZE || \n       uv.y < start.y           || \n       uv.y > start.y+STEP_SIZE){\n       return vec3(0.);\n    }\n    \n    uv -= start; uv /= STEP_SIZE; uv *= LETTER_SIZE;\n    uv += vec2(LETTER_SIZE*numToCoord(num));\n    return textureGrad(iChannel0,uv,dFdx(uv),dFdy(uv)).rrr;\n}\n\nvoid addC(vec2 st, float char, inout float moveX, inout vec3 col){\nst -= vec2(moveX,0.45);\n\nst *= mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\nst += vec2(moveX,0.45);\ncol = mix(col,vec3(1.),\n             C(st,vec2(moveX,0.45),moveX,FIRST_LETTER+char));\n    \n}\n\n\n/*\nThe sound Tab again for printing\n*/\n// Super Collider Tutorials\n// https://www.youtube.com/playlist?list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC\n\n/*\nThis isn't exactly what we get at the end of tutorial #3 because\nfor example reverb is something I don't know how to do yet. I \nmostly hack these functions together based on how the creator\nof the videos describes them (plus whatever I can find online \nquickly.)\n*/\n/*\n#define PI acos(-1.)\n\nfloat rnd(float a){return fract(sin(a*208.41)*4962.924);}\n\nfloat ExpRand(float a, float low, float high){\n    float seed = pow(rnd(a),2.);\n    float range = high-low;\n    return seed*range + low;\n}\n\n//random volume for each ear between 0 and 1\nvec2 Splay(float a){\n    return vec2(ExpRand(a,0.,1.),ExpRand(a+124.312,0.,1.) );\n}\n\n//volume of both eara always sums to 1\nvec2 Splay_2(float a){\n    float left = ExpRand(a+1.2,0.,1.);\n    return vec2(left,1.-left);\n}\n\nfloat LFNoise(float t, float freq, float low, float high){\n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    \n    float seed = mix(rnd(id),rnd(id+1.),smoothstep(0.2,0.5,fID));\n    float range = abs(high-low);\n    return floor(seed*range) + low;\n}\n\nfloat interpolateSins(float t, float freq, float i,\n                          float lowFreq, float highFreq){\n                          \n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    return  mix(sin(t*2.*PI*ExpRand(i+id,lowFreq,highFreq))*0.5+0.5,\n                sin(t*2.*PI*ExpRand(i+1.+id,lowFreq,highFreq))*0.5+0.5,\n                smoothstep(0.,0.95,fID));\n}\n\nfloat interpolatePartials(float t, float freq, float i,\n                          float lowFreq, float highFreq){\n                          \n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    return  mix(ExpRand(i+id,lowFreq,highFreq),\n                ExpRand(i+1.+id,lowFreq,highFreq),\n                smoothstep(0.6,0.0,fID));\n}\n\nvec2 dupSin(float t, float num, float lowAmp, float highAmp, \n             float lowFreq, float highFreq, inout vec3 col, vec2 uv){\n\n    vec2 sig = vec2(0.);\n    vec2 stereo = vec2(0.);\n    float amp = 0., ampNext = 0.;\n    float partial = 0.;\n    float partialFreq = 0.;\n    float noise = LFNoise(t,.2,20.,800.);\n    \n    for(float i = 0.; i < num; i++){\n        amp = sin(t*2.*PI*ExpRand(i+1.,lowAmp,highAmp))*0.5+0.5;\n        partialFreq = interpolatePartials(t, 0.2, i, lowFreq, highFreq);\n        partial = interpolateSins(t, 0.2, i, lowFreq, highFreq);\n        //interpolateSinssin(sin(t)*2.*PI*partialFreq)*0.5+0.5;\n        //interpolatePartials(t, 0.2, i, lowFreq, highFreq);\n        //sin(t*2.*PI*ExpRand(i+1.,lowFreq,highFreq))*0.5+0.5;\n        stereo = Splay(i+1.2);\n        sig += partial*amp*stereo;\n        col -= sig.x*smoothstep(0.01,0.0,abs(i - floor(uv.x*num)))/10.;\n    }\n    \n    return sig/7.;\n}\n\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = 0.5 + 0.5*cos(uv.xyy+vec3(0,2,4));\n  //  vec2 sig = dupSin(iTime,10.,0.2,22.,200.,1000., col, uv);\n    // Time varying pixel color\n    \n    vec2 st = uv;\n    \n    float moveX = 0.23;\n    \n    addC(st,_s,moveX,col);  \n    addC(st,_o,moveX,col);\n    addC(st,_u,moveX,col);  \n    addC(st,_n,moveX,col);\n    addC(st,_d,moveX,col);\n    addC(st,_z+32.+5.,moveX,col);\n    addC(st,_i,moveX,col);\n    addC(st,_n,moveX,col);\n   // Output to screen\n   //col = texture(iChannel0,uv).rgb;\n   \n   \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Super Collider Tutorials\n// https://www.youtube.com/playlist?list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC\n\n/*\nThere are some functions I'm not yet familiar with in \nSuper Collider so this the base I could make with what\nI could figure out.\n*/\n\n#define PI acos(-1.)\n\nfloat rnd(float a){return fract(sin(a*238.41)*49625.924);}\n\nfloat ExpRand(float a, float low, float high){\n    float seed = pow(rnd(a),2.);\n    float range = high-low;\n    return seed*range + low;\n}\n\n//random volume for each ear between 0 and 1\nvec2 Splay(float a){\n    return vec2(ExpRand(a,0.,1.),ExpRand(a+124.312,0.,1.) );\n}\n\n//volume of both eara always sums to 1\nvec2 Splay_2(float a){\n    float left = ExpRand(a+1.2,0.,1.);\n    return vec2(left,1.-left);\n}\n\nfloat LFNoise(float t, float freq, float low, float high){\n    float id = floor(PI*t*freq);\n    float fid = fract(PI*t*freq);\n    float seed = mix(rnd(id),rnd(id+1.),fid);\n    float range = abs(high-low);\n    return seed*range+low;\n}\n\nfloat Saw(float t, float freq, float phase ){\n    return fract((t + phase)*freq);\n}\n\nfloat Sin(float t, float freq, float modulation, float phase){\n    return sin(2.*PI*(t+phase)*freq + modulation*1.);\n}\n\nvec2 TBMBass(float t, float freq, float num){\n\n    vec2 sig = vec2(0.);\n    vec2 stereo = vec2(0.);\n    float ampL = 0., ampR = 0.;\n    \n    for(float i = 1.; i <= num; i++){\n    \n      //amp = Saw(ExpRand(freq*(i+1.),0.99,1.02));\n        ampL = Sin(t, \n                   freq*i, \n                   LFNoise(t, rnd(i+47.)*0.2+0.01, 0.97,1.2), \n                   rnd(i)*PI*2.)\n                  *LFNoise(t, ExpRand(i+1.,.5, 8.), 0.01,1.0);\n                   \n        ampR = Sin(t, \n                   freq*i, \n                   LFNoise(t, rnd(i+13.)*0.2+0.01, 0.95,1.1),\n                   rnd(i+99.)*PI*2.)\n                  *LFNoise(t, ExpRand(i+9.5,.5, 8.), 0.01,1.0);          \n                 \n        //stereo = Splay_2(i);\n        float am = 1. - (i/num);\n        sig += vec2(ampL,ampR)*am*0.4; //*stereo;\n        \n    }\n    \n    return sig;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    //return vec2(sin(time*440.*2.*PI+sin(time*10.)*4.));\n    //return vec2(sin((440.+sin(time*10.))*time*2.));//\n    float pluck = mod(time,5.)/5.;\n    float freq = mod(time,10.) < 5. ? 55. : 69.30;\n    return TBMBass(time,freq,10.)*.4*exp(pluck*1.4);\n}", "sound_inputs": [], "common_code": "#define _a 1.\n#define _b 2.\n#define _c 3.\n#define _d 4.\n#define _e 5.\n#define _f 6.\n#define _g 7.\n#define _h 8.\n#define _i 9.\n#define _j 10.\n#define _k 11.\n#define _l 12.\n\n#define _m 13.\n#define _n 14.\n#define _o 15.\n#define _p 16.\n#define _q 17.\n#define _r 18.\n#define _s 19.\n#define _t 20.\n#define _u 21.\n#define _v 22.\n#define _w 23.\n#define _x 24.\n#define _y 25.\n#define _z 26.", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 128, 128, 179], [181, 181, 238, 238, 603], [605, 605, 671, 671, 871], [1018, 3691, 3748, 3798, 4379]], "test": "untested"}
{"id": "fsfyWf", "name": "Hydrogen Orbitals (scuffed)", "author": "Zi7ar21", "description": "I have no clue if this is actually correct... I just used the \"Schrdinger Equation\" section on the \"Hydrogen atom\" Wikipedia article (aaaaand ~~stole~~ made use of Inigo Quilez's Spherical Harmonics shader...)", "tags": ["wave", "function", "quantum", "wavefunction", "schrodinger", "ign"], "likes": 24, "viewed": 658, "published": 3, "date": "1642805256", "time_retrieved": "2024-07-30T17:08:08.000640", "image_code": "// ####### Hydrogen Orbitals #######\n// Made by Jacob Bingham (Zi7ar21) on January 21st, 2022\n\n// Last Updated on January 22nd, 2022 at 03:05 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/fsfyWf\n\n// based on https://en.wikipedia.org/wiki/Hydrogen_atom#Schr%C3%B6dinger_equation\n\n/*\nI have no clue if this is actually correct...\nI just used the \"Schrodinger Equation\" section on the \"Hydrogen atom\" Wikipedia\narticle (aaaaand ~~stole~~ made use of Inigo Quilez's Spherical Harmonics shader...)\n*/\n\n/*\n## Features\n\n- Arbitrary (n, l, m) ( scroll down to Parameters to adjust, the default is (3, 2, 0) )\n- Volumetrics\n  - Ray-Marching\n  - Scattering\n  - Dithering with Interleaved Gradient Noise\n\n## Limitations/TODO\n\n- Generalized Laguerre Polynomial not taken into account\n  - I have no idea what this is and how to use it, it seems to not be\n    neccesary and so it's currently ommited\n- Spherical Harmonics Problems\n  - This only supports Real Spherical Harmonics\n  - Pre-solved Spherical Harmonics only up to l = 3\n    - Solving arbitrary spherical harmonics for l and m would be cool...\n      of course, it probably wouldn't perform very great and so it would\n      only be used for l > 3\n*/\n\n/*\n# Zi7ar21's Epic License\n\nThis applies to...\n\n- Code I wrote\n  - You must respect the individual licenses of any snippets in the source that aren't mine\n\nYou are free to...\n\n- Use this code however you want (as long as it complies with this license)\n  - e.g. personal and commercial projects\n  - Especially open-source projects\n\nAs long as...\n\n- You use it ethically\n  - e.g. no using it for NFT's, which are unsustainable and stupid\n- You keep comments in the source that credit and link to snippets of code that aren't mine\n  - e.g. Comments such as \"PCG Random: https://www.pcg-random.org/\"\n  - Of course, you must also respect whatever licenses they use\n\nRemember, we are programmers, not lawyers! :)\n*/\n\n// Check out some of my friends!\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n// skythedragon\n// https://www.shadertoy.com/user/skythedragon\n\n// We have a Discord Server focused on STEM and Memes, DM me (@Zi7ar21#2168) if you're interested.\n\n// ##### Preprocessor #####\n\n/*\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n// ##### Parameters #####\n\n// n = principal quantum number\n// l = azimuthal quantum number\n// m = magnetic quantum number\n#define n 3\n#define l 2\n#define m 0\n\n#define EXPOSURE 1.0\n\n// uncomment for orthographic camera\n//#define ORTHO\n\n#define FOV 1.5\n\n#define STEP_SIZE 4.0\n\n#define STEP_SIZE_SHADOW 0.4\n\n#define CUTOFF 0.008\n#define DENSITY 16.0\n\n#define POSITIVE_COL vec3(0.250, 1.000, 0.500)\n#define NEGATIVE_COL vec3(1.000, 0.500, 0.250)\n\n// ##### Configuration Validation #####\n\n// ### make sure n is valid ###\n\n#if n < 1\n#error n must be greater than 0\n#endif\n\n// ### make sure l is valid ###\n\n#if l < 0\n#error l must be greater than or equal to 0\n#endif\n\n#if l >= n\n#error l must be less than n\n#endif\n\n// ### make sure m is valid ###\n\n#if m > l || -m > l\n#error m must be less than or equal to abs(l)\n#endif\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// Reduced Bohr Radius\n// 5.2946541 * 10 ^ -11 meters\n// 0.52946541 angstrom\n// https://en.wikipedia.org/wiki/Bohr_radius#Hydrogen_atom_and_similar_systems\nconst float a0 = 0.52946541;\n\n// ##### Maths #####\n\n//#define dot_product(x) dot(x, x)\n\nfloat dot_product(vec2 x) { return dot(x, x); }\nfloat dot_product(vec3 x) { return dot(x, x); }\nfloat dot_product(vec4 x) { return dot(x, x); }\n\nvec2 rotate(vec2 vector, float theta)\n{\n    float s = sin(theta), c = cos(theta);\n    return vec2(vector.x * c - vector.y * s, vector.x * s + vector.y * c);\n}\n\nint factorial(int x)\n{\n    int f = 1;\n\n    for(int i = 1; i <= x; i++)\n    {\n        f = f * i;\n    }\n\n    return f;\n}\n\n// (x, y, z) -> (r, theta, phi)\nvec3 cartesian2spherical(vec3 p)\n{\n    return vec3(\n    length(p), // r\n    atan(p.y, p.x), // theta\n    atan(length(p.xy), p.z) // phi\n    );\n}\n\n// (r, theta, phi) -> (x, y, z)\nvec3 spherical2cartesian(vec3 p)\n{\n    float r     = p.x;\n    float theta = p.y;\n    float phi   = p.z;\n\n    return vec3(\n    cos(theta) * sin(phi),\n    sin(theta) * sin(phi),\n    cos(phi)\n    );\n}\n\n/*\n*/\n// modified from https://www.shadertoy.com/view/lsfXWH\n\n// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\nconst float k01 = 0.2820947918; // sqrt(  1 / PI) / 2\nconst float k02 = 0.4886025119; // sqrt(  3 / PI) / 2\nconst float k03 = 1.0925484306; // sqrt( 15 / PI) / 2\nconst float k04 = 0.3153915652; // sqrt(  5 / PI) / 4\nconst float k05 = 0.5462742153; // sqrt( 15 / PI) / 4\nconst float k06 = 0.5900435860; // sqrt( 70 / PI) / 8\nconst float k07 = 2.8906114210; // sqrt(105 / PI) / 2\nconst float k08 = 0.4570214810; // sqrt( 42 / PI) / 8\nconst float k09 = 0.3731763300; // sqrt(  7 / PI) / 4\nconst float k10 = 1.4453057110; // sqrt(105 / PI) / 4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \n//float SH( in int l, in int m, in vec3 s )\nfloat SH( in vec3 s )\n{ \n    vec3 n_ = s.zxy;\n\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n    if( l==1 && m==-1 ) return -k02 * n_.y;\n    if( l==1 && m== 0 ) return  k02 * n_.z;\n    if( l==1 && m== 1 ) return -k02 * n_.x;\n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03 * n_.x * n_.y;\n    if( l==2 && m==-1 ) return -k03 * n_.y * n_.z;\n    if( l==2 && m== 0 ) return  k04 * (3.0 * n_.z * n_.z - 1.0);\n    if( l==2 && m== 1 ) return -k03 * n_.x * n_.z;\n    if( l==2 && m== 2 ) return  k05 * (n_.x * n_.x - n_.y * n_.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06 * n_.y * (3.0 * n_.x * n_.x - n_.y * n_.y);\n    if( l==3 && m==-2 ) return  k07 * n_.z * n_.y * n_.x;\n    if( l==3 && m==-1 ) return -k08 * n_.y * (5.0 * n_.z * n_.z - 1.0);\n    if( l==3 && m== 0 ) return  k09 * n_.z * (5.0 * n_.z * n_.z - 3.0);\n    if( l==3 && m== 1 ) return -k08 * n_.x * (5.0 * n_.z * n_.z - 1.0);\n    if( l==3 && m== 2 ) return  k10 * n_.z * (n_.x * n_.x - n_.y * n_.y);\n    if( l==3 && m== 3 ) return -k06 * n_.x * (n_.x * n_.x - 3.0 * n_.y * n_.y);\n    //----------------------------------------------------------\n\n    return 0.0;\n}\n/*\n*/\n\n// Generalized Laguerre Polynomial (not neccesary, I think?)\nfloat L(float rho)\n{\n    return 1.0;\n}\n\n// Spherical Harminic Function\n// Wikipedia: \"Spherical Harmonic Function of Degree l and Order m\"\nfloat Y(float theta, float phi)\n{\n    vec3 p = spherical2cartesian( vec3(1.0, theta, phi) );\n\n    return SH(p);\n}\n\n// Normalized Position Wavefunction\nfloat wavefunction(float r, float theta, float phi)\n{\n    float rho = (2.0 * r) / (float(n) * a0);\n\n    float f0 = 2.0 / (float(n) * a0);\n    float f1 = float( factorial(n - l - 1) ) / float( 2 * n * factorial(n + l) );\n\n    return sqrt(f0 * f0 * f0 * f1) * exp(-rho / 2.0) * pow( rho, float(l) ) * L(rho) * Y(theta, phi);\n}\n\n// ##### Rendering #####\n\nvec3 sky(vec3 dir)\n{\n    return vec3(0);\n    return vec3(1) * 0.8 * smoothstep(0.0, 1.0, dir.y) + 0.2;\n}\n\nfloat sample_volume(in vec3 p, out vec3 col)\n{\n    col = vec3(0.100, 0.250, 1.000);\n\n    if(dot_product(p) > 32.0 * 32.0)\n    {\n        return 0.0;\n    }\n\n    //return 10.0 * smoothstep( 0.0, 1.0, 1.0 - length(p) );\n\n    /*\n    if(abs(p.x) > 1.2 || abs(p.y) > 1.2 || abs(p.z) > 1.2)\n    {\n        return 0.0;\n    }\n    */\n    /*\n    if(dot_product(p) < 0.8 * 0.8)\n    {\n        return 8.0;\n    }\n    if(dot_product(p) > 1.2 * 1.2)\n    {\n        return 0.0;\n    }\n\n    // https://en.wikipedia.org/wiki/Mandelbulb\n\n    vec3 c = p.xzy;\n    vec3 z = c;\n    float power = 8.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        float r = length(z);\n\n        if(r > 2.0)\n        {\n            return 8.0 * max( max(float(i - 2), 0.0) / 6.0, 0.0 );\n        }\n\n        // convert to polar coordinates\n        float theta = acos(z.z / r );\n        float phi   = atan(z.y, z.x);\n\n        // scale and rotate the point\n        //float zr = pow(r, power);\n        float zr = r * r * r * r  *r * r * r * r;\n        theta *= power;\n        phi   *= power;\n\n        float sin_theta = sin(theta);\n        float cos_theta = cos(theta);\n        float sin_phi = sin(phi);\n        float cos_phi = cos(phi);\n\n        z = ( zr * vec3(sin_theta * cos_phi, sin_phi * sin_theta, cos_theta) ) + c;\n    }\n\n    return 8.0;\n    */\n\n    p = vec3(rotate(p.xy, 1.0 * (0.1 / 3.0) * two_pi * iTime), p.z).xyz;\n    p = vec3(rotate(p.xz, 2.0 * (0.1 / 3.0) * two_pi * iTime), p.y).xzy;\n    p = vec3(rotate(p.yz, 3.0 * (0.1 / 3.0) * two_pi * iTime), p.x).yzx;\n\n    p = cartesian2spherical(p);\n    float r     = p.x;\n    float theta = p.y;\n    float phi   = p.z;\n\n    float w = wavefunction(r, theta, phi);\n\n    if(w > 0.0)\n    {\n        col = POSITIVE_COL;\n    }\n    else\n    {\n        col = NEGATIVE_COL;\n    }\n\n    return DENSITY * max(abs(w) - CUTOFF, 0.0);\n}\n\nvec3 sample_light(vec3 ro, vec3 rd)\n{\n    vec3 a = vec3(1);\n\n    for(int i = 0; i < 10; i++)\n    {\n        float t = STEP_SIZE_SHADOW * float(i);\n\n        vec3 p = ro + rd * t;\n\n        vec3 c;\n        float d = sample_volume(p, c);\n\n        if(d > 0.0)\n        {\n            a *= exp(-STEP_SIZE_SHADOW * c * d);\n        }\n    }\n\n    return a;\n}\n\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 pixel_coord, int frame)\n{\n    frame = frame % 64;\n\n    pixel_coord += 5.588238 * float(frame);\n\n    return fract( 52.9829189 * fract(0.06711056 * pixel_coord.x + 0.00583715 * pixel_coord.y) );\n}\n\n/*\n// ##### Main #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 p = 10.0 * vec3( uv, sin(0.125 * two_pi * iTime) );\n\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    float phi = atan(length(p.xy), p.z);\n\n    fragColor.rgb = vec3( 10.0 * abs( wavefunction(r, theta, phi) ) );\n}\n*/\n\n// ##### Main #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    #ifdef ORTHO\n    vec3 ro = vec3( FOV * uv ,  16.0);\n    vec3 rd = vec3( 0.0,  0.0,  -1.0);\n    #else\n    //vec3 ro = vec3( 0.0, 0.0, 0.2 * sin( (1.0 / 3.0) * two_pi * iTime ) + 16.0 );\n    vec3 ro = vec3( 0.0, 0.0, 16.0);\n    vec3 rd = normalize( vec3(FOV * uv, -1.0) );\n    #endif\n\n    //float theta = 0.125 * two_pi * iTime;\n\n    //ro = vec3(rotate(ro.xz, theta), ro.y).xzy;\n    //rd = vec3(rotate(rd.xz, theta), rd.y).xzy;\n\n    vec3 att = vec3(1);\n    vec3 col = vec3(0);\n\n    float dither = STEP_SIZE * IGN(floor(fragCoord), iFrame);\n\n    for(int i = 0; i < 40; i++)\n    {\n        float t = ( STEP_SIZE * float(i) ) + dither;\n\n        vec3 p = ro + rd * t;\n\n        #ifndef ORTHO\n        if(dot_product(p) > 16.0 * 16.0)\n        {\n            break;\n        }\n        #else\n        if(dot_product(p) > 32.0 * 32.0)\n        {\n            break;\n        }\n        #endif\n\n        vec3 c;\n        float d = sample_volume(p, c);\n\n        if(d > 0.0)\n        {\n            col += STEP_SIZE * att * d * sample_light( p, normalize( vec3(1, 1, 0) ) );\n\n            //att *= exp(-STEP_SIZE * c * d);\n            att *= exp(-STEP_SIZE * d);\n        }\n    }\n\n    fragColor.rgb = col + att * sky(rd);\n\n    #ifdef EXPOSURE\n    fragColor.rgb = smoothstep( 0.0, 1.0, 1.0 - exp(-max(fragColor.rgb, 0.0) * EXPOSURE) );\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3915, 3915, 3942, 3942, 3962], [3963, 3963, 3990, 3990, 4010], [4011, 4011, 4038, 4038, 4058], [4060, 4060, 4099, 4099, 4218], [4220, 4220, 4242, 4242, 4338], [4340, 4372, 4406, 4406, 4516], [4518, 4550, 4584, 4584, 4747], [6687, 6792, 6815, 6815, 8141], [8149, 8210, 8230, 8230, 8248], [8250, 8349, 8382, 8382, 8462], [8852, 8852, 8872, 8872, 8956], [8958, 8958, 9004, 9004, 10777], [10779, 10779, 10816, 10816, 11124], [11126, 11328, 11368, 11368, 11537], [11996, 12016, 12073, 12073, 13532]], "test": "untested"}
{"id": "ssXyD2", "name": "Still Fire", "author": "wyatt", "description": "advected curl noise with glow", "tags": ["noise", "fire"], "likes": 14, "viewed": 423, "published": 3, "date": "1642804224", "time_retrieved": "2024-07-30T17:08:08.888268", "image_code": "Main \n    vec4 a = A(U);\n    vec4 b = B(U);\n    Q = mix(a*abs(a.w),b,a.w);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I;\n#define Main void mainImage(out vec4 Q, in vec2 U) {UNI\n#define UNI R=iResolution.xy;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec4 hash (vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx)*2.-1.;\n}\nvec4 noise (vec2 u)\n{\n    vec2 v = floor(u);\n    vec4 \n        _00 = hash(vec4(v+vec2(0,0),3,0)),\n        _01 = hash(vec4(v+vec2(0,1),3,0)),\n        _10 = hash(vec4(v+vec2(1,0),3,0)),\n        _11 = hash(vec4(v+vec2(1,1),3,0)),\n        _0 = mix(_00,_01,fract(u.y)),\n        _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\nvec4 fbm (vec2 u) {\n    vec4 x = vec4(0);\n    for (float i = 1.; i < 6.; i++) {\n        x += 6./i*noise(40.*u/R.x+.2*i*i*vec2(I/60,0))/5.;\n        u = 1e4+u*2.*ei(.5);\n    }\n    return x;\n}\nvec2 grad (vec2 u) {\n    return vec2(\n        fbm(u+vec2(1,0)).x - fbm(u-vec2(1,0)).x,\n        fbm(u+vec2(0,1)).x - fbm(u-vec2(0,1)).x\n    );\n}", "buffer_a_code": "Main \n    if (I%60!=0) {Q = A(U); return;}\n    Q = vec4(0);\n    Q += 1.;\n    for (float i = 0.; i < 50.; i++)\n        U -= 1200./R.x*vec2(0.,\n                2.*smoothstep(.5,0.,abs(U.x/R.x-.5)))+\n             10.*grad(.07*U).yx*vec2(-1,1);\n    Q = .7+sin(\n        (1.-U.y/R.y-1.*abs(U.x/R.x-.5)*abs(.5-U.x/R.x))\n        *(2.+vec4(1,2,3,4)));\n    Q.w = 1.;\n    Q.w *= smoothstep(.3,0.,(1.-.7*U.y/R.y)*abs(U.x/R.x-.5));\n    Q.w *= smoothstep(2.,0.,abs(U.y/R.y));\n    Q.w = Q.w*2.-.1;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main \n    if (I%60!=0) {Q = B(U); return;}\n    Q = vec4(0);\n    vec4 q = A(U);\n    float L = 100.;\n    float dt = .1;\n    for (float t = 0.; t < 2.*3.14592; t+= dt)\n    {\n        vec4 C = vec4(0);\n        for (float r = L; r>=0.; r--)\n        {\n            vec2 v = 3.*r*vec2(cos(t),sin(t));\n            vec4 a = A(U+v);\n            if (a.w>0.) Q += 1e-4*a*a.w;\n            else Q *= exp(-.1*abs(a.w));\n        }\n    }\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dXyDH", "name": "voronoi_voronoi", "author": "tungster24", "description": "some voronoi, because I was bored", "tags": ["voronoi", "distance"], "likes": 0, "viewed": 175, "published": 3, "date": "1642797923", "time_retrieved": "2024-07-30T17:08:09.832742", "image_code": "float dist(in vec2 p,in vec2 q) {\n    float difx = p.x-q.x;\n    float dify = p.y-q.y;\n    return sqrt(difx*difx+dify*dify);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (ivec2(iMouse.xy) == ivec2(0,0)) m = vec2(0.0);\n    vec2 p = fragCoord/iResolution.xy;\n    //vector array of points\n    vec2 points[10] = \n    vec2[10](\n    vec2(0.0,0.0), //1\n    vec2(0.54,0.22), //2\n    vec2(0.23,0.67), //3\n    vec2(0.13,0.98), //4\n    vec2(0.66,0.14), //5\n    vec2(0.73,0.09), //6\n    vec2(0.99,0.24), //7\n    vec2(0.74,0.14), //8\n    vec2(0.73,0.19), //9\n    vec2(m.x,m.y)  //10 (mouse position vector)\n    );\n    \n    //minimum distance variable\n    float mindist;\n    \n    for (int i = 0;i<10;i++){\n        if (i == 0) mindist = dist(p,points[i]);\n        else {\n            if ( mindist > dist(p,points[i]) ) mindist = dist(p,points[i]);\n        }\n    }\n    //to make the color ramp more pleasant\n    mindist = sqrt(mindist);\n    fragColor = vec4(mindist,mindist,mindist,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 125], [127, 127, 184, 184, 1033]], "test": "untested"}
{"id": "7dXcDf", "name": "#800x80 cmarangu", "author": "cmarangu", "description": "[url]https://twitter.com/C010011012/status/1481939872428412932/[/url]", "tags": ["genuary", "800x80", "genuary2022"], "likes": 1, "viewed": 182, "published": 3, "date": "1642797363", "time_retrieved": "2024-07-30T17:08:10.637590", "image_code": "// Title: #800x80 .\n// Started: 2022 1/5\n// Tags: 800x80, genuary, genuary2022\n// Description: [url]https://twitter.com/C010011012/status/1481939872428412932/[/url]\n\n\n\n\n// #define showfull 1   - does not crop to 800x80 resolution\n#define showfull 0\n\n// #800x80\n#define b O.rgb\n#define p ((I-iResolution.xy/2.)/iResolution.x*20.)\nvoid mainImage(out vec4 O, in vec2 I){float m=.5+.5*sin(atan(p.y,p.x)*6.*floor(1.+9.*pow(length(p),1.5))+iTime);m*=m*1.05;b=m<1.?mix(vec3(0.,0.,100./255.),vec3(0.,1.,1.),max(m,0.)):vec3(1.);\n\n\n\n#if !showfull\nif (abs(I.y-iResolution.y/2.)>iResolution.x/20.) {\n    O = vec4(0.,0.,100./255.,1.);\n}\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXcDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 329, 367, 367, 632]], "test": "untested"}
{"id": "ssXcDX", "name": "Fractal Ball E", "author": "SnoopethDuckDuck", "description": "click to move\n\nLooks like voronoi stuff - fractal used only for colors (was used for object before)\n(messy code)", "tags": ["raymarching", "template", "artofcode"], "likes": 6, "viewed": 239, "published": 3, "date": "1642788973", "time_retrieved": "2024-07-30T17:08:11.456401", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 Rotate(vec3 p, float a) {\n    p.xy *= Rot(a - 2. * pi / 3.);\n    p.yz *= Rot(a);\n    p.zx *= Rot(a + 2. * pi / 3.);\n    return p;\n}\n\nvec3 GetCol(vec3 p) {       \n    float time = 0.05 * iTime;\n    p = Rotate(p, time);\n    time += 0.1 * iTime;\n    \n    uvec3 id = uvec3(1);\n    float m = 1.;   \n    float n = 5.;\n    \n    for (float i = 0.; i < n; i++) {\n        id *= uvec3(2);\n        id += uvec3(step(p.x,0.), step(p.y,0.), step(p.z,0.));\n        time += 2. * pi / n; // + 10. * length(p);\n        p = abs(p) - m;\n        p = Rotate(p, time);      \n        //m *= 0.5;\n        m *= 0.6 + 0.4 * thc(8., 0.2 * iTime + time);\n    }\n    \n    // h31 function?\n    /*\n    float i = h21(id.xy);\n    float j = h21(id.yz);\n    float k = h21(vec2(i, j));*/\n    float k = hash(id).x;\n    return hash(id);\n}\n\nfloat GetDist(vec3 p) {\n    /*\n    float h = 12.;\n    float time = iTime;\n    p.xz *= Rot(4. * length(p.xz) - 0.4 * iTime);\n    p.xy *= Rot(4. * length(p.xy) + 0.5 * iTime);\n    float sc = 10.;\n    float r = 0.2;// * h21(floor(p.xz * sc)) + 0.1 * cos(iTime);\n    \n    float c = 1.;//0.5 + 0.5 * thc(h, time);\n    float s = 0.5 + 0.5 * ths(h, time);\n    p.x += r * c * (h21(floor(p.xy * sc)) - 0.5);\n    p.z += r * c * (h21(floor(p.yz * sc)) - 0.5);\n    */\n    float d = length(p) - 1.8;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    dif = 0.15 + 0.85 * dif * step(length(lightPos-p), d);\n \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        //vec3 n = GetNormal(p);\n       // vec3 r = reflect(rd, n);\n\n        col = GetCol(p);\n        \n        // shouldnt be using shadows?\n        //float dif = GetLight(p, vec3(2.,4.,2.));\n        //col *= vec3(dif);\n        \n        vec3 e = 0.85 * col;//vec3(1.);\n        //col = pal(0.5 * dif + 0.1 * iTime,  e, e, e, 0.5 * col);  \n        col = pal(0.1 * iTime, e, e, e, 0.5 * col);  \n        \n        //float dif2 = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        //col += 0.4 * pow(max(0., dif2), 10.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nconst uint k = 1103515245U;\n// stolen from here: https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 124, 124, 186], [188, 188, 218, 218, 324], [326, 326, 347, 347, 990], [992, 992, 1015, 1447, 1494], [1496, 1496, 1530, 1530, 1741], [1743, 1743, 1767, 1767, 1957], [1959, 1959, 2009, 2009, 2200], [2202, 2202, 2241, 2241, 2475], [2477, 2477, 2534, 2534, 3503]], "test": "untested"}
{"id": "7sfyW2", "name": "3D Fractal Cubes (buggy)", "author": "SnoopethDuckDuck", "description": "Wanted the cubes to be bigger, but artifacts appear if 2 cubes dont align along the abs() boundary\n\n(n>=5. looks cool in GetDist, but very laggy)", "tags": ["raymarching", "template", "artofcode"], "likes": 12, "viewed": 387, "published": 3, "date": "1642781813", "time_retrieved": "2024-07-30T17:08:12.209387", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 GetDist(vec3 p) {\n\n    float m = 0.8;\n    \n    vec3 id = vec3(1);\n    float time = 0.15 * iTime;\n    float n = 3.;\n    for (float i = 0.; i < n; i++) {\n       // id \n        id *= 0.5;\n        id += vec3(step(p.x,0.), step(p.y,0.), step(p.z,0.));\n        time += 2. * pi / n;\n        p = abs(p) - m;\n        p.xy *= Rot(time - 2. * pi / 3.);\n        p.yz *= Rot(time);\n        p.zx *= Rot(time + 2. * pi / 3.);\n        //float s = 0.5 + 0.5 * cos(time + 4. * 0.);//step(0., cos(time + 2. * p.x));\n        //m *= 0.6 * (1.-s) + s * 0.4;\n               \n        m *= 0.5;\n       \n        //m *= mix(0.25, 0.5, s);\n        //m *= 0.6 + 0.4 * thc(8., 0.2 * iTime + time);\n    }\n    \n    float i = h21(id.xy);\n    float j = h21(id.yz);\n    float k = h21(vec2(i, j)); // need better 3d noise\n    float k2 = 0.375 + 0.125 * thc(8., 2. * pi * k + 0. * mlength(p) - 0.5 * iTime);\n    \n    float d = mlength(p) - 2. * m * k2;\n\n    //d = length(p) - 2. * m;\n    return vec2(0.8 * d, k);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n   // vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    dif = 0.15 + 0.85 * dif * step(length(lightPos-p), d);\n   // if(d<length(lightPos-p)) dif = 0.;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.4);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif2 = GetLight(p,vec3(4., 2., 4.));\n        col = vec3(dif2);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col *= vec3(dif);\n        \n        // VERY sloppy way of doing it\n        float k = GetDist(p).y;\n        //col *= 0.5 + 0.5 * thc(4., 2. * pi * k + iTime);\n        vec3 e = vec3(1.);\n        col *= pal(k + 0.5 * pi * thc(8., 2. * pi * k + 0.1 * iTime), \n                   e, e, e, 0.5 * vec3(0.,0.33,0.66));\n        //col *= 0.52 + 0.48 * cos(4. * length(p) - iTime);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 124, 124, 186], [188, 188, 210, 210, 1170], [1172, 1172, 1206, 1206, 1419], [1421, 1421, 1445, 1445, 1643], [1645, 1645, 1695, 1695, 1886], [1888, 1888, 1927, 2018, 2296], [2298, 2298, 2355, 2355, 3394]], "test": "untested"}
{"id": "NsfyDf", "name": "Fork Fire shade zovox 632", "author": "zovox", "description": "It is just a spin off from https://www.shadertoy.com/view/XsXSWS applying some distortion\n\nNow with simplex noise.", "tags": ["fire"], "likes": 2, "viewed": 213, "published": 3, "date": "1642779683", "time_retrieved": "2024-07-30T17:08:13.019222", "image_code": "// This is just a spin off from https://www.shadertoy.com/view/XsXSWS applying some distortion and minor tweaks\n\n#define timeScale \t\t\tiTime * 1.0\n#define fireMovement \t\tvec2(-0.01, -0.5)\n#define distortionMovement\tvec2(-0.01, -0.3)\n#define normalStrength\t\t40.0\n#define distortionStrength\t0.1\n\n// #define DEBUG_NORMAL\n\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat fbm ( in vec2 p ) {\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*snoise(p); p = m*p;\n    f += 0.2500*snoise(p); p = m*p;\n    f += 0.1250*snoise(p); p = m*p;\n    f += 0.0625*snoise(p); p = m*p;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\n/** DISTORTION **/\nvec3 bumpMap(vec2 uv) { \n    vec2 s = 1. / iResolution.xy;\n    float p =  fbm(uv);\n    float h1 = fbm(uv + s * vec2(1., 0));\n    float v1 = fbm(uv + s * vec2(0, 1.));\n       \n   \tvec2 xy = (p - vec2(h1, v1)) * normalStrength;\n    return vec3(xy + .5, 1.);\n}\n\n/** MAIN **/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 normal = bumpMap(uv * vec2(1.0, 0.3) + distortionMovement * timeScale);\n    \n    #ifdef DEBUG_NORMAL\n    \tfragColor = vec4(normal, 1.0);\n    \treturn;\n    #endif\n    \n    vec2 displacement = clamp((normal.xy - .5) * distortionStrength, -1., 1.);\n    uv += displacement; \n    \n    vec2 uvT = (uv * vec2(1.0, 0.5)) + timeScale * fireMovement;\n    float n = pow(fbm(8.0 * uvT), 1.0);    \n    \n    float gradient = pow(1.0 - uv.y, 2.0) * 5.;\n    float finalNoise = n * gradient;\n    \n    vec3 color = finalNoise * vec3(2.*n, 2.*n*n*n, n*n*n*n);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 340, 340, 391], [393, 393, 414, 414, 465], [467, 467, 489, 489, 528], [530, 530, 552, 552, 2158], [2160, 2160, 2185, 2185, 2431], [2433, 2452, 2475, 2475, 2709], [2711, 2724, 2781, 2781, 3406]], "test": "untested"}
{"id": "NsfcWf", "name": "Simple Circle [ppxxll] ", "author": "robclouth", "description": "Draws a circle", "tags": ["2d", "geometry", "ppxxll"], "likes": 0, "viewed": 250, "published": 3, "date": "1642778479", "time_retrieved": "2024-07-30T17:08:13.778193", "image_code": "/*\n@title Simple Circle\n@author jonobr1 / http://jonobr1.com/\n*/\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nconst float radius = 0.25; // @param min 0, max 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat r = radius * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = circle(uv, center, r, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 112, 149, 149, 198], [200, 279, 334, 334, 432], [485, 485, 542, 542, 876]], "test": "untested"}
{"id": "fdscD2", "name": "Basic Image Processing [ppxxll]", "author": "robclouth", "description": "Basic image processing matrices.", "tags": ["imageprocessing", "saturation", "brightness", "constrast", "ppxxll"], "likes": 0, "viewed": 276, "published": 3, "date": "1642771436", "time_retrieved": "2024-07-30T17:08:14.543148", "image_code": "/*\n@title Basic Image Processing\n@author WojtaZam\n*/\n\nmat4 brightnessMatrix( float brightness )\n{\n    return mat4( 1, 0, 0, 0,\n                 0, 1, 0, 0,\n                 0, 0, 1, 0,\n                 brightness, brightness, brightness, 1 );\n}\n\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) / 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\n\n\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}\n\nconst float brightness = 0.; // @param min -1, max 1\nconst float contrast = 1.0; // @param min 0, max 2\nconst float saturation = 1.; // @param min 0, max 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture( iChannel0, fragCoord/iResolution.xy );\n    \n\tfragColor = brightnessMatrix( brightness ) *\n        \t\tcontrastMatrix( contrast ) * \n        \t\tsaturationMatrix( saturation ) *\n        \t\tcolor;\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdscD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 97, 97, 244], [246, 246, 285, 285, 469], [472, 472, 515, 515, 1021], [1180, 1180, 1237, 1237, 1455]], "test": "untested"}
{"id": "fsXyWX", "name": "Improved scattering fractal", "author": "hamtarodeluxe", "description": "Improved version of my IFS SSS shader: mainly DOF and art direction. Increase AA in buffer A if your GPU can handle it. Define MOUSECONTROL to 1 to use interactive mode and do nice renders.", "tags": ["fractal", "subsurface", "randomwalk"], "likes": 34, "viewed": 792, "published": 3, "date": "1642765430", "time_retrieved": "2024-07-30T17:08:15.486625", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = (uv - 0.5) * 0.995 + 0.5;\n    vec3 col = vec3(1.,0, 0.)* texture(iChannel0, uv).rgb + vec3(0., 1., 1.) * texture(iChannel0, uv2).rgb;\n    vec2 dc = uv - 0.5f;\n    col *= 1./pow((pow(sqrt(0.05+dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define AA 16\n#define MOUSECONTROL 0\n\n#define RWSTEPS 8\n#define FAR 5.\n#define MARCHBIAS 0.001\n#define MAXSTEPS 40\n#define BIAS MARCHBIAS*1.2\n\n#define DENSITY 150.\n#define EXTINCTION vec3(0.25, 0.7, 1.)\n#define LIGHTSTR 50.\nvec3 EXTINCTIONs[]  = vec3[]( vec3(0.3, 0.7, 1.),\n                              vec3(1., 0.6, 0.5),\n                              vec3(0.6, 1.3, 1.3));\n    \nvec3 ALBEDOs[]  = vec3[]( vec3(.9, 0.97, .89),\n                          vec3(1., 1., 0.87),\n                          vec3(0.99, 0.9, 0.98)\n                          );\n\nvec3 EMISSIVEs[]  = vec3[]( vec3(0.01, 0.01, 0.02),\n                            vec3(0.021, 0.02, 0.01),\n                            vec3(0.02, 0.01, 0.02));\n    \nstruct Hit \n{\n\tfloat t; \n    bool hasHit;\n    vec3 position;\n};\n\nstruct Scene\n{\n    vec3 lightPosition;\n    vec3 lightIntensity;\n \tvec3 sigmaS;\n    vec3 sigmaA;\n    vec3 emissive;\n    uvec2 random;\n    int bounces;\n    float time;\n};\n\n// Float generator\nfloat nextFloat(inout uvec2 random)\n{\n\trandom.x += 1u; \n    return clamp(hash21(random),0.0000,1.);\n}\n\n// SDF\n\n#define SDF \\\nfloat t = scene.time*0.5;\\\nvec3 a = 0.1*vec3(0., t, t + PI);\\\nint k = 0;\\\nfor( k=0;k<km;k++){\\\n    p.xyz = abs(p.zxy);\\\n    p.xyz = p.xyz*vec3(2.,2.,2.)-vec3(0.6,0.6,0.6);\\\n    p.xy *= rot(a.z);\\\n    p.zx *= rot(a.y);\\\n}\\\nreturn (length(p)-1.0)/pow(2.,float(k));\\\n\nfloat sdf(vec3 p, Scene scene)\n{\n    int km = 7;\n    SDF\n}\n\nfloat sdfLow(vec3 p, Scene scene)\n{\n    int km = 3;\n    SDF\n}\n\nvec3 estimateNormal(vec3 pos, Scene scene)\n{\n \tvec3 normal = vec3(0.);\n    float d = 0.0001;\n    normal.x = sdf(pos + vec3(d,0.,0.), scene) - sdf(pos - vec3(d,0.,0.), scene);\n    normal.y = sdf(pos + vec3(0.,d,0.), scene) - sdf(pos - vec3(0.,d,0.), scene);\n    normal.z = sdf(pos + vec3(0.,0.,d), scene) - sdf(pos - vec3(0.,0.,d), scene);\n\treturn normalize(normal);\n}\n\nHit intersectSdf(vec3 ro, vec3 rd, Scene scene, float startSign, int steps)\n{\n    Hit hit;\n    hit.hasHit = false;\n\tfloat s = startSign;\n    vec3 p;\n    float t;\n    float closestD = MARCHBIAS * 1.5;\n    for(int i = 0; i < steps; i++)\n    {\n    \tp = ro + t*rd;\n     \tfloat d = sdf(p, scene);\n        if (s*d < closestD)\n        {\n            closestD = d;\n            hit.hasHit = true;\n            hit.t = t;\n            hit.position = p;\n        }\n    \tif(s*d < MARCHBIAS)\n        {\n        \tbreak;\n        }\n        if(s*d >= FAR) break;\n        t+=s*d;\n    }\n    return hit;\n}\n\n// Monte carlo\n\nvec3 sampleSurfaceBSDF(vec3 normal, inout uvec2 random, out float pdf)\n{\n\tvec2 h = vec2(nextFloat(random), nextFloat(random));\n\t\n    vec2 d = vec2(sqrt(h.x),2.*PI*h.y);\n    d = vec2(d.x*sin(d.y),d.x*cos(d.y));\n    \n    vec3 ray = vec3(d.x,sqrt(max(0.,1.-d.x*d.x-d.y*d.y)),d.y);\n    float ct = dot(ray,vec3(0.,1.,0.));\n\n   \tvec3 up = normal;\n    vec3 right =  normalize(vec3(-up.y,0.1,up.x));\n    vec3 fw = normalize(cross(right, up));\n    right = normalize(cross(fw,up));\n    ray = mat3x3(right,up,fw)*ray;\n       \n   \tpdf = ct/PI;\n    return ray;\n}\n\nvec3 sampleMediumBSDF(inout uvec2 random)\n{\n    vec2 h = vec2(nextFloat(random),nextFloat(random));\n    float polar = acos(2.*h.x-1.);\n    float azimuth = 2.*PI*h.y;\n    vec3 ray = sphToCart(vec3(1.,polar,azimuth)); \n    return ray;\n}\n\nfloat sampleMediumScattering(inout uvec2 random, vec3 S)\n{\n    int ch = int(floor(3.*nextFloat(random)));  \n\tfloat t = -log(1.-nextFloat(random))/(S[ch]);\n        \n    return t;   \n}\n\nvec3 sampleMediumBSDF(inout uvec2 random, out float pdf)\n{            \n\tvec2 h = vec2(nextFloat(random), nextFloat(random));   \n    float polar = acos(h.x*2.-1.);  \n    float azimuth = 2.*PI*h.y;\n    vec3 ray = sphToCart(vec3(1., polar, azimuth));\t\n   \tpdf = 1./(4.*PI);\n    return ray;\n}\n\n//BSDF\nvec3 evaluateSurfaceBSDF(vec3 normal, vec3 wo, vec3 wi)\n{\n\treturn vec3(1.)/PI;\n}\n\n// Integrator\nvec3 traceSdf(vec3 ro, vec3 rd, inout Scene scene)\n{\n    int bounces = 0;\n    vec3 tp = vec3(1.);\n    vec3 col = vec3(0.);\n    bool inVolume = false;\n    vec3 pos = ro;\n    vec3 ray = rd;\n    vec3 sigmaT = scene.sigmaS + scene.sigmaA;\n    Hit hit;\n\n    hit = intersectSdf(pos, ray, scene, 1.0f, MAXSTEPS);\n\n    if(!hit.hasHit) return vec3(0.00051);\n            \n    vec3 normal = estimateNormal(hit.position, scene);\n    float pdf;\n    \n    // Update tp with surface interaction\n    vec3 wi = sampleSurfaceBSDF(-normal, scene.random,pdf);// uniform hemisphere\n    vec3 wo = -ray;\n    vec3 bsdf = evaluateSurfaceBSDF(-normal, wo,wi); // 1/PI\n    tp *= (bsdf/pdf)*saturate(dot(wi,-normal));\n    pos = hit.position-BIAS*normal;\n    ray = wi;\n    \n    bounces++;\n    bool first = true;\n    while (bounces < RWSTEPS)\n    {\n\n        // Sample scattering event\n        float t = sampleMediumScattering(scene.random, sigmaT);\n        inVolume = sdfLow(pos + ray*t, scene) < 0.00f;\n        \n        if(inVolume)\n        {\n            // Update tp with scattering event\n            pos = pos + ray*t;\n            vec3 pdff = inVolume ? sigmaT*exp(-sigmaT*t) : exp(-sigmaT*t);\n            float pdf = (pdff.x+ pdff.y+ pdff.z)/3.; \n            vec3 tr = exp(-sigmaT*t);\n            tp *= inVolume ?(scene.sigmaS)*tr*(1./pdf) : tr*(1./pdf);\n            \n            // Sample medium BSDF\n            vec3 wi = sampleMediumBSDF(scene.random, pdf); \n            vec3 wo = -ray;\n            vec3 mediumBsdf = vec3(1./(4.*PI));\n            float mediumPdf = pdf;\n            tp *= mediumBsdf/mediumPdf;\n            ray = wi;\n        }\n        else // Exiting volume\n        {\n            hit = intersectSdf(pos, ray, scene, -1.0f, MAXSTEPS);\n\n            t = hit.t;\n            pos = pos + ray*t;\n            hit.position = pos;\n            \n            vec3 pdff = exp(-sigmaT*t);\n            float pdf = (pdff.x+ pdff.y+ pdff.z)/3.; \n            vec3 tr = exp(-sigmaT*t);\n            tp *= tr*(1./pdf);\n\n            vec3 normal = estimateNormal(hit.position, scene);\n            \n            // Do direct lighting\n            vec3 wo = -ray;\n            vec3 lp = scene.lightPosition;\n            vec3 lightRay = lp-pos;\n            float l = length(lightRay);\n            vec3 wi = lightRay/l;\n            vec3 bsdf = evaluateSurfaceBSDF(normal, wo, wi);           \t\n            Hit occlusion = intersectSdf(pos+normal * BIAS, wi, scene, 1.0f, MAXSTEPS);\n            vec3 lightIntensity = vec3(0.);\n            if(!occlusion.hasHit || occlusion.t>l)\n                lightIntensity = scene.lightIntensity/(l*l);\n    \n            col += tp*bsdf*lightIntensity*saturate(dot(normal,wi)) + tp * scene.emissive;\n\n            break;\n        }\n\n        bounces++;\n                   \n    }\n\n    return col;\n}\n\nvoid camera(vec2 pixel_coords, vec3 pos, vec3 rg, vec3 up, vec3 fw, float focal, vec2 rand, out vec3 ro, out vec3 rd)\n{\n\tvec2 pixelCoordsN = vec2(pixel_coords)/iResolution.xy;\n\tvec2 dc = (pixelCoordsN*2.-1.);\n\tdc.y *= float(iResolution.y)/float(iResolution.x);\n\tro = pos;\n\tfloat fo = 1.;\n\tro += (fw * fo + up * dc.y + rg * dc.x);    \n\trd = normalize(ro - pos);\n    rand = 0.175 * (rand);\n    ro = (ro + rand.x*rg + rand.y*up);\n    vec3 onFocalPlane = pos + rd * (focal / dot(rd,fw));\n    rd = normalize(onFocalPlane - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int frame =iFrame;\n    bool first = iFrame == 0;\n    #if MOUSECONTROL\n        frame = int(iMouse.x)*1000;\n        first = first || (iMouse.z > 0.);\n    #else\n        first = first || (frame % 400 == 0);\n    #endif\n    \n    int sceneI = ((frame/400) + 51) % 1000;\n    \n    Scene scene;\n    scene.time = 100.*float(sceneI)+0.005*float(frame%400);\n    \n    vec3 camPos = vec3(cos(0.01*scene.time)*3.,sin(0.01*scene.time),sin(0.01*scene.time)*3.);\n    camPos = camPos * (0.95 + 0.15f * sin(scene.time));\n   \n    vec3 lookAt = vec3(+0.1,0.05,-0.1);\n    vec3 fw = normalize(lookAt-camPos);\n\tvec3 rg = normalize(vec3(-fw.z,sin(0.0008*scene.time+PI*0.5),fw.x))*0.25;\n\tvec3 up = normalize(cross(rg,fw))*0.25;\n    \n    int index = sceneI%3;\n    vec3 albedo = ALBEDOs[index];\n    float density = DENSITY * (1.0 + 0.8 *hash(float(sceneI)*666.66));\n    vec3 extinction = EXTINCTIONs[index];\n\tscene.sigmaS = albedo*extinction;\n    scene.sigmaA = extinction-scene.sigmaS;\n    scene.sigmaS *= density;\n    scene.sigmaA *= density;\n    scene.lightPosition = vec3(camPos) + 4.*rg + 1.5*fw - 0.5*up;\n    scene.lightIntensity = LIGHTSTR*vec3(1.,1.,1.);\n    scene.emissive = EMISSIVEs[index];\n    // Init. random\n    uint seed = uint(fragCoord.x + iResolution.x*fragCoord.y )+ uint(iFrame%1000)*uint(iResolution.x*iResolution.y);\n    scene.random =  uvec2(0,seed);   \n    \n    vec3 col = vec3(0.);   \n\n\n    float d = 0.;\n    float focal = 10.;\n    if(!first)\n        focal = texelFetch(iChannel0, ivec2(0,0),0).w;\n    float rot = nextFloat(scene.random)*2.*PI;\n    vec2 os = (vec2(nextFloat(scene.random),nextFloat(scene.random))-0.5)*0.2;\n    vec2 rand;\n    for(int i = 0; i < AA && (iFrame != -1); i++)\n    {\n        rand = vogel(i, AA, rot) + os;\n        vec3 rd, ro;        \n        camera(fragCoord, camPos, rg, up, fw, focal, rand, ro, rd);\n        col += traceSdf(ro, rd, scene);\n        d += step(length((uv*2.-1.)-rand),0.015) ;\n    }\n    \n    col /= float(AA);  \n    \n    col = min(col.rgb, vec3(1.));\n    \n    vec3 pCol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n\n    if (ivec2(fragCoord).x == 0 && ivec2(fragCoord).y == 0)\n    {\n        float t = 1.;\n        camPos += 0.3*(rg * os.x + up * os.y);\n        for (int i = 0; i < 20; i++)\n        {\n            float d = sdf(camPos + t * fw, scene);\n            if (d< MARCHBIAS)\n                break;\n            t += d;\n        }\n        focal = clamp(0.1, 10., mix(focal, t+0.01, 0.2f));\n    }\n    \n    float taa = 0.2f;\n    \n    #if MOUSECONTROL\n        taa = 0.02f;\n    if (first)\n        taa = 1.0f;\n    #endif\n    \n    fragColor = vec4(mix(pCol, col.rgb, taa), focal);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n\n//random\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nvec2 vogel(int i, int samples, float rot) \n{\n        float theta = 2.4 * float(i)+rot;\n        float r = sqrt(float(i) + 0.5) / sqrt(float(samples));\n        vec2 u = r * vec2(cos(theta), sin(theta));\n        vec2 pos = u;\n        return pos;\n}\n\n//random\nfloat hash21( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    float f = float(n) * (1.0/float(0xffffffffU));\n    \n    return f;\n}\n\n//math\nfloat gauss(float x, float c)\n{\n\treturn exp(-pow(x,2.)/pow(2.*c,2.));\n\n}\n\nvec3 gamma(vec3 x, float gamma)\n{\n\treturn vec3(pow(x.x,gamma),pow(x.y,gamma),pow(x.z,gamma));\n}\n\nfloat saturate( float x) { return clamp(x,0.,1.);}\n\nvec3 saturate (vec3 x) { return vec3 (saturate(x.x),saturate(x.y),saturate(x.z));}\n            \nfloat smallestPositive(float x,float y)\n{\n\tif(x<0.&&y>=0.) return y;\n    if(y<0.&&x>=0.) return x;\n    else return min(x,y);\n}\n\nvec3 cartToSph(vec3 pos)\n{\n\tfloat r = length(pos);\n\treturn vec3(r,acos(pos.y/r),atan(pos.z,pos.x));//wikipedia physics convention\n}\n\nvec3 sphToCart(vec3 sc) //vec3 (radius, polar, azimuth)\n{\t\n\tfloat x = sc.x * sin(sc.y) * cos(sc.z);\n\tfloat z = sc.x * sin(sc.y) * sin(sc.z);\n\tfloat y = sc.x * cos(sc.y);\n\treturn vec3(x,y,z);\n}\n\nvec3 RGBToXYZ(vec3 rgb) {\n   \tvec3 xyz;\n    xyz[0] = 0.412453f * rgb[0] + 0.357580f * rgb[1] + 0.180423f * rgb[2];\n    xyz[1] = 0.212671f * rgb[0] + 0.715160f * rgb[1] + 0.072169f * rgb[2];\n    xyz[2] = 0.019334f * rgb[0] + 0.119193f * rgb[1] + 0.950227f * rgb[2];\n\n\treturn xyz;\n}\n\nmat2x2 rot(float angle)\n{\n    float ca = cos(angle);\n    float sa = sin(angle);\n    return mat2x2(ca, -sa,\n\t\t\t\t  sa, ca);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 393]], "test": "untested"}
{"id": "sssyzM", "name": "Ray-tracer by LinusDev", "author": "Pro_Coder", "description": "Simple Ray-tracer", "tags": ["raytracer"], "likes": 0, "viewed": 201, "published": 3, "date": "1642764403", "time_retrieved": "2024-07-30T17:08:16.423121", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 postProcessingData = GET(iChannel1, POST_PROC_TEXEL);\n\n    vec3 col = abs(bufA.rgb);\n    \n    // Output to screen\n    fragColor = vec4(min(col, col / postProcessingData.a ),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Light lights[] = Light[](\n  //Light(vec3(5., 13., 0.), vec3(0.,0., 1.), vec3(0.0), 0.0),\n  //Light(vec3(0., 13., 5.), vec3(1., 0., 0.), vec3(0.0), 0.0),\n  //Light(vec3(0., 7., 0.), vec3(0., 1., 0.), vec3(0.0), 0.0)\n  Light(vec3(0., 13., 0.), vec3(3., 3., 3.), vec3(0.0), 0.0)\n);\n\n\nfloat getDistance(vec3 pos, out uint hitId){\n    hitId = 0u;\n    float dis = RENDER_DISTANCE;\n    \n    float disYPlane = abs(pos.y+0.1)-0.1;\n    float disBox1 = sdfBox(pos, vec3(0., 0.5, 0.), vec3(1.));\n    float disBox2 = sdfBox(pos, vec3(3.5, 5., 0.), vec3(1., 10., 10.));\n    float disBox3 = sdfBox(pos, vec3(-2, 5., -5.5), vec3(10., 10., 1.));\n    \n    mmin(dis, disYPlane, hitId, GROUND_ID, 0u);\n    \n    mmin(dis, sdfSphere(pos, vec3(0.0, 4.0, 0.0), 1.6), hitId, SUN_ID, 0u);\n    mmin(dis, sdfSphere(pos, EARTH_POS, 0.5), hitId, EARTH_ID, 0u);\n    mmin(dis, sdfSphere(pos, MOON_POS, 0.20), hitId, MOON_ID, 0u);\n    \n    return dis;\n}\n\nfloat getDistance(vec3 pos){\n    uint a;\n    return getDistance(pos, a);\n}\n\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nHit rayMarch(Ray r){\n    \n    Hit hit = Hit(r.o, 0.0, NO_HIT_ID);\n    \n    float dis = 1000.;\n    for(uint i = 0u; i < MAX_STEPS; i++){\n        dis = getDistance(hit.pos, hit.id);\n        hit.dis += dis;\n        \n        hit.pos = r.o + r.d * hit.dis;\n        \n        if(dis < MIN_DISTANCE || hit.dis >= r.md){\n            break;\n        }\n    }\n    \n    if(dis > MIN_DISTANCE) {\n        hit.id = NO_HIT_ID;\n    }\n    \n    return hit;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinates from -1 to 1. x coordinates may exceed 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5) / (iResolution.yy*.5);\n    vec4 col = vec4(0.0);\n\n    //read Vars\n    vec4 camPosition = GET(iChannel1, CAM_POS_TEXEL); //xyz = pos; w = distance to screen\n    vec4 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL);\n    \n    //calc ray Direction\n    vec3 screenXVector = cross(viewDirection.xyz, UP_VECTOR);\n    vec3 screenYVector = -cross(viewDirection.xyz, screenXVector);\n    \n    vec3 rayDirection = viewDirection.xyz * camPosition.w + screenXVector * uv.x + screenYVector  * uv.y;   \n    rayDirection = normalize(rayDirection);\n    \n    \n    Hit hit = rayMarch(Ray(camPosition.xyz, rayDirection, RENDER_DISTANCE));\n    \n    if(hit.id != NO_HIT_ID){\n        if(hit.id == GROUND_ID){\n            col.rgb = vec3(.6, 0.4, 0.25);\n        }else if(hit.id == SUN_ID){\n            col.rgb = vec3(0.9, 0.9, 0.2);\n        }else if(hit.id == EARTH_ID){\n            col.rgb = vec3(.3, .7, 1.);\n        }else if(hit.id == MOON_ID){\n            col.rgb = vec3(.7);\n        }\n        \n        vec3 normal = getNormal(hit.pos);\n        vec3 lightColor = vec3(0.0);\n        \n        for(int i = 0; i < lights.length(); i++){\n            Light light = lights[i];\n         \n            \n            vec3 dir = light.position - hit.pos;\n            float dis = length(dir);\n            dir = normalize(dir);\n            Hit lHit = rayMarch(Ray(hit.pos + normal*0.001, dir, dis));\n            \n            if(lHit.id == NO_HIT_ID){\n                \n                float angleFact = dot(normal, dir);\n                float disFact = 1. / (1. + dis*dis*.001);\n                \n                float inte = angleFact*disFact;\n\n                lightColor += light.color * inte;       \n              \n            }\n            \n        }\n        \n        col.rgb *= lightColor;\n        \n        //col.rgb = abs(normal);\n    }else {\n        col.rgb = vec3(0.3, 0.6, 0.8)*3.;\n    }\n\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n *\n *\n * World Stuff\n *\n *\n */\n#define UP_VECTOR vec3(0., 1., 0.)\n\n#define CAM_START_POS vec3(10., 8., 0.)\n#define CAM_START_DIS_TO_SCREEN 1.\n#define CAM_START_LOOK_AT_POSITION vec3(1., 1., 1.)\n\n/*\n *\n *\n * Constants\n *\n *\n */\n#define PI 3.14\n\n/*\n *\n *\n * Vars\n *\n *\n */\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n#define GI_DATA         ivec2(0, 2)\n#define POST_PROC_TEXEL ivec2(0, 3)\n\n/*\n *\n *\n * Ray-tracer\n *\n *\n */\n#define MIN_DISTANCE 0.0001\n#define MAX_STEPS 1000u\n#define RENDER_DISTANCE 100.\n\nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n}\nfloat sdfBox(vec3 pos, vec3 center, vec3 size){\n    pos -= center;\n    vec3 d = abs(pos) - size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\nfloat sdfSphere(vec3 pos, vec3 center, float radius){\n    return length(pos-center)-radius;\n}\n\n\n\n/*void mmin(inout float dis, float b, inout uint id, uint idB, uint ignoreId) {\n    if(dis < b || ignoreId == idB) return;\n    dis = b;\n    id = idB;\n}*/\n\n#define mmin(currentDis, thisDis, currentId, thisId, ignoreId) if(thisId != ignoreId && currentDis > thisDis) {currentDis = thisDis; currentId = thisId;}\n\nvoid mmin2(inout float dis, float b, inout uint id, uint idB, uint ignoreId, uint inverseId) {\n    if(idB == inverseId) b = -b;\n    if(dis < b || ignoreId == idB) return;\n    dis = b;\n    id = idB;\n}\n\n//Distance function\n#define NO_HIT_ID 0u\n\n#define GROUND_ID 4u\n\n#define SUN_ID 1u\n\n#define EARTH_ID 2u\n#define EARTH_POS vec3(sin(iTime)*5., 4.0, cos(iTime)*5.)\n\n#define MOON_ID 3u\n#define MOON_POS (EARTH_POS + vec3(sin(iTime*2.), 0.0, cos(iTime*2.)))\n\n\n//Ray marching\n\nstruct Ray {\n    vec3 o;//origin\n    vec3 d;//distance\n    float md;//max distance\n};\n\nstruct Hit {\n    vec3 pos;\n    float dis;\n    uint id;\n};\n\n\n//light\n\nstruct Light{\n    vec3 position;\n    vec3 color;\n    vec3 direction;  //spotlight only\n    float angle;     //spotlight only\n    \n};\n\n/*\n *\n *\n * Functions\n *\n *\n */\n\nmat3 rotAroundYAxis(float angle){\n   return mat3( cos(angle) , 0.,  sin(angle),\n                0.         , 1.,  0.        ,\n                -sin(angle), 0.,  cos(angle)); \n}\n\nmat3 rotAroundZAxis(float angle){\n   return mat3( cos(angle) , -sin(angle), 0.,\n                sin(angle) , cos(angle) , 0.,\n                0.         , 0.         , 1.); \n}\n\nmat3 rotAroundXAxis(float angle){\n   return mat3( 1. , 0.         , 0.         ,\n                0. , cos(angle) , -sin(angle),\n                0. , sin(angle) , cos(angle)); \n}\n\n", "buffer_b_code": "//Keyboard and storage buffer\n\n\n#define MOVE_SPEED 0.5\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type, sampler2D channel){\n    return texture( channel, vec2(checkKey, type)).r > 0.0;\n}\n\n#define KEYBOARD_CHANNEL iChannel0\n#define BACK_BUFFER_CHANNEL iChannel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(POST_PROC_TEXEL)){\n            vec4 oldData = GET(BACK_BUFFER_CHANNEL, POST_PROC_TEXEL);\n            \n            #define M_P_TEX(channel, x, y) (pow(texture(channel, vec2(x, y)).rgb + 1., vec3(1.5)) - 1.)\n            #define M_P_AVG(c, m) (0.25 * M_P_TEX(c, m, m) + 0.25 * M_P_TEX(c, m, 1.-m) + 0.25 * M_P_TEX(c, 1.-m, m) + 0.25 * M_P_TEX(c, 1.-m, 1.-m))\n            \n            vec3 a1 = M_P_AVG(iChannel2, 0.1);\n            vec3 a2 = M_P_AVG(iChannel2, 0.2);\n            vec3 a3 = M_P_AVG(iChannel2, 0.3);\n            vec3 a4 = M_P_AVG(iChannel2, 0.4);\n            vec3 b1 = M_P_AVG(iChannel2, 0.42);\n            vec3 c1 = M_P_AVG(iChannel2, 0.43);\n            vec3 c2 = M_P_AVG(iChannel2, 0.44);\n            vec3 c3 = M_P_AVG(iChannel2, 0.45);\n            vec3 c4 = M_P_AVG(iChannel2, 0.46);\n            vec3 c5 = M_P_AVG(iChannel2, 0.47);\n            vec3 c6 = M_P_AVG(iChannel2, 0.48);\n            \n            vec3 res = .15 * a1 + .15 * a2 + .15 * a3 + .15 * a4\n                        + 0.0571 * b1\n                        + 0.0571 * c1\n                        + 0.0571 * c2\n                        + 0.0571 * c3\n                        + 0.0571 * c4\n                        + 0.0571 * c5\n                        + 0.0571 * c6;\n\n            oldData.rgb = mix(oldData.rgb, res, 0.03);\n            oldData.a = min(vmax(oldData.rgb), 2.5);\n            fragColor = oldData;\n        }\n        else if(DO_SAVE(GI_DATA)){\n            vec4 data = GET(BACK_BUFFER_CHANNEL, GI_DATA);\n            if(isKey(KEY_R, IS_PRESSED, KEYBOARD_CHANNEL)){\n                fragColor = vec4(1., float(iFrame), 0., 0.);\n            }else{\n                fragColor = vec4(0., data.y, 0., 0.);\n            }\n            \n        }\n        else if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(BACK_BUFFER_CHANNEL, CAM_POS_TEXEL);\n            vec4 vdir = GET(BACK_BUFFER_CHANNEL, VIEW_DIR_TEXEL);\n            vec2 v = normalize(vdir.xz);\n            vec2 t = normalize(cross(UP_VECTOR, vdir.xyz)).xz;\n    \n            float speed = MOVE_SPEED;\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED, KEYBOARD_CHANNEL)){//forward\n                pos.xz += v * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED, KEYBOARD_CHANNEL)){//backward\n                pos.xz -= v * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED, KEYBOARD_CHANNEL)){//left\n                pos.xz += t * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED, KEYBOARD_CHANNEL)){//right\n                pos.xz -= t * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(BACK_BUFFER_CHANNEL, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                vec2 nxz = normalize(vec2(viewDirection.z, viewDirection.x));\n                float angleXZ = atan(nxz.x, nxz.y);\n                \n                angleXZ += ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05;\n                viewDirection.a -= ((iMouse.y-iResolution.y*.5)/iResolution.x)*PI*0.05; // angle XY\n                \n                viewDirection.a = clamp(viewDirection.a, -PI/2., PI/2.);\n               \n                viewDirection.xyz = rotAroundYAxis(angleXZ) * rotAroundZAxis(viewDirection.a) * vec3(1., 0., 0.);\n            }\n               \n            \n            fragColor = viewDirection;\n            return;    \n        }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_START_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(CAM_START_LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 0.0);\n\n         }    \n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 309]], "test": "untested"}
{"id": "7lVSDD", "name": "Tiny paint streams (530char)", "author": "davidar", "description": "Not as physically accurate as [url]https://www.shadertoy.com/view/WtfyDj[/url], but 10x smaller", "tags": ["simulation", "fluid", "convolution", "2tweets", "golf"], "likes": 26, "viewed": 545, "published": 3, "date": "1642762034", "time_retrieved": "2024-07-30T17:08:17.435414", "image_code": "M - 1. + A.w * vec4(0, A.z, 1. - A.z, 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M; float G, m = A.w;\n    // iterate over neighbouring cells\n    // A.xy = velocity\n    // A.z = pigment\n    // A.w = density\n    for(int k = 81; k-->0;)\n        i = vec2(k%9,k/9)-4.,\n        x = i + A.xy, // move particle according to velocity\n\n        // Gaussian diffusion, sigma=sqrt(.5)\n        G = A.w / exp(dot(x,x)) / 3.142,\n\n        // advection\n        r += vec4(A.xyz, 1) * G,\n    \n        // pressure forces (smoothed particle hydrodynamics)\n        f -= ( m*m-m       // pressure at current position\n                           // density * (density - reference fluid density)\n             + A.w*A.w-A.w // pressure at neighbour position\n             ) * G * x;    // gradient of smoothing kernel\n\n    if(r.w > 0.) // not vacuum\n        r.xyz /= r.w, // convert momentum to velocity, normalise pigment\n        r.xy += clamp(f / r.w, -.1, .1); // acceleration\n    \n    // gravity\n    r.y -= .005;\n\n    // boundary\n    if(u.y < 9.) r.y += 1.;\n    \n    // streams\n    r = length(u - R * vec2(.2, .9)) < 9. ?\n            vec4(sin(iTime) + 2., -1, 0, 1) :\n        length(u - R * vec2(.8, .9)) < 9. ?\n            vec4(sin(iTime) - 2., -1, 1, 1) :\n        iFrame < 2 && u.y > .8*R.y ? // init\n            vec4(0,0, u.x < R.x/2., 1) :\n        r;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A texture(iChannel0,vec2(u+i)/R)\n#define M void mainImage(out vec4 r, vec2 u) { vec2 x, i = u-u, f = i; r -= r", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dlyW2", "name": "Base Grid Shader", "author": "cambalamas", "description": "Base Grid", "tags": ["grid", "basic"], "likes": 3, "viewed": 202, "published": 3, "date": "1642752055", "time_retrieved": "2024-07-30T17:08:18.326033", "image_code": "#define GRID_VIEW 0\n#define TRUCHET   1\n#define DYNAMIC   1\n#define UV_SCALE  15.0\n\n\n//===================\n\n#define ARROW_STEM_THICKNESS 0.02\n#define ARROW_STEM_ANTIALIAS 5.0\n#define ARROW_HEAD_WIDTH     0.1\n#define ARROW_HEAD_HEIGHT    0.2\n#define ARROW_HEAD_ANTIALIAS 25.0\n#define SCALE 1.25\n\nfloat vector_projection_scalar(vec2 vec_a, vec2 vec_b){\n    return dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\nfloat df_line_segment(vec2 vec_p, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ap = vec_p - vec_a;  // Displacement vector from vec_a to vec_p\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 vproj_ap_ab = dvec_ab * clamp(vector_projection_scalar(dvec_ap, dvec_ab), .0, 1.);  // Vector projection from ap to ab\n    return distance(dvec_ap, vproj_ap_ab) - ARROW_STEM_THICKNESS;  // Distance field! This is IT!\n}\nfloat sdf_triangle(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement-vector\n    vec2 dvec_ac = vec_c - vec_a;  // Displacement-vector\n    vec2 dvec_ap = vec_p - vec_a;  // Displacement-vector\n    float det_dvec_ab_dvec_ac = dvec_ab.x * dvec_ac.y - dvec_ac.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ac\n\tfloat det_dvec_ap_dvec_ac = dvec_ap.x * dvec_ac.y - dvec_ac.x * dvec_ap.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ap and dvec_ac\n    float det_dvec_ab_dvec_ap = dvec_ab.x * dvec_ap.y - dvec_ap.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ap\n    float inv_det_dvec_ab_dvec_ac = 1. / det_dvec_ab_dvec_ac;  // Multiplicative-inverse of a determinant\n    float bary_x = det_dvec_ap_dvec_ac * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_y = det_dvec_ab_dvec_ap * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_z = 1. - bary_x - bary_y;  // The last barycentric coordinate is easy!\n    return min(min(bary_x, bary_y), bary_z);\n}\nstruct Arrow\n{\n    vec2  base;  // Position vector!\n    float dir;   // Angle!\n    float norm;  // Positive number!\n};\nfloat draw_arrow(vec2 uv, Arrow arrow){\n\tvec2  base = arrow.base;\n    float dir  = arrow.dir;\n    float norm = arrow.norm;\n    uv = mat2(cos(dir), -sin(dir), sin(dir), cos(dir)) * uv;  // Rotate local coordinates by complex left-multiplication\n    float stem_len = max(.0, norm - ARROW_HEAD_HEIGHT);\n    float stem = df_line_segment(uv, base, base + vec2(stem_len, .0));\n    vec2  head_a = base + vec2(norm, .0);\n    vec2  head_b = base + vec2(stem_len, .0 + ARROW_HEAD_WIDTH);\n    vec2  head_c = base + vec2(stem_len, .0 - ARROW_HEAD_WIDTH);\n    float head   = sdf_triangle(uv, head_a, head_b, head_c);\n    stem = smoothstep(ARROW_STEM_ANTIALIAS / iResolution.y, .0, stem);\n    head = smoothstep(0., ARROW_HEAD_ANTIALIAS / iResolution.y, head);\n    return max(stem, head);\n}\n\n//===================\n\n\nfloat Hash21(in vec2 p)\n{\n    p = fract(p*vec2(134.34, 435.345));\n    p += dot(p,p+64.23);\n    return fract(p.x*p.y);\n}\n\nvoid genArrow(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    Arrow arrow;\n    arrow.base = vec2(0,0);\n    arrow.dir  = -2.15;\n    arrow.norm = (.5 * sin(iTime)) + .85;\n    float arrow_df = draw_arrow(uv, arrow);\n\n    fragColor.rgb = vec3(arrow_df);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\n    // UVs\n    vec2 uv = UV_SCALE * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // Time\n    float tScl = .00000003;\n    \n    // Grid Generation\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n\n    // Animation\n#if DYNAMIC\n    float n = Hash21(id + iTime*tScl);\n#else\n    float n = Hash21(id);\n#endif\n\n    // Color\n    vec3 col = vec3(n);\n    \n    // Truchet\n#if TRUCHET\n    if (n<.5) gv.x *= -1.;\n    float d = abs( abs(gv.x + gv.y) - .5 );\n    float halfThickness = .2;\n    float mask = smoothstep(.01, -.01, d-halfThickness);\n    //col = vec3(0) + ( mask==1. ? vec3(.6,.8,.9) : vec3(.3,.6,.8) ); // Cold\n    col = vec3(0) + ( mask==1. ? vec3(.9,.6,.4) : vec3(.8,.4,.3) ); // Warm\n#endif\n    \n    // Grid Visualization\n#if GRID_VIEW\n    float bound = .46;\n    if (UV_SCALE<=20. && (abs(gv.x)>bound || abs(gv.y)>bound)) col += vec3(.2);\n#endif\n    \n    // Output Color\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 350, 350, 402], [403, 403, 461, 461, 845], [846, 846, 913, 913, 1968], [2088, 2088, 2127, 2127, 2863], [2889, 2889, 2914, 2914, 3008], [3010, 3010, 3064, 3064, 3421], [3423, 3423, 3480, 3498, 4413]], "test": "untested"}
{"id": "sdlcDj", "name": " Sundown", "author": "wyatt", "description": "Repost, original broke", "tags": ["sunset", "fluid"], "likes": 30, "viewed": 479, "published": 3, "date": "1642745162", "time_retrieved": "2024-07-30T17:08:19.478951", "image_code": "Main {\n    U -= .5*R;\n    U *= .6/(.8+.35*U.y/R.y);\n    U += .5*R;\n    U.y += .15*R.y;\n    vec4 a = A(U),\n         n = A(U+vec2(0,1)),\n         e = A(U+vec2(1,0)),\n         s = A(U-vec2(0,1)),\n         w = A(U-vec2(1,0));\n    vec2 g = vec2(e.w-w.w,n.w-s.w);\n    float f = 0.;\n    vec2 u = U;\n    for (float i = -10.; i < 10.; i++) {\n        float w = pow(A(u).w,1.+.01*i);\n        f += w/10.;\n        u = vec2(.5,0)*R+(u-vec2(.5,0)*R)*(1.-.005);\n    }\n    Q = .4+.4*sin(1.-3.*U.y/R.y+5.*H/R.y+vec4(1,2,3,4));\n    Q += 2.*H/R.y;\n    vec2 d = normalize(vec2(.5,0)*R-U);\n    vec2 p = U;\n    float W = 0.;\n    for (float i = 0.; i < 200.; i++) {\n        p += 6.*d;\n        W += .01*A(p).w;\n    }\n    Q -= .4*W;\n    vec4 C = .8+.3*sin(W+1./(1.+a.w)+2.-3.*U.y/R.y+3.*H/R.y+vec4(1,2,3,4));\n    Q = mix(Q,C,f);\n    //Q = vec4(0);\n    { // stars\n    for (float i = 1.;i < 5.; i++)\n    for (int k = 0; k < 9; k++) {\n        vec2 u = round(U)+vec2(k%3,k/3)-1.;\n        vec3 h = hash(u)*2.-1.;\n        vec2 r = u-U+h.xy;\n        float l = 5./i*length(r);\n        Q += 8./i/sqrt(i)*exp(-1e1*f)*10.*(1.+.5*sin(iTime+6.2*h.z))*exp(-5e1*l)*max(2.*U.y/R.y-1.,0.);\n    }}\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 T (vec2 U) {\n    return A(U-A(U).xy);\n}\nMain {\n    Q = T(U);\n    vec4 n = T(U+vec2(0,1)),\n         e = T(U+vec2(1,0)),\n         s = T(U-vec2(0,1)),\n         w = T(U-vec2(1,0));\n    Q.xy= Q.xy-.25*vec2(e.z-w.z,n.z-s.z);\n    Q.xy= Q.xy-.05*vec2(s.w-n.w,e.w-w.w);\n    Q.z = .25*(n.z+e.z+s.z+w.z-n.y-e.x+s.y+w.x);\n    Q.y += 1e-4*Q.w*(1.-2.*U.y/R.y);\n    float h = H;\n    Q.w = mix(Q.w,1.,smoothstep(2.*h,h,U.y));\n    if(U.x<1.||R.x-U.x<1.) Q.xyw *= 0.;\n    if(U.y<1.||R.y-U.y<1.) Q.xyw *= 0.;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define H 50.*exp(-10.*(U.x-.5*R.x)*(U.x-.5*R.x)/R.x/R.x)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec3 hash (vec2 p)\n{\nvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\np3 += dot(p3, p3.yxz+33.33);\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 noise(vec2 p){\n    vec4 w = vec4(floor(p),ceil (p));\n    vec3 _00 = hash(w.xy),\n         _01 = hash(w.xw),\n         _10 = hash(w.zy),\n         _11 = hash(w.zw),\n         _0 = mix(_00,_01,fract(p.y)),\n         _1 = mix(_10,_11,fract(p.y));\n     return mix(_0,_1,fract(p.x));\n}\nvec3 fbm (vec2 p) {\n    vec3 w = vec3(0);\n    float N = 5.;\n    for (float i = 1.; i < N; i++) {\n        p *= 1.7*ei(.5);\n        w += noise(p)/N/i;\n    }\n    return w;\n}\n\n", "buffer_b_code": "vec4 T (vec2 U) {\n    return A(U-A(U).xy);\n}\nMain {\n    Q = T(U);\n    vec4 n = T(U+vec2(0,1)),\n         e = T(U+vec2(1,0)),\n         s = T(U-vec2(0,1)),\n         w = T(U-vec2(1,0));\n    Q.xy= Q.xy-.25*vec2(e.z-w.z,n.z-s.z);\n    Q.xy= Q.xy-.05*vec2(s.w-n.w,e.w-w.w);\n    Q.z = .25*(n.z+e.z+s.z+w.z-n.y-e.x+s.y+w.x);\n    Q.y += 1e-4*Q.w*(1.-2.*U.y/R.y);\n    float h = H;\n    Q.w = mix(Q.w,1.,smoothstep(2.*h,h,U.y));\n    if(U.x<1.||R.x-U.x<1.) Q.xyw *= 0.;\n    if(U.y<1.||R.y-U.y<1.) Q.xyw *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 T (vec2 U) {\n    return A(U-A(U).xy);\n}\nMain {\n    Q = T(U);\n    vec4 n = T(U+vec2(0,1)),\n         e = T(U+vec2(1,0)),\n         s = T(U-vec2(0,1)),\n         w = T(U-vec2(1,0));\n    Q.xy= Q.xy-.25*vec2(e.z-w.z,n.z-s.z);\n    Q.xy= Q.xy-.05*vec2(s.w-n.w,e.w-w.w);\n    Q.z = .25*(n.z+e.z+s.z+w.z-n.y-e.x+s.y+w.x);\n    Q.y += 1e-4*Q.w*(1.-2.*U.y/R.y);\n    float h = H;\n    Q.w = mix(Q.w,1.,smoothstep(2.*h,h,U.y));\n    if(U.x<1.||R.x-U.x<1.) Q.xyw *= 0.;\n    if(U.y<1.||R.y-U.y<1.) Q.xyw *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T (vec2 U) {\n    return A(U-A(U).xy);\n}\nMain {\n    Q = T(U);\n    vec4 n = T(U+vec2(0,1)),\n         e = T(U+vec2(1,0)),\n         s = T(U-vec2(0,1)),\n         w = T(U-vec2(1,0));\n    Q.xy= Q.xy-.25*vec2(e.z-w.z,n.z-s.z);\n    Q.xy= Q.xy-.05*vec2(s.w-n.w,e.w-w.w);\n    Q.z = .25*(n.z+e.z+s.z+w.z-n.y-e.x+s.y+w.x);\n    Q.y += 1e-4*Q.w*(1.-2.*U.y/R.y);\n    float h = H;\n    Q.w = mix(Q.w,1.,smoothstep(2.*h,h,U.y));\n    if(U.x<1.||R.x-U.x<1.) Q.xyw *= 0.;\n    if(U.y<1.||R.y-U.y<1.) Q.xyw *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7slcWj", "name": "Ps3 XMB", "author": "sharads", "description": "ps3", "tags": ["blue", "ps3"], "likes": 10, "viewed": 799, "published": 3, "date": "1642738779", "time_retrieved": "2024-07-30T17:08:20.417441", "image_code": "const vec3 top = vec3(0,0,0);\nconst vec3 bottom = vec3(0.094, 0.141, 0.424);\nconst float widthFactor = 1.5;\n\nvec3 calcSine(vec2 uv, float speed, \n              float frequency, float amplitude, float shift, float offset,\n              vec3 color, float width, float exponent, bool dir)\n{\n    float angle = iTime * speed * frequency * -1.0 + (shift + uv.x) * 2.0;\n    \n    float y = sin(angle) * amplitude + offset;\n    float clampY = clamp(0.0, y, y);\n    float diffY = y - uv.y;\n    \n    float dsqr = distance(y, uv.y);\n    float scale = 1.0;\n    \n    if(dir && diffY > 0.0)\n    {\n        dsqr = dsqr * 4.0;\n    }\n    else if(!dir && diffY < 0.0)\n    {\n        dsqr = dsqr * 4.0;\n    }\n    \n    scale = pow(smoothstep(width * widthFactor, 0.0, dsqr), exponent);\n    \n    return min(color * scale, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(mix(top, bottom, uv.x * uv.y * 1.1));\n    color += calcSine(uv, 0.2, 0.20, 0.2, 0.0, 0.5,  vec3(0.3, 0.3, 0.3), 0.1, 15.0,false);\n    color += calcSine(uv, 0.4, 0.40, 0.15, 0.0, 0.5, vec3(0.3, 0.3, 0.3), 0.1, 17.0,false);\n    color += calcSine(uv, 0.3, 0.60, 0.15, 0.0, 0.5, vec3(0.3, 0.3, 0.3), 0.05, 23.0,false);\n\n    color += calcSine(uv, 0.1, 0.26, 0.07, 0.0, 0.3, vec3(0.3, 0.3, 0.3), 0.1, 17.0,true);\n    color += calcSine(uv, 0.3, 0.36, 0.07, 0.0, 0.3, vec3(0.3, 0.3, 0.3), 0.1, 17.0,true);\n    color += calcSine(uv, 0.5, 0.46, 0.07, 0.0, 0.3, vec3(0.3, 0.3, 0.3), 0.05, 23.0,true);\n    color += calcSine(uv, 0.2, 0.58, 0.05, 0.0, 0.3, vec3(0.3, 0.3, 0.3), 0.2, 15.0,true);\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 287, 287, 807], [809, 809, 866, 866, 1650]], "test": "untested"}
{"id": "NdsyD2", "name": "paintdrip", "author": "Kitesurf_m8s", "description": "khgcf", "tags": ["cahnhilliard"], "likes": 3, "viewed": 437, "published": 3, "date": "1642726525", "time_retrieved": "2024-07-30T17:08:21.223287", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 f(vec4 a){\n    return (2.0*a-6.*a*a+4.0*a*a*a);\n}\n\nfloat f(float a){\n    return (2.0*a-6.*a*a+4.0*a*a*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 uu = texture(iChannel0,uv+vec2(2.,0.)/iResolution.xy);\n    vec4 u = texture(iChannel0,uv+vec2(1.,0.)/iResolution.xy);\n    vec4 c = texture(iChannel0,uv+vec2(0.,0.)/iResolution.xy);\n    vec4 d = texture(iChannel0,uv+vec2(-1.,0.)/iResolution.xy);\n    vec4 dd = texture(iChannel0,uv+vec2(-2.,0.)/iResolution.xy);\n    vec4 ll = texture(iChannel0,uv+vec2(0.,2.)/iResolution.xy);\n    vec4 l = texture(iChannel0,uv+vec2(0.,1.)/iResolution.xy);\n    vec4 r = texture(iChannel0,uv+vec2(0.,-1.)/iResolution.xy);\n    vec4 rr = texture(iChannel0,uv+vec2(0.,-2.)/iResolution.xy);\n    vec4 ul = texture(iChannel0,uv+vec2(1.,1.)/iResolution.xy);\n    vec4 ur = texture(iChannel0,uv+vec2(1.,-1.)/iResolution.xy);\n    vec4 dl = texture(iChannel0,uv+vec2(-1.,1.)/iResolution.xy);\n    vec4 dr = texture(iChannel0,uv+vec2(-1.,-1.)/iResolution.xy);\n    \n    vec4 res = c;\n    //res -= 0.01*f(c);\n    res += 0.01*(f(u)+f(d)-4.*f(c)+f(l)+f(r));\n    res -= 0.02*(20.*c+(uu+dd+ll+rr)+2.0*(ul+ur+dl+dr)-8.0*(u+d+l+r));\n    //res += 0.05*cos(0.3*iTime)*(2.*d-c-u)+0.05*cos(iTime)*(2.*r-c-l);\n    //res += cos(iTime)*0.05*(d-u)-0.05*(r*r-l*l);\n    res += cos(iTime)*0.00*(d-u)-0.01*(r*(r.x+r.y+r.z)-l*(l.x+l.y+l.z));\n    if(iMouse.z>0.){\n        vec4 new = texture(iChannel3,uv);\n        res = 0.99*res+0.01*new;\n        //res = new;\n    }\n    if(iFrame<50){\n        vec4 new = texture(iChannel3,uv);\n        res = new;\n        //res = new;\n    }\n    fragColor = vec4(res.xyz,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 162]], "test": "untested"}
{"id": "NslyD2", "name": "Disco cubes", "author": "user_name", "description": "this is my gaming pc booting at 3am", "tags": ["music", "cubes", "badmusic", "lotsofcolors"], "likes": 17, "viewed": 796, "published": 3, "date": "1642724159", "time_retrieved": "2024-07-30T17:08:22.510844", "image_code": "precision highp float;\n\nfloat grow(vec3 p) {\n    float f = fract(iTime * (22.5 / 60.0) - (length(p) - 10.0) * 0.01);\n    f = smoothstep(0.0, 0.02, f) * smoothstep(0.1, 0.02, f);\n    float f2 = fract(iTime * 1.5);\n    f2 = smoothstep(0.5, 0.0, f2) * smoothstep(0.0, 0.1, f2);\n    f += f2 * 0.2;\n    return -f * 1.5;\n}\n\nfloat cube(vec3 p, vec3 s) {\n    return length(p - clamp(p, -s, s));\n}\n\nfloat square_(vec2 p) {\n    return length(p - clamp(p, vec2(-1.0), vec2(1.0)));\n}\n\nfloat square(vec2 p) {\n    return square_(p / 2.0) * 2.0;\n}\n\nfloat sphere(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat path(vec3 p) {\n    return -max((sphere(p / 9.0) * 9.0), -sphere(p / 6.0) * 6.0);\n}\n\nfloat rand(vec3 co) {\n    float mid = dot(co, vec3(12.9898, 78.233, 45.96483));\n    mid = mod(mid, 3.14);\n    return fract(sin(mid) * 43758.5453);\n}\n\nfloat noise(float t) {\n    return sin(t * 3.4) + sin(t * 1.2 + 0.5);\n}\n\nfloat onoise(float t) {\n    return noise(t) + noise(t * 2.0) * 0.5 + noise(t * 4.0) * 0.25 + noise(t * 8.0) * 0.125;\n}\n\nvoid r(inout vec2 v, float r) {\n    vec2 o = v;\n    float s = sin(r);\n    float c = cos(r);\n    v.x = o.x * s - o.y * c;\n    v.y = o.x * c + o.y * s;\n}\n\nfloat cubegrid(vec3 p) {\n    vec3 rep = floor((p + 2.0) / 4.0);\n    \n    vec3 s = rand(rep) * vec3(1.5, 1.5, 3.5);\n    vec3 o = vec3(rand(rep), rand(rep + vec3(1.0, 6.0, 0.0)), rand(rep + vec3(0.2, 0.9, 12.0)));\n    o = o * 2.0 - 1.0;\n    \n    return cube(p - rep * vec3(4.0) + o, s);\n}\n\nvec3 cam(float t) {\n    return vec3(onoise(t * 0.5), onoise(t * 0.5 + 10.0), onoise(t * 0.5 + 20.0)) * 40.0;\n}\nvec3 cam2(float t) {\n    return vec3(noise(t * 0.5 + 19.4), noise(t * 0.5 + 420.0), noise(t * 0.5 + 4343.0));\n}\n\nfloat grid2(vec3 p) {\n    float s = 10.0;\n    p = mod(p + s, s * 2.0) - s;\n\n    return min(square(p.xy), min(square(p.xz), square(p.yz)));\n}\n\nfloat d(vec3 p, vec3 c) {\n    vec3 ip = p;\n                \n    float r = min(cubegrid(p * 2.0), cubegrid((p * 2.0) + vec3(202.0, 2.0, 2.0)));\n    \n    float g2 = grid2(p);\n    r = max(g2 - 1.5, r);\n    //r = min(r, g2);\n    \n    r += grow(c);\n    \n    return max(r, -(sphere(c / 3.0) * 3.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= (iResolution.x / iResolution.y);\n\n    vec3 col = vec3(0.0);\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(vec3(-1.0, uv * 0.5));\n    \n    vec3 c = cam(iTime * 0.04);\n    pos = -c;\n    vec3 fwd = normalize(c - cam((iTime * 0.04) - 0.001));\n    vec3 right = normalize(cross(fwd, cam2(iTime * 0.02)));\n    vec3 up = cross(fwd, right);\n    dir = mat3(\n        fwd,\n        right,\n        up\n    ) * dir;\n\n\n    int i;\n    float i_f = 0.0;\n    \n    for (i = 0; i < 256; i++) {\n        float x = d(pos, pos + c) * 0.5;\n        if (x < 0.0001) {\n            i_f = 1.0 - clamp(x / 0.0001, 0.0, 1.0);\n            break;\n        }\n        if (x > 1000.0) {\n            i_f = (x - 1000.0) / 1000.0;\n            break;\n        }\n        pos += dir * x;\n    }\n        \n    float f2 = fract(iTime * 1.5 - length(pos + c) * 0.003);\n    f2 = smoothstep(0.5, 0.0, f2) * smoothstep(0.0, 0.1, f2);\n\ncol = 1.0 - pow(vec3((float(256 - i) + i_f) / 256.0), (normalize(pos) + 1.1) * 3.0);\n    col *= (1.0 + f2 * 2.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "precision highp float;\n\nfloat rand(vec2 co) {\n    float mid = dot(co, vec2(12.9898, 78.233));\n    mid = mod(mid, 3.14);\n    return fract(sin(mid) * 43758.5453);\n}\n\nfloat kick(float t) {\n    return smoothstep(0.25, 0.0, t);\n}\n\nfloat cymbal(float t) {\n    return smoothstep(0.0, 0.005, t) * smoothstep(0.13, 0.02, t);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float bps = 90.0 / 60.0;\n    float nps = bps * 4.0;\n    \n    float b_id = floor(mod(time * nps, 19.0));\n    \n    float bfract = fract(time * bps * 0.25);\n    \n    float bartime = fract(time * bps);\n    float ktime = bartime;\n    float camp = cymbal(bartime - 0.5) * 0.6;\n    if (bfract > 0.75) {\n        camp += smoothstep(0.5, 1.0, bartime) * 0.3;\n    }\n    \n    if (bfract > 0.86) {\n        ktime = fract(ktime * 4.0) / 4.0;\n    }\n    \n    //camp += cymbal(fract(time * nps) * 2.0) * 0.2;\n    \n    float bfreq = floor(rand(vec2(b_id, 8.0)) * 6.0) * 3.0 + 140.0;\n    float bhold = rand(vec2(b_id, 0.0)) * 0.4 + 0.6;\n    float bslide = 0.0;\n    if (rand(vec2(b_id, 4.0)) > 0.2) {\n        bslide = (rand(vec2(b_id, 12.0)) * 2.0 - 1.0) * 10.0;\n    }\n    float ntime = fract(time * nps);\n    float bamp = smoothstep(bhold, 0.0, ntime) * smoothstep(0.0, 0.05, ntime);\n    bamp += 2.0 * smoothstep(0.04, 0.0, ntime);\n    float bass = tanh(sin(6.2831*(bfreq*time+bslide*ntime*ntime))*12.0) * sin(6.2831*100.0*time) * 0.1 * bamp;\n    float kick = sin(6.2831*(4.0*log(ktime*20.0 + 0.5)))*kick(ktime);\n    float cym = camp * rand(vec2(ktime * 200.0));\n    float hf = 600.0;\n    float hum = sin(time * 6.2831 * hf * 3.0) + sin(time * 6.2831 * hf * 4.0) * 0.6 + sin(time * 6.2831 * hf * 5.0) * 0.3 + sin(time * 6.2831 * hf * 6.0) * 0.15 + sin(time * 6.2831 * hf * 7.0) * 0.06;\n    hum *= smoothstep(0.02, 0.0, fract(time * bps * 0.5));\n    return vec2(clamp(bass+kick+cym + hum * 0.1, -1.0, 1.0));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 316], [318, 318, 346, 346, 388], [390, 390, 413, 413, 471], [473, 473, 495, 495, 532], [534, 534, 556, 556, 586], [588, 588, 608, 608, 676], [678, 678, 699, 699, 826], [828, 828, 850, 850, 898], [900, 900, 923, 923, 1018], [1020, 1020, 1051, 1051, 1171], [1173, 1173, 1197, 1197, 1459], [1461, 1461, 1480, 1480, 1571], [1572, 1572, 1592, 1592, 1683], [1685, 1685, 1706, 1706, 1825], [1827, 1827, 1852, 1852, 2122]], "test": "untested"}
{"id": "NdscW2", "name": "genuary 19 - txt/typo", "author": "flockaroo", "description": "...quick typography experiment for genuary 2022", "tags": ["text", "font", "genuary"], "likes": 13, "viewed": 376, "published": 3, "date": "1642723057", "time_retrieved": "2024-07-30T17:08:23.539095", "image_code": "// created by florian berger (flockaroo) - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Genuary 2022 - day 19 txt/typography\n\n#define Res (iResolution.xy)\n\n#define A_ 65\n#define B_ 66\n#define C_ 67\n#define D_ 68\n#define E_ 69\n#define F_ 70\n#define G_ 71\n#define H_ 72\n#define I_ 73\n#define J_ 74\n#define K_ 75\n#define L_ 76\n#define M_ 77\n#define N_ 78\n#define O_ 79\n#define P_ 80\n#define Q_ 81\n#define R_ 82\n#define S_ 83\n#define T_ 84\n#define U_ 85\n#define V_ 86\n#define W_ 87\n#define X_ 88\n#define Y_ 89\n#define Z_ 90\n#define a_ (65+32)\n#define b_ (66+32)\n#define c_ (67+32)\n#define d_ (68+32)\n#define e_ (69+32)\n#define f_ (70+32)\n#define g_ (71+32)\n#define h_ (72+32)\n#define i_ (73+32)\n#define j_ (74+32)\n#define k_ (75+32)\n#define l_ (76+32)\n#define m_ (77+32)\n#define n_ (78+32)\n#define o_ (79+32)\n#define p_ (80+32)\n#define q_ (81+32)\n#define r_ (82+32)\n#define s_ (83+32)\n#define t_ (84+32)\n#define u_ (85+32)\n#define v_ (86+32)\n#define w_ (87+32)\n#define x_ (88+32)\n#define y_ (89+32)\n#define z_ (90+32)\n\n#define SDFFontTex iChannel0\n\nfloat getCharDist(int c, vec2 p)  // p=[(-.5,-.5)..(.5,.5)]\n{\n    //p*=.85;\n    vec2 r=vec2(textureSize(SDFFontTex,0));\n    float d=textureLod(SDFFontTex,vec2(c%16,15-c/16)/16.+vec2(0,1)+clamp((p+.5)/16.,1./r,1.-1./r),0.).w-.5;\n    vec2  d2=abs(p)-(.5-1./r);\n    if (d2.x>0. || d2.y>0.) return d+max(d2.x,d2.y);\n    return d-.02;\n}\n\nvec2 getCharGrad(int c, vec2 p)\n{\n    float eps=.05;\n    vec2 d=vec2(eps*.5,0);\n    return vec2(\n        getCharDist(c,p+d.xy)-getCharDist(c,p-d.xy),\n        getCharDist(c,p+d.yx)-getCharDist(c,p-d.yx)\n        )/eps*vec2(1,-1);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    int lnum=7;\n    int l[7]=int[7](G_,e_,n_,u_,a_,r_,y_);\n    //int l[7]=int[7](G_,E_,N_,U_,A_,R_,Y_);\n    \n    float d=1000.;\n    mat2 m0=mat2(cos(sin(iTime*3.)+vec4(0,1.57,-1.57,0)));\n    mat2 m=mat2(1,0,0,1);\n    float sc=100.*exp(iTime);\n    float dsc=1./8.;\n    // unfortunately not an endless zoom, but 117 chars should do it fo now ;-)\n    for(int i=0;i<117;i++){\n        vec2 p=fract(fragCoord/sc)-.5;\n        d=min(d,getCharDist(l[i%lnum],m*p)*sc);\n        vec2 g=getCharGrad(l[i%lnum],m*((floor(p/dsc)+.5)*dsc));\n        g=normalize(g);\n        m=mat2(g.yx*vec2(-1,1),-g)*m;\n        sc*=dsc;\n    }\n    \n    fragColor.xyz=vec3(0)+d+1.;\n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdscW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1096, 1096, 1157, 1171, 1427], [1429, 1429, 1462, 1462, 1658], [1660, 1660, 1714, 1714, 2382]], "test": "untested"}
{"id": "7lyXzG", "name": "Metaballio", "author": "ml", "description": "30th December 2021\n\nMy first proper shader ", "tags": ["metaballs", "metaball"], "likes": 4, "viewed": 248, "published": 3, "date": "1642693110", "time_retrieved": "2024-07-30T17:08:24.502519", "image_code": "//palette function taken from here: https://iquilezles.org/articles/palettes\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos(TAU*(c*t+d) );\n}\n\nvec3 palette1(float t){\n    return palette(t, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.00, 0.25, 0.25));\n}\n\nvec3 palette2(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\n\nvec3 palette3(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));\n}\n\nvec3 palette4(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.6627, 0.9411, 0.8196));\n}\n\nvec2 idToCoord(float metaballId){\n    return vec2(\n        mod(metaballId, iResolution.x),\n        floor(metaballId/iResolution.x)\n    )/iResolution.xy;\n}\n\nfloat dist(vec2 p1,vec2 p2){\n    return sqrt(pow(p1.x-p2.x, 2.) + pow(p1.y-p2.y, 2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //if(uv.x > 1.) {\n    //    fragColor = vec4(0.);\n    //    return;\n    //}\n\n\n    float val = 0.;\n    for(float i = 0.; i < n; i++){\n    \n        \n        vec2 ballUv = texture(iChannel0, idToCoord(i)).rg;\n        \n\n        float d = dist(uv, ballUv);\n        \n\n        val += pow(d, -0.8);//pow(1./pow(d, 2.), 2.);\n    }\n\n    val /= n;\n    \n    float noise1 = 0.02+0.03*pow(0.5+hash13(vec3(fragCoord-vec2(0, 0.5), 0.))*0.5, 2.);\n    val += hash13(vec3(fragCoord, iTime))*noise1-noise1*0.5;\n    \n    val = pow(val, -0.2)*-8. + iTime*TAU*0.1;\n\n    float noise2 = 0.03;\n    val += hash13(vec3(fragCoord, 1.))*noise2-noise2*0.5;\n\n    // Output to screen\n    fragColor = vec4(palette4(val),1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat coordToId(vec2 coord){\n    coord /= iResolution.x;\n    return iResolution.x*coord.x+coord.y;\n}\n\n\nbool eq(float val1, float val2){\n    return abs(val1 - val2) < 1.;\n}\n\nvec2 pointPosition(float id){\n    return vec2(\n        ((sin(iTime*(0.4+(0.4*hash11(id*4.+0.)))+hash11(id*4.+2.)*TAU)*0.5+0.5)*0.7+0.15)*iResolution.x/iResolution.y, \n        ((sin(iTime*(0.4+(0.4*hash11(id*4.+1.)))+hash11(id*4.+3.)*TAU)*0.5+0.5)*0.7+0.15)\n    );\n}\n\nvoid mainImage( out vec4 outputVal, in vec2 fragCoord )\n{\n    outputVal = vec4(0., 0., 0., 0.);\n    \n    if(coordToId(fragCoord) < n) outputVal = vec4(pointPosition(coordToId(fragCoord)), 0., 0.);\n\n}\n", "buffer_a_inputs": [], "common_code": "#define n 9.\n#define seed 2.\n\n#define TAU 6.28318530718\n\nfloat hash11(float p)\n{\n    p += seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 150, 150, 188], [190, 190, 213, 213, 325], [327, 327, 350, 350, 462], [464, 464, 487, 487, 599], [601, 601, 624, 624, 742], [744, 744, 777, 777, 898], [900, 900, 928, 928, 988], [990, 990, 1047, 1098, 1882]], "test": "untested"}
{"id": "7sfyWj", "name": "Crystal Planet stills", "author": "eiffie", "description": "Fast resolving path tracing (only reflections and refractions).", "tags": ["refractions"], "likes": 15, "viewed": 354, "published": 3, "date": "1642691415", "time_retrieved": "2024-07-30T17:08:25.362221", "image_code": "void mainImage( out vec4 O, in vec2 U ) {\n  O=texture(iChannel0,U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rez iResolution\n#define TAU 6.283\n#define maxDepth 50.0\nconst float fov = 2.5,blurAmount = 0.007;\nconst int RaySteps=150, maxBounces=6;\nconst float FudgeFactor=0.9;\nconst vec3 ior=vec3(1.0,1.52,1.0/1.52);//water=1.33,glass=1.52,diamond=2.42\n\nvec4 orbitTrap;  \nfloat DE(vec3 z0){\n  vec4 z = vec4(z0,1.1);\n  for (int n = 0; n < 5; n++) {\n    z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n    z*=-2./clamp(dot(z.xyz,z.xyz),1.,4.);\n    z.y+=2.05; \n  }\n  orbitTrap=z;z=abs(z);\n  return (max(z.x,max(z.y,z.z))-2.667)/z.w;\n}\n\nvec3 getBackground( in vec3 rd ){\n vec3 sunDir=normalize(vec3(0.3,0.9,-0.5)), sunColor=vec3(1.0,0.9,0.6);\n return sunColor*.4+rd*0.25+sunColor*(max(0.0,dot(rd,sunDir))+30.*pow(abs(dot(rd,sunDir)),40.0));\n}\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\n\nvec3 scene(vec3 ro, vec3 rd) \n{// find color and depth of scene\n vec3 fcol=vec3(1.0);//color frequency mask\n vec3 rt=normalize(cross(rd,vec3(0.0,1.0,0.0))),up=cross(rt,rd);\n vec2 rnd=rand2();//a couple random numbers\n float HitDistance=1.0/rez.y;\n float d=DE(ro),od,t=rnd.x*d*FudgeFactor,side=0.;//dist to obj, total ray len, len to first obj, -inside or +outside of obj\n int i,iHitCount=0;\n for(i=0; i<RaySteps; i++ ){// march loop\n  od=d;//save the old distance for a funky normal calculation\n  d=DE(ro+t*rd);\n  if(side==0.)side=sign(d);\n  t+=d*side*FudgeFactor;//march\n  if(abs(d)<HitDistance*t){//hit\n   vec3 col=abs(sin(3.*orbitTrap.rgb/orbitTrap.w))*.5+.5;//grab closest color\n   ro+=rd*(t-d-od);// advance ray position near hit point\n   //calculate a normal from 2 extra DE checks since I saved the old distance.\n   vec3 nor=side*normalize(rd*(d-od)+rt*(DE(ro+rt*od)-od)+up*(DE(ro+up*od)-od));\n   ro+=rd*(d+od);//nudge forward nearer intersection\n   if(nor!=nor)nor=-rd;//is this !isNum(nor) which only happens when nor~/=-rd!!\n   rnd=rand2();//a couple more random numbers\n   vec3 refl=reflect(rd,nor),newRay=refl;//setting up for a new ray direction and defaulting to a reflection\n   vec3 refr=refract(rd,nor,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n   vec2 ca=vec2(dot(nor,rd),dot(nor,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n   if(rnd.y+rnd.x>pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)){newRay=refr;nor=-nor;}\n   rd=newRay;//powDir(nor,newRay,m.difExp);//redirect the ray\n   fcol*=col;\n   t=HitDistance*t*5.;//hopefully pushs thru the surface\n   if(ro.y>3. || t>maxDepth || ++iHitCount>maxBounces || dot(fcol,fcol)<0.01)break;   \n   side=0.;//force check of which side you are on\n  }\n }\n return clamp(fcol*getBackground(rd),0.0,1.0);//light the scene\n} \nmat3 lookat(vec3 fw){\n  fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw); \n}\nvoid Setup(float t, out vec3 eye, out vec3 tgt){t=floor(t);\n  vec2 r=fract(vec2(sin(t),sin(t+2.0))*431.456);\n  eye=vec3(r.x,0.,r.y)*(1.+t*.5);eye.y=2.;\n  tgt=eye+normalize(vec3(r.x,0,r.y))*.25;\n}\nvoid mainImage(out vec4 O, in vec2 U) {\n randv2=fract(cos(U.xy+U.yx*vec2(113.0,107.0)+vec2(iTime+float(iFrame)*0.1))*4231.8413);\n vec3 eye,tgt;\n if(iFrame<2)O=vec4(0);else O=texture(iChannel0,U/rez.xy)*0.98;\n float t=min(iTime/7.0,0.01*float(iFrame));if(fract(t)<0.1)O*=.5;\n Setup(t,eye,tgt);tgt-=eye;\n float focusDistance=length(tgt);\n mat3 looky=lookat(tgt);\n vec2 pxl=(-rez.xy+2.0*(U.xy+rand2()))/rez.y;\n vec3 er = normalize( vec3( pxl.xy, fov ) );\n vec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n vec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n O+=vec4(scene(eye+looky*go,looky*normalize(er+gd)),1.0)*0.02;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define bps 6.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 4.0; \n  else if(n<2.0)n= -6.0; \n  else if(n<3.0)n= -3.0; \n  else if(n<4.0)n= -6.0; \n  else if(n<5.0)n= 5.0; \n  else if(n<6.0)n= 0.0; \n  else if(n<7.0)n= 6.0; \n  else n=0.0;\n  return vec2(n,r); \n}\n\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.1,2.5,0.1,1.501,0.001);//silly fm synth instruments \n //instr sitar=instr(30.0,1.,4.0,0.0,0.2525,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n //instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+84.0,time,t0,epiano)*n0.y*.5;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+75.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+72.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+60.0,time,t2,epiano)*n2.y; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/64.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 84]], "test": "untested"}
{"id": "ssfyWj", "name": "faster SoC with DEL", "author": "eiffie", "description": "If you have a map function that returns the surface and light distance it only takes 2 extra calls to determine the normal and light direction.", "tags": ["soc", "del"], "likes": 10, "viewed": 355, "published": 3, "date": "1642691001", "time_retrieved": "2024-07-30T17:08:26.116205", "image_code": "// faster SoC with DEL by eiffie (adding Distance Estimated Light to the Sphere of Confusion renderer)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//SoC is sampling the cone of confusion\n//DEL is distance estimated lights\n//This faster version uses only 2 extra distance estimates to calculate\n//the normal and light direction.\n\n//uncomment for a test scene\n//#define TEST_SPHERE\n\n#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=0.6;//,shadowCone=0.5;\n\nvec3 mcol=vec3(0);\nmat2 rmx;\nconst vec4 p0=vec4(0.0,0.0,4.0,1.0);\nconst vec3 rc=vec3(6.633,0.033,6.133);\nvec2 DE(in vec3 z0){//amazing box by tglad\n#ifdef TEST_SPHERE\n if(mcol.x>0.)mcol+=vec3(1);\n return vec2(length(z0)-.75,length(vec3(sin(time),vec2(cos(time)))-z0));\n#else\n vec4 z = vec4(z0,1.0);float r2=10.0;\n for (int n = 0; n < 5; n++) {\n  z.xzy=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n  z*=-2.0/clamp(dot(z.xyz,z.xyz),0.1,1.0);\n  z+=p0;\n  if(n==1)r2=length(z.xyz)/z.w;//distance to light\n  z.xy=z.xy*rmx;\n }\n z=abs(z);\n if(mcol.x>0.)mcol+=sin(z.xyz)*.5+.5;\n z.xyz=max(z.xyz-rc,vec3(0.0));\n return vec2((length(z.xyz)-0.1)/z.w,r2);//returns distance to surface and light\n#endif\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\n//not used\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<4;i++){\n  if(t>lightDist)continue;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t).x+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=time*0.25;//camera, lighting and object setup\n float ct=cos(tim),st=sin(tim);\n rmx=mat2(ct,-st,st,ct);\n float z=cos(tim*0.3)*5.0;\n#ifdef TEST_SPHERE\n vec3 ro=vec3(0,0,-2);\n#else\n vec3 ro=vec3(vec2(ct,st)*(abs(z)+0.1)*(1.0+sin(tim*0.1)),z);\n#endif\n focalDistance=min(length(ro)+0.001,1.0);\n aperture=0.007*focalDistance;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0)-sin(ro)*0.1)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 rt=normalize(cross(vec3(0,1,0),rd)),up=cross(rd,rt);//just need to be perpendicular\n vec3 lightColor=vec3(1.0,0.5,0.25)+rd*.4;\n vec4 col=vec4(0.0);//color accumulator, .w=alpha\n vec2 D;\n float t=0.0,mld=100.0,od,d=1.,old,ld=100.,dt=0.,ot;//distance traveled, minimum light distance\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>15.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  od=D.x;old=D.y,dt=t-ot;ot=t;//save old distances for normal, light direction calc\n  D=DE(ro+rd*t);\n  d=D.x+0.33*rCoC;\n  ld=D.y;//the distance estimate to light\n  mld=min(mld,ld);//the minimum light distance along the march\n  if(d<rCoC){//if we are inside the sphere of confusion add its contribution\n   vec3 p=ro+rd*(t-dt);//back up to previos checkpoint\n   mcol=vec3(0.01);//collect color samples with normal deltas\n   vec2 Drt=DE(p+rt*dt),Dup=DE(p+up*dt);\n   vec3 N=normalize(rd*(D.x-od)+rt*(Drt.x-od)+up*(Dup.x-od));\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   vec3 L=-normalize(rd*(D.y-old)+rt*(Drt.y-old)+up*(Dup.y-old));\n   float lightStrength=1.0/(1.0+ld*ld*20.0);\n   vec3 scol=mcol*(0.2+0.4*(1.0+dot(N,L)))*lightStrength;//average material color * diffuse lighting * attenuation\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   mcol=vec3(0);//clear the color accumulator before shadows\n   //scol*=FuzzyShadow(p,L,ld,shadowCone,rCoC);//now stop the shadow march at light distance\n   col.rgb+=lightColor/(1.0+mld*mld*5000.0)*(1.0-col.w);//add a bloom around the light\n   mld=100.0;//clear the minimum light distance for the march\n   float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col=vec4(col.rgb+scol*alpha,clamp(col.w+alpha,0.0,1.0));//blend in the new color \n  }//move the minimum of the object and light distance\n  d=abs(fudgeFactor*min(d,ld+0.33*rCoC)*(0.8+0.2*rand2()));//add in noise to reduce banding and create fuzz\n  t+=d;\n }//mix in background color and remaining bloom\n col.rgb+=lightColor/(1.0+mld*mld*5000.0)*(1.0-col.w);\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 6.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= -5.0; \n  else if(n<4.0)n= 5.0; \n  else if(n<5.0)n= -4.0; \n  else if(n<6.0)n= 4.0; \n  else if(n<7.0)n= 0.0; \n  else n=2.0;\n  return vec2(n,r); \n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samps, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,1.5,0.001);//silly fm synth instruments \n instr sitar=instr(10.0,1.,8.0,0.0,0.5,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y/(1.+abs(n0.x)*.25);\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+64.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+60.,time,t1,epiano)*n1.y*.125; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+52.0,time,t2,bass)*n2.y;\n       a+=I(93.0,time+Sin(t2*272.0),t2,stick)*n2.y*.5;\n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfyWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[650, 650, 670, 692, 1226], [1228, 1228, 1261, 1323, 1387], [1388, 1388, 1417, 1417, 1513], [1514, 1514, 1555, 1555, 1588], [1672, 1672, 1686, 1774, 1868], [1869, 1880, 1961, 1961, 2191], [2193, 2193, 2250, 2250, 4952]], "test": "untested"}
{"id": "NsfyWj", "name": "Genuary 2022 - Day20", "author": "z0rg", "description": "My participation to genuary 2022\nMake a sea of shapes.", "tags": ["text", "generative", "genuary", "2022", "seaofshapes"], "likes": 19, "viewed": 532, "published": 3, "date": "1642690187", "time_retrieved": "2024-07-30T17:08:26.869191", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    rgb = mix(rgb.xxx, rgb.xxx*vec3(1.,.1,.2)*3., (sat(length(cuv)*2.))*.75);\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.15\n#define GLOW_POW .6\n#define GLOW_OPACITY 1.2\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nfloat _cube(vec3 p, vec3 sz)\n{\n    vec3 l = abs(p)-sz;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\n// Below code is taken from https://www.shadertoy.com/view/slKGzy\n//noise from iq's www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fracNoise(vec2 uv){\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat fr  = 0.5000*noise( uv ); \n    uv = m*uv;\n\tfr += 0.2500*noise( uv ); uv = m*uv;\n\tfr += 0.1250*noise( uv ); uv = m*uv;\n\tfr += 0.0625*noise( uv ); uv = m*uv;\n    fr = 0.5 + 0.5*fr;\n    return fr;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec2 reptour = vec2(50.);\n    \n    vec3 ptour = p;\n    ptour.xz = clamp(ptour.xz, vec2(-175.), vec2(175.));\n    ptour.xz = mod(ptour.xz+reptour*.5,reptour)-reptour*.5;\n    acc = _min(acc, vec2(_cube(ptour, vec3(1.,55.,1.)), 1.));\n    \n    vec2 rep = vec2(5.);\n    vec3 sz = vec3(.2);\n    vec3 psee = p;\n    vec2 id = floor((psee.xz+rep*.5)/rep);\n    float h = sin(id.x+iTime)\n    +sin(id.x*.5+id.y*.25+iTime*.35)*2.\n    +sin(id.x+id.y+iTime*.75)*.5\n    +sin((id.x-id.y)*10.+iTime*.75)*.25;\n    psee.xz = mod(psee.xz+.5*rep, rep)-rep*.5;\n    psee.y -= h;\n    acc = _min(acc, vec2(_cube(psee, sz), 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        accLight += sat(mix(vec3(0.533,0.294,0.725), vec3(0.486,0.996,0.800), p.y))\n        *(1.-sat(res.x/1.5))*.1;\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    vec2 coords = vec2(atan(rd.z, rd.x), acos(rd.y));\n    return sat(vec3(0.737,0.882,0.835)\n    *fracNoise(coords+vec2(iTime*.01, sin(iTime*.125)*.1))\n    *pow(fracNoise(coords*.1+iTime*0.01),2.)\n    *sat(pow(1.-sat(abs(dot(rd, vec3(0.,1.,0.)))),25.)+.2)*3.)*2.;\n\n    float cloud = texture(iChannel0, coords*.1).x*\n    texture(iChannel0, coords*.01+iTime*.001).x;\n    return sat(pow(cloud, 1.)-0.)*\n    vec3(1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    if (res.z == 1.)\n    {\n        col = vec3(.1);\n    }\n    if (res.z == 0.)\n    {\n        col = mix(vec3(0.533,0.294,0.725), vec3(0.486,0.996,0.800), p.y);\n    }\n    return sat(col);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(sin(iTime*.25)*15.,-15.+5.*sin(iTime*.25),-35.);\n    vec3 ta = vec3(cos(iTime*.15)*55.,-10.,sin(iTime*.15)*5.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n\n    vec3 glow = accLight;\n    float dist = 100.;\n    float py = 5.;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        py = p.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        vec3 refl = normalize(reflect(rd, n));\n        refl = normalize(refl+(fracNoise(p.xy)-.5)*.05);\n        vec3 resrefl = trace(p+n*0.01,refl, 128);\n        vec3 reflCol = getEnv(refl);\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n            reflCol = getMat(resrefl, refl, prefl, nrefl);\n        }\n        col+= reflCol;\n    }\n    else\n        col = getEnv(rd);\n    col += glow;\n    col = mix(col, vec3(0.,0.,0.), sat(1.-exp(-py*0.5+1.5)));        \n    col = mix(col, vec3(0.,0.,0.), sat(1.-exp(-dist*0.01+.5)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    col *= 1.5/(1.+col); \n    col = pow(col, vec3(1.4545));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfyWj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1162]], "test": "untested"}
{"id": "fsXcD2", "name": "Abstract met a thought,", "author": "xenn", "description": "We hive mind mathological psychonaut\nWhen deliberately devising dividing devices, does one design decisively or divisively?\n\nI dunno", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 9, "viewed": 460, "published": 3, "date": "1642688336", "time_retrieved": "2024-07-30T17:08:27.814663", "image_code": "// Fork of \"Weird mandelbox\" by loicvdb. https://shadertoy.com/view/3t3GWH\n// 2021-06-06 02:02:38\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\n// Fork of \"Psynthetika\" by xenn. https://shadertoy.com/view/fdKGDy\n// 2021-09-29 06:32:00\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm2(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - -1.0 * d).g,\n                      texture(iChannel0, uv - -2.0 * d).b);\n    \n    \n    float noise = .9 + randomFloat()*.15;\n//  \tfragColor = vec4(ACESFilm(color*noise), 1.0);\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 frogColor;\n    vec4 frigColor;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .2\n        \t\t  + bloom(.2 * iResolution.y, .5, fragCoord) * .2;\n//    frogColor = vec4(ACESFilm(color*noise), 1.0);\n//    frigColor = mix(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0),(1.0 * abs(sin(iTime * .50))));\n        frogColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n        frigColor = min(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n\nfragColor = mix(frigColor,frogColor,0.5+(0.5*cos(iTime)));\n// fragColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MaxSteps 64\n#define MaxShadowSteps 32\n#define AmbientLightSteps 14\n#define MaxDist 2.0\n#define MinDist .015\n#define GIStrength .3\n#define AOStrength .2\n\nvec3 CamPos = vec3(0, -1, -20.);\nvec3 CamRot = vec3(-0.1,0,-010);\nfloat CamFocalLength = 2.250;\n\nvec3 LightDir;\nvec3 LightColor = vec3(.7, .5, .3) * 10.;\nfloat LightRadius = .05;\n\nfloat Scale = 2.25;\nfloat Radius = .25;\nint Iterations = 9;\nmat3 Rotation;\n\nfloat distanceEstimation(vec3 position){\n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 2) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos, float dist){\n  vec2 k = vec2(dist, 0);\n  return normalize(vec3(distanceEstimation(pos + k.xyy),\n\t  \t\t\t\t\tdistanceEstimation(pos + k.yxy),\n  \t\t\t\t\t\tdistanceEstimation(pos + k.yyx))\n\t\t\t\t - vec3(dist));\n}\nvec3 normalEstimation(vec3 pos){\n  float dist = distanceEstimation(pos);\n  return normalEstimation(pos, dist);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return texture(iChannel0, dir).rgb;\n}\n\n//blurred cubemap for ambient lighting\nvec3 backgroundColorHemi(vec3 dir){\n    return textureLod(iChannel0, dir, 9.5).rgb;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\nvec3 ambientLight(vec3 pos){\n    vec3 pos0 = pos;\n    float dist0 = distanceEstimation(pos);\n    vec3 normal = normalEstimation(pos).xyz, gi, al = vec3(0.0);\n    float ao = 1., dist = dist0;\n    for(int i = 0; i < AmbientLightSteps; i++){\n        float expectedDist = dist * (1. + .8);\n        dist = distanceEstimation(pos);\n        float weight = AOStrength*(1.-float(i)/float(AmbientLightSteps));\t//more weight to first samples\n        ao *= pow(clamp(dist/expectedDist, 0., 1.0), weight);\n        normal = normalize(normalEstimation(pos, dist)+1.5*normal); //\"smoothed\" normal to avoid artifacts\n        pos += normal * .8*dist; //slightly shorter to avoid artifacts\n        al += backgroundColorHemi(normal);\n        if(i == 6 || i == 13) gi += ao*directLight(pos, normal); // two GI samples\n    }\n    gi *= GIStrength/2.0;\n    return gi + al/float(AmbientLightSteps) * ao;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 n){\n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            n = normalEstimation(pos);\n            for(int j = 0; j < 3; j++){\n                dist = distanceEstimation(pos) - 2.*MinDist;\n        \t\tpos += dist * dir;\n            }\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\n\nvec4 rayTrace(vec3 pos, vec3 dir){\n    for(int i = 0; i < 5; i++){ //to get to a distance inferior to MaxDist\n        float dist = distanceEstimation(pos);\n        pos += dist * dir;\n        if(dist < MaxDist) break;\n    }\n    vec3 n;\n    if(!trace(pos, dir, n))\n        return vec4(backgroundColor(dir), 20.0);\n    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n#define OCTAVES 2\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.001;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot((k1-q),k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nmat3 scale(float x,float y,float z){\n    return mat3(\n    vec3(x,0.,0.),vec3(0.,y,0.),vec3(0.,0.,z)\n    );\n}\n\nfloat head(vec3 sP){\n    float s1 = length(sP*scale(1.2,1.0,1.0)-vec3(0.0,0.5,0.0))-0.5;\n    float s2 = length(sP*scale(1.2,1.3,1.2)-vec3(0.0,0.12,0.15))-0.4;\n    float s3 = opSmU(s1,s2,0.2);\n    //float s5 = opSmU(s3,neck,0.1);\n    float s6 = sdCone((sP-vec3(0.,0.25,0.34))*rotateX(-2.1),0.22,0.2,0.0)-0.03;\n    float s7 = opSmU(s3,s6,0.1);\n    float s8 = length(sP-vec3(0.0,-0.08,0.27))-0.2;\n    float s9 = opSmU(s7,s8,0.1);\n    float s10 = length((vec3(abs(sP.x),sP.y,sP.z)-vec3(0.4,0.25,-0.03))*rotateY(0.37)*rotateZ(1341.6)*rotateX(1149.15)*scale(8.0,1.0,1.2))-0.12;\n    float s11 = opSmU(s9,s10,.05);\n    float s12 = length(sP-vec3(0.0,-0.14,0.56))-0.09;\n    float s13 = opSmS(s12,s11,0.1);\n    return s13;\n}\n\nfloat displace(vec3 sP,float geo){\n    float final;\n    if(geo<=0.01){\n        float disp = geo-(0.1*fbm(sP*3.0*rotateY(iTime+12.0*(0.3*(sin(sP.y*1.0+iTime*0.3))+0.6))+vec3(0.,0.,2.0*iTime))-0.195);\n    \tfinal = opSmS(disp,geo,0.3);\n    }else{\n        final = geo;\n    }\n    return final;\n}\n\n\nfloat sceneSDF(vec3 sP) {\n    vec3 sPh=sP*rotateY(noise(vec3(iTime*0.5))-0.5)*rotateX(0.1*noise(vec3(iTime*0.5+123.456))-0.09)*rotateZ(0.1*noise(vec3(iTime*0.5+222.111))-0.05);\n    \n\tfloat head = head(sPh);\n\n    float s4 = sdCapsule(sP-vec3(0.0,-0.5,-0.15),1.0,0.26);\n    float s14 = length(sP-vec3(0.0,-0.7,-0.18))-0.4;\n    float s15 = opSmU(s4,s14,0.1);\n    float s16 = length(vec3((sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s17 = opSmU(s15,s16,0.5);\n    float s16n = length(vec3(-(sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s18 = opSmU(s17,s16n,0.5);\n    float torso = opSmU(s18,s4,0.1);\n    torso-=0.03*noise(sP*8.0);\n    torso = displace(sP,torso);\n    head-=0.03*noise(sPh*8.0);\n    head = displace(sPh,head);\n    float final=opSmU(torso,head,0.01);\n\n    return final;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float depth;\n    float dd=0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = (sceneSDF(eye + dd * marchingDirection));\n        dd += dist;\n        if (dist<EPSILON) {\n            depth=dd;\n        }else if(dist>MAX_DIST){\n\t\t\treturn dd;\n            break;\n        }\n        \n    }\n    return depth;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=3;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-sceneSDF(p+n*d))/d);\n    }\n    return ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    //dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    float sdf = shortestDistanceToSurface(eye, dir);\n    if(sdf>MAX_DIST || sdf==0.0){\n        fragColor = vec4(0.0);\n        return;\n    }\n    float dist = sdf;\n    vec3 p = eye + dist * dir;\n    vec3 N = eN(p);\n    float occ = 1.0-AO(p,N);\n\n    vec3 ref = (reflect(dir,N));\n    color=(texture(iChannel0,ref).xyz*0.5+vec3(0.5))*occ*(1.0-smoothstep(4.5,6.0,dist));\n    \n    fragColor = vec4(color, 1.0);\n//}\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime + 43.;\n    \n    //fractal animation\n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    //light animation\n    LightDir = normalize(vec3(sin(time*.6), -1, cos(time*.6)));\n    \n    //camera animation\n    CamRot.z = sin(time*.4)*.2;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n\n    fragColor = rayTrace(CamPos, rayDir);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n//extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor + vec3(1.2) * (1.0-factor);\n    fragColor = vec4(col, 1.0);\n//}\n\n//void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n//{\n    vec3 skyCol = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor + vec3(1.2) * (1.0-factor);\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n   // vec3 col = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//first DoF pass\n\n#define Aperture .025\n#define DoFClamping .35\n#define DoFSamples 64\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .025\n#define DoFClamping .35\n#define DoFSamples 64\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio 30.5\n#define Margins .0\n\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * .5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * .5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 122, 122, 262], [264, 264, 321, 321, 626], [791, 791, 811, 811, 890], [892, 892, 916, 916, 1056], [1058, 1058, 1115, 1115, 2566]], "test": "untested"}
{"id": "fsXyDj", "name": "Controllable Machinery", "author": "dr2", "description": "Still doesn't do much, but now with speed controller (slide the knob) and more gears; mouseable", "tags": ["interactive", "wheel", "gear", "widget", "machine"], "likes": 90, "viewed": 4315, "published": 3, "date": "1642677044", "time_retrieved": "2024-07-30T17:08:28.743181", "image_code": "// \"Controllable Machinery\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Extension of \"Machinery\"; control widget in world space - as in \"Maze Ball Solved 2\")\n\n#define AA    0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nvec4 wgObj;\nvec3 ltDir, vnBlk;\nvec2 qBlk;\nfloat dstFar, tCur, tMov, angRot, bEdge, tCyc, cnPos, hitBlk;\nint idObj;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8, idCon = 9, idBlk = 10;\nconst float pi = 3.1415927;\nconst float nBlk = 13.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float aRot, \n   bool bev, float dMin)\n{\n  vec3 q;\n  float d, s;\n  q = p;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    q.xy = Rot2D (q.xy, aRot);\n    q.xy = Rot2D (q.xy, floor (nt * atan (q.y, - q.x) / (2. * pi) + 0.5) * 2. * pi / nt);\n    if (bev) q.xy *= 1.2 - 0.2 * q.z / wlThk;\n    s = q.x - 2. * clamp (1.5 * tWid + 0.5 * q.x * step (0., q.x) - abs (q.y), 0., tWid);\n    d = max (d, - rad - 0.95 * s);\n  }\n  return min (dMin, d);\n}\n\nvec4 BPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 5.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t / 5., bEdge, 0.);\n  } else if (t < 10.) {\n    a = 0.5 * pi * (t - 5.) / 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 15.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 10.) / 5., 1. + bEdge, 1.);\n  } else if (t < 17.5) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 15.) / 2.5);\n  } else {\n    t -= 17.5;\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, wlThk, tWid, nt, rad, gRat;\n  dMin = dstFar / 0.3;\n  gRat = 2.;\n  rad = 0.3;\n  wlThk = rad / 7.;\n  tWid = rad / 10.;\n  nt = 20.;\n  q = p - vec3 (-1.05, -0.21, 1.3);\n  dMin = GearWlDf (- q, rad, wlThk, tWid, nt, angRot * gRat, true, dMin);\n  dMin = GearWlDf ((q - vec3 (0.85 * rad, 0., 0.85 * rad)).yzx,\n     rad, wlThk, tWid, nt, angRot * gRat + pi / nt, true, dMin);\n  rad = 0.43;\n  wlThk = rad / 15.;\n  tWid = rad / 16.;\n  nt = 32.;\n  q = p -vec3 (0.1, 0., 1.);\n  dMin = GearWlDf ((q - vec3 (0., bEdge, 0.)).yzx, rad, wlThk, tWid, nt,\n     - angRot - 0.3 * pi / nt, false, dMin);\n  dMin = GearWlDf (- (q - vec3 (0., -0.21, 0.555)).zyx, rad / gRat, wlThk, tWid,\n     nt / gRat, - angRot * gRat, false, dMin);\n  rad = 0.32;\n  wlThk = rad / 15.;\n  tWid = rad / 12.;\n  nt = 24.;\n  q = p - vec3 (-1.05, -0.21, 0.6);\n  dMin = GearWlDf ((q - vec3 (0., 0., 0.1)), rad, wlThk, tWid, nt,\n     angRot * gRat + pi / nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, 0.1)), rad / gRat, wlThk, tWid, nt / gRat,\n     - angRot * gRat * gRat, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, -0.1)), rad, wlThk, tWid, nt,\n     - angRot * gRat * gRat - pi / nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., 0., -0.1)), rad / gRat, wlThk, tWid, nt / gRat,\n     angRot * gRat * gRat * gRat, false, dMin);\n  return dMin * 0.3;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n  r = length (q.yz);\n  q.yz = Rot2D (q.yz, - angRot);\n  a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n  q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) / 8.);\n  q.z = abs (q.z);\n  d = SmoothMax (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n     max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi / 32.),\n     cos (0.8 * 2. * pi / 32.))))), abs (q.x) - 0.02, 0.01);\n  DMIN (idWhl);\n  d = min (PrBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1)),\n     PrBoxDf (p - vec3 (-1.018, 0.98, 0.5), vec3 (0.1, 0.02, 0.5 - bEdge)));\n  DMIN (idPln);\n  d = SmoothMax (abs (PrCaps2Df ((p - vec3 (-0.05, -0.21, 0.)).yx, 0.2, 1.)) - 0.01,\n    abs (p.z) - 0.1, 0.02);\n  DMIN (idConv);\n  q = p - vec3 (-0.05, -0.21, 0.);\n  q.x = abs (q.x) - 1.;\n  d = PrRoundCylDf (q, 0.18, 0.01, 0.11);\n  DMIN (idSpl);\n  q = p - vec3 (0.65, -0.14, 1.);\n  q.x = abs (q.x) - 0.3;\n  d = PrRoundBoxDf (q, vec3 (0.01, 1.08, 0.06), 0.02);\n  q = p - vec3 (-0.05, -0.68, 0.);\n  q.xz = abs (q.xz) - vec2 (1., 0.2);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n  q = p - vec3 (-1.05, -0.14, 1.);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 1.08, 0.01), 0.02));\n  q = p - vec3 (-1.05, -0.68, 0.6);\n  q.z = abs (q.z) - 0.2;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n  q = p - vec3 (-0.33, -0.68, 1.555);\n  q.x = abs (q.x) - 0.3;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.55, 0.04), 0.02));\n  DMIN (idSup);\n  q = p - vec3 (0.65, bEdge, 1.);\n  d = PrCylDf (q.yzx, 0.04, 0.62);\n  q = p - vec3 (-0.36, -0.21, 1.555);\n  d = min (d, PrCylDf (q.yzx, 0.03, 0.51));\n  q = p - vec3 (-0.05, -0.21, 0.);\n  q.x -= 1.;\n  d = min (d, PrCylDf (q, 0.03, 0.27));\n  q.xz -= vec2 (-2., 0.14);\n  d = min (d, PrCylDf (q, 0.03, 0.4));\n  q.z -= 0.87;\n  d = min (d, PrCylDf (q, 0.03, 0.36));\n  q = p - vec3 (-1.05, -0.68, 0.6);\n  d = min (d, PrCylDf (q, 0.03, 0.25));\n  DMIN (idAx);\n  q = p - vec3 (0., -1.2, 0.9);\n  d = PrRoundBoxDf (q, vec3 (1.7, 0.03, 1.5), 0.02);\n  DMIN (idBas);\n  q = p - wgObj.xyz;\n  d = PrRoundCylDf (q.xzy, wgObj.w, 0.02, 0.02);\n  DMIN (idCon);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GearDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k / nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      hitBlk = k;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 a4;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k / nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GearSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = GearDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, q;\n  float dstObj, dstGear, dstBlk, sh, s, r, a, nDotL;\n  int idObjT;\n  bool isMet;\n  tCyc = 18.5;\n  bEdge = 0.08;\n  isMet = false;\n  angRot = 0.1 * pi * tMov;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstGear = GearRay (ro, rd);\n  if (dstGear < min (dstObj, dstFar)) {\n    dstObj = dstGear;\n    idObj = idGr;\n  } else idObj = idObjT;\n  dstBlk = BlkHit (ro, rd);\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      dstObj = dstBlk;\n      ro += dstObj * rd;\n      idObj = idBlk;\n      vn = vnBlk;\n      col4 = vec4 (HsvToRgb (vec3 (hitBlk / nBlk, 1., 1.)), 0.2) *\n         (1. - 0.4 * step (0.8 * bEdge, Maxv2 (abs (qBlk))));\n    } else {\n      ro += dstObj * rd;\n      vn = (idObj == idGr) ? GearNf (ro) : ObjNf (ro);\n      if (idObj == idWhl) {\n        col4 = vec4 (0.9, 0.7, 0.3, 0.2);\n        q = ro - vec3 (1.1 + bEdge + 0.03, bEdge, 1.);\n        r = length (q.yz);\n        q.yz = Rot2D (q.yz, - angRot);\n        a = fract (64. * atan (q.z, - q.y) / (2. * pi) + 0.5);\n        if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n        if (r > 0.92) col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n        isMet = true;\n      } else if (idObj == idGr) {\n        col4 = vec4 (0.9, 0.8, 0.4, 0.2);\n        isMet = true;\n      } else if (idObj == idSpl) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2) * (1. - 0.4 * step (abs (ro.z), 0.1));\n        isMet = true;\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n        isMet = true;\n      } else if (idObj == idPln) {\n        col4 = (abs (vn.y) > 0.99) ? vec4 (0.5, 0.6, 0.2, 0.05) : vec4 (0.7, 0.5, 0.4, 0.1);\n      } else if (idObj == idConv) {\n        q = ro - vec3 (-0.05, -0.21, 0.);\n        col4 = vec4 (0.8, 0.8, 0.4, 0.);\n        if (sign (vn.y) != sign (q.y)) {\n          if (abs (q.x) < 1. && abs (vn.y) > 0.5) col4 *= 1. - 0.1 * SmoothBump (0.45, 0.55, 0.03,\n           fract (10. * (q.x - sign (q.y) * mod (tMov, 20.) * 2.1 / 5.)));\n        } else col4 *= 0.8 + 0.2 * smoothstep (0., 0.01, abs (abs (q.z) - 0.07));\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.7, 0.5, 0.4, 0.1);\n        isMet = true;\n      } else if (idObj == idBas) {\n        q = ro;\n        q.z -= 0.9;\n        if (Maxv2 (abs (q.xz) - vec2 (1.65, 1.45)) > 0.) {\n          col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n          isMet = true;\n        } else {\n          col4 = vec4 (0.3, 0.5, 0.4, 0.);\n        }\n        col4 *= (0.5 + 0.5 * step (0., Maxv2 (abs (vec2 (q.x, q.z + 1.3)) - vec2 (0.4, 0.02)))) *\n           (0.7 + 0.3 * step (0., abs (PrCaps2Df (vec2 (q.z + 1.3, q.x), 0.08, 0.5)) - 0.01));\n      } else if (idObj == idCon) {\n        col4 = vec4 (0., 1., 1., 0.2);\n        if (length (ro.xz - wgObj.xz) < 0.6 * wgObj.w)\n           col4 = mix (0.8 * col4, vec4 (1., 0., 1., 0.2), step (0., sin (2. * pi * tCur)));\n      }\n    }\n    sh = min (ObjSShadow (ro, ltDir), GearSShadow (ro, ltDir));\n    sh = 0.6 + 0.4 * min (sh, BlkHitSh (ro + 0.01 * ltDir, ltDir, 6.));\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (isMet) nDotL *= nDotL;\n    col = col4.rgb * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.9 * sh * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    if (isMet) {\n      rd = reflect (rd, vn);\n      col = mix (col, vec3 (1.), 0.01 * step (0.1, Minv2 (fract (8. * vec2 (atan (rd.z, rd.x),\n         2. * asin (rd.y)) + 0.5) - 0.5)));\n    }\n  } else col = vec3 (0., 0., 0.1) * (1. + 0.9 * rd.y);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 30.;\n  stDat = Loadv4 (0);\n  tMov = stDat.x;\n  cnPos = stDat.y;\n  wgObj = vec4 (cnPos - 0.5, -1.12, -0.4, 0.08);\n  stDat = Loadv4 (1);\n  az = stDat.x;\n  el = stDat.y;\n  vuMat = StdVuMat (el, az);\n  zmFac = 4.;\n  ro = vuMat * vec3 (0., 0., -8.);\n  ro.z += 0.9;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Controllable Machinery\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat, wgObj;\n  vec3 vCon, ro;\n  vec2 canvas, iFrag, ud;\n  float tCur, tMov, az, el, asp, zmFac, spd, cnPos, mPtrPz, s;\n  int pxId, wgSel, wgReg;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 2) discard;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 2);\n  if (init) {\n    tMov = 0.;\n    spd = 0.5;\n    cnPos = 0.5;\n    az = 0.;\n    el = -0.12 * pi;\n    mPtrPz = mPtr.z;\n  } else {\n    stDat = Loadv4 (0);\n    tMov = stDat.x;\n    cnPos = stDat.y;\n    spd = stDat.z;\n    tMov += 0.02 * spd;\n    stDat = Loadv4 (1);\n    az = stDat.x;\n    el = stDat.y;\n    mPtrPz = stDat.z;\n    wgSel = int (stDat.w);\n  }\n  if (! init) {\n    if (mPtr.z > 0.) {\n      vuMat = StdVuMat (el, az);\n      ro = vuMat * vec3 (0., 0., -8.);\n      ro.z += 0.9;\n      zmFac = 4.;\n      vCon = vuMat * normalize (vec3 (2. * mPtr.xy * vec2 (asp, 1.), zmFac));\n      wgObj = vec4 (cnPos - 0.5, -1.12, -0.4, 0.08);\n      ud = (ro.xz + (- (ro.y - wgObj.y) / vCon.y) * vCon.xz);\n      s = Maxv2 (abs (ud - wgObj.xz)) - wgObj.w - 0.1;\n      if (s < 0. || wgSel == 0) {\n        if (s < 0. && wgSel == 0) cnPos = clamp (ud.x + 0.5, 0., 1.);\n        wgReg = 0;\n      } else if (wgReg < 0) {\n        az = 2. * pi * mPtr.x;\n        el = pi * mPtr.y;\n        el = clamp (el, -0.4 * pi, 0.1 * pi);\n      }\n      if (mPtrPz <= 0.) wgSel = wgReg;\n    } else {\n      wgSel = -1;\n      wgReg = -2;\n      az = mix (az, 0., 0.003 + 0.05 * step (abs (az), 0.15));\n      el = mix (el, -0.12 * pi, 0.003 + 0.05 * step (abs (el + 0.12 * pi), 0.15));\n    }\n  }\n  spd = 2. * cnPos;\n  if      (pxId == 0) stDat = vec4 (tMov, cnPos, spd, 0.);\n  else if (pxId == 1) stDat = vec4 (az, el, mPtr.z, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXyDj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1221, 1221, 1330, 1330, 1755], [1757, 1757, 1778, 1778, 2351], [2353, 2353, 2376, 2376, 3728], [3730, 3730, 3752, 3752, 5931], [5933, 5933, 5966, 5966, 6150], [6152, 6152, 6186, 6186, 6371], [6373, 6373, 6395, 6395, 6653], [6655, 6655, 6676, 6676, 6933], [6935, 6935, 6968, 6968, 7662], [7664, 7664, 7710, 7710, 8194], [8196, 8196, 8233, 8233, 8450], [8452, 8452, 8490, 8490, 8708], [8710, 8710, 8745, 8745, 12266], [12268, 12268, 12324, 12324, 13348], [13350, 13350, 13382, 13382, 13482], [13484, 13484, 13530, 13530, 13577], [13579, 13579, 13621, 13621, 13672], [13674, 13674, 13731, 13731, 13807], [13809, 13809, 13853, 13853, 13913], [13915, 13915, 13937, 13937, 13975], [13977, 13977, 13999, 13999, 14037], [14039, 14039, 14061, 14061, 14088], [14090, 14090, 14112, 14112, 14139], [14141, 14141, 14186, 14186, 14278], [14280, 14280, 14325, 14325, 14363], [14365, 14365, 14422, 14422, 14505], [14507, 14507, 14543, 14543, 14749], [14751, 14751, 14781, 14781, 14894], [14896, 14896, 14920, 14920, 15037], [15131, 15131, 15156, 15156, 15279]], "test": "untested"}
{"id": "NsfcWj", "name": "RGB Linear Color Key", "author": "MysteryPancake", "description": "This shader allows you to key a color, with threshold and softness controls like Linear Color Key in After Effects", "tags": ["2d", "chroma", "greenscreen", "chromakey", "matte", "compositing", "key", "replace"], "likes": 6, "viewed": 355, "published": 3, "date": "1642675510", "time_retrieved": "2024-07-30T17:08:29.560994", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n  vec4 replace = texture(iChannel1, fragCoord / iResolution.xy);\n  \n  const vec3 target = vec3(0.0, 1.0, 0.0); // Find green\n  const float threshold = 0.5; // Controls target color range\n  const float softness = 0.25; // Controls linear falloff\n  \n  // Get difference to use for falloff if required\n  float diff = distance(col.rgb, target) - threshold;\n  \n  // Apply linear falloff if needed, otherwise clamp\n  float factor = clamp(diff / softness, 0.0, 1.0);\n  \n  // Make everything black and white\n  replace.rgb = vec3((replace.r + replace.g + replace.b) / 3.0);\n  col.rgb = vec3((col.r + col.g + col.b) / 3.0);\n  // Brightness correction\n  col.rgb = col.rgb * 0.8 + 0.2;\n  \n  fragColor = vec4(mix(replace.rgb, col.rgb, factor), col.a);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 858]], "test": "untested"}
{"id": "NdXyWj", "name": "Falling sand test", "author": "pancakespeople", "description": "trying out some falling sand simulation", "tags": ["simulation", "sand"], "likes": 4, "viewed": 329, "published": 3, "date": "1642673031", "time_retrieved": "2024-07-30T17:08:30.342904", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SAND vec3(1.0, 1.0, 0.0)\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nbool isFilled(vec2 coord) {    \n    return texture(iChannel0, coord / iResolution.xy).r == 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    bool currentFilled = isFilled(fragCoord);\n    \n    if (iFrame == 0) {\n        if (random2(uv).x > 0.99) {\n            col = SAND;\n        }\n    }\n    else {\n        vec2 above = vec2(fragCoord.x, fragCoord.y + 1.0);\n        vec2 below = vec2(fragCoord.x, fragCoord.y - 1.0);\n\n        if (above.y < iResolution.y) {\n            if (isFilled(above) && !currentFilled) {\n                col = SAND;\n            }\n            \n            if (currentFilled && isFilled(below)) {\n                col = SAND;\n            }\n        }\n    }\n\n    if (iMouse.z > 0.0) {\n        if (distance(mouse, uv) < 0.01) {\n            col = vec3(1.0);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]], "test": "untested"}
{"id": "sslyDB", "name": "RGB Color Replacement", "author": "MysteryPancake", "description": "This shader allows you to replace a color, with threshold and softness controls like Linear Color Key in After Effects", "tags": ["2d", "chroma", "greenscreen", "chromakey", "matte", "compositing", "key", "replace"], "likes": 2, "viewed": 575, "published": 3, "date": "1642668246", "time_retrieved": "2024-07-30T17:08:31.427005", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n  \n  const vec3 target = vec3(0.0, 1.0, 0.0); // Find green\n  const vec3 replace = vec3(1.0, 0.0, 0.0); // Replace with red\n  \n  const float threshold = 0.5; // Controls target color range\n  const float softness = 0.3; // Controls linear falloff\n  \n  // Get difference to use for falloff if required\n  float diff = distance(col.rgb, target) - threshold;\n  \n  // Apply linear falloff if needed, otherwise clamp\n  float factor = clamp(diff / softness, 0.0, 1.0);\n  \n  fragColor = vec4(mix(replace, col.rgb, factor), col.a);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 641]], "test": "untested"}
{"id": "fdfyWB", "name": "Rubber surface", "author": "ersh", "description": "2D Pulse in 3D", "tags": ["2d", "3d"], "likes": 7, "viewed": 361, "published": 3, "date": "1642663037", "time_retrieved": "2024-07-30T17:08:32.180989", "image_code": "//https://graphtoy.com/?f1(x,t)=sin(x+t)*sin(x/5-t*4)&v1=false&f2(x,t)=f1(x/2,t/2)*1.3-f1(x-1,t-5)&v2=false&f3(x,t)=f2(x/2,t/2)*1.3-f1(x-1,t-5)&v3=false&f4(x,t)=f3(x,t)*(0.5+f1(x-3,t*3-5)/2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,21.258732000000105\nfloat f1(float x, float t) { return sin(x+t)*sin(x/5.-t*4.); }\nfloat f2(float x, float t) { return f1(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f3(float x, float t) { return f2(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f4(float x, float t) { return f3(x,t)*(0.5+f1(x/3.4-3.,t*2.-5.)/2.); }\n\nvec3 col(float x, float side) {\n  return vec3(clamp(x/2.+0.5,0.,1.), side, clamp(0.5-x/2.,0.,1.));\n}\n\nfloat h(vec2 p, float t) {\n    return\n        f4(p.x, t) + f4(p.y + 42.123, t/1.321+31.32) +\n        f4(p.x, t) * f4(p.y + 42.123, t/1.321+31.32)/3.;\n}\n\n\n#define H  h(uvu.xz*10., iTime)/15.\n#define INTERP_MIX(PREV, TARGET, CUR)   (TARGET-PREV)/(CUR-PREV)\n#define MAXZ   3.\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec3 uvu = vec3(I/max(iResolution.x, iResolution.y), 0.) - vec3(0, 0.15, 0);\n    float z;\n    vec3 uvuprev = uvu;\n    float zprev = H;\n    float sgn = zprev < uvu.y ? 1. : -1.;\n    for (uvu.z = 0.01; uvu.z < MAXZ; uvu.z += 0.01+uvu.z/100.,uvu.y-=0.0008,uvu.x+=0.008) {\n        z = H;\n        if (sgn*z > sgn*uvu.y) {\n            float interp = INTERP_MIX(zprev, uvuprev.y, z);\n            uvu = mix(uvuprev, uvu, interp);\n            //z = uvu.y;// = mix(zprev, z, interp);\n            z = H;\n\n            float a = atan((z - h((uvu.xz-vec2(-0.001,0.0005))*10., iTime)/15.) / 0.0014);\n\n            vec3 c = col(z*10., (-sgn+1.)/4.) * (1.-(1. - sgn)/3.) + sgn*(a*2./3.1415926);\n\n            // mesh\n            //if (mod(uvu.x*10., 1.) < 0.03 || mod(uvu.z*MAXZ/10., MAXZ/100.) < MAXZ/1000.) c = vec3(0.);\n            // angled mesh\n            //if (mod(uvu.x*10. + uvu.z*MAXZ*10., 5.) < 0.3 || mod(uvu.x*10. - uvu.z*MAXZ*10., 5.) < 0.3) c = vec3(sgn);\n\n            O = vec4(c*(1.-uvu.z/MAXZ), 0.);\n            return;\n        }\n        zprev = z; uvuprev = uvu;\n    }\n    O = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 275, 303, 303, 337], [338, 338, 366, 366, 408], [409, 409, 437, 437, 479], [480, 480, 508, 508, 556], [558, 558, 589, 589, 658], [660, 660, 686, 686, 811], [934, 934, 975, 975, 2066]], "test": "untested"}
{"id": "7dsyDS", "name": "Winter Forest", "author": "wyatt", "description": ":)", "tags": ["tree", "kifs"], "likes": 30, "viewed": 407, "published": 3, "date": "1642654252", "time_retrieved": "2024-07-30T17:08:33.139426", "image_code": "Main {\n    Q = exp(-A(V)*vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T iTime\n#define dT iTimeDelta\n#define I iFrame\n#define N 250\n#define Main void mainImage(out vec4 Q, in vec2 V)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define A(U) texture(iChannel0,(U)/R)\nvec4 hash(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n      ", "buffer_a_code": "Main {\n    Q = vec4(0);\n   \n    vec2 U = .7*(V-.5*R)/R.y;\n    U += vec2(.05,.6);\n    float M =  min(10.*T,50.);\n    float l = .3;\n    float s = 1.;\n    vec2 v = vec2(0);\n    for (float i = 1.; i < M; i++) {\n        vec2 p = U.xy;\n        vec2 a = vec2(0);\n        vec2 b = vec2(0,l);\n        float x = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n        float ln = length(p-a-(b-a)*x);\n\n        float sml = 1./i*exp(-1e5*i*ln*ln);\n        if (i>3.) Q += sml;\n         U.y -= l;\n         s = sign(U.x);\n         if (hash(vec4(V.xy,i,I)).x<.1)s *= -1.;\n         U.x = s*(U.x);\n         U.xy *= ei(.6+5.*l);\n         l *= .75-.3*l+.1*s*(mod(i,2.)*2.-1.);\n    }\n    Q = max(Q,A(V));\n    if (I < 1) Q = vec4(0);\n }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdfyzN", "name": "XY Oscilloscope Sound Drawings", "author": "amhall", "description": "\"You are seeing the sounds you're hearing.\" A visualizer of L/R waveforms and their resulting oscilloscope shapes. More thorough description in the comments.\n\nHit \"reset time\" after the video starts so the sound will play and be synced to the video.", "tags": ["2d", "3d", "oscilloscope", "sound", "tetrahedron", "4d", "mushroom", "tesseract"], "likes": 19, "viewed": 715, "published": 3, "date": "1642652165", "time_retrieved": "2024-07-30T17:08:34.229513", "image_code": "// These sounds draw shapes on an oscilloscope in XY mode where the left channel\n// is the X axis and the right channel is the Y axis. This shader visualizes the\n// left (top) and right (bottom) waveforms, and approximates a much slowed down\n// version of what is happening on the oscilloscope display.\n\n// Reduce samplesPerFrame in the Common tab to speed up if necessary.\n\n// To get a better sense of what the sounds would actually look like on an\n// oscilloscope, change phaseSpan to 1.0 and increase samplesPerFrame in the Common\n// tab (or play these sounds into a digital oscilloscope software).\n\n// To get a better sense of the path being traced, reduce animationFrequency and/or\n// enable FADE in the Common tab.\n\n// If you've never heard of oscilloscope music, I highly recommend the work of\n// Jerobeam Fenderson and Hansi Raber: https://www.youtube.com/c/jerobeamfenderson1\n\n// I'll also take this opportunity to share my own oscilloscope music piece that I\n// composed for school: https://www.youtube.com/watch?v=H5NK549Lg1I\n\n// Common has the sound synthesis and animation parameters, Buffer A computes a\n// select number of samples, buffer B does the path visualization.\n\n// Created by Anthony Hall\n\n\nvec3 waveforms(vec2 wave, float y)\n{\n    float lY = y;\n    float rY = y;\n    lY = 2.0 * y - 1.0;\n    rY = 2.0 * y + 1.0;\n    \n    float dist = min(abs(lY - wave.x), abs(rY - wave.y));\n    \n    float intensity = linestep(0.2, 0.005, dist);\n    return pow(vec3(intensity), vec3(10.0, 3.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 path = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n\n    // The L/R visualization visualizes two cycles of the wave at the current time\n    float window = floor(iTime * baseFrequency);\n    float time = (window + uv.x) / baseFrequency;\n    vec2 samples = sound(time, time);\n    vec3 wave = waveforms(samples, 1.1 * uv.y);\n    \n    fragColor = vec4(0.5 * wave + path, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// All the sound synthesis and animation parameters are here\n\n// The number of samples taken by the visualizer. A line is drawn between each sample,\n// so this is the bottleneck.\nconst int samplesPerFrame = 100;\n\n// The frequency at which the entire shape is drawn once.\nconst float animationFrequency = 1.8;\n\n// The percentage of the entire shape that is spanned by the visualizer at any given time.\nconst float phaseSpan = 0.4; \n\n// The amount of time spent on each shape.\nconst float shapeDuration = 4.0;\n\n// This makes the line fade toward the end so that visually the path is more clear.\n// It's more expensive and there are glitches when line segments overlap. To prevent\n// glitches, phaseSpan must be less than 0.375 when FADE is enabled.\n//#define FADE\n\nconst float baseFrequency = 55.0 * exp2(7.0/12.0); // E2 note\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Slightly cheaper linear version of smoothstep\nfloat linestep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nvec2 CS(float theta)\n{\n    return vec2(cos(theta), sin(theta));\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = CS(theta);\n    return mat2(cs.x, cs.y, -cs.y, cs.x);\n}\n\n// Projects so that the closest face of the canonical cube maps to the canonical square\nvec2 perspectiveProject(vec3 point, float fov)\n{\n    float offset = 1.0 / tan(fov / 2.0);\n    float cameraZ = -(1.0 + offset);\n    float zDist = point.z - cameraZ;\n    return point.xy / (zDist / offset);\n}\n\n// Projects so that the closest face of the canonical tesseract maps to the canonical cube\nvec3 perspectiveProject(vec4 coord, float fov)\n{\n    float offset = 1.0 / tan(fov / 2.0);\n    float cameraW = -(1.0 + offset);\n    float wDist = coord.w - cameraW;\n    return coord.xyz / (wDist / offset);\n}\n\nvec3 tetrahedron(float phase)\n{\n    const vec3[] vertices = vec3[](\n        vec3(1.0, 1.0, 1.0),\n        vec3(-1.0, 1.0, -1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(1.0, -1.0, -1.0));\n    \n    const ivec2[] lines = ivec2[](\n        ivec2(0, 1),\n        ivec2(1, 2),\n        ivec2(2, 0),\n        ivec2(0, 3),\n        ivec2(3, 1),\n        ivec2(1, 2),\n        ivec2(2, 3),\n        ivec2(3, 0));\n        \n    float totalPhase = float(lines.length()) * phase;\n    ivec2 line = lines[int(totalPhase)];\n    float linePhase = fract(totalPhase);\n    \n    return mix(vertices[line.x],\n        vertices[line.y],\n        linePhase) / sqrt(3.0);\n}\n\nvec4 tesseract(float phase)\n{\n    vec4[] vertices = vec4[](\n        // Cube in -w\n        // Square in -z, -w\n        vec4(-1, -1, -1, -1),\n        vec4(1, -1, -1, -1),\n        vec4(1, 1, -1, -1),\n        vec4(-1, 1, -1, -1),\n        \n        // Square in +z, -w\n        vec4(-1, -1, 1, -1),\n        vec4(1, -1, 1, -1),\n        vec4(1, 1, 1, -1),\n        vec4(-1, 1, 1, -1),\n        \n        // Cube in +w\n        // Square in -z, +w\n        vec4(-1, -1, -1, 1),\n        vec4(1, -1, -1, 1),\n        vec4(1, 1, -1, 1),\n        vec4(-1, 1, -1, 1),\n        \n        // Square in +z, +w\n        vec4(-1, -1, 1, 1),\n        vec4(1, -1, 1, 1),\n        vec4(1, 1, 1, 1),\n        vec4(-1, 1, 1, 1)); // 0s, 1s easy to deal with, normalize to canonical\n        \n    // Euler path of hypercube lines\n    ivec2[] lines = ivec2[](\n        ivec2(0, 4),\n        ivec2(4, 7),\n        ivec2(7, 3),\n        ivec2(3, 11),\n        ivec2(11, 15),\n        ivec2(15, 14),\n        ivec2(14, 10),\n        ivec2(10, 2),\n        ivec2(2, 6),\n        ivec2(6, 5),\n        ivec2(5, 13),\n        ivec2(13, 14),\n        ivec2(14, 6),\n        ivec2(6, 7),\n        ivec2(7, 15),\n        ivec2(15, 12),\n        ivec2(12, 4),\n        ivec2(4, 5),\n        ivec2(5, 1),\n        ivec2(1, 9),\n        ivec2(9, 8),\n        ivec2(8, 12),\n        ivec2(12, 13),\n        ivec2(13, 9),\n        ivec2(9, 10),\n        ivec2(10, 11),\n        ivec2(11, 8),\n        ivec2(8, 0),\n        ivec2(0, 1),\n        ivec2(1, 2),\n        ivec2(2, 3),\n        ivec2(3, 0));\n        \n    float totalPhase = float(lines.length()) * phase;\n    ivec2 line = lines[int(totalPhase)];\n    float linePhase = fract(totalPhase);\n    \n    return mix(vertices[line.x],\n        vertices[line.y],\n        linePhase) / 2.0;\n}\n\n// Slightly modified version of Jerobeam Fenderson's oscilloscope mushroom\n// https://www.youtube.com/watch?v=rtR63-ecUNo\nvec3 mushroom3D(float numMushrooms, float animationTime, float phase)\n{\n    float stemPhase = fract(phase * numMushrooms); // <- Change the number of mushrooms here\n    const float spiralFreq = 10.0;\n    vec3 point = vec3(0.0, 2.0 * stemPhase - 1.0, 0.0);\n\n    // Main spiral\n    point.xz = CS(spiralFreq * stemPhase * twoPi);\n    \n    // Stem vs cap diameter applied to main spiral\n    point.xz *= mix(0.6 * sin(twoPi * stemPhase), 0.07, float(stemPhase < 0.75));\n    \n    // Rotation\n    point.xz += 0.6 * stemPhase * CS((phase + 0.08 * animationTime) * twoPi);\n    \n    return vec3(point) / sqrt(3.0);\n}\n\n// Polygon that works with fractional vertex values\nvec2 polygon(float vertices, float phase)\n{\n    float totalPhase = phase * vertices;\n    float startIndex = floor(totalPhase);\n    float endIndex = startIndex + 1.0;\n    vec2 startVertex = CS(startIndex / vertices * twoPi);\n    vec2 endVertex = CS(min(endIndex / vertices * twoPi, twoPi));\n    \n    // linePhase must be corrected for fractional vertex values\n    float linePhase = fract(totalPhase);\n    linePhase /= mix(1.0, fract(vertices), float(endIndex > vertices));\n    return mix(startVertex, endVertex, linePhase);\n}\n\n// Inscribes a bunch of polygons\nvec2 inscribe(float levels, float vertices, float theta, float phase)\n{\n    float totalPhase = phase * levels;\n    float level = floor(totalPhase);\n    float levelPhase = fract(totalPhase);\n    \n    float slice = twoPi / vertices;\n    float halfSlice = 0.5 * slice;\n    \n    float sliceTheta = mod(theta, slice) - halfSlice;\n    float levelScale = cos(halfSlice) / cos(sliceTheta);\n    \n    return pow(levelScale, level) * rotate(theta * level) * polygon(vertices, levelPhase);\n}\n\n// The visualizer's frequency is much, much slower than the note frequency. To\n// preserve animations (e.g. rotation) between the waveform and the visualization,\n// separate time parameters are used.\nvec2 sound(float soundTime, float animationTime)\n{\n    float phase = fract(baseFrequency * soundTime);\n    float shape = mod(animationTime / shapeDuration, 4.0);\n    float currentShape = floor(shape);\n    \n    float localAnimationTime = fract(shape) * shapeDuration;\n    float envelope = smoothstep(0.0, 0.08, 0.5 - abs(fract(shape) - 0.5));\n    float cycleAlternate = floor(mod(animationTime / shapeDuration / 4.0, 2.0));\n    vec2 result = vec2(0.0);\n    \n    // Inscribed triangles\n    if (currentShape == 0.0)\n    {\n        result = rotate(0.2 * animationTime + 1.5)\n            * inscribe(6.0, 3.0 + 2.0 * cycleAlternate, 0.2 * localAnimationTime / shapeDuration, phase);\n    }\n    // Tetrahedron\n    else if (currentShape == 1.0)\n    {\n        vec3 point = tetrahedron(phase) ;\n        point.xz = rotate(0.25 * animationTime) * point.xz;\n        point.yz = rotate(-0.5) * point.yz;\n        result = perspectiveProject(point, radians(30.0));\n    }\n    // Mushroom\n    else if (currentShape == 2.0)\n    {\n        vec3 point = mushroom3D(3.0 - cycleAlternate, animationTime, phase);\n        point.yz = rotate(-0.5) * point.yz;\n        result = perspectiveProject(point, radians(30.0));\n    }\n    // Tesseract\n    else if (currentShape == 3.0)\n    {\n        vec4 point4 = tesseract(phase);\n        point4.yw = rotate(-0.35 * animationTime) * point4.yw;\n        point4.xz = rotate(0.15 * animationTime) * point4.xz;\n\n        vec3 point3 = perspectiveProject(point4, radians(120.0));\n        point3.yz = rotate(-0.4) * point3.yz;\n        result = 2.0 * perspectiveProject(point3, radians(30.0));\n    }\n    return result * envelope;\n}", "sound_code": "// In Common tab\nvec2 mainSound( int samp, float time )\n{\n    return sound(time, time);\n}", "sound_inputs": [], "buffer_a_code": "// Buffer A calculates the samples for which lines will be drawn in the visualization.\n// Each of the first (samplesPerFrame) fragments calculates one point.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int index = int(fragCoord.x + fragCoord.y * iResolution.x);\n    \n    vec2 point = vec2(0.0);\n    \n    if (index < samplesPerFrame)\n    {\n        float sampleTime = (iTime * animationFrequency + phaseSpan * float(index) / float(samplesPerFrame - 1))\n         / baseFrequency;\n        point = sound(sampleTime, iTime);\n    }\n    \n    fragColor = vec4(point, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B performs the XY visualization. The backbuffer is used so the path has\n// a fading tail.\n\nconst float lineThickness = 0.0075; \n\n// From Inigo Quilez\nfloat lineDist(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 readSample(int index)\n{\n    ivec2 texel = ivec2(index % int(iResolution.x), index / int(iResolution.x));\n    return texelFetch(iChannel0, texel, 0).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = 1.1 * (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Only compute near the limits of the waveforms: [-1, 1]\n    float bound = max(abs(uv.x), abs(uv.y));\n    if (bound < 1.1)\n    {\n        float dist = 1e5;\n        float intensity = 1.0;\n\n        for (int i = 0; i < samplesPerFrame - 1; i++)\n        {\n            vec2 start = readSample(i);\n            vec2 end = readSample(i + 1);\n            float newDist = lineDist(uv, start, end);\n\n#ifdef FADE   \n            // Progressively brighten each line\n            // The pixel will take the intensity value of the closest line\n            // This method is very glitchy when lines overlap due to floating point error\n            intensity = mix(intensity, float(i + 1) / float(samplesPerFrame - 1),\n                float(newDist < dist));\n#endif\n            dist = min(dist, newDist); \n        }\n        // Fade off near the border and brighten just a smidge for FADE mode\n        intensity *= linestep(1.1, 0.95, bound);\n        intensity = 0.2 + 0.8 * intensity;\n        \n        float line = min(lineThickness / dist, 1.0);\n        color = intensity * pow(vec3(line), vec3(10.0, 1.0, 10.0));\n        vec3 previous = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n        color = (0.45 * color + 0.75 * previous); // Blend with backbuffer\n    }\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1215, 1215, 1251, 1251, 1510], [1512, 1512, 1569, 1569, 2022]], "test": "untested"}
{"id": "NssyWB", "name": "Classified", "author": "wyatt", "description": "trying to classify digits ... ", "tags": ["digit"], "likes": 5, "viewed": 279, "published": 3, "date": "1642644448", "time_retrieved": "2024-07-30T17:08:34.979507", "image_code": "// Activation of Each Digit with Other Digits\nMain\n    int me = int(U.x/_s.x);\n    Q = vec4(0);\n    float tot = 0.;\n    float y = floor(U.y/_s.y);\n    float x = floor(U.x/_s.x);\n    for (float i = 0.; i < _s.x; i++)\n        tot += abs(active(i,y));\n    Q += 1.-7.*abs(active(x,y))/tot;\n    Q *= 10.*pow(Q,vec4(5));\n    Q *= number(me,mod(U,_s));\n    \n    if (U.x>10.*_s.x||U.y>10.*_s.y) Q = vec4(0);\n    Q = 1.-Q;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Main void mainImage(out vec4 Q,in vec2 U){UNIFORMS\nvec2 R; vec2 V; float T; int I;\n#define UNIFORMS R=iResolution.xy;V=gl_FragCoord.xy;T=iTime;I=iFrame;\n#define _s vec2(64,64)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define number(n,u) smoothstep(.5,.45,.01*sin(2.*T)+B(clamp(u,vec2(0),_s)+vec2(n,12)*_s).w)\n#define weight(n,u) (C(clamp(u,vec2(0),_s)+vec2(n,0)*_s).w)\n#define active(x,y) A(vec2(x,y)+.5).w\n", "buffer_a_code": "// Test\nMain\n\n    if (U.y>10.||U.x>10.) discard;\n    Q = vec4 (0);\n    int a = int(floor(U.x));\n    int b = int(floor(U.y));\n    for (float x = 0.; x < _s.x; x++) \n    for (float y = 0.; y < _s.y; y++) \n        Q += \n            weight(a,vec2(x,y))*\n            number(b,vec2(x,y))\n            /_s.x/_s.y;\n    \n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Train\nMain \n    int me = int(floor(U.x/_s.x));\n    if (U.x>10.*_s.x||U.y>_s.y) discard;\n    U = mod(U,_s);\n    Q = vec4(0);\n    Q += 3.*number(me,U);\n    for (int i = 0; i < 10; i++) \n    if (i!=me) {\n        Q -= number(i,U);\n    }\n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdfyDS", "name": "Flow Fields", "author": "manu210404", "description": "Press r to reset\nUse the browser extension to speed up to your liking\n\nFeedback is always welcome! I'd like to improve my style of coding. ", "tags": ["noise", "perlin", "turbulence", "buffer", "flowfield"], "likes": 38, "viewed": 1000, "published": 3, "date": "1642629064", "time_retrieved": "2024-07-30T17:08:36.082558", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n//    vec4 col = 0.1+0.8*texture(iChannel0,uv);\n    vec4 col = texture(iChannel0,uv);\n    col = pow(col, vec4(1.5));\n#ifdef LIGHT_MODE\n    col = (1.-col);\n#endif\n    uv = fragCoord/iResolution.xy-0.5;\n    fragColor = col\n#ifdef VIGNETTE\n    *(1.-0.5*dot(uv,uv))\n#endif\n    ;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    int n = posToIdx(ivec2(fragCoord), int(iResolution.y));\n    \n    \n    // position of dot\n    vec2 p = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n#ifdef CURL\n    p += field(p)*STEP_SIZE/FIELD_SCALE;\n#else\n    p += field(p)*STEP_SIZE;\n#endif\n    fragColor = vec4(p,0.0,1.0);\n    \n    // the dot gets random position when...\n    // ...pressing r for resetting\n    bool r = bool(texelFetch(iChannel1, ivec2(R, 0), 0).x);\n    \n#ifdef RESET_OUTOFBOUND\n    // ...out of bounds\n    bool b = p.x > iResolution.x/iResolution.y || p.x < 0.0 || p.y > 1.0 || p.y < 0.0;\n#else\n    bool b;\n#endif\n\n    // ...randomly\n#ifdef RESET_PROB\n    bool h = hash11(float(n)+float(iFrame)/127.0) < RESET_PROB;\n#else\n    bool h = false;\n#endif\n    \n    //bool o = texture(iChannel2, p).x < 0.5;\n    if (r || b || h || iFrame == 0) {\n        // reset position \n        fragColor = vec4(hash22(uv+fract(iTime))*vec2(iResolution.x/iResolution.y, 1.0), 0.0, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// -- tweakable parameters --\n// size of particles\n#define PARTICLE_SIZE 0.004\n// amount of particles\n#define PARTICLES 128\n// opacity of particles\n#define OPACITY 1.0\n// step size per frame\n#define STEP_SIZE 0.002\n// scale of the noise function used for the curls\n#define FIELD_SCALE 2.5\n// offset of the noise function for variety\n#define FIELD_OFFSET vec2(0, 0)\n// if defined, use curl field else just noise field\n//#define CURL\n// if defined, particles have the given probability to teleport to a random position each frame (the closer to 0 the longer the paths)\n#define RESET_PROB 0.02\n// if 2, the mouseposition modifies the distortion if 1 it doesn't and if 0 it is the only distortion\n#define MOUSE 1\n// if defined, the image appears white with black dots, else, it's the other way around\n#define LIGHT_MODE\n// if defined, the particles are reset when out of bounds\n//#define RESET_OUTOFBOUNDS\n// if defined, a subtle blur is added to the older lines.\n//#define BLUR\n// if defined a vignette effect is added\n//#define VIGNETTE\n\n\n// -- helper functions and definitions --\n\n// reset key\nconst int R = 82;\n\n// indexing of the position buffer (Buffer A)\nivec2 idxToPos(int i, int width) {return ivec2(i / width, i % width);}\nint posToIdx(ivec2 i, int width) {return i.x * width + i.y;}\n\n\n// -- noise functions --\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}\n\nfloat smoother(float t) {\n    t = clamp(t, 0.0, 1.0);\n    // 6t^{5}-15t^{4}+10t^{3}; polynomial used for smooth interpolation (from the same family of curves as the smoothstep function)\n    // this function has a continuous second derivative which makes it very useful for many applications\n    return 6.0*(t*t*t*t*t) - 15.0*(t*t*t*t) + 10.0*(t*t*t);\n}\n\nfloat perlin2d(vec2 p) {\n    vec2 i = floor(p);\n    vec2 j = ceil(p);\n    vec2 f = fract(p);\n    \n    //float su = smoothstep(uv.x, 0.0, 1.0);\n    //float sv = smoothstep(uv.y, 0.0, 1.0);\n    float su = smoother(f.x);\n    float sv = smoother(f.y);\n\n    float n0 = (1.-su)*dot(normalize(hash22(vec2(i.x, i.y))*2.-1.), f)\n                 + su *dot(normalize(hash22(vec2(j.x, i.y))*2.-1.), f-vec2(1, 0));\n    float n1 = (1.-su)*dot(normalize(hash22(vec2(i.x, j.y))*2.-1.), f-vec2(0, 1))\n                 + su *dot(normalize(hash22(vec2(j.x, j.y))*2.-1.), f-1.);\n    \n    return (1.-sv)*n0 + sv*n1;\n}\n\n// had to define them as macros because iMouse and iResolution are not defined in the \"Common\" Tab\n#define mouse_to_world(p) (iMouse.xy/iResolution.xy-(p)/vec2(iResolution.x/iResolution.y, 1.0))*vec2(iResolution.x/iResolution.y, 1.0)\n#if MOUSE == 2\n#define distortion(p) (perlin2d((p).xy * FIELD_SCALE + FIELD_OFFSET)*(clamp(length(mouse_to_world(p)), 0.0,0.4)*2.5-1.)*2.0)\n#elif MOUSE == 1\n#define distortion(p) (perlin2d((p).xy * FIELD_SCALE + FIELD_OFFSET))\n#else\n#define distortion(p) (clamp(length(mouse_to_world(p)), 0.0, 0.5)*2.-.5)\n#endif\n\n#define EPS 0.0001\n#ifdef CURL\n// the raw code of this function is commented out at the bottom (curl())\n#define field(p) normalize(vec2((distortion((p) + vec2(0,EPS)) - distortion((p) - vec2(0,EPS)))/(2.0 * EPS), -(distortion((p) + vec2(EPS,0)) - distortion((p) - vec2(EPS,0)))/(2.0 * EPS)))*4.0\n#else\nvec2 field(vec2 p) {\n    return normalize(vec2(perlin2d(p*FIELD_SCALE+FIELD_OFFSET), perlin2d(p*FIELD_SCALE + FIELD_OFFSET + 100.)))*2.;\n}\n#endif\n\n\n\n/*\nvec2 curl(vec2 p) {\n    // source: https://al-ro.github.io/projects/curl/\n    \n    float eps = 0.0001;\n    vec2 r = vec2(0);\n    \n    float n1 = distortion(vec2(p.x + eps, p.y));\n    float n2 = distortion(vec2(p.x - eps, p.y));\n    \n    r.y = (n1 - n2)/(2.0 * eps);\n\n    n1 = distortion(vec2(p.x, p.y + eps));\n    n2 = distortion(vec2(p.x, p.y - eps));\n\t\n    r.x = (n1 - n2)/(2.0 * eps);\n    return vec2(r.x, -r.y);\n}*/", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col;\n    vec2 uv = (fragCoord/iResolution.y);// + vec2((iResolution.y - iResolution.x) / iResolution.y / 2.0, 0));\n\n    // rendering the dots\n    float minDist = 2.;\n    for (int i = 0; i < PARTICLES; i++) {\n        vec2 p = texelFetch(iChannel0, idxToPos(i, int(iResolution.y)), 0).xy;\n        minDist = min(minDist, length(uv-p));\n    }\n    \n\n    if ((iFrame == 0) || bool(texelFetch(iChannel2, ivec2(R, 0), 0).x)){\n        col = vec4(0);\n    } else {\n        col = texture(iChannel1,(fragCoord/iResolution.xy)\n#ifdef BLUR\n        // adding a small amount to the coordinates adds a subtle blur to the old lines\n        +0.000006*(iFrame%2==0?-1.0:1.0)\n#endif\n        );\n    }\n    col = col + (1.-col) * vec4(OPACITY*smoothstep(PARTICLE_SIZE + 0.0015, PARTICLE_SIZE - 0.0015, minDist));\n    \n    // damping\n    col = col*0.996;\n    \n    // col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdsyWS", "name": "Flying Car Blues", "author": "eiffie", "description": "Even flying cars have to find parking spots.", "tags": ["music", "blues"], "likes": 21, "viewed": 402, "published": 3, "date": "1642620921", "time_retrieved": "2024-07-30T17:08:36.846515", "image_code": "#define time iTime\n#define rez iResolution\n//taxicab trig\n#define Pi (2.0*sqrt(2.0))\nfloat Cos(float a){return 2.0*abs(mod(a,2.0*Pi)-Pi)/Pi-1.0;}   \nfloat Sin(float a){return Cos(a-Pi/2.0);}   \nvec2 CosSin(float a){return vec2(Cos(a),Sin(a));}\nfloat Length(vec2 p){return abs(p.x)+abs(p.y);}\nvec3 taxi(float t){vec2 p=vec2(2.*Cos(t/2.),Sin(t));return vec3(p.x+p.y,0,p.x-p.y);}\nvec3 mcol=vec3(0.0);  \nfloat DE(in vec3 p){\n vec3 z=p; \n z.xz = abs(mod(z.xz,6.)-3.);\n z.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n if(z.x>z.z)z.xz=z.zx;\n float dg=z.y,t=sin((z.x+z.z)*3.)*.1,ds=length(z.xz+sin(p.zx)*.2)-.4+t;\n float dt=dg-1.5+t+sin((p.x-p.z)*.3)*.5;\n p.xz=abs(mod(p.xz+3.,12.)-6.)-3.;\n z.x+=.5;z.z=fract(z.z)-.5;\n float dc=max(length(z)-.15,abs(z.z)-0.09),n=6.;\n for(int i=0;i<5;i++){\n   vec3 c=taxi(iTime+float(2*i));\n   float dw=length(p-c)-.15;\n   if(dw<.1){//refine\n     vec3 rt=cross(vec3(0,1,0),normalize(c-taxi(iTime+float(2*i)+.3)));\n     float w=abs(dot(p-c,rt))-0.09;\n     dw=max(dw,w);\n   }\n   if(dw<dc){dc=dw;n=float(i);}\n }\n dc=max(dc,p.y-0.125);\n float d=min(min(dc,dg),max(ds*.7,dt));\n if(mcol.x>0.0){\n   if(d==dc){\n     mcol+=step(0.,abs(p.y-0.09)-.02)*(vec3(0.25)+0.25*vec3(sin(n),sin(n+1.),sin(n+2.5)));\n   }else if(d!=dg){\n     p=abs(sin(p*vec3(40.,20.,40.)));\n     mcol+=mix(vec3(0),vec3(.5)+sin(z.xyz*3.)*0.5,pow(min(p.y,min(p.x,p.z)),.2));\n   }else {\n     mcol+=vec3(ds)*.2;\n   }\n }\n return d;\n}\n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat bounce=1.;\nvec3 sky(vec3 rd, vec3 L){\n  vec3 c= abs(rd)*.2+0.3*dot(rd,L)+0.3;\n  for(float i=0.;i<5.;i+=1.){\n    vec2 p=vec2(sin(i*.1+iTime),sin(i*.1+1.+iTime*.7));\n    c+=bounce*5.*vec3(0,1,0)*exp(-abs(dot(p,rd.xz))*1000.);\n  }\n  return clamp(c,0.,1.);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd,in float dL){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n  if(d>dL)break;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,pd,os,px=1./rez.y;\n  vec3 L=normalize(vec3(0.4,0.5,0.5)),C=vec3(0);\n  float refl=1.;\n  for(int j=0;j<4;j++){\n    mcol=vec3(0);d=1.0,pd=10.0,os=0.0; //estimated,prev distance, overstep\n    for(int i=0;i<30;i++){\n      d=DE(ro+rd*t);\n      if(d>os){  //we have NOT stepped over anything \n        os=0.5*d*d/pd;//calc overstep based on ratio of this step to last \n        t+=d+os; //add in the overstep \n        pd=d; //save this step length for next calc \n      }else{  //we MAY have stepped over something \n        os*=0.5; //bisect overstep \n        t-=os; //back up \n        if(os>0.001)d=px*t*2.; //don't bail unless the overstep was small (and d of course) \n        else t+=d+os;//we are going to bail so add in this last distance \n      }\n      if(t>70.0 || d<px*t)break;\n    }\n    if(d<px*t && t<70.){\n      mcol.x=0.001;\n      vec3 so=ro+rd*t;\n      vec3 N=normal(so,d);\n      mcol*=.25;\n      refl*=mcol.x;\n      vec3 scol=mcol;mcol.x=0.;\n      float dif=0.75+0.25*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=0.5+0.5*ShadAO(so,L,1.);\n      bounce*=bounce*bounce*bounce+8.;\n      scol=(scol*dif+fr*sky(reflect(rd,N),L))*shad;\n      C=clamp(C+scol*refl,0.,1.);\n      ro+=rd*(t-px*t);rd=reflect(rd,N);t=px*t*2.;\n    }\n  }\n  return C+sky(rd,L)*refl;\n}\nvec3 path(float t){t*=.2;return vec3(2.75*sin(t),.75+sin(t*1.3)*.1,2.*cos(t)-.2);}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n vec3 ro=path(iTime),fw=normalize(-vec3(0,0.001,0.)-ro);\n //vec3 ro=vec3(1,2,0),fw=vec3(0,0,1);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,3.0));\n fragColor=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 6.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 5.0; \n  else if(n<2.0)n= -5.0; \n  else if(n<3.0)n= -2.0; \n  else if(n<4.0)n= 0.0; \n  else if(n<5.0)n= 3.0; \n  else if(n<6.0)n= -6.0; \n  else if(n<7.0)n= -1.0; \n  else n=0.0;\n  return vec2(n,r); \n}\n\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,1.5,0.001);//silly fm synth instruments \n instr sitar=instr(30.0,1.,8.0,0.0,0.12525,0.0025); \n instr bassdrum=instr(300.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   if(mod(tim,512.)<256.)a+=I(n0.x+72.0,t0/bps+0.00008*sin(t0*7.),t0,sitar)*n0.y*.4;\n   if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+63.0,time,t1,epiano)*n1.y*.25; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y*.25; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     a+=I(n2.x+32.0,t1/bps+0.008*sin(t2*5.0),t1,bassdrum)*8.0;\n     a+=I(n2.x+31.0,t1/bps+0.008*sin(t2*6.0),t1,bassdrum)*8.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y*2.; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 104, 104, 145], [149, 149, 168, 168, 190], [194, 194, 215, 215, 243], [244, 244, 265, 265, 291], [292, 292, 311, 311, 376], [400, 400, 420, 420, 1406], [1408, 1408, 1437, 1447, 1583], [1601, 1601, 1627, 1627, 1844], [1856, 1856, 1882, 1882, 1955], [1957, 1957, 2006, 2006, 2157], [2158, 2158, 2187, 2187, 3524], [3525, 3525, 3544, 3544, 3607], [3608, 3608, 3629, 3629, 3727], [3728, 3728, 3785, 3785, 4028]], "test": "untested"}
{"id": "ssXyDH", "name": "Slow light", "author": "bgold", "description": "Basic raymarching with hard shadows, but keeps track of light travel time.  The light speed is set to be not *too* fast relative to the motion of the object.\n\nCurious to see what refraction/caustics would look like, but that's another exercise... ", "tags": ["raymarching", "finitelightspeed"], "likes": 8, "viewed": 311, "published": 3, "date": "1642620277", "time_retrieved": "2024-07-30T17:08:37.611470", "image_code": "const float LIGHTSPEED = 4.0;\n\nconst vec3 CAMPOS = vec3(0);\n\nconst float WALLPOS = 10.0;\nconst float FLOORPOS = -0.5;\nconst vec3 LIGHTPOS = vec3(2.0, -5.0, 1.0);\n\nconst vec3 OBJCEN = vec3(0, 5.0, 0);\nconst float OBJRAD = 0.3;\n\nconst float EPS = 1e-2;\n\nconst vec3 OBJCOLOR = vec3(0.929,0.831,0.000);\nconst vec3 FLOORCOLOR = vec3(0.9);\nconst vec3 WALLCOLOR = vec3(0.447,1,1);\n\nvec3 objpos(in float t) {\n    return OBJCEN + 1.3 * vec3(cos(t), sin(t), 0);}\n\nconst float R1 = 2.1;\nconst float R2 = 0.5;\n\n\nvec3 rotxy(in vec3 x, in float a) {\n    return mat3(cos(a),-sin(a), 0., sin(a), cos(a), 0., 0.,0.,1.) * x;}\n\nvec3 rotxz(in vec3 x, in float a) {\n    return mat3(cos(a),0.,-sin(a), 0.,1.,0., sin(a),0.,cos(a)) * x;}\n\n/*\n// sphere\nfloat sdf(in vec3 r, in float t) {\n    float d  = distance(r, objpos(t)) - OBJRAD;\n    return d;\n}\n*/\n\n// rotating cube\nfloat sdf(in vec3 r, in float t) {\n    vec3 dr = rotxy(r-objpos(t), R1*t);\n    dr = rotxz(dr, R2*t);\n    dr = abs(dr) - OBJRAD;\n    float d = max(dr.x,dr.y);\n    d = max(d,dr.z);\n    return d;\n}\n\nvec3 grad(in vec3 r, in float t) {\n    vec3 n;\n    vec3 dr = rotxy(r-objpos(t), R1*t);\n    dr = rotxz(dr, R2*t);\n    if (abs(dr.x) > abs(dr.y) && abs(dr.x) > abs(dr.z)) {\n        n = vec3(sign(dr.x),0.0,0.0);\n    } else if (abs(dr.y) > abs(dr.x) && abs(dr.y) > abs(dr.z)) {\n        n = vec3(0.0,sign(dr.y),0.0);\n    } else {\n        n = vec3(0.0,0.0,sign(dr.z));\n    }\n    n = rotxz(n, -R2*t);\n    n = rotxy(n, -R1*t);\n    return n;\n}\n\n\nfloat objhit(in vec3 p, in vec3 v, in float t0) {\n    float d;\n    float t = iTime-t0;\n    float dt;\n    for (int i=0; i<100; i++) {\n        d = 0.7*sdf(p, t);\n        d = min(d, WALLPOS-p.y);\n        // many rays are nearly parallel to the floor so the next line speeds things up near the floor\n        d = min(d, (p.z-FLOORPOS)/max(abs(normalize(v).z), EPS));\n        if (d < 0.0) break;\n        dt = d / length(v);\n        p += v * dt;\n        t -= dt;\n        if (p.y < -1.0) return 0.0;\n    }\n    return (iTime-t0)-t;\n}\n     \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1 to 1 in y)\n    vec2 uv = (fragCoord - iResolution.xy*0.5 ) / iResolution.y * 2.0;\n    // about 20deg vertical FOV\n    vec3 rayvel = LIGHTSPEED * normalize(vec3(uv.x,0.0,uv.y) - vec3(0,-5.0,0));\n    vec3 raypos = vec3(0);\n    \n    float cht = objhit(raypos, rayvel, 0.0);\n    \n    vec3 bouncepos = raypos + cht * rayvel;\n    vec3 bouncevel;\n    \n    vec3 col;\n    \n    float intensity = clamp(pow(distance(LIGHTPOS, bouncepos)/WALLPOS*1.2, -2.0), 0.0, 1.0);\n    \n    if (bouncepos.y > WALLPOS-EPS || bouncepos.z < FLOORPOS+EPS) {\n        col = FLOORCOLOR;\n        if (bouncepos.y > WALLPOS-EPS) col = WALLCOLOR;\n        bouncepos = vec3(bouncepos.x, min(WALLPOS-EPS,bouncepos.y), max(FLOORPOS+EPS,bouncepos.z));\n        bouncevel = LIGHTSPEED * normalize(LIGHTPOS - bouncepos);\n        \n        float sht = objhit(bouncepos, bouncevel, cht);\n        if (sht > 0.0) {col *= 0.2;}\n    } else {\n        //float dd = dot(normalize(bouncepos-objpos(iTime-cht)), normalize(LIGHTPOS-bouncepos));\n        float dd = abs(dot(grad(bouncepos,iTime-cht), normalize(LIGHTPOS-bouncepos)));\n        col = OBJCOLOR * clamp(dd,0.2,1.0);\n    }\n    \n    fragColor = vec4(col*intensity, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 375, 400, 400, 452], [500, 500, 535, 535, 607], [609, 609, 644, 644, 713], [831, 848, 882, 882, 1042], [1044, 1044, 1078, 1078, 1478], [1481, 1481, 1530, 1530, 2005], [2013, 2013, 2069, 2125, 3288]], "test": "untested"}
{"id": "ssXcDB", "name": "attraction - repulsion 2b", "author": "FabriceNeyret2", "description": "red particles automatically follow the green particles with even spacing.\nCan be use to evenly resample a point distribution.", "tags": ["bluenoise", "resampling"], "likes": 1, "viewed": 211, "published": 3, "date": "1642618481", "time_retrieved": "2024-07-30T17:08:38.362462", "image_code": "// variant of https://shadertoy.com/view/7dXcDB\n// version2 of https://shadertoy.com/view/7sXyWS\n\n// === draw particles ===============================\n#define l2(v) dot(v,v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    O-=O;\n    \n    float d = 1e9; \n    for( float y=0.; y < 8.; y++ )               // draw red points\n        for( float x = N-N0; x < N; x++ )\n            d = min(d, l2( U  -T(x,y).xy ) );\n    O.r = smoothstep(3., 0., sqrt(d)*R.y -6.);          \n       \n    d = 1e9;        \n    for( float y=9.; y < 16.; y++ )              // draw green points\n        for( float x = 0.; x < N; x++ )\n            d = min(d, l2( U  -T(x,y).xy ) );\n    O.g = smoothstep(3., 0., sqrt(d)*R.y );          \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === manage particles ===============================\n// [0..N[ x [0..7 ] = red particles  \n// [0..N[ x [8..15] = green particles\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if ( u.x>N ) return; \n    \n    if (iFrame < 1) {                                  // --- init positions\n        vec2 r = H(u);\n        O.xy = u.y<8. ? 2.*r-1.                                    // rouges: Uniform\n                      : (vec2(1,.5)+.5*(r.y-.5)) * cos( 6.28*r.x + vec2(0,11) ); // verts : ellipse\n        return;\n    }\n    O = T(u.x,u.y);                                    // previous state\n    \n    if (u.y>8.) {\n#if 1                                                  // animation\n        vec2 r = H(u);\n#  if 1                      // deformed ring\n        O.xy = (.75+.25*cos(iTime+vec2(0,11))+.5*(r.y-.5)) * cos( 6.28*r.x + vec2(0,11) ); // verts : ellipse\n#  else                      // 2 components\n        O.xy = .5*sqrt(r.y) * cos( 6.28*r.x + vec2(0,11) ); // verts : ellipse\n        O.x += cos(.5*iTime)*( u.y>12. ? 1. : -1. );\n#  endif\n#endif\n        return;\n    }\n    \n    vec2 V = vec2(0);                                  // --- optimize reds\n    for( float y=0.; y < 8.; y++ )\n        for( float x = 0.; x < N; x++ ) {\n            if ( vec2(x,y) != u-.5 && x >= N-N0 )      // Freud forbid to attract or repulse yourself\n                V -= N/N0* normalize( T(x,y).xy - O.xy );    // repulsed by reds\n            V += normalize( T(x,y+8.).xy - O.xy );     // attracted by greens\n        }\n    O.xy += V/(16.*N);                                 // new position\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 128.,  // number of target green points\n     N0 = 16.;   // number of red points ( <= N )\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)-0.*fract(iDate.w)) *43758.5453123)\n#define T(x,y)   texelFetch( iChannel0, ivec2(x,y), 0)\n\n\n\n\n//#define normalize(v) normalize(v+1e-5) \n//#define normalize(v) sign(v)\n//#define normalize(v) ( length(v) < 1e-5 ? vec2(0) : (v)/length(v) )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 214, 214, 768]], "test": "untested"}
{"id": "fsXyDB", "name": "Genuary 2022 - Day19", "author": "z0rg", "description": "My participation to genuary 2022\nUse text/typography.\n", "tags": ["text", "generative", "genuary", "2022", "typo"], "likes": 14, "viewed": 338, "published": 3, "date": "1642614570", "time_retrieved": "2024-07-30T17:08:39.316910", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .95\n#define GLOW_OPACITY .86\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat getLetter(vec2 p, vec2 pos)\n{\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75);\n\n    vec2 stp = vec2(1./16.);\n    vec2 coords = clamp((p.xy*vec2(-1.))*.02, vec2(0.), stp)+stp*pos+off;\n    float sdf = texture(iChannel0, coords).x-.1;\n    return -sdf;\n}\n\nvec2 map(vec3 p)\n{\n    p.xy -= vec2(6.2,1.5);\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec2 off = vec2(1.5,0.);\n    acc = _min(acc, vec2(getLetter(p.xy+off*0., vec2(7.,11.)), 0.));\n    acc = _min(acc, vec2(getLetter(p.xy+off*1., vec2(5.,11.)), 1.));\n    acc = _min(acc, vec2(getLetter(p.xy+off*2., vec2(14.,11.)), 2.));\n    acc = _min(acc, vec2(getLetter(p.xy+off*3., vec2(5.,10.)), 3.));\n    acc = _min(acc, vec2(getLetter(p.xy+off*4., vec2(1.,11.)), 4.));\n    acc = _min(acc, vec2(getLetter(p.xy+off*5., vec2(2.,10.)), 5.));\n    acc = _min(acc, vec2(getLetter(p.xy+off*6., vec2(9.,10.)), 6.));\n    acc.x = max(acc.x, abs(p.z)-.5);\n    \n    acc = _min(acc, vec2(-p.y-.675, 7.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 15.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 lpos = vec3(-10.,-10.,10.);\n    vec3 ldir = lpos-p;\n    float ndotl = dot(normalize(ldir), n);\n    n.xy *= r2d(iTime+p.x);\n    vec3 col = n*.5+.5;\n    if (abs(dot(n, vec3(0.,0.,1.))) > 0.75)\n        col = vec3(0.);\n\n    if (res.z == 7.)\n        col = vec3(.01)+vec3(0.286,0.286,0.831)*sat(ndotl)*.25;\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(1.);\n    float zoom = 12.;\n    vec3 ro = vec3(sin(iTime),-4.,-5.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    ro -= zoom*vec3(uv.xy, 0.);\n    //rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n            for (int i = 0; i < 1; ++i)\n            {\n                vec3 refl = normalize(reflect(rd, n));\n                float spec = 1.;\n\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), spec);\n            \n                if (dot(refl, n) < 0.01)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl, 64);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    col += getMat(resrefl, refl, prefl, nrefl);\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    ;//col += getEnv(refl);\n                    break;\n                }\n                rd = refl;\n            }\n    }\n    col *= 2.5/(col+1.);\n    col = pow(col, vec3(1.7));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel1,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75);\n    vec3 col = rdr(uv+off);\n    col = sat(col);\n    //col = texture(iChannel0, fragCoord/iResolution.xy).xxx;\n//    col = mix(col, vec3(1., 0., 0.), 1.-sat((abs(length(uv)-.25)-0.001)*400.));\n    col = mix(col, texture(iChannel2, fragCoord/iResolution.xy).xyz, .9);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXyDB.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1178]], "test": "untested"}
{"id": "wdcSzH", "name": "head0000000", "author": "yy2901", "description": "raymarch", "tags": ["raymarch"], "likes": 25, "viewed": 399, "published": 3, "date": "1642606785", "time_retrieved": "2024-07-30T17:08:40.515705", "image_code": "#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n#define OCTAVES 2\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.001;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot((k1-q),k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nmat3 scale(float x,float y,float z){\n    return mat3(\n    vec3(x,0.,0.),vec3(0.,y,0.),vec3(0.,0.,z)\n    );\n}\n\nfloat head(vec3 sP){\n    float s1 = length(sP*scale(1.2,1.0,1.0)-vec3(0.0,0.5,0.0))-0.5;\n    float s2 = length(sP*scale(1.2,1.3,1.2)-vec3(0.0,0.12,0.15))-0.4;\n    float s3 = opSmU(s1,s2,0.2);\n    //float s5 = opSmU(s3,neck,0.1);\n    float s6 = sdCone((sP-vec3(0.,0.25,0.34))*rotateX(-2.1),0.22,0.2,0.0)-0.03;\n    float s7 = opSmU(s3,s6,0.1);\n    float s8 = length(sP-vec3(0.0,-0.08,0.27))-0.2;\n    float s9 = opSmU(s7,s8,0.1);\n    float s10 = length((vec3(abs(sP.x),sP.y,sP.z)-vec3(0.4,0.25,-0.03))*rotateY(0.37)*rotateZ(1341.6)*rotateX(1149.15)*scale(8.0,1.0,1.2))-0.12;\n    float s11 = opSmU(s9,s10,.05);\n    float s12 = length(sP-vec3(0.0,-0.14,0.56))-0.09;\n    float s13 = opSmS(s12,s11,0.1);\n    return s13;\n}\n\nfloat displace(vec3 sP,float geo){\n    float final;\n    if(geo<=0.01){\n        float disp = geo-(0.1*fbm(sP*3.0*rotateY(iTime+12.0*(0.3*(sin(sP.y*1.0+iTime*0.3))+0.6))+vec3(0.,0.,2.0*iTime))-0.195);\n    \tfinal = opSmS(disp,geo,0.3);\n    }else{\n        final = geo;\n    }\n    return final;\n}\n\n\nfloat sceneSDF(vec3 sP) {\n    vec3 sPh=sP*rotateY(noise(vec3(iTime*0.5))-0.5)*rotateX(0.1*noise(vec3(iTime*0.5+123.456))-0.09)*rotateZ(0.1*noise(vec3(iTime*0.5+222.111))-0.05);\n    \n\tfloat head = head(sPh);\n\n    float s4 = sdCapsule(sP-vec3(0.0,-0.5,-0.15),1.0,0.26);\n    float s14 = length(sP-vec3(0.0,-0.7,-0.18))-0.4;\n    float s15 = opSmU(s4,s14,0.1);\n    float s16 = length(vec3((sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s17 = opSmU(s15,s16,0.5);\n    float s16n = length(vec3(-(sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s18 = opSmU(s17,s16n,0.5);\n    float torso = opSmU(s18,s4,0.1);\n    torso-=0.03*noise(sP*8.0);\n    torso = displace(sP,torso);\n    head-=0.03*noise(sPh*8.0);\n    head = displace(sPh,head);\n    float final=opSmU(torso,head,0.01);\n\n    return final;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float depth;\n    float dd=0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = (sceneSDF(eye + dd * marchingDirection));\n        dd += dist;\n        if (dist<EPSILON) {\n            depth=dd;\n        }else if(dist>MAX_DIST){\n\t\t\treturn dd;\n            break;\n        }\n        \n    }\n    return depth;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=3;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-sceneSDF(p+n*d))/d);\n    }\n    return ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    //dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    float sdf = shortestDistanceToSurface(eye, dir);\n    if(sdf>MAX_DIST || sdf==0.0){\n        fragColor = vec4(0.0);\n        return;\n    }\n    float dist = sdf;\n    vec3 p = eye + dist * dir;\n    vec3 N = eN(p);\n    float occ = 1.0-AO(p,N);\n\n    vec3 ref = (reflect(dir,N));\n    color=(texture(iChannel0,ref).xyz*0.5+vec3(0.5))*occ*(1.0-smoothstep(4.5,6.0,dist));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 62, 62, 103], [105, 105, 125, 125, 224], [226, 226, 247, 247, 591], [593, 593, 615, 615, 788], [808, 808, 827, 827, 993], [1091, 1091, 1122, 1122, 1213], [1215, 1215, 1248, 1248, 1313], [1316, 1316, 1361, 1361, 1424], [1426, 1426, 1491, 1491, 1831], [1833, 1833, 1877, 1877, 1977], [1979, 1979, 2023, 2023, 2122], [2124, 2124, 2168, 2168, 2268], [2270, 2270, 2293, 2293, 2418], [2420, 2420, 2443, 2443, 2568], [2570, 2570, 2593, 2593, 2718], [2720, 2720, 2756, 2756, 2828], [2830, 2830, 2850, 2850, 3544], [3546, 3546, 3580, 3580, 3836], [3839, 3839, 3864, 3864, 4640], [4642, 4642, 4709, 4709, 5039], [5053, 5053, 5118, 5118, 5250], [5252, 5252, 5269, 5269, 5579], [5581, 5581, 5605, 5605, 5755], [5758, 5758, 5815, 5815, 6397]], "test": "untested"}
{"id": "sslcRs", "name": "[ hsb color study ]", "author": "SimonOakey", "description": "shader study working with color an some kind of \"cheap reflection\"", "tags": ["color", "flow", "hsb"], "likes": 13, "viewed": 504, "published": 3, "date": "1642555992", "time_retrieved": "2024-07-30T17:08:41.539966", "image_code": "#define Pi = 3.14159;\n   \nconst float fluid_speed = 6.0; \n\nconst int complexity = 10; \n\n// random function\n#define rand(n) fract(cos(n*89.42)*343.42)\n\nvec3 hsb2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0. , 4., 2.), 6.) - 3.) - 1., 0., 1. );\n    rgb = rgb * rgb * (3. - 2. * rgb);\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec2 R = iResolution.xy; \n   \n   vec2 p=(2.0*fragCoord.xy-R)/max(R.x,R.y);\n  \n   // rotate the uv\n   p = rot(p,iTime*.01);\t\n   \n   // move the uv\n   p.x+= sin(iTime*.016)*2.;\n   p.y+= sin(iTime*.013)*2.;\n  \n  for(int i=1;i<complexity;i++)\n  {\n     vec2 newp = p.xy;\n     newp.x += 0.8/ float(i)*sin(float(i)*p.y+iTime/fluid_speed*.3+1.5*float(i)*.55)+14.;\n     newp.y += 0.8/ float(i)*sin(float(i)*p.x+iTime/fluid_speed*.6+1.5*float(i)*.3)+14.;\n     p = newp;\n   \n  }\n      \n      p.y +=rand(uv.x*uv.y*iTime)*10.; \n     \n\tvec3 col = hsb2rgb(vec3( p.x*.11 + uv.x*.04,p.y*.006,p.y*.006 + uv.y*.04 ));\t\n\t\n\t// make some highlights\n\tcol -= sin(p.x*11.5)*.23;\n   \n      \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 173, 173, 341], [345, 372, 398, 398, 463], [466, 466, 523, 573, 1341]], "test": "untested"}
{"id": "ss3Sz8", "name": "VHS Genuary", "author": "byt3_m3chanic", "description": "Genuary 2022 | Day 18 - VHS This was an older work I've been kicking around - but felt right for VHS/Genuary", "tags": ["raymarching", "vhs", "genuary"], "likes": 35, "viewed": 993, "published": 3, "date": "1642551494", "time_retrieved": "2024-07-30T17:08:42.711833", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Genuary 2022 | Day 18 - VHS\n    01/18/22 @byt3_m3chanic \n    \n    This was an older work I've been kicking around - but felt right for VHS/Genuary\n    \n    Thank you @Fabrice for text functions / @Shane for lighting functions.\n*/\n\n#define PI  3.14159265359\n\nvec2 curvature = vec2(3.5,4.);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.35);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = baseColor;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Genuary 2022 | Day 18 - VHS\n    01/18/22 @byt3_m3chanic \n    \n    This was an older work I've been kicking around - but felt right for VHS/Genuary\n    \n    Thank you @Fabrice for text functions / @Shane for lighting functions.\n*/\n\n#define\tR\t\t\tiResolution\n#define\tT\t\t\tiTime\n#define\tM\t\t\tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MAX_DIST    150.\n#define MIN_DIST    .001\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .45 + .40 * cos(PI2 * a + vec3(.75,.5,.25) * vec3(2.89,1.98,.95))\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// webGL2 variant with dynamic size\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= .5;\n    v += char(p, 46);      p.x -= .95;\n    v += pInt(p,fract(n)*1e2);\n    return v;\n}\n////////////////////////////////////////////////////////\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// CRT effect adapted from online blog post. \n// https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc\n\nvec4 getDate(vec2 uv, float px) {\n    vec3 C = vec3(1);\n    vec4 O = vec4(0);\n    vec2 U = ( (uv*8.)-vec2(3.,3.75) )/.45;\n\n    low C(2);C(25);C(20);U.x-=.4;\n    O+=pInt(U,3.);\n    spc\n    C(13);U.x-=.475;\n    O+=pInt(U,3.);\n    C(3);C(8);C(1);C(14);C(9);C(3);\n    spc spc\n    \n    O+=pInt(U,1.);C(-49); spc spc\n    O+=pInt(U,18.);C(-49); spc spc\n    O+=pInt(U,22.);\n    \n    //U.x+=.15;\n    U.y+=.8;\n    O+=pInt(U,abs(iDate.w));\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n    \n    return vec4(shadetext);\n}\n\n// Book Of Shaders - timing functions\nfloat linearstep(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0);}\nfloat easeOutCubic(float t) {return (t = t - 1.0) * t * t + 1.0;}\nfloat easeInCubic(float t) {return t * t * t;}\n\n//The hash functions\nfloat hash(float n) {  return fract(sin(n)*43.54); }\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43.5453); }\n\n//Sum noise\nfloat noise(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.-2.*f);\n    float n = p.x + p.y*57.;\n    float res = mix(mix( hash(n+  0.1), hash(n+  1.1),f.x),\n                    mix( hash(n+ 57.1), hash(n+ 58.1),f.x),f.y);\n    return res;\n}\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n//@iq SDF functions\nfloat sdCap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// lazy globals\nvec3 htile;\nvec3 g_hp,s_hp;\nfloat travelSpeed,modTime,fractTime,tf;\nfloat ga1,ga2,ga3,ga4,glow;\nconst float rr = 10./4.75;\nconst float rx= rr/2.5;\nvec2 map(vec3 pos, float sg) {\n    vec2 res = vec2(100.,0);\n    // get center vec and some movement\n    vec3 center = vec3(travelSpeed,rx, 0);\n    vec3 pp = pos-center;\n    vec3 sp = pp;\n    // make the id's for beams\n    vec3 pi = floor((pp + 10.)/20.);\n    vec3 tt = pos-center;\n    tt.z-=20.;//fix train to back rail\n    vec3 ti = floor((tt + 10.)/20.);\n    float ftm = hash21(ti.zy+vec2(2.))*30.;\n    tt.x-=T*ftm;\n    pp =  mod(pp+10.,20.) - 10.;\n    tt =  vec3(\n    mod(tt.x+20.,40.) - 20.,\n    mod(tt.y+10.,20.) - 10.,\n    mod(tt.z+20.,40.) - 20.);\n\n    //framework\n    vec3 dp = pp;\n    vec3 cp = pp;\n    dp.x=mod(dp.x+.5,1.)-.5;\n    cp.y=mod(cp.y+1.,2.)-1.;\n    float d2 = fBox(abs(cp)-vec3(8.5,0.,9.45), vec3(2. ,.65 , .125), .01 );\n    float d3 = fBox(abs(dp)-vec3(0.,8.5,10.), vec3(.425 ,2. ,5.45), .01 );\n    //the dx's are the objects - just a float number..\n    float d1 = min(d2,d3);\n    if(d1<res.x) {\n      // comment out line below to remove platform\n        res = vec2(d1,5.);\n        g_hp = pp;\n    }\n\n    // trains\n    float d12 = fBox(tt-vec3(0.,-1.,0),vec3(15.75,5.4,2.),1.5);\n    tt.x=abs(tt.x);\n    float w11 = fBox(tt-vec3(12.,1.,0),vec3(2.75,2.4, 5.5),.5);\n    w11 =   min(fBox(tt-vec3(4., 1.,0),vec3(2.75,2.4, 5.5),.5),w11);\n    w11 =   min(fBox(tt-vec3(0.,-1.,0),vec3(15.5,5.15,1.75),1.5),w11);\n    d12 = max(d12,-w11);\n    if(d12<res.x && ti.z<0.) {\n        res = vec2(d12,3.);\n        g_hp = tt;\n    }\n\n    // pipes\n    pp.x=abs(pp.x);\n    float d11 = sdCap(abs(pp)-vec3(8.,0.,7.), 7.5,.25);\n    if(d11<res.x) {\n        res = vec2(d11,6.);\n        g_hp = pp;\n    }\n    //planks\n    float d15 = fBox(abs(cp)-vec3(8.5,0.,10.), vec3(.15 , 5.65 , .35), .01 );\n    if(d15<res.x) {\n        res = vec2(d15,5.);\n        g_hp = pp;\n    }\n    // lights\n    pp.z = abs(pp.z);\n    float d9 =  length(pp-vec3(5.,6.,7.25))-.25;\n    if(d9<res.x&&sg>0.) {\n        res = vec2(d9,0.);\n        g_hp = pp.zxy;\n    }\n    \n    if(sg>0.){\n        glow += .065/(.0025+d9*d9);\n    }\n    \n    return res;\n}\n\nvec2 marcher( in vec3 ro, in vec3 rd, int maxstep , float sg) {\n    float t = 0.,m = 0.;\n    for( int i=0; i<maxstep; i++ ) {\n        vec2 d = map(ro + rd * t, sg);\n        m = d.y;\n        if(abs(d.x)<MIN_DIST*t||t>MAX_DIST) break;\n        t += i < 32 ? d.x*.5 :  d.x*.75;\n    }\n    return vec2(t,m);\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, float t){\n    float h = t * MIN_DIST;\n    //prevent from inlining @spalmer \n    #define ZERO 0\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h, 0.).x;\n    }\n    return normalize(n);\n}\n\n// textures\nvec4 getRock(vec3 p){\n    vec3 mfp = (p + dot(p,vec3(0,1,0))*5.);\n    float brk = 0.0;\n    brk += abs(noise(mfp.xz*2.)-.5);\n    brk += abs(noise(mfp.xz*12.0)-.5)/2.0;\n    brk = pow(1.0-clamp(brk,0.0,1.0),15.0); // curve to thin the veins\n    return vec4(mix(vec3(0),vec3(1), brk ), brk);\n}\n\nvec3 getColor(float m, in vec3 n, in vec3 p) {\n    vec3 h = vec3(1.);\n    if(m==3.) h = vec3(.2);\n    if(m==5.) {\n        h = mix(vec3(1.),vec3(.5),getRock(s_hp).rgb); \n        h = mix(h,vec3(0.),getRock(s_hp*2.).rgb);\n    }\n    return h;\n}\n\n// softshadow www.pouet.net\n// http://www.pouet.net/topic.php?which=7931\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t,0.).x;\n        if( h<0.001 ) return 0.2;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.),\n          shadow = marcher(p + n * .001 * 2., l, 92,0.).x;\n    if(shadow < length(p -  lpos)) dif *= .3;\n    return dif;\n}\n\nvec3 getSpec(vec3 p, vec3 n, vec3 l, vec3 ro) {\n    vec3 spec = vec3(0.);\n    float strength = 0.75;\n    vec3 view = normalize(p - ro);\n    vec3 ref = reflect(l, n);\n    float specValue = pow(max(dot(view, ref), 0.), 32.);\n    return spec + strength * specValue;\n}\n\n//@Shane low cost AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*1.25/8.; \n        float d = map(p + n*hr,0.).x;\n        occ += (hr - d)*sca;\n        sca *= .5;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\n// main\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // precal\n    travelSpeed = T * 11.2;\n    fractTime = fract(T*.15)* (20.);\n    modTime = mod(T*.3,6.);\n    \n    // make time act like trigger\n    float tm = mod(T*.3, 12.);\n    // smoothstep in hold smoothstep out\n    float a1 = linearstep(0.0, 2.0, tm);\n    float a2 = linearstep(2.0, 4.0, tm);\n    float t1 = easeInCubic(a1);\n    float t2 = easeOutCubic(a2);\n\n    float a3 = linearstep(6.0, 8.0, tm);\n    float a4 = linearstep(8.0, 10.0, tm);\n    float t3 = easeInCubic(a3);\n    float t4 = easeOutCubic(a4);\n    ga1 = t1+t2;\n    ga2 = t3+t4;\n    \n    // reset UV coords to -1 . 0 . 1\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    // ray origin / look point\n    vec3 ro = vec3(0,.75,4.5),\n         lp = vec3(0,.75,0);\n\n    // camera view\n    vec3 cf = normalize(lp-ro),\n         cp = vec3(0.,1.,0.),\n         cr = normalize(cross(cp, cf)),\n         cu = normalize(cross(cf, cr)),\n         c = ro + cf * .75,\n         i = c + uv.x * cr + uv.y * cu,\n         rd = i-ro;\n\n    vec3 C = vec3(0);\n    vec3 FC= vec3(0.75);\n    // move camera\n    ro += vec3(0,(ga1-ga2)*20., 0.);\n    \n    // get distance\n    vec2 ray = marcher(ro,rd,128, 1.);\n    s_hp=g_hp;\n\n    if(ray.x<MAX_DIST) {\n        vec3 p = ro+ray.x*rd,\n             n = getNormal(p,ray.x);\n        vec3 lpos = vec3(-2.0, 4.0, -12.5);\n        vec3 ll = normalize(lpos);\n        \n        vec3 h = getColor(ray.y,n,p);\n        float diff = getDiff(p,n,lpos);\n        vec3 spec = getSpec(p,n,ll,ro);\n        float ao = calcAO(p,n);\n        \n        C = (h * diff + spec) * ao;\n\n        // single bounce reflect \n        if ( ray.y==3.) {\n            vec3 rr=reflect(rd,n);\n            vec2 tay=marcher(p,rr,92,1.);\n            s_hp=g_hp;\n            if(tay.x<MAX_DIST){\n                p+=tay.x*rr;\n                n = getNormal(p,ray.x);\n                h = getColor(tay.y,n,p);\n                diff = getDiff(p,n,lpos);\n                spec = getSpec(p,n,ll,ro);\n                C = clamp(vec3(0),vec3(1),C+(h * diff + spec)*.1);\n            }\n        }\n    } \n    // add glow\n   \n    C = mix(C,clamp(C+glow,vec3(0),vec3(1)),glow*.3);\n    C = clamp(C,vec3(0),vec3(1));\n    // add fog\n    C = mix( C, FC, 1.-exp(-.00000085*ray.x*ray.x*ray.x));\n    //output to screen\n    float px = fwidth(uv.x);\n    vec4 date = getDate(uv, px);\n    C = mix(C,vec3(1),date.x);\n    float tmod = mod(T,2.);\n    if(tmod>1.) {\n        float dt = length(uv-vec2(.39,.496))-.0125;\n        dt=smoothstep(px,-px,dt);\n        C=mix(C,vec3(1,0,0),dt);\n    \n    }\n    \n    C =pow(C, vec3(0.4545));\n    O = vec4(C,1.0);\n}\n// end\n", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3Sz8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[387, 387, 410, 410, 571], [573, 573, 631, 631, 793], [795, 795, 851, 851, 1006], [1043, 1043, 1100, 1100, 1596]], "test": "untested"}
{"id": "fslyzl", "name": "Genuary 2022 - Day18", "author": "z0rg", "description": "My participation to genuary 2022\nVHS", "tags": ["generative", "vhs", "genuary", "2022"], "likes": 5, "viewed": 665, "published": 3, "date": "1642545602", "time_retrieved": "2024-07-30T17:08:43.556574", "image_code": "vec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 50;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 5.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(1.)*blur;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    }\n    \n    return col/float(cnt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 624./640.;  \n    vec3 bloomSample = doBloom(uv, 2./360., 117./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = (col + (bloomSample*bloomIntensity))/2.;\n   // col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec3 rdr(vec2 uv, vec2 ouv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 orig = texture(iChannel0, ouv).xyz;\n\n    vec3 grey = vec3(1.)*(orig.r+orig.g+orig.b)/3.;\n    \n    col = mix(orig, grey, .5);\n    col += pow(texture(iChannel1, \n    uv+(vec2(rand(), rand())-.5)*.07+.2*vec2(mod(iTime, 2.3*sat(sin(iTime+uv.y*15.)*.5)), 0.))\n    .xyz*.81, vec3(2.))*.85;\n    col *= sat(pow(texture(iChannel1, \n    uv+(vec2(rand(), rand())-.5)*.07+.2*vec2(mod(-iTime, 2.3*sat(sin(-iTime+uv.y*15.)*10.)), 0.))\n    .xyz*.81, vec3(1.))+.5);\n    \n    vec3 noiseA = pow(texture(iChannel2, ouv*vec2(1.,3.)*.2-vec2(iTime, sin(iTime))).x, 3.)*vec3(1.)\n    *pow(texture(iChannel2, ouv*vec2(1.,3.)*.1+vec2(iTime, 0.)).x, 3.);\n    col += noiseA*sat(sin(uv.y*8.))*sat(sin(iTime)*5.)*2.;\n    \n    \n    vec3 noiseB = pow(texture(iChannel2, ouv*vec2(1.,3.)*.2-vec2(iTime, sin(iTime))).x, 3.)*vec3(1.)\n    *pow(texture(iChannel2, ouv*vec2(1.,3.)*.1+vec2(iTime, 0.)).x, 3.);\n    col += noiseB*sat(sin(uv.y*15.+iTime*10.)-.8)*sat(sin(iTime*.33)*5.)*3.;\n\n    vec3 noiseC = pow(texture(iChannel2, ouv*vec2(1.,3.)*.2-vec2(iTime, sin(iTime))).x, 3.)*vec3(1.)\n    *pow(texture(iChannel2, ouv*vec2(1.,3.)*.1+vec2(iTime, 0.)).x, 3.);\n    col += noiseC*sat(sin(uv.y*15.+sin(iTime*2.))-.8)*5.;\n    col *= sat(noiseC+.9+noiseB);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float stppx = .0015;\n    ouv = floor(ouv/stppx)*stppx;\n    uv = floor(uv/stppx)*stppx;\n    ouv.x += sin(mod(uv.y+iTime, .2)/.2)*.003;\n    ouv.x += sin(mod(uv.x*10.+iTime, 1.)*10.)*.0005;\n    seed=texture(iChannel2,uv).x;\n    seed+=fract(iTime);\n    vec3 col = rdr(uv, ouv);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 544], [546, 546, 603, 603, 1041]], "test": "untested"}
{"id": "sslyzl", "name": "Genuary 2022 - Day17", "author": "z0rg", "description": "My participation to genuary 2022\n3 colors", "tags": ["colors", "generative", "genuary", "2022"], "likes": 7, "viewed": 224, "published": 3, "date": "1642545420", "time_retrieved": "2024-07-30T17:08:44.581833", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nvec3 rdr(vec2 uv)\n{\n    float shp = iResolution.x*.5;\n    vec3 col = vec3(0.9);\n    \n    vec2 bsz = vec2(.1,.15)*.7;\n    vec2 lsz = vec2(.1)*.3;\n    float stpy = .1;\n    \n    vec2 uva = uv+vec2(bsz.x, -stpy);\n    float sA = _sqr(uva, bsz);\n    col = mix(col, vec3(0.), 1.-sat(sA*shp));\n\n    float sAb = _sqr(uva-vec2(0.15+sin(iTime+0.)*.05,0.), lsz);\n    col = mix(col, vec3(0.), 1.-sat(sAb*shp));\n    float sAc = _sqr(uva-vec2(0.25+sin(iTime+.5)*.05,0.), lsz);\n    col = mix(col, vec3(0.), 1.-sat(sAc*shp));\n    float sAd = _sqr(uva-vec2(0.35+sin(iTime+1.)*.05,0.), lsz);\n    col = mix(col, vec3(0.), 1.-sat(sAd*shp));\n\n    col = mix(col, vec3(1.000,0.000,0.298), 1.-sat((length(uva)-.04)*shp));\n\n\n    float sB = _sqr(uv+vec2(-bsz.x, stpy), bsz);\n    col = mix(col, vec3(0.), 1.-sat(sB*shp));\n\n    uv *= r2d(sat(sin(iTime)*2.)*3.);\n    float sC = _sqr(uv+vec2(-bsz.x, stpy), vec2(.4, lsz));\n    col = mix(col, vec3(1.000,0.000,0.298), 1.-sat(sC*shp));\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv-vec2(-.06, 0.));\n    col = mix(col, texture(iChannel0, fragCoord/iResolution.xy).xyz,\n    .5);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslyzl.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 576]], "test": "untested"}
{"id": "7dsyRl", "name": "Genuary 2022 - Day16", "author": "z0rg", "description": "My participation to genuary 2022\nColor gradients gone wrong.", "tags": ["gradient", "generative", "genuary", "2022"], "likes": 8, "viewed": 277, "published": 3, "date": "1642545337", "time_retrieved": "2024-07-30T17:08:45.507359", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float shp = iResolution.x*.5;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    vec2 ouv = fragCoord/iResolution.xy;\n    seed=texture(iChannel1,uv).x;\n    seed+=fract(iTime);\n    float str = 4.;\n    vec3 col = vec3(0.090,0.031,0.153);\n    vec2 sz = vec2(.1, .2);\n    \n    float spc = .15;\n    vec2 ps1 = uv-vec2(-spc, 0.);\n    vec3 ps1col = mix(vec3(0.082,0.424,0.965), vec3(0.000,1.000,0.624), sat((ps1.y)*str));\n    col = mix(col, ps1col, 1.-sat(_sqr(ps1, sz)*shp));\n    \n    vec2 ps2 = uv-vec2(spc,0.);\n    vec3 ps2col = mix(vec3(0.192,0.004,0.412), vec3(0.773,0.114,0.600), sat((ps2.y)*str));\n    col = mix(col, ps2col, 1.-sat(_sqr(ps2, sz)*shp));\n    \n    vec3 rgb = vec3(0.);\n    if (iFrame == 0)\n        rgb = col;\n    else\n    {\n        vec3 prev = texelFetch(iChannel0, ivec2(fragCoord+15.*(vec2(rand(), rand())-.5)), 0).xyz;\n        rgb = prev;\n    }\n    \n    fragColor = vec4(rgb,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsyRl.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 573]], "test": "untested"}
{"id": "sdXyRf", "name": "Genuary 2022 - Day15", "author": "z0rg", "description": "My participation to genuary 2022\nI know it's heavy :p\nSand", "tags": ["generative", "sand", "genuary", "2022"], "likes": 13, "viewed": 272, "published": 3, "date": "1642545215", "time_retrieved": "2024-07-30T17:08:46.261342", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float ha = -asin(sin((p.x+p.z+sin(p.x*.5)*.5+sin(p.x*.1)*10.)))*.5\n    -asin(sin(.2*(p.x+p.z*0.+sin(p.x*.5)*.5+sin(p.x*.1)*10.)))*.5\n    -asin(sin(.2*(p.x+p.z*1.+sin(p.x*.5)*.5+sin(p.x*.1)*10.)))*.43;\n    float hb = -(sin((p.x*.2+p.z*.125+sin(p.x*.15)*.4+sin(p.x*.3)*5.)))*1.5;\n    float dune = -p.y - ha-hb*.5*sin(length(p.xz)*.15);\n\n    acc = _min(acc, vec2(dune, 0.));\n   // acc = _min(acc, vec2(length(p)-1., 0.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps, float maxDist)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.35;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    return vec3(1.000,0.804,0.580)*pow(1.-sat(abs(dot(rd, vec3(0.,1.,0.)))),15.)+vec3(0.616,0.780,0.804);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.);//n*.5+.5;\n    vec3 lpos = vec3(10.,-5,10.)+(vec3(rand(), rand(), rand())-.5)*2.5;\n    vec3 ldir = lpos-p;\n        //col = n*.5+.5;\n    vec3 resShadow = trace(p+n*.01, normalize(ldir), 200, 10.);\n    \n    if (resShadow.y < 0.)\n        col = vec3(0.733,0.667,0.545)*sat(dot(normalize(ldir), n));\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.05;\n    vec3 ro = vec3(10.+sin(iTime*.25)*3.,-4.,-10.)+dof;\n    vec3 ta = vec3(-15.,-1.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*.01;\n    vec3 res = trace(ro, rd, 512, 250.);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        n += .1*vec3(sin(p.x*30.+3.*sin(p.z*2.)+p.z*5.), 0.,0.)*sat(sin(p.z));\n        n = normalize(n);\n        col = getMat(res, rd, p, n);\n            for (int i = 0; i < 2; ++i)\n            {\n                vec3 refl = normalize(reflect(rd, n));\n                float spec = 1.;\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), spec);\n            \n                if (dot(refl, n) < 0.01)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl,128, 5.);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    col += getMat(resrefl, refl, prefl, nrefl);\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    col += getEnv(refl)*vec3(0.733,0.667,0.545)*1.1;\n                    break;\n                }\n                //col += accLight;\n                rd = refl;\n            }\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    \n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75);\n    vec3 col = rdr(uv+off);\n    col *= vec3(0.984,0.745,0.616);\n    col *= 2.1/(col+1.);\n    col = pow(col, vec3(1.6));\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .95);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXyRf.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 592]], "test": "untested"}
{"id": "fsXcRf", "name": "Genuary 2022 - Day14", "author": "z0rg", "description": "My participation to genuary 2022\nSomething youd never make.", "tags": ["generative", "genuary", "2022"], "likes": 7, "viewed": 235, "published": 3, "date": "1642545039", "time_retrieved": "2024-07-30T17:08:47.341455", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .95\n#define GLOW_OPACITY .6\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat time;\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float repa = TAU/8.;\n    float angle = atan(p.z, p.x);\n    float b = mod(angle+repa*.5,repa)-repa*.5;\n    p.xz = vec2(sin(b), cos(b))*length(p.xz);\n    \n    float lower = max(p.z-1.+p.y, -p.y-1.);\n    acc = _min(acc, vec2(lower, 0.));\n\n\n    float higher = max(max(p.z-1.-p.y-2.01, p.y+1.), -p.y-1.5);\n    acc = _min(acc, vec2(higher, 0.));\n\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 v)\n{\n    return texture(iChannel0, v*vec3(1.,-1.,1.)).xxx;\n}\n\nvec3 rdr(vec2 uv, float ior)\n{\n    uv *= .75;\n    vec3 col = vec3(0.);\n    float t = time*.2;\n    float d = 10.;\n    vec3 ro = vec3(sin(t)*d,-2,cos(t)*d);\n    vec3 ta = vec3(0.,-.5,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 refl = normalize(reflect(rd, n));\n        float reflTex = getEnv(refl).x;\n        col = (pow(reflTex, 5.)*vec3(0.804,0.443,0.996)*2.\n        +reflTex*vec3(0.580,1.000,0.839)*.5)*.2\n        +getEnv(refract(rd, n, ior));\n        ;\n    }\n    else\n    {\n        col = pow(getEnv(rd).x, 2.5)*vec3(.5);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    time = iTime+texture(iChannel1, fragCoord/8.).x*.1;\n    uv += texture(iChannel1, fragCoord/8.+iTime).xx*.001;\n    vec3 col = vec3(0.);\n    col.x = rdr(uv, .1).x;\n    col.y = rdr(uv, .2).y;\n    col.z = rdr(uv, .3).z;\n\n    col = sat(col);\n    col = pow(col, vec3(1.3));\n    col = mix(col, texture(iChannel2, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = texture(iChannel0, uv).xyz;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = rdr(uv);\n    vec2 off = (vec2(1., -1.)/(iResolution.xy*1.5));\n    if (true) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;   \n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcRf.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1178]], "test": "untested"}
{"id": "7dXyRs", "name": "Fractal Rope Torus", "author": "SnoopethDuckDuck", "description": "Lots of code stolen from TheArtOfCode! + doesn't properly align in some places + wanted to color whole thing but didn't know how.\n\nAlso, it is a torus (kind of), but not the best angle to show that off lol", "tags": ["raymarching", "template", "artofcode"], "likes": 14, "viewed": 396, "published": 3, "date": "1642542098", "time_retrieved": "2024-07-30T17:08:48.244041", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 300\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n\n    float a = atan(p.x, p.z);\n    \n    // idk why ive done it like this\n    float b = 0.5 * (1.5 + 3.); float c = 0.5 * (3. - 1.5);\n    float r1 = b + c * thc(2., 0.5 * iTime);\n    float r2 = 0.5;\n    \n    float d1 = length(p.xz) - r1;\n    vec2 uv = vec2(d1, p.y);\n    float a2 = atan(uv.x, uv.y);\n    \n    float r = 0.5;\n    float th = a + iTime;// + iTime;//0.3 * iTime;\n    float sn = 1.;\n    float n = 5.;\n    float id = 0.;\n    for (float i = 0.; i < n; i++) {\n        th += mix(2.5 * a, 0.5 * a2, step(2., i)) - 0.5 * iTime;//0. * iTime;\n        uv *= 2. * Rot(sn * th);\n        int ind = int(mod(i, 2.));       \n        sn *= sign(uv[ind]);\n        uv[ind] = abs(uv[ind]) - r;\n       \n        id += pow(0.1, i) * 0.5 * (1. + sn); // <- sloppy but works \n    }\n    \n    /*\n    uv *= Rot(0.5 * a + iTime);\n    uv.y = abs(uv.y) - 0.5;\n    uv.y = abs(uv.y) - 0.25;\n    uv.y = abs(uv.y) - 0.125;\n    */\n    r2 *= 0.75 + 0.25 * cos(4. * pi * h21(vec2(id)) - 12. * a - 4. * iTime);\n    r2 += 0.5 * cos(a - 0.6 * iTime);\n    float d = 0.4 * pow(0.5, n) * (length(uv) - r2);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n   // vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    dif = 0.2 + 0.8 * dif * step(length(lightPos-p), d);\n   // if(d<length(lightPos-p)) dif = 0.;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float lerp = 1.;//0.5 + 0.5 * thc(2., 0.5 * iTime);\n\n    float time = 0.15 * (cos(uv.x - 0.15 * iTime) + iTime);\n    float r = 0.5;\n    vec3 ro = mix(vec3(0.,3.,0.), r * vec3(cos(time), 0., sin(time)),\n                  lerp);\n   \n   // ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 aim = r * vec3(sin(time), 0, -cos(time));\n    aim = mix(vec3(0), aim, lerp);\n    vec3 rd = GetRayDir(uv, ro, aim, 1.5);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n       // float ambient = .2;\n       // float difPower = .8;\n        //float dif = max(dot(n, normalize(vec3(0,1,0))), 0.);\n        //col = vec3(dif*difPower + ambient);\n        float dif2 = GetLight(p,vec3(0., 2., 0.));\n        col = vec3(dif2);\n        col *= 0.5 + 0.5 * cos(-0.5 * iTime + 2. * length(p));\n        \n        vec3 e = vec3(1.);\n        vec3 col2 = pal(length(p) * 0.25, e, e, e, 0.2 * vec3(0., 0.33, 0.66));\n\n        col *= 1.5 * texture(iChannel0,r).rgb;\n        col = min(col, col2);\n       // col = vec3(mix(dif*difPower + ambient, dif2, 1.));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXyRs.jpg", "access": "api", "license": "mit", "functions": [[1474, 1474, 1493, 1493, 1555], [1557, 1557, 1586, 1586, 1667], [1670, 1670, 1693, 1693, 2788], [2790, 2790, 2824, 2824, 3035], [3037, 3037, 3061, 3061, 3251], [3253, 3253, 3303, 3303, 3494], [3496, 3496, 3535, 3626, 3902], [3904, 3904, 3961, 3961, 5341]], "test": "untested"}
{"id": "7sXyRN", "name": "Cube Pixel Tetrahedron", "author": "amhall", "description": "Cube-like pixels based on hexagonal tiling. Mouse to rotate the axis.", "tags": ["mouse", "cube", "hexagon", "tetrahedron", "tiling"], "likes": 39, "viewed": 788, "published": 3, "date": "1642535653", "time_retrieved": "2024-07-30T17:08:49.132665", "image_code": "// Cube-like pixels based on hexagonal tiling. Buffer A acts as a vertex shader.\n\n// Created by Anthony Hall\n\nconst int SS = 2;\n\nconst float tileSize = 0.09;\nconst float lineThickness = 0.025;\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Populated in mainImage\nvec4[6] lines;\n\n// Slightly cheaper linear version of smoothstep\nfloat linestep(float a, float b, float x)\n{\n  return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// \"Hexagonal\" distance to origin\nfloat hexDist(vec2 point)\n{\n    point = abs(point);\n    return max(point.x, dot(point, vec2(0.5, 0.5 * sqrt(3.0))));\n}\n\n// Returns the point relative to and \"hexagonal\" distance from the center of the tile\nvec3 hexTile(vec2 point)\n{\n    const vec2 tileBox = tileSize * vec2(1.0, sqrt(3.0));\n    vec2 p1 = mod(point, tileBox) - 0.5 * tileBox;\n    vec2 p2 = mod(point + 0.5 * tileBox, tileBox) - 0.5 * tileBox;\n    \n    vec2 hexPoint = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n    return vec3(hexPoint, hexDist(hexPoint));\n}\n\n// From Inigo Quilez\nfloat lineDist(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 image(vec2 point)\n{\n    float dist = 1e5;\n    for (int i = 0; i < 6; i++)\n    {\n        vec4 line = lines[i];\n        dist = min(dist, lineDist(point, line.xy, line.zw));\n    }\n    // Cap intensity at 1.0 while avoiding any unlucky division by 0\n    float intensity = lineThickness / max(lineThickness, dist);\n    return pow(vec3(intensity), vec3(0.9, 3.0, 0.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Populate lines array with rotated vertices\n    vec2[4] vertices;\n    for (int i = 0; i < 4; i++)\n    {\n      vertices[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xy;;\n    }\n\n    int lineIndex = 0;\n    for (int i = 0; i < 3; i++)\n    {\n      for (int j = i + 1; j < 4; j++)\n      {\n        lines[lineIndex] = vec4(vertices[i], vertices[j]);\n        lineIndex++;\n      }\n    }\n    \n    // Independent of supersampling, there's a little bit of antialiasing at the borders.\n    // It has to be corrected so changing the tile size or resolution doesn't mess with it\n    float aaCorrection = 0.00605 / tileSize * 450.0 / iResolution.y;\n\n    const float increment = 1.0 / float(SS);\n    const float offset = 0.5 * increment - 0.5;\n    vec3 color = vec3(0.0);\n    \n    for (int x = 0; x < SS; x++)\n    {\n        for (int y = 0; y < SS; y++)\n        {\n            vec2 screenCoord = fragCoord + vec2(x, y) * increment + offset;\n            vec2 uv = (2.0 * screenCoord - iResolution.xy) / iResolution.y;\n            vec3 tile = hexTile(uv);\n            \n            // Anti-aliased black border\n            float border = linestep(0.9, 0.9 - aaCorrection, 2.0 * tile.z / tileSize);\n\n            // Figure out which cube face we're in and sample in the middle of it\n            float theta = atan(tile.y, tile.x) - pi/6.0;\n            theta = floor(3.0 * theta / twoPi) / 3.0 * twoPi;\n            theta += pi/2.0;\n            vec2 samplePoint = uv - tile.xy\n                + 0.5 / sqrt(3.0) * tileSize * vec2(cos(theta), sin(theta));\n            samplePoint.y += 0.125; // Move the screen down a bit\n            \n            vec3 sampleColor = border * image(samplePoint);\n            color += sampleColor;\n        }\n    }\n    color /= float(SS * SS);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Each of the first four pixels of this buffer performs a simple rotation and\n// orthographic projection on its respective vertex\n\nconst vec3[4] vertices = vec3[4](\n    vec3(1, 1, 1),\n    vec3(-1, 1, -1),\n    vec3(-1, -1, 1),\n    vec3(1, -1, -1));\n    \nvec2 CS(float theta)\n{\n  return vec2(cos(theta), sin(theta));\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = CS(theta);\n    return mat2(cs.x, cs.y, -cs.y, cs.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Final point to be written to buffer\n    vec2 point = vec2(0.0); \n    \n    fragCoord = floor(fragCoord);\n    int index = int(fragCoord.x + fragCoord.y * iResolution.x);\n    if (index < 4)\n    {\n        // Rotate the tetrahedron so it's flat on a face, looking directly at\n        // another face\n        const vec3 fInit = vertices[3];\n        const vec3 u = vertices[0] / sqrt(3.0);\n        const vec3 r = normalize(cross(fInit, u));\n        const vec3 f = cross(u, r);\n        \n        // Tilt the axis based on time/mouse\n        vec3 tilt = vec3(0, 1, 0);  \n        if (iMouse.z > 0.0)\n            tilt.xz = 0.4 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n        else\n            tilt.zx = 0.4 * CS(0.3 * iTime);\n\n        vec3 tiltU = normalize(tilt);\n        vec3 tiltR = normalize(cross(tiltU, vec3(0, 0, 1)));\n        vec3 tiltF = cross(tiltU, tiltR);\n        mat3 tiltMat = mat3(tiltR, tiltU, -tiltF);\n        \n        vec3 point3 = transpose(mat3(r, u, -f)) * vertices[index];\n        point3.xz = rotate(0.5 * iTime) * point3.xz;\n        point3 = tiltMat * point3;\n        point = 0.5 * point3.xy;\n    }\n    fragColor = vec4(point, 0.0, 1.0);\n}  ", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 355, 398, 398, 445], [447, 481, 508, 508, 599], [601, 687, 713, 713, 999], [1001, 1022, 1062, 1062, 1185], [1187, 1187, 1211, 1211, 1557]], "test": "untested"}
{"id": "ssscWn", "name": "box factory 2", "author": "FabriceNeyret2", "description": "Mouse controls, camera.  \nCyclical variant of https://shadertoy.com/view/sdscRr\n\nreference: https://twitter.com/akira2768922/status/1475077131151769613\nhttps://www.reddit.com/r/desmos/comments/ry7zo8/production_line_manufacturing_boxes_d/", "tags": ["origami", "reproduction"], "likes": 52, "viewed": 620, "published": 3, "date": "1642529793", "time_retrieved": "2024-07-30T17:08:50.121023", "image_code": "// cyclical variant of https://shadertoy.com/view/sdscRr\n\n#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))                       // axial rotation\n#define rot3(P,A,a)   ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) ) // 3D rotation\n//#define D(u)          vec4( smoothstep( 0., .1 ,  .5 - max(u.xxx,u.y) ), 1 ) // tile decoration\n//#define D(u)          texture( iChannel0, u )                            \n  #define D(u)          vec4( smoothstep( 0., .1 ,  .5 - max(u.xxx,u.y) ) *(.5+texture( iChannel0, u ).r), 1. ) * vec4(1,.9,.7,1)\n#define L(p)          ( Z = p, I<2 == D.y<0. ? i : Z.y=-Z.y, I%2>0 == D0.z>0. ? Z.z=-Z.z-3. : i, \\\n                        Z.xz *= rot(-M.x), Z.yz*=rot(-M.y), exp(-.05*(Z.z+6.)) )     // fog\n\nvoid mainImage(out vec4 O, vec2 U)\n{ \n    vec4  C;\n    vec3  R = iResolution, c,A, Z,\n          D = normalize(vec3(U+U-R.xy, 5.*R.y)), D0,      // ray direction\n          p = vec3(0,0,-40), p0, q,                       // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,6,0)/1e2*cos(.5*iTime+vec3(0,11,0))+vec3(0,.12,0);\n    M = vec3(0,.5,0) - 6.3*M;  \n    p.yz *= rot(M.y),                                     // camera rotations\n    p.xz *= rot(M.x); \n    D.yz *= rot(M.y),         \n    D.xz *= rot(M.x);\n    p.z += 5.5;\n    float T = mod(iTime,2.), T0,n,i,t,a,s, N=8.;\n    O-=O;\n    p0 = p, D0 = D, T0 = T;\n    \n  for( int I=0; I<4; I++ ) { // ---- 4 copies of the base unfolding pattern with spacetime symmetries \n    p = p0, D = D0, T = T0;  // everything drawn front to back.\n    if ( I<2 == D.y<0. ) p.z += T - 7., p.y -= 2.; \n    else        p.z += -5.-T, T = 2.-T, p.y += 3., D.y=-D.y, p.y=-p.y;    // bottom/up symmetry\n    if ( I%2>0 == D.z>0. )    T = 2.-T,            D.z=-D.z, p.z=-p.z-1.; // front/rear symmetry\n    \n    for ( i=0.; i<=N; i++ ) {                  // --- folded parts ----------------\n        n = D.z > 0. ? N-i : i;                          // parse front to back\n        t = mod(T+n,6.), a = 1.57*fract(t);\n        vec2 CS = .707*sin(a+1.57/2.+vec2(1.57,0));\n        if (T<1.) c = vec3(3.,  0, -2.5), c.xy += CS, A = vec3( 0,0,1); // even roll\n        else      c = vec3(2.5, 0, -3. ), c.zy += CS, A = vec3(-1,0,0); // odd roll\n        c.xz -= floor(t/2.); c.z -= n;\n        if (mod(n,2.)>0.) c.x = -c.x, int(t)%2>0 ? c.x++ : c.z++, A.z = -A.z; // left side\n        if ( (T>1. && n>3. ) || n>5. ) // n<5 : forming cubes. n>=5 : inter-levels cubes\n            c = .5-vec3(0, n>4.?T+n-6.:0., n<6. ? 10-int(t)%2 : 5+int(n) ), // a = 0.;\n            A = vec3(-1,0,0), n!=6.-floor(T) ? a=0.: a;   // inter-cubes don't roll but first\n        if (n==N && T>1.) continue;\n     // if (n+floor(T)==N) c.z += fract(T);               // extreme cube in column\n     // if (n==N && T>0. ) c.z += fract(T), a = 1.57*fract(t); // extreme cube rotate\n        q = p-c; // if (I<2) continue;                    // for debug\n     // if ( dot(q,q) - dot(q,D)*dot(q,D) < 1.  ) {\n            vec3 Pr = rot3(q,A,a), Dr = rot3(D,A,a),      // cube frame  \n                  v = (-.5*sign(Dr) - Pr ) / Dr ,P;       // intersection with cube planes\n     // if ( dot(Pr,Pr) - dot(Pr,Dr)*dot(Pr,Dr) < 1.  ) { // Bbox. why not working ?\n            int j;                                        // draw cube faces corresponding to folds\n            #define inter(i,s) P = abs(Pr + v[i]*Dr);                   \\\n                         j = int[](1,3,2,5,0,4)[ s Dr[i]>0.?3+i:i ];    \\\n                         if( v[i]>0. && max(P.x,max(P.y,P.z)) < .501 )  \\\n                        /**/ if( j <= int(T)+int(n/2.)*2 ) /**/         \\\n                          /**/  { int t = n<6. ? int(T):1; O += D( vec2( P[(i+1+t)%3], P[(i+2-t)%3] ) )*L(c); break;} /**/ \\\n                            //  { O[j%3] =j<3?.5:1.; O.a++; break; }   // attempt of time-consistant colors\n                            //  { O[i] =.5+step(s Dr[i],0.); return; } // debug : draw color cube\n            s = sign(c.x-.5);                             // left side \n            inter(0, s*); inter(1,); inter(2,);           // front cube faces\n            v = ( .5*sign(Dr) - Pr ) / Dr ,P;             // rear cube faces\n            inter(0,-s*); inter(1,-); inter(2,-);\n     // }\n    } //if (n==8.) { O.g=0.; if (T<1.) O.b=0.; }          // for debug\n  //}\n    if ( O.a > 0. && ( D.y < 0. && n+T<6. || D.z>0. && n+T > 6. ) ) return;\n     \n    q = p;                                     // --- unfolded tiling -------------               \n    t = -q.y/D.y; q += t*D;                               // intersection with plane y=0\n    if (t > 0.) C = D( abs( fract(q.zx) -.5) )*L(q-vec3(0,0,T));  // color = tiles decoration + mask\n    c = floor(q); if (3.*abs(c.x)-c.z > 10.+step(c.x,0.) ) C-=C;  // trim cells left by rolling cubes\n    if ( T > 1. &&  abs(c.x)<=2. && c.z == -9.+3.*abs(c.x)-step(c.x,0.) )  C-=C;\n    q.x += mod(ceil(q.z),2.);                             // offset\n    if  ( q.x < -2. || q.x > 4. || q.z < -10. || q.z > 0. ) C-=C; // tiling limits\n    \n    if (C.a > 0.) O = C;\n    if (O.a > 0.) return;\n  }\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssscWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdfyzs", "name": "Doc Dump II", "author": "eiffie", "description": "Rainy day shader #2 of 6", "tags": ["music"], "likes": 27, "viewed": 879, "published": 3, "date": "1642521330", "time_retrieved": "2024-07-30T17:08:51.088436", "image_code": "#define time iTime\n#define rez iResolution\nfloat wav(float t){return abs(fract(t)-.5);}\nvec3 mcol=vec3(0.0);\nfloat glw=0.;\nfloat DE(vec3 p0){\n  vec4 p=vec4(p0,1.1);\n  vec3 c=mod(p0,10.)-4.;\n  for(int n=0;n<2;n++){\n    p.xyz=abs(mod(p.xyz,4.0)-2.0)-1.0;\n    p*=2.0/clamp(dot(p.xyz,p.xyz),0.25,1.0);\n    if(p.y>p.z)p.yz=p.zy;\n    if(p.x>p.y)p.xy=p.yx;\n    p.x+=1.0;\n  }\n  float d=(length(p.yz)-.1+0.1*wav(p.x*10.0))/p.w;\n  glw+=max(wav(p.x+p0.y+p0.z+time)-.3,0.)/(1.+d*d);\n  float g=abs(sin((c.x+c.z)*10.-time*10.));\n  float d2=min(length(c.xy),length(c.yz+vec2(.5,0.)))-.125-g*.01;\n  if(mcol.x>0.0){\n    if(d<d2)mcol+=vec3(.4)+.1*abs(p.xyz);\n    else mcol+=vec3(2.*g);\n  }\n  return min(d,d2);\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=2.*pow(max(0.,dot(rd,L)),20.);\n  return vec3(d)+abs(rd)*.1;\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec4 sphere(vec3 ro, vec3 rd){\n  vec4 s=vec4(100);\n  vec3 p=vec3(iTime*.5+6.,-4.,iTime*.5+8.);\n  p=ro-p;\n  float b=dot(-p,rd); \n  if(b>0.){\n    float inner=b*b-dot(p,p)+.7;\n    if(inner>0.){\n      float t=b-sqrt(inner);\n      if(t>0.)s=vec4(normalize(p+rd*t),t);\n    }\n  }\n  return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,px=4.0/rez.x;\n  vec4 s=sphere(ro,rd);\n  for(int i=0;i<99;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>20.0 || d<px*t)break;\n    if(t>s.w){px*=10.;ro+=rd*s.w;rd=reflect(rd,s.xyz);t=0.01;}\n  }\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 bcol=sky(rd,L),col=bcol;\n  float g=glw;\n  if(d<px*t*5.0){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);\n    vec3 scol=mcol*0.25;\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    float shad=ShadAO(so,L);\n    col=(scol*dif+.5*fr*sky(reflect(rd,N),L))*shad;\n  }\n  return mix(col,bcol,clamp(t*t/400.,0.,1.))+vec3(1.,.3,.1)*exp(-t)*clamp(g*g,0.,1.);\n}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,0.8,0.1),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvec3 path(float t){t*=.5;t+=sin(t*.1)*7.;\n  return vec3(t+sin(t*1.1),sin(t*.3)*.5-5.2,t+cos(t)*.7); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n vec3 ro=path(iTime),fw=normalize(path(iTime+0.5)-ro);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,1.0));\n fragColor=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 5.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,6.0); \n  if(n<1.0)n= 1.0; \n  else if(n<2.0)n= 3.0; \n  else if(n<3.0)n= 2.0; \n  else if(n<4.0)n= 0.0; \n  else if(n<5.0)n= 3.0; \n  else if(n<6.0)n= 0.0;\n  else if(n<7.0)n= 1.0; \n  else n= -10.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float bt,instr i){//note,time,bt 0-8,instrument \n float t=bt/bps,f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n}\nvec2 mainSound(int samps, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr bell=instr(400.0,0.15,3.,0.5,.66,0.01);\n instr sitar=instr(30.0,0.1,4.0,0.0,0.335,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(50.0,20.0,10.5,0.0,12.3131,100.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005);\n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i;\n   a+=I(n0.x+91.0,t0,bell)*n0.y*.025;\n   a+=I(n0.x+89.0,t0,bell)*n0.y*.05;\n   a+=I(n0.x+87.0,t0,bell)*n0.y*.1;\n   a+=I(n0.x+72.0,t0,sitar)*n0.y*.25;\n   if(mod(i,1.)<1.)a+=I(n0.x+93.0,t0+rnd(t0)*0.002,stick)*n0.y*0.25;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     a+=I(n1.x+67.0,t1+rnd(t1)*0.002,stick)*n1.y*.5;\n     a+=I(n1.x+64.0,t1,epiano)*n1.y*.4; \n     a+=I(n1.x+60.0,t1,epiano)*n1.y*.5; \n     //a+=I(n1.x+36.0,time,t1,organ)*n1.y*.6;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,t2,bass)*n2.y; \n       //a+=I(n2.x+36.0,t2+rnd(t2)*0.002,stick)*2.0;\n       //a+=I(n2.x+12.0,t2+sin(t2),bassdrum)*2.0;\n       a+=I(n2.x+13.0,t2+sin(t2),bassdrum)*2.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 62, 62, 87], [123, 123, 141, 141, 693], [694, 694, 723, 733, 869], [870, 870, 896, 896, 968], [980, 980, 1006, 1006, 1079], [1081, 1081, 1118, 1118, 1252], [1253, 1253, 1283, 1283, 1539], [1540, 1540, 1569, 1569, 2251], [2252, 2252, 2273, 2273, 2371], [2372, 2372, 2391, 2391, 2474], [2475, 2475, 2532, 2532, 2734]], "test": "untested"}
{"id": "sdXyzs", "name": "Rainy Day Shader #3", "author": "eiffie", "description": "Lots of reflections", "tags": ["music", "reflections"], "likes": 7, "viewed": 248, "published": 3, "date": "1642520929", "time_retrieved": "2024-07-30T17:08:51.877327", "image_code": "#define time iTime\n#define rez iResolution\nvec3 mcol=vec3(0.0);  \nfloat DE(in vec3 z0) { \n vec4 z = vec4(z0,1.1);\n for (int n = 0; n < 4; n++) { \n  z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz; \n  z*=-2./clamp(dot(z.xyz,z.xyz),1.,4.); \n  z.y+=2.05; \n }\n if(mcol.x>0.0)mcol+=vec3(.5)+sin(z.xyz*3.)*0.5;\n z=abs(z);\n return (max(z.x,max(z.y,z.z))-2.667)/z.w; \n}\n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat bounce=1.;\nvec3 sky(vec3 rd, vec3 L){\n  vec3 c= abs(rd)*.2+0.3*dot(rd,L)+0.3;\n  for(float i=0.;i<5.;i+=1.){\n    vec3 p=vec3(sin(i+iTime),cos(i),sin(i+1.+iTime*.7));\n    c+=bounce*5.*abs(p)*exp(-length(p.xz-rd.xz)*100.);\n  }\n  return clamp(c,0.,1.);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd,in float dL){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n  if(d>dL)break;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,pd,os,px=1./rez.y;\n  vec3 L=normalize(vec3(0.4,0.5,0.5)),C=vec3(1);\n  for(int j=0;j<4;j++){\n    mcol=vec3(0);d=1.0,pd=10.0,os=0.0; //estimated,prev distance, overstep\n    for(int i=0;i<30;i++){\n      d=DE(ro+rd*t);\n      if(d>os){  //we have NOT stepped over anything \n        os=0.5*d*d/pd;//calc overstep based on ratio of this step to last \n        t+=d+os; //add in the overstep \n        pd=d; //save this step length for next calc \n      }else{  //we MAY have stepped over something \n        os*=0.5; //bisect overstep \n        t-=os; //back up \n        if(os>0.001)d=px*t*2.; //don't bail unless the overstep was small (and d of course) \n        else t+=d+os;//we are going to bail so add in this last distance \n      }\n      if(t>70.0 || d<px*t)break;\n    }\n    if(d<px*t && t<70.){\n      mcol.x=0.001;\n      vec3 so=ro+rd*t;\n      vec3 N=normal(so,d);\n      mcol*=.25;\n      vec3 scol=mcol;mcol.x=0.;\n      float dif=0.5+0.5*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=ShadAO(so,L,1.);\n      bounce*=bounce*bounce*bounce+8.;\n      scol=(scol*dif+fr*sky(reflect(rd,N),L))*shad;\n      C.xyz*=scol;\n      ro+=rd*(t-px*t);rd=reflect(rd,N);px*=2.;t=px*t*2.;\n    }\n  }\n  return C*sky(rd,L);\n}\nvec3 path(float t){t*=.1;return vec3(sin(t)+.1,2.2+sin(t)*.1,cos(t));}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n vec3 ro=path(iTime),fw=normalize(path(iTime+0.5)-ro);\n //vec3 ro=vec3(1,2,0),fw=vec3(0,0,1);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,1.0));\n fragColor=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 6.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 5.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= -1.0; \n  else if(n<4.0)n= 0.0; \n  else if(n<5.0)n= -5.0; \n  else if(n<6.0)n= -4.0; \n  else if(n<7.0)n= 4.0; \n  else n=0.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(200.0,0.75,1.5,0.1,2.501,0.001);//silly fm synth instruments \n //instr sitar=instr(30.0,1.,4.0,0.0,0.2525,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,epiano)*n0.y;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+65.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*8.0; \n       a+=I(n2.x+43.0,time,t2,bass)*4.0; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 88, 88, 354], [356, 356, 385, 395, 531], [549, 549, 575, 575, 788], [800, 800, 826, 826, 899], [901, 901, 950, 950, 1101], [1102, 1102, 1131, 1131, 2408], [2409, 2409, 2428, 2428, 2479], [2480, 2480, 2501, 2501, 2599], [2600, 2600, 2657, 2657, 2898]], "test": "untested"}
{"id": "sdfcRs", "name": "Crystal Planet", "author": "eiffie", "description": "\"Realtime\" gi", "tags": ["gi"], "likes": 7, "viewed": 473, "published": 3, "date": "1642519807", "time_retrieved": "2024-07-30T17:08:52.632308", "image_code": "void mainImage( out vec4 O, in vec2 U ) {\n  O=texture(iChannel0,U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rez iResolution\n#define TAU 6.283\n#define maxDepth 30.0\n//trying to mimick a packet of photons\nconst float fov = 2.5,blurAmount = 0.007;\nconst int RaySteps=64, maxBounces=6;\nconst float FudgeFactor=0.9;\nconst vec3 ior=vec3(1.0,1.52,1.0/1.52);//water=1.33,glass=1.52,diamond=2.42\n\n//struct material {vec3 color;float refrRefl,difExp,spec,specExp;};\n\nvec4 orbitTrap;  \nfloat DE(vec3 z0){\n  vec4 z = vec4(z0,1.1);\n  for (int n = 0; n < 5; n++) {\n    z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n    z*=-2./clamp(dot(z.xyz,z.xyz),1.,4.);\n    z.y+=2.05; \n  }\n  orbitTrap=z;z=abs(z);\n  return (max(z.x,max(z.y,z.z))-2.667)/z.w;\n}\n\nvec3 getBackground( in vec3 rd ){\n vec3 sunDir=normalize(vec3(0.3,0.9,-0.5)), sunColor=vec3(1.0,0.9,0.6);\n vec3 lit=vec3(0);\n for(float i=0.;i<5.;i++){\n   vec2 p=vec2(sin(i+iTime),sin(i+1.+iTime));\n   float d=length(p-rd.xz);\n   lit+=100.*vec3(p,sin(i+2.))*exp(-d*20.);\n }\n return lit+sunColor*.4+rd*0.25+sunColor*(max(0.0,dot(rd,sunDir))+30.*pow(abs(dot(rd,sunDir)),40.0));\n}\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\n\nvec3 scene(vec3 ro, vec3 rd) \n{// find color and depth of scene\n vec3 fcol=vec3(1.0);//color frequency mask\n vec2 rnd=rand2();//a couple random numbers\n float HitDistance=1.0/rez.x;\n float d,t=rnd.x*HitDistance*10.0,side=sign(DE(ro+t*rd));//dist to obj, total ray len, len to first obj, -inside or +outside of obj\n int i,iHitCount=0;\n for(i=0; i<RaySteps && t<maxDepth; i++ ){// march loop\n  t+=d=DE(ro+t*rd)*side*FudgeFactor;//march\n  if(abs(d)<HitDistance*t){//hit\n   t+=d=DE(ro+t*rd)*side;//move close to the hit point without fudging\n   ro+=rd*t;// advance ray position to hit point\n   vec2 ve=vec2(HitDistance*0.1,0.0);\n   vec3 nor = side*normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy),\n    -DE(ro-ve.yxy)+DE(ro+ve.yxy),\n    -DE(ro-ve.yyx)+DE(ro+ve.yyx)));// get the surface normal\n   if(nor!=nor)nor=-rd;//is this !isNum(nor) which only happens when nor~/=-rd!!\n   rnd=rand2();//a couple more random numbers\n   vec3 refl=reflect(rd,nor),newRay=refl;//setting up for a new ray direction and defaulting to a reflection\n   vec3 refr=refract(rd,nor,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n   vec2 ca=vec2(dot(nor,rd),dot(nor,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n   if(rnd.y+rnd.x>pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)){newRay=refr;nor=-nor;}\n   rd=newRay;//powDir(nor,newRay,m.difExp);//redirect the ray\n   vec3 col=abs(sin(3.*orbitTrap.rgb/orbitTrap.w))*.5+.5;\n   fcol*=col;\n   t=max(d*side*5.0,HitDistance);//hopefully pushs thru the surface\n   if(iHitCount++>maxBounces || dot(fcol,fcol)<0.01)break;\n   side=sign(DE(ro+t*rd));//keep track of which side you are on\n  }\n }\n return clamp(fcol*getBackground(rd),0.0,1.0);//light the scene\n} \nmat3 lookat(vec3 fw){\n  fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw); \n}\nvoid Setup(float t, out vec3 eye, out vec3 tgt){\n  t*=.5;t+=sin(t);t*=.1;\n  eye=vec3(sin(t),0.,cos(t))*(1.+t*.5);eye.y=2.2;\n  tgt=eye+normalize(vec3(eye.x,-1.5,eye.y))*.25;\n}\nvoid mainImage(out vec4 O, in vec2 U) {\n randv2=fract(cos(U.xy+U.yx*vec2(113.0,107.0)+vec2(iTime+float(iFrame)*0.1))*4231.8413);\n vec3 eye,tgt;\n if(iFrame<2)O=vec4(0);else O=texture(iChannel0,U/rez.xy)*0.9;\n Setup(iTime,eye,tgt);tgt-=eye;\n float focusDistance=length(tgt);\n mat3 looky=lookat(tgt);\n vec2 pxl=(-rez.xy+2.0*(U.xy+rand2()))/rez.y;\n vec3 er = normalize( vec3( pxl.xy, fov ) );\n vec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n vec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n O+=vec4(scene(eye+looky*go,looky*normalize(er+gd)),1.0)*0.1;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define bps 8.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 6.0; \n  else if(n<2.0)n= 5.0; \n  else if(n<3.0)n= -5.0; \n  else if(n<4.0)n= -6.0; \n  else if(n<5.0)n= 6.0; \n  else if(n<6.0)n= 5.0; \n  else if(n<7.0)n= 6.0; \n  else n=0.0;\n  return vec2(n,r); \n}\n\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n  if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.1,2.5,0.1,1.501,0.001);//silly fm synth instruments \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+84.0,time,t0,epiano)*n0.y*.5;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+75.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+72.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+60.0,time,t2,epiano)*n2.y; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/64.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 84]], "test": "untested"}
{"id": "7sXcRs", "name": "Party Box II", "author": "eiffie", "description": "Rainy day shader #1 of 6", "tags": ["music"], "likes": 12, "viewed": 347, "published": 3, "date": "1642519455", "time_retrieved": "2024-07-30T17:08:53.502980", "image_code": "#define time iTime\n#define rez iResolution\nvec3 mcol=vec3(0.0),blm=vec3(0.0);\nfloat dL=1000.,tim;\nfloat DE(vec3 p0){\n  vec4 p=vec4(abs(mod(p0,4.)-2.)-1.,1.1);\n  vec2 c=vec2(-.4,-.76);\n  for(int n=0;n<4;n++){\n    p.xy=abs(p.xy+1.0)-1.0;\n    p*=2.0/clamp(dot(p.xyz,p.xyz),0.25,1.0);\n    if(p.y>p.z)p.yz=p.zy;\n    if(p.x>p.y)p.xy=p.yx;\n    p.yz+=c;\n    if(n==2){\n      float d=length(p.xyz/p.w);\n      if(d<dL)dL=d;\n      blm+=abs(sin(p0))/(1.+dL*dL*20000.);\n    }\n    if(n==3 && mcol.x>0.0)mcol+=vec3(1.)+30.*abs(p.xyz)/p.w;\n  }\n  return (abs(p.z)-1.0)/p.w;\n}\nfloat DEL(vec3 p0){\n  vec4 p=vec4(abs(mod(p0,4.)-2.)-1.,1.1);\n  vec2 c=vec2(-.4,-.76);\n  for(int n=0;n<3;n++){\n    p.xy=abs(p.xy+1.0)-1.0;\n    p*=2.0/clamp(dot(p.xyz,p.xyz),0.25,1.0);\n    if(p.y>p.z)p.yz=p.zy;\n    if(p.x>p.y)p.xy=p.yx;\n    p.yz+=c;\n  }\n  return length((p.xyz+sin(p0+vec3(tim,.8*tim+1.,.3*tim+2.))*2.)/p.w);\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 lightDir(vec3 p, float d){//modified dr2 for light direction\n  vec2 e=vec2(d,-d);vec4 v=vec4(DEL(p+e.xxx),DEL(p+e.xyy),DEL(p+e.yxy),DEL(p+e.yyx));\n  return -normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  return rd*.1+0.4*dot(rd,L)+0.6;\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd,in float dL){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n  if(d>dL)break;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro),d,px=clamp(cos(iTime*.5)*50.,.5,50.)/rez.x;\n  t=min(t,dL)*rnd;\n  for(int i=0;i<64;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>50.0 || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 col=sky(rd,L);\n  if(d<px*t*5.0){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);\n    vec3 scol=mcol*0.25;\n    d=DEL(so);\n    L=lightDir(so,d);\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    float shad=ShadAO(so,L,d*.5);\n    col=(scol*dif/(1.+dL*dL)+fr*sky(reflect(rd,N),L))*shad;\n  }\n  return (col+blm)/t;\n}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvec3 path(float t){t*=.5;\n  return vec3(t,sin(t*5.)*.1,cos(t)*5.); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);tim=time*5.;\n vec3 ro=path(iTime),fw=normalize(path(iTime+0.001)+vec3(0,.002,0)-ro);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,1.0));\n fragColor=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 8.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= -2.0; \n  else if(n<2.0)n= 0.0; \n  else if(n<3.0)n= 2.0; \n  else if(n<4.0)n= -4.0; \n  else if(n<5.0)n= 6.0; \n  else if(n<6.0)n= -5.0; \n  else if(n<7.0)n= -3.0; \n  else n=6.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n  float n2=mod(note,12.); \n  if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//pentatonic minor\n  return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr sitar=instr(30.0,0.1,4.0,0.0,0.2525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*.5;\n   if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+65.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*8.0; \n       a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 116, 116, 557], [558, 558, 577, 577, 883], [884, 884, 913, 923, 1059], [1060, 1060, 1091, 1125, 1266], [1267, 1267, 1293, 1293, 1329], [1341, 1341, 1367, 1367, 1440], [1442, 1442, 1491, 1491, 1642], [1643, 1643, 1672, 1672, 2271], [2272, 2272, 2293, 2293, 2391], [2392, 2392, 2411, 2411, 2461], [2462, 2462, 2519, 2519, 2750]], "test": "untested"}
{"id": "7dXczl", "name": "simple 4 color gradient shader", "author": "zerocold64", "description": "simple linear 4 color gradient shader based on https://www.shadertoy.com/user/sablezubaja three color variant\ni also implemented this for my unity shader to colorize my VFX-sprites in particle system via custom data stream", "tags": ["color", "gradient"], "likes": 7, "viewed": 594, "published": 3, "date": "1642516617", "time_retrieved": "2024-07-30T17:08:54.424517", "image_code": "vec4 firstColor = vec4(1.0,1.0,1.0,1.0);\nvec4 secondColor = vec4(0.25,0.5,1,1.0);\nvec4 thirdColor = vec4(0.0,0.0,0.5,1.0);\nvec4 fourthColor = vec4(0.0,0.0,0.0,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    \n    float h = 0.333;\n    vec4 col1 = mix(mix(firstColor, secondColor, xy.x/h), mix(secondColor, thirdColor, (xy.x - h)/(1.0 - h*2.0)), step(h, xy.x));  \n    vec4 col2 = mix(mix(secondColor, thirdColor, (xy.x - h)/(1.0 - h*2.0)), mix(thirdColor, fourthColor, (xy.x - h*2.0)/(1.0-h*2.0)), step(h*2.0, xy.x));\n    vec4 col = mix(col1,col2,step(h*2.0,xy.x));\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 223, 223, 651]], "test": "untested"}
{"id": "fdfyRs", "name": "Persistence of Vision", "author": "Spi3lot", "description": "Persistence of vision simulated", "tags": ["vision", "persistence"], "likes": 3, "viewed": 227, "published": 3, "date": "1642509551", "time_retrieved": "2024-07-30T17:08:55.455759", "image_code": "#define PI 3.1415926535\n#define TAU 2.0 * PI\n\n\nstruct Sector\n{\n    float radius;\n    float startAngle;\n    float stopAngle;\n};\n\n// .r (rgba) -> radius\n// .t (stpq) -> theta\nvec2 polar(float r, float theta)\n{\n    return vec2(r, theta);\n}\n\nvec2 polar(vec2 cartesian)\n{\n    return polar(length(cartesian), PI + atan(cartesian.y, cartesian.x));\n}\n\n\nfloat normalizeAngle(float angle)\n{\n    return mod(angle, TAU);\n}\n\nfloat pointInsideSector(vec2 pointCartesian, Sector sector)\n{\n    vec2 pointPolar = polar(pointCartesian);\n    \n    if (pointPolar.r >= sector.radius)\n        return 0.0;\n    \n    float startAngle = normalizeAngle(sector.startAngle);\n    float stopAngle = normalizeAngle(sector.stopAngle);\n\n    if (startAngle > stopAngle) {\n        stopAngle += TAU;\n    \n        if (startAngle > pointPolar.t) //&& stopAngle > pointPolar.t)  // not necessary)\n            pointPolar.t += TAU;\n    }\n\n    // (pointPolar.t < startAngle) not necessary if radar/persistence mode is on\n    if (pointPolar.t >= stopAngle || pointPolar.t < startAngle)\n        return 0.0;\n\n    // Linear\n    //return (pointPolar.t - startAngle) / (stopAngle - startAngle);\n    \n    // Smooth\n    return smoothstep(startAngle, stopAngle, pointPolar.t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //float iTimeOld = iTime - iTimeDelta;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 point = fragCoord - 0.5 * iResolution.xy;\n    \n    float maxi = max(iResolution.x, iResolution.y);\n    \n    float radius = maxi;  // to cover the entire screen\n    float angle = TAU / 3.0;\n    float speed = 20.0;  // radians / second\n    \n    /* * /\n    float then = iTimeOld * speed;\n    float now = iTime * speed;\n    /* */\n    \n    float then = iTime * speed;\n    float now = then + angle;\n    \n    Sector sector = Sector(radius, then, now);\n    \n    float alpha = pointInsideSector(point, sector);\n    \n    // I could also blit a black image with alpha 0.01 or some\n    // every frame to simulate the fade out\n    \n    // Output to screen\n    fragColor = alpha * texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 173, 207, 207, 236], [238, 238, 266, 266, 342], [345, 345, 380, 380, 410], [412, 412, 473, 473, 1226], [1229, 1229, 1286, 1334, 2083]], "test": "untested"}
{"id": "fdXyzs", "name": "", "author": "chentao", "description": "", "tags": ["2d"], "likes": 0, "viewed": 218, "published": 3, "date": "1642508488", "time_retrieved": "2024-07-30T17:08:56.219717", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float up = step(200., fragCoord.x);\n    float down = step(fragCoord.x, 400.0 + iTime);\n    float color = up * down;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(color,color,color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 427]], "test": "untested"}
{"id": "NdfcRs", "name": "2D Pulse", "author": "ersh", "description": "2D Pulse", "tags": ["2d"], "likes": 2, "viewed": 286, "published": 3, "date": "1642508341", "time_retrieved": "2024-07-30T17:08:56.991653", "image_code": "//https://graphtoy.com/?f1(x,t)=sin(x+t)*sin(x/5-t*4)&v1=false&f2(x,t)=f1(x/2,t/2)*1.3-f1(x-1,t-5)&v2=false&f3(x,t)=f2(x/2,t/2)*1.3-f1(x-1,t-5)&v3=false&f4(x,t)=f3(x,t)*(0.5+f1(x-3,t*3-5)/2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,21.258732000000105\nfloat f1(float x, float t) { return sin(x+t)*sin(x/5.-t*4.); }\nfloat f2(float x, float t) { return f1(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f3(float x, float t) { return f2(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f4(float x, float t) { return f3(x,t)*(0.5+f1(x/3.4-3.,t*2.-5.)/2.); }\n\nvec3 col(float x) {\n  x /= 4.;\n  return x > 0. ? vec3(\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n   ) * 3.\n   :  vec3(\n      clamp(-x-2./3., 0., 1./3.),\n      clamp(-x-1./3., 0., 1./3.),\n      clamp(-x, 0., 1./3.)\n   ) * 3.\n   ;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uvu = I/max(iResolution.x, iResolution.y) * 10.;\n    O = vec4(col(f4(uvu.x, iTime) + f4(uvu.y + 42.123, iTime/1.321+31.32)), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 275, 303, 303, 337], [338, 338, 366, 366, 408], [409, 409, 437, 437, 479], [480, 480, 508, 508, 556], [558, 558, 577, 577, 838], [840, 840, 881, 881, 1021]], "test": "untested"}
{"id": "ssXyzX", "name": "Good old fire", "author": "ersh", "description": "Good old fire effect", "tags": ["fire"], "likes": 7, "viewed": 313, "published": 3, "date": "1642506993", "time_retrieved": "2024-07-30T17:08:57.795503", "image_code": "vec3 col(float x) {\n  return vec3(\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n   ) * 3.;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O = vec4(col(texelFetch(iChannel0, ivec2(I), 0).r), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//https://graphtoy.com/?f1(x,t)=sin(x+t)*sin(x/5-t*4)&v1=false&f2(x,t)=f1(x/2,t/2)*1.3-f1(x-1,t-5)&v2=false&f3(x,t)=f2(x/2,t/2)*1.3-f1(x-1,t-5)&v3=false&f4(x,t)=f3(x,t)*(0.5+f1(x-3,t*3-5)/2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,21.258732000000105\nfloat f1(float x, float t) { return sin(x+t)*sin(x/5.-t*4.); }\nfloat f2(float x, float t) { return f1(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f3(float x, float t) { return f2(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f4(float x, float t) { return f3(x,t)*(0.5+f1(x/3.4-3.,t*2.-5.)/2.); }\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O = vec4(0.0);\n    if (I.y < 3.5) {\n        O.a = f4(I.x/5., iTime*3.) + 0.6 - pow(I.x/iResolution.x-0.5, 2.)*10.+0.5;\n        return;\n    }\n    vec2 sh;\n    for (sh.y = -8.; sh.y < 1.5; sh.y+=1.) for (sh.x = -3.; sh.x < 3.5; sh.x+=1.) {\n        vec4 pt1 = texture(iChannel0, (I + sh + vec2(sin(I.y/10.+I.x/100.-iTime*3.),0))/iResolution.xy);\n        O.r += pt1.r + pt1.a;\n    }\n    O.r = O.r / 70. - 0.03;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 139], [141, 141, 182, 182, 244]], "test": "untested"}
{"id": "stcGDf", "name": "Fork Deform - h gchipunov 154", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation"], "likes": 2, "viewed": 226, "published": 3, "date": "1642494492", "time_retrieved": "2024-07-30T17:08:58.594368", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n\n  vec2 uv;\n  uv.x = 0.2*iTime + (r1-r2)*0.25;\n  uv.y = asin(sin(a1-a2))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-5.0*r1) + exp(-5.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(inversesqrt (col+w) -(col+w) / 1.1 ,1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcGDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 774]], "test": "untested"}
{"id": "sssyRj", "name": "WTFForest", "author": "antoinefortin", "description": "dfdfd", "tags": ["fdfd"], "likes": 5, "viewed": 260, "published": 3, "date": "1642480217", "time_retrieved": "2024-07-30T17:08:59.408192", "image_code": "mat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s,s,c);\n    \n    \n    \n}\n\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\n/* SDF */\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos)\n{\n\n    /* DICK */\n    \n    \n\tfloat x =  pos.y + (texture(iChannel0, pos.xz * 0.009f  ).x * 2.5) ;\n    return x * .5;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel1, p * 0.055 * sin(p.y)).x ;    \n    float b = (sin(p.x * 2.))  ;\n    \n    b*=  ba * sin( cos( 2.)) * abs(sin(1.) + 1.25);\n    b *= b - abs(sin(iTime));\n    return -b - 1.2;\n}\n\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat leaf(vec3 pos)\n{\n    float r = 1.0f;\n    vec3 q = pos;\n    r = sdOctahedron(pos + vec3(0.0f, -4.4f, 0.0f), 1.0);\n    pos = abs(pos);\n    pos.xy = rotate(pos.xy, .2);\n    float r2 = sdOctahedron(pos + vec3(0.0f, -4.4f, 0.0f), 1.0);\n    \n    \n    pos.xz = rotate(pos.xz, .5);\n    float r3 = sdOctahedron(pos + vec3(0.5f, -4.4f, -0.2f), .75);\n    \n    pos.y -= 1.85;\n    pos.yz = rotate(pos.yz, 5.);\n    float r4 = sdOctahedron(pos + vec3(-.5f, -1.4f, 1.f), .75);\n    \n    \n    \n    pos = q;\n    \n    \n    \n    return min(r, min(r2, min(r3, r4)));\n}\n\nfloat trunk(vec3 pos)\n{\n    vec3 q = pos;\n    float res = 1.0f;\n    \n    q.xz *= rot(q.y * 1.15);\n    \n    res = sdBox(q, vec3(.24,3.75, .25));\n    \n    q = pos;\n    q = abs(pos);\n    q.z += .15;\n      q.xz = rotate(q.xz, 0.015); \n    \n    q.xy *= rot(.85);\n    \n     \n    q.xz *= rot(q.y * ( .15));\n    \n    \n    \n  \n    \n    float t2 = sdBox(q + vec3(1.5, -2., 0.0), vec3(.014,1.22, .125));\n    \n    res = min(res, t2);\n    \n    return res * .5;\n}\n\n/* Pine tree */\n\nfloat pineLeaf()\n{\n    return 0.0f;\n}\n\nvec2 map(vec3 pos)\n{\n    \n    float theFloor = sdPlane(pos);\n    \n    \n    float box = sdBox(pos, vec3(1.));\n    float sphere = sdSphere(pos + vec3(0.0, -1., 0.), 1.0);\n\t\n\n    \n    vec2 res =     vec2(theFloor,       2.0 /*Object ID*/);\n     \n     \n    pos.x = mod(pos.x+ 5., 10.) -5.;\n    pos.z += sin(iTime);\n    pos.z = mod(pos.z+ 7.5f, 15.0f) -7.5f;\n    \n    float trunk = trunk(pos);\n    float leaf= leaf(pos);\n    \n    res = opu(res, vec2(trunk,     4.0 /*Object ID*/));\n    res = opu(res, vec2(leaf,     5.0 /*Object ID*/));\n    \n    \n//    res = opu(res, vec2(arms, 3.));\n    return res;\n}\n\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\n    float t = 0.0;\n    float id = -20.;\n\tfloat farClippingPlane = 120.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        \n    \tvec3 pos = ro + t * rd;\n        float h = map(pos).x;\n        id = map(pos).y;\n        \n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        if(t > farClippingPlane) break;\n        \n    }\n    \n    if(t > farClippingPlane) t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x\n    \t\t\t\t));\n}\n\nvoid resetToZero(inout vec3 r)\n{\n\tr = vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tvec3 ro = vec3(0. + iTime, 7.55 ,-4.5);\n\t//vec3 rd = normalize(vec3(uv.x, uv.y - .2,1.)); \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(m.x * 12.);\n\tvec3 rd = R(uv, ro, vec3(0,.5,iTime), .7);\n    \n    \n\tvec3 col = vec3(sin(uv.x * ro.y), cos(uv.y * ro.y), cos(uv.y + ro.x));\n\t\n\tvec3 ttt = texture(iChannel1, uv * sin(ro.y)).rgb;\n    col *= ttt;\n    \n\tfloat hitDistance = castRay(ro, rd).x;\n    float objectId = castRay(ro, rd).y;\n    \n    vec3 unfinishedSky;\n    \n\n    \n    \n    if(hitDistance > 0.)\n    {\n       \tvec3 debugColor = vec3(1.);\n        vec3 pos = ro + hitDistance * rd;\n        vec3 normalWS = calcNormal(pos);\n\n        /* Global Lighting section */\n        \n        // Sky\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n\t\tfloat skyMovement = .5;\n        vec3 skyColFactor = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n\t\t\n        // Basic lighting\n        vec3 sunPos = normalize(vec3(6.5, 12.4, 5.52));\n        vec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(normalWS, sunPos), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + normalWS * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(normalWS,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n        \n        //col = skyColFactor;\n        /*End of Global Lighting section */\n        \n        \n        bool materialSystem = true;\n        \n        if(materialSystem)\n        {\n            float blendingFactor = .5;\n            \n            if(objectId == 2.0)\n            {\n                col *= vec3(.21, .25, .15) * sundif * sun_sha;\n            }\n            \n\t\t\t// Sphere\n        \tif(objectId == 4.0) \n        \t{\n            //165,42,42\n            //rgb(110, 38, 14)\n                col = vec3(110.0f / 255.0f, 38.0f / 255.0f, 14.0f / 255.0f) *sundif;\n                col += vec3(.12 * sin(pos.x), .12, .12);\n        \t} \n            \n            if(objectId == 5.0) \n        \t{\n            //165,42,42\n            //rgb(110, 38, 14)\n            \n                for(int i = 0; i < 4; i++)\n                {\n                col += vec3(0.0f, .1 * sin(float(i)), .0f);\n                }\n                \n                //col += vec3(sin(pos).x, sin(pos).y + 1.5, .0f);\n        \t} \n            \n            \n        }\n\n        \n        col = col;\n       \n        /*\n       \tvec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n\t\tcastRay(ro, rd).x */    \n\t}\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 108], [110, 110, 146, 146, 236], [238, 238, 257, 257, 333], [336, 336, 378, 378, 573], [577, 587, 639, 639, 760], [762, 762, 797, 797, 824], [826, 826, 851, 867, 968], [969, 969, 1005, 1005, 1278], [1281, 1281, 1312, 1312, 1399], [1402, 1402, 1430, 1430, 1465], [1467, 1467, 1514, 1648, 1983], [1985, 1985, 2023, 2023, 2303], [2306, 2306, 2323, 2323, 2532], [2537, 2537, 2574, 2574, 2657], [2660, 2660, 2682, 2682, 3212], [3214, 3214, 3237, 3237, 3663], [3682, 3682, 3700, 3700, 3719], [3721, 3721, 3741, 3741, 4318], [4321, 4321, 4353, 4353, 4777], [4779, 4779, 4806, 4806, 5028], [5030, 5030, 5062, 5062, 5080], [5082, 5082, 5139, 5139, 8101]], "test": "untested"}
{"id": "7slczX", "name": "diamond transformer", "author": "xnio94", "description": "simple diamonds sdf", "tags": ["raymarching", "ray", "sdf", "diamond"], "likes": 5, "viewed": 192, "published": 3, "date": "1642476464", "time_retrieved": "2024-07-30T17:09:00.428464", "image_code": "#define P 3.14159265359\n#define MAXD 100.\nfloat t;\n//y rotation\nvec3 rot(in vec3 p, in float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\nfloat diamend( vec3 p)\n{\n\tfloat d=-MAXD;\n    float k=floor(t) + pow(fract(t),9.); //continuous transformations\n    //k=floor(t); //discrete transformations\n    //k=1.;\n    float t1 = k*P/16.,  t2=t1*2.,  t3=t1*3.,  t4=t1*4.;\n    \n    vec3 q;\n    for(float i=0.;i<4.;i++)\n    {\n        q=rot(p,t3-i*t2);\n        q.xz=abs(q.xz);\n        d=max(dot(q, vec3(4.,5.,4.)*.1324)-.804,d);//cut 4 top planes                \n        q.y*=-1.;\n        d=max(dot(q, vec3(5.,7.,5.)*.1005)-.762,d);//and 4 bottom\n    }   \n    for(float i=0.;i<2.;i++)//more plans cutting\n    {\n        q=rot(p, i*t4);\n        d=max(dot(abs(q), vec3(2.,3.,2.)*.2425)-0.5*1.5,d);\n        q=rot(q,-t2);\n        q=vec3(abs(q.x),q.y,abs(q.z));\n        d=max(dot(q, vec3(1.,2.,1.)*.4082)-.7,d);\n    }\n\td=max(p.y-.466,d); //flatten the top\n\treturn d;\n}\nfloat map(vec3 p)\n{\n    p = rot(p,t);\n    return diamend(p);\n\n}\n//check this https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n//from https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tt = iTime;\n\n    vec3 ta = vec3(0.);\n    float r =2.5;\n    \n    vec3 ro = ta + vec3(r*cos(0.1*t + 7.0*mo.x), .1 + 2.0*mo.y, r*sin(0.1*t + 7.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 tot = vec3(0.0);\n    vec3 rd = ca * normalize( vec3(uv,2.) );\n\t\n\tfloat dd = 0.0;\n\tvec3 p;\n    //simple ray marching\n\tfor(float i = 0.; i < 64.; i++) {\n\t\tp = ro + rd * dd;\n\t\tfloat d = map(p);\n        dd += d;\n\t\tif (d < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n    dd = min(6.0, dd);\n\tvec3 n = calcNormal(p);\n    float a = max(0.0,  dot( n ,  normalize(vec3(0.7, 3., 0.))  )); //lights\n    float b = max(0.0,  dot( n , -normalize(vec3(0.7, 2., -.2))   ));//lights\n    fragColor = vec4(0.,0., b*b + a*a , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 64, 97, 97, 188], [189, 189, 213, 213, 1001], [1002, 1002, 1021, 1021, 1065], [1066, 1122, 1152, 1152, 1411], [1412, 1457, 1509, 1509, 1686], [1687, 1687, 1744, 1744, 2541]], "test": "untested"}
{"id": "sslyRf", "name": "Fork PinkWaves violetfore 430", "author": "violetforest", "description": "PINK WAVEs", "tags": ["pink"], "likes": 4, "viewed": 274, "published": 3, "date": "1642472658", "time_retrieved": "2024-07-30T17:09:01.384907", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat range(float val, float mi, float ma) {\n    return val * (ma - mi) + mi;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat t = iTime / 5.;\n    \n\t// main code, *original shader by: 'Plasma' by Viktor Korsun (2011)\n\tfloat x = p.x;\n\tfloat y = p.y;\n    \n\tfloat mov0 = x+y+cos(sin(t)*2.0)*100.+sin(x/100.)*1000.;\n\tfloat mov1 = y / 0.3 +  t;\n\tfloat mov2 = x / 0.2;\n    \n    float c1 = abs(sin(mov1+t)/2.+mov2/2.-mov1-mov2+t);\n    float c2 = abs(sin(c1+sin(mov0/1000.+t)+sin(y/40.+t)+sin((x+y)/100.)*3.));\n\tfloat c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));\n    \n    vec3 col = hsv2rgb(vec3(range(c2, 0.85, 0.95), range(c3, 0.5, 0.55), range(c3, 1., 0.75)));\n    \n    \n\tfragColor = vec4(col, 1.);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [192, 192, 236, 236, 271], [272, 272, 329, 329, 976]], "test": "untested"}
{"id": "sdscRX", "name": "Rocket Tycoon", "author": "wyatt", "description": "Rocket Launch Simulation", "tags": ["rocket"], "likes": 33, "viewed": 496, "published": 3, "date": "1642468803", "time_retrieved": "2024-07-30T17:09:02.318411", "image_code": "Main {\n    Q = A(U);\n    Q = .7+.3*sin(2.*Q.z+vec4(1,2,3,4))-.5*Q.w;\n    \n    vec4 \n        n = C(U+vec2(0,1)),\n        e = C(U+vec2(1,0)),\n        s = C(U-vec2(0,1)),\n        w = C(U-vec2(1,0));\n    Q *= 1.+atan(2.*(n.w-s.w+e.z-w.z));\n    get_rocket\n    vec2 u = U;\n    for (float i = 0.; i < 10.; i++)\n        u -= 10.*C(u).zw;\n    \n    if (a.y>RH.y*R.y) u.y += a.y-(RH*R).y;\n    u *= .1;\n    vec2 f = .5*fwidth(u);\n    Q -= .1*smoothstep(f.x,0.,abs(sin(u.x)));\n    Q -= .1*smoothstep(f.y,0.,abs(sin(u.y)));\n    Q -= .1*smoothstep(f.x,0.,abs(sin(.5*u.x)));\n    Q -= .1*smoothstep(f.y,0.,abs(sin(.5*u.y)));\n    Q -= .1*smoothstep(f.x,0.,abs(sin(.25*u.x)));\n    Q -= .1*smoothstep(f.y,0.,abs(sin(.25*u.y)));\n    Q -= .1*smoothstep(.25*f.x,0.,abs(sin(.125*u.x)));\n    Q -= .1*smoothstep(.25*f.y,0.,abs(sin(.125*u.y)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) \n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ve(a) vec2(cos(a),sin(a))\n#define RH (vec2(.5+.05*da.x,.66+.05*da.y))\n// Size of Bottle Rocket :\n#define S vec2(30.,140.)\n// Pressure of Engine :\n#define ENGINE 1.\n// Mass of Rocket :\n#define MASS 25.\n#define N (S.y*2.)\n#define pi 3.14159265359\n#define get_rocket vec4 a = B(vec2(0,0)+.5);vec4 da = B(vec2(1,0)+.5);\n#define loop_rocket for (float i = -N; i < N; i++) {float y = 2.*i/N+1.;vec2 v1 = vec2(S.x*(-1.+(1.-exp(-y*y))),i/N*S.y)*ei(a.z); vec2 v2 = vec2(S.x*(1.-(1.-exp(-y*y))),i/N*S.y)*ei(a.z);\nvec4 rocket (vec2 U, vec4 a, vec4 da) {\n    U -= a.xy;\n    vec2 u = abs(U*ei(-a.z))-S;\n    if (max(u.x,u.y)>4.) return vec4(0);\n    float d = 1e9;\n    vec2 v = vec2(0);\n    loop_rocket\n        float l1 = length(U-v1);\n        if (l1<d) {\n            d = l1;\n            v = da.xy + vec2(-v1.y,v1.x)*da.z;\n        }\n        float l2 = length(U-v2);\n        if (l2<d) {\n            d = l2;\n            v = da.xy + vec2(-v2.y,v2.x)*da.z;\n        }\n    }\n    return vec4(v,0,1)*smoothstep(2.5,1.5,abs(d));\n}", "buffer_a_code": "Main {\n    get_rocket\n    if (a.y>RH.y*R.y) U += da.xy, a.y = (RH*R).y;\n    vec4 c = C(U);\n    Q = A(U-c.xy);\n    Q.xy -= .5*C(U-c.xy).zw;\n    if (length(U-a.xy+vec2(0,.5*S.y)*ei(a.z))<15.) Q.z = ENGINE, Q.w = 1.;\n    vec4 v = rocket(U,a,da);\n    Q.xyw = mix(Q.xyw,vec3(v.xy,0),v.w);\n    if (U.y<R.y&&(U.x<1.||R.x-U.x<1.)) Q.xy *= 0.;\n    if (U.y<1.) Q.xy *= 0.;\n    if (R.y-U.y<1.) Q *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U);\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    Q.z -= .5*(e.x-w.x+n.y-s.y);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = A(U);\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0)),\n        m = 0.25*(n+e+s+w);\n    Q.xy = m.xy;\n    Q.zw = vec2(e.z-w.z,n.z-s.z);\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    if (U.x>2.||U.y>2.) discard;\n    \n    get_rocket\n    \n    if (iFrame < 1) a = vec4(.5*R.x,S.y+4.,0,0);\n    vec4 f = vec4(0);\n    \n    loop_rocket\n        if (i<-.5*N) continue;\n        vec2 u = a.xy;\n        if (u.y>RH.y*R.y) u.y = (RH*R).y;\n        {\n            vec2 im = -.1*A(u+v1).zw/N;\n            if (length(im)>0.&&length(v1)>0.) {\n                f.z -= .01*dot(v1,vec2(-im.y,im.x));\n                f.xy += im*abs(dot(normalize(v1),normalize(im)));\n            }\n        }\n        {\n            vec2 im = -.1*A(u+v2).zw/N;\n            if (length(im)>0.&&length(v2)>0.) {\n                f.z -= .01*dot(v2,vec2(-im.y,im.x));\n                f.xy += im*abs(dot(normalize(v2),normalize(im)));\n            }\n        }\n    }\n    da += f/MASS;\n    da.y -= .1/R.y;\n    a += da;\n    \n    \n    if (U.x<1.) Q = a;\n    else        Q = da;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdscRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7slcRX", "name": "city fly through", "author": "leon", "description": "flying and blinking", "tags": ["city"], "likes": 21, "viewed": 629, "published": 3, "date": "1642464333", "time_retrieved": "2024-07-30T17:09:03.361621", "image_code": "// \"are we arrived yet?\"\n// city fly through with blinking rectangles\n// leon denise 2022 01 18\n    \n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// domain repetition\n#define repeat(p,r) (mod(p+r/2.,r)-r/2.)\n\n// hash by 4tfyW4 and Inigo Quilez https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x ) {\n    uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// geometry\nvec3 plocal;\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float dist = 100.;\n    float tt = iTime * .02; // speed\n    p.z += tt; // translate\n    float cell = 1.; // size of repetition\n    float pz = floor(p.z/cell); // index of cell in line\n    p.z = repeat(p.z, cell); // repeat space z\n    p.z *= mix(-1., 1., step(0., p.z)); // mirror z per cell in line\n    float t = floor(pp.z/cell); // rotation\n    const float count = 9.; // number of shapes\n    float a = 1.; // amplitude of falloff\n    for (float i = 0.; i < count; ++i) { // kifing\n        p.xz *= rot(t/a); // twist\n        p = abs(p)-.15*a; // fold space\n        dist = min(dist, max(p.x, max(p.y, p.z))); // space\n        a /= 1.7; // falloff curve\n    }\n    plocal = p; // for colors\n    dist = -dist; // invert volume\n    dist = max(dist, -(max(abs(pp.x)-.005, abs(pp.y)-.01))); // crop tunnel\n    return dist;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    // coodinates\n    vec2 pixel = (coordinate - iResolution.xy / 2.) / iResolution.y;\n    vec3 eye = vec3(0,.002,-1.);\n    vec3 ray = normalize(vec3(pixel, 1.+.5*sin(iTime/3.)));\n    ray.yz *= rot(-cos(iTime/4.)*.2);\n    ray.xz *= rot(sin(iTime/5.)*.2);\n    vec3 pos = eye;\n    vec3 rng = hash(uvec3(coordinate, mod(iTime, 1000.)*60.));\n    \n    // raymarch\n    const float count = 30.;\n    float i = 0.;\n    for (i = count; i > 0.; --i) {\n        float dist = map(pos);\n        if (dist < .0001) break;\n        dist *= .9 + .1 * rng.z;\n        pos += ray * dist;\n    }\n    \n    // coloring\n    float shade = i/count;\n    float sat = (1.-shade)*smoothstep(1.,0.,length(pixel));\n    \n    // vertical colored lines\n    vec3 rainbow = (1.-sat)+sat*cos(vec3(.0,.3,.6)*6.3+pixel.y*1.+2.);\n    vec3 tint = mix(vec3(0), rainbow, smoothstep(.1, .0, sin(plocal.y*4000.)));\n    \n    // horizontal colored lines\n    rainbow = (1.-sat)+sat*cos(vec3(.0,.3,.6)*6.3+pixel.x*1.+2.5);\n    tint = mix(tint, rainbow, smoothstep(.1, .0, sin(plocal.x*1000.)+.4));\n    \n    // blinking rectangles\n    vec3 mosaic = hash(uvec3(floor(abs(plocal)*1500.)+floor(iTime/.1)));\n    tint += step(.98, mosaic.x);\n    \n    color = vec4(tint*shade, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 120, 139, 139, 184], [249, 322, 344, 344, 498], [525, 525, 544, 544, 1386], [1388, 1388, 1442, 1460, 2664]], "test": "untested"}
{"id": "Ndlczf", "name": "Tree Blossom", "author": "wyatt", "description": ":)", "tags": ["tree", "kifs"], "likes": 21, "viewed": 380, "published": 3, "date": "1642458696", "time_retrieved": "2024-07-30T17:09:04.402837", "image_code": "#define R iResolution.xy\n#define T iTime\n#define dT iTimeDelta\n#define I iFrame\n#define N 250\n#define Main void mainImage(out vec4 Q, in vec2 V)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec4 hash(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nMain {\n    Q = vec4(0);\n   \n        vec3 U = vec3((V-.5*R)/R.y,0);\n        U.y += .5;\n        vec4 h = hash(vec4(I/N));\n        vec4 uh = hash(vec4(V,V));\n        float M =  30.;\n        float l = .3;\n        float s = 1.;\n        vec2 v = vec2(0);\n        for (float i = 1.; i < M; i++) {\n            vec2 p = U.xy;\n            vec2 a = vec2(0);\n            vec2 b = vec2(0,l);\n            float x = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n            float ln = length(p-a-(b-a)*x)-.5*(dot(a-b,a-b))*mix(1.,.6,x);\n            \n            float sml = smoothstep(1e-3,.8e-3,ln);\n            vec4 c = 1.5*(.5*i/M+.5+uh.y*(1.-exp(-1e4*ln*ln)))*\n                 (.3+(i+x)/M)*sin(1.5*(i+x)/M*(1.+2.5*h.y)*vec4(1,2,3,4));\n             Q = max(Q,c*sml);\n             U.y -= l;\n             s = sign(U.x);\n             vec4 ih = hash(vec4(i,I/N,0,0));\n             if (hash(vec4(U.xy,i,T)).x<.3)\n             s *= -1.;\n             U.x = s*(U.x);\n             a += ih.w*s;\n             U.xy *= ei(ih.x+.5*h.z-h.y*i/M);\n             l *= .6+.2*i/M-.2*s*(ih.y*2.-1.);\n        }\n    if (I%(N)==0) Q = (.2+.2*sin(T+V.y/R.y+vec4(1,2,3,4)))*(1.-exp(-.5*length(V)));\n    else if (length(Q)<1e-3) discard;\n\n}\n      ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndlczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 215, 215, 349]], "test": "untested"}
{"id": "NslyRf", "name": "Bach, BWV 525 1. Allegro", "author": "incription", "description": "Replicating a video from Smalin, https://www.youtube.com/watch?v=1y7aw_ExNic&t=41s&ab_channel=smalin", "tags": ["raymarching", "sound", "bach"], "likes": 13, "viewed": 495, "published": 3, "date": "1642455097", "time_retrieved": "2024-07-30T17:09:06.191056", "image_code": "// Fork of \"J.S.Bach - Badinerie BMV1067\" by incription. https://shadertoy.com/view/ftfXWl\n// 2021-07-20 20:42:17\n\n// Fork of \"Toccata and Fugue in D Minor\" by incription. https://shadertoy.com/view/NlsXWH\n// 2021-07-20 00:13:14\n\n#define F(x,y) col = mix(x, col, smoothstep(0., fwidth(y), y))\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= pi / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat sdNote( in vec2 p, in vec2 size )\n{\n    return sdBox(p, size);\n    \n    float r = size.y * .8;\n    p -= size.x / 2.;\n    float d = sdSegment(p, vec2(r - .002, .0), vec2(r - .002, .05)) - .002;\n\n    d = min(d, length(p) - r);\n    \n    if(size.x > .05) {\n        d = min(d, sdSegment(p, vec2(0,0), vec2(-size.x*2.,0)) - .006);\n        \n        //float tb = .5;\n        //vec2  sc = vec2(sin(tb),cos(tb));\n        //float R = .5 * size.x * asin(tb / 2.);\n\n        //d = min(d, sdArc(p + vec2(size.x / 2., sqrt(R*R - size.x * size.x * .5 )), sc, size.x, 0.005));\n    }\n    \n    return d;\n}\n\nvec3 background(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    return col;\n}\n\nvec3 cam(vec2 uv) {\n    vec3 col = background(uv);\n    vec3 nc;\n    \n    //int tx = int(uv.y*512.0);\n    //float fft = texelFetch( iChannel0, ivec2(tx, 0), 0).x;\n    \n    float t = (iTime - t_offset);\n    float temp;\n    float scale = .2;\n    int i;\n    float latest_t = 0.;\n    \n    int range = 150;\n    int limit = int(t/t_length*float(n_notes));\n    int lower = max(0, limit - range);\n    int higher = min(n_notes, limit + 80);\n    for(i = lower ; i < higher; i++) {\n        vec4 note = notes(i);\n        vec2 pos = vec2((note.x - t + note.z / 2.) * scale, -.42 + note.y / 128. - 1. / 128.) * vec2(1, 2) - uv;\n        if(abs(pos.x) < .5 && note.w > -1.) {\n        \n        vec2 size = vec2((note.z / 2.) * scale, 1. / 64.);\n        \n        //ignore\n        float nt = min(1. - max(0., t-note.x) / (note.z/400.), 1.);\n        if(t-(note.x+note.z) > 0.) nt = 1.;\n        \n        \n        vec2 glowpos = pos;\n        vec2 glowsize = size;\n        \n        nc = vec3(0);\n        if(note.w==2.) nc += vec3(0.412,0.820,0.239); //HSVtoRGB(vec3(note.w/10.,1.,1.));\n        if(note.w==3.) nc += vec3(0.890,0.169,0.169); //HSVtoRGB(vec3(note.w/10.,1.,1.));\n        if(note.w==7.) nc += vec3(0.639,0.627,0.263); //HSVtoRGB(vec3(note.w/10.,1.,1.));\n        \n        //nt = 1. + log(nt);\n        float boxd = sdNote(pos, size);\n        //vec3 glow = nc * (0.000008 / boxd);\n        F(nc, boxd);\n        \n        if(nt < .5 && boxd < 0.) col = pow(col, vec3(.1));\n        \n        //c += 0.5 * vec3(0.584,0.388,0.612) * d * float(note.w == 0.);\n        //c += vec3(0.584,0.388,0.612) * d * float(note.w == 1.);\n        //c += vec3(0.118,0.553,0.663) * d * float(note.w == 2.);\n        //c += vec3(0.859,0.514,0.122) * d * float(note.w == 3.);\n        \n        pos -= .5;\n        if( sdBox(pos + uv, vec2(size.x, 2.)) < 0. )\n            latest_t = t;\n        }\n    }\n    \n    return col;\n}\n\nvec3 addCol(vec3 col, vec3 col2) {\n    return 1. - (col) * (1. - col2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = cam(uv);\n    //float inPlay = sdBox(uv, vec2(.01, 1.));\n    //if(inPlay <= 0.) col = mix(addCol(col, vec3(1, 0, 0)), col, smoothstep(0.0, fwidth(inPlay), inPlay));\n    //vec3 col = 1. - ((1. - col) * mix(0., 1., min(1. ,uv.x * 10.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define n_notes 1706\n#define t_offset 1.\n#define t_length 127.5\n#define SPEED 1.2\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 notes(int n)\n{\n    const vec4 _[1024] = vec4[1024](vec4(0,3,4,-1),vec4(1.13,63,0.31944412499999997,2), vec4(1.4427073333333331,75,0.31944412499999997,2),vec4(1.776040333333333,65,0.31944412499999997,2),vec4(2.109373333333333,75,0.31944412499999997,2),vec4(1.1093743333333332,39,1.3194431249999998,6),vec4(1.1093743333333332,39,1.3194431249999998,7),vec4(1.1093743333333332,51,1.3194431249999998,8),vec4(2.442706333333333,67,0.31944412499999997,2),vec4(2.7760393333333333,75,0.31944412499999997,2),vec4(3.1093723333333334,68,0.31944412499999997,2),vec4(3.4427053333333335,75,0.31944412499999997,2),vec4(3.7760383333333336,70,0.31944412499999997,2),vec4(4.109371333333334,75,0.3194441250000004,2),vec4(3.1093723333333334,36,1.3194431250000007,6),vec4(3.1093723333333334,36,1.3194431250000007,7),vec4(3.1093723333333334,48,1.3194431250000007,8),vec4(4.442704333333334,72,0.3194441250000004,2),vec4(4.776037333333335,75,0.3194441250000004,2),vec4(5.109370333333335,70,0.1527776249999997,2),vec4(5.276036833333335,75,0.1527776249999997,2),vec4(5.442703333333335,74,0.1527776249999997,2),vec4(5.609369833333335,72,0.1527776249999997,2),vec4(5.776036333333335,70,0.1527776249999997,2),vec4(5.9427028333333345,79,0.1527776249999997,2),vec4(5.109370333333335,31,0.9861101249999988,6),vec4(5.109370333333335,31,0.9861101249999988,7),vec4(5.109370333333335,43,0.9861101249999988,8),vec4(6.109369333333334,77,0.1527776249999997,2),vec4(6.276035833333334,75,0.1527776249999997,2),vec4(6.109369333333334,32,0.3194441249999995,6),vec4(6.109369333333334,32,0.3194441249999995,7),vec4(6.109369333333334,44,0.3194441249999995,8),vec4(6.442702333333334,74,0.1527776249999997,2),vec4(6.609368833333334,72,0.1527776249999997,2),vec4(6.776035333333334,70,0.1527776249999997,2),vec4(6.9427018333333335,68,0.1527776249999997,2),vec4(6.442702333333334,34,0.6527771249999992,6),vec4(6.442702333333334,34,0.6527771249999992,7),vec4(6.442702333333334,46,0.6527771249999992,8),vec4(7.109368333333333,67,0.1527776249999997,2),vec4(7.276034833333333,68,0.1527776249999997,2),vec4(7.442701333333333,70,0.1527776249999997,2),vec4(7.609367833333333,67,0.1527776249999997,2),vec4(7.109368333333333,27,0.6527771249999992,6),vec4(7.109368333333333,27,0.6527771249999992,7),vec4(7.109368333333333,39,0.6527771249999992,8),vec4(7.776034333333333,63,0.1527776249999997,2),vec4(7.942700833333332,67,0.1527776249999997,2),vec4(8.109367333333331,70,0.15277762500000058,2),vec4(8.276033833333331,75,0.15277762500000058,2),vec4(7.776034333333333,31,0.6527771249999992,6),vec4(7.776034333333333,31,0.6527771249999992,7),vec4(7.776034333333333,43,0.6527771249999992,8),vec4(8.442700333333331,65,0.15277762500000058,2),vec4(8.60936683333333,69,0.15277762500000058,2),vec4(8.77603333333333,72,0.15277762500000058,2),vec4(8.94269983333333,75,0.15277762500000058,2),vec4(8.442700333333331,33,0.6527771250000001,6),vec4(8.442700333333331,33,0.6527771250000001,7),vec4(8.442700333333331,45,0.6527771250000001,8),vec4(9.10936633333333,74,0.15277762500000058,2),vec4(9.27603283333333,72,0.15277762500000058,2),vec4(9.10936633333333,58,0.3194441250000004,3),vec4(9.44269933333333,74,0.15277762500000058,2),vec4(9.60936583333333,77,0.15277762500000058,2),vec4(9.44269933333333,70,0.3194441250000004,3),vec4(9.77603233333333,75,0.15277762500000058,2),vec4(9.94269883333333,74,0.15277762500000058,2),vec4(9.77603233333333,60,0.3194441250000004,3),vec4(10.10936533333333,75,0.15277762500000058,2),vec4(10.27603183333333,79,0.15277762500000058,2),vec4(10.10936533333333,70,0.3194441250000004,3),vec4(9.10936633333333,34,1.3194431249999994,6),vec4(9.10936633333333,34,1.3194431249999994,7),vec4(9.10936633333333,46,1.3194431249999994,8),vec4(10.442698333333329,77,0.15277762500000058,2),vec4(10.609364833333329,75,0.15277762500000058,2),vec4(10.442698333333329,62,0.3194441250000004,3),vec4(10.776031333333329,77,0.15277762500000058,2),vec4(10.942697833333328,80,0.15277762500000058,2),vec4(10.776031333333329,70,0.3194441250000004,3),vec4(11.109364333333328,79,0.15277762500000058,2),vec4(11.276030833333328,77,0.15277762500000058,2),vec4(11.109364333333328,63,0.3194441250000004,3),vec4(11.442697333333328,79,0.15277762500000058,2),vec4(11.609363833333328,82,0.15277762500000058,2),vec4(11.442697333333328,70,0.3194441250000004,3),vec4(11.776030333333328,74,0.15277762500000058,2),vec4(11.942696833333327,72,0.15277762500000058,2),vec4(11.776030333333328,65,0.3194441250000004,3),vec4(12.109363333333327,74,0.15277762500000058,2),vec4(12.276029833333327,82,0.15277762500000058,2),vec4(12.109363333333327,70,0.3194441250000004,3),vec4(11.109364333333328,34,1.3194431249999994,6),vec4(11.109364333333328,34,1.3194431249999994,7),vec4(11.109364333333328,46,1.3194431249999994,8),vec4(12.442696333333327,75,0.15277762500000058,2),vec4(12.609362833333327,74,0.15277762500000058,2),vec4(12.442696333333327,67,0.3194441250000004,3),vec4(12.776029333333327,75,0.15277762500000058,2),vec4(12.942695833333326,82,0.15277762500000058,2),vec4(12.776029333333327,70,0.3194441250000004,3),vec4(13.109362333333326,65,0.15277762500000058,3),vec4(13.109362333333326,74,0.3194441250000004,2),vec4(13.276028833333326,70,0.15277762500000058,3),vec4(13.442695333333326,69,0.15277762500000058,3),vec4(13.442695333333326,77,0.3194441250000004,2),vec4(13.609361833333326,67,0.15277762500000058,3),vec4(13.109362333333326,34,0.6527771250000001,6),vec4(13.109362333333326,34,0.6527771250000001,7),vec4(13.109362333333326,46,0.6527771250000001,8),vec4(13.776028333333326,65,0.15277762500000058,3),vec4(13.776028333333326,82,0.3194441250000004,2),vec4(13.942694833333325,74,0.15277762500000058,3),vec4(14.109361333333325,72,0.15277762500000058,3),vec4(14.109361333333325,74,0.3194441250000004,2),vec4(14.276027833333325,70,0.15277762500000058,3),vec4(13.776028333333326,38,0.6527771250000001,6),vec4(13.776028333333326,38,0.6527771250000001,7),vec4(13.776028333333326,50,0.6527771250000001,8),vec4(14.442694333333325,69,0.15277762500000058,3),vec4(14.442694333333325,72,0.3194441250000004,2),vec4(14.609360833333325,67,0.15277762500000058,3),vec4(14.776027333333325,65,0.15277762500000058,3),vec4(14.776027333333325,81,0.3194441250000004,2),vec4(14.942693833333324,63,0.15277762500000058,3),vec4(14.442694333333325,41,0.6527771250000001,6),vec4(14.442694333333325,41,0.6527771250000001,7),vec4(14.442694333333325,53,0.6527771250000001,8),vec4(15.109360333333324,62,0.15277762500000058,3),vec4(15.109360333333324,82,0.3194441250000004,2),vec4(15.276026833333324,63,0.15277762500000058,3),vec4(15.442693333333324,65,0.15277762500000058,3),vec4(15.442693333333324,74,0.3194441250000004,2),vec4(15.609359833333324,62,0.15277762500000058,3),vec4(15.776026333333323,58,0.15277762500000058,3),vec4(15.776026333333323,77,0.3194441250000004,2),vec4(15.942692833333323,62,0.15277762500000058,3),vec4(16.109359333333323,65,0.1527776249999988,3),vec4(16.109359333333323,74,0.31944412499999686,2),vec4(16.27602583333332,70,0.1527776249999988,3),vec4(15.109360333333324,46,1.3194431249999958,6),vec4(15.109360333333324,46,1.3194431249999958,7),vec4(15.109360333333324,58,1.3194431249999958,8),vec4(16.44269233333332,62,0.1527776249999988,3),vec4(16.44269233333332,70,0.31944412499999686,2),vec4(16.609358833333317,65,0.1527776249999988,3),vec4(16.776025333333315,68,0.1527776249999988,3),vec4(16.776025333333315,74,0.31944412499999686,2),vec4(16.942691833333313,70,0.1527776249999988,3),vec4(17.10935833333331,67,0.1527776249999988,3),vec4(17.10935833333331,75,0.31944412499999686,2),vec4(17.27602483333331,65,0.1527776249999988,3),vec4(17.10935833333331,27,0.31944412499999686,6),vec4(17.10935833333331,27,0.31944412499999686,7),vec4(17.10935833333331,39,0.31944412499999686,8),vec4(17.442691333333308,67,0.1527776249999988,3),vec4(17.609357833333306,70,0.1527776249999988,3),vec4(17.442691333333308,39,0.31944412499999686,6),vec4(17.442691333333308,39,0.31944412499999686,7),vec4(17.442691333333308,51,0.31944412499999686,8),vec4(17.776024333333304,68,0.1527776249999988,3),vec4(17.776024333333304,75,0.31944412499999686,2),vec4(17.9426908333333,67,0.1527776249999988,3),vec4(17.776024333333304,29,0.31944412499999686,6),vec4(17.776024333333304,29,0.31944412499999686,7),vec4(17.776024333333304,41,0.31944412499999686,8),vec4(18.1093573333333,68,0.1527776249999988,3),vec4(18.276023833333298,72,0.1527776249999988,3),vec4(18.1093573333333,39,0.31944412499999686,6),vec4(18.1093573333333,39,0.31944412499999686,7),vec4(18.1093573333333,51,0.31944412499999686,8),vec4(18.442690333333296,70,0.1527776249999988,3),vec4(18.442690333333296,75,0.31944412499999686,2),vec4(18.609356833333294,68,0.1527776249999988,3),vec4(18.442690333333296,31,0.31944412499999686,6),vec4(18.442690333333296,31,0.31944412499999686,7),vec4(18.442690333333296,43,0.31944412499999686,8),vec4(18.776023333333292,70,0.1527776249999988,3),vec4(18.94268983333329,73,0.1527776249999988,3),vec4(18.776023333333292,39,0.31944412499999686,6),vec4(18.776023333333292,39,0.31944412499999686,7),vec4(18.776023333333292,51,0.31944412499999686,8),vec4(19.109356333333288,72,0.1527776249999988,3),vec4(19.109356333333288,75,0.31944412499999686,2),vec4(19.276022833333286,70,0.1527776249999988,3),vec4(19.109356333333288,32,0.31944412499999686,6),vec4(19.109356333333288,32,0.31944412499999686,7),vec4(19.109356333333288,44,0.31944412499999686,8),vec4(19.442689333333284,72,0.1527776249999988,3),vec4(19.609355833333282,75,0.1527776249999988,3),vec4(19.442689333333284,39,0.31944412499999686,6),vec4(19.442689333333284,39,0.31944412499999686,7),vec4(19.442689333333284,51,0.31944412499999686,8),vec4(19.77602233333328,67,0.1527776249999988,3),vec4(19.77602233333328,75,0.31944412499999686,2),vec4(19.94268883333328,65,0.1527776249999988,3),vec4(19.77602233333328,34,0.31944412499999686,6),vec4(19.77602233333328,34,0.31944412499999686,7),vec4(19.77602233333328,46,0.31944412499999686,8),vec4(20.109355333333276,67,0.1527776249999988,3),vec4(20.276021833333274,75,0.1527776249999988,3),vec4(20.109355333333276,39,0.31944412499999686,6),vec4(20.109355333333276,39,0.31944412499999686,7),vec4(20.109355333333276,51,0.31944412499999686,8),vec4(20.442688333333273,68,0.1527776249999988,3),vec4(20.442688333333273,75,0.31944412499999686,2),vec4(20.60935483333327,67,0.1527776249999988,3),vec4(20.442688333333273,36,0.31944412499999686,6),vec4(20.442688333333273,36,0.31944412499999686,7),vec4(20.442688333333273,48,0.31944412499999686,8),vec4(20.77602133333327,68,0.1527776249999988,3),vec4(20.942687833333267,75,0.1527776249999988,3),vec4(20.77602133333327,39,0.31944412499999686,6),vec4(20.77602133333327,39,0.31944412499999686,7),vec4(20.77602133333327,51,0.31944412499999686,8),vec4(21.276020833333266,75,0.1527776249999988,2),vec4(21.109354333333265,67,0.3194441250000004,3),vec4(21.109354333333265,34,0.3194441250000004,6),vec4(21.109354333333265,34,0.3194441250000004,7),vec4(21.109354333333265,46,0.3194441250000004,8),vec4(21.442687333333264,77,0.1527776249999988,2),vec4(21.609353833333262,79,0.1527776249999988,2),vec4(21.442687333333264,70,0.31944412499999686,3),vec4(21.77602033333326,80,0.1527776249999988,2),vec4(21.94268683333326,82,0.1527776249999988,2),vec4(21.77602033333326,75,0.31944412499999686,3),vec4(21.77602033333326,36,0.31944412499999686,6),vec4(21.77602033333326,36,0.31944412499999686,7),vec4(21.77602033333326,48,0.31944412499999686,8),vec4(22.109353333333257,84,0.1527776249999988,2),vec4(22.276019833333255,82,0.1527776249999988,2),vec4(22.109353333333257,67,0.31944412499999686,3),vec4(22.442686333333253,80,0.1527776249999988,2),vec4(22.60935283333325,79,0.1527776249999988,2),vec4(22.442686333333253,65,0.31944412499999686,3),vec4(22.442686333333253,38,0.31944412499999686,6),vec4(22.442686333333253,38,0.31944412499999686,7),vec4(22.442686333333253,50,0.31944412499999686,8),vec4(22.77601933333325,77,0.1527776249999988,2),vec4(22.942685833333247,80,0.1527776249999988,2),vec4(22.77601933333325,70,0.31944412499999686,3),vec4(23.109352333333245,79,0.3194441250000004,2),vec4(23.276018833333247,63,0.1527776249999988,3),vec4(23.442685333333245,65,0.1527776249999988,3),vec4(23.442685333333245,70,0.31944412499999686,2),vec4(23.609351833333243,67,0.1527776249999988,3),vec4(23.77601833333324,68,0.1527776249999988,3),vec4(23.77601833333324,72,0.31944412499999686,2),vec4(23.94268483333324,70,0.1527776249999988,3),vec4(24.109351333333237,72,0.1527776249999988,3),vec4(24.109351333333237,68,0.31944412499999686,2),vec4(24.276017833333235,70,0.1527776249999988,3),vec4(23.109352333333245,39,1.3194431249999887,6),vec4(23.109352333333245,39,1.3194431249999887,7),vec4(23.109352333333245,51,1.3194431249999887,8),vec4(24.442684333333233,68,0.1527776249999988,3),vec4(24.60935083333323,67,0.1527776249999988,3),vec4(24.77601733333323,65,0.1527776249999988,3),vec4(24.942683833333227,68,0.1527776249999988,3),vec4(24.442684333333233,38,0.652777124999993,6),vec4(24.442684333333233,38,0.652777124999993,7),vec4(24.442684333333233,50,0.652777124999993,8),vec4(24.442684333333233,77,0.819443624999991,2),vec4(25.276016833333223,80,0.1527776249999988,2),vec4(25.109350333333225,67,0.31944412499999686,3),vec4(25.44268333333322,79,0.1527776249999988,2),vec4(25.60934983333322,77,0.1527776249999988,2),vec4(25.44268333333322,58,0.31944412499999686,3),vec4(25.109350333333225,39,0.652777124999993,6),vec4(25.109350333333225,39,0.652777124999993,7),vec4(25.109350333333225,51,0.652777124999993,8),vec4(25.776016333333217,75,0.1527776249999988,2),vec4(25.942682833333215,74,0.1527776249999988,2),vec4(25.776016333333217,60,0.31944412499999686,3),vec4(26.109349333333213,72,0.1527776249999988,2),vec4(26.27601583333321,70,0.1527776249999988,2),vec4(26.109349333333213,56,0.31944412499999686,3),vec4(25.776016333333217,44,0.652777124999993,6),vec4(25.776016333333217,44,0.652777124999993,7),vec4(25.776016333333217,56,0.652777124999993,8),vec4(26.44268233333321,68,0.1527776249999988,2),vec4(26.609348833333208,67,0.1527776249999988,2),vec4(26.776015333333206,68,0.1527776249999988,2),vec4(26.942681833333204,77,0.1527776249999988,2),vec4(27.1093483333332,67,0.1527776249999988,2),vec4(26.44268233333321,65,0.819443624999991,3),vec4(27.2760148333332,77,0.1527776249999988,2),vec4(27.2760148333332,68,0.1527776249999988,3),vec4(27.442681333333198,75,0.1527776249999988,2),vec4(27.442681333333198,67,0.1527776249999988,3),vec4(27.609347833333196,74,0.1527776249999988,2),vec4(27.609347833333196,65,0.1527776249999988,3),vec4(27.1093483333332,35,0.652777124999993,6),vec4(27.1093483333332,35,0.652777124999993,7),vec4(27.1093483333332,47,0.652777124999993,8),vec4(27.776014333333194,72,0.1527776249999988,2),vec4(27.776014333333194,63,0.1527776249999988,3),vec4(27.942680833333192,70,0.1527776249999988,2),vec4(27.942680833333192,62,0.1527776249999988,3),vec4(28.10934733333319,68,0.1527776249999988,2),vec4(28.10934733333319,60,0.1527776249999988,3),vec4(28.276013833333188,67,0.1527776249999988,2),vec4(28.276013833333188,58,0.1527776249999988,3),vec4(27.776014333333194,36,0.652777124999993,6),vec4(27.776014333333194,36,0.652777124999993,7),vec4(27.776014333333194,48,0.652777124999993,8),vec4(28.442680333333186,56,0.1527776249999988,3),vec4(28.609346833333184,55,0.1527776249999988,3),vec4(28.776013333333182,56,0.1527776249999988,3),vec4(28.94267983333318,65,0.1527776249999988,3),vec4(28.442680333333186,38,0.652777124999993,6),vec4(28.442680333333186,38,0.652777124999993,7),vec4(28.442680333333186,50,0.652777124999993,8),vec4(28.442680333333186,65,0.819443624999991,2),vec4(29.10934633333318,55,0.1527776249999988,3),vec4(29.276012833333176,68,0.1527776249999988,2),vec4(29.276012833333176,65,0.1527776249999988,3),vec4(29.442679333333174,67,0.1527776249999988,2),vec4(29.442679333333174,63,0.1527776249999988,3),vec4(29.609345833333172,65,0.1527776249999988,2),vec4(29.609345833333172,62,0.1527776249999988,3),vec4(29.10934633333318,27,0.652777124999993,6),vec4(29.10934633333318,27,0.652777124999993,7),vec4(29.10934633333318,39,0.652777124999993,8),vec4(29.77601233333317,60,0.1527776249999988,3),vec4(29.94267883333317,58,0.1527776249999988,3),vec4(30.109345333333167,56,0.1527776249999988,3),vec4(30.276011833333165,55,0.1527776249999988,3),vec4(29.77601233333317,63,0.819443624999991,2),vec4(30.60934483333316,62,0.1527776249999988,2),vec4(30.77601133333316,63,0.1527776249999988,2),vec4(30.942677833333157,65,0.1527776249999988,2),vec4(29.77601233333317,32,1.3194431249999852,6),vec4(29.77601233333317,32,1.3194431249999852,7),vec4(29.77601233333317,44,1.3194431249999852,8),vec4(30.442678333333163,53,0.819443624999991,3),vec4(31.109344333333155,59,0.31944412499999686,2),vec4(31.276010833333153,56,0.1527776249999988,3),vec4(31.44267733333315,55,0.1527776249999988,3),vec4(31.44267733333315,62,0.31944412499999686,2),vec4(31.60934383333315,53,0.1527776249999988,3),vec4(31.109344333333155,31,0.652777124999993,6),vec4(31.109344333333155,31,0.652777124999993,7),vec4(31.109344333333155,43,0.652777124999993,8),vec4(31.776010333333147,67,0.31944412500000396,2),vec4(31.776010333333147,51,0.31944412500000396,3),vec4(31.94267683333315,43,0.15277762500000236,6),vec4(31.94267683333315,43,0.15277762500000236,7),vec4(31.94267683333315,55,0.15277762500000236,8),vec4(32.10934333333315,41,0.1527776249999988,6),vec4(32.10934333333315,41,0.1527776249999988,7),vec4(32.10934333333315,53,0.1527776249999988,8),vec4(32.10934333333315,71,0.31944412499999686,2),vec4(32.10934333333315,55,0.31944412499999686,3),vec4(32.27600983333315,43,0.1527776249999988,6),vec4(32.27600983333315,43,0.1527776249999988,7),vec4(32.27600983333315,55,0.1527776249999988,8),vec4(32.44267633333315,39,0.1527776249999988,6),vec4(32.44267633333315,39,0.1527776249999988,7),vec4(32.44267633333315,51,0.1527776249999988,8),vec4(32.44267633333315,72,0.31944412499999686,2),vec4(32.44267633333315,57,0.31944412499999686,3),vec4(32.609342833333145,41,0.1527776249999988,6),vec4(32.609342833333145,41,0.1527776249999988,7),vec4(32.609342833333145,53,0.1527776249999988,8),vec4(32.77600933333314,38,0.1527776249999988,6),vec4(32.77600933333314,38,0.1527776249999988,7),vec4(32.77600933333314,50,0.1527776249999988,8),vec4(32.77600933333314,74,0.31944412499999686,2),vec4(32.77600933333314,59,0.31944412499999686,3),vec4(32.94267583333314,39,0.1527776249999988,6),vec4(32.94267583333314,39,0.1527776249999988,7),vec4(32.94267583333314,51,0.1527776249999988,8),vec4(33.10934233333314,75,0.1527776249999988,2),vec4(33.27600883333314,72,0.1527776249999988,2),vec4(33.10934233333314,60,0.31944412499999686,3),vec4(33.10934233333314,36,0.31944412499999686,6),vec4(33.10934233333314,36,0.31944412499999686,7),vec4(33.10934233333314,48,0.31944412499999686,8),vec4(33.442675333333135,71,0.1527776249999988,2),vec4(33.60934183333313,72,0.1527776249999988,2),vec4(33.442675333333135,39,0.31944412499999686,6),vec4(33.442675333333135,39,0.31944412499999686,7),vec4(33.442675333333135,51,0.31944412499999686,8),vec4(33.77600833333313,67,0.1527776249999988,2),vec4(33.94267483333313,72,0.1527776249999988,2),vec4(33.77600833333313,36,0.31944412499999686,6),vec4(33.77600833333313,36,0.31944412499999686,7),vec4(33.77600833333313,48,0.31944412499999686,8),vec4(34.10934133333313,71,0.1527776249999988,2),vec4(34.276007833333125,72,0.1527776249999988,2),vec4(34.10934133333313,39,0.31944412499999686,6),vec4(34.10934133333313,39,0.31944412499999686,7),vec4(34.10934133333313,51,0.31944412499999686,8),vec4(34.44267433333312,75,0.1527776249999988,2),vec4(34.60934083333312,72,0.1527776249999988,2),vec4(34.44267433333312,36,0.31944412499999686,6),vec4(34.44267433333312,36,0.31944412499999686,7),vec4(34.44267433333312,48,0.31944412499999686,8),vec4(34.77600733333312,71,0.1527776249999988,2),vec4(34.94267383333312,72,0.1527776249999988,2),vec4(34.77600733333312,39,0.31944412499999686,6),vec4(34.77600733333312,39,0.31944412499999686,7),vec4(34.77600733333312,51,0.31944412499999686,8),vec4(35.109340333333115,68,0.31944412499999686,2),vec4(35.27600683333311,65,0.1527776249999988,3),vec4(35.109340333333115,29,0.31944412499999686,6),vec4(35.109340333333115,29,0.31944412499999686,7),vec4(35.109340333333115,41,0.31944412499999686,8),vec4(35.44267333333311,63,0.1527776249999988,3),vec4(35.60933983333311,65,0.1527776249999988,3),vec4(35.44267333333311,44,0.31944412499999686,6),vec4(35.44267333333311,44,0.31944412499999686,7),vec4(35.44267333333311,56,0.31944412499999686,8),vec4(35.77600633333311,60,0.1527776249999988,3),vec4(35.77600633333311,75,0.31944412499999686,2),vec4(35.942672833333106,65,0.1527776249999988,3),vec4(35.77600633333311,29,0.31944412499999686,6),vec4(35.77600633333311,29,0.31944412499999686,7),vec4(35.77600633333311,41,0.31944412499999686,8),vec4(36.109339333333104,63,0.1527776249999988,3),vec4(36.2760058333331,65,0.1527776249999988,3),vec4(36.109339333333104,44,0.31944412499999686,6),vec4(36.109339333333104,44,0.31944412499999686,7),vec4(36.109339333333104,56,0.31944412499999686,8),vec4(36.4426723333331,68,0.1527776249999988,3),vec4(36.4426723333331,75,0.31944412499999686,2),vec4(36.6093388333331,65,0.1527776249999988,3),vec4(36.4426723333331,29,0.31944412499999686,6),vec4(36.4426723333331,29,0.31944412499999686,7),vec4(36.4426723333331,41,0.31944412499999686,8),vec4(36.776005333333096,63,0.1527776249999988,3),vec4(36.942671833333094,65,0.1527776249999988,3),vec4(36.776005333333096,44,0.31944412499999686,6),vec4(36.776005333333096,44,0.31944412499999686,7),vec4(36.776005333333096,56,0.31944412499999686,8),vec4(37.27600483333309,70,0.1527776249999988,2),vec4(37.10933833333309,62,0.31944412499999686,3),vec4(37.10933833333309,34,0.31944412499999686,6),vec4(37.10933833333309,34,0.31944412499999686,7),vec4(37.10933833333309,46,0.31944412499999686,8),vec4(37.44267133333309,68,0.1527776249999988,2),vec4(37.609337833333086,70,0.1527776249999988,2),vec4(37.44267133333309,38,0.31944412499999686,6),vec4(37.44267133333309,38,0.31944412499999686,7),vec4(37.44267133333309,50,0.31944412499999686,8),vec4(37.776004333333084,65,0.1527776249999988,2),vec4(37.94267083333308,70,0.1527776249999988,2),vec4(37.776004333333084,68,0.31944412499999686,3),vec4(37.776004333333084,34,0.31944412499999686,6),vec4(37.776004333333084,34,0.31944412499999686,7),vec4(37.776004333333084,46,0.31944412499999686,8),vec4(38.10933733333308,68,0.1527776249999988,2),vec4(38.27600383333308,70,0.1527776249999988,2),vec4(38.10933733333308,38,0.31944412499999686,6),vec4(38.10933733333308,38,0.31944412499999686,7),vec4(38.10933733333308,50,0.31944412499999686,8),vec4(38.442670333333076,74,0.1527776249999988,2),vec4(38.609336833333074,70,0.1527776249999988,2),vec4(38.442670333333076,68,0.31944412499999686,3),vec4(38.442670333333076,34,0.31944412499999686,6),vec4(38.442670333333076,34,0.31944412499999686,7),vec4(38.442670333333076,46,0.31944412499999686,8),vec4(38.77600333333307,68,0.1527776249999988,2),vec4(38.94266983333307,70,0.1527776249999988,2),vec4(38.77600333333307,38,0.31944412499999686,6),vec4(38.77600333333307,38,0.31944412499999686,7),vec4(38.77600333333307,50,0.31944412499999686,8),vec4(39.10933633333307,67,0.31944412499999686,2),vec4(39.27600283333307,63,0.1527776249999988,3),vec4(39.10933633333307,27,0.31944412499999686,6),vec4(39.10933633333307,27,0.31944412499999686,7),vec4(39.10933633333307,39,0.31944412499999686,8),vec4(39.442669333333065,61,0.1527776249999988,3),vec4(39.60933583333306,63,0.1527776249999988,3),vec4(39.442669333333065,43,0.31944412499999686,6),vec4(39.442669333333065,43,0.31944412499999686,7),vec4(39.442669333333065,55,0.31944412499999686,8),vec4(39.77600233333306,58,0.1527776249999988,3),vec4(39.77600233333306,73,0.31944412499999686,2),vec4(39.94266883333306,63,0.1527776249999988,3),vec4(39.77600233333306,27,0.31944412499999686,6),vec4(39.77600233333306,27,0.31944412499999686,7),vec4(39.77600233333306,39,0.31944412499999686,8),vec4(40.10933533333306,61,0.1527776249999988,3),vec4(40.276001833333055,63,0.1527776249999988,3),vec4(40.10933533333306,43,0.31944412499999686,6),vec4(40.10933533333306,43,0.31944412499999686,7),vec4(40.10933533333306,55,0.31944412499999686,8),vec4(40.44266833333305,67,0.1527776249999988,3),vec4(40.44266833333305,73,0.31944412499999686,2),vec4(40.60933483333305,63,0.1527776249999988,3),vec4(40.44266833333305,27,0.31944412499999686,6),vec4(40.44266833333305,27,0.31944412499999686,7),vec4(40.44266833333305,39,0.31944412499999686,8),vec4(40.77600133333305,61,0.1527776249999988,3),vec4(40.94266783333305,63,0.1527776249999988,3),vec4(40.77600133333305,43,0.31944412499999686,6),vec4(40.77600133333305,43,0.31944412499999686,7),vec4(40.77600133333305,55,0.31944412499999686,8),vec4(41.109334333333045,60,0.1527776249999988,3),vec4(41.27600083333304,68,0.1527776249999988,2),vec4(41.27600083333304,65,0.1527776249999988,3),vec4(41.109334333333045,32,0.31944412499999686,6),vec4(41.109334333333045,32,0.31944412499999686,7),vec4(41.109334333333045,44,0.31944412499999686,8),vec4(41.44266733333304,67,0.1527776249999988,2),vec4(41.44266733333304,64,0.1527776249999988,3),vec4(41.60933383333304,68,0.1527776249999988,2),vec4(41.60933383333304,65,0.1527776249999988,3),vec4(41.44266733333304,36,0.31944412499999686,6),vec4(41.44266733333304,36,0.31944412499999686,7),vec4(41.44266733333304,48,0.31944412499999686,8),vec4(41.77600033333304,65,0.1527776249999988,2),vec4(41.77600033333304,60,0.1527776249999988,3),vec4(41.942666833333035,68,0.1527776249999988,2),vec4(41.942666833333035,65,0.1527776249999988,3),vec4(41.77600033333304,32,0.31944412499999686,6),vec4(41.77600033333304,32,0.31944412499999686,7),vec4(41.77600033333304,44,0.31944412499999686,8),vec4(42.10933333333303,67,0.1527776249999988,2),vec4(42.10933333333303,64,0.1527776249999988,3),vec4(42.27599983333303,68,0.1527776249999988,2),vec4(42.27599983333303,65,0.1527776249999988,3),vec4(42.10933333333303,36,0.31944412499999686,6),vec4(42.10933333333303,36,0.31944412499999686,7),vec4(42.10933333333303,48,0.31944412499999686,8),vec4(42.44266633333303,72,0.1527776249999988,2),vec4(42.44266633333303,68,0.1527776249999988,3),vec4(42.60933283333303,68,0.1527776249999988,2),vec4(42.60933283333303,65,0.1527776249999988,3),vec4(42.44266633333303,32,0.31944412499999686,6),vec4(42.44266633333303,32,0.31944412499999686,7),vec4(42.44266633333303,44,0.31944412499999686,8),vec4(42.775999333333026,67,0.1527776249999988,2),vec4(42.775999333333026,63,0.1527776249999988,3),vec4(42.942665833333024,68,0.1527776249999988,2),vec4(42.942665833333024,65,0.1527776249999988,3),vec4(42.775999333333026,36,0.31944412499999686,6),vec4(42.775999333333026,36,0.31944412499999686,7),vec4(42.775999333333026,48,0.31944412499999686,8),vec4(43.10933233333302,65,0.1527776249999988,2),vec4(43.27599883333302,70,0.1527776249999988,2),vec4(43.10933233333302,62,0.31944412499999686,3),vec4(43.10933233333302,32,0.31944412499999686,6),vec4(43.10933233333302,32,0.31944412499999686,7),vec4(43.10933233333302,44,0.31944412499999686,8),vec4(43.44266533333302,68,0.1527776249999988,2),vec4(43.609331833333016,70,0.1527776249999988,2),vec4(43.44266533333302,65,0.31944412499999686,3),vec4(43.44266533333302,38,0.31944412499999686,6),vec4(43.44266533333302,38,0.31944412499999686,7),vec4(43.44266533333302,50,0.31944412499999686,8),vec4(43.775998333333014,74,0.1527776249999988,2),vec4(43.94266483333301,70,0.1527776249999988,2),vec4(43.775998333333014,32,0.31944412499999686,6),vec4(43.775998333333014,32,0.31944412499999686,7),vec4(43.775998333333014,44,0.31944412499999686,8),vec4(44.10933133333301,68,0.1527776249999988,2),vec4(44.27599783333301,70,0.1527776249999988,2),vec4(44.10933133333301,38,0.31944412499999686,6),vec4(44.10933133333301,38,0.31944412499999686,7),vec4(44.10933133333301,50,0.31944412499999686,8),vec4(44.442664333333006,77,0.1527776249999988,2),vec4(44.609330833333004,74,0.1527776249999988,2),vec4(44.442664333333006,32,0.31944412499999686,6),vec4(44.442664333333006,32,0.31944412499999686,7),vec4(44.442664333333006,44,0.31944412499999686,8),vec4(44.775997333333,72,0.1527776249999988,2),vec4(44.942663833333,74,0.1527776249999988,2),vec4(44.775997333333,38,0.31944412499999686,6),vec4(44.775997333333,38,0.31944412499999686,7),vec4(44.775997333333,50,0.31944412499999686,8),vec4(43.775998333333014,70,1.4861096249999832,3),vec4(45.109330333333,82,0.31944412499999686,2),vec4(45.275996833333,58,0.1527776249999988,3),vec4(45.109330333333,31,0.31944412499999686,6),vec4(45.109330333333,31,0.31944412499999686,7),vec4(45.109330333333,43,0.31944412499999686,8),vec4(45.442663333332995,56,0.1527776249999988,3),vec4(45.442663333332995,79,0.31944412499999686,2),vec4(45.60932983333299,58,0.1527776249999988,3),vec4(45.442663333332995,39,0.31944412499999686,6),vec4(45.442663333332995,39,0.31944412499999686,7),vec4(45.442663333332995,51,0.31944412499999686,8),vec4(45.77599633333299,63,0.1527776249999988,3),vec4(45.94266283333299,58,0.1527776249999988,3),vec4(45.77599633333299,31,0.31944412499999686,6),vec4(45.77599633333299,31,0.31944412499999686,7),vec4(45.77599633333299,43,0.31944412499999686,8),vec4(46.10932933333299,56,0.1527776249999988,3),vec4(46.275995833332985,58,0.1527776249999988,3),vec4(46.10932933333299,39,0.31944412499999686,6),vec4(46.10932933333299,39,0.31944412499999686,7),vec4(46.10932933333299,51,0.31944412499999686,8),vec4(46.44266233333298,67,0.1527776249999988,3),vec4(46.60932883333298,63,0.1527776249999988,3),vec4(46.44266233333298,31,0.31944412499999686,6),vec4(46.44266233333298,31,0.31944412499999686,7),vec4(46.44266233333298,43,0.31944412499999686,8),vec4(46.77599533333298,62,0.1527776249999988,3),vec4(46.94266183333298,63,0.1527776249999988,3),vec4(46.77599533333298,39,0.31944412499999686,6),vec4(46.77599533333298,39,0.31944412499999686,7),vec4(46.77599533333298,51,0.31944412499999686,8),vec4(45.77599633333299,75,1.4861096249999832,2),vec4(47.109328333332975,69,0.1527776249999988,3),vec4(47.27599483333297,74,0.1527776249999988,2),vec4(47.27599483333297,70,0.1527776249999988,3),vec4(47.44266133333297,72,0.1527776249999988,2),vec4(47.44266133333297,69,0.1527776249999988,3),vec4(47.60932783333297,70,0.1527776249999988,2),vec4(47.60932783333297,67,0.1527776249999988,3),vec4(47.109328333332975,29,0.652777124999993,6),vec4(47.109328333332975,29,0.652777124999993,7),vec4(47.109328333332975,41,0.652777124999993,8),vec4(47.77599433333297,69,0.1527776249999988,2),vec4(47.77599433333297,65,0.1527776249999988,3),vec4(47.942660833332965,70,0.1527776249999988,2),vec4(47.942660833332965,74,0.1527776249999988,3),vec4(48.10932733333296,69,0.1527776249999988,2),vec4(48.10932733333296,72,0.1527776249999988,3),vec4(48.27599383333296,67,0.1527776249999988,2),vec4(48.27599383333296,70,0.1527776249999988,3),vec4(48.44266033333296,65,0.1527776249999988,2),vec4(48.44266033333296,69,0.1527776249999988,3),vec4(48.60932683333296,75,0.1527776249999988,2),vec4(48.60932683333296,67,0.1527776249999988,3),vec4(48.775993333332956,74,0.1527776249999988,2),vec4(48.775993333332956,65,0.1527776249999988,3),vec4(48.942659833332954,72,0.1527776249999988,2),vec4(48.942659833332954,63,0.1527776249999988,3),vec4(49.10932633333295,62,0.1527776249999988,3),vec4(49.27599283333295,60,0.1527776249999988,3),vec4(49.10932633333295,34,0.31944412499999686,6),vec4(49.10932633333295,34,0.31944412499999686,7),vec4(49.10932633333295,46,0.31944412499999686,8),vec4(49.44265933333295,62,0.1527776249999988,3),vec4(49.609325833332946,65,0.1527776249999988,3),vec4(49.44265933333295,46,0.31944412499999686,6),vec4(49.44265933333295,46,0.31944412499999686,7),vec4(49.44265933333295,58,0.31944412499999686,8),vec4(49.775992333332944,63,0.1527776249999988,3),vec4(49.94265883333294,62,0.1527776249999988,3),vec4(49.775992333332944,36,0.31944412499999686,6),vec4(49.775992333332944,36,0.31944412499999686,7),vec4(49.775992333332944,48,0.31944412499999686,8),vec4(50.10932533333294,63,0.1527776249999988,3),vec4(50.27599183333294,67,0.1527776249999988,3),vec4(50.10932533333294,46,0.31944412499999686,6),vec4(50.10932533333294,46,0.31944412499999686,7),vec4(50.10932533333294,58,0.31944412499999686,8),vec4(50.442658333332936,65,0.1527776249999988,3),vec4(50.609324833332934,63,0.1527776249999988,3),vec4(50.442658333332936,38,0.31944412499999686,6),vec4(50.442658333332936,38,0.31944412499999686,7),vec4(50.442658333332936,50,0.31944412499999686,8),vec4(50.77599133333293,65,0.1527776249999988,3),vec4(50.94265783333293,68,0.1527776249999988,3),vec4(50.77599133333293,46,0.31944412499999686,6),vec4(50.77599133333293,46,0.31944412499999686,7),vec4(50.77599133333293,58,0.31944412499999686,8),vec4(49.10932633333295,70,2.1527756249999754,2),vec4(51.10932433333293,67,0.1527776249999988,3),vec4(51.275990833332926,69,0.1527776249999988,2),vec4(51.275990833332926,65,0.1527776249999988,3),vec4(51.10932433333293,39,0.31944412499999686,6),vec4(51.10932433333293,39,0.31944412499999686,7),vec4(51.10932433333293,51,0.31944412499999686,8),vec4(51.442657333332924,70,0.1527776249999988,2),vec4(51.442657333332924,67,0.1527776249999988,3),vec4(51.60932383333292,75,0.1527776249999988,2),vec4(51.60932383333292,70,0.1527776249999988,3),vec4(51.442657333332924,46,0.31944412499999686,6),vec4(51.442657333332924,46,0.31944412499999686,7),vec4(51.442657333332924,58,0.31944412499999686,8),vec4(51.77599033333292,70,0.1527776249999988,2),vec4(51.77599033333292,62,0.1527776249999988,3),vec4(51.94265683333292,69,0.1527776249999988,2),vec4(51.94265683333292,60,0.1527776249999988,3),vec4(51.77599033333292,41,0.31944412499999686,6),vec4(51.77599033333292,41,0.31944412499999686,7),vec4(51.77599033333292,53,0.31944412499999686,8),vec4(52.10932333333292,70,0.1527776249999988,2),vec4(52.10932333333292,62,0.1527776249999988,3),vec4(52.275989833332915,74,0.1527776249999988,2),vec4(52.275989833332915,70,0.1527776249999988,3),vec4(52.10932333333292,46,0.31944412499999686,6),vec4(52.10932333333292,46,0.31944412499999686,7),vec4(52.10932333333292,58,0.31944412499999686,8),vec4(52.44265633333291,63,0.1527776249999988,3),vec4(52.60932283333291,62,0.1527776249999988,3),vec4(52.44265633333291,43,0.31944412499999686,6),vec4(52.44265633333291,43,0.31944412499999686,7),vec4(52.44265633333291,55,0.31944412499999686,8),vec4(52.77598933333291,63,0.1527776249999988,3),vec4(52.94265583333291,70,0.1527776249999988,3),vec4(52.77598933333291,46,0.31944412499999686,6),vec4(52.77598933333291,46,0.31944412499999686,7),vec4(52.77598933333291,58,0.31944412499999686,8),vec4(52.44265633333291,72,0.819443624999991,2),vec4(53.2759888333329,79,0.1527776249999988,2),vec4(53.109322333332905,41,0.31944412499999686,6),vec4(53.109322333332905,41,0.31944412499999686,7),vec4(53.109322333332905,53,0.31944412499999686,8),vec4(53.4426553333329,77,0.1527776249999988,2),vec4(53.6093218333329,75,0.1527776249999988,2),vec4(53.109322333332905,62,0.652777124999993,3),vec4(53.4426553333329,46,0.31944412499999686,6),vec4(53.4426553333329,46,0.31944412499999686,7),vec4(53.4426553333329,58,0.31944412499999686,8),vec4(53.7759883333329,74,0.1527776249999988,2),vec4(53.942654833332895,82,0.1527776249999988,2),vec4(53.942654833332895,74,0.1527776249999988,3),vec4(53.7759883333329,39,0.31944412499999686,6),vec4(53.7759883333329,39,0.31944412499999686,7),vec4(53.7759883333329,51,0.31944412499999686,8),vec4(54.10932133333289,81,0.1527776249999988,2),vec4(54.10932133333289,72,0.1527776249999988,3),vec4(54.27598783333289,79,0.1527776249999988,2),vec4(54.27598783333289,70,0.1527776249999988,3),vec4(54.10932133333289,46,0.31944412499999686,6),vec4(54.10932133333289,46,0.31944412499999686,7),vec4(54.10932133333289,58,0.31944412499999686,8),vec4(54.44265433333289,77,0.1527776249999988,2),vec4(54.44265433333289,69,0.1527776249999988,3),vec4(54.60932083333289,75,0.1527776249999988,2),vec4(54.60932083333289,67,0.1527776249999988,3),vec4(54.44265433333289,41,0.31944412499999686,6),vec4(54.44265433333289,41,0.31944412499999686,7),vec4(54.44265433333289,53,0.31944412499999686,8),vec4(54.775987333332885,74,0.1527776249999988,2),vec4(54.775987333332885,65,0.1527776249999988,3),vec4(54.94265383333288,72,0.1527776249999988,2),vec4(54.94265383333288,63,0.1527776249999988,3),vec4(54.775987333332885,45,0.31944412499999686,6),vec4(54.775987333332885,45,0.31944412499999686,7),vec4(54.775987333332885,57,0.31944412499999686,8),vec4(55.10932033333288,62,0.1527776249999988,3),vec4(55.10932033333288,70,0.31944412499999686,2),vec4(55.27598683333288,70,0.1527776249999988,3),vec4(55.44265333333288,69,0.1527776249999988,3),vec4(55.44265333333288,77,0.31944412499999686,2),vec4(55.609319833332876,70,0.1527776249999988,3),vec4(55.10932033333288,34,0.652777124999993,6),vec4(55.10932033333288,34,0.652777124999993,7),vec4(55.10932033333288,46,0.652777124999993,8),vec4(55.775986333332874,63,0.1527776249999988,3),vec4(55.775986333332874,79,0.31944412499999686,2),vec4(55.94265283333287,70,0.1527776249999988,3),vec4(56.10931933333287,62,0.1527776249999988,3),vec4(56.10931933333287,77,0.31944412499999686,2),vec4(56.27598583333287,70,0.1527776249999988,3),vec4(56.442652333332866,63,0.1527776249999988,3),vec4(56.442652333332866,79,0.31944412499999686,2),vec4(56.609318833332864,70,0.1527776249999988,3),vec4(56.77598533333286,60,0.1527776249999988,3),vec4(56.77598533333286,75,0.31944412499999686,2),vec4(56.94265183333286,70,0.1527776249999988,3),vec4(57.10931833333286,77,0.1527776249999988,2),vec4(57.275984833332856,82,0.1527776249999988,2),vec4(57.10931833333286,62,0.31944412499999686,3),vec4(57.442651333332854,81,0.1527776249999988,2),vec4(57.60931783333285,82,0.1527776249999988,2),vec4(57.442651333332854,65,0.31944412499999686,3),vec4(57.10931833333286,34,0.652777124999993,6),vec4(57.10931833333286,34,0.652777124999993,7),vec4(57.10931833333286,46,0.652777124999993,8),vec4(57.77598433333285,75,0.1527776249999988,2),vec4(57.94265083333285,82,0.1527776249999988,2),vec4(57.77598433333285,67,0.31944412499999686,3),vec4(58.10931733333285,74,0.1527776249999988,2),vec4(58.275983833332845,82,0.1527776249999988,2),vec4(58.10931733333285,65,0.31944412499999686,3),vec4(58.44265033333284,75,0.1527776249999988,2),vec4(58.60931683333284,82,0.1527776249999988,2),vec4(58.44265033333284,67,0.31944412499999686,3),vec4(58.77598333333284,72,0.1527776249999988,2),vec4(58.94264983333284,82,0.1527776249999988,2),vec4(58.77598333333284,63,0.31944412499999686,3),vec4(59.109316333332835,65,0.1527776249999988,3),vec4(59.27598283333283,58,0.1527776249999988,3),vec4(59.44264933333283,60,0.1527776249999988,3),vec4(59.60931583333283,62,0.1527776249999988,3),vec4(59.44264933333283,41,0.31944412499999686,6),vec4(59.44264933333283,41,0.31944412499999686,7),vec4(59.44264933333283,53,0.31944412499999686,8),vec4(59.109316333332835,74,0.819443624999991,2),vec4(59.942648833332825,70,0.1527776249999988,2),vec4(59.77598233333283,43,0.31944412499999686,6),vec4(59.77598233333283,43,0.31944412499999686,7),vec4(59.77598233333283,55,0.31944412499999686,8),vec4(60.10931533333282,72,0.1527776249999988,2),vec4(60.27598183333282,74,0.1527776249999988,2),vec4(60.10931533333282,41,0.31944412499999686,6),vec4(60.10931533333282,41,0.31944412499999686,7),vec4(60.10931533333282,53,0.31944412499999686,8),vec4(60.44264833333282,75,0.1527776249999988,2),vec4(59.77598233333283,63,0.819443624999991,3),vec4(60.60931483333282,77,0.1527776249999988,2),vec4(60.60931483333282,62,0.1527776249999988,3),vec4(60.44264833333282,43,0.31944412499999686,6),vec4(60.44264833333282,43,0.31944412499999686,7),vec4(60.44264833333282,55,0.31944412499999686,8),vec4(60.775981333332815,79,0.1527776249999988,2),vec4(60.775981333332815,63,0.1527776249999988,3),vec4(60.94264783333281,81,0.1527776249999988,2),vec4(60.94264783333281,60,0.1527776249999988,3),vec4(60.775981333332815,39,0.31944412499999686,6),vec4(60.775981333332815,39,0.31944412499999686,7),vec4(60.775981333332815,51,0.31944412499999686,8),vec4(61.10931433333281,82,0.31944412499999686,2),vec4(61.10931433333281,65,0.31944412499999686,3),vec4(61.10931433333281,38,0.31944412499999686,6),vec4(61.10931433333281,38,0.31944412499999686,7),vec4(61.10931433333281,50,0.31944412499999686,8),vec4(61.44264733333281,70,0.31944412499999686,2),vec4(61.44264733333281,62,0.31944412499999686,3),vec4(61.44264733333281,43,0.31944412499999686,6),vec4(61.44264733333281,43,0.31944412499999686,7),vec4(61.44264733333281,55,0.31944412499999686,8),vec4(61.775980333332804,72,0.31944412499999686,2),vec4(61.775980333332804,63,0.31944412499999686,3),vec4(61.775980333332804,39,0.31944412499999686,6),vec4(61.775980333332804,39,0.31944412499999686,7),vec4(61.775980333332804,51,0.31944412499999686,8),vec4(62.4426463333328,70,0.1527776249999988,2),vec4(62.4426463333328,62,0.1527776249999988,3),vec4(62.6093128333328,69,0.0763888124999994,2),vec4(62.6093128333328,60,0.0763888124999994,3),vec4(62.692646083332804,70,0.0763888124999994,2),vec4(62.692646083332804,62,0.0763888124999994,3),vec4(62.775979333332806,69,0.31944412499999686,2),vec4(62.775979333332806,60,0.31944412499999686,3),vec4(62.4426463333328,41,0.6527771250000001,6),vec4(62.4426463333328,41,0.6527771250000001,7),vec4(62.4426463333328,53,0.6527771250000001,8),vec4(63.1093123333328,70,1.3194431249999994,2),vec4(63.1093123333328,62,1.3194431249999994,3),vec4(63.1093123333328,34,1.3194431249999994,6),vec4(63.1093123333328,34,1.3194431249999994,7),vec4(63.1093123333328,46,1.3194431249999994,8),vec4(65.1093103333328,77,0.31944412500000396,3),vec4(65.44264333333281,65,0.31944412500000396,3),vec4(65.77597633333282,75,0.31944412500000396,3),vec4(66.10930933333283,65,0.31944412500000396,3),vec4(65.1093103333328,34,1.319443125000035,6),vec4(65.1093103333328,34,1.319443125000035,7),vec4(65.1093103333328,46,1.319443125000035,8),vec4(66.44264233333284,74,0.31944412500000396,3),vec4(66.77597533333285,65,0.31944412500000396,3),vec4(67.10930833333286,72,0.31944412500000396,3),vec4(67.44264133333287,65,0.31944412500000396,3),vec4(67.77597433333288,70,0.31944412500000396,3),vec4(68.1093073333329,65,0.31944412500000396,3),vec4(67.10930833333286,39,1.319443125000035,6),vec4(67.10930833333286,39,1.319443125000035,7),vec4(67.10930833333286,51,1.319443125000035,8),vec4(68.4426403333329,69,0.31944412500000396,3),vec4(68.77597333333291,65,0.31944412500000396,3),vec4(69.10930633333292,70,0.1527776249999988,3),vec4(69.27597283333293,65,0.1527776249999988,3),vec4(69.44263933333293,67,0.1527776249999988,3),vec4(69.60930583333294,69,0.1527776249999988,3),vec4(69.10930633333292,38,0.6527771250000143,6),vec4(69.10930633333292,38,0.6527771250000143,7),vec4(69.10930633333292,50,0.6527771250000143,8),vec4(69.77597233333294,70,0.1527776249999988,3),vec4(69.94263883333295,62,0.1527776249999988,3),vec4(70.10930533333296,63,0.1527776249999988,3),vec4(70.27597183333296,65,0.1527776249999988,3),vec4(69.77597233333294,43,0.6527771250000143,6),vec4(69.77597233333294,43,0.6527771250000143,7),vec4(69.77597233333294,55,0.6527771250000143,8),vec4(70.44263833333297,67,0.1527776249999988,3),vec4(70.60930483333297,69,0.1527776249999988,3),vec4(70.77597133333298,70,0.1527776249999988,3),vec4(70.94263783333298,72,0.1527776249999988,3),vec4(70.44263833333297,41,0.6527771250000143,6),vec4(70.44263833333297,41,0.6527771250000143,7),vec4(70.44263833333297,53,0.6527771250000143,8),vec4(71.10930433333299,74,0.1527776249999988,3),vec4(71.27597083333299,72,0.1527776249999988,3),vec4(71.442637333333,70,0.1527776249999988,3),vec4(71.609303833333,74,0.1527776249999988,3),vec4(71.10930433333299,46,0.6527771250000143,6),vec4(71.10930433333299,46,0.6527771250000143,7),vec4(71.10930433333299,58,0.6527771250000143,8),vec4(71.775970333333,77,0.1527776249999988,3),vec4(71.94263683333301,74,0.1527776249999988,3),vec4(72.10930333333302,70,0.1527776249999988,3),vec4(72.27596983333302,65,0.1527776249999988,3),vec4(71.775970333333,38,0.6527771250000143,6),vec4(71.775970333333,38,0.6527771250000143,7),vec4(71.775970333333,50,0.6527771250000143,8),vec4(72.44263633333303,74,0.1527776249999988,3),vec4(72.60930283333303,70,0.1527776249999988,3),vec4(72.77596933333304,68,0.1527776249999988,3),vec4(72.94263583333304,65,0.1527776249999988,3),vec4(72.44263633333303,34,0.6527771250000143,6),vec4(72.44263633333303,34,0.6527771250000143,7),vec4(72.44263633333303,46,0.6527771250000143,8),vec4(73.10930233333305,67,0.1527776249999988,3),vec4(73.10930233333305,82,0.31944412500000396,2),vec4(73.27596883333305,68,0.1527776249999988,3),vec4(73.44263533333306,67,0.1527776249999988,3),vec4(73.44263533333306,70,0.31944412500000396,2),vec4(73.60930183333306,63,0.1527776249999988,3),vec4(73.77596833333307,65,0.1527776249999988,3),vec4(73.77596833333307,80,0.31944412500000396,2),vec4(73.94263483333307,67,0.1527776249999988,3),vec4(74.10930133333308,65,0.1527776249999988,3),vec4(74.10930133333308,70,0.31944412500000396,2),vec4(74.27596783333308,62,0.1527776249999988,3),vec4(73.10930233333305,39,1.319443125000035,6),vec4(73.10930233333305,39,1.319443125000035,7),vec4(73.10930233333305,51,1.319443125000035,8),vec4(74.44263433333309,63,0.1527776249999988,3),vec4(74.44263433333309,79,0.31944412500000396,2),vec4(74.6093008333331,65,0.1527776249999988,3),vec4(74.7759673333331,63,0.1527776249999988,3),vec4(74.7759673333331,70,0.31944412500000396,2),vec4(74.9426338333331,60,0.1527776249999988,3),vec4(75.10930033333311,62,0.1527776249999988,3),vec4(75.10930033333311,77,0.31944412500000396,2),vec4(75.27596683333311,63,0.1527776249999988,3),vec4(75.44263333333312,62,0.1527776249999988,3),vec4(75.44263333333312,70,0.31944412500000396,2),vec4(75.60929983333313,58,0.1527776249999988,3),vec4(75.77596633333313,67,0.1527776249999988,3),vec4(75.77596633333313,75,0.31944412500000396,2),vec4(75.94263283333314,68,0.1527776249999988,3),vec4(76.10929933333314,67,0.1527776249999988,3),vec4(76.10929933333314,70,0.31944412500000396,2),vec4(76.27596583333315,58,0.1527776249999988,3),vec4(75.10930033333311,46,1.319443125000035,6),vec4(75.10930033333311,46,1.319443125000035,7),vec4(75.10930033333311,58,1.319443125000035,8),vec4(76.44263233333315,65,0.1527776249999988,3),vec4(76.44263233333315,74,0.31944412500000396,2),vec4(76.60929883333316,67,0.1527776249999988,3),vec4(76.77596533333316,65,0.1527776249999988,3),vec4(76.77596533333316,70,0.31944412500000396,2),vec4(76.94263183333317,58,0.1527776249999988,3),vec4(76.44263233333315,44,0.6527771250000143,6),vec4(76.44263233333315,44,0.6527771250000143,7),vec4(76.44263233333315,56,0.6527771250000143,8),vec4(77.10929833333317,75,0.1527776249999988,2),vec4(77.27596483333318,70,0.1527776249999988,2),vec4(77.10929833333317,67,0.31944412500000396,3),vec4(77.44263133333318,72,0.1527776249999988,2),vec4(77.60929783333319,74,0.1527776249999988,2),vec4(77.44263133333318,63,0.31944412500000396,3),vec4(77.10929833333317,43,0.6527771250000143,6),vec4(77.10929833333317,43,0.6527771250000143,7),vec4(77.10929833333317,55,0.6527771250000143,8),vec4(77.77596433333319,75,0.1527776249999988,2),vec4(77.9426308333332,67,0.1527776249999988,2),vec4(77.77596433333319,58,0.31944412500000396,3),vec4(78.1092973333332,68,0.1527776249999988,2),vec4(78.27596383333321,70,0.1527776249999988,2),vec4(78.1092973333332,67,0.31944412500000396,3),vec4(77.77596433333319,31,0.6527771250000143,6),vec4(77.77596433333319,31,0.6527771250000143,7),vec4(77.77596433333319,43,0.6527771250000143,8),vec4(78.44263033333321,72,0.1527776249999988,2),vec4(78.60929683333322,74,0.1527776249999988,2),vec4(78.44263033333321,65,0.31944412500000396,3),vec4(78.77596333333322,75,0.1527776249999988,2),vec4(78.94262983333323,77,0.1527776249999988,2),vec4(78.77596333333322,62,0.31944412500000396,3),vec4(78.44263033333321,34,0.6527771250000143,6),vec4(78.44263033333321,34,0.6527771250000143,7),vec4(78.44263033333321,46,0.6527771250000143,8),vec4(79.10929633333323,79,0.1527776249999988,2),vec4(79.27596283333324,77,0.1527776249999988,2),vec4(79.10929633333323,63,0.31944412500000396,3),vec4(79.44262933333324,75,0.1527776249999988,2),vec4(79.60929583333325,79,0.1527776249999988,2),vec4(79.44262933333324,70,0.31944412500000396,3),vec4(79.77596233333325,82,0.1527776249999988,2),vec4(79.94262883333326,79,0.1527776249999988,2),vec4(79.77596233333325,67,0.31944412500000396,3),vec4(80.10929533333326,75,0.1527776249999988,2),vec4(80.27596183333327,70,0.1527776249999988,2),vec4(80.10929533333326,70,0.31944412500000396,3),vec4(79.10929633333323,27,1.319443125000035,6),vec4(79.10929633333323,27,1.319443125000035,7),vec4(79.10929633333323,39,1.319443125000035,8),vec4(80.44262833333327,79,0.1527776249999988,2),vec4(80.60929483333328,75,0.1527776249999988,2),vec4(80.44262833333327,73,0.31944412500000396,3),vec4(80.77596133333329,73,0.1527776249999988,2),vec4(80.94262783333329,70,0.1527776249999988,2),vec4(80.77596133333329,67,0.31944412500000396,3),vec4(81.1092943333333,72,0.1527776249999988,2),vec4(81.2759608333333,73,0.1527776249999988,2),vec4(81.1092943333333,68,0.31944412500000396,3),vec4(81.4426273333333,72,0.1527776249999988,2),vec4(81.60929383333331,68,0.1527776249999988,2),vec4(81.4426273333333,39,0.31944412500000396,6),vec4(81.4426273333333,39,0.31944412500000396,7),vec4(81.4426273333333,51,0.31944412500000396,8),vec4(81.77596033333332,70,0.1527776249999988,2),vec4(81.94262683333332,72,0.1527776249999988,2),vec4(81.77596033333332,67,0.31944412500000396,3),vec4(81.77596033333332,49,0.31944412500000396,6),vec4(81.77596033333332,49,0.31944412500000396,7),vec4(81.77596033333332,61,0.31944412500000396,8),vec4(82.10929333333333,70,0.1527776249999988,2),vec4(82.27595983333333,67,0.1527776249999988,2),vec4(82.10929333333333,39,0.31944412500000396,6),vec4(82.10929333333333,39,0.31944412500000396,7),vec4(82.10929333333333,51,0.31944412500000396,8),vec4(82.44262633333334,68,0.1527776249999988,2),vec4(82.60929283333334,70,0.1527776249999988,2),vec4(82.44262633333334,63,0.31944412500000396,3),vec4(82.44262633333334,48,0.31944412500000396,6),vec4(82.44262633333334,48,0.31944412500000396,7),vec4(82.44262633333334,60,0.31944412500000396,8),vec4(82.77595933333335,68,0.1527776249999988,2),vec4(82.94262583333335,65,0.1527776249999988,2));\n    const vec4 _1[682] = vec4[682](vec4(82.77595933333335,39,0.31944412500000396,6),vec4(82.77595933333335,39,0.31944412500000396,7),vec4(82.77595933333335,51,0.31944412500000396,8),vec4(83.10929233333336,67,0.1527776249999988,2),vec4(83.27595883333336,68,0.1527776249999988,2),vec4(83.10929233333336,63,0.31944412500000396,3),vec4(83.10929233333336,46,0.31944412500000396,6),vec4(83.10929233333336,46,0.31944412500000396,7),vec4(83.10929233333336,58,0.31944412500000396,8),vec4(83.44262533333337,67,0.1527776249999988,2),vec4(83.60929183333337,63,0.1527776249999988,2),vec4(83.44262533333337,39,0.31944412500000396,6),vec4(83.44262533333337,39,0.31944412500000396,7),vec4(83.44262533333337,51,0.31944412500000396,8),vec4(83.77595833333338,72,0.1527776249999988,2),vec4(83.94262483333338,73,0.1527776249999988,2),vec4(83.77595833333338,63,0.31944412500000396,3),vec4(83.77595833333338,44,0.31944412500000396,6),vec4(83.77595833333338,44,0.31944412500000396,7),vec4(83.77595833333338,56,0.31944412500000396,8),vec4(84.10929133333339,72,0.1527776249999988,2),vec4(84.2759578333334,63,0.1527776249999988,2),vec4(84.10929133333339,39,0.31944412500000396,6),vec4(84.10929133333339,39,0.31944412500000396,7),vec4(84.10929133333339,51,0.31944412500000396,8),vec4(84.4426243333334,70,0.1527776249999988,2),vec4(84.6092908333334,72,0.1527776249999988,2),vec4(84.4426243333334,63,0.31944412500000396,3),vec4(84.4426243333334,43,0.31944412500000396,6),vec4(84.4426243333334,43,0.31944412500000396,7),vec4(84.4426243333334,55,0.31944412500000396,8),vec4(84.77595733333341,70,0.1527776249999988,2),vec4(84.94262383333341,63,0.1527776249999988,2),vec4(84.77595733333341,39,0.31944412500000396,6),vec4(84.77595733333341,39,0.31944412500000396,7),vec4(84.77595733333341,51,0.31944412500000396,8),vec4(85.10929033333342,72,0.31944412500000396,2),vec4(85.27595683333342,63,0.1527776249999988,3),vec4(85.10929033333342,44,0.31944412500000396,6),vec4(85.10929033333342,44,0.31944412500000396,7),vec4(85.10929033333342,56,0.31944412500000396,8),vec4(85.44262333333343,65,0.1527776249999988,3),vec4(85.44262333333343,68,0.31944412500000396,2),vec4(85.60928983333343,67,0.1527776249999988,3),vec4(85.77595633333344,68,0.1527776249999988,3),vec4(85.77595633333344,72,0.31944412500000396,2),vec4(85.94262283333344,70,0.1527776249999988,3),vec4(85.77595633333344,43,0.31944412500000396,6),vec4(85.77595633333344,43,0.31944412500000396,7),vec4(85.77595633333344,55,0.31944412500000396,8),vec4(86.10928933333345,72,0.1527776249999988,3),vec4(86.10928933333345,63,0.31944412500000396,2),vec4(86.27595583333346,70,0.1527776249999988,3),vec4(86.44262233333346,68,0.1527776249999988,3),vec4(86.44262233333346,65,0.31944412500000396,2),vec4(86.60928883333347,67,0.1527776249999988,3),vec4(86.44262233333346,41,0.31944412500000396,6),vec4(86.44262233333346,41,0.31944412500000396,7),vec4(86.44262233333346,53,0.31944412500000396,8),vec4(86.77595533333347,65,0.1527776249999988,3),vec4(86.77595533333347,74,0.31944412500000396,2),vec4(86.94262183333348,68,0.1527776249999988,3),vec4(87.27595483333349,75,0.1527776249999988,2),vec4(87.10928833333348,67,0.31944412500000396,3),vec4(87.44262133333349,77,0.1527776249999988,2),vec4(87.6092878333335,79,0.1527776249999988,2),vec4(87.44262133333349,58,0.31944412500000396,3),vec4(87.7759543333335,80,0.1527776249999988,2),vec4(87.9426208333335,82,0.1527776249999988,2),vec4(87.7759543333335,60,0.31944412500000396,3),vec4(88.10928733333351,84,0.1527776249999988,2),vec4(88.27595383333352,82,0.1527776249999988,2),vec4(88.10928733333351,56,0.31944412500000396,3),vec4(87.10928833333348,39,1.319443125000035,6),vec4(87.10928833333348,39,1.319443125000035,7),vec4(87.10928833333348,51,1.319443125000035,8),vec4(88.44262033333352,80,0.1527776249999988,2),vec4(88.60928683333353,79,0.1527776249999988,2),vec4(88.77595333333353,77,0.1527776249999988,2),vec4(88.94261983333354,80,0.1527776249999988,2),vec4(88.44262033333352,38,0.6527771250000143,6),vec4(88.44262033333352,38,0.6527771250000143,7),vec4(88.44262033333352,50,0.6527771250000143,8),vec4(88.44262033333352,65,0.8194436250000194,3),vec4(89.10928633333354,79,0.31944412500000396,2),vec4(89.27595283333355,63,0.1527776249999988,3),vec4(89.44261933333355,65,0.1527776249999988,3),vec4(89.44261933333355,72,0.31944412500000396,2),vec4(89.60928583333356,67,0.1527776249999988,3),vec4(89.10928633333354,39,0.6527771250000143,6),vec4(89.10928633333354,39,0.6527771250000143,7),vec4(89.10928633333354,51,0.6527771250000143,8),vec4(89.77595233333356,69,0.1527776249999988,3),vec4(89.77595233333356,77,0.31944412500000396,2),vec4(89.94261883333357,71,0.1527776249999988,3),vec4(90.10928533333357,72,0.1527776249999988,3),vec4(90.27595183333358,74,0.1527776249999988,3),vec4(89.77595233333356,38,0.6527771250000143,6),vec4(89.77595233333356,38,0.6527771250000143,7),vec4(89.77595233333356,50,0.6527771250000143,8),vec4(90.44261833333358,75,0.1527776249999988,3),vec4(90.10928533333357,68,0.6527771250000143,2),vec4(90.60928483333359,77,0.1527776249999988,3),vec4(90.7759513333336,75,0.1527776249999988,3),vec4(90.7759513333336,77,0.31944412500000396,2),vec4(90.9426178333336,68,0.1527776249999988,3),vec4(90.44261833333358,36,0.6527771250000143,6),vec4(90.44261833333358,36,0.6527771250000143,7),vec4(90.44261833333358,48,0.6527771250000143,8),vec4(91.1092843333336,67,0.1527776249999988,2),vec4(91.1092843333336,77,0.1527776249999988,3),vec4(91.27595083333361,71,0.1527776249999988,2),vec4(91.27595083333361,67,0.1527776249999988,3),vec4(91.1092843333336,35,0.31944412500000396,6),vec4(91.1092843333336,35,0.31944412500000396,7),vec4(91.1092843333336,47,0.31944412500000396,8),vec4(91.44261733333362,72,0.1527776249999988,2),vec4(91.44261733333362,69,0.1527776249999988,3),vec4(91.60928383333362,74,0.1527776249999988,2),vec4(91.60928383333362,71,0.1527776249999988,3),vec4(91.44261733333362,41,0.31944412500000396,6),vec4(91.44261733333362,41,0.31944412500000396,7),vec4(91.44261733333362,53,0.31944412500000396,8),vec4(91.77595033333363,75,0.1527776249999988,2),vec4(91.77595033333363,72,0.1527776249999988,3),vec4(91.94261683333363,77,0.1527776249999988,2),vec4(91.94261683333363,74,0.1527776249999988,3),vec4(91.77595033333363,39,0.31944412500000396,6),vec4(91.77595033333363,39,0.31944412500000396,7),vec4(91.77595033333363,51,0.31944412500000396,8),vec4(92.10928333333364,79,0.1527776249999988,2),vec4(92.10928333333364,75,0.1527776249999988,3),vec4(92.27594983333364,80,0.1527776249999988,2),vec4(92.27594983333364,77,0.1527776249999988,3),vec4(92.10928333333364,38,0.31944412500000396,6),vec4(92.10928333333364,38,0.31944412500000396,7),vec4(92.10928333333364,50,0.31944412500000396,8),vec4(92.44261633333365,82,0.1527776249999988,2),vec4(92.60928283333365,84,0.1527776249999988,2),vec4(92.44261633333365,36,0.31944412500000396,6),vec4(92.44261633333365,36,0.31944412500000396,7),vec4(92.44261633333365,48,0.31944412500000396,8),vec4(92.77594933333366,82,0.1527776249999988,2),vec4(92.94261583333366,72,0.1527776249999988,2),vec4(92.77594933333366,40,0.31944412500000396,6),vec4(92.77594933333366,40,0.31944412500000396,7),vec4(92.77594933333366,52,0.31944412500000396,8),vec4(93.10928233333367,80,0.1527776249999988,2),vec4(92.44261633333365,79,0.8194436250000194,3),vec4(93.27594883333367,79,0.1527776249999988,2),vec4(93.27594883333367,70,0.1527776249999988,3),vec4(93.44261533333368,77,0.1527776249999988,2),vec4(93.44261533333368,68,0.1527776249999988,3),vec4(93.60928183333368,76,0.1527776249999988,2),vec4(93.60928183333368,67,0.1527776249999988,3),vec4(93.10928233333367,29,0.6527771250000143,6),vec4(93.10928233333367,29,0.6527771250000143,7),vec4(93.10928233333367,41,0.6527771250000143,8),vec4(93.77594833333369,77,0.1527776249999988,2),vec4(93.94261483333369,75,0.1527776249999988,2),vec4(94.1092813333337,73,0.1527776249999988,2),vec4(94.2759478333337,72,0.1527776249999988,2),vec4(93.77594833333369,68,0.8194436250000194,3),vec4(94.60928083333371,68,0.1527776249999988,3),vec4(94.77594733333372,67,0.1527776249999988,3),vec4(94.94261383333372,65,0.1527776249999988,3),vec4(93.77594833333369,37,1.319443125000035,6),vec4(93.77594833333369,37,1.319443125000035,7),vec4(93.77594833333369,49,1.319443125000035,8),vec4(94.44261433333371,70,0.8194436250000194,2),vec4(95.10928033333373,64,0.1527776249999988,3),vec4(95.27594683333373,68,0.1527776249999988,2),vec4(95.27594683333373,65,0.1527776249999988,3),vec4(95.44261333333374,67,0.1527776249999988,2),vec4(95.44261333333374,64,0.1527776249999988,3),vec4(95.60927983333374,65,0.1527776249999988,2),vec4(95.60927983333374,62,0.1527776249999988,3),vec4(95.10928033333373,36,0.6527771250000143,6),vec4(95.10928033333373,36,0.6527771250000143,7),vec4(95.10928033333373,48,0.6527771250000143,8),vec4(95.77594633333375,64,0.31944412500000396,2),vec4(95.77594633333375,60,0.31944412500000396,3),vec4(95.94261283333375,48,0.1527776249999988,6),vec4(95.94261283333375,48,0.1527776249999988,7),vec4(95.94261283333375,60,0.1527776249999988,8),vec4(96.10927933333376,46,0.1527776249999988,6),vec4(96.10927933333376,46,0.1527776249999988,7),vec4(96.10927933333376,58,0.1527776249999988,8),vec4(96.10927933333376,72,0.31944412500000396,2),vec4(96.10927933333376,64,0.31944412500000396,3),vec4(96.27594583333376,48,0.1527776249999988,6),vec4(96.27594583333376,48,0.1527776249999988,7),vec4(96.27594583333376,60,0.1527776249999988,8),vec4(96.44261233333377,44,0.1527776249999988,6),vec4(96.44261233333377,44,0.1527776249999988,7),vec4(96.44261233333377,56,0.1527776249999988,8),vec4(96.44261233333377,74,0.31944412500000396,2),vec4(96.44261233333377,65,0.31944412500000396,3),vec4(96.60927883333378,46,0.1527776249999988,6),vec4(96.60927883333378,46,0.1527776249999988,7),vec4(96.60927883333378,58,0.1527776249999988,8),vec4(96.77594533333378,43,0.1527776249999988,6),vec4(96.77594533333378,43,0.1527776249999988,7),vec4(96.77594533333378,55,0.1527776249999988,8),vec4(96.77594533333378,76,0.31944412500000396,2),vec4(96.77594533333378,67,0.31944412500000396,3),vec4(96.94261183333379,44,0.1527776249999988,6),vec4(96.94261183333379,44,0.1527776249999988,7),vec4(96.94261183333379,56,0.1527776249999988,8),vec4(97.10927833333379,68,0.1527776249999988,3),vec4(97.10927833333379,77,0.31944412500000396,2),vec4(97.2759448333338,65,0.1527776249999988,3),vec4(97.10927833333379,41,0.31944412500000396,6),vec4(97.10927833333379,41,0.31944412500000396,7),vec4(97.10927833333379,53,0.31944412500000396,8),vec4(97.4426113333338,64,0.1527776249999988,3),vec4(97.6092778333338,65,0.1527776249999988,3),vec4(97.4426113333338,44,0.31944412500000396,6),vec4(97.4426113333338,44,0.31944412500000396,7),vec4(97.4426113333338,56,0.31944412500000396,8),vec4(97.77594433333381,60,0.1527776249999988,3),vec4(97.94261083333382,65,0.1527776249999988,3),vec4(97.77594433333381,41,0.31944412500000396,6),vec4(97.77594433333381,41,0.31944412500000396,7),vec4(97.77594433333381,53,0.31944412500000396,8),vec4(98.10927733333382,64,0.1527776249999988,3),vec4(98.27594383333383,65,0.1527776249999988,3),vec4(98.10927733333382,44,0.31944412500000396,6),vec4(98.10927733333382,44,0.31944412500000396,7),vec4(98.10927733333382,56,0.31944412500000396,8),vec4(98.44261033333383,68,0.1527776249999988,3),vec4(98.60927683333384,65,0.1527776249999988,3),vec4(98.44261033333383,41,0.31944412500000396,6),vec4(98.44261033333383,41,0.31944412500000396,7),vec4(98.44261033333383,53,0.31944412500000396,8),vec4(98.77594333333384,63,0.1527776249999988,3),vec4(98.94260983333385,65,0.1527776249999988,3),vec4(98.77594333333384,44,0.31944412500000396,6),vec4(98.77594333333384,44,0.31944412500000396,7),vec4(98.77594333333384,56,0.31944412500000396,8),vec4(99.27594283333386,70,0.1527776249999988,2),vec4(99.10927633333385,61,0.31944412500000396,3),vec4(99.10927633333385,34,0.31944412500000396,6),vec4(99.10927633333385,34,0.31944412500000396,7),vec4(99.10927633333385,46,0.31944412500000396,8),vec4(99.44260933333386,68,0.1527776249999988,2),vec4(99.60927583333387,70,0.1527776249999988,2),vec4(99.44260933333386,49,0.31944412500000396,6),vec4(99.44260933333386,49,0.31944412500000396,7),vec4(99.44260933333386,61,0.31944412500000396,8),vec4(99.77594233333387,65,0.1527776249999988,2),vec4(99.94260883333388,70,0.1527776249999988,2),vec4(99.77594233333387,68,0.31944412500000396,3),vec4(99.77594233333387,34,0.31944412500000396,6),vec4(99.77594233333387,34,0.31944412500000396,7),vec4(99.77594233333387,46,0.31944412500000396,8),vec4(100.10927533333388,68,0.1527776249999988,2),vec4(100.27594183333389,70,0.1527776249999988,2),vec4(100.10927533333388,49,0.31944412500000396,6),vec4(100.10927533333388,49,0.31944412500000396,7),vec4(100.10927533333388,61,0.31944412500000396,8),vec4(100.4426083333339,73,0.1527776249999988,2),vec4(100.6092748333339,70,0.1527776249999988,2),vec4(100.4426083333339,68,0.31944412500000396,3),vec4(100.4426083333339,34,0.31944412500000396,6),vec4(100.4426083333339,34,0.31944412500000396,7),vec4(100.4426083333339,46,0.31944412500000396,8),vec4(100.7759413333339,68,0.1527776249999988,2),vec4(100.94260783333391,70,0.1527776249999988,2),vec4(100.7759413333339,49,0.31944412500000396,6),vec4(100.7759413333339,49,0.31944412500000396,7),vec4(100.7759413333339,61,0.31944412500000396,8),vec4(101.10927433333391,67,0.31944412500000396,2),vec4(101.27594083333392,63,0.1527776249999988,3),vec4(101.10927433333391,39,0.31944412500000396,6),vec4(101.10927433333391,39,0.31944412500000396,7),vec4(101.10927433333391,51,0.31944412500000396,8),vec4(101.44260733333392,61,0.1527776249999988,3),vec4(101.60927383333393,63,0.1527776249999988,3),vec4(101.44260733333392,43,0.31944412500000396,6),vec4(101.44260733333392,43,0.31944412500000396,7),vec4(101.44260733333392,55,0.31944412500000396,8),vec4(101.77594033333393,58,0.1527776249999988,3),vec4(101.77594033333393,73,0.31944412500000396,2),vec4(101.94260683333394,63,0.1527776249999988,3),vec4(101.77594033333393,39,0.31944412500000396,6),vec4(101.77594033333393,39,0.31944412500000396,7),vec4(101.77594033333393,51,0.31944412500000396,8),vec4(102.10927333333395,61,0.1527776249999988,3),vec4(102.27593983333395,63,0.1527776249999988,3),vec4(102.10927333333395,43,0.31944412500000396,6),vec4(102.10927333333395,43,0.31944412500000396,7),vec4(102.10927333333395,55,0.31944412500000396,8),vec4(102.44260633333396,67,0.1527776249999988,3),vec4(102.44260633333396,73,0.31944412500000396,2),vec4(102.60927283333396,63,0.1527776249999988,3),vec4(102.44260633333396,39,0.31944412500000396,6),vec4(102.44260633333396,39,0.31944412500000396,7),vec4(102.44260633333396,51,0.31944412500000396,8),vec4(102.77593933333397,61,0.1527776249999988,3),vec4(102.94260583333397,63,0.1527776249999988,3),vec4(102.77593933333397,43,0.31944412500000396,6),vec4(102.77593933333397,43,0.31944412500000396,7),vec4(102.77593933333397,55,0.31944412500000396,8),vec4(103.27593883333398,68,0.1527776249999988,2),vec4(103.10927233333398,60,0.31944412500000396,3),vec4(103.10927233333398,32,0.31944412500000396,6),vec4(103.10927233333398,32,0.31944412500000396,7),vec4(103.10927233333398,44,0.31944412500000396,8),vec4(103.44260533333399,66,0.1527776249999988,2),vec4(103.60927183333399,68,0.1527776249999988,2),vec4(103.44260533333399,48,0.31944412500000396,6),vec4(103.44260533333399,48,0.31944412500000396,7),vec4(103.44260533333399,60,0.31944412500000396,8),vec4(103.775938333334,63,0.1527776249999988,2),vec4(103.942604833334,68,0.1527776249999988,2),vec4(103.775938333334,66,0.31944412500000396,3),vec4(103.775938333334,32,0.31944412500000396,6),vec4(103.775938333334,32,0.31944412500000396,7),vec4(103.775938333334,44,0.31944412500000396,8),vec4(104.10927133333401,66,0.1527776249999988,2),vec4(104.27593783333401,68,0.1527776249999988,2),vec4(104.10927133333401,48,0.31944412500000396,6),vec4(104.10927133333401,48,0.31944412500000396,7),vec4(104.10927133333401,60,0.31944412500000396,8),vec4(104.44260433333402,72,0.1527776249999988,2),vec4(104.60927083333402,68,0.1527776249999988,2),vec4(104.44260433333402,66,0.31944412500000396,3),vec4(104.44260433333402,32,0.31944412500000396,6),vec4(104.44260433333402,32,0.31944412500000396,7),vec4(104.44260433333402,44,0.31944412500000396,8),vec4(104.77593733333403,66,0.1527776249999988,2),vec4(104.94260383333403,68,0.1527776249999988,2),vec4(104.77593733333403,48,0.31944412500000396,6),vec4(104.77593733333403,48,0.31944412500000396,7),vec4(104.77593733333403,60,0.31944412500000396,8),vec4(105.10927033333404,65,0.1527776249999988,2),vec4(105.27593683333404,70,0.1527776249999988,2),vec4(105.27593683333404,61,0.1527776249999988,3),vec4(105.10927033333404,37,0.31944412500000396,6),vec4(105.10927033333404,37,0.31944412500000396,7),vec4(105.10927033333404,49,0.31944412500000396,8),vec4(105.44260333333405,69,0.1527776249999988,2),vec4(105.44260333333405,60,0.1527776249999988,3),vec4(105.60926983333405,70,0.1527776249999988,2),vec4(105.60926983333405,61,0.1527776249999988,3),vec4(105.44260333333405,41,0.31944412500000396,6),vec4(105.44260333333405,41,0.31944412500000396,7),vec4(105.44260333333405,53,0.31944412500000396,8),vec4(105.77593633333406,65,0.1527776249999988,2),vec4(105.77593633333406,58,0.1527776249999988,3),vec4(105.94260283333406,70,0.1527776249999988,2),vec4(105.94260283333406,61,0.1527776249999988,3),vec4(105.77593633333406,37,0.31944412500000396,6),vec4(105.77593633333406,37,0.31944412500000396,7),vec4(105.77593633333406,49,0.31944412500000396,8),vec4(106.10926933333407,69,0.1527776249999988,2),vec4(106.10926933333407,60,0.1527776249999988,3),vec4(106.27593583333407,70,0.1527776249999988,2),vec4(106.27593583333407,61,0.1527776249999988,3),vec4(106.10926933333407,41,0.31944412500000396,6),vec4(106.10926933333407,41,0.31944412500000396,7),vec4(106.10926933333407,53,0.31944412500000396,8),vec4(106.44260233333408,73,0.1527776249999988,2),vec4(106.44260233333408,65,0.1527776249999988,3),vec4(106.60926883333408,70,0.1527776249999988,2),vec4(106.60926883333408,61,0.1527776249999988,3),vec4(106.44260233333408,37,0.31944412500000396,6),vec4(106.44260233333408,37,0.31944412500000396,7),vec4(106.44260233333408,49,0.31944412500000396,8),vec4(106.77593533333409,68,0.1527776249999988,2),vec4(106.77593533333409,60,0.1527776249999988,3),vec4(106.9426018333341,70,0.1527776249999988,2),vec4(106.9426018333341,61,0.1527776249999988,3),vec4(106.77593533333409,41,0.31944412500000396,6),vec4(106.77593533333409,41,0.31944412500000396,7),vec4(106.77593533333409,53,0.31944412500000396,8),vec4(107.1092683333341,58,0.1527776249999988,3),vec4(107.1092683333341,67,0.31944412500000396,2),vec4(107.2759348333341,63,0.1527776249999988,3),vec4(107.1092683333341,37,0.31944412500000396,6),vec4(107.1092683333341,37,0.31944412500000396,7),vec4(107.1092683333341,49,0.31944412500000396,8),vec4(107.44260133333411,61,0.1527776249999988,3),vec4(107.44260133333411,70,0.31944412500000396,2),vec4(107.60926783333412,63,0.1527776249999988,3),vec4(107.44260133333411,43,0.31944412500000396,6),vec4(107.44260133333411,43,0.31944412500000396,7),vec4(107.44260133333411,55,0.31944412500000396,8),vec4(107.77593433333412,67,0.1527776249999988,3),vec4(107.94260083333413,63,0.1527776249999988,3),vec4(107.77593433333412,37,0.31944412500000396,6),vec4(107.77593433333412,37,0.31944412500000396,7),vec4(107.77593433333412,49,0.31944412500000396,8),vec4(108.10926733333413,61,0.1527776249999988,3),vec4(108.27593383333414,63,0.1527776249999988,3),vec4(108.10926733333413,43,0.31944412500000396,6),vec4(108.10926733333413,43,0.31944412500000396,7),vec4(108.10926733333413,55,0.31944412500000396,8),vec4(108.44260033333414,70,0.1527776249999988,3),vec4(108.60926683333415,67,0.1527776249999988,3),vec4(108.44260033333414,37,0.31944412500000396,6),vec4(108.44260033333414,37,0.31944412500000396,7),vec4(108.44260033333414,49,0.31944412500000396,8),vec4(108.77593333333415,65,0.1527776249999988,3),vec4(108.94259983333416,67,0.1527776249999988,3),vec4(108.77593333333415,43,0.31944412500000396,6),vec4(108.77593333333415,43,0.31944412500000396,7),vec4(108.77593333333415,55,0.31944412500000396,8),vec4(107.77593433333412,75,1.48610962500004,2),vec4(109.27593283333417,63,0.1527776249999988,2),vec4(109.10926633333416,75,0.31944412500000396,3),vec4(109.10926633333416,36,0.31944412500000396,6),vec4(109.10926633333416,36,0.31944412500000396,7),vec4(109.10926633333416,48,0.31944412500000396,8),vec4(109.44259933333417,61,0.1527776249999988,2),vec4(109.60926583333418,63,0.1527776249999988,2),vec4(109.44259933333417,72,0.31944412500000396,3),vec4(109.44259933333417,44,0.31944412500000396,6),vec4(109.44259933333417,44,0.31944412500000396,7),vec4(109.44259933333417,56,0.31944412500000396,8),vec4(109.77593233333418,68,0.1527776249999988,2),vec4(109.94259883333419,63,0.1527776249999988,2),vec4(109.77593233333418,36,0.31944412500000396,6),vec4(109.77593233333418,36,0.31944412500000396,7),vec4(109.77593233333418,48,0.31944412500000396,8),vec4(110.10926533333419,61,0.1527776249999988,2),vec4(110.2759318333342,63,0.1527776249999988,2),vec4(110.10926533333419,44,0.31944412500000396,6),vec4(110.10926533333419,44,0.31944412500000396,7),vec4(110.10926533333419,56,0.31944412500000396,8),vec4(110.4425983333342,72,0.1527776249999988,2),vec4(110.60926483333421,68,0.1527776249999988,2),vec4(110.4425983333342,36,0.31944412500000396,6),vec4(110.4425983333342,36,0.31944412500000396,7),vec4(110.4425983333342,48,0.31944412500000396,8),vec4(110.77593133333421,67,0.1527776249999988,2),vec4(110.94259783333422,68,0.1527776249999988,2),vec4(110.77593133333421,44,0.31944412500000396,6),vec4(110.77593133333421,44,0.31944412500000396,7),vec4(110.77593133333421,56,0.31944412500000396,8),vec4(111.10926433333422,74,0.1527776249999988,2),vec4(109.77593233333418,68,1.48610962500004,3),vec4(111.27593083333423,75,0.1527776249999988,2),vec4(111.27593083333423,67,0.1527776249999988,3),vec4(111.44259733333423,74,0.1527776249999988,2),vec4(111.44259733333423,65,0.1527776249999988,3),vec4(111.60926383333424,72,0.1527776249999988,2),vec4(111.60926383333424,63,0.1527776249999988,3),vec4(111.10926433333422,34,0.6527771250000143,6),vec4(111.10926433333422,34,0.6527771250000143,7),vec4(111.10926433333422,46,0.6527771250000143,8),vec4(111.77593033333424,70,0.1527776249999988,2),vec4(111.77593033333424,62,0.1527776249999988,3),vec4(111.94259683333425,79,0.1527776249999988,2),vec4(111.94259683333425,63,0.1527776249999988,3),vec4(112.10926333333425,77,0.1527776249999988,2),vec4(112.10926333333425,62,0.1527776249999988,3),vec4(112.27592983333426,75,0.1527776249999988,2),vec4(112.27592983333426,60,0.1527776249999988,3),vec4(112.44259633333427,74,0.1527776249999988,2),vec4(112.44259633333427,58,0.1527776249999988,3),vec4(112.60926283333427,72,0.1527776249999988,2),vec4(112.60926283333427,68,0.1527776249999988,3),vec4(112.77592933333428,70,0.1527776249999988,2),vec4(112.77592933333428,67,0.1527776249999988,3),vec4(112.94259583333428,68,0.1527776249999988,2),vec4(112.94259583333428,65,0.1527776249999988,3),vec4(113.10926233333429,67,0.1527776249999988,2),vec4(113.27592883333429,65,0.1527776249999988,2),vec4(113.10926233333429,27,0.31944412500000396,6),vec4(113.10926233333429,27,0.31944412500000396,7),vec4(113.10926233333429,39,0.31944412500000396,8),vec4(113.4425953333343,67,0.1527776249999988,2),vec4(113.6092618333343,70,0.1527776249999988,2),vec4(113.4425953333343,39,0.31944412500000396,6),vec4(113.4425953333343,39,0.31944412500000396,7),vec4(113.4425953333343,51,0.31944412500000396,8),vec4(113.7759283333343,68,0.1527776249999988,2),vec4(113.94259483333431,67,0.1527776249999988,2),vec4(113.7759283333343,29,0.31944412500000396,6),vec4(113.7759283333343,29,0.31944412500000396,7),vec4(113.7759283333343,41,0.31944412500000396,8),vec4(114.10926133333432,68,0.1527776249999988,2),vec4(114.27592783333432,72,0.1527776249999988,2),vec4(114.10926133333432,39,0.31944412500000396,6),vec4(114.10926133333432,39,0.31944412500000396,7),vec4(114.10926133333432,51,0.31944412500000396,8),vec4(114.44259433333433,70,0.1527776249999988,2),vec4(114.60926083333433,68,0.1527776249999988,2),vec4(114.44259433333433,31,0.31944412500000396,6),vec4(114.44259433333433,31,0.31944412500000396,7),vec4(114.44259433333433,43,0.31944412500000396,8),vec4(114.77592733333434,70,0.1527776249999988,2),vec4(114.94259383333434,73,0.1527776249999988,2),vec4(114.77592733333434,39,0.31944412500000396,6),vec4(114.77592733333434,39,0.31944412500000396,7),vec4(114.77592733333434,51,0.31944412500000396,8),vec4(115.10926033333435,72,0.1527776249999988,2),vec4(113.10926233333429,63,2.1527756250000607,3),vec4(115.27592683333435,70,0.1527776249999988,2),vec4(115.27592683333435,62,0.1527776249999988,3),vec4(115.10926033333435,32,0.31944412500000396,6),vec4(115.10926033333435,32,0.31944412500000396,7),vec4(115.10926033333435,44,0.31944412500000396,8),vec4(115.44259333333436,72,0.1527776249999988,2),vec4(115.44259333333436,63,0.1527776249999988,3),vec4(115.60925983333436,75,0.1527776249999988,2),vec4(115.60925983333436,68,0.1527776249999988,3),vec4(115.44259333333436,39,0.31944412500000396,6),vec4(115.44259333333436,39,0.31944412500000396,7),vec4(115.44259333333436,51,0.31944412500000396,8),vec4(115.77592633333437,67,0.1527776249999988,2),vec4(115.77592633333437,63,0.1527776249999988,3),vec4(115.94259283333437,65,0.1527776249999988,2),vec4(115.94259283333437,62,0.1527776249999988,3),vec4(115.77592633333437,34,0.31944412500000396,6),vec4(115.77592633333437,34,0.31944412500000396,7),vec4(115.77592633333437,46,0.31944412500000396,8),vec4(116.10925933333438,67,0.1527776249999988,2),vec4(116.10925933333438,63,0.1527776249999988,3),vec4(116.27592583333438,75,0.1527776249999988,2),vec4(116.27592583333438,67,0.1527776249999988,3),vec4(116.10925933333438,39,0.31944412500000396,6),vec4(116.10925933333438,39,0.31944412500000396,7),vec4(116.10925933333438,51,0.31944412500000396,8),vec4(116.44259233333439,68,0.1527776249999988,2),vec4(116.6092588333344,67,0.1527776249999988,2),vec4(116.44259233333439,36,0.31944412500000396,6),vec4(116.44259233333439,36,0.31944412500000396,7),vec4(116.44259233333439,48,0.31944412500000396,8),vec4(116.7759253333344,68,0.1527776249999988,2),vec4(116.9425918333344,75,0.1527776249999988,2),vec4(116.7759253333344,39,0.31944412500000396,6),vec4(116.7759253333344,39,0.31944412500000396,7),vec4(116.7759253333344,51,0.31944412500000396,8),vec4(116.44259233333439,65,0.8194436250000194,3),vec4(117.27592483333441,72,0.1527776249999988,3),vec4(117.10925833333441,34,0.31944412500000396,6),vec4(117.10925833333441,34,0.31944412500000396,7),vec4(117.10925833333441,46,0.31944412500000396,8),vec4(117.44259133333442,70,0.1527776249999988,3),vec4(117.10925833333441,67,0.6527771250000143,2),vec4(117.60925783333442,68,0.1527776249999988,3),vec4(117.44259133333442,39,0.31944412500000396,6),vec4(117.44259133333442,39,0.31944412500000396,7),vec4(117.44259133333442,51,0.31944412500000396,8),vec4(117.77592433333443,67,0.1527776249999988,3),vec4(117.94259083333444,79,0.1527776249999988,2),vec4(117.94259083333444,75,0.1527776249999988,3),vec4(117.77592433333443,32,0.31944412500000396,6),vec4(117.77592433333443,32,0.31944412500000396,7),vec4(117.77592433333443,44,0.31944412500000396,8),vec4(118.10925733333444,77,0.1527776249999988,2),vec4(118.10925733333444,74,0.1527776249999988,3),vec4(118.27592383333445,75,0.1527776249999988,2),vec4(118.27592383333445,72,0.1527776249999988,3),vec4(118.10925733333444,39,0.31944412500000396,6),vec4(118.10925733333444,39,0.31944412500000396,7),vec4(118.10925733333444,51,0.31944412500000396,8),vec4(118.44259033333445,74,0.1527776249999988,2),vec4(118.44259033333445,70,0.1527776249999988,3),vec4(118.60925683333446,72,0.1527776249999988,2),vec4(118.60925683333446,68,0.1527776249999988,3),vec4(118.44259033333445,34,0.31944412500000396,6),vec4(118.44259033333445,34,0.31944412500000396,7),vec4(118.44259033333445,46,0.31944412500000396,8),vec4(118.77592333333446,70,0.1527776249999988,2),vec4(118.77592333333446,67,0.1527776249999988,3),vec4(118.94258983333447,68,0.1527776249999988,2),vec4(118.94258983333447,65,0.1527776249999988,3),vec4(118.77592333333446,38,0.31944412500000396,6),vec4(118.77592333333446,38,0.31944412500000396,7),vec4(118.77592333333446,50,0.31944412500000396,8),vec4(119.10925633333447,67,0.1527776249999988,2),vec4(119.27592283333448,75,0.1527776249999988,2),vec4(119.10925633333447,63,0.31944412500000396,3),vec4(119.44258933333448,74,0.1527776249999988,2),vec4(119.60925583333449,75,0.1527776249999988,2),vec4(119.44258933333448,70,0.31944412500000396,3),vec4(119.10925633333447,27,0.6527771250000143,6),vec4(119.10925633333447,27,0.6527771250000143,7),vec4(119.10925633333447,39,0.6527771250000143,8),vec4(119.77592233333449,68,0.1527776249999988,2),vec4(119.9425888333345,75,0.1527776249999988,2),vec4(119.77592233333449,72,0.31944412500000396,3),vec4(120.1092553333345,67,0.1527776249999988,2),vec4(120.27592183333451,75,0.1527776249999988,2),vec4(120.1092553333345,70,0.31944412500000396,3),vec4(120.44258833333451,68,0.1527776249999988,2),vec4(120.60925483333452,75,0.1527776249999988,2),vec4(120.44258833333451,72,0.31944412500000396,3),vec4(120.77592133333452,65,0.1527776249999988,2),vec4(120.94258783333453,75,0.1527776249999988,2),vec4(120.77592133333452,68,0.31944412500000396,3),vec4(121.10925433333453,70,0.1527776249999988,3),vec4(121.10925433333453,67,0.31944412500000396,2),vec4(121.27592083333454,75,0.1527776249999988,3),vec4(121.44258733333454,74,0.1527776249999988,3),vec4(121.44258733333454,82,0.31944412500000396,2),vec4(121.60925383333455,75,0.1527776249999988,3),vec4(121.10925433333453,27,0.6527771250000143,6),vec4(121.10925433333453,27,0.6527771250000143,7),vec4(121.10925433333453,39,0.6527771250000143,8),vec4(121.77592033333455,68,0.1527776249999988,3),vec4(121.77592033333455,84,0.31944412500000396,2),vec4(121.94258683333456,75,0.1527776249999988,3),vec4(122.10925333333456,67,0.1527776249999988,3),vec4(122.10925333333456,82,0.31944412500000396,2),vec4(122.27591983333457,75,0.1527776249999988,3),vec4(122.44258633333457,68,0.1527776249999988,3),vec4(122.44258633333457,84,0.31944412500000396,2),vec4(122.60925283333458,75,0.1527776249999988,3),vec4(122.77591933333458,65,0.1527776249999988,3),vec4(122.77591933333458,80,0.31944412500000396,2),vec4(122.94258583333459,75,0.1527776249999988,3),vec4(123.1092523333346,82,0.1527776249999988,2),vec4(123.2759188333346,75,0.1527776249999988,2),vec4(123.4425853333346,77,0.1527776249999988,2),vec4(123.60925183333461,79,0.1527776249999988,2),vec4(123.4425853333346,46,0.31944412500000396,6),vec4(123.4425853333346,46,0.31944412500000396,7),vec4(123.4425853333346,58,0.31944412500000396,8),vec4(123.1092523333346,67,0.8194436250000194,3),vec4(123.94258483333462,63,0.1527776249999988,3),vec4(123.77591833333462,48,0.31944412500000396,6),vec4(123.77591833333462,48,0.31944412500000396,7),vec4(123.77591833333462,60,0.31944412500000396,8),vec4(124.10925133333463,65,0.1527776249999988,3),vec4(124.27591783333463,67,0.1527776249999988,3),vec4(124.10925133333463,46,0.31944412500000396,6),vec4(124.10925133333463,46,0.31944412500000396,7),vec4(124.10925133333463,58,0.31944412500000396,8),vec4(123.77591833333462,80,0.8211603125000266,2),vec4(124.44258433333464,68,0.154494312500006,3),vec4(124.61112358333465,79,0.154494312500006,2),vec4(124.61112358333465,70,0.154494312500006,3),vec4(124.44258433333464,48,0.32303356250001514,6),vec4(124.44258433333464,48,0.32303356250001514,7),vec4(124.44258433333464,60,0.32303356250001514,8),vec4(124.77966283333465,80,0.154494312500006,2),vec4(124.77966283333465,72,0.154494312500006,3),vec4(124.94820208333466,77,0.15624995833333344,2),vec4(124.94820208333466,74,0.15624995833333344,3),vec4(124.77966283333465,44,0.32478920833334257,6),vec4(124.77966283333465,44,0.32478920833334257,7),vec4(124.77966283333465,56,0.32478920833334257,8),vec4(125.11865658333467,82,0.3284228750000011,2),vec4(125.11865658333467,75,0.3284228750000011,3),vec4(125.11865658333467,43,0.3284228750000011,6),vec4(125.11865658333467,43,0.3284228750000011,7),vec4(125.11865658333467,55,0.3284228750000011,8),vec4(125.46161433333467,75,0.33618312500000513,2),vec4(125.46161433333467,67,0.33618312500000513,3),vec4(125.46161433333467,48,0.33618312500000513,6),vec4(125.46161433333467,48,0.33618312500000513,7),vec4(125.46161433333467,60,0.33618312500000513,8),vec4(125.81250333333467,77,0.3484056041666719,2),vec4(125.81250333333467,68,0.3484056041666719,3),vec4(125.81250333333467,44,0.3484056041666719,6),vec4(125.81250333333467,44,0.3484056041666719,7),vec4(125.81250333333467,56,0.3484056041666719,8),vec4(126.56326533333468,75,0.12499987708334004,2),vec4(126.56326533333468,67,0.12499987708334004,3),vec4(126.70025150000136,74,0.061643774999993184,2),vec4(126.70025150000136,65,0.061643774999993184,3),vec4(126.76874458333468,75,0.06617640000000335,2),vec4(126.76874458333468,67,0.06617640000000335,3),vec4(126.84227391666802,74,0.06617640000000335,2),vec4(126.84227391666802,65,0.06617640000000335,3),vec4(126.91580325000136,75,0.06617640000000335,2),vec4(126.91580325000136,67,0.06617640000000335,3),vec4(126.9893325833347,74,0.4880949791666609,2),vec4(126.9893325833347,65,0.4880949791666609,3),vec4(126.56326533333468,46,0.9141622291666778,6),vec4(126.56326533333468,46,0.9141622291666778,7),vec4(126.56326533333468,58,0.9141622291666778,8),vec4(127.50015483333469,75,3.9722212291666636,2),vec4(127.50015483333469,67,3.9722212291666636,3),vec4(127.50015483333469,39,3.9722212291666636,6),vec4(127.50015483333469,39,3.9722212291666636,7),vec4(127.50015483333469,51,3.9722212291666636,8));\n    \n    vec4 note;\n    if(n < 1024) note = _[n];\n    else note = _1[n-1024];\n    note.xz /= SPEED;\n    return note;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "\n// Various temperaments, expressed as the number of cents from which they differ\n// from the equal temperament.\n// https://en.wikipedia.org/wiki/Musical_temperament\n\n// 12-tone equal temperament\n//const float[] adjustment = float[12](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n\n// Five-limit tuning: unpleasant intervals appear when modulating\nconst float[] adjustment = float[12](0., 12., 4., 16., -14., -2., -10., 2., 14., -16., 18., -12.);\n\n// 1/4 comma meantone\n//const float[] adjustment = float[12](0., 16., -6., 10., -13., 3., -19., -3., 13., -10., 6., -16.);\n\nfloat pitch(float i)\n{\n    // Chromatic scale degree within the B minor scale.\n    // Goes from 0 (note B) to 11 (note A#).\n    int degree = int(mod(i - 6., 12.));\n    // Baroque tuning (middle A = 415hz vs 440hz)\n    // Adjust each degree with the number of cents prescribed.\n    return 415. * pow(2., (i - 69. + 0.01*adjustment[degree]) / 12.);\n}\n\nvec2 wave(vec2 f, vec2 a, float time)\n{\n    vec2 w = 2.*pi*fract(f * time);\n    //float v = pow(abs(sin(w / 2.)), 8.) - .5;\n    //float v = pow(max(0., (sin(w) + 1.) / 2.), 2.) - .5;\n    vec2 sw = sin(w/2.);\n    vec2 sw2 = sw*sw;\n    vec2 v = sw2*sw2 - .375; // Remove DC offset\n    //vec2 v = sw2*sw2*sw2 - .3125; // Remove DC offset\n    a *= sqrt(clamp(800./f, 1., 10.));\n    return a * v;\n}\n\nvec2 organ(vec2 f, float time)\n{\n    vec2 sound = vec2(0);\n    sound += wave(f, vec2(.08), time);\n    sound += wave(f * 2., vec2(0.8,1)*.01, time);\n    sound += wave(f * 4., vec2(.004), time);\n    sound += wave(f * .5, vec2(1,0.5)*.008, time);\n    return sound;\n}\n\n\nvec2 mainSound(int samp, float time)\n{\n    vec2 sound = vec2(0);\n\n    float t = time - t_offset;\n    for (int i=min(0, int(iSampleRate)) ; i<n_notes ; ++i)\n    {\n        vec4 note = notes(i);\n        note.y;\n        if (note.w == -1.)\n            continue;\n        if (note.x < t && t < note.x + note.z  + 5.)\n        {\n            float f = pitch(note.y);\n            // Add random pitch variation per note,\n            // so that if several notes with the same pitch are\n            // played at the same time, they are still\n            // decorrelated.\n            // Otherwise the combined tone sounds too loud\n            // (amplitude proportional to n, instead of sqrt(n)).\n            f += 0.3*sin(float(i));\n            \n            float pos = sin(note.w);\n            vec2 pan = sqrt(vec2(1) + 0.5*vec2(1,-1)*pos);\n            \n            \n            float t_in = t - note.x; // Time since attack\n            float t_out = t_in - note.z; // Time since release\n            float env = smoothstep(0., .05, t_in) * smoothstep(.05,0.,t_out);\n            sound += pan*env*organ(vec2(f), time);\n            float rtime = 0.1 + smoothstep(100.,400.,f);\n            float rtau = 99./rtime; // Reverb decay time: lower for bass notes\n            float env_verb = clamp(1.-exp(-t_in*rtau),0.,1.)*clamp(exp(-t_out*rtau),0.,1.);\n            sound += 0.5 * rtime * env_verb * organ(f+vec2(-.2,.32), time);\n            \n        }\n    }\n\n    return sound;\n}\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 322, 403, 517], [519, 519, 547, 596, 676], [678, 678, 712, 712, 806], [808, 808, 869, 916, 1050], [1052, 1052, 1093, 1093, 1643], [1645, 1645, 1671, 1671, 1718], [1720, 1720, 1739, 1739, 3599], [3601, 3601, 3635, 3635, 3674], [3676, 3676, 3733, 3733, 4109]], "test": "untested"}
{"id": "ftKXDt", "name": " Awkward Mushroom", "author": "prishainabox", "description": "This was mostly an experiment, so I'm probably not doing any of the mathematically correct techniques.\n\nLinks to sources for learning in code.", "tags": ["raymarching"], "likes": 0, "viewed": 147, "published": 3, "date": "1642448040", "time_retrieved": "2024-07-30T17:09:07.332005", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 60.0;\nconst int AA = 3;\nconst float FRESNEL_POWER = 5.0;\n\n//*******************************************************//\n\n// SDF MUSHROOM\n\nfloat sdMushroom(in vec3 pt, out Material mat) {\n\n\t// distance to closest object\n\tfloat res;\n\t\n\t// default\n\tmat = defaultMaterial();\n    mat.amb = 0.05;\n    \n    float ang = atan(pt.z, pt.x);\n    vec3 q = pt - vec3(0, 5, 0);\n    \n    // mushroom stalk\n    {\n        float stalk;\n        // cylinder\n        stalk = length(q.xz) - 1.6; \n        stalk = smoothmax(stalk, abs(pt.y - 5.0) - 3.0, 0.7);\n        // ellipsoid mushroom body\n        float r2 = 2.2 + sin(ang * 2.0) * 0.4;\n        stalk = smoothmin(stalk, sdEllipsoid(q - vec3(0, -3, 0), vec3(r2, 2.9, r2)), 4.0);\n        // ellipsoid top part that connects to head\n        float r3 = 3.6 + sin(ang*20.0) * 0.04;\n        stalk = smoothmin(stalk, sdEllipsoid(q - vec3(0, 3.5, 0), vec3(r3, 0.5, r3)), 1.5); \n        stalk += sin(ang * 15.0) * 0.2;\n    \n        // stalk\n        res = stalk;\n        mat.id = 1;\n        mat.fresnel = 0.5;\n   \n    }\n\n    // mushroom head\n    {\n        float head;\n        vec3 h = q - vec3(0, 2.2, 0);\n        float r1 = 5.6;\n        h.y -= 2.7 * smoothstep(r1, r1*0.2, length(h.xz));\n        head = sdEllipsoid(h, vec3(r1, 3, r1));\n        head = smoothmin(head, sdEllipsoid(h - vec3(4.0, 1, 0), vec3(1.8, 1.5, 4.0)), 2.5); // right\n        head = smoothmin(head, sdEllipsoid(h - vec3(-4.0, 1, -1), vec3(2.0, 1.0, 3.0)), 2.0); // left\n        head = smoothmax(head, -h.y, 0.8); // cut off bottom\n        head = smoothmax(head, -(length(h - vec3(0, -3, 0)) - r1*0.5), 0.7); // subtract a sphere on inside\n        head += pow((sin(ang*25.0)+1.0) * 0.5, 6.0) * 0.2 * smoothstep(12.0, 5.0, pt.y); // ridges\n\n        if (head < res) {\n            res = head;\n            mat.id = 2;\n            mat.spec = 1.0;\n            mat.shininess = 20.0;\n            // mushroom texture and color\n            mat.clr = vec3(0.04, 0.01, 0.02);\n            mat.clr += 0.1 * texture(iChannel1, pt.xy * 0.45).rgb;\n            // spots\n            vec2 section = vec2(ang * 13.0, length(pt.xz) * 0.7); // create a \"grid\" based on angle and radius (polar)\n            vec2 i = floor(section); // integer part\n            vec2 f = fract(section); // fractional part\n            float r = random(i); // random number\n            res -= mat.clr.r * 0.8; // bumpy texture\n            if (r > 0.6) {\n                float l = distance(f, vec2(0.5));\n                float c = smoothstep(0.5, 0.0, l); // for circle based on distance from center of \"grid cell\"\n                vec3 spotClr = 2.8 * vec3(0.055, 0.03, 0.011) * (0.5 + 0.5*random(floor(section*0.3)));\n                mat.clr = mix(mat.clr, spotClr, c); // mix red mushroom color and spot clr\n                // little depressions where spots are\n                float depressions = c * 0.28 * smoothstep(0.9, 0.7, l) * smoothstep(15.5, 10.0, pt.y); \n                res += depressions;\n            }\n        }\n    }\n      \n\treturn res;\n    \n}\n\n// MAIN SD FUNCTION\n\nfloat sdf(in vec3 pt, out Material mat) {\n    \n    // distance to closest object\n    float res;\n    \n    mat = defaultMaterial();\n    \n    // ground\n    vec3 groundClr = vec3(0.34, 0.2, 0.5) * 0.15 + 0.1*texture(iChannel2, pt.xz*0.04).rgb;\n    {\n        res = pt.y;\n        float ang = atan(pt.z,pt.x);\n        res -= smoothstep(15.0, 30.0, length(pt.xz)) * (5.0  + 4.0*fractalNoise(ang, 3));\n        res -= 0.2*noise(pt.xz) + 0.1*noise(pt.xz*2.0);\n        mat.id = 0;\n        mat.spec = 0.0;\n        mat.clr = groundClr;\n    }\n    \n    // the mushroom\n    if (length(pt - vec3(0, 6, 0)) < 10.0 && pt.y > 0.25) {\n        Material mushroomMat;\n        float mushroom = sdMushroom(pt, mushroomMat);\n        if (mushroom < res) {\n            res = mushroom;\n            mat = mushroomMat;\n        }\n        \n    }\n    \n    mat.groundBounceClr = groundClr * 3.0;\n    \n    return res;\n\n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n\tvec2 h = vec2(EPSILON, 0);\n\tMaterial m;\n\t// central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n\treturn normalize(vec3(\n\t\tsdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n\t\tsdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n\t\tsdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n\t));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n\t// total distance traveled\n\tfloat td = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat h = sdf(ro + td*rd, mat);\n\t\t// if distance is really close, break\n\t\tif (abs(h) < (0.0001*td)) break;\n\t\t// add to total distance\n\t\ttd += h;\n\t\t// if too far, break\n\t\tif (td >= MAX_DIST) {\n\t\t\tmat.id = -1;\n\t\t\tmat.ref = vec3(0.0);\n\t\t\tmat.fresnel = 0.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n\tfloat res = 1.0; // result\n\tfloat td = 0.05; // total distance traveled\n\tfor (int i = 0; i < 200 && td < MAX_DIST; i++) {\n\t\tMaterial m;\n\t\tfloat d = sdf(ro + td*rd, m);\n\t\tif (d < 0.001) {\n\t\t\t// intersection, so return shadow\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min(res, k*d/td);\n\t\ttd += d;\n\t}\n\t// if no intersection -> shadow 0.0 to light 1.0\n\treturn res;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\n// ambient occlusion\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n\tfloat occ = 0.0;\n\tfloat scl = 1.0;\n\t\n\tMaterial m; // placeholder\n\t\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat h = 0.01 + 0.11 * 0.25 * float(i);\n\t\tfloat d = sdf(pt + h * nor, m);\n\t\tocc += (h-d)*scl;\n\t\tscl *= 0.95;\n\t}\n\t\n\treturn uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n\n\t// diffuse\n\tfloat dif = uclamp(dot(nor, light.dir)) * mat.dif;\n\t\n\t// shadow\n\tfloat shadow = light.isPointLight ? 1.0 : softShadow(pt, light.dir, light.shadowSoftness);\n\t\n\t// specular\n\tvec3 ref = reflect(light.dir, nor);\n\tfloat spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n\t// return dif * clr * shadow * spec + dif * clr * shadow; \n\treturn light.brightness * light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    // mix sun clr with sky clr to get fog clr\n\tvec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    // mix pixel clr with fog clr\n\treturn mix(clr, fogClr, 1.0 - exp(-0.00002 * d * d * d));\n}\n\n//*******************************************************//\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, inout Material mat) {\n\n\tvec3 pt = ro + rd * d;\n\n\t// COLORS\n\tvec3 skyClr = vec3(0.45, 0.4, 0.2) * 0.5;\n\t\n\t// LIGHTS\n    Light sky = createLight(pt, false, 1.0, 2.0, normalize(vec3(0, 1,  0)), skyClr);\n    Light sun = createLight(pt, false, 1.0, 25.0, normalize(vec3(-2, 0.1, -5)), vec3(10.0, 8.0, 3.7));\n\t\n\t// background color\n\tvec3 clr = skyClr;\n\n\t// return background if too far (id is -1.0)\n\tif (mat.id == -1) {\n\t\t// sun\n\t\tclr = mix(skyClr, sun.clr * 0.15, pow(max(dot(rd, sun.dir), 0.0), 10.0));\n\t\treturn clr;\n\t}\n    \n    // materials\n    \n    // stalk\n    if (mat.id == 1) {\n        mat.spec = 0.5;\n        mat.shininess = 5.0;\n        // stalk texture and color\n        mat.clr = vec3(0.07, 0.07, 0.045) * 1.15;\n        mat.clr += vec3(0.03) * sin(30.0 * atan(pt.z, pt.x)) * smoothstep(5.0, 8.0, pt.y);\n        mat.clr += texture(iChannel1, pt.xy * vec2(0.25, 0.15)).r * 0.06;\n        mat.clr -= (0.04 + 0.05 * smoothstep(4.0, -1.0, pt.y)) * texture(iChannel0, pt.yx * 0.3 + 0.1*sin(pt.z)).rgb;\n   }\n    \n    // mushroom fresnel\n    if (mat.id == 1 || mat.id == 2) {\n        mat.fresnel = 1.0 * -dot(vec3(0, -1, 0), nor);\n    }\n    \n    // material id is not -1.0, so we hit an obj\n\tclr = mat.clr;\n\t\n\t// LIGHTS\n\t\n\t// CALCULATE COLOR\n\tfloat occ = calcOcc(pt, nor); // ambient occlusion\n\tvec3 light = vec3(mat.amb); // ambient\n    light += calcLighting(pt, rd, nor, sky, mat); // sky diffuse\n    light += calcLighting(pt, rd, nor, sun, mat); // sun light\n    \n    // point lights\n    {\n        for (float r = 6.0; r < 20.0; r+=3.0) {\n            for (float i = 0.0; i < 6.0; i++) {\n                float ang = r + i + 2.0*random(r);\n                vec3 lpos = vec3(r * cos(ang), pt.y + 1.2, r * sin(ang));\n                vec3 lclr = vec3(50.0 + 20.0*random(fract(sin(i)*121.0)), 40.0 + 20.0*random(ang), 10.0 + 20.0*random(i*r*ang)) * (0.2 + 0.05*random(ang*r*i));\n                Light ptLight = createLight(pt, true, 2.0 + 1.5*fract(21.0*sin(r+i*20.0)), 5.9, lpos, lclr);\n                light += calcLighting(pt, rd, nor, ptLight, mat);\n            }\n        }\n    }\n    \n\tlight += (uclamp(dot(nor, vec3(0, -1, 0)))*0.8 + 0.2) * mat.groundBounceClr; // ground diffuse\n\n\tclr *= light * occ;\n\n\tclr = applyFog(rd, d, clr, sun.clr * 0.1, sun.dir, skyClr);\n\t\n\treturn clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n\tMaterial mat;\n\n\tfloat d = castRay(ro, rd, mat); // distance to point on object in scene\n\tvec3 nor = calcNormal(ro + rd*d); // surface normal\n\t\n\t// calculate color of the pixel\n\tvec3 clr = calcClr(ro, rd, d, nor, mat);\n\t\n\tbool willReflect = mat.ref.r > 0.0 || mat.ref.g > 0.0 || mat.ref.b > 0.0;\n\tif (mat.fresnel > 0.0 || willReflect) {\n\t\n\t\tint bounces = 1;\n\t\tvec3 ref = vec3(0.0);\n\t\tfloat fresnel = 0.5 * uclamp(pow(1.0 - dot(nor, -rd), FRESNEL_POWER));\n\t\t\n\t\t// if the material will reflect\n\t\tif (willReflect) {\n\t\t\tbounces = 3;\n\t\t\t// if reflective and doesn't have fresnel\n\t\t\tif (mat.fresnel == 0.0) ref = mat.ref;\n\t\t\t// if reflective with fresnel\n\t\t\telse ref = fresnel * mat.ref;\n\t\t} else {\n\t\t\tref = vec3(fresnel);\n\t\t}\n\t\t\n\t\t// bouncing around for fresnel and reflection\n\t\tvec3 fil = vec3(1.0);\n\t\tfor (int i = 0; i < bounces; i++) {\n\t\t\tfil *= ref;\n\t\t\t// to intersection point and reflect\n\t\t\tro += rd*d + nor*EPSILON*3.0;\n\t\t\trd = reflect(rd, nor);\n\t\t\t// find new point\n\t\t\td = castRay(ro, rd, mat);\n\t\t\tnor = calcNormal(ro + rd*d);\n\t\t\t// add color\n\t\t\tclr += fil * calcClr(ro, rd, d, nor, mat);\n\t\t\tif (mat.id == -1) break;\n\t\t}\n\t\t\t\n\t}\n\t\n\tclr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n\treturn clr;\n    \n}\n\n//*******************************************************//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame != 0) discard;\n\n\tvec2 res = iResolution.xy;\n    // float time = iTime * 0.5;\n\t\n\t// target\n\tvec3 target = vec3(0, 4.8, 0);\n\t// ray origin\n    vec3 ro = vec3(0, 4.2, 13);\n\t\n\t// accumulate color\n\tvec3 clr = vec3(0.0);\n\t\n\tfor (int i = 0; i < AA; i++) {\n\t\tfor (int j = 0; j < AA; j++) {\n\t\t\t// Normalized pixel coordinates\n\t\t\tvec2 f = gl_FragCoord.xy + vec2(float(i), float(j)) / float(AA);\n\t\t\tvec2 uv = (2.0*f - res) / min(res.x, res.y);\n\t\t\tvec3 rd = setCamera(uv, ro, target);\n\t\t\t// calculate color based on distance, etc\n\t\t\tclr += render(ro, rd);\n\t\t}\n\t}    \n\t\n\tclr /= float(AA*AA);\n\n\t// Output to screen\n\tfragColor = vec4(clr, 1.0);\n    \n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//*******************************************************//\n\n// Structs\n\n// Light struct\nstruct Light {\n    bool isPointLight;\n    vec3 clr;\n    float shadowSoftness; // higher number -> crisper shadows\n    // if isPointLight, set position, else set direction\n    vec3 pos;\n    vec3 dir;\n    float brightness;\n};\n\n// create a light\nLight createLight(in vec3 pt, in bool isPointLight, in float fadeAdjust, in float shadowSoftness, in vec3 dirOrPos, in vec3 clr) {\n\n    Light light;\n    light.clr = clr;\n    light.shadowSoftness = shadowSoftness;\n\n    if (isPointLight) {\n        // point light\n        light.pos = dirOrPos;\n        light.isPointLight = true;\n        // calculate brightness and direction\n        float d = distance(pt, light.pos);\n        d = pow(d, fadeAdjust);\n        light.brightness = 1.0 / (d * d);\n        light.dir = normalize(light.pos - pt);\n    } else {\n\t\t// directional light\n        light.brightness = 1.0;\n        light.dir = dirOrPos;\n    }\n\n    return light;\n\n}\n\n// Material struct\nstruct Material {\n    vec3 clr; // color\n    float amb; // ambient\n    float dif; // diffuse\n    float spec; // specular\n    float shininess;\n    vec3 ref; // reflect clr\n    float fresnel; // multiply fresnel calculated by float between 0.0 and 1.0\n    vec3 groundBounceClr; // bounce color from ground\n    int id; // unique identifier\n};\n\n// return a nondescript material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.05;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.fresnel = 0.0;\n    mat.groundBounceClr = vec3(0.0);\n    mat.id = -1;\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\n// https://iquilezles.org/articles/smin\n\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smoothmax\nfloat smoothmax( float a, float b, float k ) {\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\n// Smooth min for distance and color\n// returns rgb and d in vec4\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n\tfloat h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\t// distance\n\tfloat d = mix(b, a, h) - k*h*(1.0-h);\n\t// color\n\tvec3 c = mix(clr2, clr1, h);\n\treturn vec4(c, d);\n}\n\n// return points for finite and infinite repetition\n\nvec3 infRep(in vec3 pt, in vec3 period) {\n\treturn mod(pt + 0.5 * period, period) - 0.5 * period;\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 minLim, in vec3 maxLim) {\n\treturn pt - period * clamp(round(pt/period), minLim, maxLim);\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 lim) {\n\treturn pt - period * clamp(round(pt/period), -lim, lim);\n}\n\n\n//*******************************************************//\n\n// random and noise\n\n// https://thebookofshaders.com/10/\nfloat random(in float v) {\n\treturn fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n\treturn fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n\treturn fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in float v) {\n    float fid = fract(v); // fraction part\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    float id = floor(v); // integer part\n    return mix(random(id), random(id + 1.0), fid);\n}\n\nfloat noise(in vec2 uv) {\n    \n\tvec2 fid = fract(uv); // fraction part of uv -> where in the grid\n\tfid = fid * fid * (3.0 - 2.0 * fid);\n\tvec2 id = floor(uv); // integer part of uvw -> which grid\n\t\n\t// corners of square\n\tfloat bl = random(id + vec2(0, 0));\n\tfloat br = random(id + vec2(1, 0));\n\tfloat tl = random(id + vec2(0, 1));\n\tfloat tr = random(id + vec2(1, 1));\n\t\n\t// interpolate between corner\n\tfloat b = mix(bl, br, fid.x);\n\tfloat t = mix(tl, tr, fid.x);\n\treturn mix(b, t, fid.y);\n    \n}\n\nfloat noise(in vec3 uvw) {\n\n\tvec3 f = fract(uvw); // fraction part of uvw -> where in the grid cell\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec3 i = floor(uvw); // integer part of uvw -> which grid cell\n\t\n\t// lerp bottom face\n\tfloat bf = mix(random(i + vec3(0, 0, 0)), random(i + vec3(1, 0, 0)), f.x);\n\tfloat bb = mix(random(i + vec3(0, 0, 1)), random(i + vec3(1, 0, 1)), f.x);\n\tfloat b = mix(bf, bb, f.z);\n\n\t// lerp top face\n\tfloat tf = mix(random(i + vec3(0, 1, 0)), random(i + vec3(1, 1, 0)), f.x);\n\tfloat tb = mix(random(i + vec3(0, 1, 1)), random(i + vec3(1, 1, 1)), f.x);\n\tfloat t = mix(tf, tb, f.z);\n\t\n\treturn mix(b, t, f.y);\n\t\n}\n\nfloat fractalNoise(in float u, in int iter) {\n    float s1 = 1.0, s2 = 4.0;\n    float c = 0.0;\n    for (int i = 0; i < iter; i++) {\n        c += s1 * noise(u * s2);\n        s1 *= 0.5;\n        s2 *= 2.0;\n    }\n    c /= 2.0;\n    return c;\n}\n\nfloat fractalNoise(in vec3 uvw) {\n\tfloat c = noise(uvw * 4.0);\n\tc += 0.5 * noise(uvw * 8.0);\n\tc += 0.25 * noise(uvw * 16.0);\n\tc += 0.125 * noise(uvw * 32.0);\n\tc += 0.0625 * noise(uvw * 64.0);\n\tc /= 2.0;\n\treturn c;\n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdSphere(in vec3 pt, in float rad) {\n\treturn length(pt) - rad;\n}\n\nfloat sdEllipsoid(in vec3 pt, in vec3 rad) {\n\tfloat k0 = length(pt/rad);\n\tfloat k1 = length(pt/(rad*rad));\n\treturn k0 * (k0-1.0)/k1;\n}\n\n// https://www.youtube.com/watch?v=PMltMdi1Wzg\nfloat sdCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n\tvec3 apt = pt - a;\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n\treturn length( apt - ab * t ) - r;\n}\n\n// https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat sdBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 236, 268, 3055], [3078, 3078, 3119, 3158, 3960], [4023, 4069, 4098, 4098, 4363], [4426, 4426, 4483, 4512, 4858], [4860, 4905, 4959, 4959, 5308], [5310, 5372, 5412, 5412, 5669], [5732, 5732, 5821, 5834, 6246], [6248, 6287, 6387, 6434, 6605], [6668, 6668, 6751, 6751, 9007], [9070, 9070, 9107, 9107, 10319], [10382, 10382, 10437, 10437, 11090]], "test": "untested"}
{"id": "sdXyRX", "name": "Ghost Village", "author": "butadiene", "description": "Ghost Village", "tags": ["raymarching"], "likes": 13, "viewed": 355, "published": 3, "date": "1642447276", "time_retrieved": "2024-07-30T17:09:08.224619", "image_code": "#define HOUSWPOS vec3(8,4.,-10)\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nvec2 pmod(vec2 p,float n){\n    float np = 2.*3.14159265/n;\n    float r =atan(p.x,p.y)-0.5*np;\n    r = mod(r,np)-0.5*np;\n    return length(p)*vec2(cos(r),sin(r));\n}\n\nvec2 random2(vec2 st){\n    return texelFetch(iChannel0,ivec2(st),0).xy;\n}\n\nfloat noise (in vec2 st) {\n       vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .8;\n    }\n    return value;\n}\n\nfloat cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//https://iquilezles.org/articles/distfunctions\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec2 froor(vec3 p,vec3 housepos){\n  float h = 1.4*fbm(100.+0.08*p.xz);\n  h += housepos.y*exp(-0.2*length(vec2(0.2,0.9)*(p.xz-housepos.xz-vec2(0,1.9)))); \n  return vec2(p.y-h,h);\n}\n\nfloat house(vec3 p,vec3 housepos){\nfloat sc = 1.2;\n  float radi = 0.125;\n  p -= housepos;\n  p *= sc;\n  p.xz *= rot(1.9);\n  p.y += 0.3;\n  vec3 sp = p;\n  \n  p.y -= 1.+2.*radi;\n  p.y = abs(p.y)-4.*radi;\n  p.xy *= rot(0.5*3.1416);\n  p.y = abs(p.y)-1.4121*1.5;\n  p.xz = abs(p.xz)-radi;\n  p.zy *= rot(0.25*3.141592);\n  p.x = abs(p.x-radi)-radi*1.;\n  float cyl = cylinder(p,radi*2.*12.,radi);\n  \n  p = sp;\n  p.y -= 3.;\n  p.xz *= rot(0.25*3.141592);\n  p.xz = abs(p.xz);\n  p.yz *= rot(0.25*3.141592);\n  float wall = box(p-vec3(1.4,-0.9,0.2),vec3(0.1,radi*12.,radi*12.));\n  float roof = box(p-vec3(0,0.7,0.4),vec3(1.8,0.1,1.8));\n  \n  p = sp;\n  p.zx *= rot(0.25*3.141592);\n  float door = box(p-vec3(0.6,1,0.9),vec3(0.5,1,1));\n  float d =  min(min(cyl,roof),min(wall,door));\n  return d/sc;\n}\n\nfloat grass(vec3 p,float h){\np.y -= 0.13;\nfloat k = 0.05;\nfloat cylinhigh = 2.8*noise(200.+p.xz*0.05);\nvec3 sp = p;\nfloat ks = 4.;\nfloat kt = 0.3;\nfloat kzx = 0.1;\nvec3 ds = 0.2*vec3((p.y-h)*ks*sin(kzx*p.x+iTime*kt),0,(p.y-h)*ks*cos(kzx*p.z+iTime*kt));\nfloat d2 = sdCappedCone(p-ds-vec3(0,h+cylinhigh*2.,0.),cylinhigh,0.025,0.);\n/*\nfor(int i = 0;i<8;i++){\np.xz = abs(p.xz)-1.;\n//p.xz *= rot(0.3);\nd2 = min(d2,sdCappedCone(p-vec3(0,h+cylinhigh*2.,0.),cylinhigh,0.025,0.));\n\n}*/\n\np = sp;\n  p.xz = mod(p.xz,k)-0.5*k;\n  float d = sdCappedCone(p-ds-vec3(0,h+cylinhigh*.5,0.),cylinhigh,0.05,0.);\n  return min(d2,d);\n}\n\nvec2 tree(vec3 p){ \nfloat sc = 0.6;\np *= sc;\n  float shi = 0.9;\n  float sr = 0.17;\n  float sd = cylinder(p,shi,sr);\n  p.y -= shi;\n  p.xz = pmod(p.xz,4.);\n  vec2 scale = vec2(0.75,0.67);\n  vec2 size = vec2(1.,sr);\n  float d = cylinder(p,size.x,size.y);\n  for(int i =0;i<3;i++){\n   p.x = abs(p.x);\n   p.y -= size.x;\n   p.xy *= rot(-0.7);\n   size *= scale;\n   d = min(d,cylinder(p,size.x,size.y));\n  }\n   p.xz = pmod(p.xz,7.);\n   for(int i =0;i<3;i++){\n   p.x = abs(p.x);\n   p.y -= size.x;\n   p.xy *= rot(-0.6);\n   size *= scale;\n   d = min(d,cylinder(p,size.x,size.y));\n  }\n  scale = vec2(0.6,0.6);\n   p.x = abs(p.x);\n   p.y -= size.x;\n   p.xy *= rot(-0.4);\n   size *= scale;\n   float ind = 0.;\n   d = min(d,cylinder(p,2.*size.x,size.y));\n   float kd = box(p-vec3(0,size.x*2.,0),1.2*vec3(0.05,0.07,0.01));\n    d = min(d,sd);\n   if(d>kd) ind = 1.0;\n   d = min(d,kd);\n \n  return vec2(d/sc,ind);\n\n}\n\nvec4 dist(vec3 p){\n  vec3 col = vec3(0);\n  vec3 housepos = HOUSWPOS;\n  vec2 dfroor = froor(p,housepos);\n  float dhouse = house(p,housepos);\n  float dgrass = grass(p,dfroor.y);\n  float dtree =tree(p-housepos-vec3(-4,0,0)).x;\n  float d = dhouse;\n  d = min(d,dfroor.x);\n  d = min(d,dgrass);\n  d = min(d,dtree);\n  return vec4(col,d);\n}\n\nvec3 getnormal(vec3 p){\n  vec2 e = vec2(0.0001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\nfloat softray(vec3 ro, vec3 rd , float hn)\n{\n\tfloat t = 0.1;\n\tfloat jt = 0.0;\n\tfloat res = 1.;\n\tfor (int i = 0; i < 20; ++i) {\n\t\tjt = dist(ro+rd*t).w;\n\t\tres = min(res,jt*hn/t);\n\t\tt = t+ clamp(0.02,2.,jt);\n\t}\n\treturn clamp(res,0.,1.);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n    vec2 uv= fragCoord.xy/r;\n    vec3 ro = vec3(0,1.2,15.+25.*fract(iTime/25.));\n    vec3 ta = vec3(-1,5.8,0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(side*p.x+up*p.y+2.*cdir);\n    float d,t=0.0;\n    vec4 rsd = vec4(0);\n\n    float faraway = 100.;\n    float esp = 0.0001;\n    for(int i = 0;i<308;i++){\n      rsd = dist(ro+rd*t);\n      d = rsd.w;\n      t += d;\n      if(d<esp||t>faraway)break;\n    }\n    vec3 sp = ro+rd*t;\n    vec3 col = vec3(0);\n    if(d<esp&&t<faraway){\n        vec3 diffuse = vec3(0,0,0);\n          vec3 housepos = HOUSWPOS;\n        vec2 st = tree(sp-housepos-vec3(-4,0,0));\n      \n        vec2 sr = froor(sp,housepos);\n        float sh = house(sp,housepos);\n        float sg = grass(sp,sr.y);\n        \n        if(min(st.x,sr.x)<min(sh,sg)){\n         if(st.x<sr.x){\n             if(st.y<0.5){diffuse = vec3(0.3,0.22,0.1);\n             }else{\n             diffuse = vec3(0.3,0.8,0.3);\n             }\n         }\n         else{\n             diffuse = vec3(0.4,0.3,0.04);\n         }\n        }else if(sh<sg){\n         diffuse = vec3(0.7,0.5,0.3);\n        }else{\n           diffuse =vec3 (0.6,0.9,0.6);\n        }\n        \n        vec3 normal = getnormal(sp);\n        vec3 lightdir = normalize(vec3(0.1,1,1));\n\n        float val =max(dot(normal,lightdir),0.)*0.5+0.5;\n        float hlc = val *val*(3./(4.*3.141592));\n\n        vec3 shadowRay = normalize(vec3(0.1,1.,1));\n        float shadow = softray(sp,shadowRay,3.1);\n        col = vec3(diffuse*hlc*shadow);\n    }\n    vec3 fogcol = vec3(0.9,0.9,1.);\n    float far = 30.;\n    float near = 1.;\n    //col = mix(col,fogcol,clamp((t-near)/(far-near),0.,1.));\n   col = mix(fogcol,col,exp(-0.06*(t+fbm(uv*0.2+0.2*iTime)*10.)));\n   col = clamp(col,vec3(0),vec3(1));\n   col = pow(col,vec3(1.2,1.2,1.));\n    fragColor=vec4(col,1);\n    }", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 51, 51, 98], [99, 99, 124, 124, 143], [144, 144, 169, 169, 188], [189, 189, 215, 215, 352], [354, 354, 376, 376, 427], [429, 429, 455, 455, 862], [882, 882, 906, 906, 1130], [1132, 1132, 1176, 1176, 1283], [1333, 1333, 1404, 1404, 1742], [1744, 1744, 1769, 1769, 1866], [1868, 1868, 1901, 1901, 2047], [2049, 2049, 2083, 2083, 2828], [2830, 2830, 2858, 2858, 3441], [3443, 3443, 3461, 3461, 4336], [4338, 4338, 4356, 4356, 4669], [4671, 4671, 4694, 4694, 4867], [4868, 4868, 4912, 4912, 5103], [5108, 5108, 5165, 5165, 7108]], "test": "untested"}
{"id": "fdlcRX", "name": "Tetrahedron 4b", "author": "FabriceNeyret2", "description": "mouse controls camera\nTrying to get the iterative version of   https://shadertoy.com/view/sdfyzf\nwell, this is not:  the small spheres are stuck in regular tetra subdiv, while they should go more down.", "tags": ["raymarching", "tetrahedra", "short", "pseudoapollonians"], "likes": 20, "viewed": 449, "published": 3, "date": "1642444266", "time_retrieved": "2024-07-30T17:09:09.132192", "image_code": "// variant of https://shadertoy.com/view/sdfyzf\n\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))             // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., o=.67, s; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,A,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x),\n#define D(x,y,z) dot(q,vec3(x,y,z))\n        t = min(t, ( max(max(D(1,1,-1),D(1,-1,1)),max(D(-1,1,1),D(-1,-1,-1))) - 1. ) / 1.73 ); // variant of spalmer's tet\n        s=1.;\n        for( int i=0; i<4; i++ )                              // recursion\n            A = sign(q),                                      // symmetry: to closest axis\n            t = max(t, s  - length(q) ),                      // hollow sphere\n            q -= o*A*s, s *= .34;\n         // t = max(t, 1.  - length(q) ),                     // hollow sphere\n         // q -= o*A, q /= .34;\n\n    // t = max(t, .34 - length(q-.67*A) ),                    // hollow spheres #2\n    // t = max(t, .12 - length(q-.89*A) ),                    // hollow spheres #3\n   \n       p += .3*t*D;                                           // step forward = dist to obj          \n   }\n   O *= O*O*2.; \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdsyRX", "name": "ShyGuy (332 chars)", "author": "IWBTShyGuy", "description": "ShyGuy bitmap in 332 chars\n\nI used this code to compress the bitmap.\n[url]https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=be3ff9fabf32f4a8dbf63adf5d612e18[/url]\n", "tags": ["bitmap", "shyguy"], "likes": 8, "viewed": 310, "published": 3, "date": "1642443141", "time_retrieved": "2024-07-30T17:09:09.944022", "image_code": "// 332 chars, gray = 0.495\n// devised operation (Xor)\nvoid mainImage(out vec4 O, vec2 u){\n    ivec2 U = ivec2(8.* (u+u-(O.xy = iResolution.xy))/O.y + 9.); U.x--;\n    O -= vec4(.63,1.33,O)*floor(\n    O = vec4(clamp(U,0,15)==U\n          ? int[](\n              713032321,138346656,805519116,849362929,\n              1244139457,170540997,715788273,715821041,\n              545423361,545423365,1252659185,1252671484,\n              1386758129,1409548037,1426063445 \n                 ) [U.y-1] >> U.x*2&3 : 1 ) / 2.02);\n}\n\n\n/**************************************************************************************************\n** Rule of code golf                                                                             **\n** - ShyGuy is sacred! Keep the color (8-bit integers), shape (16x16 px) and central position.   **\n** - You may SLIGHTLY change the background gray. Especially, it must be a single color.         **\n** - Keep things window size independant, and all be valid code (e.g. no missing initialization. **\n** - test env: Windows/Edge, Windows/Firefox with true OpenGL, Android, MacOS/Safari             **\n**************************************************************************************************/\n\n/*\nChangelog\n\n// 335 chars, gray = 0.495\n// skipping r\nvoid mainImage(out vec4 O, vec2 u){\n    O.xyz = iResolution;\n    ivec2 U = ivec2( 8.* (u+u-O.xy)/O.y + 9. )-1;\n    // U.y==8 && iFrame%99<12 ? U.y--: 0 ;\n    O = vec4( U.y<15 && 0<=U.x && U.x<16\n          ? int[](\n              713032321,138346656,805519116,849362929,\n              1244139457,170540997,715788273,715821041,\n              545423361,545423365,1252659185,1252671484,\n              1386758129,1409548037,1426063445\n                   ) [U.y] >> U.x*2&3 : 1 ) / 2.02;\n    O.x > 1. ? O = vec4(.85,.16,0,0) : O;\n}\n\n// 336 chars, gray = 0.495.\n// fix on the true OpenGL.\nvoid mainImage(out vec4 O, vec2 u){\n    vec2 r = iResolution.xy;\n    ivec2 U = ivec2( 8.* (u+u-r)/r.y + 9. )-1;\n    int i = 545423361, c = U.y<15 && 0<=U.x && U.x<16\n          ? int[](\n              713032321,\n              138346656,\n              805519116,\n              849362929,\n              1244139457,\n              170540997,\n              715788273,\n              715821041,\n              i,\n              i+4,\n              1252659185,\n              1252671484,\n              1386758129,\n              1409548037,\n              1426063445\n                   ) [U.y] >> U.x*2&3 : 1;\n    O = c==3 ? vec4(.85,.16,0,0) : vec4(c) / 2.02;\n}\n\n// 335 chars, gray = 0.495, but does not work on true OpenGL.\n// Resurrected `c`. Compressed the array by merging similar values by operation.\nvoid mainImage(out vec4 O, vec2 u){\n    vec2 r = iResolution.xy;\n    ivec2 U = ivec2( 8.* (u+u-r)/r.y + 9. )-1;\n    int i, c = U.y<15 && 0<=U.x && U.x<16\n          ? int[](\n              713032321,\n              138346656,\n              805519116,\n              849362929,\n              1244139457,\n              170540997,\n              715788273,\n              715821041,\n              i=545423361,\n              i+4,\n              i=1252659185,\n              i+12299,\n              1386758129,\n              1409548037,\n              1426063445\n                   ) [U.y] >> U.x*2&3 : 1;\n    O = c==3 ? vec4(.85,.16,0,0) : vec4(c) / 2.02;\n}\n\n// 336 chars, gray = 0.495\n// replacing %4 with &3, using ivec2, skipping c (FabriceNeyret2)\nvoid mainImage(out vec4 O, vec2 u){\n    vec2 r = iResolution.xy;\n    ivec2 U = ivec2( 8.* (u+u-r)/r.y + 9. )-1;\n    O = vec4( U.y<15 && 0<=U.x && U.x<16\n          ? int[](\n              713032321,138346656,805519116,849362929,\n              1244139457,170540997,715788273,715821041,\n              545423361,545423365,1252659185,1252671484,\n              1386758129,1409548037,1426063445\n                   ) [U.y] >> U.x*2&3 : 1 ) / 2.02;\n    O.x > 1. ? O = vec4(.85,.16,0,0) : O;\n}\n\n// 347 chars, gray = 0.495\n// Replaced the last number in the array with a conditional branch.\nvoid mainImage(out vec4 O, vec2 U){\n    vec2 r = iResolution.xy;\n    U = ceil( 8.* (U+U-r)/r.y ) + 7.;\n    int i = int( U.y * 16. + U ) * 2,\n        c = i < 480 && abs(7.5 - U.x) < 8.\n          ? ( int[](\n              713032321,138346656,805519116,849362929,\n              1244139457,170540997,715788273,715821041,\n              545423361,545423365,1252659185,1252671484,\n              1386758129,1409548037,1426063445\n                   ) [i / 32] >> i\n            ) % 4 : 1;\n    \n    O = c==3 ? vec4(.85,.16,0,0) : vec4(c)/2.02;\n}\n\n// 351 chars, gray = 0.495\n// remap bitmap and use c to color setting (FabriceNeyret2)\nvoid mainImage(out vec4 O, vec2 U){\n    vec2 r = iResolution.xy;\n    U = ceil( 8.* (U+U-r)/r.y ) + 7.;\n    int i = int( U.y * 16. + U ) * 2,\n        c = abs(7.5 - U.x) < 8.\n          ? ( int[](\n              713032321,138346656,805519116,849362929,\n              1244139457,170540997,715788273,715821041,\n              545423361,545423365,1252659185,1252671484,\n              1386758129,1409548037,1426063445,1431655765\n                   ) [i / 32] >> i\n            ) % 4 : 1;\n    \n    O = c==3 ? vec4(.85,.16,0,0) : vec4(c)/2.02;\n}\n\n// original code: 386 chars, gray = 0.5\nvoid mainImage(out vec4 O, in vec2 U){\n    O-=O; // O=vec4(0); // <- if you are using Mac, this may have to be activate.\n    vec2 r = iResolution.xy;\n    U = ceil((U-.5*r)/r.y*16.)+7.;\n    int i = int(U.y * 16. + U.x),\n        c = abs(U = 7.5 - abs(7.5 - U)) == U ?\n        (\n            int[](\n                1788171924,1501517221,1968668509,1990557684,443113428,\n                1516928976,1789550580,1789566964,1704367444,1704367440,\n                447373300,447381501,111771636,22544208,5592320,0\n            )[i / 16] >> i % 16 * 2\n        ) % 4 : 0;\n    c==3?O.xyz+=vec3(.847,.157,0):O.xyz+=c==0?.5:c==1?0.:.987;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdfyzf", "name": "Tetrahedron 4", "author": "FabriceNeyret2", "description": "mouse controls camera", "tags": ["raymarching", "tetrahedra", "short", "pseudoapollonians"], "likes": 13, "viewed": 325, "published": 3, "date": "1642439381", "time_retrieved": "2024-07-30T17:09:10.780785", "image_code": "// variant of https://shadertoy.com/view/fsXczf\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))             // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,A,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x),\n        A = sign(q),                                          // symmetry: to closest axis\n#define D(x,y,z) dot(q,vec3(x,y,z))\n        t = min(t, ( max(max(D(1,1,-1),D(1,-1,1)),max(D(-1,1,1),D(-1,-1,-1))) - 1. ) / 1.73 ), // variant of spalmer's tet\n        t = max(t, 1.  - length(q) ),                         // hollow sphere\n        t = max(t, .34 - length(q-.67*A) ),                   // hollow spheres #2\n        t = max(t, .12 - length(q-.89*A) ),                   // hollow spheres #3\n     \n       p += t*D;                                              // step forward = dist to obj          \n    O *= O*O; O*=O*O;                                         // contrast\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdfcRf", "name": "Tetrahedron 3", "author": "FabriceNeyret2", "description": "mouse controls camera.\ncycles in 2pi seconds.", "tags": ["raymarching", "tetrahedra", "short"], "likes": 39, "viewed": 578, "published": 3, "date": "1642438228", "time_retrieved": "2024-07-30T17:09:11.645473", "image_code": "// Fork of spalmer's https://shadertoy.com/view/Ndt3WX\n// minor modification of Fabrice's https://shadertoy.com/view/7s33Df\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))             // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,s; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -4.*R.y) - R),              // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x);\n        for( int i=0; i<4; i++, q*=1.5, q.xy*=rot(.5*iTime) ) { // loop on tets\n            a = abs(q),\n    #define D(x,y,z) dot( q, vec3(x,y,z) ) \n            s = ( max(max(D(1,1,-1),D(1,-1,1)),max(D(-1,1,1),D(-1,-1,-1))) -1. ) /1.73, // variant of spalmer's tet\n            s = max(s, -( max(a.x,max(a.y,a.z))-.9 ) ),       // hollow tet\n            t = min(t, s);\n       }\n      \n       p += .3*t*D;                                           // step forward = dist to obj          \n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dscR2", "name": "Perfect Ellipse AA", "author": "oneshade", "description": "Pixel perfect antialiasing of an ellipse.", "tags": ["antialiasing", "aa", "ellipse", "perfect"], "likes": 10, "viewed": 181, "published": 3, "date": "1642436149", "time_retrieved": "2024-07-30T17:09:12.488220", "image_code": "// See https://www.desmos.com/calculator/u1naqzb34q\n\n#define ANTIALIAS\n\nfloat sqr(in float x) { return x * x; }\nfloat arcint(in float x) { return (asin(clamp(x, -1.0, 1.0)) + x * sqrt(max(0.0, 1.0 - x * x))) / 2.0; }\n\n// Indefinite integral of clamp(ab.y * sqrt(1 - (x / ab.x)^2), mi, ma)\nfloat intClampedArc(in float mi, in float ma, in vec2 ab, in float x) {\n    if (ma < 0.0) return ma * x;\n    if (mi > ab.y) return mi * x;\n    if (mi < 0.0 && ma > ab.y) return ab.x * ab.y * arcint(x / ab.x);\n\n    float r1 = ab.x * sqrt(max(0.0, 1.0 - sqr(ma / ab.y)));\n    float r2 = ab.x * sqrt(max(0.0, 1.0 - sqr(mi / ab.y)));\n\n    if (mi < 0.0) {\n        if (abs(x) < r1) return ma * x;\n        return ab.x * ab.y * arcint(x / ab.x) - (ab.x * ab.y * arcint(r1 / ab.x) - ma * r1) * sign(x);\n    }\n\n    if (ma > ab.y) {\n        if (abs(x) < r2) return ab.x * ab.y * arcint(x / ab.x);\n        return mi * x + (ab.x * ab.y * arcint(r2 / ab.x) - mi * r2) * sign(x);\n    }\n\n    if (abs(x) < r2) {\n        if (abs(x) < r1) return ma * x;\n        return ab.x * ab.y * arcint(x / ab.x) - (ab.x * ab.y * arcint(r1 / ab.x) - ma * r1) * sign(x);\n    }\n\n    return mi * x + ((ab.x * ab.y * arcint(r2 / ab.x) - mi * r2) - (ab.x * ab.y * arcint(r1 / ab.x) - ma * r1)) * sign(x);\n}\n\n// Computes pixel coverage of an ellipse\nfloat ellipseAA(in vec2 p, in vec2 w, in vec2 ab) {\n    vec2 r = w / 2.0;\n    vec2 p1 = p - r, p2 = p + r;\n    float yMin = clamp(p1.y, -ab.y, ab.y), yMax = clamp(p2.y, -ab.y, ab.y);\n\n    float u = intClampedArc(p1.x, p2.x, ab.yx, yMax) - intClampedArc(p1.x, p2.x, ab.yx, yMin);\n    float v = intClampedArc(-p2.x, -p1.x, ab.yx, yMax) - intClampedArc(-p2.x, -p1.x, ab.yx, yMin);\n\n    return (u + v) / (w.x * w.y);\n}\n\nvec3 hue2rgb(in float hue) {\n    //return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    return smoothstep(0.0, 1.0, abs(2.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0)) - 1.0)) * 1.2;\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    //return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float pix = 1.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 ab = vec2(0.3 + 0.25 * cos(iTime), 0.25 + 0.2 * sin(iTime));\n    #ifdef ANTIALIAS\n    color += ellipseAA(uv, vec2(pix), ab);\n    #else\n    uv /= ab;\n    color += step(dot(uv, uv), 1.0);\n    #endif\n\n    // Colorize (a bit distracting from the AA)\n    //color *= hue2rgb(0.5 * (cos(uv.x + iTime) + sin(uv.y)) - 0.25 * iTime);\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dscR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 95, 95, 111], [112, 112, 138, 138, 216], [218, 289, 360, 360, 1258], [1260, 1301, 1352, 1352, 1715], [1717, 1717, 1745, 1849, 2191], [2193, 2193, 2248, 2248, 2788]], "test": "untested"}
{"id": "7dfcRX", "name": "Global Illumination in RT", "author": "Pro_Coder", "description": "Calculation can be reset by pressing R. Camera can move around with WASD. There is a progress bar, which shows the Global Illumination calculation progress. \n\nFor every pixel 4096 Global Illumination Rays are traced.", "tags": ["raytracing", "gi", "globalillumination"], "likes": 3, "viewed": 323, "published": 3, "date": "1642434980", "time_retrieved": "2024-07-30T17:09:13.640140", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coordinates from -1 to 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n\n    vec4 dataGI = GET(iChannel1, GI_DATA);\n    vec4 indirectLight = texture(iChannel2, fragCoord/iResolution.xy);\n    int frame = iFrame - int(dataGI.y);\n    int now = frame%(MAX_INDEX+1);\n    \n    float percent = min(1., float(frame)/float(MAX_INDEX));\n    if(percent != 1. && uv.y > 0.95){\n        if(abs(uv.x) < 0.25){\n            \n            float px = (uv.x + 0.25)*2.;\n            \n            if(px <= percent) fragColor = vec4(1.);\n            else fragColor = vec4(vec3(0.0), 1.);\n            return;\n        }\n    }\n    \n    \n    //Screen coordinates from -1 to 1.\n    uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n    //output color\n    vec3 col = vec3(0.0);\n\n    world.camPosition = GET(iChannel1, CAM_POS_TEXEL);\n    world.viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    float distanceToScreen = world.camPosition.w;\n    \n    //Virtual Screen\n    float screenSizeFactor = 1.0; //The actual screen size depends on the uv\n    vec3 screenNormal = world.viewDirection; //The screen is always perpendicular to the viewDirection\n    vec3 screenTangent = normalize(WORLD_NORMAL + (dot(WORLD_NORMAL, screenNormal) * -screenNormal)); //vector in the direction of the height of the screen\n    vec3 screenBiTangent = normalize(cross(screenNormal, screenTangent)); //vector in direction of the width of the screen\n    \n    //World-position of the pixel\n    vec3 pixelPos = world.camPosition.xyz\n    + (world.viewDirection * distanceToScreen)\n    + (uv.y * screenTangent * screenSizeFactor)\n    + (uv.x * screenBiTangent * screenSizeFactor);\n    \n    vec3 rayDirection = normalize(pixelPos - world.camPosition.xyz);\n    world.rayDirection = rayDirection;\n    \n    \n    if(isKey(KEY_I, IS_PRESSED, iChannel0)){\n        fragColor = vec4(indirectLight.rgb, 1.);\n        return;\n    }\n    \n    //Ray Marching\n    State state = stateMarch(world.camPosition.xyz, rayDirection);\n    \n    vec3 light = indirectLight.rgb + state.light;\n    col = state.mat.color * light;\n     \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define KEYBOARD_CHANNEL iChannel0\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(GI_DATA)){\n            vec4 data = GET(iChannel1, GI_DATA);\n            if(isKey(KEY_R, IS_PRESSED, KEYBOARD_CHANNEL)){\n                fragColor = vec4(1., float(iFrame), 0., 0.);\n            }else{\n                fragColor = vec4(0., data.y, 0., 0.);\n            }\n            \n        }\n        else if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(iChannel1, CAM_POS_TEXEL);\n            vec4 vdir = GET(iChannel1, VIEW_DIR_TEXEL);\n            vec3 tdir = cross(WORLD_NORMAL, vdir.xyz);\n            float speed = MOVE_SPEAD;\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED, KEYBOARD_CHANNEL)){//forward\n                pos.xyz += vdir.xyz * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED, KEYBOARD_CHANNEL)){//backward\n                pos.xyz -= vdir.xyz * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED, KEYBOARD_CHANNEL)){//left\n                pos.xyz += tdir * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED, KEYBOARD_CHANNEL)){//right\n                pos.xyz -= tdir * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                float angleXZ = atan(viewDirection.x, viewDirection.z);\n                angleXZ -= ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05; \n                viewDirection.xyz = normalize(vec3(sin(angleXZ), viewDirection.y, cos(angleXZ)));\n            }\n            fragColor = viewDirection;\n            return;    \n        }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 1.0);\n\n         }    \n    }\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.1415926\n\n//World stuff\n#define LOOK_AT_POSITION vec3(2.0, -2., 0.0)\n\n#define CAM_START_POS vec3(-4., -2., 1.)\n#define CAM_DIS_TO_SCREEN 1.0\n#define WORLD_NORMAL vec3(0.0, 1.0, 0.0)\n#define MOVE_SPEAD 0.1\n\n//Saving variables\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n#define GI_DATA         ivec2(0, 2) \n\n\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type, sampler2D channel){\n    return texture( channel, vec2(checkKey, type)).r > 0.0;\n}\n\n// ----------------------------------------------- //\n//                                              \n//\n//                    Render\n//\n//\n//\n// ----------------------------------------------- //\n\n//defines the GI ray amount. Set to 4, 8, 12, 16, 20, 24, 28, 32, ... 512, ...\n#define AMOUNT_W 32\n#define AMOUNT_H (AMOUNT_W/4)\n#define MAX_INDEX (AMOUNT_W*AMOUNT_H)\n#define PER_FRAME 2\n\n\n#define EXTRA_BOXES\n//#define SHOW_NORMALS\n#define RENDER_DISTANCE 40.\n#define MAX_STEPS 1000\n#define MIN_DISTANCE 0.00001\n\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n};\n\nstruct Material\n{\n    vec3 color;\n    bool lightSource;\n    vec3 lightColor;\n};\n\n//Objects\n#define NO_HIT_MATERIAL Material(vec3(0.0, 0.5, 1.0), false, vec3(1.0))\n#define NO_HIT_ID 0\n#define UNKNOWN_ID -1\n\n//lights. Must also be added to the lightsources array below!\n#define SPHERE_LIGHT_1\n#define SPHERE_LIGHT_1_MATERIAL Material(vec3(1.0), true, vec3(1.0, 1.0, 0.7))\nconst Sphere sphere_light_1 = Sphere(vec3(0.0, -2.0, 0.0), 0.1);\n//#define SPHERE_LIGHT_2\n#define SPHERE_LIGHT_2_MATERIAL Material(vec3(1.0), true, vec3(0.0, 0.2, 0.0))\nconst Sphere sphere_light_2 = Sphere(vec3(3.0, -2.0, 4.0), 0.1);\n\n\n\n//other scene stuff\n#define BOX_2        \nconst Box box_2 = Box(vec3(1.0, -3.5, -2.), vec3(2., 2., 2.));\n#define BOX_3        \nconst Box box_3 = Box(vec3(2.5, -0.5, 1.), vec3(4., 8., 1.));\n#define GROUND \nconst Box ground_ = Box(vec3(0.0, 5.0, 0.0), vec3(10., 1., 10.));\n#define GREY_WALL \nconst Box grey_wall = Box(vec3(0., 0., 5.), vec3(10., 10., 1.));\n#define RED_WALL \nconst Box red_wall = Box(vec3(5., 0., 0.), vec3(1., 10., 10.));\n#define GREEN_WALL\nconst Box green_wall = Box(vec3(-5., 0., 0.), vec3(1., 10., 10.));\n\n\n\n#define BOX_2_MATERIAL        Material(vec3(0.0, 0.0, 1.0), false, vec3(0.0))\n#define GROUND_MATERIAL       Material(vec3(.5),            false, vec3(0.0))\n#define RED_WALL_MATERIAL     Material(vec3(1., 0., 0.),    false, vec3(0.0))\n#define GREEN_WALL_MATERIAL   Material(vec3(0., 1., 0.),    false, vec3(0.0))\n#define BOX_3_MATERIAL        Material(vec3(.3, .3, .3),    false, vec3(0.0))\n\n\n\n\n//world information and current frame information\nstruct World\n{\n    vec4 camPosition; // cam pos (xyz) and distanceToScreen (w)\n    vec3 viewDirection;\n    vec3 rayDirection;\n} world;\n\n\nstruct LightSource\n{\n    vec3 pos;\n};\n\nconst LightSource lightSources[] = LightSource[](\n                                //LightSource(sphere_light_2.position),\n                                LightSource(sphere_light_1.position)\n                            );\n\nconst Material materials[] = Material[12](\n                              NO_HIT_MATERIAL,      //0\n                              Material(vec3(0.7, 0.1, 0.66), false, vec3(0.0)),      //1\n                              SPHERE_LIGHT_1_MATERIAL,//2\n                              Material(vec3(250./255., 179./255., 27./255.), false, vec3(0.0)),      //3\n                              BOX_3_MATERIAL ,      //4\n                              SPHERE_LIGHT_2_MATERIAL,      //5\n                              GROUND_MATERIAL,      //6\n                              BOX_2_MATERIAL,       //7\n                              GROUND_MATERIAL,      //8\n                              GROUND_MATERIAL,      //9\n                              RED_WALL_MATERIAL,    //10\n                              GREEN_WALL_MATERIAL   //11\n                            );\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nmat3 rotAroundYAxis(float angle){\n   return mat3( cos(angle) , 0.,  sin(angle),\n                0.         , 1.,  0.        ,\n                -sin(angle), 0.,  cos(angle)); \n}\n\nmat3 rotAroundZAxis(float angle){\n   return mat3( cos(angle) , -sin(angle), 0,\n                sin(angle) , cos(angle) , 0.,\n                0.         , 0.         , 1.); \n}\n\n\n// normal - normal vector of surface, must be normalized\n// index - between 0 and MAX_INDEX\n//\n// returns new ray direction\nvec3 getNextGIRayDirection(vec3 normal, int index){\n    mat3 rotateBack;\n    \n    if(abs(normal.y) < 0.99){\n        float angleBetweenXZ = acos(dot(normalize(normal.xz), vec2(1., 0.))) * sign(normal.z == 0.0 ? 1.0 : normal.z);\n        float angleBetweenXY = acos(dot(normal, vec3(0., 1., 0.))); //both must be normalized\n\n        //This matrix can transform the vector (0, 1, 0) into the given normal vector\n        //Note: this doesn't work if the normal vector already is (0, 1, 0)!\n        rotateBack =  rotAroundZAxis(-angleBetweenXY)*rotAroundYAxis(-angleBetweenXZ);\n    }\n    \n    vec3 n = vec3(0., 1., 0.);\n    \n    if(index != AMOUNT_H*AMOUNT_W){    \n        int indexH = index % AMOUNT_H;\n        float xy = float(indexH+1) * (PI / float(AMOUNT_H*2+1)) ;\n        float xz = float(index / AMOUNT_H) * ((PI*2.) / float(AMOUNT_W));\n        n *= rotAroundZAxis(xy);\n        n *= rotAroundYAxis(xz);\n    }\n    \n    //rotate back. If normal.y is 1, we do not need to rotate back. Sometimes we have precision issues\n    //so check against 0.99 instead\n    if(abs(normal.y) < 0.99) n*=rotateBack;\n    else n.y *= sign(normal.y);\n    \n    return n;\n}\n\n//functions\nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n}\n\n\nfloat sdfSphere(vec3 pos, Sphere s){\n    return length(pos - s.position) - s.radius;\n}\n\nfloat sdfBox(vec3 p, Box box){\n    p -= box.center;\n    vec3 d = abs(p) - box.size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\n\nint getDistance(vec3 pos, out float dis){\n    dis = RENDER_DISTANCE * 2.;\n    float sphereLight = 100.;\n    float sphereLight2 = 100.;\n    float box2 = 100.;\n    float ground = 100.;\n    float greyWall = 100.;\n    float redWall = 100.;\n    float greenWall = 100.;\n    \n    #ifdef SPHERE_LIGHT_1\n        sphereLight = sdfSphere(pos, sphere_light_1);   \n        dis = min(dis, sphereLight);\n    #endif\n    \n    #ifdef SPHERE_LIGHT_2\n        sphereLight2 = sdfSphere(pos, sphere_light_2);   \n        dis = min(dis, sphereLight2);\n    #endif\n    \n    #ifdef BOX_2\n        box2 = sdfBox(pos, box_2);\n        //box2 = min(box2, rotTest(pos));\n        dis = min(dis, box2);\n    #endif\n    \n    \n    #ifdef GROUND\n        //dublicate the Ground from the ceiling to the ground\n        ground = sdfBox(vec3(pos.x, abs(pos.y), pos.z), ground_);\n        dis = min(dis, ground);\n    #endif\n    \n    #ifdef GREY_WALL\n        greyWall = sdfBox(vec3(pos.x, pos.y, abs(pos.z)), grey_wall);\n        dis = min(dis, greyWall);\n    #endif\n    \n    #ifdef RED_WALL\n        redWall = sdfBox(pos, red_wall);\n        dis = min(dis, redWall);\n    #endif\n    \n    #ifdef GREEN_WALL\n        greenWall = sdfBox(pos, green_wall);\n        dis = min(dis, greenWall);\n    #endif\n    \n    #ifdef EXTRA_BOXES\n        float b1 = sdfBox(pos - vec3(1.5, 3.5, 1.5), box_2);\n        dis = min(dis, b1);\n\n        float b2 = sdfBox(pos - vec3(-2., 3., -1.), box_2);\n        dis = min(dis, b2);\n    #endif\n    \n    #ifdef BOX_3\n        float box3 = sdfBox(pos, box_3);\n        dis = min(dis, box3);\n    #endif\n         \n    if(dis <= MIN_DISTANCE){\n        if(dis == sphereLight){\n            return 2;\n        }else if(dis == sphereLight2){\n            return 5;\n        }else if(dis == box2){\n            return 7;\n        }else if(dis == ground || dis == greyWall){\n            return 9;\n        }else if(dis == redWall){\n            return 10;\n        }else if(dis == greenWall){\n            return 11;\n        }\n        #ifdef EXTRA_BOXES\n        else if(dis == b1){\n            return 1;\n        }else if(dis == b2){\n            return 3;\n        }\n        #endif\n        #ifdef BOX_3\n        else if(dis == box3){\n            return 4;\n        }\n        #endif\n    }else if(dis > MIN_DISTANCE){\n        return NO_HIT_ID;\n    }\n\n    return UNKNOWN_ID;\n}\n\nfloat getDistance(vec3 pos){\n    float d;\n    getDistance(pos, d);\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nint rayMarch(inout vec3 pos, vec3 rd, float fact, out float dis){\n    \n    int outId;\n    dis = MIN_DISTANCE*90.;\n    float cDis = RENDER_DISTANCE*2.;\n    \n    pos = pos + rd * dis;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n       outId = getDistance(pos, cDis);\n       cDis *= fact;\n       \n       \n       if(cDis <= MIN_DISTANCE){\n           return outId;\n           \n       }else if(dis > RENDER_DISTANCE){\n           return NO_HIT_ID;\n           \n       }\n       \n       dis += cDis;\n       pos = pos + rd * cDis;\n       \n    }\n    \n    return UNKNOWN_ID;\n}\n\n\nvec3 getDirectLight(vec3 p, vec3 normal){\n\n    vec3 outLight = vec3(0.0);\n\n    //tempVars\n    vec3 lightDirection;\n    vec3 pCopy;\n    float lightDis;\n    int id;\n    Material mat;\n\n    for(int i = 0; i < lightSources.length(); i++){\n        lightDirection = normalize(lightSources[i].pos - p);\n        pCopy = p;\n        id = rayMarch(pCopy, lightDirection, 1., lightDis);\n        vec3 dist = lightSources[i].pos - pCopy;\n        if(dot(dist, dist) < 1.){\n            //We hit the actual Lightsource, we wanted to hit.\n            //Note, this does not work, if the lightsources are too big\n            //or to close to each other!\n            mat = materials[id];\n            outLight += mat.lightColor * dot(normal, lightDirection);\n        }\n        \n    }\n    \n    return outLight;\n}\n\n\nstruct State\n{\n    bool isSky;\n    vec3 newPos;\n    vec3 normal;\n    Material mat;\n    vec3 light;\n    float dis;\n};\n\nState stateMarch(vec3 pos, inout vec3 rd){\n    vec3 p = pos;\n    float dis;\n    \n    //hit\n    int hitId = max(0, rayMarch(p, rd, 1., dis)); \n    Material mat = materials[hitId];\n    vec3 normal = getNormal(p);\n    \n    if(hitId == NO_HIT_ID){\n        return State(true, p, vec3(0.), mat, mat.lightColor, dis);\n    }\n           ;\n    vec3 light = getDirectLight(p, normal);\n    \n    return State(false, p, normal, mat, light, dis); \n}\n\n", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coordinates from -1 to 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n    //output color\n    vec4 info = texture(iChannel0, fragCoord/iResolution.xy);\n   \n    vec3 col = vec3(0.0);\n\n    world.camPosition = GET(iChannel1, CAM_POS_TEXEL);\n    world.viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    float distanceToScreen = world.camPosition.w;\n    \n    //Virtual Screen\n    float screenSizeFactor = 1.0; //The actual screen size depends on the uv\n    vec3 screenNormal = world.viewDirection; //The screen is always perpendicular to the viewDirection\n    vec3 screenTangent = normalize(WORLD_NORMAL + (dot(WORLD_NORMAL, screenNormal) * -screenNormal)); //vector in the direction of the height of the screen\n    vec3 screenBiTangent = normalize(cross(screenNormal, screenTangent)); //vector in direction of the width of the screen\n    \n    //World-position of the pixel\n    vec3 pixelPos = world.camPosition.xyz\n    + (world.viewDirection * distanceToScreen)\n    + (uv.y * screenTangent * screenSizeFactor)\n    + (uv.x * screenBiTangent * screenSizeFactor);\n    \n    vec3 rayDirection = normalize(pixelPos - world.camPosition.xyz);\n    world.rayDirection = rayDirection;\n    \n    \n    \n    \n    //Ray Marching\n    State state = stateMarch(world.camPosition.xyz, rayDirection);\n    \n    if(state.isSky) return;\n    \n    col = state.mat.color;\n\n    //Global Illumination\n    vec4 dataGI = GET(iChannel1, GI_DATA);\n    vec3 rayDirectionGI;\n    State stateGI;\n    State stateDL;\n    vec3 lrd;\n    float lightGI = info.w;\n    int frame = iFrame - int(dataGI.y);\n    int now = frame%(MAX_INDEX+1);\n    if(dataGI.x == 1.0){\n        fragColor = vec4(0., 0., 0., 0.);\n        return;\n    }else{\n        if(frame <= MAX_INDEX){\n            \n            for(int i = now; i < (now + PER_FRAME); i++){\n                rayDirectionGI = getNextGIRayDirection(state.normal, i);\n                stateGI = stateMarch(state.newPos, rayDirectionGI);                \n                \n                if(!stateGI.mat.lightSource && !stateGI.isSky) {\n                    //GI ray did not hit a lightSource!\n                    vec3 light = stateGI.light / float(MAX_INDEX*4);\n                    info.rgb += stateGI.mat.color * light;\n                }else if(stateGI.isSky){\n                    info.rgb += stateGI.light / float(MAX_INDEX*4);\n                }else{\n                    //GI ray hit a light source!\n                    //In Theory, it would be possible to calculate the Direct light also with GI,\n                    //but that doesnt really work for me, cause I get a lot of Artifcats\n                    //Maybe it works with a really high amount of GI rays\n                    //Or more GI rays in the direction of the light source\n                    //info.rgb += stateGI.mat.lightColor * dot(stateGI.newPos, stateGI.normal) / float(MAX_INDEX/10);\n                }\n            }\n        }\n    }\n    info.w = lightGI;\n      \n    fragColor = info;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 96, 2184]], "test": "untested"}
{"id": "ssfyzX", "name": "Dancing lights", "author": "fzy", "description": "private test for montlhy art", "tags": ["dancinglights"], "likes": 4, "viewed": 223, "published": 3, "date": "1642433370", "time_retrieved": "2024-07-30T17:09:14.796049", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - iResolution.xy*0.5 ) / iResolution.y;\n    //uv /= iResolution.x;\n\n    float time = mod(iTime, 117.);\n\n    if (time < 22.)\n        fragColor = rosace(iResolution, uv, time);\n    else if (time < 41.)\n        fragColor = lines(iResolution, uv, time - 22.);\n    else\n        fragColor = circles(iResolution, uv, time - 41.);\n    //fragColor = circles(iResolution, uv, iTime);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Function to calculate distance\nfloat distance2(vec2 v1, vec2 v2)\n{\n    return pow(v2.x - v1.x, 2.) + pow(v2.y - v1.y, 2.);\n}\n\nfloat cross2(vec2 pc, vec2 p1, vec2 p2)\n{\n    float dxc = pc.x - p1.x;\n    float dyc = pc.y - p1.y;\n\n    float dxl = p2.x - p1.x;\n    float dyl = p2.y - p1.y;\n\n    return dxc * dyl - dyc * dxl;\n}\n\nconst int   count = 45;\n\nvec4 circles(vec3 iResolution, vec2 uv, float iTime)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 coord = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n\tvec2 center = iResolution.xy/2.;\n\n    // Time varying pixel color\n     vec3 color = vec3(0.0);\n\n    for(int i = 0; i < count; i++)\n    {\n       float originalRadius = iTime/10.;// * 3. / 200.;\n       float rad = radians(360.0 / float(count)) * float(i) + iTime;\n\n       if (iTime > 45.)\n       {\n           //radius = max(0., 60. - iTime) / 100.;\n       }\n\n       float flatness = 1.;\n       if (iTime > 25.)\n       {\n           flatness = max(0., (45. - iTime) / 20.);\n       }\n\n       //if (iTime > 45.)\n       //{\n       //   time = 60.- iTime;\n       //    if (flatness == 0.)\n       //        flatness = cos(rad);\n       //    flatness = flatness * min(1., (iTime - 45.) / 15.);\n       //}\n\n        for (int nbCircle = 0; nbCircle < 10; nbCircle++)\n        {\n            float time = iTime;\n           if (iTime > 45.)\n               time = 60.- iTime;\n            float radius = time / 100. * float(nbCircle);\n            rad *= -1.;\n            radius = mod(radius, 1.3);\n            float colorMult = 0.0007 * min(iTime, 1.);\n           if (iTime > 60.)\n           {\n               radius = 0.;\n               colorMult -= (iTime - 60.) * 0.00005;\n           }\n            color += col * colorMult / length(uv + vec2(radius * cos(rad), radius * sin(rad) * flatness));\n        }\n        //color += col * 0.001 / length(uv + vec2(radius * cos(rad), radius * sin(rad) * flatness));\n        //radius *= 0.2;\n        //rad *= -1.;\n        //color += col * 0.001 / length(uv + vec2(radius * cos(rad), radius * sin(rad) * flatness));\n\n        //color += col * 0.001 / length(uv + vec2(radius * sin(rad) * cos(rad), radius * flatness));\n    }\n\n    // Output to screen\n    return vec4(color,1.0);\n}\n\nconst float PI = 3.14159265359;\nvec4 rosace(vec3 iResolution, vec2 uv, float iTime)\n{\n    //uv = ( 2.*fragCoord - R ) / R.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float countMult = abs(sin(iTime/ 2.)) * 120.;\n    int count = int(countMult);\n    for(int i = 0; i < count; i++)\n    {\n        float percent = (float(i) / float(count));\n        percent = mod(percent + iTime / 5.,  1.);\n        float distanceToLine = abs(cross2(uv, vec2(0.), vec2(cos(percent * PI), sin(percent * PI))));\n        float maxDistToLine = 0.001;\n        maxDistToLine *= iTime * iTime / 9.;\n        if (distanceToLine < maxDistToLine)\n                col = col + vec3((1. - (distanceToLine / maxDistToLine)) * 0.5);\n        //col = col + vec3((1. - (distanceToLine * 10.)) * 0.2);\n    }\n    \n    return vec4(col,1.0);\n}\n\nfloat f[102] = float[102]( 0.4188,0.6803,0.8351,0.3931,0.1484,0.3489,0.1822,0.7921,0.5776,0.9585,0.4354,0.9094,0.5859,0.3453,0.4575,0.7487,0.5225,0.0288,0.6419,0.7387,0.8284,0.63,0.5873,0.1152,0.9798,0.8107,0.4874,0.5231,0.1614,0.4882,0.4668,0.6859,0.1536,0.8647,0.5416,0.6051,0.0466,0.5658,0.4728,0.4422,0.5758,0.4453,0.2487,0.0069,0.397,0.8259,0.7331,0.5653,0.7406,0.9684,0.8633,0.4285,0.3096,0.6653,0.0481,0.7099,0.2539,0.8341,0.293,0.6564,0.8789,0.6588,0.6868,0.7394,0.6775,0.3235,0.0148,0.7472,0.9446,0.8022,0.3768,0.1409,0.6058,0.6033,0.3116,0.5055,0.5784,0.461,0.3446,0.6589,0.4123,0.6917,0.3609,0.5184,0.4885,0.6628,0.3636,0.6953,0.2945,0.2809,0.1784,0.8433,0.3716,0.4287,0.8966,0.0248,0.2529,0.6683,0.9053,0.5581,0.0454,0.6303);\nvec4 lines(vec3 iResolution, vec2 uv, float iTime)\n{\n    vec3 col = vec3(0.);\n    \n    //float countMult = abs(sin(iTime / 2.)) * 120.;\n    int count = 100;//int(countMult);\n    for(int i = 0; i < count; i++)\n    {\n        float percent = f[i];\n        \n        float maxMod = 1.5;\n        float time = iTime;\n        if (iTime > 12.)\n        {\n            time -= 12.;\n            maxMod = 5.;\n        }\n        if (mod(float(i), 2.) > 0.)\n            percent = mod(percent * 1.5 + time / 4., maxMod) - 0.75;\n        else\n            percent = mod(percent * 1.5 - time / 4., maxMod) - 0.75;\n        float lineXPos = percent*3.;\n        float rotation = 1.;\n        if (iTime > 7.) // add rotation\n            rotation = cos(iTime-7.);// + 1.;\n        vec2 p1 = vec2(percent, 0.);\n        vec2 p2 = vec2(percent + (f[i + 1] * 2. - 1.) * rotation, 0.5);\n        \n        //float slope = (f[i + 1] * 2. - 1.) / 0.3;\n        vec2 perp = vec2(0.3, -(f[i + 1] * 2. - 1.));\n        perp *= percent;\n        \n        p1 += perp;\n        p2 += perp;\n        \n        if (iTime > 12.) // lining up\n            p2.x -= (p2.x - p1.x) * min((iTime - 13.) / 5., 1.);\n        \n        vec2 uv2 = uv;\n\n        float distanceToLine = abs(cross2(uv2, p1, p2));\n        float maxDistToLine = max(0.01, 0.1 - iTime / 30.);\n        if (distanceToLine < maxDistToLine)\n        {\n            if (false) // apply color\n                col = col + vec3(sin(iTime+uv.xyx+vec3(0,2,4)) * (1. - (distanceToLine / maxDistToLine)) * 0.5);\n            else\n                col = col + vec3((1. - (distanceToLine / maxDistToLine)) * 0.5);\n        }\n    }\n    \n    return vec4(col,1.0);\n}\n\n#define CS(a)  vec2(cos(a),sin(a))\n\nvec4 test(vec3 iResolution, vec2 uv, float iTime)\n{\n    vec2 R = iResolution.xy;\n\n    float PI = 3.14159,\n        phi = iTime*0.001 + 0.1, // or phi = (1. + sqrt(5.))/2.,\n          a = phi * 2.*PI,\n         i0 = ( length(uv) - .01 ) /.0015,\n         i1 = ( mod( atan(uv.y,uv.x) ,2.*PI) )/ a, // + k*2PI/a\n          k = floor( (i0-i1) / (2.*PI/a) ), \n          i, d = 1e9;\n    \n    for (float n = 0.; n < 2.; n++) {\n        i = round( i1 + k++ * 2.*PI/a );\n        vec2 p = ( .01+ 0.0015*i ) *CS(i*a);\n    \td = min( d, length(uv - p) - .001 );   \n    }\n  \n      vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    return vec4(smoothstep(3./iResolution.y, 0., d - .01) * col, 0.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 459]], "test": "untested"}
{"id": "fdXyRX", "name": "Oily thing", "author": "pancakespeople", "description": "I dunno whats going on here.", "tags": ["oil", "screensaver"], "likes": 1, "viewed": 318, "published": 3, "date": "1642413029", "time_retrieved": "2024-07-30T17:09:15.770444", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float calmness = 0.1;\n    float waveIntensity = 0.5;\n    \n    vec2 noiseCoord = uv;\n    noiseCoord.x += cos(iTime / 10.0);\n    noiseCoord.y += sin(iTime / 10.0);\n    \n    uv.x += noise(noiseCoord / calmness) * waveIntensity;\n    uv.y += noise((noiseCoord + 100.0) / calmness) * waveIntensity;\n\n    vec4 col = texture(iChannel0, uv);\n    col += noise(noiseCoord);\n    col *= vec4(0.3, 0.6, 1.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 248, 270, 270, 674], [676, 676, 733, 783, 1281]], "test": "untested"}
{"id": "7slyRj", "name": "Star systems evolution", "author": "ersh", "description": "Star dynamics. Mass conservation guaranteed. Walls in reality do not exist but this makes it more fun :)", "tags": ["simulation"], "likes": 22, "viewed": 459, "published": 3, "date": "1642395756", "time_retrieved": "2024-07-30T17:09:16.590252", "image_code": "// (C) Copyright 2021 by Yury Ershov\n\n// https://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics\n\n#define PALETTE        0    // 0=fire, 1=blue, 2=green\n\nvec3 col(float x) {\n  return vec3(\n#if PALETTE == 0\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n#elif PALETTE == 1\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x, 0., 1./3.)\n#elif PALETTE == 2\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.)\n#endif\n   ) * 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.a = 1.0;\n\n\tfragColor.rgb = col(log(texture(iChannel0,uv).a*10000.)/12.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define WALLS_ACTION   2      // 0=none  1=bounce  2=wrap\n#define RANGE          10.    // Increase for better simulation\n\n#define CH iChannel0\n\nconst float dt = 1.;\nconst float G = 0.01;\nconst float m_epsilon = 0.000001;\nconst float speed_rnd = 0.08;\nconst float center_gravity = 0.0005;\n\nvec2 vclamp(vec2 v) {\n    float l = length(v);\n    return l < 10. ? v : v/l;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat overlapping_area(vec2 l1, vec2 r1, vec2 l2, vec2 r2)\n{\n    float x_dist = min(r1.x, r2.x) - max(l1.x, l2.x);\n    float y_dist = min(r1.y, r2.y) - max(l1.y, l2.y);\n    return x_dist > 0. && y_dist > 0. ? x_dist * y_dist : 0.;\n}\n\nvec2 randomizespeed(vec2 v) {\n    return vec2(v.x + (hash12(fract(v)*1573.32)-0.5)*speed_rnd, v.y + (hash12(fract(v)*178362.78)-0.5)*speed_rnd);\n}\n\n\n// Gas dynamics layer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if WALLS_ACTION == 1\n    if (fragCoord.x < 1.5 || fragCoord.y < 1.5 || fragCoord.x > iResolution.x-1.5 || fragCoord.y > iResolution.y-1.5) { fragColor=vec4(0.); return; }\n#endif\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2 || iMouse.z > 0.) {\n        float r = distance(fragCoord, iResolution.xy/2.);\n        if (r < 50.) {\n            fragColor = vec4(0.0,-(uv.y - 0.5)*30./(r+1.)*50.,(uv.x - 0.5)*30./(r+1.)*50.,hash12(fragCoord)*5.*(52.-r)/20.);\n        } else {\n//            fragColor = vec4(0.0,0.0,0.0,hash12(fragCoord)*100.*m_epsilon);\n            fragColor = vec4(0.0);\n        }\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec4 pt0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 speed0 = pt0.gb;\n    float mass0 = pt0.a;\n    vec2 f = vec2(0.);\n    vec2 p = vec2(0.);\n    float mass2 = 0.;\n\n    vec2 sh;\n    for (sh.y = -RANGE; sh.y < RANGE+0.5; sh.y+=1.) for (sh.x = -RANGE; sh.x < RANGE+0.5; sh.x+=1.) {\n        float l = length(sh);\n        vec2 coord1 = fragCoord + sh;\n        vec4 pt1 = texelFetch(iChannel0, ivec2(mod(coord1 + iResolution.xy, iResolution.xy)), 0);\n        vec2 speed1 = pt1.gb;\n        float mass1 = pt1.a;\n\n        if (l > 3.5) {    // must be 0.5 but bigger number prevents from collapsing into 2x2 dots.\n            // Gravity, acceleration\n            f += sh/l * mass0*mass1/l/l;\n        }\n\n        // speed: mass transfer, impulse change:\n        vec2 coord_next = coord1 + speed1 * dt;\n        float overlap = overlapping_area(fragCoord, fragCoord+vec2(1.,1.), coord_next, coord_next+vec2(1.,1.));\n        float dm = mass1 * overlap;\n        mass2 += dm;\n        p += speed1 * dm;\n    }\n    \n    // Slight gravity towards the center to compensate the inability to feel further than 10 pts.\n    vec2 to_c = iResolution.xy/2. - fragCoord;\n    to_c = length(to_c) < 5. ? vec2(0.) : normalize(to_c)*center_gravity;\n\n    fragColor.r = 0.;\n    fragColor.a = mass2 > m_epsilon ? mass2 : 0.;\n    fragColor.gb =\n        mass2 > m_epsilon ?\n        vclamp(randomizespeed(p/mass2 + dt * G*f/(mass0 > m_epsilon ? mass0 : mass2) + dt*to_c)) : vec2(0.);\n#if WALLS_ACTION == 1\n    if (fragCoord.x <= 11.) {\n        if (fragColor.g < 0.) fragColor.g = abs(fragColor.g)/2.;\n    } else if (fragCoord.x >= iResolution.x - 12.) {\n        if (fragColor.g > 0.) fragColor.g = -abs(fragColor.g)/2.;\n    }\n    if (fragCoord.y <= 11.) {\n        if (fragColor.b < 0.) fragColor.b = abs(fragColor.b)/2.;\n    } else if (fragCoord.y >= iResolution.y - 12.) {\n        if (fragColor.b > 0.) fragColor.b = -abs(fragColor.b)/2.;\n    }\n#endif\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 604, 604, 735]], "test": "untested"}
{"id": "fdscz2", "name": "Image Tracking II - Eyes/Head", "author": "oneshade", "description": "Calibrate by positioning your eyes in the two circles. They'll disappear when the tracker has locked on. If it locks onto something else, try restarting the shader. Then try tilting and moving your head (SLOWLY, and try not to blink).", "tags": ["eyes", "cv", "image", "tracking", "useless"], "likes": 6, "viewed": 732, "published": 3, "date": "1642395110", "time_retrieved": "2024-07-30T17:09:17.486855", "image_code": "// If anyone knows how to do this sort of tracking better, please let me know!\n\n// https://www.shadertoy.com/view/WtdBRS\nfloat sdMoon(in vec2 p, in float d, in float ra, in float rb) {\n    p.y = abs(p.y);\n\n    float a = (ra * ra - rb * rb + d * d) / (2.0 * d);\n    float b = sqrt(max(ra * ra - a * a, 0.0));\n    if (d * (p.x * b - p.y * a) > d * d * max(b - p.y, 0.0)) {\n        return length(p - vec2(a, b));\n    }\n\n    return max(length(p) - ra, rb - length(p - vec2(d, 0.0)));\n}\n\nvec3 heatPalette(in float h) {\n    return vec3(1.0, pow(0.95, h), pow(0.1, h)) * pow(0.98, h);\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float unit = 2.0 / iResolution.y;\n\n    fragColor = texture(iChannel0, uv);\n    //fragColor.rgb = heatPalette(length(fragColor.rgb) * 100.0);\n\n    vec3 eye1 = texelFetch(iChannel1, ivec2(0, 0), 0).xyz;\n    vec3 eye2 = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n\n    float aspect = iResolution.x / iResolution.y;\n\n    uv -= 0.5;\n    uv.x *= aspect;\n\n    if (eye1.z > 0.5 && eye2.z > 0.5) {\n        eye1.xy -= 0.5;\n        eye1.x *= aspect;\n\n        eye2.xy -= 0.5;\n        eye2.x *= aspect;\n\n        if (length(uv - eye1.xy) < 0.01) fragColor++;\n        if (length(uv - eye2.xy) < 0.01) fragColor++;\n\n        vec2 pos = (eye1.xy + eye2.xy) / 2.0;\n        vec2 right = normalize(eye2.xy - eye1.xy);\n        mat2 basis = mat2(right, -right.y, right.x);\n        uv = (uv - pos) * basis;\n\n        uv.y -= 0.25;\n        uv.x = 0.1 - abs(uv.x);\n        float tilt = 0.2;\n        float co = cos(tilt), si = sin(tilt);\n        uv *= mat2(co, si, -si, co);\n        drawSDF(max(sdMoon(uv, 0.2, 0.2, 0.3), -0.1 - uv.y), vec3(1.0, 0.0, 0.0));\n    }\n\n    else {\n        vec2 pEyeLock1 = eyeLock1 - 0.5;\n        pEyeLock1.x *= aspect;\n        drawSDF(abs(length(uv - pEyeLock1) - minLock), vec3(1.0));\n\n        vec2 pEyeLock2 = eyeLock2 - 0.5;\n        pEyeLock2.x *= aspect;\n        drawSDF(abs(length(uv - pEyeLock2) - minLock), vec3(1.0));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WIN_W 40.0\n#define WIN_H 40.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float x=-WIN_W; x < WIN_W; x++) {\n        float weight = 0.1 * exp(-smoothing * x * x);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(x, 0.0)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define WIN_W 40.0\n#define WIN_H 40.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float y=-WIN_H; y < WIN_H; y++) {\n        float weight = 0.1 * exp(-smoothing * y * y);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(0.0, y)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define video(x, y) texture(iChannel0, vec2(x, y)).r\nvec2 newtonOptimize(in vec2 p0) {\n    vec2 p = p0;\n    vec2 h = 1.0 / iResolution.xy;\n    for (int i=0; i < 10; i++) {\n        float up = video(p.x, p.y + h.y);\n        float right = video(p.x + h.x, p.y);\n        vec2 grad = vec2(right, up) - video(p.x, p.y);\n\n        float dxx = (video(p.x + 2.0 * h.x, p.y) - right - grad.x) / (h.x * h.x);\n        float dxy = (video(p.x + h.x, p.y + h.y) - right - grad.y) / (h.x * h.y);\n        float dyy = (video(p.x, p.y + 2.0 * h.y) - up    - grad.y) / (h.y * h.y);\n\n        grad /= h;\n        mat2 hessian = mat2(dxx, dxy, dxy, dyy);\n\n        p -= inverse(hessian) * grad;\n    }\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord == ivec2(0, 0)) {\n        fragColor = texelFetch(iChannel1, ivec2(0, 0), 0);\n        if (fragColor.z < 0.5) {\n            fragColor.xy = newtonOptimize(eyeLock1);\n            if (length(fragColor.xy - eyeLock1) < minLock) {\n                fragColor.z = 1.0;\n            }\n        }\n\n        else {\n            fragColor.xy = newtonOptimize(fragColor.xy);\n        }\n    }\n\n    if (iFragCoord == ivec2(1, 0)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        if (fragColor.z < 0.5) {\n            fragColor.xy = newtonOptimize(eyeLock2);\n            if (length(fragColor.xy - eyeLock2) < minLock) {\n                fragColor.z = 1.0;\n            }\n        }\n\n        else {\n            fragColor.xy = newtonOptimize(fragColor.xy);\n        }\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define eyeLock1 vec2(0.42, 0.5)\n#define eyeLock2 vec2(0.58, 0.5)\n#define minLock 0.05\n#define smoothing 0.005", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdscz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 121, 184, 184, 481], [483, 483, 513, 513, 579], [681, 681, 736, 736, 2116]], "test": "untested"}
{"id": "flGXRc", "name": "2D Heat Equation - Square", "author": "oneshade", "description": "It turns out that with a slight modification, a convolution with a gaussian kernel gives the exact solution to the 2D heat equation. So the initial function literally just becomes more blurred over time.", "tags": ["2d", "heat", "pde", "plate"], "likes": 16, "viewed": 448, "published": 3, "date": "1642379916", "time_retrieved": "2024-07-30T17:09:18.385452", "image_code": "// Error function approximation\nfloat erf(in float x) {\n    //return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n    float t = 1.0 / (1.0 + 0.3275911 * abs(x));\n    return (1.0 - (((((1.061405429 * t - 1.453152027) * t + 1.421413741) * t - 0.284496736) * t + 0.254829592) * t) * exp(-x * x)) * sign(x);\n}\n\nvec3 heatPalette(in float h) {\n    return pow(vec3(0.98, 0.93, 0.1), vec3(h));\n}\n\nfloat heatSquare(in vec2 p, in float t, in float k) {\n    float w = 2.0 * sqrt(k * t);\n    float a = erf((p.x + 1.0) / w) - erf((p.x - 1.0) / w);\n    float b = erf((p.y + 1.0) / w) - erf((p.y - 1.0) / w);\n    return a * b / 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 5.0;\n    vec2 corner = vec2(2.5 * iResolution.x / iResolution.y, 2.5);\n\n    float t = max(0.0, iTime - 1.0);\n    float temp = heatSquare(uv, t, 0.01);\n    fragColor = vec4(heatPalette((1.0 - temp) * 100.0), 1.0);\n\n    vec2 textTimeUv = 0.25 * (uv + corner + vec2(0.3, -0.1));\n    fragColor.rgb = digitIn(fragColor.rgb, vec3(1.0), textTimeUv, 100.0, t);\n}", "image_inputs": [], "common_code": "        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 55, 115, 307], [309, 309, 339, 339, 389], [391, 391, 444, 444, 621], [623, 623, 678, 678, 1100]], "test": "untested"}
{"id": "fslczj", "name": "[ the floating ring creature ]", "author": "SimonOakey", "description": "part of the MACHINEPAINTING series - // updated with the help of @FabriceNeyret2", "tags": ["ring", "loop", "oscillation", "slow", "float", "creature"], "likes": 6, "viewed": 297, "published": 3, "date": "1642377897", "time_retrieved": "2024-07-30T17:09:19.202268", "image_code": "// random function\n#define rand(n) fract(cos(n*89.42)*343.42)\n\n//draw a even nicer ring\n#define nice_ring(U,P,r,w)   w / abs(length(P - U) - r)\n\n// generic rotation by angle\n#define rot(a) mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 R = iResolution.xy;\n   \tvec2 uv = ( 2.* fragCoord.xy - R.xy  ) / R.y;\n \n\tfloat t = iTime*.3 + 123. , s = 0., r = 0.1, w = .22;\n\t\n\t// make the creature rotate at all\n\tuv *= rot(sin(t*1.3)*.3);\n    \n    // make it move over the screen\n     uv.x += sin(t*.6)*.3;\n     uv.y += sin(t*.3)*.2;\n\t\n\t// sinus mirror\n\t uv.x *= sin((uv.x)*1.);\n\tuv.x *=1.25; // against the x stretching a bit\n\t\n\t// rotate within axis\n\tuv *= rot(t*.2);\n\t\t\n\tfloat deform_amplitude = sin(t*.9)*.8+.2;\n\tfloat deform_freq = sin(t*.6)*.8+.2;\n    \n    \n    for(float i=0.;i<16.;i++){\n\t\t\n\t\tvec2 posi = vec2(sin(t*i*.156 + i*12.2423)*.3 , sin(i*12.45313 + t*.132*i)*.3 );\n\t\t\n\t\t uv.x += sin(uv.y*6.*deform_freq + t*.6)*.01*deform_amplitude;\n\t\t uv.y += sin(uv.x*6.*deform_freq + t*.3)*.01*deform_amplitude;\n\t\t\n\t\ts += nice_ring( uv, posi, r,w*.01 );\n\t\t\n\t\t// shrink stuff\n\t\t r +=.025 ;\n\t\t w +=.05 - i*.002;\n\t\t\n\t}\n\t\n\ts = smoothstep(1.,.3,s)*.8-.2;\n    \n \t// lowkey dithering - very light for nice fullscreen grain\n\ts -= rand(uv.x)*.02; \n\t\n\t// tweaky vignette whatever  \n\tfloat vig = uv.x*uv.y * 10.0; \n\ts += vig*.01;\n       \t\t\n\tfragColor = vec4( vec3(s), 1.0 );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 288, 288, 1430]], "test": "untested"}
{"id": "NsfcRS", "name": "Horse Automaton", "author": "wyatt", "description": "Rigid body simulation of horse shape with legs that form circles with their feet as it walks.", "tags": ["horsie"], "likes": 31, "viewed": 508, "published": 3, "date": "1642376511", "time_retrieved": "2024-07-30T17:09:20.020082", "image_code": "Main\n    Q = vec4(0);\n    U -= .5*R;\n    U *= 2.;\n    U += .5*R;\n    U += A(BACK).xy-vec2(.5,.5)*R;\n    DRAW(HEAD,3,2)\n    DRAW(NECK,4,2)\n    DRAW(SHOULDER,5,4)\n    DRAW(BACK,5,5)\n    DRAW(BUTT,4,5)\n    DRAW(TAIL,0,3)\n    DRAW(BACK_LEG_RIGHT,2,4)\n    DRAW(BACK_LEG_LEFT,2,4)\n    DRAW(BACK_FOOT_RIGHT,1,2)\n    DRAW(BACK_FOOT_LEFT,1,2)\n    DRAW(FRONT_LEG_RIGHT,3,2)\n    DRAW(FRONT_LEG_LEFT,3,2)\n    DRAW(FRONT_FOOT_RIGHT,2,1)\n    DRAW(FRONT_FOOT_LEFT,2,1)\n    \n    Q += pow(B(.5*(2.*U-1.5*vec2(A(BACK).xy))),vec4(5));\n    Q += pow(B(.5*(U-.5*vec2(A(BACK).xy))),vec4(4));\n    Q += pow(B(.5*(1.5*U-1.*vec2(A(BACK).xy))),vec4(8));\n    Q -= step(U.y,HEIGHT(U.x));\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; float dT; int I;\n#define Main void mainImage(out vec4 Q, in vec2 U) { R=iResolution.xy;M=iMouse;T=iTime;dT=iTimeDelta;I=iFrame;\nfloat ln (vec2 p, vec2 a, vec2 b, float r1, float r2) { \n    float x = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n    return length(p-a-(b-a)*x)-mix(r1,r2,x);\n}\nstruct dual {\n    vec2 xy;\n    float z;\n    vec2 dxy;\n    float dz;\n};\ndual set_dual(vec4 a, vec4 b) {return dual(a.xy,a.z,b.xy,b.z);}\nvec4 first (dual a) {return vec4(a.xy,a.z,1);}\nvec4 second (dual a) {return vec4(a.dxy,a.dz,1);}\n#define pi 3.14159265359\n#define dt .2\n#define L (R.x*.07)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define G(x) (vec2(x,0)+.5)\n#define S(o) (L*an(o.z))\n#define dS(o) (L*an(o.z+.5*pi)*o.dz)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define an(a) vec2(cos(a),sin(a))\n#define SET(g,b) if (length(U-(g))<.5) Q = first(b); if (length(U-(g)-vec2(0,1))<.5) Q = second(b);\n#define GET(g,b) dual b = set_dual(A(g),A((g)+vec2(0,1)));\n#define BEHIND(a,b) a.xy = b.xy-S(b)-S(a); a.dxy = b.dxy-dS(b)-dS(a);\n#define INFRONT(a,b) b.xy = a.xy+S(a)+S(b); b.dxy = a.dxy+dS(a)+dS(b);\nvoid draw (inout vec4 Q, vec2 U, vec4 b, vec4 db, float j, float k) {\n    vec2 v = S(b); \n    float l = ln(U+vec2(0,-15.),\n                    b.xy-v,b.xy+v,\n                    10.*float(j),10.*float(k)\n                );\n    Q += .6*vec4(1.-Q)*\n    smoothstep(8.,5.,abs(l));\n}\n#define DRAW(g,j,k) draw(Q,U,A((g)),A((g)+vec2(0,1)),float(j),float(k));\n#define HEIGHT(x) (.1*R.y*(.0001*(x)+2.*sin(10.*sin(.0005*x)+(x)*.001)+.7+.5*sin(.003*(x))+.1*sin(.02*(x))+.3*sin(.004*(x))+.05*sin(.03*(x))+.03*sin(.1*(x))+.01*sin(.2*(x)) ))\n#define gravity -1e-2\nvoid calc_force(dual pt, vec2 bk, inout vec2 force, inout float torq) {\n    vec2 a = pt.xy - S(pt);\n    vec2 b = pt.xy + S(pt);\n    vec2 da = pt.dxy - dS(pt);\n    vec2 db = pt.dxy + dS(pt);\n    #define DH(x) normalize(vec2(-1./R.y*(HEIGHT(x+1.)-HEIGHT(x-1.)),1))\n    if (a.y < HEIGHT(a.x)) {\n        vec2 dh =  DH(a.x);\n        vec2 im = dh*.2-.3*da;\n        im += .5*vec2(-dh.y,dh.x)*atan(-dot(da,dh));\n        vec2 r = a-bk;\n        torq -= dot(r,vec2(-im.y,im.x))/(10.*L*L);\n        force.xy += im*abs(dot(normalize(r),normalize(im)));\n        \n    }\n    if (b.y < HEIGHT(b.x)) {\n        vec2 dh =  DH(b.x);\n        vec2 im = dh*.2-.3*db;\n        im += .5*vec2(-dh.y,dh.x)*atan(-dot(db,dh));\n        vec2 r = b-bk;\n        torq -= dot(r,vec2(-im.y,im.x))/(10.*L*L);\n        force.xy += im*abs(dot(normalize(r),normalize(im)));\n    }\n}\n#define FORCE(g) calc_force((g),back.xy,force,torq);\nvoid place (dual p1, inout dual p2, inout dual p3, vec2 v, vec2 t) {\n    float theta = acos(min(.5*length(t),1.));\n    float phi = atan(t.y,t.x);\n    float z = p2.z;\n    p2.z = phi+theta;\n    p2.dz = p2.z-z;\n    z = p3.z;\n    p3.z = phi-theta;\n    p3.dz = p3.z-z;\n}\n#define PLACE(p1,p2,p3,t) place((p1),(p2),(p3),(p1).xy-S(p1),t);\n/*\n\n                 _\n            ____/\n           /|\\ |\\\n            | || |\n\n\n*/\n#define BACK             G(0)\n#define BUTT             G(1)\n#define TAIL             G(2)\n#define BACK_LEG_RIGHT   G(4)\n#define BACK_LEG_LEFT    G(5)\n#define FRONT_LEG_RIGHT  G(6)\n#define FRONT_LEG_LEFT   G(7)\n#define BACK_FOOT_RIGHT  G(8)\n#define BACK_FOOT_LEFT   G(9)\n#define FRONT_FOOT_RIGHT G(10)\n#define FRONT_FOOT_LEFT  G(11)\n#define SHOULDER         G(12)\n#define NECK             G(13)\n#define HEAD             G(14)\n\n\n\n\n\n", "buffer_a_code": "Main if (U.y>2.||U.x>20.) discard;\n  //\n    GET(HEAD,head)\n    GET(NECK,neck)\n    GET(SHOULDER,shoulder)\n    GET(BACK,back)\n    GET(BUTT,butt)\n    GET(TAIL,tail)\n    GET(BACK_LEG_RIGHT,back_leg_right)\n    GET(BACK_LEG_LEFT,back_leg_left)\n    GET(FRONT_LEG_RIGHT,front_leg_right)\n    GET(FRONT_LEG_LEFT,front_leg_left)\n    GET(BACK_FOOT_RIGHT,back_foot_right)\n    GET(BACK_FOOT_LEFT,back_foot_left)\n    GET(FRONT_FOOT_RIGHT,front_foot_right)\n    GET(FRONT_FOOT_LEFT,front_foot_left)\n  \n/*\n\n                 _\n            ____/\n           /|\\ |\\\n            | || |\n\n\n*/\nfloat N = 25.;\ndT /= N;\nfor (float _i = 0.; _i < N; _i++) {\n    T += dT;\n    if (I<1) back.z = 0.1,   back.dz = 0.4;\n    butt.z = back.z+0.;     butt.dz = back.dz+0.;\n    tail.z = back.z+.2*pi; tail.dz = butt.dz;\n    shoulder.z = back.z+0.; shoulder.dz = back.dz;\n    neck.z = shoulder.z + .3*pi+.2*cos(8.*T); neck.dz = shoulder.dz+.2*8.*dT*sin(T);\n    head.z = -0.2;      head.dz = neck.dz+0.;\n    \n    float w = -1.5*(HEIGHT(butt.xy.x) - HEIGHT(shoulder.xy.x))/R.y;\n    \n    PLACE(butt,back_leg_right,back_foot_right,.5*an(-4.*T)*1.+vec2(0,1.5+w))\n    PLACE(butt,back_leg_left,back_foot_left,.5*an(-4.*T+pi)*1.+vec2(0,1.5+w))\n     \n    PLACE(shoulder,front_leg_right,front_foot_right,.5*an(-4.*T)*1.+vec2(0,-1.5+w))\n    PLACE(shoulder,front_leg_left,front_foot_left,.5*an(-4.*T+pi)*1.+vec2(0,-1.5+w))\n    \n/*\n\n                 _\n            ____/\n           /|\\ |\\\n            | || |\n\n\n*/\n    if (I<1) back.xy = (0.5,.7)*R, back.dz = -0.02, back.dxy = vec2(8,1);\n    BEHIND(butt,back)\n    BEHIND(tail,butt)\n    \n    BEHIND(back_leg_right,butt)\n    BEHIND(back_foot_right,back_leg_right)\n    \n    BEHIND(back_leg_left,butt)\n    BEHIND(back_foot_left,back_leg_left)\n    \n    INFRONT(back,shoulder)\n    \n    INFRONT(shoulder,front_leg_right)\n    INFRONT(front_leg_right,front_foot_right)\n    \n    INFRONT(shoulder,front_leg_left)\n    INFRONT(front_leg_left,front_foot_left)\n    \n    INFRONT(shoulder,neck)\n    INFRONT(neck,head)\n //\n     vec2 force = vec2(0,gravity);\n     float torq = float(0);\n     FORCE(head)\n     FORCE(neck)\n     FORCE(shoulder)\n     FORCE(back)\n     FORCE(butt)\n     FORCE(tail)\n     FORCE(back_leg_right)\n     FORCE(back_foot_right)\n     FORCE(back_leg_left)\n     FORCE(back_foot_left)\n     FORCE(front_leg_right)\n     FORCE(front_foot_right)\n     FORCE(front_leg_left)\n     FORCE(front_foot_left)\n     \n     back.dxy += dt*force;\n     back.dz +=  dt*torq;\n     back.xy +=  dt*(.5*force+back.dxy);\n     back.z +=   dt*(.5*torq+back.dz);\n}\n //\n     if (M.z>0.) back.dxy += .2*(M.xy-.5*R)/R.y;\n\n //\n    SET(HEAD,head)\n    SET(NECK,neck)\n    SET(SHOULDER,shoulder)\n    SET(BACK,back)\n    SET(BUTT,butt)\n    SET(TAIL,tail)\n    SET(BACK_LEG_RIGHT,back_leg_right)\n    SET(BACK_LEG_LEFT,back_leg_left)\n    SET(FRONT_LEG_RIGHT,front_leg_right)\n    SET(FRONT_LEG_LEFT,front_leg_left)\n    SET(BACK_FOOT_RIGHT,back_foot_right)\n    SET(BACK_FOOT_LEFT,back_foot_left)\n    SET(FRONT_FOOT_RIGHT,front_foot_right)\n    SET(FRONT_FOOT_LEFT,front_foot_left)\n \n \n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssfcR2", "name": "kifings tubes with a twist", "author": "leon", "description": "space, volume, repeat", "tags": ["yes"], "likes": 18, "viewed": 386, "published": 3, "date": "1642366819", "time_retrieved": "2024-07-30T17:09:23.735148", "image_code": "// are we arrived yet?\n// kifings tubes with a twist\n// leon denise 2022 01 16\n\n// smooth union by Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n    \n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// repetition domain\n#define repeat(p,r) (mod(p+r/2.,r)-r/2.)\n\n// geometry\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float dist = 100.;\n    p.z += iTime * .1; // translate\n    float cell = .7; // size of repetition\n    float pz = floor(p.z/cell); // index of cell in line\n    p.z = repeat(p.z, cell); // repeat space z\n    p.z *= mix(-1., 1., step(0.5, mod(p.z, 2.))); // mirror z per cell in line\n    float d = length(p); // distance from origin\n    float t = iTime * .1; // time rotation\n    const float count = 6.; // number of shapes\n    float a = 1.; // amplitude of falloff\n    for (float i = 0.; i < count; ++i) { // kifing\n        p.yz *= rot(t); // twist\n        p.yx *= rot(t); // twist\n        p = abs(p)-(.05+d*.2)*a; // fold space\n        dist = smin(dist, length(p.xz)-(.01+d*.1)*a, (.01+d*.8)*a); // smoothly add tube\n        a /= 2.; // falloff curve\n    }\n    return abs(dist)-.0001; // shell volume\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    // coodinates\n    vec2 pixel = (coordinate - iResolution.xy / 2.) / iResolution.y;\n    vec3 eye = vec3(0,0,-1.);\n    vec3 ray = normalize(vec3(pixel, 1.5));\n    vec3 pos = eye + ray * .5; // start ahead, carve volume\n    \n    // raymarch\n    const float count = 30.;\n    float i = 0.;\n    for (i = count; i > 0.; --i) {\n        float dist = map(pos);\n        if (dist < .0001) break;\n        pos += ray * dist;\n    }\n    \n    // coloring\n    float shade = i/count;\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = .9 + .1 * cos(vec3(.0, .3, .6) * 6.283 + shade * 6. + pos.z * 18. + 2.);\n    color = vec4(tint * shade,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 161, 204, 204, 303], [309, 328, 347, 347, 392], [457, 469, 488, 488, 1311], [1313, 1313, 1367, 1385, 2040]], "test": "untested"}
{"id": "4sj3WD", "name": "Gemstone Collection", "author": "HLorenzi", "description": "Revisiting a very old shader that I never got around to finishing! Tweaking my 8-year-old messy code for the final touches today was a mouthful...", "tags": ["gem", "stone", "collection", "gems", "raymarchtone"], "likes": 1, "viewed": 349, "published": 3, "date": "1642366088", "time_retrieved": "2024-07-30T17:09:24.827229", "image_code": "#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 50\n#define SHADOW_STEP 1.0\n#define SHADOW_SMOOTHNESS 4.0\n#define SHADOW_DARKNESS 0.75\n\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat hashp(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n\n// Distance functions from iquilezles.org\n\nfloat fSubtraction(float a, float b) {return max(-a,b);}\nfloat fIntersection(float d1, float d2) {return max(d1,d2);}\nfloat fUnion(float d1, float d2) {return min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\nfloat pPlane(vec3 p, vec4 n) {return dot(p,n.xyz) + n.w;}\n\nfloat pMineral(vec3 p, vec2 h, float r) {\n\tvec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5) - r;\n}\n\n\nmat3 rotmat(vec3 u, float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tfloat ic = 1.0 - c;\n\t\n\tfloat x = u.x;\n\tfloat y = u.y;\n\tfloat z = u.z;\n\t\n\treturn mat3(x*x*ic+c, x*y*ic-z*s, x*z*ic+y*s,\n\t\t\t\ty*x*ic+z*s, y*y*ic+c, y*z*ic-x*s,\n\t\t\t\tz*x*ic-y*s, z*y*ic+x*s, z*z*ic+c);\n}\n\n#define CYCLE_TIME 3.0\n#define TRANSITION_TIME 0.25\n\nfloat distf(vec3 p)\n{\n\tfloat dFinal = 50.0;\n    \n    float indexHash = hashp(floor((iTime + 126.0) / CYCLE_TIME));\n    \n    float t = mod(iTime, CYCLE_TIME) / CYCLE_TIME;\n    \n    if (t < TRANSITION_TIME)\n    {\n        float t2 = (1.0 - (t / TRANSITION_TIME));\n        p.y += t2 * t2 * t2 * 20.0;\n    }\n    \n    if (t > 1.0 - TRANSITION_TIME)\n    {\n        float t2 = ((t - (1.0 - TRANSITION_TIME)) / TRANSITION_TIME);\n        p.y -= t2 * t2 * t2 * 20.0;\n    }\n\n    for(float j = 0.0; j < 2.0; j += 1.0)\n    {\n        float d = 0.0;\n        for(float i = 0.0; i < 3.0; i += 1.0)\n        {\n            float iterHash = 7.6 * j + 3.7 * i;\n            d = fIntersection(d, pMineral(\n                vec3(\n                    3.0 * (hashp(iterHash + 1.4 + indexHash) - 0.5),\n                    3.0 * (hashp(iterHash + 7.3 + indexHash) - 0.5),\n                    3.0 * (hashp(iterHash + 8.9 + indexHash) - 0.5))\n                 * hashp(iterHash + 3.3 + indexHash) * 1.0 +\n                    rotmat(normalize(vec3(hash(iterHash+0.1+indexHash),hash(iterHash+0.2+indexHash),hash(iterHash+0.3+indexHash))),\n                           hashp(iterHash+0.4+indexHash)*3.14159*2.) * p,\n                vec2(5.0,hashp(iterHash + 4.6 + indexHash) * 5.0),\n                hashp(iterHash + 8.5 + indexHash) * 0.25));\n        }\n        dFinal = fUnion(dFinal, d);\n    }\n\treturn dFinal;\n}\n\nvec3 normal(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z)) - distf(vec3(p.x+eps,p.y,p.z))),\n                   (distf(vec3(p.x,p.y-eps,p.z)) - distf(vec3(p.x,p.y+eps,p.z))),\n                   (distf(vec3(p.x,p.y,p.z-eps)) - distf(vec3(p.x,p.y,p.z+eps)))\n\t\t\t\t );\n    return normalize(n);\n}\n\nstruct raymarch_data {\n\tbool hit;\n\tvec3 hitPos;\n\tvec3 backPos;\n\tvec3 backDir;\n};\n\nvec3 raymarch_thru(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 10.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t\tdist -= distEval;\n\t}\n\t\n\treturn from + increment * dist;\n}\n\nraymarch_data raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t}\n\t\n\tfloat mat = 1.0;\n\tif (dist >= maxDist) mat = 0.0;\n\t\n\tvec3 p = from + increment * dist;\n\tvec3 n = -normal(p);\n\tvec3 pdir = refract(increment, n, 1.0 / 2.0);\n\t\n\treturn raymarch_data(\n\t\t\t\tmat == 1.0,\n\t\t\t\tp,\n\t\t\t\traymarch_thru(p, pdir),\n\t\t\t\tpdir\n\t\t\t);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n        float h = distf(from + increment * t);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, SHADOW_SMOOTHNESS * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nvec4 HSVtoRGB(vec3 hsv)\n{\n\tfloat i = floor(mod(floor(hsv.x / 60.0),6.0));\n\tfloat f = mod(hsv.x / 60.0, 6.0) - i;\n\tfloat p = hsv.z * (1.0 - hsv.y);\n\tfloat q = hsv.z * (1.0 - f * hsv.y);\n\tfloat t = hsv.z * (1.0 - (1.0 - f) * hsv.y);\n\t\n\tif (i == 0.) return vec4(hsv.z,t,p,1);\n\tif (i == 1.) return vec4(q,hsv.z,p,1);\n\tif (i == 2.) return vec4(p,hsv.z,t,1);\n\tif (i == 3.) return vec4(p,q,hsv.z,1);\n\tif (i == 4.) return vec4(t,p,hsv.z,1);\n\treturn vec4(hsv.z,p,q,1);\n}\n\n\nfloat time;\nvec4 getPixel(vec2 p, vec3 from, vec3 increment)\n{\n\tvec3 light = normalize(vec3(0,0,1));\n\t\n\traymarch_data c = raymarch(from, increment);\n\tvec3 n1 = normal(c.hitPos);\n\tfloat diff1 = clamp(dot(n1, -light), 0.0, 1.0) * 0.5 + 0.5;\n\tfloat spec1 = pow(max(0.0, dot(reflect(-light, n1), normalize(from - c.hitPos))), 5.0);\n\t\n\tvec3 n2 = -normal(c.backPos);\n\tfloat diff2 = clamp(dot(n2, -light), 0.0, 1.0) * 0.5 + 0.5;\n\tfloat spec2 = pow(max(0.0, dot(reflect(-light, n2), normalize(from - c.backPos))), 5.0);\n\t\n\tif (!c.hit) return texture(iChannel0, normalize(c.hitPos.xzy));\n    \n    float indexHash = hashp(floor((iTime + 195.0) / CYCLE_TIME));\n    vec4 mainColor = vec4(\n        hashp(indexHash * 3.5),\n        hashp(indexHash * 2.7),\n        hashp(indexHash * 1.9),\n        1.0);\n    \n\tvec4 color = mix(\n\t\t\n\t\t\t\tmix(\n\t\t\t\t\tmix(mainColor * diff1,\n\t\t\t\t\t\ttexture(iChannel0, normalize(reflect(increment,n1).xzy)),\n\t\t\t\t\t\t0.1),\n\t\t\t\t\tmix(\n\t\t\t\t\t\tmix(mainColor * 1.2 * diff2,\n\t\t\t\t\t\t\ttexture(iChannel0, normalize(c.backDir.xzy)),\n\t\t\t\t\t\t\t0.1),\t\t\t\t\t\t\t\n\t\t\t\t\t\tvec4(1,1,1,1), spec2),\n\t\t\t\t\t0.3\n\t\t\t\t),\n\t\t\t\t\n\t\t\t\tvec4(1,1,1,1), spec1);\n\t\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\ttime = iTime;\n\t\n\t// pixel position\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x/iResolution.y;\n\t\n\t// mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\t//if (iMouse.z == 0.0 && iMouse.w == 0.0)\n    {\n\t\tm = vec2(time * 0.06 + 1.67, 0.5 + 0.3 * sin(time * 0.5));\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-0.9);\n\n\t// camera position\n\tfloat dist = 15.0;\n\tvec3 ta = vec3(0,0,0);\n\tvec3 ro = vec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\t\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t// calculate color\n\tvec4 col = getPixel(p, ro, rd);\n    col = pow(col, vec4(1.0 / 2.2));\n    col = col*1.5-0.4;\n\tfragColor = col;\n\t\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sj3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 166, 166, 219], [221, 221, 243, 243, 284], [330, 330, 368, 368, 386], [387, 387, 428, 428, 447], [448, 448, 482, 482, 501], [502, 502, 534, 534, 554], [555, 555, 597, 597, 633], [634, 634, 664, 664, 723], [724, 724, 755, 755, 814], [815, 815, 864, 864, 978], [979, 979, 1009, 1009, 1036], [1038, 1038, 1079, 1079, 1167], [1170, 1170, 1200, 1200, 1437], [1492, 1492, 1513, 1513, 2864], [2866, 2866, 2887, 2887, 3202], [3286, 3286, 3333, 3333, 3675], [3677, 3677, 3728, 3728, 4283], [4285, 4285, 4326, 4326, 4629], [4631, 4631, 4656, 4656, 5092], [5107, 5107, 5157, 5157, 6235], [6238, 6238, 6295, 6295, 7183]], "test": "untested"}
{"id": "7sXcR2", "name": "Super Collider #5 [MultiChan]", "author": "Yusef28", "description": "I first learned of the super collider tutorials from athibaul in the comments of his featured sahder \"Techno Song (sound)\"\nhttps://www.shadertoy.com/view/sls3WM\nThe link to those tutorials is in those comments, and in the sound tab of this shader.", "tags": ["pulse", "wave", "super", "collider", "supercollider"], "likes": 7, "viewed": 357, "published": 3, "date": "1642363890", "time_retrieved": "2024-07-30T17:09:25.622103", "image_code": "\n#define LETTER_SIZE 1./16.\n#define STEP_SIZE 1./8.\n#define FIRST_LETTER 64.\n#define FIRST_NUMBER 48.\n\nvec2 numToCoord(float a){\n    return vec2( mod(a,16.), 15.-floor(a/16.) );\n}\n\nvec3 C(vec2 uv, vec2 start, inout float moveX,float num){\n    moveX += STEP_SIZE/2.3;\n    if(uv.x < start.x           || \n       uv.x > start.x+STEP_SIZE || \n       uv.y < start.y           || \n       uv.y > start.y+STEP_SIZE){\n       return vec3(0.);\n    }\n    \n    uv -= start; uv /= STEP_SIZE; uv *= LETTER_SIZE;\n    uv += vec2(LETTER_SIZE*numToCoord(num));\n    return textureGrad(iChannel0,uv,dFdx(uv),dFdy(uv)).rrr;\n}\n\nvoid addC(vec2 st, float char, inout float moveX, inout vec3 col){\n    col = mix(col,vec3(1.),\n             C(st,vec2(moveX,0.45),moveX,FIRST_LETTER+char));\n    \n}\n\n\n/*\nThe sound Tab again for printing\n*/\n// Super Collider Tutorials\n// https://www.youtube.com/playlist?list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC\n\n/*\nThis isn't exactly what we get at the end of tutorial #3 because\nfor example reverb is something I don't know how to do yet. I \nmostly hack these functions together based on how the creator\nof the videos describes them (plus whatever I can find online \nquickly.)\n*/\n/*\n#define PI acos(-1.)\n\nfloat rnd(float a){return fract(sin(a*208.41)*4962.924);}\n\nfloat ExpRand(float a, float low, float high){\n    float seed = pow(rnd(a),2.);\n    float range = high-low;\n    return seed*range + low;\n}\n\n//random volume for each ear between 0 and 1\nvec2 Splay(float a){\n    return vec2(ExpRand(a,0.,1.),ExpRand(a+124.312,0.,1.) );\n}\n\n//volume of both eara always sums to 1\nvec2 Splay_2(float a){\n    float left = ExpRand(a+1.2,0.,1.);\n    return vec2(left,1.-left);\n}\n\nfloat LFNoise(float t, float freq, float low, float high){\n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    \n    float seed = mix(rnd(id),rnd(id+1.),smoothstep(0.2,0.5,fID));\n    float range = abs(high-low);\n    return floor(seed*range) + low;\n}\n\nfloat interpolateSins(float t, float freq, float i,\n                          float lowFreq, float highFreq){\n                          \n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    return  mix(sin(t*2.*PI*ExpRand(i+id,lowFreq,highFreq))*0.5+0.5,\n                sin(t*2.*PI*ExpRand(i+1.+id,lowFreq,highFreq))*0.5+0.5,\n                smoothstep(0.,0.95,fID));\n}\n\nfloat interpolatePartials(float t, float freq, float i,\n                          float lowFreq, float highFreq){\n                          \n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    return  mix(ExpRand(i+id,lowFreq,highFreq),\n                ExpRand(i+1.+id,lowFreq,highFreq),\n                smoothstep(0.6,0.0,fID));\n}\n\nvec2 dupSin(float t, float num, float lowAmp, float highAmp, \n             float lowFreq, float highFreq, inout vec3 col, vec2 uv){\n\n    vec2 sig = vec2(0.);\n    vec2 stereo = vec2(0.);\n    float amp = 0., ampNext = 0.;\n    float partial = 0.;\n    float partialFreq = 0.;\n    float noise = LFNoise(t,.2,20.,800.);\n    \n    for(float i = 0.; i < num; i++){\n        amp = sin(t*2.*PI*ExpRand(i+1.,lowAmp,highAmp))*0.5+0.5;\n        partialFreq = interpolatePartials(t, 0.2, i, lowFreq, highFreq);\n        partial = interpolateSins(t, 0.2, i, lowFreq, highFreq);\n        //interpolateSinssin(sin(t)*2.*PI*partialFreq)*0.5+0.5;\n        //interpolatePartials(t, 0.2, i, lowFreq, highFreq);\n        //sin(t*2.*PI*ExpRand(i+1.,lowFreq,highFreq))*0.5+0.5;\n        stereo = Splay(i+1.2);\n        sig += partial*amp*stereo;\n        col -= sig.x*smoothstep(0.01,0.0,abs(i - floor(uv.x*num)))/10.;\n    }\n    \n    return sig/7.;\n}\n\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = 0.5 + 0.5*cos(uv.xyy+vec3(0,2,4));\n  //  vec2 sig = dupSin(iTime,10.,0.2,22.,200.,1000., col, uv);\n    // Time varying pixel color\n    \n    vec2 st = uv;\n    float moveX = 0.23;\n    \n    addC(st,_s,moveX,col);  \n    addC(st,_o,moveX,col);\n    addC(st,_u,moveX,col);  \n    addC(st,_n,moveX,col);\n    addC(st,_d,moveX,col);\n    addC(st,_z+32.+5.,moveX,col);\n    addC(st,_i,moveX,col);\n    addC(st,_n,moveX,col);\n   // Output to screen\n   //col = texture(iChannel0,uv).rgb;\n   \n   \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Super Collider Tutorials\n// https://www.youtube.com/playlist?list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC\n\n/*\nThis isn't exactly what we get at the end of tutorial #5 \nWith no access to \"dup\" or \"!\" or the number of mix channels\nhis sound card seems to have, this is what I was able to come up with.\n\nI wanted to have the frequencies change over time with a mix\nfunction but that get's weird for somereason so I'm just mixing\nthe volumes of current and next for each signal in the set.\n*/\n\n#define PI acos(-1.)\n\nfloat rnd(float a){return fract(sin(a*208.41)*4962.924);}\n\nfloat ExpRand(float a, float low, float high){\n    float seed = pow(rnd(a),2.);\n    float range = high-low;\n    return seed*range + low;\n}\n\n//random volume for each ear between 0 and 1\nvec2 Splay(float a){\n    return vec2(ExpRand(a,0.,1.),ExpRand(a+124.312,0.,1.) );\n}\n\n//volume of both eara always sums to 1\nvec2 Splay_2(float a){\n    float left = ExpRand(a+1.2,0.,1.);\n    return vec2(left,1.-left);\n}\n\nfloat LFNoise(float t, float freq, float low, float high){\n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    \n    float seed = mix(rnd(id),rnd(id+1.),smoothstep(0.2,0.5,fID));\n    float range = abs(high-low);\n    return floor(seed*range) + low;\n}\n\nfloat interpolateSins(float t, float freq, float i,\n                          float lowFreq, float highFreq){\n                          \n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    return  mix(sin(t*2.*PI*ExpRand(i+id,lowFreq,highFreq))*0.5+0.5,\n                sin(t*2.*PI*ExpRand(i+1.+id,lowFreq,highFreq))*0.5+0.5,\n                smoothstep(0.,0.95,fID));\n}\n\nfloat interpolatePartials(float t, float freq, float i,\n                          float lowFreq, float highFreq){\n                          \n    float id = floor(t*freq);\n    float fID = fract(t*freq);\n    return  mix(ExpRand(i+id,lowFreq,highFreq),\n                ExpRand(i+1.+id,lowFreq,highFreq),\n                smoothstep(0.6,0.0,fID));\n}\n\nvec2 dupSin(float t, float num, float lowAmp, float highAmp, \n             float lowFreq, float highFreq){\n\n    vec2 sig = vec2(0.);\n    vec2 stereo = vec2(0.);\n    float amp = 0., ampNext = 0.;\n    float partial = 0.;\n    float partialFreq = 0.;\n    float noise = LFNoise(t,.2,20.,800.);\n    \n    for(float i = 0.; i < num; i++){\n        amp = sin(t*2.*PI*ExpRand(i+1.,lowAmp,highAmp))*0.5+0.5;\n        partialFreq = interpolatePartials(t, 0.2, i, lowFreq, highFreq);\n        partial = interpolateSins(t, 0.2, i, lowFreq, highFreq);\n        //interpolateSinssin(sin(t)*2.*PI*partialFreq)*0.5+0.5;\n        //interpolatePartials(t, 0.2, i, lowFreq, highFreq);\n        //sin(t*2.*PI*ExpRand(i+1.,lowFreq,highFreq))*0.5+0.5;\n        stereo = Splay(i+1.2);\n        sig += partial*amp*stereo;\n    }\n    \n    return sig/5.;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    return dupSin(time,10.,0.2,22.,200.,1000.);\n}", "sound_inputs": [], "common_code": "#define _a 1.\n#define _b 2.\n#define _c 3.\n#define _d 4.\n#define _e 5.\n#define _f 6.\n#define _g 7.\n#define _h 8.\n#define _i 9.\n#define _j 10.\n#define _k 11.\n#define _l 12.\n\n#define _m 13.\n#define _n 14.\n#define _o 15.\n#define _p 16.\n#define _q 17.\n#define _r 18.\n#define _s 19.\n#define _t 20.\n#define _u 21.\n#define _v 22.\n#define _w 23.\n#define _x 24.\n#define _y 25.\n#define _z 26.", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 128, 128, 179], [181, 181, 238, 238, 603], [605, 605, 671, 671, 768], [915, 3588, 3645, 3695, 4271]], "test": "untested"}
{"id": "NtySzV", "name": "truchet madness", "author": "ml", "description": "more shader practice. playing with 10print", "tags": ["truchet", "10print"], "likes": 5, "viewed": 282, "published": 3, "date": "1642340164", "time_retrieved": "2024-07-30T17:09:26.457869", "image_code": "#define CELL_SIZE 0.075\n#define THICKNESS 0.1\n#define BLUR 0.01\n\n#define TAU 6.28318530718\n\n\n//const vec3 palette[2] = vec3[2](vec3(0.965, 0.925, 0.255), vec3(0.305, 0.245, 0.525));\n//const vec3 palette[2] = vec3[2](vec3(0.1), vec3(0.98));\nconst vec3 palette[2] = vec3[2](vec3(0.986), vec3(0.665, 0.135, 0.215));\n \n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat dist(vec2 p1,vec2 p2){\n    return sqrt(pow(p1.x-p2.x, 2.) + pow(p1.y-p2.y, 2.));\n}\n\nfloat timeOffset(vec2 cell){\n    vec2 centre = vec2(iResolution.x/iResolution.y*0.5, 0.5);\n    \n    \n    float o;\n    o = sin(dist((cell+vec2(0.5, 0.5))*CELL_SIZE, centre)*TAU/5.)*1.;\n    //o = sin(cell.x*CELL_SIZE*TAU/10.)+cos(cell.y*CELL_SIZE*TAU/10.);\n    return -o;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec2 cell = vec2(floor(uv.x/CELL_SIZE), floor(uv.y/CELL_SIZE));\n    \n    vec2 cellUv = vec2(mod(uv.x, CELL_SIZE), mod(uv.y, CELL_SIZE))/CELL_SIZE;\n    \n    float t = iTime + timeOffset(cell);\n\n    \n    bool dir = hash12(cell) < 0.5;\n    \n    float d = dir ? abs(cellUv.x - cellUv.y) :  abs(1.-cellUv.x - cellUv.y);\n    \n    d = 1. - d;\n    \n    float a = sin(t*TAU/4.)*0.5+0.5;\n    \n    d = d*(1.-a)+dist(cellUv, vec2(0.5, 0.5))*a;\n    \n    float m = 2.+sin(t*TAU/10.);\n        \n    d = sin(d*TAU*m)*0.5+0.5;\n    \n    float thickness = 0.5;//sin(t*TAU/3.)*0.4+0.4;\n    \n    float v = smoothstep(thickness+BLUR, thickness-BLUR, d);\n\n    \n    // Time varying pixel color\n    vec3 col = palette[int(v)];\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtySzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 338, 338, 455], [457, 457, 485, 485, 545], [547, 547, 575, 575, 821], [823, 823, 880, 930, 1784]], "test": "untested"}
{"id": "slVSzt", "name": "genuary stars", "author": "ml", "description": "https://genuary.art/prompts#jan3", "tags": ["genuary", "genuary2022"], "likes": 4, "viewed": 323, "published": 3, "date": "1642340043", "time_retrieved": "2024-07-30T17:09:27.280669", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 correctedUv = vec2(uv.x*iResolution.x/iResolution.y, uv.y);\n    \n\n    vec4 stars = texture(iChannel1, uv);\n    \n    float cloudLightness = texture(iChannel0, uv).r*pow(texture(iChannel0, uv).g, 2.)*0.76+0.03;\n\n    float r = texture(iChannel0, uv+vec2(0.5, 0.5)).r*0.9+0.23;\n    float g = texture(iChannel0, uv).a*0.9-0.05;\n    float b = texture(iChannel0, uv).b*0.95+0.42;\n\n    vec3 clouds = cloudLightness*vec3(r, g, b);\n    \n    // Output to screen\n    fragColor = stars+vec4(clouds, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// noise\nfloat noise(vec2 pos)\n{\n    pos.x += 100.*seed;\n\treturn fract( sin( dot(pos*0.001 ,vec2(24.12357, 36.789) ) ) * 12345.123);\t\n}\n\n\n// blur noise\nfloat smooth_noise(vec2 pos)\n{\n\treturn   ( noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) ) / 16.0 \t\t\n\t\t   + ( noise(pos + vec2(1,0)) + noise(pos + vec2(-1,0)) + noise(pos + vec2(0,1)) + noise(pos + vec2(0,-1)) ) / 8.0 \t\t\n    \t   + noise(pos) / 4.0;\n}\n\n\n// linear interpolation\nfloat interpolate_noise(vec2 pos)\n{\n\tfloat\ta, b, c, d;\n\t\n\ta = smooth_noise(floor(pos));\t\n\tb = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y)));\n\tc = smooth_noise(vec2(floor(pos.x), floor(pos.y+1.0)));\n\td = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y+1.0)));\n\t\t\n\ta = mix(a, b, fract(pos.x));\n\tb = mix(c, d, fract(pos.x));\n\ta = mix(a, b, fract(pos.y));\n\t\n\treturn a;\t\t\t\t   \t\n}\n\n\n\nfloat perlin_noise(vec2 pos)\n{\n\tfloat\tn;\n\t\n\tn = interpolate_noise(pos*0.0625)*0.5;\n\tn += interpolate_noise(pos*0.125)*0.25;\n\tn += interpolate_noise(pos*0.025)*0.225;\n\tn += interpolate_noise(pos*0.05)*0.0625;\n\tn += interpolate_noise(pos)*0.03125;\n\treturn n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 correctedUv = vec2(uv.x*iResolution.x/iResolution.y, uv.y);\n    \n    const float scale = 100.;\n    \n    if(iFrame == 0){\n        fragColor = vec4(\n        perlin_noise(correctedUv*scale), \n        perlin_noise((correctedUv+vec2(3., 0.))*scale),\n        perlin_noise((correctedUv+vec2(6., 0.))*scale),\n        perlin_noise((correctedUv+vec2(9., 0.))*scale));\n    }else{\n        fragColor = texture(iChannel0, uv);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define seed 123.\n#define TAU 6.28318530718\n\n\nfloat hash11(float p)\n{\n    p += seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n    p.x += seed;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n    p += seed;\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n    p.x += seed;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash13(vec3 p3)\n{\n    p3.x += seed;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat dist(vec2 p1,vec2 p2){\n    return sqrt(pow(p1.x-p2.x, 2.) + pow(p1.y-p2.y, 2.));\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = texture(iChannel1, uv);\n\n    vec2 correctedUv = vec2(uv.x*iResolution.x/iResolution.y, uv.y);\n    \n    float closestDist = 1000000.;\n    \n    \n    for(float i = 0.; i < 100.; i++){\n        vec2 pos = hash22(vec2(i, iFrame));\n        pos.x *= iResolution.x/iResolution.y;\n        \n        float d = dist(pos, correctedUv);\n        if(d < closestDist){\n            closestDist = d;\n        }\n        \n        float r = hash12(vec2(i, iFrame));\n        float r2 = hash12(vec2(i+0.5, iFrame));\n        \n        float starBrightness = pow(r, 100.)*r2*texture(iChannel0, correctedUv).r*r2;\n        \n        \n        float starPixelBrightess = pow(d, -2.)*starBrightness*5e-5;\n        \n\n        \n        if(starPixelBrightess < 0.003) starPixelBrightess = 0.;\n        \n        \n        vec3 starRgb = vec3(1.);\n        float alpha = pow(hash13(vec3(i, iFrame, 4.)), 0.8);\n        \n        r = hash13(vec3(i, iFrame, 0.));\n\n        if(r < 0.04){\n            starRgb = vec3(\n                0.9+hash13(vec3(i, iFrame, 1.))*0.1,\n                0.23+hash13(vec3(i, iFrame, 2.))*0.8,\n                0.23+hash13(vec3(i, iFrame, 3.))*0.04\n            );\n            alpha = pow(alpha, 2.5);\n        }else if(r < 0.07){\n             starRgb = vec3(\n                0.31+hash13(vec3(i, iFrame, 1.))*0.41,\n                0.31+hash13(vec3(i, iFrame, 2.))*0.41,\n                0.9+hash13(vec3(i, iFrame, 3.))*0.1\n             );\n             alpha = pow(alpha, 1.2);\n        }\n        \n        alpha = alpha*0.8+0.2*texture(iChannel0, correctedUv).r;\n        \n        vec4 starColor = vec4(starRgb, alpha);\n        \n        col += starColor*starPixelBrightess*texture(iChannel0, correctedUv).r;\n    }\n\n\n    // Output to screen\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 650]], "test": "untested"}
{"id": "7dsczS", "name": "Tonemapping primaries sweep", "author": "bjornornorn", "description": "Experiment with hue preserving tonemapping/output transforms. \n\nScaling chroma based on the derivative of the tone curve. This behave similarly to per channel tone mapping for low saturation colors, but preserves hue for saturated colors.", "tags": ["tonemapping", "tonemap", "oklab"], "likes": 4, "viewed": 971, "published": 3, "date": "1642323807", "time_retrieved": "2024-07-30T17:09:28.091501", "image_code": "// Copyright(c) 2022 Bjrn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst float softness_scale = 0.2; // controls softness of RGB clipping\nconst float offset = 0.75; // controls how colors desaturate as they brighten. 0 results in that colors never fluoresce, 1 in very saturated colors \nconst float chroma_scale = 1.2; // overall scale of chroma\n\nconst mat3 rec2020toSrgb = mat3(\n    1.6603034854, -0.5875701425, -0.0728900602,\n    -0.1243755953,  1.1328344814, -0.0083597372,\n    -0.0181122800, -0.1005836085,  1.1187703262);\n\nconst mat3 displayP3toSrgb = mat3(\n    1.2248021163, -0.2249112615, -0.0000475721,\n    -0.0419281049,  1.0420298967, -0.0000026429,\n    -0.0196088092, -0.0786321233,  1.0983153702);\n\nconst mat3 SrgbToSrgb = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    \nconst mat3 sourceColorSpaceToSrgb = SrgbToSrgb; // change for different input color space\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = max(x, 0.0);\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    \n    x = max(x, 0.0);\n    vec3 r = (x*(c*x + d) + e);\n    return (a*x*(d*x + 2.0*e) + b*(e - c*x*x))/(r*r);\n}\n\nvec3 tonemap_per_channel(vec3 c)\n{\n    return s_curve(c);\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c_smooth,x-c_smooth)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n\n    return sqrt(a*a + b*b);\n}\n\nvec2 calculateMC(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float M = findCenterAndPurity(lms).x; \n    \n    return vec2(M, calculateC(lms));\n}\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec2 MC = calculateMC(rgb);\n    vec2 STnew = vec2((MC.x)/MC.y, (1.0-MC.x)/MC.y);\n    STnew = (STnew + 3.0*STnew*STnew*MC.y);\n    \n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec2 MC = calculateMC(rgb);\n    float Cnew = (1.0/((ST.x/(MC.x)) + (ST.y/(1.0-MC.x))));\n\n    return max(MC.y/Cnew, scale);\n}\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\nvec3 tonemap_hue_preserving(vec3 c)\n{\n    mat3 toLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n        \n    mat3 fromLms = mat3(\n        +4.0767416621f , -3.3077115913, +0.2309699292,\n        -1.2684380046f , +2.6097574011, -0.3413193965,\n        -0.0041960863f , -0.7034186147, +1.7076147010);\n        \n    vec3 lms_ = c*toLms;\n    vec3 lms = sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n    \n    vec2 MP = findCenterAndPurity(lms);\n    \n    // apply tone curve\n    \n    // Approach 1: scale chroma based on derivative of chrome curve\n    if (true)\n    { \n        float I = (MP.x+(1.0-offset)*MP.y);\n        // Remove comment to see what the results are with Oklab L\n        //I = dot(lms, vec3(0.2104542553f, 0.7936177850f, - 0.0040720468f));\n        \n        lms = lms*I*I;\n        I = I*I*I;\n        vec3 dLms = lms - I;\n\n        float Icurve = s_curve(vec3(I)).x;\n        lms = 1.0f + chroma_scale*dLms*d_s_curve(vec3(I))/Icurve;     \n        I = pow(Icurve, 1.0/3.0);\n\n        lms = lms*I;\n    }\n    \n    // Approach 2: Separate color into a whiteness/blackness part, apply scale to them independendtly\n    if (false)\n    {\n        lms = chroma_scale*(lms - MP.x) + MP.x;\n    \n        float invBlackness = (MP.x+MP.y);\n        float whiteness = (MP.x-MP.y);\n        \n        float invBlacknessC = pow(s_curve(vec3(invBlackness*invBlackness*invBlackness)).x, 1.0/3.0);\n        float whitenessC = pow(s_curve(vec3(whiteness*whiteness*whiteness)).x, 1.0/3.0);\n        \n        lms = (invBlacknessC+whitenessC)/2.0 + (lms-(invBlackness+whiteness)/2.0)*(invBlacknessC-whitenessC)/(invBlackness-whiteness);\n    }\n    \n    \n    // compress to a smooth approximation of the target gamut\n    { \n        float M = findCenterAndPurity(lms).x;\n        vec2 ST = approximateShape(); // this can be precomputed, only depends on RGB gamut\n        float C_smooth_gamut = (1.0)/((ST.x/(M)) + (ST.y/(1.0-M)));\n        float C = calculateC(lms);\n\n        lms = (lms-M)/sqrt(C*C/C_smooth_gamut/C_smooth_gamut+1.0) + M;\n    }\n    \n    vec3 rgb = lms*lms*lms*fromLms;\n\n    return rgb;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    // not quite sure this mapping is easy to invert, but should be possible to construct similar ones that do\n    \n    float grey = 0.2;\n        \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n    \n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = floor(1.0+18.0*fragCoord.y/iResolution.y)/18.0 * 3.141592 * 2.;\n    float L = floor(fragCoord.x*24.0/iResolution.y)/(24.0/iResolution.y)/iResolution.x - 0.4;\n    \n    \n    vec3 color = cos(h + vec3(0.0,1.0,2.0)* 3.141592*2.0/3.0);\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n    \n    color = exp(10.0*L)*(color-minRGB)/(maxRGB-minRGB);\n\n    color = tonemap_hue_preserving(color*sourceColorSpaceToSrgb);\n    color = softClipColor(color);\n\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsczS.jpg", "access": "api", "license": "mit", "functions": [[1927, 2105, 2127, 2127, 2308], [2310, 2335, 2359, 2359, 2578], [2580, 2580, 2614, 2614, 2639], [2641, 2641, 2675, 2816, 3409], [3411, 3411, 3431, 3431, 3692], [3694, 3694, 3722, 3864, 4483], [4485, 4485, 4511, 4511, 4628], [4630, 4630, 4667, 4667, 4860], [4862, 4862, 4913, 4913, 5042], [5044, 5044, 5069, 5069, 5909], [5911, 5911, 5948, 5948, 8095], [8097, 8097, 8132, 8132, 8310], [8312, 8312, 8344, 8578, 9137], [9139, 9139, 9196, 9196, 9749]], "test": "untested"}
{"id": "sdsczS", "name": "easy motion blur test", "author": "takahiroando", "description": "based on\nhttps://www.youtube.com/watch?v=E0dsqlajCM4", "tags": ["motionblur"], "likes": 2, "viewed": 223, "published": 3, "date": "1642322733", "time_retrieved": "2024-07-30T17:09:28.860445", "image_code": "float sphere(vec3 p) {\n    return length(p) - 2.0;\n}\n\n\nfloat map(vec3 p) {\n    vec3 c = vec3(10.0);\n    return sphere(mod(p + 0.5*c, c) - 0.5 * c);\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    float hit = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        float d = map(ro);\n        ro += d * rd;\n        if (abs(d) < 0.0001) {\n            hit = 1.0;\n            break;\n        }\n    }\n    return vec4(ro, hit);\n}\n\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(123.45, 678.90))) * 987654.321);\n    }\n   \nvec3 normal(vec3 p) {\n    mat3 m = mat3(p, p, p) - mat3(0.01);\n    return normalize(map(p) - vec3(map(m[0]), map(m[1]), map(m[2])));\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord -  iResolution.xy) / min(iResolution.x, iResolution.y);\n    // time += 0.01 * random()\n    float blur = uv.x > 0.0 ? 0.01 : 0.0;\n    float t = iTime + blur * hash(uv + iTime);\n    vec3 ro = vec3(5.0, 0.0, -10.0 * t);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec4 hit = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    float col = hit.w > 0.0 ? max(dot(normal(hit.xyz), light), 0.0) : 0.0;\n    //col = hash(uv);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 52], [55, 55, 74, 74, 149], [151, 151, 184, 184, 407], [409, 409, 430, 430, 503], [508, 508, 529, 529, 646], [649, 649, 706, 756, 1294]], "test": "untested"}
{"id": "7ssyRS", "name": "Infinite Hearts ~ 126 chars", "author": "JuliaPoo", "description": "Procrastinating", "tags": ["hearts"], "likes": 2, "viewed": 194, "published": 3, "date": "1642313221", "time_retrieved": "2024-07-30T17:09:29.732115", "image_code": "#define f(i) 4. * cos(i.y + acos(cos(2. * i.x)) / 3.) * sin(i.x) - 3. * sin(iTime)\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    C += f((U/2e1 - iTime));\n}\n\n/* Minimized\n\n#define f(i) 4.*cos(i.y+acos(cos(2.*i.x))/3.)*sin(i.x)-3.*sin(iTime)\nvoid mainImage(out vec4 C,in vec2 U){C+=f((U/2e1-iTime));}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 122, 122, 153]], "test": "untested"}
{"id": "NssczB", "name": "Primordial Soup System", "author": "davidar", "description": "A continuous version of the [url=https://nagualdesign.github.io/]Primordial Particle System[/url] (also see [url]https://www.shadertoy.com/view/Wdj3zm[/url]), using reintegration tracking.", "tags": ["simulation", "fluid", "automata", "life", "cell", "particle", "ecology", "reintegration"], "likes": 18, "viewed": 479, "published": 3, "date": "1642312685", "time_retrieved": "2024-07-30T17:09:30.620738", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 data = texture(iChannel0, fragCoord / iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n    vec2 vel = P.V;\n\n    fragColor = vec4(pow(clamp(P.M, 0., 1.), .4));\n    fragColor.rgb *= .6 + .6 * cos(3.5*fragColor.x + vec3(0,23,21));\n\n    if(iMouse.z > 0. && length(iMouse.xy - fragCoord) < 10.) fragColor += 0.5;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_SPEED 1.9\n#define MAX_FORCE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame < 10) {\n        float q = 2.*PI * hash12(1. + fragCoord);\n        particle P;\n        P.X = fragCoord;\n        P.V = MAX_SPEED * vec2(cos(q), sin(q));\n        P.M = .45 - abs(fragCoord.x/iResolution.x - 0.5);\n        fragColor = saveParticle(P, fragCoord);\n        return;\n    }\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    particle P = getParticle(data, fragCoord);\n    vec2 pos = P.X, vel = P.V;\n\n    float r = 0., l = 0.;\n\n    for(int i = -RADIUS; i <= RADIUS; i++) {\n        for(int j = -RADIUS; j <= RADIUS; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(RADIUS)) continue;\n\n            vec4 data2 = texelFetch(iChannel0, ivec2(mod(fragCoord + ij, iResolution.xy)), 0);\n            particle P2 = getParticle(data2, fragCoord + ij);\n            vec2 pos2 = P2.X;\n            float m = P2.M;\n\n            vec2 d = pos - pos2;\n            float side = dot(vel, vec2(-d.y, d.x));\n            if(side > 0.0)\n                r += m;\n            else\n                l += m;\n        }\n    }\n\n    float angle = atan(vel.y, vel.x);\n    angle += ALPHA + BETA * (r + l) * tanh(r - l);\n    P.V = vec2(cos(angle), sin(angle));\n    fragColor = saveParticle(P, fragCoord);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// reintegration tracking code from https://www.shadertoy.com/view/ttBcWm\n#define Bi(p) ivec2(mod(p,iResolution.xy))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, DIFFUSION);\n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    particle P;\n    Reintegration(iChannel0, P, fragCoord);\n    fragColor = saveParticle(P, fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RADIUS 8\n#define DIFFUSION 1.12\n#define MAX_DENSITY 4.\n\n#define ALPHA radians(uv.y < .5 ? 117. :  0.) // intrinsic turning angle\n#define BETA  radians(uv.y < .5 ?  -4. : 13.) // reactive turning angle\n\n#define PI 3.14159265359\n\nstruct particle {\n    vec2 X, V;\n    float M;\n};\n\nparticle getParticle(vec4 data, vec2 pos) {\n    particle P;\n    if (data == vec4(0)) return P;\n    P.X = data.xy + pos;\n    P.M = data.z;\n    P.V = vec2(cos(data.w), sin(data.w));\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos) {\n    return vec4(clamp(P.X - pos, -.5, .5), clamp(P.M, 0., MAX_DENSITY), atan(P.V.y, P.V.x));\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 465]], "test": "untested"}
{"id": "7dlcW7", "name": "Fluidic Boids II", "author": "davidar", "description": "Separation is handled a bit more sensibly, and now has mouse interaction.", "tags": ["simulation", "fluid", "boids", "ecology"], "likes": 32, "viewed": 658, "published": 3, "date": "1642307936", "time_retrieved": "2024-07-30T17:09:31.576184", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 data = texture(iChannel0, fragCoord / iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n    vec2 vel = P.V;\n\n    fragColor.rgb = .6 + .6 * cos(atan(vel.y,vel.x) + vec3(0,23,21));\n    fragColor.rgb *= pow(clamp(P.M, 0., 1.), .4);\n\n    if(iMouse.z > 0. && length(iMouse.xy - fragCoord) < 10.) fragColor += 0.5;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_SPEED 1.9\n#define MAX_FORCE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if(iFrame < 10) {\n        float q = 2.*PI * hash12(1. + fragCoord);\n        particle P;\n        P.X = fragCoord;\n        P.V = MAX_SPEED * vec2(cos(q), sin(q));\n        P.M = .25;\n        fragColor = saveParticle(P, fragCoord);\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n\n    vec2 pos = P.X;\n    vec2 vel = P.V;\n    float m0 = P.M;\n\n    float mass = 0.;\n\n    vec2 alignment = vec2(0);\n    vec2 cohesion = vec2(0);\n    vec2 separation = vec2(0);\n\n    for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++) {\n        for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(NEIGHBOR_DIST)) continue;\n\n            vec4 data2 = texture(iChannel0, fract((fragCoord + ij) / iResolution.xy));\n            particle P2 = getParticle(data2, fragCoord + ij);\n            vec2 pos2 = P2.X;\n            vec2 vel2 = P2.V;\n            float m = P2.M;\n\n            float d2 = dot(pos - pos2, pos - pos2);\n            if(d2 < 1e-6) continue;\n            separation += clamp(pow(m + m0, 9.), 0., 9.) * (pos - pos2) / d2;\n\n            alignment += m * vel2;\n            cohesion  += m * pos2;\n            mass      += m;\n        }\n    }\n\n    float d = length(pos - iMouse.xy);\n    if(iMouse.z > 0. && d < 200.) {\n        alignment += iMouse.xy - texture(iChannel1, vec2(0)).xy;\n        if(d < 50.) {\n            separation += pos - iMouse.xy;\n        } else {\n            cohesion += d/1e3 * iMouse.xy;\n            mass     += d/1e3;\n        }\n    }\n    \n    cohesion = cohesion / mass - pos;\n    cohesion   = clamp_length(MAX_SPEED * normalize(cohesion)   - vel, MAX_FORCE);\n    alignment  = clamp_length(MAX_SPEED * normalize(alignment)  - vel, MAX_FORCE);\n    separation = clamp_length(MAX_SPEED * normalize(separation) - vel, MAX_FORCE);\n\n    if(!any(isnan(cohesion)))   vel += cohesion * COHESION;\n    if(!any(isnan(alignment)))  vel += alignment * ALIGNMENT;\n    if(!any(isnan(separation))) vel += separation * SEPARATION;\n    P.V = clamp_length(vel, MAX_SPEED);\n    fragColor = saveParticle(P, fragCoord);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// reintegration tracking code from https://www.shadertoy.com/view/ttBcWm\n#define Bi(p) ivec2(mod(p,iResolution.xy))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, DIFFUSION);\n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    particle P;\n    Reintegration(iChannel0, P, fragCoord);\n    fragColor = saveParticle(P, fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NEIGHBOR_DIST 6\n#define DIFFUSION     1.12\n#define ALIGNMENT     .45\n#define SEPARATION    1.\n#define COHESION      .9\n\n///\n\n#define PI 3.14159265359\n\nvec2 clamp_length(vec2 v, float r) {\n    if(length(v) > r) return r * normalize(v);\n    return v;\n}\n\nuint pack(vec2 x)\n{\n    x = 65535.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65535.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P;\n    if (data == vec4(0)) return P;\n    P.X = decode(data.x) + pos;\n    P.M = data.y;\n    P.V = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    vec2 x = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(x), P.M, P.V);\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iMouse;\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 465]], "test": "untested"}
{"id": "fssyRB", "name": "Hot Palette", "author": "oneshade", "description": "Hot looking colors.", "tags": ["color", "palette", "heat", "blackbodyish"], "likes": 13, "viewed": 190, "published": 3, "date": "1642298494", "time_retrieved": "2024-07-30T17:09:32.472787", "image_code": "vec3 heatPalette(in float h) {\n    //return vec3(1.0, pow(0.95, h), pow(0.1, h)) * pow(0.98, h);\n    return pow(vec3(0.98, 0.93, 0.1), vec3(h));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float h = fragCoord.x / iResolution.x * 100.0;\n    fragColor = vec4(heatPalette(h), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 96, 146], [148, 148, 203, 203, 299]], "test": "untested"}
{"id": "fdsyRB", "name": "[ floating circle snake ]", "author": "SimonOakey", "description": "another draft for the MACHINEPAINTING series - // updated with the help of @FabriceNeyret2 - thanky!", "tags": ["circle", "loop", "oscillation"], "likes": 10, "viewed": 313, "published": 3, "date": "1642297798", "time_retrieved": "2024-07-30T17:09:33.781288", "image_code": "// updated with the help of @FabriceNeyret2 - thanky!\n// check out the shrinked version in the comments!!\n\n// random function\n#define rand(n) fract(cos(n*89.42)*343.42)\n\n//draw a even nicer ring\n#define nice_ring(U,P,r,w)   w / abs(length(P - U) - r)\n\n// generic rotation by angle\n#define rot(a) mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n   vec2 uv = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n    // instead of this \n    //vec2 uv = 2.*( fragCoord.xy / iResolution.xy ) - 1. ;\n\t//uv.x *= iResolution.x/iResolution.y;\n\t\n\tfloat t = iTime*.3 , s = 0., r = .55, w = .2,  i = 0. ;\n\n\t// rotate all\n\tuv *= rot(t*.14);\n\t\n\t// slight wiggle all / on both axis\n\tuv += sin(t*.15)*.3;\n\t\t\t\n\tfor(;i<27.;i++){\n\t\t\n\t\tvec2 posi = vec2(sin(t + i*.23)*.5 , sin(i*.13 + t)*.80 );\n\t\t\n\t\tw += sin(i*.3+t*.81)*.02;\n\t\ts += nice_ring( uv, posi, r,w*.01 );\n\t\tr -=.01;\n\t\tw +=.01;\n\t\t\n\t}\n\t\n\ts = smoothstep(1.,.3,s)*.8-.1;\n\t\n\t// lowkey dithering - very light for nice fullscreen grain\n\ts -= rand(uv.x)*.04; \n\t\n\t// tweaky vignette whatever  \n\t float vig = uv.x*uv.y * 15.0; \n\t  s+=vig*.006-.1;\n     \n   \t\t\n\tfragColor = vec4( vec3(s), 1.0 );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 395, 395, 1192]], "test": "untested"}
{"id": "NslyRB", "name": "incomplete spiral staircase v2", "author": "jorge2017a2", "description": "incomplete, spiral, staircase, v2", "tags": ["spiral", "staircase", "v2", "incomplete"], "likes": 8, "viewed": 209, "published": 3, "date": "1642297602", "time_retrieved": "2024-07-30T17:09:34.845443", "image_code": "//----------image\n//por jorge2017a2-\n//incomplete spiral staircase-v2  -15-enero-2022\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b; return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); } \nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat tau = atan(1.0) * 8.0;\nvec3 opAngRep( vec3 p, float a )\n{   vec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec2 EscaleraV2(vec3 p)\n{   float d1,d2,d3,dfin1,dfin2,dfin3;\n    vec3 pos,a,b,a3,b3;\n    p.xz= rotatev2(p.xz, radians(iTime*20.0));\n    vec3 p0=p;\n    float d0= sdCylinderXZ(p-vec3(0.0,6.0,0.0), vec2(1.0,7.0) );\n    float r=0.25;\n\n    a=vec3(1.25,0.0,0.0); b=vec3(7.0,0.0,0.0);\n    a3=vec3(7.0,0.0,0.0);b3=vec3(7.0,0.2,3.5);\n     dfin1=9999.0;dfin2=9999.0;dfin3=9999.0;\n     float ang=18.0;\n\n    for (float i=0.0; i<10.0;i++)\n    {   vec3 p1= rotate_y(p0-vec3(0.0,0.0+i*1.0,0.0), radians(ang*i));\n        vec3 p2= rotate_y(p0-vec3(0.0,3.0+i*1.0,0.0), radians(ang*i));\n        vec3 p3= rotate_y(p0-vec3(0.0,6.0+i*1.0,0.0), radians(ang*i));\n        d1= sdBox( p1-vec3(3.5,0.0,0.0), vec3(3.0,0.15,0.7) );  //escalon\n        d2= sdBox( p2-vec3(6.5,0.0,-0.5), vec3(0.25,3.0,0.15) );  //poste       \n        float d3= sdSphere(p3-vec3(6.5,0.0,-0.5), 0.5 );\n        dfin1=min(dfin1,d1);\n        dfin2=min(dfin2,d2);\n        dfin3=min(dfin3,d3);\n    }\n    vec2 res;\n    res=opU(vec2(d0,2.0), vec2(dfin1,8.0));\n    res=opU(res, vec2(dfin2,11.0));\n    res=opU(res, vec2(dfin3,4.0));\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    //res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.y=p.y-4.0;\n    vec2 d5= EscaleraV2(p-vec3(0.0,1.5,0.0));\n    res =opU3(res, vec3(d5.x,d5.y,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;  return color;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0){return pattern( p.xz );}\n    if (id_material==8.0){return pattern( p.xy );}\n    if (id_material==9.0){return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    if (id_material>-1.0 && id_color==-1)\n        { colobj=vec3(0.5);\n          colobj*=getMaterial(p, id_material); return colobj;\n    }return colobj;\n}\n\nvec3 linear2srgb(vec3 c) \n{   return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,step(vec3(0.0031308), c));}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{  return vec3(1.0) - exp(-hdrColor * exposure);}\n\nvec3 ACESFilm(vec3 x)\n{   float a = 2.51;float b = 0.03;\n    float c = 2.43;float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd; mObj.ro=ro;\n   vec3 p,result;\n     float d=RayMarch(ro,rd, MAX_STEPS);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*0.25,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;        \n \tlight_pos1= vec3(-10.0, 20.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,12.0,-15.0+5.0*sin(t));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 583, 583, 604], [605, 605, 637, 637, 719], [721, 721, 760, 760, 855], [856, 856, 895, 895, 990], [991, 991, 1030, 1030, 1125], [1127, 1171, 1218, 1218, 1245], [1246, 1246, 1289, 1289, 1316], [1317, 1317, 1365, 1365, 1393], [1394, 1459, 1493, 1493, 1589], [1590, 1590, 1624, 1624, 1715], [1716, 1716, 1750, 1750, 1841], [1842, 1842, 1876, 1876, 1966], [1997, 1997, 2031, 2031, 2200], [2202, 2202, 2227, 2227, 3293], [3295, 3295, 3320, 3320, 3580], [3582, 3582, 3606, 3606, 3768], [3770, 3770, 3819, 3819, 4445], [4447, 4447, 4483, 4483, 4728], [4730, 4730, 4767, 4767, 5031], [5033, 5033, 5116, 5116, 5682], [5684, 5684, 5777, 5777, 5907], [5909, 5909, 5941, 5941, 6138], [6140, 6188, 6216, 6216, 6404], [6406, 6406, 6453, 6453, 6652], [6654, 6654, 6747, 6747, 7036], [7038, 7038, 7065, 7065, 7154], [7156, 7156, 7214, 7214, 7262], [7264, 7264, 7287, 7287, 7415], [7417, 7417, 7448, 7448, 8109], [8111, 8111, 8168, 8168, 8656]], "test": "untested"}
{"id": "sdXyRB", "name": "genuary2022 15: sandpiles", "author": "ml", "description": "sandpiles attempt", "tags": ["genuary", "genuary2022"], "likes": 5, "viewed": 275, "published": 3, "date": "1642291794", "time_retrieved": "2024-07-30T17:09:35.815848", "image_code": "//const vec3 palette [5] = vec3[5](vec3(0.995, 0.485, 0.415), vec3(0.945, 0.235, 0.415), vec3(0.545, 0.365, 0.345), vec3(0.655, 0.935, 0.815), vec3(0.995, 0.965, 0.965));\n\n//const vec3 palette [5] = vec3[5](vec3(0.185, 0.075, 0.065), vec3(0.415, 0.145, 0.095), vec3(0.895, 0.835, 0.765), vec3(0.155, 0.415, 0.495), vec3(0.775, 0.775, 0.035));\n//const vec3 palette[5] = vec3[5](vec3(0.185, 0.075, 0.065), vec3(0.415, 0.145, 0.095), vec3(0.665, 0.545, 0.465), vec3(0.895, 0.835, 0.765), vec3(0.155, 0.415, 0.495));\n\n//const vec3 palette[4] = vec3[4](  vec3(0.995, 0.965, 0.875), vec3(0.985, 0.595, 0.535), vec3(0.925, 0.425, 0.355), vec3(0.565, 0.585, 0.255));\n\nconst vec3 palette[4] = vec3[4] (vec3(0.995, 0.815, 0.035), vec3(0.805, 0.365, 0.465), vec3(0.865, 0.245, -0.005), vec3(0.445, 0.005, -0.005));\n\n//const vec3 palette[2] = vec3[2](vec3(0.), vec3(1.));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragCoord = floor(floor(fragCoord)/8.)+fract(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n        \n\n    float v = N1(0, 0);//(texture(iChannel1, uv).r)/3.;\n\n\n    //if(v <= 3.) v = 0.;\n\n    vec3 rgb = palette[int(mod(v+3., float(palette.length())))];\n        \n    // Output to screen\n    fragColor = vec4(rgb, 1.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float neighboursTotal =       N1(-1, 0) \n                      + N1( 0,-1)            + N1( 0, 1)\n                                  N1( 1, 0) ;\n    \n    bool topple = N1(0, 0) >= 4.;\n    \n    \n    fragColor = vec4(float(topple), 0., 0., 0.);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SEED 27.\n\n#define T0(i,j) texture(iChannel0, (uv + vec2(i,j)*vec2(1./iResolution.xy) )).r \n#define N0(i,j) +floor( T0(i,j) + 0.5)\n\n#define T1(i,j) texture(iChannel1, (uv + vec2(i,j)*vec2(1./iResolution.xy) )).r \n#define N1(i,j) +floor( T1(i,j) + 0.5)\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    //p3.x = abs(p3.x);\n    //p3.y = abs(p3.y);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_b_code": "//#define randb() hash13(vec3(fragCoord.xy, iTime+SEED+234.))\n//#define rand() hash13(vec3(floor(vec2((fragCoord.x-400.)/(15.)+randb()*0.1, (fragCoord.y-225.)/(15.)+randb()*0.1)), SEED)) \n\n\nfloat rand(vec2 fragCoord){\n    vec2 coord = vec2(\n        fragCoord.x/15.,\n        fragCoord.y/15.\n    );\n    \n    coord = floor(coord);\n    \n    float randVal = hash13(vec3(coord, SEED));\n    \n    float r = hash13(vec3(coord, SEED*10.+123.));\n    \n    if(r < 0.5 && mod(floor(fragCoord.x), 2.) == 0.){\n        randVal = mod(randVal+0.5, 1.);\n    }else if(r >= 0.5 && mod(floor(fragCoord.y), 2.) == 0.){\n        randVal = mod(randVal+0.5, 1.);\n    }\n    \n    return randVal; \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(iFrame == 0){\n        //float val = floor(rand()*2.)*4.;//2.;//floor(rand()*5.);\n        float val = rand(fragCoord)*2.0 + 1.6;//floor(rand()*2.)*1.+2.;\n        \n        \n        //if(int(fragCoord.x) == 80 && int(fragCoord.y) == 80) val = 3000.;\n        \n        fragColor = vec4(val, 0., 0., 0.);\n\n        return;\n    }\n    \n    \n    float sandGainFromNeighbours =  N0(-1, 0)\n                      + N0( 0,-1)              + N0( 0, 1)\n                                    N0( 1, 0);\n    \n    float currentValue = N1(0, 0);\n    \n    \n    float newValue = sandGainFromNeighbours + currentValue;\n\n     \n    if(N0(0, 0) > 0.) newValue -= 4.;\n    //if(int(fragCoord.x) == 400 && int(fragCoord.y) == 225) newValue = 0.;//10000.;\n    \n    fragColor = vec4(newValue, 0., 0., 0.);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[861, 861, 918, 918, 1251]], "test": "untested"}
{"id": "ssXyzB", "name": "sdf frame", "author": "elenzil", "description": "rejiggered, with Kastorp's suggested improvement and some minor rendering tweaks.", "tags": ["framesdf"], "likes": 10, "viewed": 316, "published": 3, "date": "1642280191", "time_retrieved": "2024-07-30T17:09:36.809192", "image_code": "// Fork of \"Raymarching - Primitives\" by iq. https://shadertoy.com/view/Xds3zN\n// 2022-01-15 20:02:10\n\n// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    https://iquilezles.org/articles/distfunctions\n\n\n\n//------------------------------------------------------------------\n// testing undefined preprocessor symbols.\n// comment out first three lines to replicate in-browser\n// the error which shows up in the iOS for HW_PERFORMANCE.\n#ifndef NO_SUCH_SYMBOL\n#define NO_SUCH_SYMBOL 1\n#endif\n#if NO_SUCH_SYMBOL == 0\nthis line is never compiled\n#endif\n//------------------------------------------------------------------\n\n\n#ifndef HW_PERFORMANCE     // iOS app fix\n#define HW_PERFORMANCE 0\n#endif\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n\nfloat min3(float a, float b, float c) {\n    return min(a, min(b, c));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Based on IQs sdBoundingBox().\nfloat sdFrame(vec3 p, vec2 b, float e)\n{\n       p = abs(p  )-vec3(b, e);\n  vec3 q = abs(p+e)-e;\n\n  return min3(\n    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0),\n    length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat _3FrameEdge(in vec3 v) {\n    return length(max(v, 0.0)) + min(max(v.x, max(v.y, v.z)), 0.0);\n}\n// thanks, @kastorp\nfloat sd3Frame( in vec3 p, in vec3 b, in float e)\n{\n//  b -= e;\n  p = abs(p);\n  vec3 m=step(p,p.zxy)*step(p,p.yzx);\n  p += m * (b - e) - b;\n  vec3 q = abs(p + e) - e;\n  float d =1e9;\n  d = min(d, _3FrameEdge(vec3(p.x, q.y, q.z)));\n  d = min(d, _3FrameEdge(vec3(q.x, p.y, q.z)));\n  d = min(d, _3FrameEdge(vec3(q.x, q.y, p.z)));\n  return d;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    float w = 0.025 + sin(iTime * 0.331) * 0.02;\n    \n    vec3 b = 0.25 + 0.05 * vec3(sin(iTime * 1.11), cos(iTime * 1.21), cos(iTime * 1.31));\n    \n    float r = 0.2;\n    float R = 2.0 + 2.0 * r;\n    \n    vec3 center = vec3(0.0, b.y + w * 0.25, 0.0);\n\n    res = opU( res, vec2( -w * r + sd3Frame     (pos - center, b - w * 0.0 * R, w ), 16.9 ) );\n    res = opU( res, vec2( -w * r + sdBoundingBox(pos - center, b - w * 1.0 * R, w ),  2.0 ) );\n    res = opU( res, vec2( -w * r + sd3Frame     (pos - center, b - w * 2.0 * R, w ),  2.9 ) );\n    res = opU( res, vec2( -w * r + sdBoundingBox(pos - center, b - w * 3.0 * R, w ), 11.1 ) );\n\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.841,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<270 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.001, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    float orbitSize = 3.0;\n    vec3 ta = vec3( 0.0, 0.25, -0.0 );\n    vec3 ro = ta + vec3( orbitSize*cos(0.1*time + 7.0*mo.x), 0.0 + 2.5*(1.0 - mo.y), orbitSize*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 7.0;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyzB.jpg", "access": "api", "license": "proprietary-license", "functions": [[1855, 1855, 1894, 1894, 1926], [1928, 1928, 1953, 1953, 1972], [1973, 1973, 1998, 1998, 2017], [2018, 2018, 2054, 2054, 2082], [2084, 2084, 2109, 2109, 2124], [2126, 2126, 2157, 2157, 2248], [2250, 2250, 2298, 2298, 2586], [2588, 2621, 2661, 2661, 2948], [2951, 2951, 2981, 2981, 3051], [3052, 3072, 3123, 3135, 3412], [3484, 3484, 3514, 3514, 3547], [3719, 3719, 3744, 3744, 4435], [4437, 4485, 4536, 4536, 4741], [4743, 4743, 4783, 4783, 5595], [5597, 5642, 5720, 5743, 6131], [6133, 6179, 6211, 6211, 6781], [6783, 6783, 6825, 6825, 7134], [7136, 7188, 7252, 7273, 7506], [7508, 7508, 7573, 7592, 10164], [10166, 10166, 10218, 10218, 10395]], "test": "untested"}
{"id": "7dfyzB", "name": "Fireblender", "author": "oneshade", "description": "Inspired by @SnoopethDuckDuck's Fractal Rope series.", "tags": ["fractal", "fire", "feedback", "blender"], "likes": 33, "viewed": 352, "published": 3, "date": "1642279307", "time_retrieved": "2024-07-30T17:09:37.745689", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = 0.5 * texture(iChannel0, uv);\n    fragColor += 0.75 * texture(iChannel1, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTimeDelta 0.025\n#define iTime (float(iFrame) * iTimeDelta)\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    vec2 st = 0.99 * (fragCoord / iResolution.xy - 0.5) + 0.5;\n    vec3 color = texture(iChannel0, st).rgb * 0.98;\n\n    color.g *= 0.95;\n    color.b *= 0.1;\n\n    float scale = 1.0;\n    for (int i=0; i < 10; i++) {\n        uv *= Rotate2D(iTime);\n        drawSDF(sdBox(uv, vec2(0.05)) / scale, vec3(1.0));\n        vec2 flip = sign(uv);\n        uv = abs(uv) - 0.2;\n        uv *= 2.5 * flip;\n        scale *= 2.0;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define WIDTH 30.0\n#define HEIGHT 30.0\n#define BLUR 10.0\n\nfloat gaussian(in float x, in float sigma) {\n    x /= sigma;\n    return 0.398942280401 / (sigma * exp(0.5 * x * x)); // 0.398942280401 ~ 1/sqrt(2)\n}", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float x=-WIDTH; x < WIDTH; x++) {\n        float weight = gaussian(x, BLUR);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(x, 0.0)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float y=-HEIGHT; y < HEIGHT; y++) {\n        float weight = gaussian(y, BLUR);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(0.0, y)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 193]], "test": "untested"}
{"id": "ssfyRB", "name": "[ floating strings ]", "author": "SimonOakey", "description": "wip of MACHINEPAINTING series", "tags": ["line", "wobble", "oscillation"], "likes": 18, "viewed": 516, "published": 3, "date": "1642268717", "time_retrieved": "2024-07-30T17:09:38.649273", "image_code": "#define count 12.\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n// generic rand return\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = 2.*( (fragCoord.xy) / iResolution.xy )-1.0 ;\n\t\n\t uv.x *= iResolution.x/iResolution.y;\n\t\n\tuv = rot(uv,iTime*.01+.3);\n \n\tfloat spread = .9;\n\tfloat thickness = .04;\n\tfloat wobble_freq = .15;\n\tfloat wobble_ampl = .15;\n\tfloat t = iTime*.77;\n\t\n\t\n\tvec3 col = vec3(0.0);\n\tfloat s = 0.;\n\t\n\tfor(float i=0.;i<count;i++){\n\t\n\t\t// individual wobble here\n\t\tuv.x += sin( (t-i*6.41) * uv.y * wobble_freq*.25  + (t-i*22.) + i*1.61 ) * wobble_ampl;\n\t\t\n\t\t// todo > eliminate ugly unision phase when sin becomes max ?!?\n\t\t\n\t\t// make them all move slightly\n\t\t uv.x += cos(t + i*uv.y * wobble_freq*.81)*.02;\n\t\t\n\t\t// offset each line\n\t\tuv.x +=\ti*spread*.03 - spread*count*.011;\n\t\n\t\ts += abs( .01 / uv.x* (thickness+i*.06+.01));\n\t}\n\n\t// emboss\n\ts = smoothstep(.7,.2,s)-.1;\n\t\n\t// lowkey dithering :)\n\ts -= rand(uv.x)*.06;\n\t\n\t\n\t\n\t float vig = uv.x*uv.y * 15.0; \n\t //vig = pow(vig, 0.25);\n\ts+=vig*.01-.2;\n\t\n\t\n\t\n\tfragColor = vec4( vec3(s), 1. );\n\n}\n  \n  \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 47, 73, 73, 138], [140, 163, 183, 183, 222], [225, 225, 282, 282, 1218]], "test": "untested"}
{"id": "sdfyzS", "name": "Projected Circles [Test]", "author": "Yusef28", "description": "Just a test of projection", "tags": ["projection"], "likes": 7, "viewed": 272, "published": 3, "date": "1642263592", "time_retrieved": "2024-07-30T17:09:39.526927", "image_code": "#define EPS 0.001\n#define S(r,a) smoothstep(r+EPS,r-EPS,a);\n\nfloat circleProj(vec2 uv, vec3 p, float r){\n    return S(r/p.z,length(uv-p.xy/(p.z)));\n}\n\nvec3 pointList[8] = vec3[8](\n    vec3(-0.5,-0.5,1.),\n    vec3(-0.5,0.5,1.),\n    vec3(0.5,-0.5,1.),\n    vec3(0.5,0.5,1.),\n    \n    vec3(-0.5,-0.5,2.),\n    vec3(-0.5,0.5,2.),\n    vec3(0.5,-0.5,2.),\n    vec3(0.5,0.5,2.)\n \n);\n\nmat2 rotX(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    uv*=2.;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.9);\n    float zMax = 5.;\n    float xMax = 5.;\n    /*for(float z = 1.; z <= zMax; z++){\n        for(float x = -xMax*0.5; x <= xMax*0.5; x++){\n            float y = sin(x+z+iTime)*0.3;\n            col = mix(col,vec3(0.1),circleProj(uv, vec3(x,y,z),0.1));\n            \n        }   \n    }*/\n\n    \n    for(int i = 0; i < 8; i++){\n        pointList[i].xy *= rotX(iTime*2.);\n        pointList[i].z -= 1.5;\n        pointList[i].xz *= rotX(iTime*2.);\n        pointList[i].z +=1.5;\n        col = mix(col,vec3(0.1),circleProj(uv, pointList[i], 0.125));\n    }\n    \n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 104, 104, 149], [374, 374, 393, 393, 456], [458, 458, 515, 565, 1311]], "test": "untested"}
{"id": "7sXcWn", "name": "Gamut compression comparison", "author": "bjornornorn", "description": "Gamut compression comparison", "tags": ["gamut"], "likes": 6, "viewed": 555, "published": 3, "date": "1642263064", "time_retrieved": "2024-07-30T17:09:40.343743", "image_code": "float modulo(float x)\n{\n    return x - floor(x);\n}\n\nfloat findCenter(vec3 x)\n{\n    float a = 1.9779984951f*x.x - 2.4285922050f*x.y + 0.4505937099f*x.z;\n    float b = 0.0259040371f*x.x + 0.7827717662f*x.y - 0.8086757660f*x.z;\n    float C = sqrt(a*a+b*b);\n    \n    // Matrix derived for max(l,m,s) to be as close to macadam limit as possible\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26923008, -1.43594808,  0.166718,\n        -0.98545265,  2.12616699, -0.14071434,\n        -0.02985871, -0.25753239,  1.2873911);\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n  \n    return c_smooth;\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n}\n\nvec3 calculateLCh(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float maxLms = findCenter(lms);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n\n    return vec3(maxLms, C, atan(-b, -a));\n}\n\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec3 LCh = calculateLCh(rgb);\n    vec2 STnew = vec2(LCh.x/LCh.y, (1.0-LCh.x)/LCh.y);\n    STnew = (STnew + 3.0*STnew*STnew*LCh.y);\n    \n\n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec3 LCh = calculateLCh(rgb);\n    float Cnew = (1.0/((ST.x/LCh.x) + (ST.y/(1.0-LCh.x))));\n\n    return max(LCh.y/Cnew, scale);\n}\n\nfloat softness_scale = 0.2;\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\n\nvec3 compute(float L, float hue, float sat)\n{\n    vec3 c;\n    c.x = L;\n    c.y = cos(hue);\n    c.z = sin(hue);\n    \n    float l_ = + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = - 0.0894841775f * c.y - 1.2914855480f * c.z;\n    \n    vec3 lms = vec3(l_,m_,s_);\n    \n    vec2 MC = findCenterAndPurity(lms);\n    \n    lms -= MC.x;\n    \n    lms *= sat;  \n    \n    lms += c.x;\n\n    lms = lms*lms*lms;\n    \n    float l = lms.x;\n    float m = lms.y;\n    float s = lms.z;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    \n    return rgbResult;\n}\n\nvec3 scurve3(vec3 x)\n{\n    return (3.0*x - x*x*x)/2.0;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    \n    float grey = 0.2;\n    \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n\n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = (fragCoord.x / iResolution.x)* 3.141592 * 2.;\n    float L = 2.0*fragCoord.y / iResolution.y;\n    L = L - floor(L);\n    float C = -0.5*log(0.5+0.5*sin(iTime));\n    \n    vec2 ST = approximateShape();\n   \n    float C_smooth = (1.0/((ST.x/L) + (ST.y/(1.0-L))));\n    float C_max;\n    \n    for (int i=0; i<200; i++)\n    {\n        vec3 rgbTest = compute(L, h, 0.5*float(i)/200.0);\n        float diff = length(rgbTest - clamp(rgbTest, 0., 1.));\n    \n        if(diff == 0.)\n        {\n            C_max = 0.5*float(i)/200.0;\n        }\n    }\n    \n    vec3 rgb;\n    \n    if (fragCoord.y / iResolution.y > 0.5)\n    {\n        rgb = compute(L, h, C/sqrt(C*C/C_smooth/C_smooth+1.0));\n        rgb = softClipColor(rgb);\n    }\n    else\n    {\n        rgb = compute(L, h, C/sqrt(C*C/C_max/C_max+1.0));\n    }\n    \n    fragColor.rgb = Srgb3(rgb);\n    fragColor.a = 1.;\n    \n        \n    //fragColor = vec4(Srgb3(avgColor),1.);\n}", "image_inputs": [], "common_code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 50], [52, 52, 78, 78, 955], [957, 957, 991, 1132, 1711], [1714, 1714, 1734, 1734, 1995], [1997, 1997, 2025, 2167, 2594], [2596, 2596, 2623, 2623, 2931], [2934, 2934, 2971, 2971, 3170], [3172, 3172, 3223, 3223, 3355], [3386, 3386, 3411, 3411, 4251], [4254, 4254, 4299, 4299, 5057], [5059, 5059, 5081, 5081, 5115], [5117, 5117, 5152, 5152, 5330], [5332, 5332, 5364, 5487, 6038], [6040, 6040, 6097, 6097, 7017]], "test": "untested"}
{"id": "ssfcRS", "name": "incomplete spiral staircase", "author": "jorge2017a2", "description": "incomplete spiral staircase\n\n", "tags": ["spiral", "staircase", "incomplete"], "likes": 3, "viewed": 214, "published": 3, "date": "1642258747", "time_retrieved": "2024-07-30T17:09:41.282233", "image_code": "//----------image\n//por jorge2017a2-\n//incomplete spiral staircase  -15-enero-2022\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n    \nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{   vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat tau = atan(1.0) * 8.0;\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec2 EscaleraV2(vec3 p)\n{   \n    float d1,d2,d3,dfin1,dfin2,dfin3;\n    vec3 pos;\n    vec3 a,b,a3,b3;\n    \n    p.xz= rotatev2(p.xz, radians(iTime*20.0));\n    vec3 p0=p;\n    float d0= sdCylinderXZ(p-vec3(0.0,6.0,0.0), vec2(1.0,7.0) );\n    \n    float r=0.25;\n    \n    a=vec3(1.25,0.0,0.0); b=vec3(7.0,0.0,0.0);\n    a3=vec3(7.0,0.0,0.0);b3=vec3(7.0,0.2,3.5);\n    \n     dfin1=9999.0;dfin2=9999.0;dfin3=9999.0;\n    \n    for (float i=0.0; i<12.0;i++)\n    {   vec3 p1= rotate_y(p0-vec3(0.0,0.0+i*1.0,0.0), radians(40.0*i));\n        vec3 p2= rotate_y(p0-vec3(0.0,3.0+i*1.0,0.0), radians(40.0*i));\n        vec3 p3= rotate_y(p0-vec3(0.0,6.0+i*1.0,0.0), radians(40.0*i));\n        \n        d1=sdCylinder(p1, a, b,0.45);\n        d2=sdCylinderXZ(p2-vec3(6.5,0.0,0.0), vec2(0.25,3.) );\n        \n        //d3=sdCylinder(p3, a3, b3,0.25);\n        float d3= sdSphere(p3-vec3(6.5,0.0,0.0), 0.5 );\n        \n        dfin1=min(dfin1,d1);\n        dfin2=min(dfin2,d2);\n        dfin3=min(dfin3,d3);\n    }\n    \n    vec2 res;\n    res=opU(vec2(d0,2.0), vec2(dfin1,8.0));\n    res=opU(res, vec2(dfin2,3.0));\n    res=opU(res, vec2(dfin3,4.0));\n    return res;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    //res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.y=p.y-4.0;\n    vec2 d5= EscaleraV2(p-vec3(0.0,1.5,0.0));\n    res =opU3(res, vec3(d5.x,d5.y,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*0.25,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-10.0, 20.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   \n   vec3 ro=vec3(0.0,12.0,-15.0+5.0*sin(t));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[545, 545, 581, 581, 602], [608, 608, 647, 647, 742], [743, 743, 782, 782, 877], [878, 878, 917, 917, 1012], [1014, 1058, 1105, 1105, 1132], [1133, 1133, 1176, 1176, 1203], [1204, 1204, 1252, 1252, 1280], [1281, 1346, 1380, 1380, 1476], [1477, 1477, 1511, 1511, 1602], [1603, 1603, 1637, 1637, 1728], [1729, 1729, 1763, 1763, 1858], [1860, 1860, 1911, 1911, 2269], [2300, 2300, 2334, 2334, 2507], [2509, 2509, 2534, 2534, 3638], [3641, 3641, 3666, 3666, 3930], [3932, 3932, 3956, 3956, 4118], [4120, 4120, 4169, 4169, 4836], [4839, 4839, 4875, 4875, 5120], [5122, 5122, 5159, 5159, 5435], [5437, 5437, 5520, 5520, 6094], [6096, 6096, 6189, 6189, 6319], [6321, 6321, 6353, 6353, 6550], [6552, 6600, 6628, 6628, 6816], [6818, 6818, 6865, 6865, 7096], [7098, 7098, 7191, 7191, 7532], [7535, 7535, 7562, 7562, 7672], [7674, 7674, 7732, 7732, 7784], [7787, 7787, 7810, 7810, 7950], [7953, 7953, 7984, 7984, 8696], [8699, 8699, 8756, 8756, 9249]], "test": "untested"}
{"id": "sdsyWN", "name": "Instamaze", "author": "davidar", "description": "I was playing with Lenia and happened across this Turing pattern", "tags": ["convolution", "diffusion", "automata", "life", "cellular", "maze", "reaction", "turing", "continuous", "artificial", "lenia"], "likes": 23, "viewed": 643, "published": 3, "date": "1642230079", "time_retrieved": "2024-07-30T17:09:43.940127", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = 1. - texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// modified from SmoothLife by davidar - https://www.shadertoy.com/view/Msy3RD\n\nconst int R = 10;         // space resolution = kernel radius\nconst float dt = .15;       // time step\n\nconst mat4 beta = mat4(.25,1,0,0, 1,.75,.75,0, 1,0,0,0, 0,0,0,0);   // kernel ring heights\nconst vec3 betaLen = vec3(2,3,1);    // kernel ring number\nconst vec3 mu = vec3(0.16, 0.22, 0.28);       // growth center\nconst vec3 sigma = vec3(0.025, 0.042, 0.025);   // growth width\nconst vec3 eta = vec3(1);     // growth strength\n\nconst float rho = 0.5;       // kernel center\nconst float omega = 0.15;    // kernel width\n\n#define G(z) exp(-.5*(z)*(z))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n\n    vec3 sum = vec3(0), total = vec3(0);\n    for (int x = -R; x <= R; x++) for (int y = -R; y <= R; y++) {\n        float r = length(vec2(x,y)/float(R));\n        if (r > 1.) continue;\n        float val = texelFetch(iChannel0, pos + ivec2(x,y), 0).x;\n        vec3 height;\n        for (int i = 0; i < 3; i++)\n            height[i] = beta[i][int(r * betaLen[i])];\n        vec3 weight = height * G((fract(r * betaLen) - rho) / omega);\n        sum += val * weight;\n        total += weight;\n    }\n    vec3 avg = sum / total;\n\n    float r = texelFetch(iChannel0, pos, 0).x;\n    r = mix(r, dot(G((avg - mu) / sigma), eta), dt);\n    r = clamp(r, 0., 1.);\n\n    if (iFrame < 2)\n        r = noise(fragCoord/float(R) + iTime*100.);\n    if (iMouse.z > 0.) {\n        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);\n        if (d <= 5.*float(R)/iResolution.x)\n        \tr = noise(fragCoord/float(R) + iTime*100.);\n    }\n\n    fragColor = vec4(r);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Noise simplex 2D by iq - https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "wsySDV", "name": "Tubular world", "author": "ShnitzelKiller", "description": "tubes", "tags": ["raymarching", "voxels", "tubes"], "likes": 5, "viewed": 353, "published": 3, "date": "1642225167", "time_retrieved": "2024-07-30T17:09:45.076089", "image_code": "#define GRID 0.5\n#define THICKNESS 0.05\n#define FDIST 0.5\n\n#define TOTAL_ITERS 100\n#define RAYMARCH_EPS 0.001\n\n#define OCCUPANCY 0.5\n\n#define FOV 1.55\n\nvec3 rainbow(float t) {\n    return vec3(sin(t), cos(t), -sin(t)) * .5 + .5;\n}\n\nfloat traceCell(in vec3 ro, in vec3 rd) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = GRID * abs(dr);\n    \n    vec3 pout =  k - n;\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat noise(in vec3 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nvec3 cellmod(in vec3 ro) {\n    return mod(ro, GRID) - GRID*0.5;\n}\n\nvec3 cellID(in vec3 ro) {\n    return floor(ro/GRID);\n}\n\nfloat occupancy(in vec3 id) {\n    return noise(id);\n}\n\n// LOD SDF: skip evaluating details if the current distance OR the distance to the exit is \nfloat longpipe(vec3 ro, float mindist, float bound) {\n    float dist = length(ro.yz) - THICKNESS;\n    if (dist < min(mindist, bound)) {\n        // complex stuff\n        dist += 0.005*GRID*(cos(ro.x*20. * 3.14159)+1.);\n    } \n    // bounding volume\n    return dist;\n}\n\nfloat torus(vec3 ro) {\n    float xydist = length(ro.xy) - 0.5 * GRID;\n    return length(vec2(ro.z, xydist))-THICKNESS;\n}\n\nvec2 march(in vec3 ro, in vec3 rd) {\n    vec3 id = cellID(ro);\n    vec3 dr = GRID/rd;\n    vec3 rs = sign(rd);\n    vec3 tr = (0.5 * rs - cellmod(ro)/GRID) * dr; // exiting t\n    vec3 t = vec3(0.); // current t\n    int i;\n    vec2 disp = vec2(1., 0.);\n    for (i=0; i<TOTAL_ITERS; i++) {\n        // DDA traversal\n        if (occupancy(id) > OCCUPANCY) {\n            // check neighbors\n            vec3 n_pos = step(OCCUPANCY, vec3(occupancy(id+disp.xyy),\n                              \t\t\t\t  occupancy(id+disp.yxy),\n                              \t\t\t\t  occupancy(id+disp.yyx)));\n            vec3 n_neg = step(OCCUPANCY, vec3(occupancy(id-disp.xyy),\n                              \t\t\t\t  occupancy(id-disp.yxy),\n                              \t\t\t\t  occupancy(id-disp.yyx)));\n            vec3 n_axes = n_pos + n_neg;\n            vec3 diff_axes = n_pos - n_neg;\n            float total = n_axes.x + n_axes.y + n_axes.z;\n            if (total > 0.5) {\n            \t\n                \n                // raymarching\n                float t0 = min(t.x, min(t.y, t.z));\n                float maxdist = min(tr.x, min(tr.y, tr.z)) - t0;\n                vec3 ro0 = ro + t0 * rd - (id+0.5) * GRID;\n                float tt = 0.;\n                for (; i<TOTAL_ITERS; i++) {\n                    vec3 pos = ro0 + tt * rd;\n                    float dist = 1e6;\n                    float bound = maxdist - tt;\n                    if (n_axes.x > 1.5) {\n                        dist = min(dist, longpipe(pos, dist, bound));\n                    }\n                    if (n_axes.y > 1.5) {\n                        dist = min(dist, longpipe(pos.yzx, dist, bound));\n                    }\n                    if (n_axes.z > 1.5) {\n                        dist = min(dist, longpipe(pos.zxy, dist, bound));\n                    } \n                    for (int j=0; j<2; j++) {\n                        if (abs(n_axes[j]-1.)<0.5) {\n                            for (int k=j+1; k<3; k++) {\n                                if (abs(n_axes[k]-1.)<0.5) {\n                                    vec3 u = vec3(0.);\n                                    u[j] = diff_axes[j];\n                                    vec3 v = vec3(0.);\n                                    v[k] = diff_axes[k];\n                                    vec3 w = cross(u, v);\n                                    mat3 rot = mat3(u, v, w);\n                                    mat3 rotT = transpose(rot);\n                                    vec3 pos_local = rotT * (pos -(v + u) * 0.5*GRID);\n                                    dist = min(dist, torus(pos_local));\n                                }\n                            }\n                        }\n                    }\n                    \n                    tt += dist;\n                    if (abs(dist) < RAYMARCH_EPS) {\n                        return vec2(tt + t0, i);\n                    }\n                    if (tt > maxdist || tt < 0.) {\n                        break;\n                    }\n                }\n            }\n        }\n        t = tr;\n        vec3 n = step(tr.xyz, tr.zxy) * step(tr.xyz, tr.yzx) * rs;\n        tr += dr * n;\n        id += n;\n    }\n    return vec2(min(t.x, min(t.y, t.z)), i);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x * FOV;\n\tvec3 eye = vec3(2.*iTime, 0.1, 0.1);\n    vec3 w = normalize(vec3(1., sin(.5*iTime), cos(iTime*.2)));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec2 c = cos(uv);\n    vec2 s = sin(uv);\n    vec3 rd = normalize(s.x * c.y * u + s.y * v + c.x * c.y * w);\n    \n    vec2 t = march(eye, rd);\n    \n    fragColor = vec4(pow(rainbow(t.x/2.+1.5) * vec3(1.-t.y/100.), vec3(0.75)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 175, 175, 229], [231, 231, 272, 272, 421], [423, 423, 447, 568, 1391], [1393, 1393, 1419, 1419, 1458], [1460, 1460, 1485, 1485, 1514], [1516, 1516, 1545, 1545, 1569], [1571, 1663, 1716, 1716, 1929], [1931, 1931, 1953, 1953, 2051], [2053, 2053, 2089, 2089, 5242], [5245, 5245, 5302, 5302, 5787]], "test": "untested"}
{"id": "fsXcRS", "name": "Even More Fractal Rope", "author": "SnoopethDuckDuck", "description": "little visualisation of how the trick works (2D fractal replacing time with height)", "tags": ["raymarching", "template", "artofcode"], "likes": 81, "viewed": 1112, "published": 3, "date": "1642223841", "time_retrieved": "2024-07-30T17:09:45.961721", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 400\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    vec2 uv = p.xz;\n   \n    //p = abs(p) - 0.5;\n    float time = 1. * p.y + 0.2 * iTime;\n    float th = 2. + 0.45 * iTime;\n    uv = abs(Rot(-0.8 *p.y + 0.1 * iTime) * uv );\n    \n    float m = 0.8;\n    float n = 4.;\n    for (float i = 0.; i < n; i++) {\n        th -= 2. * abs(.5 * i * iTime + 1.5 * th + (1.-i/n) * p.y);\n        uv = abs(Rot(th) * (uv - m));\n        m *= 0.35;\n    }\n\n    float d = length(uv) - 0.02;\n    d = max(p.y, d);\n    //float d = length(p) - 0.5;\n    \n    //float d = length(uv)- 0.5;\n    \n    return 0.5 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float l = 0.5 + 0.5 * thc(3., 0.5 * iTime);\n\n    float r = mix(0.01, 5.5, 1.-l);\n    float time = 0.45 * iTime;\n    vec3 ro = vec3(r * cos(time), mix(6., -3., 1.-l) + 0. * iTime, r * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,mix(0., -3., 1.-l),0), 2.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float ambient = .3;\n        float difPower = .4;\n        float dif = max(dot(n, normalize(vec3(1,2,3))), 0.);\n        col = vec3(dif*difPower + ambient);\n\n        col *= texture(iChannel0,r).rgb;\n        col *= 1. + r.y;//+ p.y;\n        col = clamp(col, 0., 1.);\n        \n        vec3 e = vec3(1.);\n        col *= pal(r.y, e, e, e, 0.35 * vec3(0.,0.33,0.66));\n        //col *= 0.5 + 0.5 * thc(4., 12. * length(p) + 0.4 * iTime) * cos(4. * p.y + iTime);\n        //col *= 0.5 * (1. + thc(2., iTime + p.y * 4.));\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcRS.jpg", "access": "api", "license": "mit", "functions": [[1474, 1474, 1493, 1493, 1555], [1557, 1557, 1580, 1580, 2116], [2118, 2118, 2152, 2152, 2363], [2365, 2365, 2389, 2389, 2579], [2581, 2581, 2631, 2631, 2822], [2824, 2824, 2881, 2881, 4108]], "test": "untested"}
{"id": "NsXcRS", "name": "Simple raytraced wire box", "author": "ShnitzelKiller", "description": "I found a nice way to raytrace a wire box in three passes. It is actually non-euclidian, but all the \"portals\" line up to create the illusion of being normal. Dunno if there's a more elegant method for raytracing this shape out there. Has mouse controls.", "tags": ["raytracing", "cube", "box"], "likes": 8, "viewed": 288, "published": 3, "date": "1642222446", "time_retrieved": "2024-07-30T17:09:46.880265", "image_code": "#define FDIST 0.5\n#define THICKNESS 0.25\n#define PI 3.1415926\n\n// raytrace a 2D box with outgoing normal\nvec2 box2d(in vec2 ro, in vec2 rd, in vec2 r, out vec2 no) {\n    vec2 dr = 1.0/rd;\n    vec2 n = ro * dr;\n    vec2 k = r * abs(dr);\n    \n    vec2 pout =  k - n;\n    vec2 pin =  - k - n;\n    float tout = min(pout.x, pout.y);\n    float tin = max(pin.x, pin.y);\n    no = -sign(rd) * step(pout.xy, pout.yx);\n    return vec2(tin, tout);\n}\n\n// Raytrace box, returns (t_in, t_out) and incident normal\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    vec3 pin =  - k - n;\n    float tout = min(pout.x, min(pout.y, pout.z));\n    float tin = max(pin.x, max(pin.y, pin.z));\n    no = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    return vec2(tin, tout);\n}\n\n//raytrace a wirebox\nvec2 wirebox_anim(in vec3 eye, in vec3 rd, in float r, in float thickness, out vec3 no) {\n    float modtime = mod(iTime, 6.);\n    vec2 t = box(eye, rd, vec3(r), no);\n    \n    if (t.y > t.x) {\n        //trace the inner walls by tracing infinite rectangular shafts in each face, then repeating once for the inner walls\n        vec3 ro = eye + t.x * rd;\n        for (int i=0; i<2; ++i) {\n            float thickness_curr = mix(1., thickness, smoothstep(0., 1., modtime - float(i)));\n            thickness_curr = mix(thickness_curr, 1., smoothstep(0., 1., modtime - 5.));\n            //transform the ray into tangent space to intersect it with a shaft perpendicular to the normal\n            mat2x3 invproj = mat2x3(no.zxy, no.yzx);\n            mat3x2 proj = transpose(invproj);\n            vec2 n2;\n            vec2 t2 = box2d(proj * ro, proj * rd, vec2(r-thickness_curr), n2);\n            if (t2.x > 0. || t2.y < 0.) {\n                break;\n            }\n            t.x += t2.y;\n            ro = eye + t.x * rd;\n            no = invproj * n2;\n        }\n            \n        //visualize clipping on/off (remove this part if using, obviously)\n        float inftime = atanh(clamp(-modtime+3., 0., 1.));\n        t.y = t.y + inftime*inftime;\n    }\n    return t;\n}\n\n//raytrace a wirebox (clean version without animations)\n/*\nvec2 wirebox(in vec3 eye, in vec3 rd, in float r, in float thickness, out vec3 no) {\n    vec2 t = box(eye, rd, vec3(r), no);\n    \n    if (t.y > t.x) {\n        //trace the inner walls by tracing infinite rectangular shafts in each face, then repeating once for the inner walls\n        vec3 ro = eye + t.x * rd;\n        for (int i=0; i<2; ++i) {\n            //transform the ray into tangent space to intersect it with a shaft perpendicular to the normal\n            mat2x3 invproj = mat2x3(no.zxy, no.yzx);\n            mat3x2 proj = transpose(invproj);\n            vec2 n2;\n            vec2 t2 = box2d(proj * ro, proj * rd, vec2(r-thickness), n2);\n            if (t2.x > 0. || t2.y < 0.) {\n                break;\n            }\n            t.x += t2.y;\n            ro = eye + t.x * rd;\n            no = invproj * n2;\n        }\n    }\n    return t;\n}*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tfloat ang = iTime * 0.5;\n    \n    vec3 eye;\n    if (iMouse.z > 0.) {\n        float mouseY = (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n        float mouseX =  -(iMouse.x/iResolution.x) * 2. * PI;\n        eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    } else {\n        eye = 4.*vec3(cos(ang), sin(ang), 0.3 * sin(ang/0.70752)+.3);\n    }\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + FDIST * w);\n    \n    //trace the outer box\n    vec3 n;\n    \n    vec2 t = wirebox_anim(eye, rd, 1., THICKNESS, n);\n    float objmask = step(0., t.y-t.x);\n    \n    //trace the floor\n    float tfloor = -(eye.z + 2.)/rd.z;\n    float floormask = step(0., tfloor);\n    vec3 bgcol = floormask * vec3(.5, .7, .8);\n    if (floormask > 0.5) {\n        //floor shadow\n        vec3 lightdir = normalize(vec3(-.3, -.5, -1.));\n        vec3 floorpt = eye + tfloor * rd;\n        vec3 ns;\n        vec2 ts = wirebox_anim(floorpt, lightdir, 1., THICKNESS, ns);\n        bgcol *= step(ts.y, ts.x);\n    }\n    \n    vec3 col = mix(bgcol, n*.5 + .5, objmask);\n    fragColor = vec4(mix(col, vec3(0.5, 0.1, 0.), objmask * clamp(1.-exp(-t.x/10.), 0., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 105, 165, 165, 437], [439, 498, 556, 556, 878], [880, 901, 990, 990, 2159], [3070, 3070, 3127, 3127, 4451]], "test": "untested"}
{"id": "7slyD7", "name": "6_1_fdistImproved", "author": "tomoe", "description": "sample code\ndistance to the nearest feature point\n(left) 2D  (right) 3D", "tags": ["ch6"], "likes": 2, "viewed": 270, "published": 3, "date": "1642211580", "time_retrieved": "2024-07-30T17:09:47.754927", "image_code": "int channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nfloat fdist21(vec2 p){\n    vec2 n = floor(p + 0.5);\n    float dist = sqrt(2.0);\n    for(float j = 0.0; j <= 2.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = -1.0; i <= 1.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            dist = min(dist, length(glid + jitter - p));\n        }\n    }\n    return dist;\n}\nfloat fdist31(vec3 p){\n    vec3 n = floor(p + 0.5);\n    float dist = sqrt(3.0);\n    for(float k = 0.0; k <= 2.0; k ++ ){\n            vec3 glid;\n            glid.z = n.z + sign(mod(k, 2.0) - 0.5) * ceil(k * 0.5);\n            if (abs(glid.z - p.z) - 0.5 > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ){\n            glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n            if (abs(glid.y - p.y) - 0.5 > dist){\n                continue;\n            }\n            for(float i = -1.0; i <= 1.0; i ++ ){\n                glid.x = n.x + i;\n                vec3 jitter = hash33(glid) - 0.5;\n                dist = min(dist, length(glid + jitter - p));\n            }\n        }\n    }\n    return dist;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x/ iResolution.x); \n    pos *= 10.0;\n    pos += iTime;\n    fragColor = channel == 0 ? vec4(fdist21(pos)) : vec4(fdist31(vec3(pos, iTime)));\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 164, 164, 263], [264, 264, 287, 287, 400], [401, 401, 424, 424, 525], [526, 526, 548, 548, 631], [632, 632, 653, 653, 739], [740, 740, 761, 761, 847], [848, 848, 868, 868, 950], [951, 951, 971, 971, 1053], [1054, 1065, 1087, 1087, 1559], [1560, 1560, 1582, 1582, 2306], [2307, 2307, 2361, 2361, 2624]], "test": "untested"}
{"id": "sslyD7", "name": "6_0_fdist", "author": "tomoe", "description": "sample code\ndistance to the nearest feature point ", "tags": ["ch6"], "likes": 1, "viewed": 215, "published": 3, "date": "1642211242", "time_retrieved": "2024-07-30T17:09:48.782180", "image_code": "//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nfloat fdist(vec2 p){\n    vec2 n = floor(p + 0.5);\n    float dist = sqrt(2.0);\n    for(float j = - 2.0; j <= 2.0; j ++ ){\n        for(float i = - 2.0; i <= 2.0; i ++ ){\n            vec2 glid = n + vec2(i, j);\n            vec2 jitter = sin(iTime) * (hash22(glid) - 0.5);\n            dist = min(dist, distance(glid + jitter, p));\n        }\n    }\n    return dist;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    pos *= 10.0;\n    pos += iTime;\n    fragColor = vec4(fdist(pos));\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 151, 151, 250], [251, 251, 274, 274, 387], [388, 388, 411, 411, 512], [513, 513, 535, 535, 618], [619, 619, 640, 640, 726], [727, 727, 748, 748, 834], [835, 835, 855, 855, 937], [938, 938, 958, 958, 1040], [1041, 1052, 1072, 1072, 1413], [1414, 1414, 1468, 1468, 1626]], "test": "untested"}
{"id": "NdlcDM", "name": "Super Collider #3 [Pulse Synth]", "author": "Yusef28", "description": "I first learned of the super collider tutorials from athibaul in the comments of his featured sahder \"Techno Song (sound)\"\nhttps://www.shadertoy.com/view/sls3WM\nThe link to those tutorials is in those comments, and in the sound tab of this shader.", "tags": ["pulse", "wave", "super", "collider", "supercollider"], "likes": 6, "viewed": 356, "published": 3, "date": "1642200545", "time_retrieved": "2024-07-30T17:09:49.684767", "image_code": "\n#define LETTER_SIZE 1./16.\n#define STEP_SIZE 1./8.\n#define FIRST_LETTER 64.\n#define FIRST_NUMBER 48.\n\nvec2 numToCoord(float a){\n    return vec2( mod(a,16.), 15.-floor(a/16.) );\n}\n\nvec3 C(vec2 uv, vec2 start, inout float moveX,float num){\n    moveX += STEP_SIZE/2.3;\n    if(uv.x < start.x           || \n       uv.x > start.x+STEP_SIZE || \n       uv.y < start.y           || \n       uv.y > start.y+STEP_SIZE){\n       return vec3(0.);\n    }\n    \n    uv -= start; uv /= STEP_SIZE; uv *= LETTER_SIZE;\n    uv += vec2(LETTER_SIZE*numToCoord(num));\n    return textureGrad(iChannel0,uv,dFdx(uv),dFdy(uv)).rrr;\n}\n\nvoid addC(vec2 st, float char, inout float moveX, inout vec3 col){\n    col = mix(col,vec3(1.),\n             C(st,vec2(moveX,0.45),moveX,FIRST_LETTER+char));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 st = uv;\n    float moveX = 0.23;\n    \n    addC(st,_s,moveX,col);  \n    addC(st,_o,moveX,col);\n    addC(st,_u,moveX,col);  \n    addC(st,_n,moveX,col);\n    addC(st,_d,moveX,col);\n    addC(st,_z+32.+5.,moveX,col);\n    addC(st,_i,moveX,col);\n    addC(st,_n,moveX,col);\n   // Output to screen\n   //col = texture(iChannel0,uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Super Collider Tutorials\n// https://www.youtube.com/playlist?list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC\n\n/*\nThis isn't exactly what we get at the end of tutorial #3 because\nfor example reverb is something I don't know how to do yet. I \nmostly hack these functions together based on how the creator\nof the videos describes them (plus whatever I can find online \nquickly.)\n*/\n\nfloat rnd(float a){return fract(sin(a*274.41)*4962.924);}\n\nfloat LFNoise(float t, float freq, float low, float high){\n    float id = floor(t*freq);\n    float seed = rnd(id);\n    float range = abs(high-low);\n    return floor(seed*range) + low;\n}\n\nfloat pulse(float t, float freq, float duty, float phase){\n    return step(1.-duty,mod((t+phase)*freq,1.)); \n}\n\nvec2 theSound(float t, float freq, float maxPartial){\n    vec2 sig; float ampl, freqPulse;\n    \n    ampl = pulse(t, 5., 0.5, 0.);\n    freqPulse = pulse(t, 6., 0.5, 0.)+1.;\n    freq *= LFNoise(t,2.,1.,maxPartial) * freqPulse;\n    sig.x = pulse(t, freq, 0.5,0.)*ampl;\n    \n    ampl = pulse(t, 4., 0.5, 0.3);\n    freqPulse = pulse(t, 7., 0.5, 0.)+1.;\n    freq *= LFNoise(t+800.,2.,1.,maxPartial) * freqPulse;\n    sig.y = pulse(t, freq, 0.5,0.2)*ampl;\n    \n    return sig;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    float freq = LFNoise(time,8.,200.,800.);\n    vec2 sig = theSound(time,20.,7.);\n    float sig1 = pulse(time,freq,0.5,0.);\n    return sig*0.1;//*exp(-3.0*time) )*0.2;\n}", "sound_inputs": [], "common_code": "#define _a 1.\n#define _b 2.\n#define _c 3.\n#define _d 4.\n#define _e 5.\n#define _f 6.\n#define _g 7.\n#define _h 8.\n#define _i 9.\n#define _j 10.\n#define _k 11.\n#define _l 12.\n\n#define _m 13.\n#define _n 14.\n#define _o 15.\n#define _p 16.\n#define _q 17.\n#define _r 18.\n#define _s 19.\n#define _t 20.\n#define _u 21.\n#define _v 22.\n#define _w 23.\n#define _x 24.\n#define _y 25.\n#define _z 26.", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 128, 128, 179], [181, 181, 238, 238, 603], [605, 605, 671, 671, 768], [770, 770, 827, 877, 1374]], "test": "untested"}
{"id": "fslyW4", "name": "Golden Ratio and Spiral", "author": "iq", "description": "A zoom into a Golder Spiral, which, like all logarithmic spirals, is self-similar. I added lots of comments in the code.", "tags": ["2d", "zoom", "spiral", "infinite", "goldenratio", "golden", "selfsimilar"], "likes": 84, "viewed": 1925, "published": 3, "date": "1642195205", "time_retrieved": "2024-07-30T17:09:50.567407", "image_code": "// Copyright Inigo Quilez, 2022 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2  op  = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float opx = 2.0/iResolution.y;\n    \n    // mathematical constants\n    const float kt = 6.283185307;         // tau\n    const float kh = (1.0+sqrt(5.0))/2.0; // phi\n    const float k2 = 4.0*log2(kh);\n\n    // for time and color dithering\n    float ran = fract(sin(fragCoord.x*7.0+17.0*fragCoord.y)*1.317);\n\n    // motion blur loop\n    vec3 tot = vec3(0.0);\n    #if HW_PERFORMANCE==0\n    const int kNumSamples = 6;\n    #else\n    const int kNumSamples = 12;\n    #endif\n    for( int mb=0; mb<kNumSamples; mb++ )\n    {\n        // aperture is half of a frame\n        float time = iTime + (0.5/60.0)*(float(mb)+ran)/float(kNumSamples);\n\n        // loop\n        float ft = fract(time/1.0);\n        float it = floor(time/1.0);\n\n        // constant (exponential) zoom\n        float sca = 0.5*exp2(-ft*k2);\n        vec2  p  = sca*op;\n        float px = sca*opx;\n\n        // draw golden rectangles\n        vec3 col = vec3(0.0);\n        {\n            float d = 1e20;\n            float w = 1.0;\n            vec2  q = p +  vec2(3,-1)/sqrt(5.0);\n            for( int i=0; i<20; i++ )\n            {\n                // square (in L2)\n                float t = max(abs(q.x),abs(q.y))-w;\n\n                // fill\n                if( t<0.0 )\n                {\n                    // color  (https://iquilezles.org/articles/palettes)\n                    float id = float(i) + it*4.0;\n                    col = vec3(0.7,0.5,0.4) + vec3(0.1,0.2,0.2)*cos(kt*id/12.0+vec3(2.0,2.5,3.0) );\n                    // texture\n                    col += 0.04*cos(kt*p.x*8.0/w)*cos(kt*p.y*8.0/w);\n                }    \n\n                // border (https://iquilezles.org/articles/distfunctions2d)\n                d = min( d, abs(t)-0.001*w );\n\n                // displace, rotate and scale for next iteration\n                q -= w*vec2(kh,2.0-kh);\n                q  = vec2(-q.y,q.x);\n                w *= kh-1.0; // should be w /= kh, but luckily 1/phi = phi-1\n            }\n            col *= smoothstep( 0.0, 1.5*px, d-0.001*sca );\n        }\n\n        // draw spiral (https://www.shadertoy.com/view/fslyWN)\n        {\n            p  /= (3.0-kh); // p  /= (2.0-1.0/kh);\n            px /= (3.0-kh); // px /= (2.0-1.0/kh);\n            float ra = length(p);\n            float an = atan(-p.x,p.y)/kt;\n            float id = round( log2(ra)/k2 - an );\n            if( id>-1.5 || (id>-2.5 && an>0.5-ft) )\n            {\n                float d = abs( ra - exp2(k2*(an+id)) );\n                col = mix( col, vec3(1.0), smoothstep( 2.0*px, 0.0, d-0.005*sca ) );\n            }\n        }\n        // accumulate\n        tot += col;\n    }\n    // resolve\n    tot /= float(kNumSamples);\n\n    // vignetting\n    tot *= 1.2-0.25*length(op);\n    \n    // remove color banding through dithering\n    tot += (1.0/255.0)*ran;\n\n    // output\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslyW4.jpg", "access": "api", "license": "proprietary-license", "functions": [], "test": "untested"}
{"id": "NslcD7", "name": "Spiral #4 (Keep Going)", "author": "lsdlive", "description": "@lsdlive\nCC-BY-NC-SA\n\nSpiral #4 (Keep Going)", "tags": ["raymarching", "spiral"], "likes": 26, "viewed": 563, "published": 3, "date": "1642190311", "time_retrieved": "2024-07-30T17:09:51.439077", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nSpiral #4 (Keep Going)\n\nGeometries are generated with sphere-tracing algorithms:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nSome notation:\np: position (usually in world space)\nrd: ray direction (eye or view vector)\n*/\n\n#define time iTime\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// http://mercury.sexy/hg_sdf/\n// hglib mirrorOctant\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x) p = p.yx;\n}\n\n// hglib pMod1\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\n// hglib pModPolar\nvoid amod(inout vec2 p, float d) {\n\tfloat a = re(atan(p.x, p.y), d); // beware, flipped y,x\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\n// signed cross\nfloat sc(vec3 p, float d) {\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x, min(p.y, p.z)) - d;\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n    vec3 q = p;\n\n    p.xy *= r2d(-time * .1);\n    p.xy *= r2d(p.z*.02);\n    p.z = re(p.z, 2.);\n\n    amod(p.xy, 6.28 / 4.);\n    mo(p.xz, vec2(.7, 1.3));\n    float sc2 = sc(p, 1.3);\n\n    amod(p.xy, 6.28 / 2.);\n    mo(p.xy, vec2(1.2, .2));\n    float d = sc(p, .4);\n\n    d = max(d, -sc2);\n\n    q.xy *= r2d(-time);\n    q.xy *= r2d(q.z*.9);\n    q.x = abs(q.x) - .3;\n    q.y = abs(q.y) - .24;\n    d = min(d, length(q.xy) - .01);\n\n    q.x = abs(q.x) - 2.3;\n    q.y = abs(q.y) - 3.;\n    d = min(d, length(q.xy) - .03);\n\n    g += .01 / (.02 + d * d);\n    return d;\n}\n\n\nfloat random(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n\n    vec3 ro = vec3(0, 0, -4. + time * 4.);\n    vec3 rd = normalize(vec3(uv, 1. - length(uv) * .2));\n\n    float t = 0.;\n    vec3 p;\n    float grain = random(uv);\n    for (float i = 0.; i < 1.; i += .01) {\n        p = ro + rd * t;\n        float d = de(p);\n        d = max(abs(d), .02);\n        d *= 1. + grain * .03;\n        t += d * .4;\n    }\n\n    vec3 c = vec3(.18, .37, .2);\n    c += g * .025;\n    c.r += sin(p.z) * .2;\n    c = mix(c, vec3(.15, .1, .2), 1. - exp(-.01 * t * t));\n    c *= 1.4;\n    c = clamp(c, 0., 1.);\n\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslcD7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[354, 354, 373, 373, 433], [435, 488, 519, 519, 593], [595, 610, 638, 638, 677], [679, 698, 732, 732, 830], [832, 848, 875, 875, 956], [972, 972, 990, 990, 1547], [1550, 1550, 1573, 1573, 1645], [1647, 1647, 1702, 1702, 2334]], "test": "untested"}
{"id": "fslcW7", "name": "Little Fractal", "author": "SnoopethDuckDuck", "description": "might stretch it around a torus later idk", "tags": ["e"], "likes": 3, "viewed": 234, "published": 3, "date": "1642182204", "time_retrieved": "2024-07-30T17:09:52.252901", "image_code": "//future ideas:\n// do same but split into 4/6 etc.\n// give each subdivision random split number\n\n\nmat2 Rot(float a) {\n    float s = sin(a); float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// doesnt work / wrong (I think?)\nfloat rand(float id) {\n    float time = iTime;\n    float v1 = h21(vec2(floor(time) + 10. * id));\n    float v2 = h21(vec2(floor(time) + 10. * id + 1.));\n    return mix(v1, v2, smoothstep(0., 1., fract(time)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float r = 0.5;\n    float th = 0.3 * iTime;\n    float sn = 1.;\n    float n = 5.;\n    float id = 0.;\n    for (float i = 0.; i < n; i++) {\n        th -= 0.5 * pi + 0.22 * (h21(vec2(id + 1.))-0.5) * iTime;\n        uv = 2. * Rot(sn * th) * uv;\n        int ind = int(mod(i, 2.));       \n        sn *= sign(uv[ind]);\n        uv[ind] = abs(uv[ind]) - r;\n        id += pow(0.1, i) * 0.5 * (1. + sn); // <- sloppy but works \n    }\n    \n    float d = length(uv);\n    float s = step(d -  0.25 * (1. + cos(2. * pi * h21(vec2(id)) + iTime)), 0.);\n    \n    vec3 col = vec3(s);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 117, 117, 189], [191, 225, 247, 247, 435], [437, 437, 494, 494, 1168]], "test": "untested"}
{"id": "sdXcW7", "name": "Basic Metronome", "author": "kbx", "description": "Sine wave gets more distorted over time due to shadertoy time precision.\nI've never wrote shaders before, but i think i did a pretty good job on this :)\nFeel free to copy the BPM algo for your own purposes, just give credit\nspecial thanks to 0v5vr \n\n", "tags": ["music", "gpusound", "metronome"], "likes": 1, "viewed": 271, "published": 3, "date": "1642180769", "time_retrieved": "2024-07-30T17:09:53.170447", "image_code": "//circle code borrowed from https://www.shadertoy.com/view/XsjGDt\n\nvec3 rgb(float r, float g, float b) {\nreturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\nfloat d = length(pos - uv) - rad;\nfloat t = clamp(d, 0.0, 1.0);\nreturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    calculateBPM(iTime);\n   \n    vec2 uv = fragCoord.xy;\n    vec2 center = iResolution.xy * 0.5;\n    float radius = ( 0.3 - smoothstep(lb, lb+(tbb), iTime) / 10.) * iResolution.y;\n\n    vec4 layer1 = vec4(rgb(0., 0., 0.), 1.0);\n    vec3 color = rgb(255.0, 255.0, 255.0);\n    vec4 layer2 = circle(uv, center, radius, color);\n    fragColor = mix(layer1, layer2, layer2.a);\n}", "image_inputs": [], "sound_code": "\n\nvec2 mainSound( int samp, float time )\n{\n    \n    calculateBPM(time);\n\n    //metronome\n    \n    if(cb == 0){\n    return vec2( (sin((6.2831*2000.0)*time) / 10.) * exp(-10.*(time - lb)) );\n    }else{\n    return vec2( (sin((6.2831*1000.0)*time) / 10.) * exp(-10.*(time - lb)) );\n    }\n}", "sound_inputs": [], "common_code": "// by kbx\n//\n// https://www.shadertoy.com/view/sdXcW7\n\n#define BPM 200.\n\n\nfloat tbb = 1./(BPM/60.); // time between each beat\nfloat lb;                 // time on last beat\nfloat lba;                // time on last bar\nint cbf = 1;              // total beats\nint cb;                   // current beat\nint bp = 1;               // total bars\n\n\nvoid calculateBPM(float time){\n    cbf = int(time / tbb);\n    if(cbf >= 2){\n        if( cbf % 4 == 0){\n             bp = cbf/4;\n             cb = cbf-(bp*4);   \n        }else{\n              cb = cbf-(bp*4);\n            }\n    }else{\n        cb = cbf;\n    }\n    \n    lb = (float(cbf) * tbb);\n    lba = lb - (float(cb) * tbb);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 104, 104, 152], [155, 155, 210, 210, 305], [307, 307, 364, 364, 736]], "test": "untested"}
{"id": "fdfcW8", "name": "PixelBytes", "author": "eiffie", "description": "bytebeats applied to pixel coords", "tags": ["bytebeats", "pixelbytes"], "likes": 9, "viewed": 388, "published": 3, "date": "1642177965", "time_retrieved": "2024-07-30T17:09:54.056079", "image_code": "#define rez iResolution\nvoid mainImage( out vec4 O, in vec2 U )\n{//an idea from https://fractalforums.org/index.php?topic=4561.0\n    vec2 u=(2.*U-iResolution.xy)/rez.x;\n    ivec2 v=ivec2(atan(u.x,u.y)/3.14159*512.,dot(u,u)*256.-pow(iTime,1.5)*16.);\n    int t=int(iTime*8.);\n    O=vec4(1)-vec4(abs(v.x&v.y)%t,(v.x^v.y)&t,(v.x&v.y)&t,0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{//bytebeats\n    float tym=time+sin(time*3.14*4.41*time)*.0005;\n    int t=int(tym*44100.+.5);\n    int t1=t*(t>>7 & t>>12);\n    t*=(t>>9 & t>>14);\n    return vec2( ivec2(t,t1)%256)/256. -.5;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 65, 128, 337]], "test": "untested"}
{"id": "fdsyDM", "name": "GenericHelixSpiral", "author": "Del", "description": "My attempt at a rectangle profile generic helix spiral - distance is far from exact  ", "tags": ["spiral"], "likes": 7, "viewed": 321, "published": 3, "date": "1642174162", "time_retrieved": "2024-07-30T17:09:54.962656", "image_code": "// my generic helix spiral function - distance is not exact, but it may be good enough for your needs... :)\n// currently thinking about how to cap the top and bottom properly\n\n#define PI 3.14159265\n#define TAU 6.283185\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\nfloat smax(float a,float b,float k)\n{\n    k = -k;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n// pass in a negative coils value to reverse direction...\n// better clamping...\n\n// pass in a negative coils value to reverse direction...\nfloat sdHelixSpiral(vec3 p, float rad1,float rad2, float height, float coils, float pd,float ph)\n{\n    float rounding = 0.1;\n    float dir = sign(coils)*0.5;\n    coils=abs(coils);\n\n    coils =  coils / (height/PI);\n\n    float vv = clamp(p.z, -height*0.5, height*0.5);\n    vv = remap(vv,-height*0.5, height*0.5,rad2,rad1);\n    vec3 pp = vec3(normalize(p.xy)*vv, p.z);\n    float d1 = distance(p, pp);\n\tfloat d2 = asin(sin(p.z*coils + dir*atan(p.x,p.y)))/coils;\n    float d=sdBox2D(vec2(d1,d2), vec2(pd,ph))-rounding;\n\n    // hard clamp top and bottom\n    float t = abs(p.z) - height*0.5;\n    d = smax(d,t,0.5);\n    return d;\n}\n\n\n// old version with manky clamping\n/*float sdHelixSpiral(vec3 p, float rad1,float rad2, float height, float coils, float pd,float ph)\n{\n    float rounding = 0.1;\n    float dir = sign(coils)*0.5;\n    coils=abs(coils);\n\n    coils =  coils / (height/PI);\n\n    float vv = clamp(p.z, -height*0.5, height*0.5);\n    float vv1 = remap(vv,-height*0.5, height*0.5,rad2,rad1);\n    \n    vec3 pp = vec3(normalize(p.xy)*vv1, vv);\n    float d1 = distance(p, pp);\n\tfloat d2 = asin(sin(p.z*coils + dir*atan(p.x,p.y)))/coils;\n    float d=sdBox2D(vec2(d1,d2), vec2(pd,ph))-rounding;\n    return d;\n}\n*/\n\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat map( in vec3 pos )\n{\n    pos.xz*=rot(fract(iTime*0.24)*6.28);\n    \n    float ns1 = 0.5+sin(iTime*1.1)*0.5;\n    float ns2 = 0.5+sin(iTime*0.7)*0.5;\n    \n    float rad1 = 1.0+ns1*2.0;  // top rad\n    float rad2 = 4.0;         // bottom rad\n    float height = 4.0+(3.0*ns2);\n    float pd = 0.25;           // extrude depth\n    float ph = 0.075;           // extrude height\n    float coils = 5.0;        // (negative values will reverse spiral direction)\n    float d1 = sdHelixSpiral(pos.xzy, rad1,rad2,height, coils, pd, ph);\n    \n    return d1*0.7;    // distance is not exact due to massive deformation ;)\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    float maximumDistance = 30.0;\n    float t = 0.0;\n    for (int i = 0; i < 150; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = map(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = PI*0.4;\n\tvec3 rayOrigin = vec3(9.0 * cos(angle), 6.0, 9.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    ivec2 sampleCount = ivec2(1.0, 1.0);\n\n    vec2 uv = fragCoord;\n    uv = uv / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, 1.5));\n    rayDirection = cameraTransform * rayDirection;\n    float t = raycast(rayOrigin, rayDirection);\n    vec3 color = vec3((1.0-abs(uv.y))*0.1);\n    \n    if (t > 0.0)\n    {\n        vec3 position = rayOrigin + rayDirection * t;\n        vec3 n = calcNormal(position);\n        \n            vec3 mycol = vec3(0.58,0.41,0.24);\n            vec3 pos = rayOrigin + t*rayDirection;\n            vec3 nor = n;\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rayDirection, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 64.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            color =  mycol*dif;\n            color+=spec;\n    }\n\tfragColor = vec4(sqrt(color), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 239, 239, 297], [299, 299, 338, 338, 418], [421, 421, 483, 483, 525], [527, 527, 564, 564, 679], [761, 819, 917, 917, 1443], [2032, 2032, 2084, 2084, 2191], [2195, 2195, 2221, 2221, 2807], [2809, 2855, 2887, 2887, 3125], [3128, 3128, 3167, 3167, 3349], [3350, 3350, 3400, 3400, 3752], [3755, 3755, 3810, 3810, 4985]], "test": "untested"}
{"id": "sdfcW7", "name": "sdTurd", "author": "Del", "description": "Signed distance for a dog poop - NOT EXACT ;)", "tags": ["raymarch", "spiral", "poop"], "likes": 13, "viewed": 317, "published": 3, "date": "1642166553", "time_retrieved": "2024-07-30T17:09:55.953009", "image_code": "// poop - NOT EXACT ;)\n\n#define PI 3.14159265\n#define TAU 6.283185\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat smax(float a,float b,float k)\n{\n    k = -k;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdHelix(vec3 p, float radius,float height, float coils, float pd,float ph)\n{\n    coils =  coils / (height/PI);\n    vec3 pp = vec3(normalize(p.xy)*radius, clamp(p.z, -height*0.5, height*0.5));\n    float d1 = distance(p, pp);\n\tfloat d2 = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    float d=sdBox2D(vec2(d1,d2), vec2(pd,ph));\n    return d;\n}\n\nfloat sdTurd(vec3 pos)\n{\n    float radius = 2.5;\n    float height = 4.0;\n    float pd = radius-0.35;\n    float ph = 0.01f;\n    float coils = 4.0;    \n    float d1 = sdHelix(pos.xzy, radius,height, coils, pd, ph)-0.02;\n    float d2 = sdCappedCone(pos,(height)*0.5,radius,0.0)-0.03;\n    float d = smax(d2,-d1,0.45);\n    return d*0.95;\n}\n\nfloat map( in vec3 pos )\n{\n    pos.xz*=rot(fract(iTime*0.24)*6.28);\n    return sdTurd(pos);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    float maximumDistance = 30.0;\n    float t = 0.0;\n    for (int i = 0; i < 150; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = map(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = PI*0.4;\n\tvec3 rayOrigin = vec3(6.0 * cos(angle), 3.0+(sin(iTime*0.1)*1.5), 6.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    ivec2 sampleCount = ivec2(1.0, 1.0);\n\n    vec2 uv = fragCoord;\n    uv = uv / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, 1.5));\n    rayDirection = cameraTransform * rayDirection;\n    float t = raycast(rayOrigin, rayDirection);\n    vec3 color = vec3((1.0-abs(uv.y))*0.1);\n    \n    if (t > 0.0)\n    {\n        vec3 position = rayOrigin + rayDirection * t;\n        vec3 n = calcNormal(position);\n        \n            vec3 mycol = vec3(0.48,0.21,0.04);\n            vec3 pos = rayOrigin + t*rayDirection;\n            vec3 nor = n;\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rayDirection, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 64.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            color =  mycol*dif;\n            color+=spec;\n    }\n\tfragColor = vec4(sqrt(color), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 93, 93, 112], [113, 113, 172, 172, 485], [487, 487, 524, 524, 639], [641, 641, 660, 660, 718], [720, 720, 759, 759, 839], [841, 841, 923, 923, 1193], [1195, 1195, 1219, 1219, 1529], [1531, 1531, 1557, 1557, 1624], [1626, 1672, 1704, 1704, 1942], [1945, 1945, 1984, 1984, 2166], [2167, 2167, 2217, 2217, 2569], [2572, 2572, 2627, 2627, 3823]], "test": "untested"}
{"id": "7sfcD7", "name": "Herringbone tilling", "author": "xZAKHAMx", "description": "Herringbone tilling ... WIP", "tags": ["herringbone"], "likes": 5, "viewed": 252, "published": 3, "date": "1642166423", "time_retrieved": "2024-07-30T17:09:56.811712", "image_code": "float S(float x, float snap)\n{\n    return floor(x)*snap;\n}\n\nfloat pingpong(float value, float scale)\n{\n    return scale - abs(mod(abs(value), (2.*scale)) - scale);\n}\n\nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 20.;\n    float BL = 3.;\n    float edgeblur = .95;\n    float edgegap  = .98;\n    vec2 uv = (fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= scale;\n    float col = 0.;\n    \n    float snapX = S(uv.x, 1.);\n    float snapY = S(uv.y, 1.);\n    \n    float t1 = snapX + uv.y;\n    float t2 = snapY + uv.x;\n    \n    float modY = mod(t1, BL*2.);\n    float modX = mod(t2, BL);\n    if(modY < BL) col = 1.;\n    \n    float UVy = mix(modX, modY, col);\n    \n    vec2 fracUV = fract(uv);\n    float UVx = mix(fracUV.y, fracUV.x, col);\n    \n    vec2 newUV = vec2(UVx, UVy);\n    \n    float snapT1 = S(t1, BL)+t1;\n    float snapT2 = S(t1, BL)-t2;\n    float snapT12 = mix(snapT2, snapT1, col);\n    float h = pingpong(UVx, .5);\n    float w = pingpong(UVy, BL/2.);\n    vec3 edge = vec3(w, h, 0.);\n    vec3 edgeburn = blendColorBurn(edge, vec3(edgegap), 1.);\n    vec3 edgedodge = blendColorDodge(edgeburn, vec3(edgeblur), 1.);\n    float edges = min(edgedodge.x, edgedodge.y);\n    fragColor = vec4(edges);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 58], [60, 60, 102, 102, 165], [167, 167, 214, 214, 278], [279, 279, 323, 323, 433], [435, 435, 494, 494, 570], [572, 572, 620, 620, 676], [677, 677, 722, 722, 835], [837, 837, 897, 897, 974], [975, 975, 1032, 1032, 2060]], "test": "untested"}
{"id": "7lySDz", "name": "Glossy Reflections", "author": "Shane", "description": "Path tracing and lighting up a very basic scene.", "tags": ["global", "illumination", "tracing", "path", "glossy", "emissive"], "likes": 70, "viewed": 1097, "published": 3, "date": "1642166189", "time_retrieved": "2024-07-30T17:09:57.829989", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // The other buffer has a maximum Y-resolution of 540 set, which \n    // means any pixels outside that are not rendered. On a 1980x1080\n    // fullscreen resolution, this means roughly a quarter of the pixels\n    // are rendered, which is a huge saving. Of course, this also means\n    // that the scene needs to be upscaled, which will make things less\n    // crisp, but you can't have everything. :)\n    //\n    // By the way, this tip came from Shadertoy user, spalmer, who has\n    // a heap of interesting work for anyone interested:\n    // https://www.shadertoy.com/user/spalmer\n    //\n    float maxRes = 540.;\n    vec2 uv = fragCoord/iResolution.xy;\n    // If the resolution exceeds the maximum, upscale.\n    if(iResolution.y>maxRes) uv = (fragCoord/iResolution.xy - .5)*maxRes/iResolution.y + .5;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(col, vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Glossy Reflections\n    ------------------\n    \n    I do a bit of path tracing in the background, but noticed that I haven't\n    put a 3D one up on Shadertoy yet, so I dug up a very old example and \n    prettied it up a bit, just to get one on the board, as they say. I'll put\n    up some more interesting examples in due course.\n    \n    People say realtime path tracing is here... I'm not entirely convinced, \n    but I've seen some mind blowing examples out there. Either way, it's\n    definitely possible to trace out some inexpensive rudimentary geometry \n    and produce a simple but nicely lit scene. \n    \n    This particular scene comprises one sphere, four walls and some pattern \n    generated emitters. With the spare cycles, I've attempted to produce some \n    glossy reflections. Due to the limited number of samples, the results \n    aren't perfect by any stretch, but I can remember being utterly amazed by \n    a realtime raytraced Phong-lit white sphere on a brown background running \n    at under 10 FPS back in the 90s, so it's an improvement. :) \n    \n\n*/\n\n\n// Sample number and blend number: The trick is to find a balance between the\n// two, or use a faster computer. :)\n\n// Number of samples: My computer can handle more. If yours is struggling, you \n// can lower this. Naturally, sample number is proportional to noise quality.\n#define sampNum 32\n\n// The blended samples per frame: Higher numbers give the impression of more\n// samples, which boosts quality. However, there's a price to pay, and that's \n// ghosting effects. Any more than 2 or 3 will result in noticeable ghosting.\n#define blendNum 2.\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n/*\n// Tone mapping: There are so many to choose from, and which one you use depends on\n// what you're after, but I prefer the Uncharted 2 tone map since it works as advertised,\n// which is tone down values in the high dynamic range and leave the others alone.\nfloat A = .22, B = .3, C = .1, D = .2, E = .01, F = .22;//.3;\n//float W = 11.2;\n\nvec3 Un2Tone(vec3 x){\n\n   return ((x*(A*x + C*B) + D*E)/(x*(A*x + B) + D*F))-E/F;\n}\nvec4 Uncharted2Tonemap(vec4 col){\n\n   float ExposureBias = 1.;\n   col.xyz = Un2Tone(ExposureBias*col.xyz);\n\n   col.w = 2.2;//1./dot(col, vec4(.299, .587, .114, 0));\n   vec3 whiteScale = 1./Un2Tone(vec3(col.w));//col.www\n   \n   return vec4(col.xyz*whiteScale, col.w); \n}\n*/\n\n/////\nvec2 seed = vec2(.183, .257);\n\n/*\nvec2 hash22() {\n    \n    seed += fract(seed + vec2(.7123, .6247));\n     \n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), \n                          dot(seed.xy, vec2(41.898, 57.263))))\n                          *vec2(43758.5453, 23421.6361));\n}\n*/\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash22(){\n\n    // I should probably use a \"uvec2\" seed, but I hacked this from an old\n    // example. I'll update it later.\n    seed = fract(seed + vec2(.7123, .6457));\n    uvec2 p = floatBitsToUint(seed);\n    \n    // Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n    // Faster than \"full\" xxHash and good quality.\n    p = 1103515245U*((p>>1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n// IQ's box routine.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : - 1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n\n\n    return q;\n}\n\n\n/////////\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir( in float seed, in vec3 n){\n\n    vec2 rnd = hash22();\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n/////\n\n// Sphere normal.\nvec3 sphereNorm(vec3 p, float id, vec4 sph){\n   \n    return (p - sph.xyz)/sph.w; \n    \n}\n\n\n \n// Hitting a number of walls from the inside: You could simply raytrace four\n// planes, but this is a little more concise. I was too lazy to write my own\n// routine, so quickly adapted a working one (sadly, not many of those around) \n// from one of PublicIntI's examples. At some stage, I'll get in amongst it and \n// rewrite one, or find one of my older routines. Alternatively, if someone\n// knows of a concise reliable function or sees a way to tidy the following up, \n// feel free to let me know. :)\n//\n// crystal exhibit(pathtraced) - public_int_i \n// https://www.shadertoy.com/view/wljSRz\n//\n// Ray-box intersection: The function take in the ray origin (offset if needed)\n// the unit direction ray and the box dimensions, then returns the distance and \n// normal.\n//\nvec4 boxIntersect(vec3 ro, vec3 rd, vec3 dim) {\n\n    const float maxT = 1e8;\n \n    vec3 minD = (ro + dim)/rd, maxD = (ro - dim)/rd;\n\tminD = -(minD - step(vec3(-1e-6), minD)*(minD + maxT));\n\tmaxD = -(maxD - step(vec3(-1e-6), maxD)*(maxD + maxT));\n\tminD = min(minD, maxD);\n    \n    // Result: Distance and normal.\n    vec4 res;\n\n    // Performing some ray-plane intersections, modified to handle\n    // two planes at once. I'd imagine you could cleverly combine this\n    // into just one test, but I'm not clever, so I'll leave that to \n    // someone else. :D\n     \n    // We don't need the left and right walls for this example.\n    //if (minD.x<maxT){\n        //vec2 pd = abs(ro.zy + rd.zy*minD.x) - dim.zy;\n        //if (max(pd.x, pd.y) < 0.) res = vec4(minD.x, -sign(rd.x), 0, 0);\n    //}\n    \n    // Top and bottom surfaces, or ceiling and floor, if you prefer.\n    if (minD.y<maxT){\n        vec2 pd = abs(ro.xz + rd.xz*minD.y) - dim.xz;\n        if (max(pd.x, pd.y) < 0.) res = vec4(minD.y, 0, -sign(rd.y), 0.);\n    }\n    \n    // Front and back walls.\n    if (minD.z<maxT){\n        vec2 pd = abs(ro.xy + rd.xy*minD.z) - dim.xy;\n        if (max(pd.x, pd.y) < 0.) res = vec4(minD.z, 0, 0, -sign(rd.z));\n    }\n    \n    // Return the distance and normal.\n    return res;\n}\n \n \n// Sphere intersection: Pretty standard, and adapted from one\n// of IQ's formulae.\nvec2 sphereIntersect(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n    if(b > 0.) return vec2(1e8, 0.);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.) return vec2(1e8, 0.);\n\treturn vec2(-b - sqrt(h), 1.); \n    \n}\n\n\n// Sphere position and radius.\nconst vec4 sph4 = vec4(0, -.5, 1., .5);\n\n// Hacking in a normal for the box equation.\nvec3 boxNrm;\n\n// Scene normal logic: Not that exciting for this example. :)\nvec3 getNorm(vec3 p, float id){\n    \n    return (id<.5)? sphereNorm(p, id, sph4) : boxNrm; \n}\n\n\n// Intersection logic for all objects.\nvec3 intersect(vec3 ro, vec3 rd){\n    \n    // Containers for two objects. Usually there'd be more.\n    vec2[2] q;\n    \n    // The sphere.\n    q[0] = sphereIntersect(ro, rd, sph4);\n \n    // The box tube object, or 4 walls at once, if you prefer. :)\n    vec4 bx = boxIntersect(ro - vec3(0, 1, -.5), rd, vec3(1e8, 2, 3.5));\n    q[1] = vec2(bx.x, 1);\n    boxNrm = bx.yzw; \n   \n    \n    // Returning the object distance, a hit ID (inside surface, etc, and redundant \n    // for this example) and the object ID used for materials and so forth.\n    return q[0].x<q[1].x? vec3(q[0], 0) : vec3(q[1], 1);\n    \n    /*\n    // For more objects, you need to do a little more work.\n    vec3 d = vec3(1e5);\n    \n    for(int i = 0; i<2; i++){\n       if(q[i].x< d.x) d = vec3(q[i], i);\n    }\n        \n    return d;\n    */\n    \n}\n\n// The wall and floor pattern, which is just something quick and effective.\n// Since it's a path traced example, I went with a cliche rounded\n// quarter circle arrangement.\nvec3 distField(vec2 p){\n    \n    // Scale.\n    const float sc = 1.5;\n    \n    // Edge width.\n    const float ew = .05;\n    \n    // Partitioning into cells and providing the local cell ID\n    // and local coordinates.\n    p *= sc;\n    p += .5;\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    \n    // Rounded square.\n    float sq = sBox(p, vec2((1. - ew)/2.), .125);\n    \n    // Randomly rotate each cell.\n    p = rot2(floor(hash21(ip)*8.)*6.2831/4.)*p;\n       \n    // A circle, offset to one of the corners.    \n    float cir = length(p - .5 + ew*.7) - (1. - ew);\n \n    // Producing a rounded circle.\n    float d = max(cir, sq);\n    \n    // Putting a hole in it just to break things up.\n    d = max(d, -(length(p - .07) - .1));\n    \n    //d = abs(d + .1) - .1;\n    \n    // Returning the distance and local cell ID. Note that the \n    // distance has been rescaled by the scaling factor.\n    return vec3(d/sc, ip);\n}\n \n\n\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better version of this that I'll have to find.\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    \n    // Setting a maximum resolution, then upscaling. I picked up this tip when\n    // looking at one of spalmer's examples, here:\n    // https://www.shadertoy.com/view/sdKXD3\n    float maxRes = 540.;\n    float iRes = min(iResolution.y, maxRes);\n    //ivec2 iR = ivec2(fragCoord);\n    //if(iR.y > 0 || iR.x>3){\n    fragColor = vec4(0, 0, 0, 1);\n    vec2 uv2 = abs(fragCoord - iResolution.xy*.5) - iRes/2.*vec2(iResolution.x/iResolution.y, 1.);\n    if(any(greaterThan(uv2, vec2(0)))) return;  // if(uv2.x>0. || uv2.y>0.) return;\n    //} \n        \n    // Screen pixel coordinates.\n    vec2 seed0 = fract(iTime/vec2(111.13, 57.61))*vec2(-.143, .457);\n    vec2 uv0 = (fragCoord - iResolution.xy*.5)/iRes;\n    \n  \n    float FOV = 1.; // FOV - Field of view.\n    vec3 ro = vec3(0, 0, -2);\n    // \"Look At\" position.\n    vec3 lk = ro + vec3(0, 0, .25);\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    // Camera.\n    mat3 mCam = mat3(rgt, up, fwd);\n    mCam *= rot(vec3(0, .05, 0)); \n    mCam *= rot(vec3(0, 0, -sin(iTime/4.)*.25)); \n    \n    \n    vec3 aCol = vec3(0);\n    \n    \n    for(int j = min(0, iFrame); j<sampNum; j++){\n        \n        // Seed value and jitter.\n        seed = uv0 + seed0 + vec2(j*57, j*27)/1321.;\n        vec2 jit = hash22()*2. - 1.;\n        \n        // Jittered UV coordinate.\n        vec2 uv = uv0 - jit/iResolution.y;\n\n        // Using the above to produce the unit ray-direction vector.\n        vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n\n        // Camera position. Initially set to the ray origin.\n        vec3 cam = ro;\n        // Surface postion. Also initially set to the ray origin.\n        vec3 sp = ro;\n\n        vec3 col = vec3(0);\n        \n        // Emissive, throughput and sample colors.\n        vec3 emissive = vec3(0);\n        vec3 through = vec3(1);\n        vec3 sCol = vec3(0);\n        \n        // Fog.\n        float fogD = 1e8;\n       \n        \n        // Just three bounces. More looks better, but the extra randomess\n        // requires more samples. For static scenes, that's not a problem,\n        // but this is a realtime one.\n        for(int i = min(0, iFrame); i<3; i++){\n\n            \n            vec3 scene = intersect(sp, rd); // Scene intersection.\n\n            float t = scene.x; // Scene distance.\n            float retVal = scene.y; // Redundant here, but used when refraction is involved.\n            float id = scene.z;// Object ID.\n            \n            // Set the fog distance on the first pass.\n            if(i==0) fogD = t;\n\n            sp += rd*t; // Advance the ray position.\n\n  \n            if(t<1e8){\n\n                \n                vec3 sn = getNorm(sp, id); // Normal.\n\n                vec3 oCol = vec3(0); // Object color.\n\n                emissive = vec3(0);\n                float rough = .9;\n\n               \n                if(id<.5) { \n                   \n                    // The sphere.\n                    oCol = vec3(1); \n                    \n                    // Texture position. Rotating the texture instead of the sphere\n                    // is cheating, but we can get away with it here.\n                    vec3 tSp = sp - sph4.xyz;\n                    tSp.xz *= rot2(-iTime/2.);\n                    tSp.xy *= rot2(-3.14159/6.);\n\n                    // Texturing the sphere with an icosahedral mapping.\n                    //\n                    // Obtaining the local cell coordinates and spherical coordinates\n                    // for the icosahedron cell.\n                    vec3[3] gV, gVID;\n\n                    const float rad = .5;\n                    vec3 lq = getIcosTri(tSp, gVID, rad);\n\n                    gV[0] = sphericalToWorld(gVID[0]); \n                    gV[1] = sphericalToWorld(gVID[1]);\n                    gV[2] = sphericalToWorld(gVID[2]); \n                    \n                    // The cell center, which doubles as a cell ID,\n                    // due to its uniqueness.\n                    vec3 ctr = normalize((gV[0] + gV[1] + gV[2]))*rad;\n \n                    // Sphere triangles. \n                    mat3 edge = mat3(cross(gV[0], gV[1]), cross(gV[1], gV[2]), cross(gV[2], gV[0]));\n                    vec3 ep = (normalize(lq)*edge)/length(gV[0] - gV[1]);  \n                    float tri = smax(smax(ep.x, ep.y, .07), ep.z, .07) + .025;\n                    tri = max(tri, -(length(lq - ctr) - .05));\n                    //tri = abs(tri + .01) - .02;\n \n                    // Object color, random for each triangle.\n                    vec3 dCol = mix(vec3(1, .4, .2), vec3(1), hash31(ctr + .02));\n \n                    // Random blinking.\n                    float rndV = hash31(ctr + .08);\n                    rndV = sin(rndV*6.2831 + iTime)*.5 + .5;\n                    rndV = smoothstep(.25, .75, sin(rndV*6.2831 + iTime)*.5 + .5);\n                    //\n                    dCol = mix(dCol/16., dCol*4., rndV);\n\n                    // Emissivity.\n                    emissive = mix(emissive, dCol, 1. - smoothstep(0., .005, tri));\n                    \n                    // Roughness.\n                    //rough = .1;\n                    rough = mix(.1, .9, 1. - smoothstep(0., .005, tri));\n               \n               }\n               else {\n\n                   \n                    // Producing a wall and floor pattern, coloring it, and using\n                    // parts to act as emitters.\n                    \n                    // Back wall or not.\n                    float sgn = (abs(sn.z)>.5)? 1. : -1.;\n                    \n                    // UV coordinates for the walls and floors.\n                    vec2 uv = sgn>.5? sp.xy : abs(sn.x)>.5? sp.yz : sp.xz;\n\n                    // Distance field pattern:\n                    // Returns the distance field and cell ID.\n                    vec3 d3 = distField(uv);\n \n                    // Random color.\n                    vec3 dCol = mix(vec3(1, .4, .2), vec3(1), hash21(d3.yz));\n\n                    // Render the pattern on the walls, or the reverse on the floor and ceiling.\n                    oCol = mix(vec3(.25), vec3(.5), 1. - smoothstep(0., .005, sgn*(d3.x + .02)));\n                    //sgn*(abs((d3.x + .02+.02)) - .035)\n                    \n\n                    // Pattern based emissivity -- It doesn't always have to be object based.\n                    emissive = mix(emissive, dCol*2., 1. - smoothstep(0., .01, d3.x + .02));\n                    \n                    // Random blinking.\n                    float rnd = hash21(d3.yz + .43);\n                    rnd = smoothstep(.9, .97, sin(rnd*6.2831 + iTime)*.5 + .5);\n                    \n                    // Ramping up the emissivity in tune with the blinking lights.\n                    if(sgn>.5) emissive = mix(emissive/128., emissive, rnd);\n                    else emissive = emissive/128.;\n\n                    // Turn off the wall lights.\n                    //emissive *= 0.;\n                  \n                }\n               \n                \n                // Tweaking the color and emissive color values a bit.\n                oCol = mix(oCol, oCol.xzy, clamp(sp.y - 1., 0., 1.));  \n                emissive = mix(emissive, emissive.xzy, clamp(sp.y - 1., 0., 1.)); \n                emissive = clamp(emissive*vec3(1, .7, .6), 0., 20.);\n\n                //emissive = emissive.zyx; \n                // Applying some fog, if necessary. You don't actually see this, but\n                // I want it there for completeness.\n                emissive = mix(vec3(0), emissive, 1./(1. + fogD*fogD*.02));\n\n\n\n\n                \n                // I definitely like the more natural way in which colors are applied\n                // when rendering this way. We only add surface color when it's been\n                // hit by a ray that has visited a light source at some point.\n                sCol += emissive*through;\n                // Applying this bounce's color to future bounces. For instance, if we\n                // hit a pink emitter then hit another surface later, that surface will\n                // incorporate a bit of pink into it.\n                through *= oCol;\n \n\n                vec3 ref = reflect(rd, sn); // Purely reflected vector.\n                vec3 rrd = cosDir(0., sn); // Random half hemisphere vector.\n\n                // Mimicking surface inconsistancies with fuzzy reflections.\n                // Rougher surfaces have a greater chance of randomly reflecting at any direction\n                // and smoother surfaces are more likely to purely reflect.\n                float rChance = step(rough, hash21(uv + vec2(i*277, j*113) + fract(iTime*.977 + .137)));\n                rd = (mix(rrd, ref, rChance));\n\n\n                sp += sn*1e-6;\n                //rd = ref; // Pure reflection override. Not as effective at all.\n\n            } \n            \n            \n             if(aCol.x>1e5) break; // Attempting to reduce compile time. \n        }\n        \n\n        // Tone mapping can be helpful in bringing the extremely high values\n        // down to an acceptable range, but I didn't find it necessary here.\n        //sCol = Uncharted2Tonemap(vec4(sCol, 1)).xyz; \n        \n        // Accumulate the sample color.\n        aCol += sCol;\n        \n        if(sCol.x>1e5) break; // Attempting to reduce compile time.\n        \n        \n    }\n    \n    // Average color over all samples.\n    aCol /= float(sampNum);\n    \n   \n    /////\n    \n\n    \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./blendNum; \n    fragColor = mix(preCol, vec4(clamp(aCol, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    //fragColor = vec4(max(aCol, 0.), 1);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lySDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 649, 1045]], "test": "untested"}
{"id": "7dXyD7", "name": "5_5_bool", "author": "tomoe", "description": "sample code\nBoolean operation of noises", "tags": ["ch5"], "likes": 2, "viewed": 206, "published": 3, "date": "1642162766", "time_retrieved": "2024-07-30T17:09:58.663760", "image_code": "int channel;\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n//end pnoise\n\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * (vnoise21(freq * p) - 0.5);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat base21(vec2 p){\n    return mod(iTime, 20.0) < 10.0 ?\n    fbm21(p, 0.5) : \n    pnoise21(p);\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        val = base21(p + g * vec2(cos(TAU * val), sin(TAU * val)));\n    }\n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    vec2 f = vec2(warp21(pos, 1.0), warp21(pos + 10.0, 1.0));\n    f -= 0.5;\n    vec4 x;\n    if (channel == 0){\n        bvec2 b = bvec2(step(f, vec2(0)));\n        x = vec4(b[0] && b[1], \n        b[0] && !b[1],\n        !b[0] && b[1],\n        !(b[0] || b[1])\n        );\n    } else {\n        x = vec4(max(f[0], f[1]),\n        max(f[0], -f[1]), \n        max(-f[0], f[1]), \n        -min(f[0], f[1]));\n        x = step(x, vec4(0.0)\n        );\n    }\n    vec3[4] col4 = vec3[](\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1),\n        vec3(1, 1, 0)\n    );\n    for (int i = 0; i < 4; i++){\n        fragColor.rgb += x[i] * col4[i];\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 222, 222, 321], [322, 322, 345, 345, 458], [459, 459, 482, 482, 583], [584, 584, 606, 606, 689], [690, 690, 711, 711, 797], [798, 798, 819, 819, 905], [906, 906, 926, 926, 1008], [1009, 1009, 1029, 1029, 1111], [1496, 1511, 1547, 1547, 1847], [2234, 2234, 2263, 2263, 2485], [2486, 2486, 2507, 2507, 2584], [2585, 2585, 2615, 2615, 2761]], "test": "untested"}
{"id": "sdXyD7", "name": "5_4_blending", "author": "tomoe", "description": "sample code\nblending colors", "tags": ["ch5"], "likes": 4, "viewed": 233, "published": 3, "date": "1642162658", "time_retrieved": "2024-07-30T17:09:59.482571", "image_code": "int channel;\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n//end pnoise\n\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * (vnoise21(freq * p) - 0.5);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat base21(vec2 p){\n    return mod(iTime, 20.0) < 10.0 ?\n    fbm21(p, 0.5) : \n    pnoise21(p);\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        val = base21(p + g * vec2(cos(TAU * val), sin(TAU * val)));\n    }\n    return val;\n}\nvec3 blend(float a, float b){\n    float time = abs(mod(0.1 * iTime, 2.0) - 1.0);\n    vec3[2] col2;\n    col2[0] = vec3(a, a, 1);\n    col2[1] = vec3(0, b, b);\n    return channel == 0 ? mix(col2[0], col2[1], time):\n        mix(col2[0], col2[1], smoothstep(0.5 - 0.5 * time, 0.5 + 0.5 * time, b / (a + b)))\n    ;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    float a = warp21(pos, 1.0);\n    float b = warp21(pos + 10.0, 1.0);\n    fragColor.rgb = blend(a, b);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 222, 222, 321], [322, 322, 345, 345, 458], [459, 459, 482, 482, 583], [584, 584, 606, 606, 689], [690, 690, 711, 711, 797], [798, 798, 819, 819, 905], [906, 906, 926, 926, 1008], [1009, 1009, 1029, 1029, 1111], [1496, 1511, 1547, 1547, 1847], [2234, 2234, 2263, 2263, 2485], [2486, 2486, 2507, 2507, 2584], [2585, 2585, 2615, 2615, 2761], [3073, 3073, 3127, 3127, 3403]], "test": "untested"}
{"id": "7dfcW7", "name": "5_3_conversion", "author": "tomoe", "description": "sample code\nimage conversion\n(up left) S-shaped tone-mapping curve (up center) gamma correlation (up right) solarization\n(down left) original (down center) binarization (down right) posterization", "tags": ["ch5"], "likes": 3, "viewed": 243, "published": 3, "date": "1642162392", "time_retrieved": "2024-07-30T17:10:00.254507", "image_code": "ivec2 channel;\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n//end pnoise\n\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * (vnoise21(freq * p) - 0.5);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat base21(vec2 p){\n    return mod(iTime, 20.0) < 10.0 ?\n    fbm21(p, 0.5) : \n    pnoise21(p);\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        val = base21(p + g * vec2(cos(TAU * val), sin(TAU * val)));\n    }\n    return val;\n}\nfloat converter(float v){\n    float time = abs(mod(0.1 * iTime, 2.0) - 1.0);\n    float n = floor(8.0 * time);\n    return channel == ivec2(1, 0) ? step(time, v) : \n        channel == ivec2(2, 0) ? (floor(n * v) + step(0.5, fract (n * v))) / n :\n        channel == ivec2(0, 1) ? smoothstep(0.5 * (1.0 - time), 0.5 * (1.0 + time), v): \n        channel == ivec2(1, 1) ? pow(v, 2.0 * time) : \n        channel == ivec2(2, 1) ? 0.5 * sin(2.0 *  TAU * v +  iTime) + 0.5 :\n        v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = ivec2(vec2(3, 2) * fragCoord.xy / iResolution.xy);\n    pos = 10.0 * pos + iTime;\n    fragColor.rgb = vec3(converter(warp21(pos, 1.0)));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 224, 224, 323], [324, 324, 347, 347, 460], [461, 461, 484, 484, 585], [586, 586, 608, 608, 691], [692, 692, 713, 713, 799], [800, 800, 821, 821, 907], [908, 908, 928, 928, 1010], [1011, 1011, 1031, 1031, 1113], [1498, 1513, 1549, 1549, 1849], [2236, 2236, 2265, 2265, 2487], [2488, 2488, 2509, 2509, 2586], [2587, 2587, 2617, 2617, 2763], [2764, 2764, 2789, 2789, 3240], [3242, 3242, 3296, 3296, 3534]], "test": "untested"}
{"id": "7sXcW7", "name": "5_2_warpRot", "author": "tomoe", "description": "sample code\ndomain warping with rotational warping direction\n(left) fbm base (right) Perlin noise base", "tags": ["ch5"], "likes": 4, "viewed": 240, "published": 3, "date": "1642161957", "time_retrieved": "2024-07-30T17:10:01.195989", "image_code": "int channel;\nconst float TAU = 6.2831853;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n//end pnoise\n\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * (vnoise21(freq * p) - 0.5);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat base21(vec2 p){\n    return channel == 0 ? fbm21(p, 0.5) : \n        pnoise21(p);\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        val = base21(p + g * vec2(cos(TAU * val), sin(TAU * val)));\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    fragColor = vec4(vec3(warp21(pos, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 194, 194, 293], [294, 294, 317, 317, 430], [431, 431, 454, 454, 555], [556, 556, 578, 578, 661], [662, 662, 683, 683, 769], [770, 770, 791, 791, 877], [878, 878, 898, 898, 980], [981, 981, 1001, 1001, 1083], [1468, 1483, 1519, 1519, 1819], [2206, 2206, 2235, 2235, 2457], [2458, 2458, 2479, 2479, 2545], [2546, 2546, 2576, 2576, 2722], [2723, 2723, 2777, 2777, 2977]], "test": "untested"}
{"id": "ssXcW7", "name": "5_1_warp", "author": "tomoe", "description": "sample code\ndomain warping\n(left) fbm base (right) Perlin noise base", "tags": ["ch5"], "likes": 3, "viewed": 270, "published": 3, "date": "1642161818", "time_retrieved": "2024-07-30T17:10:01.985877", "image_code": "int channel;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n//end pnoise\n\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * (vnoise21(freq * p) - 0.5);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat base21(vec2 p){\n    return channel == 0 ? fbm21(p, 0.5): \n        pnoise21(p);\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        val = base21(p + g * val);\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    pos = 10.0 * pos;\n    float g = abs(mod(iTime, 10.0) - 5.0);\n    fragColor = vec4(vec3(warp21(pos, g)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 264], [265, 265, 288, 288, 401], [402, 402, 425, 425, 526], [527, 527, 549, 549, 632], [633, 633, 654, 654, 740], [741, 741, 762, 762, 848], [849, 849, 869, 869, 951], [952, 952, 972, 972, 1054], [1439, 1454, 1490, 1490, 1790], [2177, 2177, 2206, 2206, 2428], [2429, 2429, 2450, 2450, 2515], [2516, 2516, 2546, 2546, 2659], [2660, 2660, 2714, 2714, 2947]], "test": "untested"}
{"id": "7dXcW7", "name": "5_0_fbm", "author": "tomoe", "description": "sample code\nfractional Brownian motion\n(left) value noise base  (right) Perlin noise base", "tags": ["ch5"], "likes": 1, "viewed": 217, "published": 3, "date": "1642161674", "time_retrieved": "2024-07-30T17:10:02.878491", "image_code": "int channel;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n//end pnoise\n\nfloat base21(vec2 p){\n    return channel == 0 ? vnoise21(p) - 0.5 : \n        pnoise21(p) - 0.5;\n}\n\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * base21(freq * p);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    float g = abs(mod(0.2 * iTime, 2.0) - 1.0);\n    fragColor = vec4(vec3(fbm21(pos, g)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 264], [265, 265, 288, 288, 401], [402, 402, 425, 425, 526], [527, 527, 549, 549, 632], [633, 633, 654, 654, 740], [741, 741, 762, 762, 848], [849, 849, 869, 869, 951], [952, 952, 972, 972, 1054], [1439, 1454, 1490, 1490, 1790], [2177, 2177, 2198, 2198, 2274], [2276, 2276, 2305, 2305, 2517], [2518, 2518, 2572, 2572, 2817]], "test": "untested"}
{"id": "ssfcWM", "name": "2d Colorful Clouds", "author": "ersh", "description": "2d Colorful Clouds", "tags": ["procedural", "2d", "fractal", "cloud", "fire", "generated"], "likes": 1, "viewed": 320, "published": 3, "date": "1642158420", "time_retrieved": "2024-07-30T17:10:03.905744", "image_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define OUTPUT_AVG     0    // Average 4 buffers or use only one\n#define SMOOTH         1    // Filter output: 0=no; 1=slightly; 2=more\n#define WARP           1\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2. + V( 0.0,  0.0)*8. + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 20.; \\\n//EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y) + \\\n//          V(-s.x,  0.0) + V( 0.0,  0.0)*2.) / 5.; \\\n// EOM\n//#define AVG \\\n//  return (V(0.0, -s.y) + V(-s.x, 0.0) + V(s.x, 0.0) + V(0.0, s.y))/4.; \\\n// EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//EOM\n//#define AVG \\\n//  vec3 avg = \\\n//         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//  vec3 pt = V(0.0, 0.0); \\\n//  float diff = distance(avg, pt); \\\n//  return mix(pt, avg, smoothstep(0.0, 1.0, diff*1.5)); \\\n// EOM\n#define min2(a,b)                       vec3(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z))\n#define min4(a1,a2,a3,a4)               min2(min2(a1,a2),min2(a3,a4))\n#define min8(a1,a2,a3,a4,b1,b2,b3,b4)   min2(min4(a1,a2,a3,a4),min4(b1,b2,b3,b4))\n#define max2(a,b)                       vec3(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z))\n#define max4(a1,a2,a3,a4)               max2(max2(a1,a2),max2(a3,a4))\n#define max8(a1,a2,a3,a4,b1,b2,b3,b4)   max2(max4(a1,a2,a3,a4),max4(b1,b2,b3,b4))\n#define AVG \\\n  vec3 mn = min8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  vec3 mx = max8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  vec3 avg = \\\n         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n  vec3 pt = V(0.0, 0.0); \\\n  float minmaxdiff = clamp(distance(mn,mx), 0.01, 0.67); \\\n  float diff = distance(avg, pt); \\\n  return mix(pt, avg, smoothstep(0.0, 1.0, diff / minmaxdiff)); \\\n// EOM\n\n#define T(a, b)  texture(a, fract(b))\n\n#define V(X,Y)   T(iChannel0, c + vec2(X, Y)).rgb\nvec3 avg0(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   T(iChannel1, c + vec2(X, Y)).rgb\nvec3 avg1(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   T(iChannel2, c + vec2(X, Y)).rgb\nvec3 avg2(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   T(iChannel3, c + vec2(X, Y)).rgb\nvec3 avg3(in vec2 c, in vec2 s) { AVG }\n#undef V\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if WARP\n  float size = iResolution.x / (25.0 + pow(sin(iTime/5.5),9.)*10.);\n  float angle = iTime / 25.0;\n  float kx = sin(iTime/10.)/(iResolution.x*1.3*(1.2-pow(sin(iTime/15.),5.)));\n  float ky = pow(sin(iTime/14.),3.)/(iResolution.x*1.3*(1.16-pow(sin(iTime/22.),7.)));\n  fragCoord = fragCoord.xy - iResolution.xy / 2.0;\n  float stretch_x = fragCoord.x - iResolution.x * 1.5 / 2.0 * sin(iTime/11.);\n  float stretch_y = fragCoord.y - iResolution.y * 1.5 / 2.0 * sin(iTime/19.);\n  fragCoord = fragCoord.xy * rotate2d(angle + kx*stretch_x - ky*stretch_y);\n#endif\n\tvec2 uv = fragCoord / iResolution.xy;\n    fragColor.a = 1.0;\n\n#if OUTPUT_AVG\n#if SMOOTH\n    vec2 s = vec2(1., 1.) / iResolution.xy;\n\tfragColor = vec4(\n            (avg0(uv, s) +\n            avg1(uv, s) +\n            avg2(uv, s) +\n            avg3(uv, s)) / 4.\n            , 1.);\n#else\n\tfragColor = vec4(\n            (T(iChannel0,uv).rgb +\n            T(iChannel1,uv).rgb +\n            T(iChannel2,uv).rgb +\n            T(iChannel3,uv).rgb) / 4.\n            , 1.);\n#endif\n\n#else\n\n#if SMOOTH\n    fragColor.rgb = avg0(uv, vec2(1., 1.) / iResolution.xy);\n#else\n    fragColor.rgb = T(iChannel0,uv).rgb;\n#endif\n\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        1     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 60.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 70.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 80.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 241, 274, 274, 450], [3245, 3245, 3269, 3269, 3319], [3321, 3321, 3378, 3378, 4556]], "test": "untested"}
{"id": "NsXcW7", "name": "4_5_periodicNoise", "author": "tomoe", "description": "sample code\nperiodic Perlin noise in polar coordinate ", "tags": ["ch4"], "likes": 2, "viewed": 232, "published": 3, "date": "1642142294", "time_retrieved": "2024-07-30T17:10:04.672694", "image_code": "\n//start xy<->pol\nconst float PI = 3.1415926;\nfloat atan2(float y, float x){\n    return x == 0.0 ? sign(y) * PI / 2.0 : atan(y, x);\n}\nvec2 xy2pol(vec2 xy){\n    return vec2(atan2(xy.y, xy.x), length(xy));\n}\nvec2 pol2xy(vec2 pol){\n    return pol.y * vec2(cos(pol.x), sin(pol.x));\n}\n//end xy<->pol\n\nuint uhash11(uint n){\n    n ^= (n << 1u);\n    n ^= (n >> 1u);\n    n *= 0x456789abu;\n    n ^= (n << 1u);\n    return n * 0x456789abu;\n}\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = (uhash11(uhash11(n.x) + n.y) >> 29);\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat periodicNoise21(vec2 p, float period){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(mod(n + vec2(i, j), period), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gtable3(vec3 lattice, vec3 p){\n    uvec3 n = floatBitsToUint(lattice);\n    uint ind = (uhash11(uhash11(uhash11(n.x) + n.y) + n.z) >> 28);\n    float u = ind < 8u ? p.x : p.y;\n    float v = ind < 4u ? p.y : ind == 12u || ind == 14u ? p.x : p.z;\n    return ((ind & 1u) == 0u? u: -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat periodicNoise31(vec3 p, float period){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = gtable3(mod(n + vec3(i, j, k), period), f - vec3(i, j, k)) * 0.70710678;\n            }\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    pos = 2.0 * pos.xy - vec2(1.0);\n    pos = xy2pol(pos);\n    pos = vec2(5.0 / PI, 5.0) * pos + iTime;\n    fragColor = vec4(periodicNoise21(pos, 10.0));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 76, 76, 133], [134, 134, 155, 155, 205], [206, 206, 228, 228, 279], [296, 296, 317, 317, 429], [430, 430, 466, 466, 783], [1190, 1190, 1226, 1226, 1507], [2105, 2105, 2159, 2159, 2384]], "test": "untested"}
{"id": "fsXcW7", "name": "4_4_pnoise", "author": "tomoe", "description": "sample code\ngradient noise and Perlin noise\n(up left) 3D gradient noise  (up right) 3D Perlin noise\n(down left) 2D gradient noise (down right)  2D Perlin noise ", "tags": ["ch4"], "likes": 1, "viewed": 257, "published": 3, "date": "1642142181", "time_retrieved": "2024-07-30T17:10:05.499483", "image_code": "ivec2 channel;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start gnoise\nfloat gnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2[4] g;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            g[i+2*j] = normalize(2.0 * hash22(n + vec2(i,j)) - vec2(1.0));\n        }\n    }\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = dot(g[i+2*j], f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3[8] g;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                g[i+2*j+4*k] = normalize(2.0 * hash33(n + vec3(i, j, k)) - vec3(1.0));\n            }\n            \n        }\n    }\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = dot(g[i+2*j+4*k], f - vec3(i, j, k));\n            }\n            \n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n//end gnoise\n\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gtable3(vec3 lattice, vec3 p){\n    uvec3 n = floatBitsToUint(lattice);\n    uint ind = uhash33(n).x >> 28;\n    float u = ind < 8u ? p.x : p.y;\n    float v = ind < 4u ? p.y : ind == 12u || ind == 14u ? p.x : p.z;\n    return ((ind & 1u) == 0u? u: -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = gtable3(n + vec3(i, j, k), f - vec3(i, j, k)) * 0.70710678;\n            }\n            \n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n//end pnoise\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos = 10.0 * pos + iTime;\n    channel = ivec2(2.0 * fragCoord.xy / iResolution.xy);\n    float v = channel[0] == 0 ? \n        channel[1] == 0 ? gnoise21(pos) :\n        gnoise31(vec3(pos, iTime)) :\n        channel[1] == 0 ? pnoise21(pos) : \n        pnoise31(vec3(pos, iTime));\n    fragColor.rgb = vec3(v);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 167, 167, 266], [267, 267, 290, 290, 403], [404, 404, 427, 427, 528], [529, 529, 551, 551, 634], [635, 635, 656, 656, 742], [743, 743, 764, 764, 850], [851, 851, 871, 871, 953], [954, 954, 974, 974, 1056], [2448, 2463, 2499, 2499, 2799], [3172, 3172, 3208, 3208, 3457], [4047, 4047, 4101, 4101, 4497]], "test": "untested"}
{"id": "NdXcW7", "name": "4_3_noiseQuality", "author": "tomoe", "description": "sample code\nquality check of bad gradient noise (outlier values are in red)\ngradient direction is limited to \n(left) diagonal  (right) lattice ", "tags": ["ch4"], "likes": 1, "viewed": 190, "published": 3, "date": "1642142121", "time_retrieved": "2024-07-30T17:10:06.275408", "image_code": "int channel;\n\nvec2[4] diag = vec2[](    // 0.70710678 = 1.0 / sqrt(2.0)\n    vec2(0.70710678,0.70710678),\n    vec2(-0.70710678,0.70710678),\n    vec2(0.70710678,-0.70710678),\n    vec2(-0.70710678,-0.70710678)\n);\nvec2[4] axis = vec2[](\n    vec2(1, 0),\n    vec2(-1, 0),\n    vec2(0, 1),\n    vec2(0, -1)\n);\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nfloat gnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            uvec2 m = floatBitsToUint(n + vec2(i, j));\n            uint ind = (uhash22(m).x >> 30);\n            if (channel == 0){\n                v[i+2*j] = dot(diag[ind], f - vec2(i, j));\n            } else {\n                v[i+2*j] = dot(axis[ind], f - vec2(i, j));\n            }\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy / min(iResolution.x, iResolution.y);\n    channel = int(fragCoord.x * 2.0 / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    float v = gnoise21(pos);\n    if (v > 0.85 || v < 0.15){\n        fragColor.rgb = vec3(1.,0.,0.);\n    }   else {\n        fragColor.rgb = vec3(v);\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 441, 441, 554], [1148, 1148, 1202, 1202, 1530]], "test": "untested"}
{"id": "fdXcW7", "name": "4_2_rotNoise", "author": "tomoe", "description": "sample code\nrotational gradient noise\n(left) 2D  (right) 3D", "tags": ["ch4"], "likes": 1, "viewed": 176, "published": 3, "date": "1642142014", "time_retrieved": "2024-07-30T17:10:07.038369", "image_code": "int channel;\nconst float PI = 3.1415926;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n\n//begin rot\nvec2 rot2(vec2 p, float t){\n    t *= PI;\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\n//end rot\n\nfloat rotNoise21(vec2 p, float ang){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            vec2 g = normalize(2.0 * hash22(n + vec2(i,j)) - vec2(1.0));\n            g = rot2(g, ang);\n            v[i+2*j] = dot(g, f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat rotNoise31(vec3 p, float ang){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                vec3 g = normalize(2.0 * hash33(n + vec3(i, j, k)) - vec3(1.0));\n                g = rotZ(g, ang);\n                v[i+2*j+4*k] = dot(g, f - vec3(i, j, k));\n            }\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(fragCoord.x * 2.0 / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    if (channel < 1){\n        fragColor = vec4(rotNoise21(pos, iTime));  //right\n    } else {\n        fragColor = vec4(rotNoise31(vec3(pos, iTime), iTime));\n        \n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 193, 193, 292], [293, 293, 316, 316, 429], [430, 430, 453, 453, 554], [555, 555, 577, 577, 660], [661, 661, 682, 682, 768], [769, 769, 790, 790, 876], [877, 877, 897, 897, 979], [980, 980, 1000, 1000, 1082], [1096, 1108, 1135, 1135, 1224], [1225, 1225, 1252, 1252, 1291], [1292, 1292, 1319, 1319, 1362], [1363, 1363, 1390, 1390, 1429], [2570, 2570, 2624, 2624, 2968]], "test": "untested"}
{"id": "fsfyW7", "name": "4_1_noiseRange", "author": "tomoe", "description": "sample code\nrange of values in HSV color\n(up left) 3D value noise  (up right) 3D gradient noise\n(down left) 2D value noise (down right) 2D gradient noise", "tags": ["ch4"], "likes": 1, "viewed": 190, "published": 3, "date": "1642141925", "time_retrieved": "2024-07-30T17:10:07.800332", "image_code": "ivec2 channel;\n\nvec3 hsv2rgb(in vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\nfloat vnoise31(vec3 p){\n    vec3 n = floor(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = hash31(n + vec3(i, j, k));\n            }\n            \n        }\n    }\n    vec3 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return mix(w[0], w[1], f[2]);\n}\n//end vnoise\n\n//start gnoise\nfloat gnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            vec2 g = normalize(2.0 * hash22(n + vec2(i,j)) - vec2(1.0));\n            v[i+2*j] = dot(g, f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                vec3 g = normalize(2.0 * hash33(n + vec3(i, j, k)) - vec3(1.0));\n                v[i+2*j+4*k] = dot(g, f - vec3(i, j, k));\n            }\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n//end gnoise\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos = 20.0 * pos + iTime;\n    channel = ivec2(2.0 * fragCoord.xy / iResolution.xy);\n    float v;\n    if (channel[0] == 0){\n        if (channel[1] == 0){\n            v = vnoise21(pos);\n        } else {\n            v = vnoise31(vec3(pos, iTime));\n        }\n    } else{\n        if (channel[1] == 0){\n            v = gnoise21(pos);\n        } else {\n            v = gnoise31(vec3(pos, iTime));\n        }\n    }\n    fragColor.rgb = hsv2rgb(vec3(v, 1.0, 1.0));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 40, 40, 177], [308, 308, 329, 329, 428], [429, 429, 452, 452, 565], [566, 566, 589, 589, 690], [691, 691, 713, 713, 796], [797, 797, 818, 818, 904], [905, 905, 926, 926, 1012], [1013, 1013, 1033, 1033, 1115], [1116, 1116, 1136, 1136, 1218], [3201, 3201, 3255, 3255, 3800]], "test": "untested"}
{"id": "NdfyW7", "name": "4_0_gnoise", "author": "tomoe", "description": "sample code\ngradient noise\n(left) 2D  (right) 3D", "tags": ["ch4"], "likes": 1, "viewed": 222, "published": 3, "date": "1642141863", "time_retrieved": "2024-07-30T17:10:08.695937", "image_code": "int channel;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n\nfloat gnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            vec2 g = normalize(2.0 * hash22(n + vec2(i,j)) - vec2(1.0));\n            v[i+2*j] = dot(g, f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                vec3 g = normalize(2.0 * hash33(n + vec3(i, j, k)) - vec3(1.0));\n                v[i+2*j+4*k] = dot(g, f - vec3(i, j, k));\n            }\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(fragCoord.x * 2.0 / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    if (channel < 1){\n        fragColor = vec4(gnoise21(pos));  //left\n    } else {\n        fragColor = vec4(gnoise31(vec3(pos, iTime)));\n        \n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 264], [265, 265, 288, 288, 401], [402, 402, 425, 425, 526], [527, 527, 549, 549, 632], [633, 633, 654, 654, 740], [741, 741, 762, 762, 848], [849, 849, 869, 869, 951], [952, 952, 972, 972, 1054], [2107, 2107, 2161, 2161, 2486]], "test": "untested"}
{"id": "fdfyW7", "name": "3_1_vnoiseGrad", "author": "tomoe", "description": "sample code\nvalue noise derivatives\n(left) cubic interpolation  (right) quintic interpolation", "tags": ["ch3"], "likes": 1, "viewed": 198, "published": 3, "date": "1642141771", "time_retrieved": "2024-07-30T17:10:09.463883", "image_code": "int channel;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    if (channel == 0){\n        f = f * f * (3.0 -2.0 * f); // Hermite interpolation\n    } else {\n        f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); //quintic Hermite interpolation\n    }\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n\nvec2 grad(vec2 p){\n    float eps = 0.001;\n    return 0.5 * (vec2(\n            vnoise21(p + vec2(eps, 0.0)) - vnoise21(p - vec2(eps, 0.0)),\n            vnoise21(p + vec2(0.0, eps)) - vnoise21(p - vec2(0.0, eps))\n    )) / eps;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(fragCoord.x * 2.0 / iResolution.x);\n    pos = 3.0 * pos+iTime;\n    fragColor.rgb = vec3(dot(vec2(1), grad(pos)));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 264], [265, 265, 288, 288, 401], [402, 402, 425, 425, 526], [527, 527, 549, 549, 632], [633, 633, 654, 654, 740], [741, 741, 762, 762, 848], [849, 849, 869, 869, 951], [952, 952, 972, 972, 1054], [1550, 1550, 1568, 1568, 1776], [1777, 1777, 1831, 1831, 2051]], "test": "untested"}
{"id": "NsXyW7", "name": "3_0_vnoise", "author": "tomoe", "description": "sample code\nvalue noise with\n(left) lerp in 2D  (center) Hermitian interpolation in 2D (right) Hermitian interpolation in 3D", "tags": ["ch3"], "likes": 1, "viewed": 229, "published": 3, "date": "1642141711", "time_retrieved": "2024-07-30T17:10:10.313612", "image_code": "int channel;\n\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n\n\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    if (channel == 1){\n        f = f * f * (3.0 -2.0 * f); // Hermite interpolation\n    }\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\nfloat vnoise31(vec3 p){\n    vec3 n = floor(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = hash31(n + vec3(i, j, k));\n            }\n            \n        }\n    }\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Hermite interpolation\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return mix(w[0], w[1], f[2]);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    channel = int(fragCoord.x * 3.0 / iResolution.x);\n    pos = 10.0 * pos + iTime;\n    if (channel < 2){\n        fragColor = vec4(vnoise21(pos));  //right\n    } else {\n        fragColor = vec4(vnoise31(vec3(pos, iTime)));\n        \n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 264], [265, 265, 288, 288, 401], [402, 402, 425, 425, 526], [527, 527, 549, 549, 632], [633, 633, 654, 654, 740], [741, 741, 762, 762, 848], [849, 849, 869, 869, 951], [952, 952, 972, 972, 1054], [1984, 1984, 2038, 2038, 2364]], "test": "untested"}
{"id": "fsXyW7", "name": "2_3_hash2d3d", "author": "tomoe", "description": "sample code\nhash function of\n(up left) 2-in/2-out  (up right) 3-in/3-out\n(down left) 2-in/1-out  (down right) 3-in/1-out\n", "tags": ["ch2"], "likes": 4, "viewed": 307, "published": 3, "date": "1642141633", "time_retrieved": "2024-07-30T17:10:11.183286", "image_code": "ivec2 channel;\n\nconst uint UINT_MAX = 0xffffffffu;\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n    //nesting approach\n    //return float(uhash11(n.x+uhash11(n.y)) / float(UINT_MAX)\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n    //nesting approach\n    //return float(uhash11(n.x+uhash11(n.y+uhash11(n.z))) / float(UINT_MAX)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float time = floor(60.* iTime);\n    vec2 pos = fragCoord.xy + time;\n    channel = ivec2(fragCoord.xy * 2.0 / iResolution.xy);\n    if (channel[0] == 0){ //left\n        if (channel[1] == 0){\n            fragColor.rgb = vec3(hash21(pos));\n        } else {\n            fragColor.rgb = vec3(hash22(pos), 1.0);\n        }\n    } else {    //right\n        if (channel[1] == 0){\n            fragColor.rgb = vec3(hash31(vec3(pos, time)));\n        } else {\n            fragColor.rgb = hash33(vec3(pos, time));\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 156, 156, 269], [270, 270, 293, 293, 394], [395, 395, 415, 415, 497], [498, 498, 518, 518, 600], [601, 601, 622, 622, 794], [795, 795, 816, 816, 1001], [1003, 1003, 1057, 1057, 1600]], "test": "untested"}
{"id": "NdXyW7", "name": "2_2_hash1d", "author": "tomoe", "description": "sample code\nhash function of 1-in and 1-out", "tags": ["ch2"], "likes": 2, "viewed": 245, "published": 3, "date": "1642141592", "time_retrieved": "2024-07-30T17:10:11.959212", "image_code": "uint k = 0x456789abu;\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << 1);\n    n ^= (n >> 1);\n    n *= k;\n    n ^= (n << 1);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float time = floor(60.0 * iTime);\n    vec2 pos = fragCoord.xy + time;\n    fragColor.rgb = vec3(hash11(pos.x));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 78, 78, 167], [168, 168, 190, 190, 273], [274, 274, 328, 328, 468]], "test": "untested"}
{"id": "fdXyW7", "name": "2_1_binary", "author": "tomoe", "description": "sample code\nvisualization of binary data", "tags": ["ch2"], "likes": 2, "viewed": 231, "published": 3, "date": "1642141536", "time_retrieved": "2024-07-30T17:10:12.727159", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    pos *= vec2(32.0, 9.0);\n    uint[9] a = uint[](\n        uint(iTime),\n        0xbu,\n        9u,\n        0xbu ^ 9u,\n        0xffffffffu,\n        0xffffffffu + uint(iTime),\n        floatBitsToUint(floor(iTime)),\n        floatBitsToUint(-floor(iTime)),\n        floatBitsToUint(11.5625)\n    );\n    if (fract(pos.x) < 0.1) {\n        if (floor(pos.x) == 1.0) {\n            fragColor = vec4(1, 0, 0, 1);\n        } else if (floor(pos.x) == 9.0) {\n            fragColor = vec4(0, 1, 0, 1);\n        } else {\n            fragColor = vec4(0.5);\n        }\n    } else if (fract(pos.y) < 0.1) {\n        fragColor = vec4(0.5);\n    } else {\n        uint b = a[int(pos.y)]; \n        b = (b << uint(pos.x)) >> 31;\n        fragColor = vec4(vec3(b), 1.0); \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NsfcDM", "name": "2_0_legacy", "author": "tomoe", "description": "sample code\nlegacy noise made from sin()", "tags": ["ch2"], "likes": 1, "viewed": 200, "published": 3, "date": "1642141378", "time_retrieved": "2024-07-30T17:10:13.517046", "image_code": "int channel;\nfloat fractSin11(float x){ // 1 in, 1 out\n    return fract(1000.0 * sin(x));\n}\nfloat fractSin21(vec2 xy){ // 2 in, 1 out\n    return fract(sin(dot(xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy;\n    pos += floor(60.0 * iTime);\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    if (channel == 0){ //left\n        fragColor = vec4(fractSin11(pos.x));\n    } else { //right\n        fragColor = vec4(fractSin21(pos.xy / iResolution.xy));\n    }\n    fragColor.a = 1.0; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 39, 54, 91], [92, 92, 118, 133, 206], [207, 207, 262, 262, 568]], "test": "untested"}
{"id": "sslcD4", "name": "Robot Creation", "author": "wyatt", "description": "Belabored walking of a dumb robot :/ Maybe it will get smarter on the next iteration", "tags": ["physics"], "likes": 14, "viewed": 366, "published": 3, "date": "1642132239", "time_retrieved": "2024-07-30T17:10:14.283996", "image_code": "// Fork of \"Brick Wall Physics\" by wyatt. https://shadertoy.com/view/sdsyD8\n// 2022-01-13 22:23:09\nMain\n    //if (iFrame%4==0)discard;\n    vec4 pos = A(POS);\n    Q = .2*max(sign(sin((pos.x+U.xxxx)/R.x*10.)-.999),0.);\n    U.x += pos.x-.5*R.x;\n    U.y -= .1*R.y;\n    Q += smoothstep(2.,1.,abs(U.y));\n    Q += .1*sin(U.x/R.x+vec4(1,2,3,4));\n    vec4 vel = A(VEL);\n    vec4 ang = A(ANG);\n    vec4 le = pos;\n    vec4 ri = pos;\n    float d = 1e9;\n    for (int i = 0; i < 3; i++) {\n        {\n            d = map(U,ri,W);\n            Q += vec4(1)*smoothstep(2.,0.,abs(d));\n            vec2 pivot = ri.xy + vec2(1,-1)*W*ei(ri.z);\n            ri.xy += vec2(2,0)*W*ei(ri.z);\n            ri.xy -= pivot;\n            ri.xy *= ei(ang[i]);\n            ri.z  += ang[i];\n            ri.xy += pivot;\n        }\n        {\n            \n            d = map(U,le,W);\n            Q += vec4(1)*smoothstep(2.,0.,abs(d));\n            vec2 pivot = le.xy + vec2(-1,-1)*W*ei(le.z);\n            le.xy += vec2(-2,0)*W*ei(le.z);\n            le.xy -= pivot;\n            le.xy *= ei(-ang[2+i]);\n            le.z  += -ang[2+i];\n            le.xy += pivot;\n        }\n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I; vec4 M;\n#define A(U) texture(iChannel0,(U)/R)\n#define pi 3.14159265359\n#define Main void mainImage(out vec4 Q, in vec2 U) {R=iResolution.xy;I=iFrame;M=iMouse;T=float(I)/60.;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define an(a) vec2(cos(a),sin(a))\n\n#define N 3.\n#define dt .2\n#define W (.07*R)\n\n#define F1 vec2(2.+1.5*cos(-4.*(T+z/1200.)),-3.-1.5*sin(-4.*(T+z/1200.)))\n#define F2 vec2(2.+1.5*cos(3.*(T+z/1200.)),-3.-1.5*sin(3.*(T+z/1200.)))\n\n#define POS vec2(.5,2.5)\n#define VEL vec2(.5,1.5)\n#define ANG vec2(0.5,.5)\n\nvec2 velo (vec2 u, vec4 p, vec4 v) {\n    vec2 w = u.xy-p.xy;\n    if (length(w)>0.) w = vec2(-w.y,w.x);\n    return v.xy + w*v.z;\n}\n\nfloat map ( vec2 p, vec4 a, vec2 b )\n{ //iquilezles.org/articles/distfunctionsl\n  p = (p-a.xy)*ei(-a.z);\n  vec2 q = (abs(p) - b);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0)-4.;\n}\n", "buffer_a_code": "\nMain\n    if (U.x>4.||U.y>4.)discard;\n    vec4 pos = A(POS);\n    vec4 vel = A(VEL);\n    vec4 ang = A(ANG);\n    for (float z = 0.; z <40.; z++) {\n        vec4 ong = ang;\n        vec4 f = vec4(0);\n        {\n            vec2 pivot = pos.xy + vec2(1,-1)*W*ei(pos.z);\n            vec2 Y = pivot.xy+F1*W;\n            vec2 r = Y-pivot.xy;\n            if (length(r)>4.*W.x) r = 4.*W.x*normalize(r);\n            float theta = atan(r.y,r.x);\n            float l     = length(r);\n            float t = -acos(.25*l/W.x);\n            ang.x = theta-t;\n            ang.y = 2.*t;\n        }\n        {\n            vec2 pivot = pos.xy + vec2(-1,-1)*W*ei(pos.z);\n            vec2 Y = pivot.xy+F2*W;\n            vec2 r = Y-pivot.xy;\n            if (length(r)>4.*W.x) r = 4.*W.x*normalize(r);\n            float theta = atan(r.y,r.x);\n            float l     = length(r);\n            float t = -acos(.25*l/W.x);\n            ang.z = theta-t;\n            ang.w = 2.*t;\n        }\n        vec4 dang = ang-ong;\n        vec4 le = pos;\n        vec4 ri = pos;\n        float h = 0.;\n        for (int i = 0; i < 3; i++) {\n            {\n                vec2 pivot = ri.xy + vec2(1,-1)*W*ei(ri.z);\n                for (int x = 0; x <= 1; x++)\n                for (int y = 0; y <= 1; y++)\n                {\n                    vec2 v = ri.xy+(vec2(x,y)*2.-1.)*W*ei(ri.z);\n                    if (v.y<0.) {\n                        vec2 r = v-pos.xy;\n                        if (length(r)>0.) {\n                            vec2 dv = velo(v,pos,vel);\n                            vec2 im = vec2(0,1)-dv;\n                             f.z -= dot(r,vec2(-im.y,im.x))/(10.*W.x*W.y);\n                             f.xy += im*abs(dot(normalize(r),im));\n                             f.x += (v-pivot).y*dang[i];\n                             h++;\n                        }\n                    }\n                }\n                ri.xy += vec2(2,0)*W*ei(ri.z);\n                ri.xy -= pivot;\n                ri.xy *= ei(ang[i]);\n                ri.z  += ang[i];\n                ri.xy += pivot;\n            }\n            {\n                vec2 pivot = le.xy + vec2(-1,-1)*W*ei(le.z);\n                for (int x = 0; x <= 1; x++)\n                for (int y = 0; y <= 1; y++)\n                {\n                    vec2 v = le.xy+(vec2(x,y)*2.-1.)*W*ei(le.z);\n                    if (v.y<0.) {\n                        vec2 r = v-pos.xy;\n                        if (length(r)>0.) {\n                            vec2 dv = velo(v,pos,vel);\n                            vec2 im = vec2(0,1)-dv;\n                             f.z -= dot(r,vec2(-im.y,im.x))/(10.*W.x*W.y);\n                             f.xy += im*abs(dot(normalize(r),im));\n                             f.x += -(v-pivot).y*dang[i+2];\n                             h++;\n                        }\n                    }\n                }\n                le.xy += vec2(-2,0)*W*ei(le.z);\n                le.xy -= pivot;\n                le.xy *= ei(-ang[2+i]);\n                le.z  += -ang[2+i];\n                le.xy += pivot;\n            }\n        }\n\n\n        vel.y -= 3e-3;\n        if (h>0.) f /= h;\n        vel += dt*f;\n        pos += dt*(vel);\n    }\n   if (length(U-POS)<.5) Q = I<1?vec4(.5*R,0,0):pos;\n   else\n   if (length(U-VEL)<.5) Q = I<1?vec4(0):vel;\n   else\n   if (length(U-ANG)<.5) Q = ang;//A(THA);\n   else\n   discard;\n   \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslcD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sssyWN", "name": "Spiral Arcs - distance", "author": "iq", "description": "EXACT distance to a spiral made of circular arcs", "tags": ["2d", "sdf", "circle", "distance", "arcs"], "likes": 30, "viewed": 864, "published": 3, "date": "1642124885", "time_retrieved": "2024-07-30T17:10:15.056929", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a spiral made of circular arcs\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdSpiral( in vec2 p, float w, in float h )\n{\n    // base point\n    float d = length(p);\n    // 8 arcs\n    for( int i=0; i<8; i++ )\n    {\n        p.x -= w;\n        if( p.x<0.0 && p.y>0.0 ) d = min( d, abs(length(p)-w) );\n        p.y -= w;\n        p = vec2(-p.y,p.x);\n        w *= h;\n    }\n    // tip point\n    return min( d, length(p) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    \n    float w = 1.0;\n    float h = 0.5+0.5*sin((iTime-10.0)*0.3+2.90327519);\n    //float h = (sqrt(5.0)-1.0)/2.0; // approximated golden spiral\n    \n    p  *= 1.15;\n    px *= 1.15;\n    \n    p -= vec2(-0.8,-0.3);\n    m -= vec2(-0.8,-0.3);\n\n    float d = sdSpiral(p,w,h);\n\n   \n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(160.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdSpiral(m,w,h);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssyWN.jpg", "access": "api", "license": "mit", "functions": [[1255, 1255, 1305, 1323, 1599], [1602, 1602, 1659, 1659, 2592]], "test": "untested"}
{"id": "7dsyD4", "name": "1d gold gradient", "author": "CWBudde1", "description": "Just a simple 1d gold gradient", "tags": ["simple", "gradient", "1d", "gold"], "likes": 3, "viewed": 206, "published": 3, "date": "1642121719", "time_retrieved": "2024-07-30T17:10:15.907655", "image_code": "vec3 goldGradient(float t) {\n\tvec3 c = vec3(0.9923842, 1.0102498, 0.106);\n\tc.r += -0.7307684 / (1.0 + exp(7.55021*t));\n\tc.g += -1.3544996 / (1.0 + exp(2.61615*t));\n\tc.b += (0.054*t + 0.295) * t;\n\treturn clamp(c, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 oFragColor, in vec2 iFragCoord) {\n    oFragColor.rgb = goldGradient(iFragCoord.x / iResolution.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 224], [226, 226, 283, 283, 350]], "test": "untested"}
{"id": "sslyWN", "name": "Rich Emergence - MNCA", "author": "SlackermanzCA", "description": "Continuous Multiple Neighborhood Cellular Automata", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 3, "viewed": 380, "published": 3, "date": "1642121111", "time_retrieved": "2024-07-30T17:10:17.138364", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   3060246268u, 1738652270u, 1860951328u, 2516787966u, \n    613987017u, 775395886u, 4280169843u, 148624400u, \n    2137189529u, 264381586u, 4101169455u, 1994322064u, \n    2818505514u, 2251564764u, 2645029938u, 1458108844u, \n    2072157747u, 1168555589u, 3671807972u, 1833414612u, \n    3461305943u, 3138647863u, 2727543091u, 1308884491u, \n    964217604u, 500229995u, 2212719393u, 482016387u, \n    2983380564u, 678753835u, 328940010u, 1830820096u, \n    878175310u, 821649567u, 610488564u, 1150301103u, \n    149010126u, 1003328336u, 635271555u, 3640019719u, \n    1201184467u, 775316069u, 2145230570u, 805788811u, \n    3010664919u, 534543614u, 909992471u, 952238036u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1034091979u, 1126448937u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nstruct ConvData {\n\tvec4 \tvalue;\n\tfloat \ttotal;\n};\n\n\nConvData ring( float r ) {\n\n\tconst float psn = 32768.0;\n\n\tfloat tot = 0.0;\n\tvec4  val = vec4(0.0,0.0,0.0,0.0);\n\n\tfloat sq2\t= sqrt(2.0);\n\n\tfloat o_0 = r + 0.5;\n\tfloat o_1 = sq2 * o_0;\n\tfloat o_2 = o_1 / 2.0;\n\tfloat o_3 = sqrt( o_0*o_0 - r*r );\n\tfloat o_4 = o_2 - ( floor(o_2) + 0.5 );\n\tfloat o_5 = floor( o_2 ) + floor( o_4 );\n\n\tfloat i_0 = r - 0.5;\n\tfloat i_1 = sq2 * i_0;\n\tfloat i_2 = i_1 / 2.0;\n\tfloat i_3 = sqrt( i_0*i_0 - r*r );\n\tfloat i_4 = i_2 - ( floor(i_2) + 1.0 );\n\tfloat i_5 = floor( i_2 ) + floor( i_4 );\n\n\tfloat d_0 = ( i_5 ) + 1.0 - ( o_5 );\n\n\tfor(float i = 1.0; i < floor( i_2 ) + 1.0 - d_0; i++) {\n\n\t\tfloat j_0 = sqrt( o_0*o_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_1 = sqrt( i_0*i_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_2 = ( 1.0 - abs( sign ( (floor( i_2 ) + 1.0) - i ) ) );\n\n\t\tfor(float j = floor( j_1 ) + j_2; j < floor( j_0 ); j++) {\n\t\t\tval += floor(gdv(ivec2( i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1), i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1), i), txdata) * psn);\n\t\t\ttot += 8.0 * psn; } }\n\n//\tOrthagonal\n\tval += floor(gdv(ivec2( r, 0), txdata) * psn);\n\tval += floor(gdv(ivec2( 0,-r), txdata) * psn);\n\tval += floor(gdv(ivec2(-r,-0), txdata) * psn);\n\tval += floor(gdv(ivec2(-0, r), txdata) * psn);\n\ttot += 4.0 * psn;\n\n//\tDiagonal\n//\tTODO This is not quite perfect\n\tfloat k_0 = r;\n\tfloat k_1 = sq2 * k_0;\n\tfloat k_2 = k_1 / 2.0;\n\tfloat k_3 = sqrt( k_0*k_0 - r*r );\n\tfloat k_4 = k_2 - ( floor(k_2) + 1.0 );\n\tfloat k_5 = floor( k_2 ) + floor( k_4 );\n\n\tfloat dist = round(k_2);\n\n\tif( sign( o_4 ) == -1.0 ) {\n\t//\tval += gdv(ivec2( (floor(o_5)+1), floor(o_5)+1), txdata);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\ttot += 4.0 * psn; }\n\n\treturn ConvData( val, tot ); }\n\n\nvec4 conv( float r ) {\n\tConvData nh = ring( r );\n\treturn \tnh.value / nh.total; }\n    \nvec4 bitmake(ConvData[MAX_RADIUS] rings, uint bits, uint of) {\n\tvec4  sum = vec4(0.0,0.0,0.0,0.0);\n\tfloat tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings[i].value; tot += rings[i].total; } }\n\treturn sum / tot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tConvData[MAX_RADIUS] nh_rings_m;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) { nh_rings_m[i] = ring(float(i+1u)); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  128.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub[2],  ub[3],\n\t\tub[4],  ub[5],  ub[6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tvec4[12] smnca_res = vec4[12](res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c);\n\n\tvec4 conv1 = conv(1.0);\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n                \n\t\tvec4 nhv = bitmake( nh_rings_m, nb[i/2u], (i & 1u) * 16u );\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 0u) && nhv[cho] <= utp( ur[i], 8u, 1u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * res_c[chm]; }\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 2u) && nhv[cho] <= utp( ur[i], 8u, 3u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * res_c[chm]; } }\n\n\tuvec4 dev_idx = uvec4(0u,0u,0u,0u);\n    \n\tvec4 dev = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < 6u; i++) {\n\t\tvec4 smnca_res_temp = abs(res_c - smnca_res[i]);\n\t\tif(smnca_res_temp[0] > dev[0]) { dev_idx[0] = i; dev[0] = smnca_res_temp[0]; }\n\t\tif(smnca_res_temp[1] > dev[1]) { dev_idx[1] = i; dev[1] = smnca_res_temp[1]; }\n\t\tif(smnca_res_temp[2] > dev[2]) { dev_idx[2] = i; dev[2] = smnca_res_temp[2]; }\n\t\tif(smnca_res_temp[3] > dev[3]) { dev_idx[3] = i; dev[3] = smnca_res_temp[3]; } }\n\n\tres_v[0] = smnca_res[dev_idx[0]][0];\n\tres_v[1] = smnca_res[dev_idx[1]][1];\n\tres_v[2] = smnca_res[dev_idx[2]][2];\n\tres_v[3] = smnca_res[dev_idx[3]][3];\n\n    res_c = ((res_v + (conv1 * (s*2.13333))) / (1.0 + (s*2.13333)))- 0.01 * s;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   3060246268u, 1738652270u, 1860951328u, 2516787966u, \n    613987017u, 775395886u, 4280169843u, 148624400u, \n    2137189529u, 264381586u, 4101169455u, 1994322064u, \n    2818505514u, 2251564764u, 2645029938u, 1458108844u, \n    2072157747u, 1168555589u, 3671807972u, 1833414612u, \n    3461305943u, 3138647863u, 2727543091u, 1308884491u, \n    964217604u, 500229995u, 2212719393u, 482016387u, \n    2983380564u, 678753835u, 328940010u, 1830820096u, \n    878175310u, 821649567u, 610488564u, 1150301103u, \n    149010126u, 1003328336u, 635271555u, 3640019719u, \n    1201184467u, 775316069u, 2145230570u, 805788811u, \n    3010664919u, 534543614u, 909992471u, 952238036u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1034091979u, 1126448937u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nstruct ConvData {\n\tvec4 \tvalue;\n\tfloat \ttotal;\n};\n\n\nConvData ring( float r ) {\n\n\tconst float psn = 32768.0;\n\n\tfloat tot = 0.0;\n\tvec4  val = vec4(0.0,0.0,0.0,0.0);\n\n\tfloat sq2\t= sqrt(2.0);\n\n\tfloat o_0 = r + 0.5;\n\tfloat o_1 = sq2 * o_0;\n\tfloat o_2 = o_1 / 2.0;\n\tfloat o_3 = sqrt( o_0*o_0 - r*r );\n\tfloat o_4 = o_2 - ( floor(o_2) + 0.5 );\n\tfloat o_5 = floor( o_2 ) + floor( o_4 );\n\n\tfloat i_0 = r - 0.5;\n\tfloat i_1 = sq2 * i_0;\n\tfloat i_2 = i_1 / 2.0;\n\tfloat i_3 = sqrt( i_0*i_0 - r*r );\n\tfloat i_4 = i_2 - ( floor(i_2) + 1.0 );\n\tfloat i_5 = floor( i_2 ) + floor( i_4 );\n\n\tfloat d_0 = ( i_5 ) + 1.0 - ( o_5 );\n\n\tfor(float i = 1.0; i < floor( i_2 ) + 1.0 - d_0; i++) {\n\n\t\tfloat j_0 = sqrt( o_0*o_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_1 = sqrt( i_0*i_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_2 = ( 1.0 - abs( sign ( (floor( i_2 ) + 1.0) - i ) ) );\n\n\t\tfor(float j = floor( j_1 ) + j_2; j < floor( j_0 ); j++) {\n\t\t\tval += floor(gdv(ivec2( i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1), i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1), i), txdata) * psn);\n\t\t\ttot += 8.0 * psn; } }\n\n//\tOrthagonal\n\tval += floor(gdv(ivec2( r, 0), txdata) * psn);\n\tval += floor(gdv(ivec2( 0,-r), txdata) * psn);\n\tval += floor(gdv(ivec2(-r,-0), txdata) * psn);\n\tval += floor(gdv(ivec2(-0, r), txdata) * psn);\n\ttot += 4.0 * psn;\n\n//\tDiagonal\n//\tTODO This is not quite perfect\n\tfloat k_0 = r;\n\tfloat k_1 = sq2 * k_0;\n\tfloat k_2 = k_1 / 2.0;\n\tfloat k_3 = sqrt( k_0*k_0 - r*r );\n\tfloat k_4 = k_2 - ( floor(k_2) + 1.0 );\n\tfloat k_5 = floor( k_2 ) + floor( k_4 );\n\n\tfloat dist = round(k_2);\n\n\tif( sign( o_4 ) == -1.0 ) {\n\t//\tval += gdv(ivec2( (floor(o_5)+1), floor(o_5)+1), txdata);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\ttot += 4.0 * psn; }\n\n\treturn ConvData( val, tot ); }\n\n\nvec4 conv( float r ) {\n\tConvData nh = ring( r );\n\treturn \tnh.value / nh.total; }\n    \nvec4 bitmake(ConvData[MAX_RADIUS] rings, uint bits, uint of) {\n\tvec4  sum = vec4(0.0,0.0,0.0,0.0);\n\tfloat tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings[i].value; tot += rings[i].total; } }\n\treturn sum / tot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tConvData[MAX_RADIUS] nh_rings_m;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) { nh_rings_m[i] = ring(float(i+1u)); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  128.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub[2],  ub[3],\n\t\tub[4],  ub[5],  ub[6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tvec4[12] smnca_res = vec4[12](res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c);\n\n\tvec4 conv1 = conv(1.0);\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n                \n\t\tvec4 nhv = bitmake( nh_rings_m, nb[i/2u], (i & 1u) * 16u );\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 0u) && nhv[cho] <= utp( ur[i], 8u, 1u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * res_c[chm]; }\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 2u) && nhv[cho] <= utp( ur[i], 8u, 3u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * res_c[chm]; } }\n\n\tuvec4 dev_idx = uvec4(0u,0u,0u,0u);\n    \n\tvec4 dev = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < 6u; i++) {\n\t\tvec4 smnca_res_temp = abs(res_c - smnca_res[i]);\n\t\tif(smnca_res_temp[0] > dev[0]) { dev_idx[0] = i; dev[0] = smnca_res_temp[0]; }\n\t\tif(smnca_res_temp[1] > dev[1]) { dev_idx[1] = i; dev[1] = smnca_res_temp[1]; }\n\t\tif(smnca_res_temp[2] > dev[2]) { dev_idx[2] = i; dev[2] = smnca_res_temp[2]; }\n\t\tif(smnca_res_temp[3] > dev[3]) { dev_idx[3] = i; dev[3] = smnca_res_temp[3]; } }\n\n\tres_v[0] = smnca_res[dev_idx[0]][0];\n\tres_v[1] = smnca_res[dev_idx[1]][1];\n\tres_v[2] = smnca_res[dev_idx[2]][2];\n\tres_v[3] = smnca_res[dev_idx[3]][3];\n\n    res_c = ((res_v + (conv1 * (s*2.13333))) / (1.0 + (s*2.13333)))- 0.01 * s;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   3060246268u, 1738652270u, 1860951328u, 2516787966u, \n    613987017u, 775395886u, 4280169843u, 148624400u, \n    2137189529u, 264381586u, 4101169455u, 1994322064u, \n    2818505514u, 2251564764u, 2645029938u, 1458108844u, \n    2072157747u, 1168555589u, 3671807972u, 1833414612u, \n    3461305943u, 3138647863u, 2727543091u, 1308884491u, \n    964217604u, 500229995u, 2212719393u, 482016387u, \n    2983380564u, 678753835u, 328940010u, 1830820096u, \n    878175310u, 821649567u, 610488564u, 1150301103u, \n    149010126u, 1003328336u, 635271555u, 3640019719u, \n    1201184467u, 775316069u, 2145230570u, 805788811u, \n    3010664919u, 534543614u, 909992471u, 952238036u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1034091979u, 1126448937u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nstruct ConvData {\n\tvec4 \tvalue;\n\tfloat \ttotal;\n};\n\n\nConvData ring( float r ) {\n\n\tconst float psn = 32768.0;\n\n\tfloat tot = 0.0;\n\tvec4  val = vec4(0.0,0.0,0.0,0.0);\n\n\tfloat sq2\t= sqrt(2.0);\n\n\tfloat o_0 = r + 0.5;\n\tfloat o_1 = sq2 * o_0;\n\tfloat o_2 = o_1 / 2.0;\n\tfloat o_3 = sqrt( o_0*o_0 - r*r );\n\tfloat o_4 = o_2 - ( floor(o_2) + 0.5 );\n\tfloat o_5 = floor( o_2 ) + floor( o_4 );\n\n\tfloat i_0 = r - 0.5;\n\tfloat i_1 = sq2 * i_0;\n\tfloat i_2 = i_1 / 2.0;\n\tfloat i_3 = sqrt( i_0*i_0 - r*r );\n\tfloat i_4 = i_2 - ( floor(i_2) + 1.0 );\n\tfloat i_5 = floor( i_2 ) + floor( i_4 );\n\n\tfloat d_0 = ( i_5 ) + 1.0 - ( o_5 );\n\n\tfor(float i = 1.0; i < floor( i_2 ) + 1.0 - d_0; i++) {\n\n\t\tfloat j_0 = sqrt( o_0*o_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_1 = sqrt( i_0*i_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_2 = ( 1.0 - abs( sign ( (floor( i_2 ) + 1.0) - i ) ) );\n\n\t\tfor(float j = floor( j_1 ) + j_2; j < floor( j_0 ); j++) {\n\t\t\tval += floor(gdv(ivec2( i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1), i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1), i), txdata) * psn);\n\t\t\ttot += 8.0 * psn; } }\n\n//\tOrthagonal\n\tval += floor(gdv(ivec2( r, 0), txdata) * psn);\n\tval += floor(gdv(ivec2( 0,-r), txdata) * psn);\n\tval += floor(gdv(ivec2(-r,-0), txdata) * psn);\n\tval += floor(gdv(ivec2(-0, r), txdata) * psn);\n\ttot += 4.0 * psn;\n\n//\tDiagonal\n//\tTODO This is not quite perfect\n\tfloat k_0 = r;\n\tfloat k_1 = sq2 * k_0;\n\tfloat k_2 = k_1 / 2.0;\n\tfloat k_3 = sqrt( k_0*k_0 - r*r );\n\tfloat k_4 = k_2 - ( floor(k_2) + 1.0 );\n\tfloat k_5 = floor( k_2 ) + floor( k_4 );\n\n\tfloat dist = round(k_2);\n\n\tif( sign( o_4 ) == -1.0 ) {\n\t//\tval += gdv(ivec2( (floor(o_5)+1), floor(o_5)+1), txdata);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\ttot += 4.0 * psn; }\n\n\treturn ConvData( val, tot ); }\n\n\nvec4 conv( float r ) {\n\tConvData nh = ring( r );\n\treturn \tnh.value / nh.total; }\n    \nvec4 bitmake(ConvData[MAX_RADIUS] rings, uint bits, uint of) {\n\tvec4  sum = vec4(0.0,0.0,0.0,0.0);\n\tfloat tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings[i].value; tot += rings[i].total; } }\n\treturn sum / tot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tConvData[MAX_RADIUS] nh_rings_m;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) { nh_rings_m[i] = ring(float(i+1u)); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  128.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub[2],  ub[3],\n\t\tub[4],  ub[5],  ub[6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tvec4[12] smnca_res = vec4[12](res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c);\n\n\tvec4 conv1 = conv(1.0);\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n                \n\t\tvec4 nhv = bitmake( nh_rings_m, nb[i/2u], (i & 1u) * 16u );\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 0u) && nhv[cho] <= utp( ur[i], 8u, 1u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * res_c[chm]; }\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 2u) && nhv[cho] <= utp( ur[i], 8u, 3u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * res_c[chm]; } }\n\n\tuvec4 dev_idx = uvec4(0u,0u,0u,0u);\n    \n\tvec4 dev = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < 6u; i++) {\n\t\tvec4 smnca_res_temp = abs(res_c - smnca_res[i]);\n\t\tif(smnca_res_temp[0] > dev[0]) { dev_idx[0] = i; dev[0] = smnca_res_temp[0]; }\n\t\tif(smnca_res_temp[1] > dev[1]) { dev_idx[1] = i; dev[1] = smnca_res_temp[1]; }\n\t\tif(smnca_res_temp[2] > dev[2]) { dev_idx[2] = i; dev[2] = smnca_res_temp[2]; }\n\t\tif(smnca_res_temp[3] > dev[3]) { dev_idx[3] = i; dev[3] = smnca_res_temp[3]; } }\n\n\tres_v[0] = smnca_res[dev_idx[0]][0];\n\tres_v[1] = smnca_res[dev_idx[1]][1];\n\tres_v[2] = smnca_res[dev_idx[2]][2];\n\tres_v[3] = smnca_res[dev_idx[3]][3];\n\n    res_c = ((res_v + (conv1 * (s*2.13333))) / (1.0 + (s*2.13333)))- 0.01 * s;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   3060246268u, 1738652270u, 1860951328u, 2516787966u, \n    613987017u, 775395886u, 4280169843u, 148624400u, \n    2137189529u, 264381586u, 4101169455u, 1994322064u, \n    2818505514u, 2251564764u, 2645029938u, 1458108844u, \n    2072157747u, 1168555589u, 3671807972u, 1833414612u, \n    3461305943u, 3138647863u, 2727543091u, 1308884491u, \n    964217604u, 500229995u, 2212719393u, 482016387u, \n    2983380564u, 678753835u, 328940010u, 1830820096u, \n    878175310u, 821649567u, 610488564u, 1150301103u, \n    149010126u, 1003328336u, 635271555u, 3640019719u, \n    1201184467u, 775316069u, 2145230570u, 805788811u, \n    3010664919u, 534543614u, 909992471u, 952238036u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1034091979u, 1126448937u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nstruct ConvData {\n\tvec4 \tvalue;\n\tfloat \ttotal;\n};\n\n\nConvData ring( float r ) {\n\n\tconst float psn = 32768.0;\n\n\tfloat tot = 0.0;\n\tvec4  val = vec4(0.0,0.0,0.0,0.0);\n\n\tfloat sq2\t= sqrt(2.0);\n\n\tfloat o_0 = r + 0.5;\n\tfloat o_1 = sq2 * o_0;\n\tfloat o_2 = o_1 / 2.0;\n\tfloat o_3 = sqrt( o_0*o_0 - r*r );\n\tfloat o_4 = o_2 - ( floor(o_2) + 0.5 );\n\tfloat o_5 = floor( o_2 ) + floor( o_4 );\n\n\tfloat i_0 = r - 0.5;\n\tfloat i_1 = sq2 * i_0;\n\tfloat i_2 = i_1 / 2.0;\n\tfloat i_3 = sqrt( i_0*i_0 - r*r );\n\tfloat i_4 = i_2 - ( floor(i_2) + 1.0 );\n\tfloat i_5 = floor( i_2 ) + floor( i_4 );\n\n\tfloat d_0 = ( i_5 ) + 1.0 - ( o_5 );\n\n\tfor(float i = 1.0; i < floor( i_2 ) + 1.0 - d_0; i++) {\n\n\t\tfloat j_0 = sqrt( o_0*o_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_1 = sqrt( i_0*i_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_2 = ( 1.0 - abs( sign ( (floor( i_2 ) + 1.0) - i ) ) );\n\n\t\tfor(float j = floor( j_1 ) + j_2; j < floor( j_0 ); j++) {\n\t\t\tval += floor(gdv(ivec2( i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1), i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1), i), txdata) * psn);\n\t\t\ttot += 8.0 * psn; } }\n\n//\tOrthagonal\n\tval += floor(gdv(ivec2( r, 0), txdata) * psn);\n\tval += floor(gdv(ivec2( 0,-r), txdata) * psn);\n\tval += floor(gdv(ivec2(-r,-0), txdata) * psn);\n\tval += floor(gdv(ivec2(-0, r), txdata) * psn);\n\ttot += 4.0 * psn;\n\n//\tDiagonal\n//\tTODO This is not quite perfect\n\tfloat k_0 = r;\n\tfloat k_1 = sq2 * k_0;\n\tfloat k_2 = k_1 / 2.0;\n\tfloat k_3 = sqrt( k_0*k_0 - r*r );\n\tfloat k_4 = k_2 - ( floor(k_2) + 1.0 );\n\tfloat k_5 = floor( k_2 ) + floor( k_4 );\n\n\tfloat dist = round(k_2);\n\n\tif( sign( o_4 ) == -1.0 ) {\n\t//\tval += gdv(ivec2( (floor(o_5)+1), floor(o_5)+1), txdata);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\ttot += 4.0 * psn; }\n\n\treturn ConvData( val, tot ); }\n\n\nvec4 conv( float r ) {\n\tConvData nh = ring( r );\n\treturn \tnh.value / nh.total; }\n    \nvec4 bitmake(ConvData[MAX_RADIUS] rings, uint bits, uint of) {\n\tvec4  sum = vec4(0.0,0.0,0.0,0.0);\n\tfloat tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings[i].value; tot += rings[i].total; } }\n\treturn sum / tot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tConvData[MAX_RADIUS] nh_rings_m;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) { nh_rings_m[i] = ring(float(i+1u)); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  128.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub[2],  ub[3],\n\t\tub[4],  ub[5],  ub[6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tvec4[12] smnca_res = vec4[12](res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c);\n\n\tvec4 conv1 = conv(1.0);\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n                \n\t\tvec4 nhv = bitmake( nh_rings_m, nb[i/2u], (i & 1u) * 16u );\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 0u) && nhv[cho] <= utp( ur[i], 8u, 1u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * res_c[chm]; }\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 2u) && nhv[cho] <= utp( ur[i], 8u, 3u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * res_c[chm]; } }\n\n\tuvec4 dev_idx = uvec4(0u,0u,0u,0u);\n    \n\tvec4 dev = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < 6u; i++) {\n\t\tvec4 smnca_res_temp = abs(res_c - smnca_res[i]);\n\t\tif(smnca_res_temp[0] > dev[0]) { dev_idx[0] = i; dev[0] = smnca_res_temp[0]; }\n\t\tif(smnca_res_temp[1] > dev[1]) { dev_idx[1] = i; dev[1] = smnca_res_temp[1]; }\n\t\tif(smnca_res_temp[2] > dev[2]) { dev_idx[2] = i; dev[2] = smnca_res_temp[2]; }\n\t\tif(smnca_res_temp[3] > dev[3]) { dev_idx[3] = i; dev[3] = smnca_res_temp[3]; } }\n\n\tres_v[0] = smnca_res[dev_idx[0]][0];\n\tres_v[1] = smnca_res[dev_idx[1]][1];\n\tres_v[2] = smnca_res[dev_idx[2]][2];\n\tres_v[3] = smnca_res[dev_idx[3]][3];\n\n    res_c = ((res_v + (conv1 * (s*2.13333))) / (1.0 + (s*2.13333)))- 0.01 * s;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]], "test": "untested"}
{"id": "7sscW4", "name": "More Fractal Ropes", "author": "SnoopethDuckDuck", "description": "still not too good at colors etc,", "tags": ["raymarching", "template", "artofcode"], "likes": 56, "viewed": 1247, "published": 3, "date": "1642116975", "time_retrieved": "2024-07-30T17:10:18.005047", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    vec2 uv = p.xz;\n    \n    uv.x = abs(uv.x);\n    float time = 12. + iTime; // 0.3 * h21(floor(10. * uv))  //<-very cool extremely laggy\n    vec2 q = vec2(1,0);\n    \n    float th = 0.4 * p.y - 0.6 * time;\n    float n = 9.;\n    float m = -0.0 * length(uv) + 1.8;\n    for (float i = 0.; i < n; i++) { \n        uv -= m * q;\n        th += 0.5 * p.y + 0.05 * time;\n        uv = Rot(th) * uv;\n        uv.x = abs(uv.x);\n        m *= 0.05 * cos(8. * length(uv)) +  0.55;// + 0.05 * cos(0.4 * p.y - 0.6 * iTime);\n        //m += m * cos(iTime);\n    }\n    \n    float d = length(uv) - 2. * m;\n    \n    //float d = length(uv)- 0.5;\n    \n    return 0.5 * d; // was 0.35\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 5.5;\n    float time = 0. * iTime;\n    vec3 ro = vec3(r * cos(time), 0.1 * iTime, r * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.1 * iTime,0), 2.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float ambient = .3;\n        float difPower = .4;\n        float dif = max(dot(n, normalize(vec3(1,2,3))), 0.);\n        col = vec3(dif*difPower + ambient);\n\n        col *= texture(iChannel0,r).rgb;\n        col *= 1. + r.y;//+ p.y;\n        col = clamp(col, 0., 1.);\n        \n        vec3 e = vec3(1.);\n        col *= pal(r.y, e, e, e, 0.35 * vec3(0.,0.33,0.66));\n        //col *= 0.5 + 0.5 * thc(4., 12. * length(p) + 0.4 * iTime) * cos(4. * p.y + iTime);\n        //col *= 0.5 * (1. + thc(2., iTime + p.y * 4.));\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sscW4.jpg", "access": "api", "license": "mit", "functions": [[1474, 1474, 1493, 1493, 1555], [1557, 1557, 1580, 1580, 2239], [2241, 2241, 2275, 2275, 2486], [2488, 2488, 2512, 2512, 2702], [2704, 2704, 2754, 2754, 2945], [2947, 2947, 3004, 3004, 4136]], "test": "untested"}
{"id": "fdlcDN", "name": "three dimensions test", "author": "tungster24", "description": "i wanted to try it out\nit was a pain but it works :D", "tags": ["3d", "points"], "likes": 2, "viewed": 196, "published": 3, "date": "1642108059", "time_retrieved": "2024-07-30T17:10:18.777980", "image_code": "#define scale 1\n#define rad radians\n\nstruct point {\nfloat x;\nfloat y;\nfloat z;\n};\n\nstruct camera {\n//camera position\nfloat x;\nfloat y;\nfloat z;\n//camera angles\nfloat tx;\nfloat ty;\nfloat tz;\n//camera projection plane location\nfloat ex;\nfloat ey;\nfloat ez;\n};\n\n//projection function\nvec2 projection(in point p,in camera cam) {\n    float x = p.x-cam.x;\n    float y = p.y-cam.y;\n    float z = p.z-cam.z;\n    \n    float dx = cos(cam.ty)*(sin(cam.tz)*y+cos(cam.tz)*x)-sin(cam.ty)*z;\n    \n    float dy = sin(cam.tx)*( \n    cos(cam.ty)*z+\n    sin(cam.ty)*\n        (\n        sin(cam.tz)*y+cos(cam.tz)*x\n        )\n    \n    )+cos(cam.tx)* (cos(cam.tz)*y-sin(cam.tz)*x)\n    ;\n    float dz = cos(cam.tx)*( \n    cos(cam.ty)*z+\n    sin(cam.ty)*\n        (\n        sin(cam.tz)*y+cos(cam.tz)*x\n        )\n    )-sin(cam.tx)* (cos(cam.tz)*y-sin(cam.tz)*x)\n    ;\n    \n    return vec2(\n    (cam.ez/dz)*dx+cam.ex,\n    (cam.ez/dz)*dy+cam.ey\n    );\n}\n\n//distance between two points because it's useful\nfloat dist(in vec2 p,in vec2 d) {\n    float difx = p.x-d.x;\n    float dify = p.y-d.y;\n    if (sqrt(difx*difx+dify*dify) < 0.01)return 1.0;else return 0.0;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy+vec2(0.0,0.0);\n    if (length(iMouse.xy) < 50.0) m = vec2(0.5);\n    //define modified time\n    float t = cos(iTime)/5.0;\n    //define camera\n    camera cam;\n    cam.x = 0.5;cam.y=t;cam.z= -3.0;\n    cam.tx = rad(m.y-0.5)*120.0;cam.ty = rad(-m.x+0.5)*120.0; cam.tz = 0.0;\n    cam.ex = 0.0;cam.ey = 0.0;cam.ez = 1.0;\n    //define points\n    point a[8] = point[8](\n    point(0.0,0.0,0.0),\n    point(0.0,0.0,1.1),\n    point(0.0,1.1,0.0),\n    point(0.0,1.1,1.1),\n    point(1.1,0.0,0.0),\n    point(1.1,0.0,1.1),\n    point(1.1,1.1,0.0),\n    point(1.1,1.1,1.1)\n    );\n    //light constant for glow\n    float light = 0.0;\n    \n    //normalised screen coords\n    vec2 p = fragCoord.xy/iResolution.yy*float(scale)-float(scale)/2.0*iResolution.xy/iResolution.yy;\n    \n    for(int i = 0;i<8;i++) {\n    light += dist(p,projection(a[i],cam))*20.0;\n    }\n    fragColor = vec4(vec3(light),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 281, 324, 324, 924], [926, 976, 1009, 1009, 1137], [1138, 1138, 1195, 1195, 2112]], "test": "untested"}
{"id": "fslyWN", "name": "Spiral - distance (INEXACT)", "author": "iq", "description": "INEXACT distance to a logarithmic spiral. Works fine for high number of rotations, but not so well for small.", "tags": ["2d", "distancefield", "sdf", "spiral", "distance", "logarithmic", "golden"], "likes": 36, "viewed": 958, "published": 3, "date": "1642105320", "time_retrieved": "2024-07-30T17:10:19.549916", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a logarithmic spiral. It's inexact, mostly\n// noticeable when the number of rotations is small.\n\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\n    // body\n    const float kTau = 6.283185307;\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float n = floor( 0.5/w + (log2(r/w)*k-a)/kTau );\n    float ra = w*exp2((a+kTau*(min(n+0.0,0.0)-0.5))/k);\n    float rb = w*exp2((a+kTau*(min(n+1.0,0.0)-0.5))/k);\n    float d = min( abs(r-ra), abs(r-rb) );\n\n    // tip\n    return min( d, length(p+vec2(w,0.0)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    // recenter\n    p -= vec2(0.2,-0.09);\n    m -= vec2(0.2,-0.09);\n    \n    // animation\n    float sw = 1.0;\n    float sk = 1.0 + 10.0*(0.5-0.5*cos(iTime+1.5));\n    \n    // distance\n    float d = sdSpiral(p, sw, sk);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(160.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdSpiral(m, sw, sk);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(-px, px, abs(length(p-m)-abs(d))-0.005));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(-px, px, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslyWN.jpg", "access": "api", "license": "mit", "functions": [[1321, 1401, 1451, 1463, 1819], [1821, 1821, 1878, 1914, 2798]], "test": "untested"}
{"id": "ssXyWN", "name": "Night Sky 2", "author": "turboplay", "description": "A nice night sky with moon, stars, clouds, optionally modifies a texture.\nConverted for ShaderToy from https://github.com/Oncorporation/obs-shaderfilter/.", "tags": ["night"], "likes": 4, "viewed": 397, "published": 3, "date": "1642087003", "time_retrieved": "2024-07-30T17:10:20.314871", "image_code": " float speed = 20.0;\n bool Include_Clouds = true;\n bool Include_Moon = true;\n float Alpha_Percentage = 95.; //<Range(0.0,100.0)>\n \n // Stars\n int number_stars = 40; //<Range(0.0,100.0)>\n \n // Sky\n vec4 SKY_COLOR = vec4(0.027, 0.151, 0.354, 1.0 );\n vec4 STAR_COLOR = vec4(0.92, 0.92, 0.14, 1.0 );\n vec4 LIGHT_SKY = vec4(.45, 0.61, 0.98, 1.0);\n float SKY_LIGHTNESS = .4;\n \n// Moon\n vec4 MOON_COLOR = vec4(.4, .25, 0.25, 1.0 );\n float moon_size = 0.18;\n float moon_bump_size = 0.14;\n float Moon_Position_x = -0.2;\n float Moon_Position_y = 0.3;\n\n// Apply to image?\n bool Apply_To_Image = false;\n\n\n#define PI 3.1416\n\n//Noise functions from https://www.youtube.com/watch?v=zXsWftRdsvU\nfloat noise11(float p) {\n    return fract(sin(p * 633.1847) * 9827.95);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise21(vec2 p) {\n    return fract(sin(p.x * 827.221 + p.y * 3228.8275) * 878.121);\n}\n\nvec2 noise22(vec2 p) {\n    return fract(vec2(sin(p.x * 9378.35), sin(p.y * 75.589)) * 556.89);\n}\n\n//From https://codepen.io/Tobsta/post/procedural-generation-part-1-1d-perlin-noise\nfloat cosineInterpolation(float a, float b, float x) {\n    float ft = x * PI;\n    float f = (1. - cos(ft)) * .5;\n    return a * (1. - f) + b * f;\n}\n\nfloat smoothNoise11(float p, float dist) {\n    float prev = noise11(p - dist);\n    float next = noise11(p + dist);\n\n    return cosineInterpolation(prev, next, .5);\n}\n\n\nfloat smoothNoise21(vec2 uv, float cells) {\n    vec2 lv = fract(uv * cells);\n    vec2 id = floor(uv * cells);\n\n    //smoothstep function: maybe change it later!\n    lv = lv * lv * (3. - 2. * lv);\n\n    float bl = noise21(id);\n    float br = noise21(id + vec2(1., 0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = noise21(id + vec2(0., 1.));\n    float tr = noise21(id + vec2(1., 1.));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nvec2 smoothNoise22(vec2 uv, float cells) {\n    vec2 lv = fract(uv * cells);\n    vec2 id = floor(uv * cells);\n\n    lv = lv * lv * (3. - 2. * lv);\n\n    vec2 bl = noise22(id);\n    vec2 br = noise22(id + vec2(1., 0.));\n    vec2 b = mix(bl, br, lv.x);\n\n    vec2 tl = noise22(id + vec2(0., 1.));\n    vec2 tr = noise22(id + vec2(1., 1.));\n    vec2 t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nfloat valueNoise11(float p) {\n    float c = smoothNoise11(p, 0.5);\n    c += smoothNoise11(p, 0.25) * .5;\n    c += smoothNoise11(p, 0.125) * .25;\n    c += smoothNoise11(p, 0.0625) * .125;\n\n    return c /= .875;\n}\n\nfloat valueNoise21(vec2 uv) {\n    float c = smoothNoise21(uv, 4.);\n    c += smoothNoise21(uv, 8.) * .5;\n    c += smoothNoise21(uv, 16.) * .25;\n    c += smoothNoise21(uv, 32.) * .125;\n    c += smoothNoise21(uv, 64.) * .0625;\n\n    return c /= .9375;\n}\n\nvec2 valueNoise22(vec2 uv) {\n    vec2 c = smoothNoise22(uv, 4.);\n    c += smoothNoise22(uv, 8.) * .5;\n    c += smoothNoise22(uv, 16.) * .25;\n    c += smoothNoise22(uv, 32.) * .125;\n    c += smoothNoise22(uv, 64.) * .0625;\n\n    return c /= .9375;\n}\n\nvec3 points(vec2 p, vec2 uv, vec3 color, float size, float blur) {\n    float dist = distance(p, uv);\n    return color * smoothstep(size, size * (0.999 - blur), dist);\n}\n\nfloat mapInterval(float x, float a, float b, float c, float d) {\n    return (x - a) / (b - a) * (d - c) + c;\n}\n\nfloat blink(float time, float timeInterval) {\n    float halfInterval = timeInterval / 2.0;\n    //Get relative position in the bucket\n    float p = mod(time, timeInterval);\n\n\n    if (p <= timeInterval / 2.) {\n        return smoothstep(0., 1., p / halfInterval);\n    }\n    else {\n        return smoothstep(1., 0., (p - halfInterval) / halfInterval);\n    }\n}\n\nvec3 sampleBumps(vec2 p, vec2 uv, float radius, float spin) {\n    float dist = distance(p, uv);\n    vec3 BumpSamples = vec3(0., 0., 0.);\n\n    if (dist < radius) {\n        float bumps = (1. - valueNoise21(uv * spin)) * .1;\n        BumpSamples = vec3(bumps, bumps, bumps);\n    }\n    return  BumpSamples;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n   \n    float uv_scale = 0.;\n\n    vec4 rgba;\n    float alpha = clamp(Alpha_Percentage * .01, 0., 1.0);\n    vec2 center_pixel_coordinates =vec2(0.5);\n    vec2 st = uv * uv_scale;\n    vec2 toCenter = center_pixel_coordinates - st;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 ouv = uv;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 seed = toCenter / iResolution.xy;\n\n    float time = iTime + seed.x * speed;\n\n    //float3 col = float3(0.0);\n    //float m = valueNoise21(uv);    \n    vec3 col = mix(SKY_COLOR.rgb, LIGHT_SKY.rgb, ouv.y - SKY_LIGHTNESS);\n\n    col *= SKY_LIGHTNESS - (1. - ouv.y);\n\n    //Add clouds\n    if (Include_Clouds)\n    {\n        vec2 timeUv = uv;\n        timeUv.x += time * .1;\n        timeUv.y += valueNoise11(timeUv.x + .352) * .01;\n        float cloud = valueNoise21(timeUv);\n        col += cloud * .1;\n    }\n\n    //Add stars in the top part of the scene\n    float timeInterval = speed * .5; //5.0\n    float timeBucket = floor(time / timeInterval);\n\n    vec2 moonPosition = vec2(-1000, -1000);\n    if (Include_Moon)\n    {\n        moonPosition = vec2(Moon_Position_x, Moon_Position_y);\n        col += points(moonPosition, uv, MOON_COLOR.rgb, moon_size, 0.3);\n        // Moon bumps\n        col += sampleBumps(moonPosition, uv, moon_bump_size, 9. + mod(time * .1, 9.));\n    }\n\n    for (int i = 0; i < clamp(number_stars, 0, 100); i++) {\n    \n        float fi = float(i);\n        vec2 starPosition = vec2(fi/10., fi / 10.);\n\n        starPosition.x = mapInterval(valueNoise11(timeBucket + fi * 827.913) - .4, 0., 1., 0.825, -0.825);\n        starPosition.y = mapInterval(valueNoise11(starPosition.x) - .3, 0., 1., 0.445, -0.445);\n\n        float starIntensity = blink(time + (rand(uv) * fi), timeInterval);\n        //Hide stars that are behind the moon\n        if (distance(starPosition, moonPosition) > moon_size) {\n            col += points(starPosition, uv, STAR_COLOR.rgb, 0.001, 0.0) * clamp(starIntensity - .1, 0.0, 1.0) * 10.0;\n            col += points(starPosition, uv, STAR_COLOR.rgb, 0.009, 3.5) * starIntensity * 3.0;\n        }\n    }\n    //col = float3(blink(time, timeInterval));\n    rgba = vec4(col, alpha);\n\n    // Output to screen\n    if (Apply_To_Image)\n    {\n        vec4 color = texture(iChannel0,ouv);\n        vec4 original_color = color;\n        rgba = mix(original_color, rgba * color, alpha);\n\n    }\n    fragColor = rgba;\n   \n   \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[612, 679, 703, 703, 752], [754, 754, 774, 774, 844], [846, 846, 869, 869, 937], [939, 939, 961, 961, 1035], [1037, 1120, 1174, 1174, 1267], [1269, 1269, 1311, 1311, 1434], [1437, 1437, 1480, 1480, 1888], [1890, 1890, 1932, 1932, 2284], [2286, 2286, 2315, 2315, 2497], [2499, 2499, 2528, 2528, 2748], [2750, 2750, 2778, 2778, 2997], [2999, 2999, 3065, 3065, 3167], [3169, 3169, 3233, 3233, 3279], [3281, 3281, 3326, 3326, 3636], [3638, 3638, 3699, 3699, 3941], [3944, 3944, 4001, 4051, 6498]], "test": "untested"}
{"id": "7sfyD4", "name": "Sea Sickness", "author": "turboplay", "description": "Found it in https://github.com/Oncorporation/obs-shaderfilter/ seems nice.\nChange the parameters ", "tags": ["distortion", "filter"], "likes": 2, "viewed": 268, "published": 3, "date": "1642084863", "time_retrieved": "2024-07-30T17:10:21.088802", "image_code": " float amplitude = 0.03f; // 0.01 to 0.1, 0.03\n float speed = 1.0f; // 0.1 to 10, 1\n float frequency = 6.0f; // 1 to 30, 6\n float opacity = 0.6f; // 0 to 1, 0.5\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pulse = sin(iTime * speed - frequency * uv);\n    vec2 coord = uv + amplitude * vec2(pulse.x, -pulse.y);\n    fragColor = texture(iChannel0,coord) * opacity;\n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 220, 270, 482]], "test": "untested"}
{"id": "sdfyD4", "name": "Fractal 2d Clouds", "author": "ersh", "description": "Fractal 2d Clouds", "tags": ["procedural", "2d", "fractal", "cloud", "fire", "generated"], "likes": 9, "viewed": 415, "published": 3, "date": "1642083935", "time_retrieved": "2024-07-30T17:10:22.121042", "image_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define OUTPUT_AVG     1    // Average 4 buffers or use only one\n#define SMOOTH         3    // Smooth output: 0=no; 1=yes; 2=use an extra iteration; 3=extra iter+regular\n#define LOOKUP_DIST    2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define PALETTE        1    // 0=fire, 1=blue, 2=green\n\nvec3 col(float x) {\n  return vec3(\n#if PALETTE == 0\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n#elif PALETTE == 1\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x, 0., 1./3.)\n#elif PALETTE == 2\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.)\n#endif\n   ) * 3.;\n}\n\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2. + V( 0.0,  0.0)*8. + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 20.; \\\n//EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y) + \\\n//          V(-s.x,  0.0) + V( 0.0,  0.0)*2.) / 5.; \\\n// EOM\n//#define AVG \\\n//  return (V(0.0, -s.y) + V(-s.x, 0.0) + V(s.x, 0.0) + V(0.0, s.y))/4.; \\\n// EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//EOM\n//#define AVG \\\n//  float avg = \\\n//         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//  float pt = V(0.0, 0.0); \\\n//  float diff = distance(avg, pt); \\\n//  return mix(pt, avg, smoothstep(0.0, 1.0, diff*1.5)); \\\n// EOM\n\n#define min4(a1,a2,a3,a4)               min(min(a1,a2),min(a3,a4))\n#define min8(a1,a2,a3,a4,b1,b2,b3,b4)   min(min4(a1,a2,a3,a4),min4(b1,b2,b3,b4))\n#define max4(a1,a2,a3,a4)               max(max(a1,a2),max(a3,a4))\n#define max8(a1,a2,a3,a4,b1,b2,b3,b4)   max(max4(a1,a2,a3,a4),max4(b1,b2,b3,b4))\n#define AVG \\\n  float mn = min8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  float mx = max8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  float avg = \\\n         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n  float pt = V(0.0, 0.0); \\\n  float minmaxdiff = clamp(distance(mn,mx), 0.01, 0.67); \\\n  float diff = distance(avg, pt); \\\n  return mix(pt, avg, smoothstep(0.0, 1.0, diff / minmaxdiff)); \\\n// EOM\n\n#define V(X,Y)   texture(iChannel0, c + vec2(X, Y)).r\nfloat avg0(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   texture(iChannel1, c + vec2(X, Y)).r\nfloat avg1(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   texture(iChannel2, c + vec2(X, Y)).r\nfloat avg2(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   texture(iChannel3, c + vec2(X, Y)).r\nfloat avg3(in vec2 c, in vec2 s) { AVG }\n#undef V\n\nfloat gen1(in vec2 uv, in sampler2D iChannel, in vec2 s1)\n{\n    //vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    return texture(iChannel, d).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.a = 1.0;\n\n#if OUTPUT_AVG\n#if SMOOTH == 0\n\tfragColor.rgb = col(\n            (texture(iChannel0,uv).r +\n            texture(iChannel1,uv).r +\n            texture(iChannel2,uv).r +\n            texture(iChannel3,uv).r) / 4.\n        );\n#elif SMOOTH == 1\n    vec2 s = vec2(1., 1.) / iResolution.xy;\n\tfragColor.rgb = col(\n            (avg0(uv, s) +\n             avg1(uv, s) +\n             avg2(uv, s) +\n             avg3(uv, s)) / 4.\n        );\n#elif SMOOTH == 2\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n\tfragColor.rgb = col(\n            (gen1(uv, iChannel0, s1) +\n            gen1(uv, iChannel1, s1) +\n            gen1(uv, iChannel2, s1) +\n            gen1(uv, iChannel3, s1)) / 4.\n        );\n#elif SMOOTH == 3\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n\tfragColor.rgb = col(\n            (gen1(uv, iChannel0, s1) +\n            gen1(uv, iChannel1, s1) +\n            gen1(uv, iChannel2, s1) +\n            gen1(uv, iChannel3, s1) +\n            avg0(uv, s1) +\n            avg1(uv, s1) +\n            avg2(uv, s1) +\n            avg3(uv, s1)) / 8.\n        );\n#endif\n\n#else\n\n#if SMOOTH == 0\n\tfragColor.rgb = col(texture(iChannel0,uv).r);\n#elif SMOOTH == 1\n    fragColor.rgb = col(avg0(uv, vec2(1., 1.) / iResolution.xy));\n#elif SMOOTH == 2\n\tfragColor.rgb = col(gen1(uv, iChannel0, vec2(1., 1.) / iResolution.xy));\n#elif SMOOTH == 3\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n\tfragColor.rgb = col((gen1(uv, iChannel0, s1) + avg0(uv, s1))/2.);\n#endif\n\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        1     // Cause the fire to flare up\n#define SPEED         0.05\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-distance(uv, vec2(0.5))/5.)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,1.-distance(vec2(0.5), uv));\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,1.-distance(vec2(0.5), uv));\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord)/SPEED > (COORD)\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + (hash12(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED         0.05\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1520. + 60.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,1.-distance(vec2(0.5), uv));\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,1.-distance(vec2(0.5), uv));\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord)/SPEED > (COORD)\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + (hash12(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED         0.05\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1550. + 70.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,1.-distance(vec2(0.5), uv));\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,1.-distance(vec2(0.5), uv));\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord)/SPEED > (COORD)\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + (hash12(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED         0.05\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1570. + 80.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,1.-distance(vec2(0.5), uv));\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,1.-distance(vec2(0.5), uv));\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord)/SPEED > (COORD)\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + (hash12(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3336, 3336, 3395, 3442, 4330], [4332, 4332, 4389, 4389, 5898]], "test": "untested"}
{"id": "ssfyW4", "name": "Penguins Spiraling", "author": "dr2", "description": "Spiraling penguins\n", "tags": ["spiral", "logarithmic", "penguin"], "likes": 17, "viewed": 301, "published": 3, "date": "1642080238", "time_retrieved": "2024-07-30T17:10:22.905943", "image_code": "// \"Penguins Spiraling\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, fAng, spd[2];\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float dMin, float dir, float rScl)\n{  // (\"Sliding Penguins\")\n  vec3 q;\n  float d, dh, szFac;\n  szFac = 0.08;\n  p /= szFac;\n  dMin /= szFac;\n  q = p;\n  q.y -= 0.5;\n  d = PrSphDf (q, 2.5);\n  if (d < 0.1) {\n    p.xz *= dir;\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (3);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.6, -1.05);\n    q.yz = Rot2D (q.yz, -0.5 * pi);\n    q.y -= -0.6;\n    d = PrCylDf (q.xzy, 0.12, 0.7);\n    DMINQ (4);\n    q -= vec3 (0.1, -0.67, -0.4);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, -0.2);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n    DMINQ (6);\n  } else dMin = min (dMin, d);\n  return 0.8 * dMin * rScl * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a, rScl, dc ;\n  dMin = dstFar;\n  r = length (p.xz);\n  if (r > 0.1) {  // (\"Spiraling In and Out\")\n    q = p;\n    a = (r > 0.) ? atan (q.z, q.x) / pi : 0.;\n    q.xz = mod (vec2 (0.5 * (pi * log (r) - a), -5. * a) + 0.5, 1.) - 0.5;\n    q.y /= sqrt (r);\n    if (r > 1.) q.y /= log (r);\n    q.y -= 0.16;\n    rScl = 0.25 * r;\n    dc = length (vec2 (abs (q.x) - 0.25, q.y)) - 0.16;\n    if (r > 1.) {\n      for (int k = VAR_ZERO; k < 2; k ++) {\n        dMin = PengDf (vec3 (q.x + 0.25 * sign (float (k) - 0.5), q.y + 0.01, mod (q.z +\n           spd[k] * tCur + 0.5, 1.) - 0.5), dMin, sign (spd[k]), rScl);\n      }\n    }\n    d = rScl * SmoothMax (abs (dc) - 0.015, q.y + 0.05, 0.02);\n    DMINQ (7);\n  }\n  q = p;\n  d = max (0., q.y);\n  DMINQ (8);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, grCol4;\n  vec3 col, vn;\n  vec2 q;\n  float dstObj, r, a;\n  spd[0] = 0.2;\n  spd[1] = -0.15;\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (16. * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    grCol4 = vec4 (1., 1., 1., 0.1) * (0.85 + 0.15 * Fbm2 (8. * ro.xz));;\n    vn = ObjNf (ro);\n    if (idObj == 7 || idObj == 8) {\n      q = ro.xz;\n      r = length (q);\n      if (r > 0.) {\n        a = atan (q.y, q.x) / pi;\n        q = mod (vec2 (0.5 * (pi * log (r) - a), -5. * a) + 0.5, 1.) - 0.5;\n      }\n    }\n    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z > 0.4 && abs (qHit.x) < 0.08 ||\n       qHit.z < 0.4 && length (qHit.xy) < 0.2) ? vec4 (0.9, 0.9, 0.95, 0.1) :\n       vec4 (0.2, 0.2, 0.25, 0.1);\n    else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n    else if (idObj == 3) col4 = vec4 (0.2, 0.2, 1., -1.);\n    else if (idObj == 4) col4 = vec4 (0.85, 0.85, 0.2, 0.2);\n    else if (idObj == 5) col4 = vec4 (0.95, 0.95, 0., 0.2);\n    else if (idObj == 6) col4 = vec4 (0.2, 0.2, 0.25, 0.1);\n    else if (idObj == 7) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.05) * (0.93 + 0.07 * cos (64. * pi * qHit.x));\n      if (r > 0.1 && min (length (vec2 (q.x - 0.25, mod (q.y + spd[0] * tCur + 0.5, 1.) - 0.5)),\n         length (vec2 (q.x + 0.25, mod (q.y + spd[1] * tCur + 0.5, 1.) - 0.5))) < 0.12) col4 *= 0.7;\n    } else if (idObj == 8) {\n      col4 = grCol4;\n      if (r > 0.1 && abs (abs (q.x) - 0.25) < 0.15) col4 *= 0.7;\n    }\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    col = mix (grCol4.rgb, col, smoothstep (1., 1.5, length (ro.xz)));\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.25 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, -0.15 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 2.1;\n  dstFar = 200.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfyW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[756, 756, 814, 839, 2376], [2378, 2378, 2400, 2400, 3185], [3187, 3187, 3220, 3220, 3403], [3405, 3405, 3426, 3426, 3681], [3683, 3683, 3718, 3718, 5650], [5652, 5652, 5708, 5708, 6817], [6819, 6819, 6852, 6852, 6879], [6881, 6881, 6923, 6923, 6974], [6976, 6976, 7011, 7011, 7073], [7075, 7075, 7120, 7120, 7212], [7214, 7214, 7259, 7259, 7297], [7299, 7299, 7356, 7356, 7439], [7441, 7441, 7477, 7477, 7683], [7685, 7685, 7715, 7715, 7828], [7862, 7862, 7886, 7886, 7998], [8000, 8000, 8025, 8025, 8211], [8213, 8213, 8234, 8234, 8389]], "test": "untested"}
{"id": "NdfcWN", "name": "Image warp", "author": "ersh", "description": "Image warp", "tags": ["2d", "warp", "lsd"], "likes": 1, "viewed": 228, "published": 3, "date": "1642072297", "time_retrieved": "2024-07-30T17:10:23.710791", "image_code": "mat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float size = iResolution.x / (25.0 + pow(sin(iTime/5.5),9.)*10.);\n  float angle = iTime / 10.0;\n  float kx = sin(iTime/1.)/(iResolution.x*1.3*(1.-pow(sin(iTime/15.),5.)));\n  float ky = pow(sin(iTime/1.4),3.)/(iResolution.x*1.3*(1.-pow(sin(iTime/22.),7.)));\n  fragCoord = fragCoord.xy - iResolution.xy / 2.0;\n  float stretch_x = fragCoord.x - iResolution.x * 1.5 / 2.0 * sin(iTime/11.);\n  float stretch_y = fragCoord.y - iResolution.y * 1.5 / 2.0 * sin(iTime/19.);\n  vec2 p = fragCoord.xy * rotate2d(angle + kx*stretch_x - ky*stretch_y);\n  vec2 pmod = vec2(mod(p.x, size * 2.0), mod(p.y, size * 2.0));\n  float k = max(pmod.x, pmod.y)/size/2.;\n  fragColor = texture(iChannel0, p/iResolution.xy - vec2(0.5,0.5));\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 74], [76, 76, 131, 131, 845]], "test": "untested"}
{"id": "NdfyWN", "name": "Sponge Cells", "author": "ersh", "description": "Trippy thing", "tags": ["procedural", "2d", "fx", "lsd"], "likes": 5, "viewed": 256, "published": 3, "date": "1642070771", "time_retrieved": "2024-07-30T17:10:24.576477", "image_code": "mat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float size = iResolution.x / (25.0 + pow(sin(iTime/5.5),9.)*10.);\n  float angle = iTime / 10.0;\n  float kx = sin(iTime/1.)/(iResolution.x*1.3*(1.-pow(sin(iTime/15.),5.)));\n  float ky = pow(sin(iTime/1.4),3.)/(iResolution.x*1.3*(1.-pow(sin(iTime/22.),7.)));\n  fragCoord = fragCoord.xy - iResolution.xy / 2.0;\n  float stretch_x = fragCoord.x - iResolution.x * 1.5 / 2.0 * sin(iTime/11.);\n  float stretch_y = fragCoord.y - iResolution.y * 1.5 / 2.0 * sin(iTime/19.);\n  vec2 p = fragCoord.xy * rotate2d(angle + kx*stretch_x - ky*stretch_y);\n  vec2 pmod = vec2(mod(p.x, size * 2.0), mod(p.y, size * 2.0));\n  float k = max(pmod.x, pmod.y)/size/2.;\n  fragColor = vec4(vec3(k), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 74], [76, 76, 131, 131, 811]], "test": "untested"}
{"id": "7sfyW8", "name": "Genuary 2022 - Day13", "author": "z0rg", "description": "My participation to genuary 2022\n800x80", "tags": ["genuary", "800x80", "2022"], "likes": 8, "viewed": 230, "published": 3, "date": "1642068296", "time_retrieved": "2024-07-30T17:10:25.440168", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nvec3 rdrr(vec2 uv, vec2 ouv)\n{\n    vec3 col;\n    float shp = iResolution.x*.5;\n    \n    \n    float rep = 0.02;\n    vec2 idx = floor((uv+rep*.5)/vec2(rep));\n    \n\n    float minLoad = -23.;\n    float maxLoad = 23.;\n    \n    float load = mix(minLoad, maxLoad, (sin(iTime)*.5+.5));\n    \n    if (idx.x > minLoad && idx.x < load && abs(idx.y) < 2.)\n    {\n        uv = mod(uv+.5*rep, vec2(rep))-rep*.5;\n        float sqr = _sqr(uv, vec2(rep * .1));\n        col = mix(col, vec3(1.), 1.-sat(sqr*shp));\n    }\n    float border = abs(_sqr(ouv, vec2(23.*rep, 2.*rep)))-rep*.1;\n    col = mix(col, vec3(1.), 1.-sat(border*shp));\n    \n    return col;    \n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    vec2 dir = vec2(0.,1.);\n    float dist = 0.007*sin(uv.x*15.+iTime*2.);\n    \n    col.r = rdrr(uv+dir*dist, uv).r;\n    col.g = rdrr(uv, uv).g;\n    col.b = rdrr(uv-dir*dist, uv).b;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    col = mix(col, 1.-col, sin(uv.x*2.+iTime)*.5+.5);\n    float border = _sqr(uv, vec2(.47,.05));\n    col *= 1.-sat(border*iResolution.x);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfyW8.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 458, 458, 509], [511, 511, 541, 541, 1151], [1153, 1153, 1172, 1172, 1386], [1388, 1388, 1445, 1445, 1708]], "test": "untested"}
{"id": "ssfyR4", "name": "Double Orbit Trapping", "author": "amhall", "description": "Mandelbrot set colored with a combination of smooth iteration count and orbit trapping. Each orbit is trapped to two different shapes, one used for points in the set and the other for points not in the set. Mouse to change color and outer orbit shape.", "tags": ["2d", "fractal", "mouse", "mandelbrot", "orbit", "trap"], "likes": 14, "viewed": 559, "published": 3, "date": "1642060566", "time_retrieved": "2024-07-30T17:10:26.289896", "image_code": "// Mandelbrot set in which orbits are simultaneously trapped to two different shapes.\n// Whether the point is inside or outside the set determines which shape is used for\n// coloring. Mouse x changes the the shape, mouse y offsets the color.\n\n// The goal of this was for regions in the set to be a little more spicy than the\n// classic pitch black look. I couldn't figure out a good way to color the inside but\n// I think if it were done well, it would make for some beautiful renders.\n\n// This doesn't work as well away from the x axis unfortunately. Since those mini-\n// Mandelbrots aren't quite bilaterally symmetrical, there can be a lot of asymmetry\n// in the final orbit trap distances.\n\n// Created by Anthony Hall\n\n\n// Lower these to speed up\nconst int SS = 2;\nconst float maxIters = 600.0;\n\n// The amount of time spent on each shape variation\nconst float shapeDuration = 8.0;\n\nconst float scale = 0.25*0.00131604;\nconst vec2 center = vec2(-1.575705, 0.0);\n\nconst float pi  = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Globals set in mainImage\nfloat leafOrbitOffset; \nfloat orbitTrapInfluence;\nfloat colorOffset;\n\nvec2 complexMultiply(vec2 c1, vec2 c2) {\n    return vec2(\n    \tc1.x*c2.x - c1.y*c2.y,\n    \tc1.x*c2.y + c1.y*c2.x);\n}\n\n// \"Triangular\" distance from origin\nfloat triangleOrbit(vec2 point)\n{\n    point.y = abs(point.y);\n    return max(-point.x, dot(point, vec2(0.5, 0.5 * sqrt(3.0))));\n}\n\n// \"Leafular\" (??) distance from orgin for positive offset values only - still produces\n// interesting results with negative offset values\n// Increasing offset makes it less circular and more leaf-like\nfloat leafOrbit(vec2 point)\n{\n    point.y = abs(point.y);\n    point.y += leafOrbitOffset;\n    float leafDist = length(point) - leafOrbitOffset;\n    return leafDist;\n}\n\n// Oscillating \"glowing\" color band\nvec3 colorBand(float t, vec3 exponents)\n{\n    float phase = t * twoPi;\n    return pow(vec3(0.5 - 0.5 * cos(phase)), exponents);\n}\n\nvec3 mandelbrot(vec2 C)\n{\n    vec2 z = C; // Implicit first iteration\n    float zz; // z . z\n    float outerDist = 1e5; // Orbit trap outside the set\n    float innerDist = 1e5; // Orbit trap inside the set\n    float iters;\n    \n    // The magnitude at which we consider a point divergent. Higher values are better\n    // for the smooth iteration count method (so Z^2 becomes much more significant than C)\n    // at the cost of a few more iterations.\n    const float bound = 32.0;\n    \n    // This offset corrects the optimized version of the smooth iteration formula\n    // so it is equivalent to the non-optimized version\n    const float smoothOffset = -log2(log2(bound)) - 1.0;\n    \n    for (iters = 1.0; iters < maxIters; iters ++)\n    {\n        z = complexMultiply(z, z) + C;\n        zz = dot(z, z);\n        if (zz > bound * bound)\n            break;\n        \n        // This is a really weird function but it produces a good result\n        outerDist = min(outerDist, \n            log( 0.4 * abs( log( abs( log( leafOrbit(5.0 * z) ) ) ) ) + 0.04) );\n        innerDist = min(innerDist, triangleOrbit(z));\n    }\n    if (iters == maxIters) // In set\n    {  \n        //float t = log(innerDist + 0.00002) - 0.12 * iTime + 0.6; // old\n        float t = 300.0 * innerDist - 0.075 * iTime + 0.45;\n        return colorBand(t, vec3(6.0, 20.0, 1.5));\n    }\n    else // Not in set\n    {\n        // See Inigo Quilez's article on smooth iteration count\n        // https://iquilezles.org/articles/msetsmooth\n        // Orbit distance gets added slightly to the smooth iteration count\n        float smoothIters = iters - (log2(log2(zz)) + smoothOffset);\n        float t = -0.25 * orbitTrapInfluence * outerDist\n            + 0.9 * log2(smoothIters) + 0.5 * (1.0 - orbitTrapInfluence) + colorOffset;\n        return colorBand(t, vec3(10.0, 2.5, 0.75));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Oscillate between different orbit trap shapes based on time/mouse\n    const float[3] offsets = float[3](-2.1, 1.6, -1.0);\n    float shape;\n    if (iMouse.z > 0.0)\n    {\n        shape = 3.0 * iMouse.x / iResolution.x;\n        colorOffset = iMouse.y / iResolution.y - 0.5;\n    }\n    else\n    {\n        shape = mod(iTime / shapeDuration + 0.2, 3.0);\n        colorOffset = 0.0;\n    }   \n    leafOrbitOffset = offsets[int(shape)] + 0.4 * fract(shape);\n    orbitTrapInfluence = smoothstep(0.0, 0.2, 0.5 - abs(fract(shape) - 0.5));     \n\n    const float theta = -0.3;\n    const mat2 transform = scale * mat2(\n        cos(theta), sin(theta),\n        -sin(theta), cos(theta));\n\n    vec3 color = vec3(0.0);\n    for (int y = 0; y < SS; y++)\n    {\n        for (int x = 0; x < SS; x++)\n        {\n            const float increment = 1.0 / float(SS);\n            const float offset = 0.5 * increment - 0.5;\n            vec2 newFragCoord = fragCoord + offset + increment * vec2(x, y);\n            vec2 uv = (2.0 * newFragCoord - iResolution.xy) / iResolution.y;\n            \n            vec2 C = center + transform * uv;\n            color += mandelbrot(C);\n        }\n    }\n    color /= float(SS * SS);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1134, 1134, 1174, 1174, 1250], [1252, 1289, 1322, 1322, 1418], [1420, 1622, 1651, 1651, 1788], [1790, 1826, 1867, 1867, 1955], [1957, 1957, 1982, 1982, 3803]], "test": "untested"}
{"id": "7slyDH", "name": "verbose mandelbrot", "author": "Zi7ar21", "description": "yeetus", "tags": ["fractal", "mandelbrot", "verbose", "didactic"], "likes": 8, "viewed": 245, "published": 3, "date": "1642051741", "time_retrieved": "2024-07-30T17:10:27.069810", "image_code": "// Using the name \"ITERATIONS\" anywhere will be replaced with this number.\n// In this case, it controls the maximum number of iterations our mandelbrot can go for.\n#define ITERATIONS 256\n\n// this is Shadertoy's own way of rendering,\n// traditional GLSL has different ways of\n// input/output.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize fragColor- this is the output pixel color\n    // vec4() constructs a 4-component vector, which in this case is Red, Green, Blue, and Alpha.\n    // Alpha is unused by Shadertoy but it is reccomended it gets set to 1.0.\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // normalize pixel coordinates- subtracting half of the resolution\n    // moves the point (0, 0) to the center of the canvas. Dividing by\n    // the resolution normalizes the coordinates, so that the bottom left\n    // corner is (-0.5, -0.5) and the top right corner is (0.5, 0.5)\n    /* vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.xy; */\n    // we will divide by the maximum resolution to fix the aspect ratio.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // multiply uv by 4, this is just to \"zoom\" out so we can see the full mandelbrot set\n    //uv *= 4.0;\n\n    // Zoom animation, iTime is Shadertoy's time input\n    // repeat after 30 seconds because we reach the limits of floating-point precision\n    uv *= 4.0 / exp( 0.5 * mod(iTime, 30.0) );\n\n    // Center on the desired coordinates to zoom in on\n    uv += vec2(-0.8216345, 0.2000020);\n\n    // define z (our mandelbrot set orbit)\n    // the first iteration will just add c, so we can skip it by setting z to c (uv in our case)\n    vec2 z = uv;\n\n    for(int i = 0; i < ITERATIONS; i++) // for loop that runs ITERATIONS times\n    {\n        //if(length(z) > 2.0) // mandelbrot set bailout condition- check if the orbit \"escaped\"\n        // we will replace length() with dot() (which is length squared) because it's faster on the GPU\n        // since it skips the use of sqrt(), which is expensive. Don't worry too much about it.\n        if(dot(z, z) > 2.0 * 2.0)\n        {\n            // Set the Red, Green, and Blue components of the pixel color to\n            // a color based on how many iterations the mandelbrot set orbit\n            // lasted. vec3() converts a float to a 3-component vector.\n            fragColor.rgb = vec3( float(i) / float(ITERATIONS) );\n\n            return; // exits mainImage()\n        }\n\n        // mandelbrot set formula: z = z^2 + c\n        // vectors aren't complex numbers and so we need to do this ourself.\n        // the real component is represented by X and the imaginary one by Y.\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + uv;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 292, 349, 585, 2740]], "test": "untested"}
{"id": "sslcD8", "name": "menger up", "author": "jorge2017a2", "description": "menger up", "tags": ["mengerup"], "likes": 10, "viewed": 217, "published": 3, "date": "1642042644", "time_retrieved": "2024-07-30T17:10:27.834765", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n#define MENGER_ITERATIONS\t3\nvec4 map(in vec3 p)\n{\tvec3 p0=p;\n    p.z= opRep1D(p.z, 2.0 );\n    p.y= opRep1D(p.y, 2.0 );\n    p= rotate_x( p,radians(45.0));\n    float d1 =sdBox( p, vec3(1.0,1.0,1.0) );\n    float d=d1;\n    vec4 res = vec4(d, 2.0, 0.0, 0.0);\n\t\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 4.5;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.3) / s;\n\n        if(c > d)\n        {   d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n    vec4 v4= map(p);\n    res =opU3(res, vec3(v4.x,100.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    //{ vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n    { vec3 col=tex3D(iChannel0, p/1., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*0.5,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-2.0, 1.0, -1.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(2.0, 0.5, 0.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   \n    vec3 ro=vec3(0.0,4.65+t,28.06);\n   \n   ro= rotate_x( ro,radians(45.0));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(30.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslcD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 530, 530, 614], [616, 660, 707, 707, 734], [735, 735, 778, 778, 805], [806, 806, 854, 854, 882], [883, 921, 957, 957, 1002], [1003, 1068, 1102, 1102, 1198], [1199, 1199, 1233, 1233, 1324], [1325, 1325, 1359, 1359, 1450], [1451, 1451, 1485, 1485, 1580], [1610, 1610, 1631, 1631, 2305], [2307, 2307, 2332, 2332, 2461], [2463, 2463, 2487, 2487, 2649], [2651, 2651, 2700, 2700, 3367], [3369, 3369, 3405, 3405, 3650], [3653, 3653, 3690, 3690, 3966], [3968, 3968, 4051, 4051, 4630], [4632, 4632, 4681, 4681, 4988], [4990, 4990, 5083, 5083, 5213], [5215, 5215, 5247, 5247, 5444], [5447, 5447, 5540, 5540, 5858], [5861, 5861, 5888, 5888, 5998], [6000, 6000, 6058, 6058, 6110], [6113, 6113, 6136, 6136, 6276], [6279, 6279, 6310, 6310, 7022], [7025, 7025, 7082, 7082, 7684]], "test": "untested"}
{"id": "7ssyD8", "name": "menger building", "author": "jorge2017a2", "description": "menger building", "tags": ["mengerbuilding"], "likes": 21, "viewed": 262, "published": 3, "date": "1642042183", "time_retrieved": "2024-07-30T17:10:28.607699", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\nfloat t1, t2;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox2D(vec2 p, vec2 b) {\n\tvec2  di = abs(p) - b;\n    float mc = max(di.x,di.y);\n    return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox2D(p.xy,vec2(1.0));\n  float db = sdBox2D(p.yz,vec2(1.0));\n  float dc = sdBox2D(p.zx,vec2(1.0));\n  return min(da,min(db,dc));\n}\n\n#define iterations 4.0  //5.0\n\nfloat MengerSponge(vec3 p) \n{  if (t1<t2)\n    p.y= opRep1D(p.y, 1.0 );\n   else\n    p.z= opRep1D(p.z, 1.0 );\n    \n    float d = sdBox(p,vec3(1.0));\n    \n    for (float i = 0.0; i < iterations; i++) \n    {   float scale = pow(2.0,i);\n        vec3 q = mod(scale*p,2.0)-1.0;\n        q = 1.0-abs(q);\n        float c = sdCross(q*3.0)/(scale*3.0);\n        d = max(d,-c),1.0;\n        p += scale/3.0;\n   }\n    return d;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.y=p.y-5.0;\n    \n    float d1=MengerSponge(p);\n    res =opU3(res, vec3(d1,100.0,-1.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    //{ vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n    //{ vec3 col=tex3D(iChannel0, p/0.25, nor); return col*2.0; }\n    //por Shane\n    // Using the \"Wood\" texture.\n    if (i==100){\n    \n       // Normal based UV coordinates.\n       vec2 uv = abs(nor.x)>.5? p.yz : abs(nor.y)>.5? p.xz : p.xy;\n       // Color sample, followed by rough sRGB to linear conversion.\n       vec3 col = texture(iChannel0, uv*2.).xyz; col *= col;\n       // Second layer at a higher frequency, if you wanted.\n       vec3 col2 = texture(iChannel0, uv*4. + .35).xyz; col2 *= col2;\n       col = mix(col, col2, .75); // Mixing the two layers.\n       // Smoothstep is a handy way to tweak the texture tone.\n       col = smoothstep(-.2, .6, col); \n       return col;\n}\n\n    \n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 linear2srgb(vec3 c) \n{   return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=1.7+0.3*sin(iTime);\n   float veltime=10.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,0.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*0.5,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-10.0, 20.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, 10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro,rd;\n   \n   t1=mod(iTime,3.0);\n   t2=mod(iTime,5.0);\n   \n   if (t1<t2)\n   {\n    ro=vec3(0.0,5.0+t,0.0);\n    rd=normalize( vec3(uv.x,uv.y,1.0)); \n    Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n   }\n   else\n   {\n    ro=vec3(0.0+0.5*sin(iTime),5.0,-1.0+t);\n    rd=normalize( vec3(uv.x,uv.y,1.0)); \n   }\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 513, 549, 549, 570], [571, 571, 603, 603, 687], [689, 733, 780, 780, 807], [808, 808, 851, 851, 878], [879, 879, 927, 927, 955], [956, 994, 1030, 1030, 1075], [1076, 1141, 1175, 1175, 1271], [1272, 1272, 1306, 1306, 1397], [1398, 1398, 1432, 1432, 1523], [1524, 1524, 1558, 1558, 1653], [1655, 1655, 1686, 1686, 1783], [1785, 1785, 1813, 1813, 1958], [1991, 1991, 2020, 2020, 2403], [2405, 2405, 2430, 2430, 2680], [2682, 2682, 2706, 2706, 2868], [2870, 2870, 2919, 2919, 3586], [3589, 3589, 3625, 3625, 3870], [3873, 3873, 3910, 3910, 4186], [4188, 4188, 4271, 4271, 4850], [4852, 4852, 4901, 4901, 5840], [5842, 5842, 5935, 5935, 6065], [6067, 6067, 6099, 6099, 6296], [6298, 6346, 6374, 6374, 6562], [6564, 6564, 6611, 6611, 6842], [6844, 6844, 6937, 6937, 7369], [7371, 7371, 7398, 7398, 7506], [7508, 7508, 7566, 7566, 7618], [7621, 7621, 7644, 7644, 7784], [7787, 7787, 7818, 7818, 8530], [8532, 8532, 8569, 8569, 8852], [8855, 8855, 8912, 8912, 9685]], "test": "untested"}
{"id": "NssyDr", "name": "Rigid Polygons", "author": "wyatt", "description": "I was trying to get the corners to snap together like magnetic toy blocks ", "tags": ["physics"], "likes": 24, "viewed": 459, "published": 3, "date": "1642036609", "time_retrieved": "2024-07-30T17:10:29.670856", "image_code": "Main\n    //if (I%8>0)discard;\n    Q = -.3+B(2.*U);\n    for (float i = 0.; i < N; i++) {\n        vec4 p = A(vec2(i,0)+.5);\n        vec4 v = A(vec2(i,1)+.5);\n        vec2 no = vec2(0);\n        float l = dNgon(U,p,no);\n        Q += exp(-l*l);\n        if (l < 0.) Q = vec4(.6+.4*no.x/l)*(1.-.5*sin(1.+.05*i+vec4(1,2,3,4)));\n        for (float j = 0.; j < p.w; j++){\n            vec2 u = p.xy+W/(2.*sin(pi/p.w))*an(p.z+2.*pi*j/p.w);\n            Q += (1.-.2*(U.x-u.x))*(mod(j,2.)*2.-1.)*exp(-.5*length(U-u));\n            \n        }\n     }\n    Q = 1.-Q;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I; vec4 M;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define pi 3.14159265359\n\n#define Main void mainImage(out vec4 Q, in vec2 U) {R=iResolution.xy;T=iTime;I=iFrame;M=iMouse;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define an(a) vec2(cos(a),sin(a))\n#define N 51.\n#define W (.06*R.x)\n#define dt .2\n#define G 2e-2\n#define F -ca*cb*ab/l*( 2.-l )/(1.+.5*l*l)\n#define L .999\nvec2 vel (vec2 r, vec4 v) {\n    if (length(r)>0.) r = vec2(-r.y,r.x);\n    return v.xy + r*v.z;\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    return \n    sign(dot(p-a,vec2(a.y-b.y,b.x-a.x)))*\n    length(p-a-(b-a)*\n    clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.))+4.;\n}\n\nfloat Ngon (vec2 p, vec4 g) {\n    float d = 1e9;\n    float r = W/(2.*sin(pi/g.w));\n    for (float i = 0.; i < g.w; i++) {\n        vec2 a = g.xy + r*an(g.z+2.*pi*i/g.w);\n        vec2 b = g.xy + r*an(g.z+2.*pi*(i+1.)/g.w);\n        d = min(d,sg(p,a,b));\n    }\n    return -d;\n}\n\nfloat dNgon (vec2 p, vec4 g, inout vec2 no) {\n    float d = 1e9;\n    float r = W/(2.*sin(pi/g.w));\n    for (float i = 0.; i < g.w; i++) {\n        vec2 a = g.xy + r*an(g.z+2.*pi*i/g.w);\n        vec2 b = g.xy + r*an(g.z+2.*pi*(i+1.)/g.w);\n        float s = sg(p,a,b);\n        if (s < d)\n            d = s, no = .4*s*normalize(vec2(a.y-b.y,b.x-a.x));\n    }\n    return -d;\n}\n", "buffer_a_code": "Main\n\n    if (U.y>2.) discard;\n    float x = floor(U.x);\n    float y = floor(U.y);\n    vec4 p = A(vec2(x,0)+.5);\n    vec4 v = A(vec2(x,1)+.5);\n    vec4 f = vec4(0);\n    float h = 0.;\n    float r1 = W/(2.*sin(pi/p.w));\n    for (float i = 0.; i < N; i++) if (i!=x)\n    {\n        vec4 P = A(vec2(i,0)+.5);\n        vec4 V = A(vec2(i,1)+.5);\n        vec2 no = vec2(0);\n        float r2 = W/(2.*sin(pi/P.w));\n        if (p.y<R.y&&P.y<R.y)\n        \n        if (length(p.xy-P.xy)>4.*(r2+r1)) continue;\n        // Snap together force :\n        for (float j = 0.; j < p.w; j++) {\n            float ca = mod(j+x,2.)*2.-1.;\n            vec2 a = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            for (float k = 0.; k < P.w; k++) {\n                float cb = mod(k+i,2.)*2.-1.;\n                vec2 b = P.xy+r2*an(P.z+2.*pi*k/P.w);\n                vec2 r = p.xy-a;\n                vec2 ab = b-a;\n                float l = length(ab);\n                vec2 im = F;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n            }\n        }\n        if (length(p.xy-P.xy)>1.*(r2+r1)) continue;\n        if (Ngon(p.xy,P)<0.) continue;\n        // My point in them :\n        for (float j = 0.; j < p.w; j++) {\n            vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            float m = dNgon(u,P,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = -2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n        \n        // Their piont in me :\n        for (float j = 0.; j < P.w; j++) {\n            vec2 u = P.xy+r2*an(P.z+2.*pi*j/P.w);\n            float m = dNgon(u,p,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = 2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n    }\n    // Walls \n    for (float j = 0.; j < p.w; j++) {\n        vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n        vec2 r = u-p.xy;\n        vec2 im = vec2(0);\n        if (u.x<0.)im.x=1./dt;\n        if (u.y<0.)im.y=1./dt;\n        if (u.x>R.x)im.x=-1./dt;\n        //if(T>100.) if (u.y>R.y)im.y=-1./dt;\n        if (length(im)>0.) {\n            f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n            f.xy += im*abs(dot(normalize(r),normalize(im)));\n            f.xy *= .9;\n            h += 1.;\n        }\n    }\n    if (h>0.) f/=h;\n    f.y -= G;\n    v += dt*f;\n    p += dt*(f+v);\n    v *= L;\n    if (M.z>0.) v.xy += 3e-3*(p.xy-M.xy)*exp(-.01*length(p.xy-M.xy));\n    if (I<1) {\n        p = vec4(.5*R.x,2.*W*(1.+x),0,max(mod(x,8.),3.));\n        v = vec4(0,0,.01,0);\n    }\n    \n    \n    if (y==0.) Q = p;\n    if (y==1.) Q = v;\n    \n    \n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n\n    if (U.y>2.) discard;\n    float x = floor(U.x);\n    float y = floor(U.y);\n    vec4 p = A(vec2(x,0)+.5);\n    vec4 v = A(vec2(x,1)+.5);\n    vec4 f = vec4(0);\n    float h = 0.;\n    float r1 = W/(2.*sin(pi/p.w));\n    for (float i = 0.; i < N; i++) if (i!=x)\n    {\n        vec4 P = A(vec2(i,0)+.5);\n        vec4 V = A(vec2(i,1)+.5);\n        vec2 no = vec2(0);\n        float r2 = W/(2.*sin(pi/P.w));\n        if (p.y<R.y&&P.y<R.y)\n        \n        if (length(p.xy-P.xy)>4.*(r2+r1)) continue;\n        // Snap together force :\n        for (float j = 0.; j < p.w; j++) {\n            float ca = mod(j+x,2.)*2.-1.;\n            vec2 a = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            for (float k = 0.; k < P.w; k++) {\n                float cb = mod(k+i,2.)*2.-1.;\n                vec2 b = P.xy+r2*an(P.z+2.*pi*k/P.w);\n                vec2 r = p.xy-a;\n                vec2 ab = b-a;\n                float l = length(ab);\n                vec2 im = F;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n            }\n        }\n        if (length(p.xy-P.xy)>1.*(r2+r1)) continue;\n        if (Ngon(p.xy,P)<0.) continue;\n        // My point in them :\n        for (float j = 0.; j < p.w; j++) {\n            vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            float m = dNgon(u,P,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = -2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n        \n        // Their piont in me :\n        for (float j = 0.; j < P.w; j++) {\n            vec2 u = P.xy+r2*an(P.z+2.*pi*j/P.w);\n            float m = dNgon(u,p,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = 2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n    }\n    // Walls \n    for (float j = 0.; j < p.w; j++) {\n        vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n        vec2 r = u-p.xy;\n        vec2 im = vec2(0);\n        if (u.x<0.)im.x=1./dt;\n        if (u.y<0.)im.y=1./dt;\n        if (u.x>R.x)im.x=-1./dt;\n        //if(T>100.) if (u.y>R.y)im.y=-1./dt;\n        if (length(im)>0.) {\n            f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n            f.xy += im*abs(dot(normalize(r),normalize(im)));\n            f.xy *= .9;\n            h += 1.;\n        }\n    }\n    if (h>0.) f/=h;\n    f.y -= G;\n    v += dt*f;\n    p += dt*(f+v);\n    v *= L;\n    if (M.z>0.) v.xy += 3e-3*(p.xy-M.xy)*exp(-.01*length(p.xy-M.xy));\n    if (I<1) {\n        p = vec4(.5*R.x,2.*W*(1.+x),0,max(mod(x,8.),3.));\n        v = vec4(0,0,.01,0);\n    }\n    \n    \n    if (y==0.) Q = p;\n    if (y==1.) Q = v;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n\n    if (U.y>2.) discard;\n    float x = floor(U.x);\n    float y = floor(U.y);\n    vec4 p = A(vec2(x,0)+.5);\n    vec4 v = A(vec2(x,1)+.5);\n    vec4 f = vec4(0);\n    float h = 0.;\n    float r1 = W/(2.*sin(pi/p.w));\n    for (float i = 0.; i < N; i++) if (i!=x)\n    {\n        vec4 P = A(vec2(i,0)+.5);\n        vec4 V = A(vec2(i,1)+.5);\n        vec2 no = vec2(0);\n        float r2 = W/(2.*sin(pi/P.w));\n        if (p.y<R.y&&P.y<R.y)\n        \n        if (length(p.xy-P.xy)>4.*(r2+r1)) continue;\n        // Snap together force :\n        for (float j = 0.; j < p.w; j++) {\n            float ca = mod(j+x,2.)*2.-1.;\n            vec2 a = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            for (float k = 0.; k < P.w; k++) {\n                float cb = mod(k+i,2.)*2.-1.;\n                vec2 b = P.xy+r2*an(P.z+2.*pi*k/P.w);\n                vec2 r = p.xy-a;\n                vec2 ab = b-a;\n                float l = length(ab);\n                vec2 im = F;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n            }\n        }\n        if (length(p.xy-P.xy)>1.*(r2+r1)) continue;\n        if (Ngon(p.xy,P)<0.) continue;\n        // My point in them :\n        for (float j = 0.; j < p.w; j++) {\n            vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            float m = dNgon(u,P,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = -2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n        \n        // Their piont in me :\n        for (float j = 0.; j < P.w; j++) {\n            vec2 u = P.xy+r2*an(P.z+2.*pi*j/P.w);\n            float m = dNgon(u,p,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = 2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n    }\n    // Walls \n    for (float j = 0.; j < p.w; j++) {\n        vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n        vec2 r = u-p.xy;\n        vec2 im = vec2(0);\n        if (u.x<0.)im.x=1./dt;\n        if (u.y<0.)im.y=1./dt;\n        if (u.x>R.x)im.x=-1./dt;\n        //if(T>100.) if (u.y>R.y)im.y=-1./dt;\n        if (length(im)>0.) {\n            f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n            f.xy += im*abs(dot(normalize(r),normalize(im)));\n            f.xy *= .9;\n            h += 1.;\n        }\n    }\n    if (h>0.) f/=h;\n    f.y -= G;\n    v += dt*f;\n    p += dt*(f+v);\n    v *= L;\n    if (M.z>0.) v.xy += 3e-3*(p.xy-M.xy)*exp(-.01*length(p.xy-M.xy));\n    if (I<1) {\n        p = vec4(.5*R.x,2.*W*(1.+x),0,max(mod(x,8.),3.));\n        v = vec4(0,0,.01,0);\n    }\n    \n    \n    if (y==0.) Q = p;\n    if (y==1.) Q = v;\n    \n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n\n    if (U.y>2.) discard;\n    float x = floor(U.x);\n    float y = floor(U.y);\n    vec4 p = A(vec2(x,0)+.5);\n    vec4 v = A(vec2(x,1)+.5);\n    vec4 f = vec4(0);\n    float h = 0.;\n    float r1 = W/(2.*sin(pi/p.w));\n    for (float i = 0.; i < N; i++) if (i!=x)\n    {\n        vec4 P = A(vec2(i,0)+.5);\n        vec4 V = A(vec2(i,1)+.5);\n        vec2 no = vec2(0);\n        float r2 = W/(2.*sin(pi/P.w));\n        if (p.y<R.y&&P.y<R.y)\n        \n        if (length(p.xy-P.xy)>4.*(r2+r1)) continue;\n        // Snap together force :\n        for (float j = 0.; j < p.w; j++) {\n            float ca = mod(j+x,2.)*2.-1.;\n            vec2 a = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            for (float k = 0.; k < P.w; k++) {\n                float cb = mod(k+i,2.)*2.-1.;\n                vec2 b = P.xy+r2*an(P.z+2.*pi*k/P.w);\n                vec2 r = p.xy-a;\n                vec2 ab = b-a;\n                float l = length(ab);\n                vec2 im = F;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n            }\n        }\n        if (length(p.xy-P.xy)>1.*(r2+r1)) continue;\n        if (Ngon(p.xy,P)<0.) continue;\n        // My point in them :\n        for (float j = 0.; j < p.w; j++) {\n            vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n            float m = dNgon(u,P,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = -2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(p.w*W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n        \n        // Their piont in me :\n        for (float j = 0.; j < P.w; j++) {\n            vec2 u = P.xy+r2*an(P.z+2.*pi*j/P.w);\n            float m = dNgon(u,p,no);\n            if (m < 0.) {\n                vec2 r = u-p.xy;\n                vec2 dv = vel(r,V)-vel(r,v);\n                float l = length(r);\n                vec2 im = 2.*no/dt+dv;\n                f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n                f.xy += im*abs(dot(normalize(r),normalize(im)));\n                f.xy += .5*(V-v).xy*smoothstep(2.,1.,length(im));\n                h += 1.;\n            }\n        }\n    }\n    // Walls \n    for (float j = 0.; j < p.w; j++) {\n        vec2 u = p.xy+r1*an(p.z+2.*pi*j/p.w);\n        vec2 r = u-p.xy;\n        vec2 im = vec2(0);\n        if (u.x<0.)im.x=1./dt;\n        if (u.y<0.)im.y=1./dt;\n        if (u.x>R.x)im.x=-1./dt;\n        //if(T>100.) if (u.y>R.y)im.y=-1./dt;\n        if (length(im)>0.) {\n            f.z -= dot(r,vec2(-im.y,im.x))/(W*W);\n            f.xy += im*abs(dot(normalize(r),normalize(im)));\n            f.xy *= .9;\n            h += 1.;\n        }\n    }\n    if (h>0.) f/=h;\n    f.y -= G;\n    v += dt*f;\n    p += dt*(f+v);\n    v *= L;\n    if (M.z>0.) v.xy += 3e-3*(p.xy-M.xy)*exp(-.01*length(p.xy-M.xy));\n    if (I<1) {\n        p = vec4(.5*R.x,2.*W*(1.+x),0,max(mod(x,8.),3.));\n        v = vec4(0,0,.01,0);\n    }\n    \n    \n    if (y==0.) Q = p;\n    if (y==1.) Q = v;\n    \n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fslcDH", "name": "Flying through infinite cubes", "author": "ninofiliu", "description": "Raymarched a modulo'd cube and added an offset depending on the time on the ray origin", "tags": ["raymarching", "simple", "cube", "inifinity"], "likes": 2, "viewed": 265, "published": 3, "date": "1642032722", "time_retrieved": "2024-07-30T17:10:30.539534", "image_code": "float STEP = 0.99;\nfloat MAX_DIST = 100.;\nfloat SURFACE_DIST = 0.0001;\nfloat NORMAL_DIST = 0.00001;\nvec3 MOD_CENTER = vec3(0., 0., -5.);\nfloat MOD_SIZE = 7.;\n\nstruct Marched {\n    vec3 w; // marched position, modulo'd\n    vec3 n; // surface normal\n    float d; // distance from scene\n    float md; // marched distance\n};\n\n/** \n * Signed distance from a point `w` to a plane defined by a point `p` and a normal `n`\n */\nfloat distPlane(vec3 w, vec3 p, vec3 n) {\n    return dot(n, w-p);\n}\n\n/** \n * The scene is a cube centered at `center`\n * The `radius` is the distance from `center` to any face\n * Faces are contained in infinite planes defined by `normals`\n * A point on each face is derived from existing variables\n * Like any concave polygon, the distance from it to a point\n * is the max of signed distance to infinite face planes\n */\nfloat distScene(vec3 w) {\n    vec3 center = vec3(0., 0., -5.);\n    float radius = .8;\n    vec3 normals[6];\n    normals[0] = vec3(0., sin(iTime), cos(iTime));\n    normals[1] = vec3(1., 0., 0.);\n    normals[2] = cross(normals[0], normals[1]);\n    for (int i = 0; i < 3; i++) {\n        normals[3+i] = -normals[i];\n    }\n    \n    float d = 0.;\n    for (int i = 0; i < 6; i++) {\n        d = max(d, distPlane(w, center + normals[i] * radius, normals[i]));\n    }\n    \n    return d;\n}\n\nMarched march(vec3 ray) {\n    vec3 w = vec3(\n        mod(iTime, MOD_SIZE),\n        mod(2.*iTime, MOD_SIZE),\n        mod(-5.*iTime, MOD_SIZE)\n    );\n    float md = 0.;\n    float d = distScene(w);\n    int i = 0;\n    while (i < 1000 && d > SURFACE_DIST && d < MAX_DIST) {\n        w += ray * d * STEP;\n        md += d * STEP;\n        for (int j = 0; j < 3; j++) {\n            float offset = -MOD_CENTER[j] + MOD_SIZE / 2.;\n            w[j] = mod(w[j] + offset, MOD_SIZE) - offset;\n        }\n        d = distScene(w);\n        i++;\n    }\n    // Computes the normal based on distance from nearby points\n    // https://computergraphics.stackexchange.com/a/8097/17336\n    float dwx = distScene(w + vec3(NORMAL_DIST, 0., 0.));\n    float dwy = distScene(w + vec3(0., NORMAL_DIST, 0.));\n    float dwz = distScene(w + vec3(0., 0., NORMAL_DIST));\n    vec3 n = (vec3(dwx, dwy, dwz) - d) / NORMAL_DIST;\n    \n    return Marched(w, n, d, md);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    // Camera is at (0,0,0) and looks towards (0,0,-1)\n    vec3 ray = normalize(vec3(\n        (coord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y),\n        -1.\n    ));\n    Marched m = march(ray);\n    float light =\n        // light from a vertical source\n        // objects do not cast shadows\n        (0.5 + 0.5 * dot(m.n, vec3(0., 1., 0.)))\n        // darken far away objects\n        / (1. + .05 * m.md)\n        // adjusts brightness\n        * 2.;\n    color = vec4(vec3(light), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 418, 459, 459, 485], [487, 838, 863, 863, 1314], [1316, 1316, 1341, 1341, 2242], [2244, 2244, 2291, 2346, 2789]], "test": "untested"}
{"id": "NdlcDH", "name": "Pixel to Hex", "author": "qtiki", "description": "Pixel to hex test.", "tags": ["hex"], "likes": 0, "viewed": 27, "published": 3, "date": "1642032327", "time_retrieved": "2024-07-30T17:10:31.408211", "image_code": "struct Hex {\n    float q;\n    float r;\n    float s;\n};\n\nstruct Orientation {\n    float f0;\n    float f1;\n    float f2;\n    float f3;\n    float b0;\n    float b1;\n    float b2;\n    float b3;\n    float start_angle;\n};\n\nconst Orientation PointyOrientation = Orientation(sqrt(3.0), sqrt(3.0) / 2.0, 0.0, 3.0 / 2.0, sqrt(3.0) / 3.0, -1.0 / 3.0, 0.0, 2.0 / 3.0, 0.5);\nconst Orientation FlatOrientation = Orientation(3.0 / 2.0, 0.0, sqrt(3.0) / 2.0, sqrt(3.0), 2.0 / 3.0, 0.0, -1.0 / 3.0, sqrt(3.0) / 3.0, 0.0);\n\n#define POINTY\n\nvoid pixelToHex(out Hex hex, in vec2 p, in vec2 size, in vec2 origin) {\n    vec2 pt = vec2((p.x - origin.x) / size.x, (p.y - origin.y) / size.y);\n#ifdef POINTY\n    Orientation M = PointyOrientation;\n#else\n    Orientation M = FlatOrientation;\n#endif\n    hex.q = M.b0 * pt.x + M.b1 * pt.y;\n    hex.r = M.b2 * pt.x + M.b3 * pt.y;\n    hex.s = -hex.q - hex.r;\n}\n\nvoid roundHex(inout Hex hex) {\n    float qi = round(hex.q);\n    float ri = round(hex.r);\n    float si = round(hex.s);\n    float q_diff = abs(qi - hex.q);\n    float r_diff = abs(ri - hex.r);\n    float s_diff = abs(si - hex.s);\n    if (q_diff > r_diff && q_diff > s_diff)\n    {\n        qi = -ri - si;\n    }\n    else\n        if (r_diff > s_diff)\n        {\n            ri = -qi - si;\n        }\n        else\n        {\n            si = -qi - ri;\n        }\n    hex.q = qi;\n    hex.r = ri;\n    hex.s = si;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 size = vec2(50.0, 30.0);\n    vec2 origin = vec2(iResolution) / 2.0;\n    \n    origin += vec2(\n        sin(iTime * 0.5) * 500.0,\n        cos(iTime * 0.52) * 500.0\n    );\n\n    Hex hex = Hex(0.0, 0.0, 0.0);\n    \n    pixelToHex(hex, fragCoord, size, origin);\n    roundHex(hex);\n    \n    vec3 color = vec3(\n        sin(hex.q * 1.0) * 0.5 + 0.5,\n        sin(hex.r * 1.0) * 0.5 + 0.5,\n        sin(hex.s * 1.0) * 0.5 + 0.5\n    );\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 592, 592, 877], [879, 879, 909, 909, 1378], [1380, 1380, 1435, 1435, 1906]], "test": "untested"}
{"id": "fdsyD8", "name": "Mandelbrot Set Visualiser", "author": "xiving", "description": "Visualises the Mandelbrot set and the underlying iterations used for calculating the Mandelbrot set. More info on the Mandelbrot set and how its calculations can be implemented, can be found here: https://en.wikipedia.org/wiki/Mandelbrot_set", "tags": ["math", "mandelbrot", "visualiser"], "likes": 2, "viewed": 228, "published": 3, "date": "1642023080", "time_retrieved": "2024-07-30T17:10:32.275891", "image_code": "#define PI 3.1415926538\n\nstruct INum {\n    float R;\n    float I;\n};\n\nint modI(float a,float b) {\n    float m=a-floor((a+0.5)/b)*b;\n    return int(floor(m+0.5));\n}\n\nINum iPow(INum num) {\n    return INum(num.R * num.R - num.I * -1.0, num.R * num.I * 2.0);\n}\n\nINum iAdd(INum num1, INum num2) {\n    return INum(num1.R + num2.R, num1.I + num2.I);\n}\n\nbool inBounds(INum num, float threshold) {\n    if (num.R > 0.0) {\n        if (num.R >= threshold) {\n            return false;\n        }\n    } else {\n        if (num.R <= threshold * -1.0) {\n            return false;\n        }\n    }\n    \n    if (num.I == 0.0) {\n        if (num.I >= threshold) {\n            return false;\n        }\n    } else {\n        if (num.I <= threshold * -1.0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nbool converges(INum c, float threshold, int n) {\n    INum z = INum(0.0, 0.0);\n    \n    for (int i = 0; i < n; i++) {\n        z = iAdd(iPow(z), c);\n        \n        if (!inBounds(z, threshold)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nfloat mandelbrotX(float x, float zoom) {\n    float offset = -1.4855;\n    return ((((x / iResolution.x) * (2.47) - (2.0)) - offset) / zoom) + offset;\n}\n\nfloat mandelbrotY(float y, float zoom) {\n    return ((y / (iResolution.y)) * 2.24 - 1.12) / zoom;\n}\n\nint mandelbrot(float x, float y, int maxIterations, float zoom) { \n   float x0 = mandelbrotX(x, zoom);\n   float y0 = mandelbrotY(y, zoom);\n   \n   x = 0.0;\n   y = 0.0;\n   \n   float xX = 0.0;\n   float yY = 0.0;\n   \n   int iteration = 0;\n   \n   while(xX + yY <= 4.0 && iteration < maxIterations) {\n       y = 2.0 * x * y + y0;\n       x = xX - yY + x0;\n       xX = x * x;\n       yY = y * y;\n       iteration = iteration + 1;\n   }\n   \n   return iteration;\n}\n\nvec3 mandelbrotColor(int iterations, int maxIterations) {\n    float d = float(iterations) / float(maxIterations);\n    \n    float red = clamp(sin(PI * d * 0.5), 0.2, 1.0 );\n    float green = clamp(sin(PI * d), 0.2, 1.0);\n    float blue = clamp(cos(PI * d * 0.5), 0.2, 1.0);\n    \n    d = sqrt(0.05 + (0.95  * d));\n    \n    return vec3(d * red, d * green, d * blue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float framesPerIteration = 10.0;\n   float iDelta = float(iFrame) / framesPerIteration;\n   \n   float zoom = pow((float(iFrame) * 0.005), 2.0);\n   \n   if (zoom <= 1.0) {\n       zoom = 1.0;\n   }\n   \n   int maxIteration = int(floor(iDelta)) + 1;\n   float delta = iDelta - float(maxIteration - 1);\n   \n   if (maxIteration > 200) {\n       maxIteration = 200;\n       delta = 0.0;\n   }\n\n   vec3 color = vec3(0.0, 0.0, 0.0);\n   int i0 = mandelbrot(fragCoord.x, fragCoord.y, maxIteration, zoom);\n   \n   if (i0 != maxIteration) {\n      int i1 = mandelbrot(fragCoord.x, fragCoord.y, maxIteration + 1, zoom);\n      \n      vec3 i0Color = mandelbrotColor(i0, maxIteration);\n      vec3 i1Color = mandelbrotColor(i1, maxIteration + 1);\n      \n      color = (i0Color * (1.0 - delta)) + (i1Color * delta);\n   }\n   \n   fragColor = vec4(color, 1.0);\n}\n \n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 162], [164, 164, 185, 185, 255], [257, 257, 290, 290, 343], [345, 345, 387, 387, 795], [797, 797, 845, 845, 1057], [1059, 1059, 1099, 1099, 1209], [1211, 1211, 1251, 1251, 1310], [1312, 1312, 1377, 1377, 1764], [1766, 1766, 1823, 1823, 2131]], "test": "untested"}
{"id": "NdlyD8", "name": "[ the floating blob ]", "author": "SimonOakey", "description": "This shader is part of MACHINEPAINTING. This series sets the machine both as aesthetical tool and material in an artistic way. work in progress!\n\ninfo here: https://tristanschulze.de/?p=4226", "tags": ["circle", "blob", "liquid", "viscocity"], "likes": 12, "viewed": 540, "published": 3, "date": "1642022927", "time_retrieved": "2024-07-30T17:10:33.129608", "image_code": "// ------------------------------------------------------------\n// ----  licenced under love, peace and happiness  ------\n// ------------------------------------------------------------\n// ------------- MACHINEPAINTING -----------------\n// ------------------------------------------------------------\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nfloat time;\n\nconst vec3 col1 = vec3(0.);\nconst vec3 col2 = vec3(1.0);\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nfloat sdCircle(vec2 pos, float radius) {\nreturn length(pos) - radius;\n}\n\nvec2 translate(vec2 pos, vec2 offset) {\nreturn pos - offset;\n}\n\nfloat random(float v){\nreturn fract(sin(v*1223.42454));\n}\n\nfloat opUnion(float a, float b){\nreturn min(a,b);\n}\nfloat opSmoothUnion(float d1, float d2, float k) {\nreturn -log2(exp2(-k * d1) + exp2(-k * d2)) / k;\n}\n\n\nfloat random2 (vec2 st) {\nreturn fract(sin(dot(st.xy,vec2(1.9898,178.233)))*4378.5453123);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n   time = iTime;\n   \n   const int N = 9;\nfloat _time = time*.3;\nvec2 positions[N];\nfloat _spread = sin(_time*2.3)*.5+.5;\nfloat _speed = sin(_time*5.)*.5+.5;\nfloat _blobby = sin(_time*1.3)*.5+.5;\nfloat _viscocity = sin(_time*1.3)*.5+.5;\nfloat _blobradius = sin(_time*1.3)*.5+.5;\n\n\nvec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\npos *= 4.0; // zoom\nfloat d = 1e7;\n\n\nfor (float i = 1.0; i < float(N); i++) {\n\n\nfor(int j = 0; j < 2; j++){\npositions[int(i)].x += (.5+_spread) * random2(vec2(i, j)) * sin(10.1 * _time * random2(vec2(j, i)));\npositions[int(i)].y += (.5+_spread) * random2(vec2(i * i, j)) * cos(10.1 * _time * random2(vec2(i, j * j)));\n}\n\n\nfloat radius = mix(0.14*(_blobradius*.3+.5), .14*(_blobradius*.3+.5), .4+_blobby*random(i))*.01;\nfloat cd = sdCircle(translate(pos, positions[int(i)]), radius + .1+random(i)*.61);\nd = opSmoothUnion(d, cd, 2.+ _viscocity*18.) ;\n}\n\nfloat val = (d);\n\n// val = fract(sin(val*12.));\n\nval = smoothstep(.5,.52,val)+.2;\n\nval += d*.3;\n\nval = min(1.0,val);\nval -=.2;\n\n// dithering\nval -= random2(vec2(pos.x,pos.y+time*.01))*.02;\n\n\nvec3 col = vec3(val);\n\n\nfragColor = vec4(col, 1.0);\n   \n   \n   \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlyD8.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[452, 452, 475, 475, 531], [533, 533, 573, 573, 604], [606, 606, 645, 645, 668], [670, 670, 692, 692, 727], [729, 729, 761, 761, 780], [781, 781, 831, 831, 882], [885, 885, 910, 910, 977], [981, 981, 1038, 1088, 2308]], "test": "untested"}
{"id": "7dXcW8", "name": "Spiral fractal", "author": "vipiao", "description": "A helix spiral with a ball pattern.", "tags": ["raymarching", "reflection", "control", "infinite"], "likes": 11, "viewed": 266, "published": 3, "date": "1642012456", "time_retrieved": "2024-07-30T17:10:33.891571", "image_code": "\n# define MAX_NUM_STEPS 200\n# define PI 3.1415926538\n# define EXPONENT 4.\n# define MAX_DEPTH 8.\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\n\nfloat sdSphereWorld(in vec3 pos){\n    pos = mod(pos, 1.0);\n    return sdSphere(pos, vec3(0.5), 0.5);\n}\n\nvec3 normalSphereWorld(in vec3 pos){\n    float sd = sdSphereWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdSphereWorld(pos - e.xyy),\n    \tsdSphereWorld(pos - e.yxy),\n    \tsdSphereWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nfloat sdSpiral(in vec3 pos){\n    float radius = 1.;\n    vec3 pos1 = vec3(cos(pos.z)*radius, sin(pos.z)*radius, pos.z);\n    float angle = atan(pos.y, pos.x);\n    float offset = pos.z / PI / 2. - angle / PI / 2.;\n    vec3 pos2 = vec3(\n        pos.xy / length(pos.xy)*radius,\n        pos.z + abs(offset - round(offset)) * PI * 2.\n    );\n    float rr = length(pos - (pos1 + pos2) / 2.0);\n    float sd = rr-0.4;\n    \n    return sd*0.5;\n}\n\nvec3 normalsdSpiral(in vec3 pos){\n    float sd = sdSpiral(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdSpiral(pos - e.xyy),\n    \tsdSpiral(pos - e.yxy),\n    \tsdSpiral(pos - e.yyx)\n    ));\n    return normal;\n}\n\nfloat sdTotalWorld(in vec3 pos, float resolution){\n\n    \n    // Modulus repeat.\n    float size = 100.;\n    pos.xy = mod(pos.xy + size*0.5, size) - size*0.5;\n    \n    // Add rotation.\n    float speed = 0.2;\n    float sine = sin(iTime*speed);\n    float cosine = cos(iTime*speed);\n    pos = vec3(\n        cosine * pos.x + sine * pos.y,\n        sine * pos.x - cosine * pos.y,\n        pos.z\n    );\n    \n    \n    float ss = sdSphereWorld(pos);\n    float ff = 1.0;\n    for(int i=0; i<int(resolution); i++){\n        ff *= EXPONENT;\n        ss = min(ss, sdSphereWorld(pos*ff)/ff);\n    }\n    ff *= EXPONENT;\n    ss = mix(\n        ss,\n        min(ss, sdSphereWorld(pos*ff)/ff),\n        mod(resolution, 1.)\n    );\n    return max(min(sdSpiral(pos), sdSpiral(vec3(pos.xy, pos.z - PI))), -ss);\n}\nvec3 normalSdTotalWorld(in vec3 pos, float resolution, float delta){\n    float sd = sdTotalWorld(pos, resolution);\n    vec2 e = vec2(delta, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdTotalWorld(pos - e.xyy, resolution),\n    \tsdTotalWorld(pos - e.yxy, resolution),\n    \tsdTotalWorld(pos - e.yyx, resolution)\n    ));\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rr = 3.;\n    float ss = 0.1;\n    vec3 cameraPos = vec3(sin(iTime*ss)*rr,cos(iTime*ss)*rr,-iTime*1.2);\n    vec3 forward = normalize(vec3(normalize(-cameraPos.xy), -1.8+1.4*sin(iTime*0.3)));\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    float zoom = 0.9;\n    vec3 viewDir = normalize(forward*0.8*zoom + right * uv.x + up * uv.y);\n    \n    float debug = 0.0;\n    \n    // Calculate color.\n    vec3 color = vec3(0.1,0,0);\n    vec3 reflectionConstant = vec3(1.0);\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.0;\n    float maxDist = 200.0;\n    int maxNumSteps = MAX_NUM_STEPS;\n    int numSteps = 0;\n    float minDist = 0.0001;\n    vec3 prevPos = pos;\n    float prevSD = 0.0;\n    float sd = 0.0;\n    bool shaddowMode = false;\n    float distToSurface = maxDist;\n    int numStepsToSurface = maxNumSteps;\n    for(; numSteps < maxNumSteps; numSteps++){\n        prevSD = sd;\n        float dd = shaddowMode? distToSurface: dist;\n        float resolution =  clamp(-log2(dd*0.003)/log2(EXPONENT), 0., MAX_DEPTH);\n        sd = sdTotalWorld(pos, resolution);\n        if(sd < minDist){\n            // Collision with sphere.\n            float backFactor = (minDist - sd) / (prevSD - sd);\n            pos = mix(pos, prevPos, backFactor);\n            sd *= (1.0-backFactor);\n            \n            vec3 normal = normalSdTotalWorld(pos, resolution, 0.001);\n            vec3 surfaceColor = vec3(1,1,0.9);\n            float ambient = 0.1;\n            if(shaddowMode){\n                color = surfaceColor * ambient;\n                //debug += 1.0;\n                break;\n            }\n            shaddowMode = true;\n            pos += normal * minDist;\n            const vec3 lightDir = normalize(vec3(1,1,2));\n            color = surfaceColor * (vec3(dot(lightDir, normal)) + ambient);\n            distToSurface = dist;\n            numStepsToSurface = numSteps;\n            dir = lightDir;\n            //debug += 1.;\n            //break;\n            //\n        }\n        const float brightnessFactor = 0.1;\n        if(dist + sd > maxDist){\n            dist = maxDist;\n            break;\n        }\n        prevPos = pos;\n        pos += normalize(dir) * sd;\n        dist += sd;\n    }\n    //debug += numStepsToSurface == numSteps? 1.:0.;\n    // Mist.\n    float fogFactor = max(\n        float(numStepsToSurface)/float(maxNumSteps),\n        distToSurface / maxDist\n    );\n    vec3 fogColor = mix(vec3(0.3,0.3,.6), vec3(0.1,0.1,.2), viewDir.z);\n    color = mix(color, fogColor, fogFactor);\n    color.r += debug;\n    //if(debug > 0.) color = vec3(1,0,0);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 158, 158, 200], [202, 202, 235, 235, 304], [306, 306, 342, 342, 573], [575, 575, 603, 603, 1007], [1009, 1009, 1042, 1042, 1253], [1255, 1255, 1305, 1334, 2035], [2036, 2036, 2104, 2104, 2379], [2381, 2381, 2438, 2438, 5296]], "test": "untested"}
{"id": "fsXyD8", "name": "Genuary 2022 - Day12", "author": "z0rg", "description": "My participation to genuary 2022\nPacking (squares, circles, any shape)", "tags": ["packing", "genuary", "2022"], "likes": 13, "viewed": 300, "published": 3, "date": "1642009577", "time_retrieved": "2024-07-30T17:10:34.646552", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x<b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float th = 0.01;\n    vec3 bSz = vec3(1.);\n    float box = abs(_cube(p, bSz))-th;\n    box = max(box, -_cube(p-vec3(0.,-th*3.,0.), bSz));\n    acc = _min(acc, vec2(box,0.));\n    \n    float flapH = bSz.z/2.;\n    vec3 pFlap =p;\n    pFlap.z = -abs(pFlap.z);\n    pFlap -= vec3(0.,-bSz.y+.1,-bSz.z - flapH);\n    pFlap.yz *= r2d(-.25);\n    float flap = _cube(pFlap, vec3(bSz.x, th, flapH));\n    //flap = max(flap, abs(uv.x)-.1*uv.z);\n    acc = _min(acc, vec2(flap,0.));\n    \n    for (int i = 0; i < 16; ++i)\n    {\n        float fi = float(i);\n        vec2 dir = vec2(sin(fi), cos(fi));\n        float fCube = mod(fi*.1+iTime,1.5);\n        float spread = pow(fCube, 0.25f);\n        vec3 pos = p-vec3(mod(fi*.1,.5), fCube*fCube-2.5, 0.0)\n        +vec3(dir.x, 0.0f, dir.y)*spread*.25;\n        pos.xy *= r2d(fi);\n        pos.xz *= r2d(fi);\n        acc = _min(acc, vec2(_cube(pos, vec3(.1)), 1.));\n    }\n    \n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x< 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.941,0.337,0.600)*pow(1.-sat(length(uv)-.2),.5);\n    float d= 10.;\n    float t=iTime*.5;\n    vec3 ro = vec3(sin(t)*d,-5.,cos(t)*d);\n    vec3 ta = vec3(0.,-1.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 lpos = vec3(8.,-5.,5.);\n        vec3 ldir = normalize(lpos-p);\n        float ndotl = dot(n,ldir);\n        if (res.z == 0.)\n        {\n            vec2 coords = p.xy*sat(abs(dot(n, vec3(0.,0.,1.))))\n            +p.zy*sat(abs(dot(n, vec3(1.,0.,0.))));\n            col = pow(texture(iChannel0, coords*.2).x,.025)*\n            vec3(0.831,0.545,0.306)+vec3(.2)*sat(ndotl);\n        }\n        if (res.z == 1.0)\n        {\n            col = vec3(.75)+vec3(.5)*sat(ndotl);\n        }\n        \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXyD8.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 449, 449, 506], [508, 508, 537, 537, 598], [600, 600, 627, 627, 678], [680, 680, 698, 698, 1652], [1654, 1654, 1685, 1685, 1816], [1818, 1818, 1859, 1859, 2077], [2079, 2079, 2110, 2110, 2224], [2226, 2226, 2245, 2245, 3164], [3166, 3166, 3223, 3223, 3346]], "test": "untested"}
{"id": "stc3DX", "name": "Les maths aiment la musique", "author": "byt3_m3chanic", "description": "As a coder I have a fear of algebra.", "tags": ["raymarching", "noise", "waves", "sketch"], "likes": 23, "viewed": 430, "published": 3, "date": "1642002135", "time_retrieved": "2024-07-30T17:10:35.473342", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Les maths aiment la musique\n    01/12/22 @byt3_m3chanic\n\n             .---.                                          \n            /. ./|               .---.           .--.--.    \n         .-'-. ' |  ,--.--.    /.  ./|  ,---.   /  /    '   \n        /___/ \\: | /       \\ .-' . ' | /     \\ |  :  /`./   \n     .-'.. '   ' ..--.  .-. /___/ \\: |/    /  ||  :  ;_     \n    /___/ \\:     ' \\__\\/: . .   \\  ' .    ' / | \\  \\    `.  \n    .   \\  ' .\\    ,\" .--.; |\\   \\   '   ;   /|  `----.   \\ \n     \\   \\   ' \\ |/  /  ,.  | \\   \\  '   |  / | /  /`--'  / \n      \\   \\  |--\";  :   .'   \\ \\   \\ |   :    |'--'.     /  \n       \\   \\ |   |  ,     .-./  '---\" \\   \\  /   `--'---'   \n        '---\"     `--`---'             `----'    \n        \n   just doing some waves on a surface with a floor/hue for color\n   still playing around with the hatching / sketch look. \n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    65.\n#define MIN_DIST    .0001\n\n// random var to alter waves\nfloat u_hash = .8123;\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec3 hue(float a) { return .55+.45*cos(PI2*a*(vec3(0.196,0.925,0.208)*vec3(.99,.97,.96))); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432);  }\n// @iq sdf \nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 g_hp,s_hp;\nfloat g_hsh,s_hsh,time;\n\nvec2 map(vec3 p) {\n    p.y+=1.75;\n    vec3 pq = p;\n    vec2 res = vec2(1e5,0.);\n\n    // make waves\n    float ter = .2*sin(length((p.xz)-vec2(.5*sin(T*.12)*.76,u_hash))*3.25+T*.75); \n          ter = exp(ter);\n          ter +=.2*cos(length((p.xz)+vec2(.5*sin(T*.2)*.776,u_hash))*3.00+T*1.50);  \n    p.y= abs(p.y)-2.;\n    p.y+=2.95+ter;\n    \n    // two caps\n    float pk = cap(p+vec3(0,2.5,0),4.15,5.);\n    float pz = cap(p+vec3(0,2.5,0),4.20,5.);\n    \n    if (pk < res.x) {\n        res=vec2(pk,2.5);\n        g_hp=p;\n        g_hsh=ter;\n    }\n    \n    if (pz < res.x) {\n        res=vec2(pz,4.5);\n        g_hp=p;\n        g_hsh=1.;\n    }\n    \n    // the sphere\n    float pl = length(pq-vec3(0,2.75+.5*sin(T*.5),0))-1.5;\n    if (pl < res.x) {\n        res=vec2(pl,5.5);\n        g_hp=p;\n        g_hsh=0.;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps, float sg) {\n    hit = false; float d=0., m = 0., dist = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<1e-4) hit = true;\n        m  = t.y;  \n        d += i<32? t.x*.75:t.x*.95;\n        p = ro + rd * d;\n        if(d>75.) break;\n    } \n    return vec2(d,m);\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.1325/3.75; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, .075, 1.);\n}\n\nvec3 FC = vec3(.015);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d, in vec2 F) {\n        \n    vec3 RC=vec3(0);\n\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p,hit,158,1.);\n    d = ray.x;\n    m = ray.y;\n    s_hp=g_hp;\n    s_hsh=g_hsh;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(-18.,8,-9);\n        vec3 l = normalize(lpos);\n        \n        float diff = clamp(dot(n,l),.2,1.);\n        float ao = calcAO(p,n);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 24.);\n        \n        float shdw = 1.,t=.1;\n        for( int i =1; i<20; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<1e-3 ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<.1 || t>45. ) break;\n        }\n        if(m==2.5) shdw=(shdw>.5 && mod(F.x,3.)!=mod(F.y,3.) ) ? .8:.05;\n        diff=mix(diff,diff*shdw,.75); \n\n        vec3 h = vec3(.25);\n\n        if(m== 2.5||m==5.5) ref=vec3(.55);\n        \n        ao=smoothstep(.2,.51,ao);\n        vec3 sdif = vec3(diff+.5);\n        diff=clamp((diff+.25)*ao,0.,1.);\n        \n        if(m==3.5) {sdif*=1.15;}\n        if(m==2.5) diff *=hue(floor(s_hsh*8.)*2.).r;\n        \n        if(diff<.5&&(mod(F.x,4.)==mod(F.y,4.))) sdif=sdif*.4;\n        if(diff<.175&&(mod(1.-F.y,4.)==mod(F.x,4.))) sdif=sdif*.35;\n        if(diff<.125&&(mod(F.x,1.)==mod(F.y,2.))) sdif=sdif*.3;\n        if(diff<.100&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif=sdif*.1;\n        if(diff<.015&&(mod(F.x,1.)==mod(F.y,1.))) sdif=sdif*.4;\n        \n        if(spec>.45&&(mod(F.x,4.)==mod(F.y,4.))) sdif+=.15;\n        if(spec>.65&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif+=.15;\n\n        RC = clamp(diff*1.25,0.,1.)*sdif;\n\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n    } \n    \n    return RC;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T;\n    \n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    \n    // pixel effect\n    //float pxg = 126.;\n    //uv = floor(uv*(pxg*R.x/R.y))/(pxg*R.x/R.y);pxg*=1.5;\n    \n    // background patterns\n    vec2 ft = fract((uv*2.)*rot(.78))-.5;\n    FC.xyz=mix(FC,vec3(.04),mod(floor(ft.x),3.)==0.?1.:0.);\n \n     // ortho camera\n    float zoom = 7.;\n    vec3 ro = vec3(uv*zoom,-zoom-2.5);\n    vec3 rd = vec3(0,-.05,1.);\n\n    // cam rotations\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*1.-.5)*PI;\n    mat2 rx =rot(.35);\n    mat2 ry =rot(.78+y);\n\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    // the loop and march or march and loop\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 3;\n    for(int i = 0; i < bnc + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,bnc-i,d,F);\n        C = mix(C,RC,fill);\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n\n    // back + fog\n    C = mix(C,FC, 1.-exp(-.00005*fA*fA*fA));\n\n    // hash it up\n    float hs = hash21(uv);\n    if(fract(hs*5.)>.65) C = clamp(C-.02,vec3(0),vec3(1));\n    if(hs>.75) C = clamp(C+.015,vec3(0),vec3(1));\n\n    // gamma out\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3DX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1171, 1171, 1190, 1190, 1235], [1236, 1236, 1255, 1255, 1328], [1329, 1329, 1351, 1351, 1408], [1409, 1421, 1459, 1459, 1566], [1609, 1609, 1627, 1627, 2433], [2435, 2445, 2475, 2475, 2709], [2711, 2711, 2794, 2794, 3072], [3074, 3086, 3121, 3121, 3384], [3408, 3408, 3502, 3502, 5254], [5256, 5256, 5297, 5297, 6576]], "test": "untested"}
{"id": "sssyDn", "name": "Fork Mandelbulb mclarekin 090", "author": "mclarekin", "description": "Learning shadertoy\nIQ's  Polynomial pow 8  Mandelbulb implementation. morph breathing. Approx DE", "tags": ["3d", "raymarching", "fractal", "distancefield"], "likes": 6, "viewed": 433, "published": 3, "date": "1641988654", "time_retrieved": "2024-07-30T17:10:36.238297", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n//\n// More info here: https://iquilezles.org/articles/mandelbulb\n//\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n\n// https://iquilezles.org/articles/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 z = p;\n     \n  //  vec3 c = p;\n    float m = dot(z,z);\n\n    vec4 trap = vec4(abs(z),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n//#if 0\n\tfloat tp = dot(z, z);\n    \n    float r = sqrt(tp);\n\ttp = tp * tp * tp * r;\n\tdz = tp * dz * 8.0 + 1.0;\n\t\n\tvec3 z2 = z * z;\n\tvec3 z4 = z2 * z2;\n    \n\tfloat k3 = z2.x + z2.y;\n\ttp = k3 * k3;\n\ttp = tp * tp * tp * k3;\n\t//float k2 = 1.0f / sqrt(tp);\n    float k = 3.0 - (sin(iTime*.8) + 1.0);\n\tfloat k2 = k / sqrt(tp);\n\tdz *= k;\n\ttp = z2.x * z2.y;\n\tfloat k1 = z4.x + z4.y + z4.z - 6.0f * z2.z * k3 + 2.0 * tp;\n\tfloat k4 = k3 - z2.z;\n\tfloat k12 = k1 * k2;\n\t//z.x = 64.0f * z.x * z.y * z.z * k4 * (z2.x - z2.y) * (z4.x - 6.0f * tp + z4.y) * k12;\n\t\n\tz.x = 64.0 * z.x * z.y * z.z * k4 * (z2.x - z2.y) * (z4.x - 6.0 * tp + z4.y) * k12;\n\tz.y = -8.0 * z.z * k4 * (z4.x * z4.x - 28.0 * tp * (z4.x + z4.y) + 70.0 * z4.x * z4.y + z4.y * z4.y) * k12;\n\n\tz.z = -16.0 * z2.z * k3 * k4 * k4 + k1 * k1;\n     z += p;   \n    \n/*#else\n\n\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 9.0*pow(m,4.0)*dz + 1.0;\n      \n        // z = z^8+z\n        float r = length(w);\n                float b = ( w.y/r);\n       b = 9.0*mix(acos(b), asin(b),.5*(cos(iTime*.1) + 1.0));\n        float a = 9.0*atan( w.x, w.z );\n        float sb = sin(b);\n        w = p + pow(r,9.0) * vec3(sb*sin(a), cos(b), sb*cos(a) );\n             \n\n    \n//#endif  */      \n        \n        trap = min( trap, vec4(abs(z),m) );\n\n        m = dot(z,z);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\nvec3 refVector( in vec3 v, in vec3 n )\n{\n    return v;\n    float k = dot(v,n);\n    //return (k>0.0) ? v : -v;\n    return (k>0.0) ? v : v-2.0*n*k;\n}\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n        \n        // lighting terms\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t, px );\n        \n        nor = refVector(nor,-rd);\n        \n        vec3  hal = normalize( light1-rd);\n        vec3  ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 12.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin +=  4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin +=  1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin +=  2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ);\n        \t lin +=  4.0*fac*occ;\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );\n        col += spe1*15.0;\n    }\n\n    // gamma\n\tcol = pow( col, vec3(0.4545) );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    // camera\n\t//float di = 1.4+0.1*cos(.29*time);\n    float di = 2.;\n\t//vec3  ro = di*vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n   vec3  ro = di*vec3(0.,1., 0.001 );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n  //float cr = 0.5*cos(0.1*time);\n  float cr = 0.0;\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    // render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssyDn.jpg", "access": "api", "license": "proprietary-license", "functions": [[1045, 1093, 1146, 1146, 1341], [1343, 1389, 1432, 1432, 3117], [3119, 3165, 3222, 3222, 3453], [3455, 3500, 3556, 3556, 3830], [3832, 3832, 3903, 3903, 4447], [4552, 4552, 4592, 4592, 4699], [4702, 4702, 4741, 4755, 6805], [6811, 6811, 6868, 6868, 7742]], "test": "untested"}
{"id": "7slyzM", "name": " - Log Popol Room", "author": "totetmatt", "description": "Log Popol", "tags": ["logpolar"], "likes": 13, "viewed": 285, "published": 3, "date": "1641975150", "time_retrieved": "2024-07-30T17:10:37.116947", "image_code": "\n/******\nInspiration and copy code from\n\nhttps://www.osar.fr/notes/logspherical/\nGaz https://www.shadertoy.com/user/gaz\n\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  vec4 pframe = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    // Output to screen\n    fragColor = vec4(min(pframe.xyz/pframe.a,vec3(1.,1.,1.)),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Gaz\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam(vec3 p,float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n//https://www.osar.fr/notes/logspherical/\nfloat logpol(vec3 p,float scale){\n\n    vec2 p2d = p.xz;\n    \n    float r = length(p2d);\n    \n    p2d = vec2(log(r),atan(p2d.y,p2d.x));\n \n    p2d *=scale;\n    vec2 id = floor(p2d);\n    p2d = fract(p2d)-.5;\n    float m = r/scale;\n    vec3 pp = vec3(p2d, p.y/m);\n    \n    float h = diam(pp+vec3(0,0.,0.),1.2);\n    h = min(length(pp.xz)-.1,h);\n    return h * m;\n}\n\nvec2 sdf(vec3 p){\n    p.y = -(abs(p.y)-3.1);\n    vec2 h;\n    h.x = logpol(p,3.);\n    h.y = 1.;\n    \n    h.x = smin(h.x,length(p)-.5,1.4);\n    return h;\n}\nfloat rand(float n){return fract(sin(n) * 995897.48484);}\n\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float a){vec2 e =vec2(-a,a);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5*iResolution.xy)/iResolution.y;\n    uv += vec2(rand(iTime),rand(iTime+rand(iTime)))*.001;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,2.*sin(iTime*.2),-3.)+1e-5;\n    ro.xz*=rot(iTime*.1);\n    vec3 rt = vec3(0.)+1e-5;\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.-log(1.5+length(uv))));\n    vec3 rp = ro;\n    \n    vec3 light = vec3(0.,01.,-0.);\n    float dd = 0.;\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        dd +=d.x;\n        rp +=d.x*rd;\n        if(dd>50.) break;\n        if(d.x<.0001){\n            vec3 n = norm(rp,.001);\n            vec3 n2 = norm(rp,.01);\n            float dif = max(0.,dot(normalize(light-rp),n));\n            float spc = pow(max(0.,dot(rd,reflect(normalize(light-rp),n))),12.);;\n            col = min(1.,dif)*vec3(.1)+spc*H(spc)+smoothstep(0.3,.6,pow(length(n-n2),.125));\n            break;\n        }\n    }\n    vec3 pcol = vec3(0.);\n    // Yolo\n    for(int x=-1;x<=1;x++){\n      for(int y=-1;y<=1;y++){ \n      if(y==x && x==0) continue;\n      pcol += texelFetch(iChannel0,ivec2(fragCoord.xy)+ivec2(x,y),0).rgb;\n    }}\n    pcol /=8.;\n    col  = mix(col,pcol*.9,.86)*sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slyzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1070, 1070, 1127, 1177, 1374]], "test": "untested"}
{"id": "NslcDn", "name": "Fork Fork Mande mclarekin 667", "author": "mclarekin", "description": "Learning shadertoy\nIQ's  Trig pow 9  Mandelbulb implementation. morph between cos and sin, through sphere c = 0", "tags": ["3d", "raymarching", "fractal", "distancefield"], "likes": 2, "viewed": 201, "published": 3, "date": "1641972441", "time_retrieved": "2024-07-30T17:10:37.979641", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n//\n// More info here: https://iquilezles.org/articles/mandelbulb\n//\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n\n// https://iquilezles.org/articles/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n     \n    vec3 c = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n/*#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else*/\n\n\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 9.0*pow(m,4.0)*dz + 1.0;\n      \n        // z = z^8+z\n        float r = length(w);\n                float b = ( w.y/r);\n       b = 9.0*mix(acos(b), asin(b),.5*(cos(iTime*.1) + 1.0));\n        float a = 9.0*atan( w.x, w.z );\n        float sb = sin(b);\n        c *= abs(mix(1., -1.,.5*(cos(iTime*.1) + 1.0)));\n        w = c + pow(r,9.0) * vec3(sb*sin(a), cos(b), sb*cos(a) );\n             \n\n    \n//#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\nvec3 refVector( in vec3 v, in vec3 n )\n{\n    return v;\n    float k = dot(v,n);\n    //return (k>0.0) ? v : -v;\n    return (k>0.0) ? v : v-2.0*n*k;\n}\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n        \n        // lighting terms\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t, px );\n        \n        nor = refVector(nor,-rd);\n        \n        vec3  hal = normalize( light1-rd);\n        vec3  ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 12.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin +=  4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin +=  1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin +=  2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ);\n        \t lin +=  4.0*fac*occ;\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );\n        col += spe1*15.0;\n    }\n\n    // gamma\n\tcol = pow( col, vec3(0.4545) );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    // camera\n\t//float di = 1.4+0.1*cos(.29*time);\n    float di = 2.5;\n\t//vec3  ro = di*vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n   vec3  ro = di*vec3(0.,0., 1. );\n\tvec3  ta = vec3(0.0,0.0,0.0);\n  //float cr = 0.5*cos(0.1*time);\n  float cr = 0.0;\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    // render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslcDn.jpg", "access": "api", "license": "proprietary-license", "functions": [[1045, 1093, 1146, 1146, 1341], [1343, 1389, 1432, 1432, 3094], [3096, 3142, 3199, 3199, 3430], [3432, 3477, 3533, 3533, 3807], [3809, 3809, 3880, 3880, 4424], [4529, 4529, 4569, 4569, 4676], [4679, 4679, 4718, 4732, 6782], [6788, 6788, 6845, 6845, 7717]], "test": "untested"}
{"id": "ssfyDn", "name": "Fork Mandelbulb mclarekin 606", "author": "mclarekin", "description": "Learning shadertoy\nIQ's  Trig pow 9  Mandelbulb implementation. morph between cos and sin", "tags": ["3d", "raymarching", "fractal", "distancefield"], "likes": 3, "viewed": 241, "published": 3, "date": "1641971613", "time_retrieved": "2024-07-30T17:10:38.865273", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n//\n// More info here: https://iquilezles.org/articles/mandelbulb\n//\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n\n// https://iquilezles.org/articles/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n     \n  //  vec3 c = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n/*#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else*/\n\n\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 9.0*pow(m,4.0)*dz + 1.0;\n      \n        // z = z^8+z\n        float r = length(w);\n                float b = ( w.y/r);\n       b = 9.0*mix(acos(b), asin(b),.5*(cos(iTime*.1) + 1.0));\n        float a = 9.0*atan( w.x, w.z );\n        float sb = sin(b);\n        w = p + pow(r,9.0) * vec3(sb*sin(a), cos(b), sb*cos(a) );\n             \n\n    \n//#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\nvec3 refVector( in vec3 v, in vec3 n )\n{\n    return v;\n    float k = dot(v,n);\n    //return (k>0.0) ? v : -v;\n    return (k>0.0) ? v : v-2.0*n*k;\n}\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n        \n        // lighting terms\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t, px );\n        \n        nor = refVector(nor,-rd);\n        \n        vec3  hal = normalize( light1-rd);\n        vec3  ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 12.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin +=  4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin +=  1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin +=  2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ);\n        \t lin +=  4.0*fac*occ;\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );\n        col += spe1*15.0;\n    }\n\n    // gamma\n\tcol = pow( col, vec3(0.4545) );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    // camera\n\t//float di = 1.4+0.1*cos(.29*time);\n    float di = 2.5;\n\t//vec3  ro = di*vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n   vec3  ro = di*vec3(0.,0., 1. );\n\tvec3  ta = vec3(0.0,0.0,0.0);\n  //float cr = 0.5*cos(0.1*time);\n  float cr = 0.0;\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    // render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfyDn.jpg", "access": "api", "license": "proprietary-license", "functions": [[1045, 1093, 1146, 1146, 1341], [1343, 1389, 1432, 1432, 3039], [3041, 3087, 3144, 3144, 3375], [3377, 3422, 3478, 3478, 3752], [3754, 3754, 3825, 3825, 4369], [4474, 4474, 4514, 4514, 4621], [4624, 4624, 4663, 4677, 6727], [6733, 6733, 6790, 6790, 7662]], "test": "untested"}
{"id": "tdtSzs", "name": "zickzack", "author": "lennyjpg", "description": "sdfsdfsdfsdfsdfsdfasdf", "tags": ["dfdfsasdfsdf"], "likes": 1, "viewed": 177, "published": 3, "date": "1641960619", "time_retrieved": "2024-07-30T17:10:39.733950", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y, s = vec2(.0),c = vec2(.0);    \n    vec2 f = fragCoord.xy;\n    float k = uv.x;\n    float t = iTime * 0.3;// * floor(uv.x * 100.0);\n    t+=sin(t*10.)*0.1;\n    f.y += 233.0;\n    float d = floor(uv.x * 10.0) + 0.5;\n    f.y+=uv.x*5000.0*(floor(mod(d,2.0)-1.0)+0.5);\n    float g = d * 20.0;\n    f.y += 1233.0 * g * t*.05;\n    k = sin(f.y / g);\n    k = floor(k+1.0);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 485]], "test": "untested"}
{"id": "fslyz7", "name": "Fractal Spiral Rope Thing", "author": "SnoopethDuckDuck", "description": "not much different from what its forked from. surprisingly fun technique", "tags": ["raymarching", "template", "artofcode"], "likes": 25, "viewed": 532, "published": 3, "date": "1641957822", "time_retrieved": "2024-07-30T17:10:40.500900", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat2 M(float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th));\n}\n\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat GetDist(vec3 p) {\n   // float time = 5. * p.y + 0.4 * iTime;\n    \n    vec2 uv = p.xz;\n    //uv -= 0.5 * vec2(cos(time), sin(time));\n    //uv = M(time) * uv;\n   // uv *= 1. +  sin(0.6 * length(uv) - 0. * iTime);\n    float th = 4. * p.y + 3.5 * length(uv) + .0 * iTime;//-0. * iTime;\n    uv = abs(M(th) * uv);\n    \n    float m = 0.2;\n    float n = 4.;\n    for (float i = 0.; i < n; i++) {\n       // th += 0.03 * length(p) / length(uv);\n        th = abs(th - m); // <- dont think this does anything\n       // th += 0. * iTime + 0. * p.y;\n        //th -= 0.5 * (1.-i/n) * thc(2., 4. * th - iTime);\n        uv = abs(M(th) * (uv - m));\n        m *= 0.28 + 0.25 * thc(2., 4. * p.y - pi * i/n - iTime);\n    }\n\n    float d = length(uv) - 0.2 * m;\n    //d = max(d, length(p + vec3(0., 0.08 * cos(iTime), 0.)) - 0.45);\n    //d = max(d, length(p) - 1.);\n    //float s = step(d, 1.4 * m);\n    \n    //float d = length(p.xz - 0.5 * vec2(cos(time), sin(time))) - 0.2;\n    \n    return 0.35 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 1.5;\n    float time = 0.2 * iTime;\n    vec3 ro = vec3(r * cos(time), 0.1 * iTime, r * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.1 * iTime,0), 1.2);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        col *= texture(iChannel0,r).rgb;\n        col *= 1.2 + r.y;//+ p.y;\n        //col *= 0.5 + 0.5 * thc(4., 12. * length(p) + 0.4 * iTime) * cos(4. * p.y + iTime);\n        //col *= 0.5 * (1. + thc(2., iTime + p.y * 4.));\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslyz7.jpg", "access": "api", "license": "mit", "functions": [[1474, 1474, 1493, 1493, 1555], [1557, 1557, 1575, 1575, 1631], [1653, 1653, 1682, 1682, 1723], [1725, 1725, 1748, 1791, 2710], [2712, 2712, 2746, 2746, 2957], [2959, 2959, 2983, 2983, 3173], [3175, 3175, 3225, 3225, 3416], [3418, 3418, 3475, 3475, 4408]], "test": "untested"}
{"id": "Ndc3Dn", "name": "Fast cheap pseudoangle", "author": "mkennan", "description": "Monotonically rises with angle, but doesn't use trig. Output is in [0.0, 1.0]. A fast and cheap way to order points correctly without actually computing the angles and with very little error.\n\n(r,g,b): (error * 100, pseudoangle, atan)", "tags": ["angle", "pseudoangle"], "likes": 4, "viewed": 202, "published": 3, "date": "1641947353", "time_retrieved": "2024-07-30T17:10:41.269844", "image_code": "#define PI  acos(-1.0)\n#define TAU (2.0 * PI)\n\nfloat pseudoAngle(float y, float x) {\n  float d = 0.25 * x / (abs(x) + abs(y));\n  if (y > 0.0)\n    return 0.75 - d;\n  return 0.25 + d;\n}\nfloat pseudoAngle(vec2 v) { return pseudoAngle(v.y, v.x); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2  uv  = fragCoord.xy / iResolution.xy - 0.5;\n  float soo = pseudoAngle(uv);             // g: pseudoangle\n  float ang = atan(uv.y,uv.x) / TAU + 0.5; // b: atan\n  float dif = abs(soo - ang) * 100.0;      // r: error * 100\n  \n                          fragColor = vec4(0.0, soo, 0.0, 1.0);\n  if (iFrame % 600 > 200) fragColor = vec4(0.0, 0.0, ang, 1.0);\n  if (iFrame % 600 > 400) fragColor = vec4(dif, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 84, 84, 183], [184, 184, 211, 211, 243], [245, 245, 300, 300, 724]], "test": "untested"}
{"id": "7tySWV", "name": "Ferrofluid Clock", "author": "ArmandB", "description": "a clock that looks like it's made of ferrofluid. move the mouse to change the light position.", "tags": ["mouse", "clock", "buffer"], "likes": 18, "viewed": 439, "published": 3, "date": "1641944406", "time_retrieved": "2024-07-30T17:10:42.145502", "image_code": "/*\n0: distance\n1: black\n2: sin of dist\n3: shaded\n4: displaced grid\n5: normals\n*/\nconst int mode = 3;\nbool cycleModes = false;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float pxunit = 1.0/iResolution.y*7.0;\n    int effectiveMode = mode;\n    \n    if (cycleModes == true){\n        effectiveMode = int(mod(iDate.w/5.0,6.0));\n    }\n    \n    if (effectiveMode == 1) { //black\n        col = vec3(mix(0.0, 1.0, smoothstep(thresh, thresh + pxunit*2.0, col.x)));\n    } else if (effectiveMode == 2) { //sin\n        col = sin(col*20.0);\n    } else if (effectiveMode == 3 || effectiveMode == 5) { //normals && shaded \n        float normScale = 0.1;\n        \n        vec3 p0 = vec3(0,thresh-col.x,0);\n        vec3 p1 = vec3(normScale,thresh-texture(iChannel0, uv + vec2(pxunit,0)).x,0);\n        vec3 p2 = vec3(0,thresh-texture(iChannel0, uv + vec2(0,pxunit)).x,normScale);\n        vec3 v1 = normalize(p1-p0);\n        vec3 v2 = normalize(p2-p0);\n        vec3 normal = cross(v1,v2);\n        if (effectiveMode == 3){ //shaded\n            vec3 lightpos = vec3(m.x,0.1,m.y);\n            vec3 light = normalize(vec3(uv.x,0,uv.y) - lightpos);\n            vec3 camray = normalize(vec3(0.5,1,0.5) - vec3(uv.x, col.x, uv.y));\n            vec3 color = vec3(0.6,0.1,0.0);\n            vec3 background = vec3(1.0,1.0,0.8);\n            \n            float mask = mix(1.0, 0.0, smoothstep(thresh, thresh + pxunit*2.0, col.x));\n            \n            float dotproduct = clamp(dot(light, normal),0.0,1.0);\n            vec3 reflectedRay = reflect(light, normal);\n            float specular = max(dot(reflectedRay, camray),0.0);\n            vec3 ambient = color * 0.4;\n            vec3 basecol = ambient + (specular * dotproduct * mask * color)/pow(distance(vec3(uv.x,0,uv.y),lightpos),2.0);\n            \n            col = mix(background, basecol, mask);\n            \n        } else { //normals\n            col = normal;\n        }\n    } else if (effectiveMode == 4) { //displaced grid\n        col = vec3(mix(col.x, 0.5+col.x/3.0, smoothstep(0.95, 1.0, sin(uv.y*200.0 + col.x*6.0))));\n        col = vec3(mix(col.x, 0.5+col.x/3.0, smoothstep(0.95, 1.0, sin(uv.x*200.0 + col.x*3.0))));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float thresh = 0.2;\n\nfloat smin(float a, float b) {\n  float k = 0.25;\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) -  h * h * k * (1.0 / 4.0);\n}\n\nfloat weightedPointToLineSegment(vec2 a, vec2 b, vec2 p) {\n  float l2 = (b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y);\n  float t = max(0.0, min(1.0, dot(p - a, b - a) / l2));\n  vec2 projection = a + t * (b - a);\n  return distance(p, projection) + smin(t, 1.0-t)/4.0; \n}\n\nfloat segment0(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,0), vec2(1,0), uv);\n}\nfloat segment1(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,1), vec2(1,1), uv);\n}\nfloat segment2(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,2), vec2(1,2), uv);\n}\nfloat segment3(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,0), vec2(0,1), uv);\n}\nfloat segment4(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,1), vec2(0,2), uv);\n}\nfloat segment5(vec2 uv) {\n    return weightedPointToLineSegment(vec2(1,0), vec2(1,1), uv);\n}\nfloat segment6(vec2 uv) {\n    return weightedPointToLineSegment(vec2(1,1), vec2(1,2), uv);\n}\nfloat segment7(vec2 uv) {\n    return weightedPointToLineSegment(vec2(0,0), vec2(0,2), uv);\n}\nfloat segment8(vec2 uv) {\n    return weightedPointToLineSegment(vec2(1,0), vec2(1,2), uv);\n}\n\nfloat zero(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment2(uv)),smin(segment3(uv),segment4(uv))),smin(segment5(uv),segment6(uv)));\n}\n\nfloat one(vec2 uv) {\n    return smin(segment3(uv),segment4(uv));\n}\n\nfloat two(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment3(uv))),segment6(uv));\n}\n\nfloat three(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment6(uv))),segment5(uv));\n}\n\nfloat four(vec2 uv) {\n    return smin(smin(segment1(uv),segment4(uv)),smin(segment5(uv),segment6(uv)));\n}\n\nfloat five(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment4(uv))),segment5(uv));\n}\n\nfloat six(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment4(uv))),smin(segment5(uv),segment3(uv)));\n}\n\nfloat seven(vec2 uv) {\n    return smin(smin(segment2(uv),segment5(uv)),segment6(uv));\n}\n\nfloat eight(vec2 uv) {\n    return smin(smin(smin(segment0(uv),segment1(uv)),smin(segment2(uv),segment4(uv))),smin(smin(segment6(uv),segment3(uv)), segment5(uv)));\n}\n\nfloat nine(vec2 uv) {\n    return smin(smin(segment1(uv),segment2(uv)),smin(smin(segment6(uv),segment5(uv)), segment4(uv)));\n}\n\nfloat colon(vec2 uv) {\n    return min(distance(vec2(0,0.25), uv), distance(vec2(0,1.75), uv));\n}\n\nfloat dist(int num, vec2 uv) {\n    if (num == 1) {\n        return one(uv);\n    } else if (num == 2) {\n        return two(uv);\n    } else if (num == 3) {\n        return three(uv);\n    } else if (num == 4) {\n        return four(uv);\n    } else if (num == 5) {\n        return five(uv);\n    } else if (num == 6) {\n        return six(uv);\n    } else if (num == 7) {\n        return seven(uv);\n    } else if (num == 8) {\n        return eight(uv);\n    } else if (num == 9) {\n        return nine(uv);\n    } else {\n        return zero(uv);\n    }\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*7.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv += vec2(-1, -1.2);\n\n    float seconds = iDate.w;\n    float minutes = seconds / 60.0;\n    float hours = minutes / 60.0;\n    float second = floor(mod(seconds, 60.0));\n    float minute = floor(mod(minutes, 60.0));\n    float hour = floor(mod(hours, 12.0));\n    \n    int sec1s = int(mod(second,10.0));\n    int sec10s = int(second/10.0);\n    int min1s = int(mod(minute,10.0));\n    int min10s = int(minute/10.0);\n    int hour1s = int(mod(hour,10.0));\n    int hour10s = int(hour/10.0);\n    \n    bool am = hours-1.0 < 12.0;\n    \n    vec3 col = vec3(1);\n        \n    float yoffset = 0.0;\n    \n    float mindist = 999.0;\n    \n    if (hour == 0.0){\n        mindist = min(mindist, dist(1, uv - vec2(0)));\n        yoffset += 1.0;\n        mindist = min(mindist, dist(2, uv - vec2(yoffset, 0)));\n        yoffset += 2.0;\n    } else {\n        if (hour10s != 0) {\n            mindist = min(mindist, dist(hour10s, uv - vec2(yoffset, 0)));\n            if (hour10s == 1) {\n                yoffset += 1.0;\n            } else {\n                yoffset += 2.0;\n            }\n        }\n        mindist = min(mindist, dist(hour1s, uv - vec2(yoffset, 0)));\n        if (hour1s == 1) {\n            yoffset += 1.0;\n        } else {\n            yoffset += 2.0;\n        }\n    }\n    \n    mindist = min(mindist, colon(uv - vec2(yoffset, 0)));\n    yoffset += 1.0;\n    \n    mindist = min(mindist, dist(min10s, uv - vec2(yoffset, 0)));\n    if (min10s == 1) {\n        yoffset += 1.0;\n    } else {\n        yoffset += 2.0;\n    }\n    mindist = min(mindist, dist(min1s, uv - vec2(yoffset, 0)));\n    if (min1s == 1) {\n        yoffset += 1.0;\n    } else {\n        yoffset += 2.0;\n    }\n            \n    mindist = min(mindist, dist(sec10s, (uv - vec2(yoffset, 0))/0.75));\n    if (sec10s == 1) {\n        yoffset += 1.0*0.75;\n    } else {\n        yoffset += 2.0*0.75;\n    }\n    mindist = min(mindist, dist(sec1s, (uv - vec2(yoffset, 0))/0.75));\n    \n    //test sphere\n    //mindist = min(mindist, -sqrt(1.0-pow(distance(vec2(3.0, 4.0),uv),2.0)));\n\n    col = (vec3(mindist) + texture(iChannel0, fragCoord/iResolution.xy).x*12.0)/13.0;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tySWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 184, 184, 2360]], "test": "untested"}
{"id": "7sXyDn", "name": "Sand Castles", "author": "SnoopethDuckDuck", "description": "using noise to cover up how horribly buggy this is", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 277, "published": 3, "date": "1641941692", "time_retrieved": "2024-07-30T17:10:42.918436", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n\n    vec2 uv = p.xz;\n    vec2 uv2 = Rot(0.005 *  h21(uv)) * vec2(p.x,p.z);\n    uv2 = abs(fract(uv2));\n    uv = mix(uv, uv2, 0.5 - 0.5 * thc(3., 0.3 * iTime));\n    //uv = uv2;\n    float sc = 4.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = sc * uv - ipos;\n    //p.y += 0.4 * cos(2. * pi * h21(ipos) + iTime);\n    float d = length(fpos) - 0.4;// * (0.5 + 0.5 * cos(iTime + 2. * pi * h21(ipos)));\n    \n    float n = 2. + ceil(4. + 8. * h21(ipos)) * (1. + thc(4., 0.2 * h21(uv) + 2. * pi * h21(ipos) + iTime));\n    d += ceil(n * 2. * p.y * (1.-p.y))/n;\n   \n    d = max(d, mlength(uv) - 0.5);\n    //float d = mlength(M(10. * p.y) * uv) - 0.1 - 0.1 * cos(10. * p.y);\n    \n    return 0.25 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 1.5;\n    float time = 0.2 * iTime;\n    vec3 ro = vec3(r * cos(time), 0.12, r * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,mix(0.05, 0.25, 0.5 - 0.5 * thc(3., 0.3 * iTime)),0), 4. + cos(0.4 * iTime));\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        col *= texture(iChannel0,r).rgb;\n        col *= 1.2 + r.y;//+ p.y;\n        col += (0.5 - 0.5 * thc(3., 0.3 * iTime)) * p.y * vec3(1.,0.5,1.);\n        //col *= 0.5 + 0.5 * thc(4., 12. * length(p) + 0.4 * iTime) * cos(4. * p.y + iTime);\n        //col *= 0.5 * (1. + thc(2., iTime + p.y * 4.));\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXyDn.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1581, 1581, 2279], [2281, 2281, 2315, 2315, 2526], [2528, 2528, 2552, 2552, 2742], [2744, 2744, 2794, 2794, 2985], [2987, 2987, 3044, 3044, 4101]], "test": "untested"}
{"id": "7dscRM", "name": "Genuary 2022 - Day10", "author": "z0rg", "description": "My participation to genuary 2022\nMachine learning, wrong answers only.", "tags": ["machinelearning", "genuary", "2022"], "likes": 11, "viewed": 320, "published": 3, "date": "1641931910", "time_retrieved": "2024-07-30T17:10:43.696356", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float f = 1.;\n    vec3 col = texture(iChannel0, (uv)*f+vec2(.5)-vec2(.5*f)).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdr(vec2 uv, vec2 coords)\n{\n    vec3 col = vec3(0.);\n    \n    if (mod(float(iFrame), 550.0) == 0.)\n        col += vec3(1.)*sat(pow(texture(iChannel1, uv*2.0).x, 20.)*400.);\n    else\n    {\n        float prev = texelFetch(iChannel0, ivec2(coords),0).x;\n        float neighbors[8];\n        neighbors[0] = texelFetch(iChannel0, ivec2(coords+vec2(1.0,0.0)),0).x;\n        neighbors[1] = texelFetch(iChannel0, ivec2(coords+vec2(1.0,1.0)),0).x;\n        neighbors[2] = texelFetch(iChannel0, ivec2(coords+vec2(0.0,1.0)),0).x;\n        neighbors[3] = texelFetch(iChannel0, ivec2(coords+vec2(-1.0,1.0)),0).x;\n        neighbors[4] = texelFetch(iChannel0, ivec2(coords+vec2(-1.0,0.0)),0).x;\n        neighbors[5] = texelFetch(iChannel0, ivec2(coords+vec2(-1.0,-1.0)),0).x;\n        neighbors[6] = texelFetch(iChannel0, ivec2(coords+vec2(0.0,-1.0)),0).x;\n        neighbors[7] = texelFetch(iChannel0, ivec2(coords+vec2(1.0,-1.0)),0).x;\n        int neighborsCount = 0;\n        for (int i = 0; i < 8; ++i)\n        {\n            neighborsCount += int(neighbors[i]);\n        }\n        if (prev > 0.5 && (neighborsCount == 2 || neighborsCount == 3))\n            col = vec3(1.0);\n        if (prev < 0.5 && neighborsCount == 3)\n            col = vec3(1.0);\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = rdr(uv, fragCoord);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s ,s, c); }\n\n// Thanks IQ\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n", "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    vec3 prev = texelFetch(iChannel1, ivec2(fragCoord.xy), 0).xyz;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n\n    col = mix(col, col*vec3(sin(uv.x*5.+iTime)*.2+.8, .2, .8), sat(prev.x));\n    \n    uv *= .25;\n    float shape = \n    max(max((length(uv*vec2(1.,1.7)*r2d(.5)-vec2(-0.01,.03))-.075), -uv.y-0.01), uv.x-.01);\n    shape = smin(shape,     \n    (length((uv-vec2(.025,0.015))*r2d(.8)*vec2(1.4,1.8))-.07), .01);\n\n    shape = min(shape, length(uv*r2d(-.2)*vec2(1.,1.3)-vec2(-0.01,-0.005))-.035);\n    shape = min(shape, length(uv*r2d(-.2)*vec2(1.,1.3)-vec2(0.025,-0.02))-.035);\n    \n    shape = smin(shape, max(max(abs(uv.x*1.5+uv.y+.01)-.01, uv.y), -uv.y-.06), 0.01);\n    col *= sat((1.-sat(shape*400.))*.5+.4);\n    \n//    col += (1.-sat((abs(shape)-.0001)*4000.))*vec3(1.);\n    //col += 1.-texture(iChannel2, uv*5.-vec2(.5)).xyz; // Brain texture\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 4.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(fi/fcnt)*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 5.;  \n    vec3 bloomSample = doBloom(uv, 50./360., 437./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.9));\n    col = pow(col, vec3(1.)*mix(0.45,1.45,(sat(length(cuv*3.)))));\n    col = col + (bloomSample*bloomIntensity);\n    \n    col = pow(col, vec3(1.9));\n    \n    col *= 1.-sat((length(cuv)-.25)*3.);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dscRM.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 614]], "test": "untested"}
{"id": "sdsyz8", "name": "Genuary 2022 - Day9", "author": "z0rg", "description": "My participation to genuary 2022\nCode is messy I know :p", "tags": ["architecture", "genuary", "2022"], "likes": 13, "viewed": 394, "published": 3, "date": "1641931895", "time_retrieved": "2024-07-30T17:10:44.643823", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .8\n#define GLOW_OPACITY .4\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\n// Thanks IQ\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// Thanks IQ\nfloat _rsqr(vec2 uv, vec2 s, float r)\n{\n    vec2 l = abs(uv)-s;\n    return min(length(max(l, 0.)+min(max(l.x, l.y), 0.))-r, max(l.x, l.y));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}", "buffer_a_code": "\n#define GROUND_MAT 0.\n#define WALL_MAT 1.\n#define BACK_LEFT_WALL 2.\n#define FRONT_LEFT_WALL 3.\n#define CEILING_MAT 4.\n#define RIGHT_WALL_MAT 5.\n\nstruct matProp\n{\n    vec3 SpecularColor;\n    vec3 DiffuseColor;\n    float Glossiness;\n};\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x,max(l.y, l.z));\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n\n    vec2 acc = vec2(10000., -1.);\n    \n    acc = _min(acc, vec2(-p.y, GROUND_MAT));\n    float wallth = .2;\n    // RightWall\n    float rightWall = _cube(p-vec3(1.,0.,0.), vec3(wallth,5., 10.));\n    rightWall = max(rightWall, -(_sqr(p.zy-vec2(-1.,-2.2), vec2(.5,1.3))));\n    rightWall = max(rightWall, -(_sqr(p.zy-vec2(-3.,-2.2), vec2(.5,1.3))));\n    acc = _min(acc, vec2(rightWall, RIGHT_WALL_MAT));\n    \n    float gridRep = 0.3;\n    vec3 pGrid = p;\n    vec3 pGrid2 = p;\n    pGrid.y = mod(pGrid.y+gridRep*.5, gridRep)-gridRep*.5;\n    pGrid2.z = mod(pGrid2.z+gridRep*.5, gridRep)-gridRep*.5;\n    float rightWindowGrids = _cube(pGrid-vec3(1.,0.,0.), vec3(.025,.025,5.));\n    rightWindowGrids = min(rightWindowGrids, _cube(pGrid2-vec3(1.,0.,0.), vec3(.025,5.,.025)));\n    acc = _min(acc, vec2(rightWindowGrids, WALL_MAT));\n    \n    // Left nearest wall\n    float leftNearWall = _cube(p-vec3(-4.,0.,-2.), vec3(3.,5., wallth));\n    leftNearWall = max(leftNearWall, -(length(p.xy-vec2(-2.2,-1.5))-0.7));\n    leftNearWall = max(leftNearWall, -(_sqr(p.xy-vec2(-2.2,-3.), vec2(.2,.5))));\n    acc = _min(acc, vec2(leftNearWall, FRONT_LEFT_WALL));\n   \n    // Back wall\n    acc = _min(acc, vec2(_cube(p-vec3(-2.,0.,0.), vec3(3.,5., wallth)), BACK_LEFT_WALL));\n    \n    acc = _min(acc, vec2(max(p.y+4.5, p.x-.8), CEILING_MAT));\n    \n   \n\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps, float maxDist)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        /*if (res.y == FLAME_MAT)\n        accLight += vec3(0.941,0.376,0.000)*(1.-sat(res.x/.05))*.05;*/\n        p+= rd*res.x*.25;//*.0125;\n    }\n    return vec3(( distance(p, ro) < maxDist ? -1. : -2.));\n}\n\nfloat getShadow(vec3 ro, vec3 lpos, int steps)\n{\n    float maxDist = distance(ro, lpos);\n    vec3 rd = -normalize(lpos-ro);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return 0.;\n        p+= rd*res.x*.125;\n    }\n    return float(distance(p, ro) > maxDist);\n}\nvec3 getEnv(vec3 rd)\n{\n    return 5.*texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz*vec3(0.941,1.000,1.000);//*.25;\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float stars = pow(texture(iChannel0, uv*5.*vec2(2.,1.)).x, 10.)*sat(-rd.y);\n    vec3 back = mix(vec3(0.910,0.671,0.588), vec3(0.176,0.180,0.345)*.75, pow(sat(-rd.y*2.+.2), .3)); \n    back += vec3(0.455,0.871,0.925)*pow(sat(-(rd.x-2.1)*.4+rd.y*2.),1.2)*.5;\n    back += vec3(0.733,0.416,0.208)*pow(sat(-(rd.x-1.9)*.4+rd.y*2.),3.);\n    back *= 1.-sat(length((uv-vec2(.75,0.1))*.5*vec2(2.,2.)));\n    return back+ vec3(1.)*stars+vec3(.2,.4,.7)*stars*1.;\n}\n\nmatProp getMat(float idMat, vec3 p, vec3 n)\n{\n    matProp mat;\n    mat.SpecularColor = vec3(.05);\n    mat.DiffuseColor = n*.5+.5;\n    mat.Glossiness = .7;\n    \n    if (idMat == GROUND_MAT)\n    {\n        mat.DiffuseColor = vec3(.7)*pow(texture(iChannel3, p.xz*r2d(PI*.5)*1.).x,.25);\n    }\n    if (idMat == FRONT_LEFT_WALL)\n    {\n        mat.DiffuseColor = vec3(0.898,0.600,0.263);\n    }\n    if (idMat == RIGHT_WALL_MAT)\n    {\n        mat.DiffuseColor = vec3(1.000,0.478,0.514);\n    }\n    if (idMat == BACK_LEFT_WALL)\n    {\n        mat.DiffuseColor = vec3(0.149,0.329,0.259);\n    }\n    return mat;\n}\n\n\nvec3 getDirectLighting(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    matProp mat = getMat(res.z, p, n);\n    vec3 col = vec3(0.);//n*.5+.5;\n    vec3 lpos = vec3(-40.,15.,10.)*.35+1.*(vec3(rand(), rand(), rand())-.5);\n    vec3 ldir= p-lpos;\n    vec3 lcol = vec3(1.000,0.796,0.659)*10.;\n    vec3 h = normalize(rd+ldir);\n\n    float ndotl = sat(dot(n, normalize(ldir)));\n    \n    col += mat.DiffuseColor*.3;\n\n    if (getShadow(p+n*0.01,  lpos, 256) > 0.5)\n    {\n        vec3 spec = lcol*mat.SpecularColor*pow(sat(dot(n,h)), mat.Glossiness);\n        vec3 remainingLight = max(lcol-spec, vec3(0.));\n        col += spec+mat.DiffuseColor*ndotl*remainingLight;\n    }\n\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float xpos = sin(iTime*0.+.5)*2.2;\n    float offy = -.85;\n    float zoff = 5.9;\n    //uv *= r2d(.25);\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.008*0.;\n    vec3 ro = vec3(-5.,-1.7,-8.1)*.9+dof;\n    vec3 ta = vec3(0.5,-1.2,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*0.0025;\n    vec3 res = trace(ro, rd, 4096*2, 15.);\n    float maxdist = 20.;\n    float dist = maxdist;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getDirectLighting(res, rd, p, n);\n        //col += accLight;\n        if (true)\n        {\n            vec3 lastCol = col;\n            for (int i = 0; i < 3; ++i)\n            {\n                \n                matProp mat = getMat(res.z, p, n);\n                float doSpec = sat((rand()-0.5)*400.0); // 0 or 1\n                \n                float spec = mat.Glossiness;\n                vec3 glossSamplePos = normalize(vec3(rand(), rand(), rand())-.5)*spec;\n                vec3 refl = normalize(reflect(rd, n)+spec+glossSamplePos);\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), doSpec);\n            \n                if (dot(refl, n) < 0.0 && doSpec < 0.5)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl, 4096*2, 7.);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    vec3 retCol = getDirectLighting(resrefl, refl, prefl, nrefl)*lastCol;\n                    col += retCol;\n                    lastCol = retCol;\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    if (res.x != -1.)\n                        col += getEnv(refl)*mix(mat.DiffuseColor, mat.SpecularColor, doSpec);\n                    break;\n                }\n                \n                rd = refl;\n            }\n\n\n        }\n    col = mix(col, vec3(0.), sat(exp(-dist*.05-.1)));\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float scaleF = 1.;\n    uv *= scaleF;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75/scaleF);\n    vec3 col = rdr(uv+off);\n\n    //col = sat(col);\n    // Thanks IQ https://www.shadertoy.com/view/Xd2fzR\n    // gain\n    col *= 1.1/(1.0+col);\n    // burn the highlights\n    float g = dot(col,vec3(0.3333));\n    col = mix( col, vec3(g), min(g*0.2,1.0) );\n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \n    //col = pow(col, vec3(.9));\n    col = sat(col);\n    if (iFrame > 1)\n        col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col,  1.0 / float(iFrame + 1));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsyz8.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1179]], "test": "untested"}
{"id": "fsXcDr", "name": "SerenityOS performant Ladyball", "author": "kleinesFilmroellchen", "description": "A 3D rendition of the SerenityOS \"Ladyball\"\n\nThis fork mainly adjusts parameters for performance and is intended for systems where adaptation of a specific shader is not possible.", "tags": ["serenityos"], "likes": 1, "viewed": 265, "published": 3, "date": "1641931188", "time_retrieved": "2024-07-30T17:10:45.601263", "image_code": "const float INF  = 1./0., //If divide by zero error occurs, replace this with a very big number\n            M_PI = 3.14159;\n\n//--- Settings ---\n// Many of these settings cause really hacky control flow changes.\n// As long as they are only used as constants, that are known at\n// compile time, they should have no impact on performance.\n// But should they be unknown at compile time, they might have\n// severe performance impacts\n\nconst bool MOUSECONTROL = false\n\n         , SHOW_CYCLES              = false\n         , SHOW_COLLISION_DISTANCE  = false\n         , BAILOUT_SPECIAL_COLOR    = false\n         , SHOW_NORMAL              = false\n         , THREE_D                  = false\n         , FIELD_CROSS_SECTION      = false\n         , CUTVIEW                  = false //TODO: fix cutview\n         // EDGE DETECTION SETTINGS\n         , DRAW_NEAR_MISS_EDGES     = false\n         , DRAW_INSIDE_EDGES        = false\n         , DRAW_BOOL_EDGES          = false\n         \n         , DISTANCE_GROWING_THRESH  = false\n         , STEPPING_SLOWDOWN        = false\n         \n         , NEAR_MISS_ANTI_ALIASING  = false\n         , DO_LIGHTING              = false\n         ,   FAKE_SOFT_SHADOWS      = false //  \"realistic\" lighting\n         ,   LIGHTING_DISTANCE_FADE = false  //  sub settings\n         ,   SHADOW_NEAR_MISS_AA    = false // \n         ,   SPECULAR_LIGHT_SOURCES = false  // \n         \n         , DO_DITHERING             = false;\n\nconst int MAX_STEPS  = 50;\n\nconst float ambient_light    = 0.13,\n            base_dist_thresh = 0.001,\n            shadowDistThresh = 0.01,\n            numGradStep      = 0.0001,\n            bailout_cam_dist = 1000.,\n            gamma            = 2.,    //setting gamma to easy to calculate values might result in a very slight speedup\n            EDGE_WIDTH       = 1.0;\n\nconst vec3 EDGE_COLOR = vec3(1., 0., 1.);\n\n//---\n\n//--- Lights ---\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float size;\n};\n\nLight lightsList[] = Light[](\n    Light(vec3(0.,0.,-5.),vec3(1.000,1.000,1.000)*5.,0.5),\n    Light(vec3(0.,5.,0.),vec3(1.000,1.000,1.000),1.)\n    );\nint lightsListLength = 2;\n\n//---\n\n//--- Materials ---\n\nstruct Material {\n    vec3 color_diffuse;\n    vec3 color_specular;\n    vec3 color_subsurface;\n    float roughness;\n    float stripe_dens;\n    float stripe_rot;\n};\n\nMaterial materials[] = Material[](\n        Material(vec3(1.), vec3(1.), vec3(0.), .8, 1.0, M_PI / 4.), //mutableMaterial\n        Material(vec3(0.333, 0.666, 1.), vec3(0.333, 0.666, 1.), vec3(0.4), .8, 1.0, M_PI / 4.), //standardMaterial\n        Material(vec3(.64, 0.11, 0.17),  vec3(.64, 0.11, 0.17),  vec3(0.4), .8, 3.0, M_PI / 4.), //redMaterial\n        Material(vec3(.0, 0.9, 0.1),     vec3(.0, 0.9, 0.1),     vec3(0.4), .8, 2.0, M_PI / 4.), //greenMaterial\n        Material(vec3(.0, 0.17, 0.8),    vec3(.0, 0.17, 0.8),    vec3(0.4), .8, 1.0, M_PI * 3. / 4.), //blueMaterial\n        Material(vec3(0.945,0.682,0.000),    vec3(.0, 0.17, 0.8),    vec3(0.4), .8, 1.0, M_PI / 4.), //yellowMaterial\n        Material(vec3(0.020,0.020,0.020), vec3(0.239,0.220,0.275), vec3(0.4), 1., 1.0, M_PI / 4.), //blackCoreMaterial\n        Material(vec3(0.976,0.008,0.008), vec3(0.878,0.106,0.141), vec3(0.4), 0.2, 1.0, M_PI / 4.), //redShellMaterial\n        Material(vec3(0.000,0.000,0.000), vec3(1.000,1.000,1.000), vec3(0.4), 0.0, 1.0, M_PI / 4.) //blackShellSpotMaterial\n    );\n\n// Material indices\nint mutableMaterial  = 0;\nint standardMaterial = 1;\nint redMaterial      = 2;\nint greenMaterial    = 3;\nint blueMaterial     = 4;\nint yellowMaterial   = 5;\nint blackCoreMaterial = 6;\nint redShellMaterial = 7;\nint blackShellSpotMaterial = 8;\n\n//---\n\n// Vector roation around origin\nvoid Rotate( inout vec3 vector, vec2 angle ){\n    vector.yz = cos(angle.y) * vector.yz\n                + sin(angle.y) * vec2(-1,1) * vector.zy;\n    vector.xz = cos(angle.x) * vector.xz\n                + sin(angle.x) * vec2(-1,1) * vector.zx;\n}\n\nvec3 rotate( in vec3 vector, vec2 angle){\n    vec3 result = vector;\n    Rotate(result, angle);\n    return result;\n}\n\n//--- signed distance field - functions ---\nfloat Diff(float A, float B, inout float combined_min){\n    combined_min = min(combined_min, max(abs(A), abs(B)));\n    return max(A, -B);\n}\n\n// Coordinate transformation functions\nvec3 toHorizontal( in vec3 p ){\n    vec3 result;\n    \n    result.x = atan(p.z, p.x); // Azimuth\n    \n    result.y = atan(p.y / length(p.xz)); // Attitude\n    \n    result.z = length(p); // Distance\n    \n    return result;\n}\n\nvec3 fromHorizontal( in vec3 pol ){\n    vec3 result;\n    \n    result.x = cos(pol.x) * cos(pol.y);\n    \n    result.y = sin(pol.y);\n    \n    result.z = sin(pol.x) * cos(pol.y);\n    \n    result *= pol.z;\n    \n    return result;\n}\n\nvec3 mirrorY( in vec3 p ){\n    vec3 result = p;\n    \n    result.y = abs(p.y);\n    \n    return result;\n}\n\n// -- Geometries --\nfloat Sphere( vec3 centre, float radius, vec3 point ){\n    return length(centre-point)-radius;\n}\n\nfloat Box(vec3 pos, vec3 size, vec3 point) {\n    vec3 d = abs(point - pos) - (size / 2.0);\n    \n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat Limit(vec3 pos, vec3 dir, vec3 point ){\n    return dot(point - pos, normalize(dir));\n}\n\n// the following functions are taken 1:1 from Inigo Quilez\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.yz) - w, p.x );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// --\n//---\n\n//Target Detection, and material determination\nvoid det(inout float f, inout int m, in float dist, in int material){\n    if(dist < f){\n        f = dist;\n        m = material;\n    }\n}\n\n// The Background Function - rays that don't hit objects, will be colored according to this function\nvec3 background( in vec3 ray){\n    // Background color constants, change these to change the background appearance\n    const vec3 ground      = pow( vec3(0.251,0.180,0.133), vec3(gamma)),\n               ground_haze = pow( vec3(0.522,0.341,0.200), vec3(gamma)),\n               ground_grid = pow( vec3(0.545,0.435,0.420), vec3(gamma)),\n               sky         = pow( vec3(0.251,0.184,0.129), vec3(gamma)),\n               sky_haze    = pow( vec3(0.082,0.055,0.031), vec3(gamma)),\n               sky_grid    = pow( vec3(0., 0., 0.), vec3(gamma));\n               \n    vec2 effective_ground_plane_coord = mod(ray.xz * (-3./ray.y), vec2(1.));\n    float dist_to_grid = min(abs(effective_ground_plane_coord.y - .5),\n                             abs(effective_ground_plane_coord.x - .5));\n    \n    vec3 col = mix(ground_haze,\n                   mix(ground_grid,\n                       ground,\n                       clamp(dist_to_grid * 30.,\n                             0.,\n                             1.)\n                       ),\n                   clamp(pow(-ray.y * 4., 1.3), 0., 1.)\n                   );\n    col = mix(mix(sky_haze,\n                  sky,\n                  clamp(ray.y, 0., 1.)\n                  ),\n              col,\n              clamp(-ray.y * 70., 0., 1.)\n              );\n                   \n    return col;\n}\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( in vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n//accumulated sdf function\nfloat Scene( in vec3 pos, inout int material, out float combined_min){\n    combined_min = INF;\n    #define D(dist, mat) det(f, material, dist, mat)\n    float f = INF;\n    \n    float shell_d = 0.95;\n    \n    vec3 ladyball_pos = pos;\n    //ladyball_pos += vec3(0., 0., 1.); //Offset for VR\n    Rotate(ladyball_pos, vec2(0., iTime*1.9));\n    \n    \n    D(\n        min(\n            Diff(\n                sdPie(opRevolution(ladyball_pos, 0.).yx, vec2(sin(M_PI/4.), cos(M_PI/4.)), shell_d),\n                ladyball_pos.z,\n                combined_min\n            ),\n            sdSolidAngle(\n                mirrorY(ladyball_pos),\n                vec2(sin(M_PI/4.), cos(M_PI/4.)),\n                shell_d\n            )\n        )-0.1,\n        redShellMaterial\n    );\n    \n    D( Sphere(vec3(0), 1., ladyball_pos), blackCoreMaterial);\n    \n    D( sdEllipsoid(ladyball_pos - vec3(0., 1. ,0.), vec3(0.4, 0.07, 0.4)), blackShellSpotMaterial);\n    \n    D( sdEllipsoid(rotate((ladyball_pos), vec2(0., -M_PI*0.3)) - vec3(0., 1. ,0.) , vec3(0.3, 0.07, 0.3)), blackShellSpotMaterial);\n    \n    D( sdEllipsoid(rotate((ladyball_pos), vec2(0., -M_PI*0.52)) - vec3(0., 1. ,0.) , vec3(0.2, 0.07, 0.2)), blackShellSpotMaterial);\n    \n    /*\n    // Axis indication spheres\n    pos += vec3(2, 2, 2);\n    D( Sphere(vec3(0, 0, 0), 0.1, pos), yellowMaterial);\n    D( Sphere(vec3(1, 0, 0), 0.1, pos), redMaterial);\n    D( Sphere(vec3(0, 1, 0), 0.1, pos), greenMaterial);\n    D( Sphere(vec3(0, 0, 1), 0.1, pos), blueMaterial);\n    */\n    return f;\n    #undef D\n}\n\n//calculating the surface normal/normalized field gradient - numerically\nvec3 get_normal(in vec3 pos){\n    vec3 normal;\n    int mat; //hacky - only needed to match the function signature\n    float combined_min; //hacky +1 - but should be optimized away anyways\n    normal.x = Scene(pos + vec3(numGradStep, 0, 0), mat, combined_min);\n    normal.y = Scene(pos + vec3(0, numGradStep, 0), mat, combined_min);\n    normal.z = Scene(pos + vec3(0, 0, numGradStep), mat, combined_min);\n    normal -= vec3(Scene(pos, mat, combined_min));\n    normal = normalize( normal ); //this makes distored (e.g. smooth) SDFs possible\n    return normal;\n}\n\nfloat light_reachable(vec3 pos, Light light, float dist_per_pix){\n    float intensity = 1.;\n    \n    vec3  light_diff_vec  = light.pos - pos;\n    float light_diff_dist = length(light_diff_vec),\n          trav_length     = 0.,\n          min_h           = INF;\n    vec3  ray             = normalize(light_diff_vec);\n    int mat; //currently unused, could be used for transparent objects\n    //path marching to light\n    for(int i = 0; i < 500; i++){\n        float combined_min; //only needed to match the function signature of Scene\n        float h = Scene( pos, mat , combined_min);\n        \n        if(h > min_h){\n            if(FAKE_SOFT_SHADOWS){\n                float shadow_width = light.size * ( trav_length / (light_diff_dist - trav_length));\n\n                intensity *= clamp((min_h * (light_diff_dist / (light_diff_dist - trav_length))) / shadow_width,\n                                   0., 1.);\n                min_h = INF;\n            }else if(SHADOW_NEAR_MISS_AA){\n                float local_dist_per_pix = dist_per_pix * ((light_diff_dist - trav_length) / light_diff_dist);\n                float miss_factor = (min_h - shadowDistThresh) / local_dist_per_pix;\n                intensity *= min(miss_factor, 1.);\n            }\n            \n            min_h = INF;\n        }\n        \n        //Fake Smooth Shadows\n        if(FAKE_SOFT_SHADOWS || NEAR_MISS_ANTI_ALIASING){\n            min_h = min(min_h, h);\n        }\n        \n        //Overshoot Detection\n        trav_length += h;\n        if( trav_length >= light_diff_dist)\n            break;\n        \n        //Collision Detection\n        if( h < shadowDistThresh){\n            intensity = 0.;\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    return intensity;\n}\n\nvoid mainMarch( out vec4 fragColor,\n                in vec3 pos,\n                in vec3 ray,\n                in float unit_dist_per_pix,\n                in float perspectiveness,\n                in vec3 image_plane_vertical,\n                in vec3 image_plane_horizontal,\n                in vec3 image_plane_normal\n                ){\n    \n    vec3 start_pos = pos;\n    \n    //constant background color/fragment color initialization goes here\n\tfragColor.rgb = vec3(1.);\n    \n    //-- edge detection values -- //TODO: check what values are still used\n    bool collided = false,\n         pixel_dist_near_miss = false;\n    vec3 pixel_dist_near_miss_color;\n    float near_miss_pixel_ratio = 1.,\n          min_h = INF,\n          h = INF, //elevation from nearest surface (Distance)\n          trav_dist = 0.;\n    int material_ind = standardMaterial;\n    //--\n    //main marching loop\n    int i; //declared outside to be used for BAILOUT_SPECIAL_COLOR\n    //        number of steps before bailout\n    for (i = MAX_STEPS; i > 0; i--){\n        float combined_min; //Variable to store the combined minimum of bool operations\n        h = Scene(pos, material_ind, combined_min);\n        \n        float dist_thresh = base_dist_thresh;\n        if( DISTANCE_GROWING_THRESH )\n            dist_thresh *= trav_dist;\n        \n        bool pixel_dist_near_miss_on_this_pass = false;\n        if(h > min_h){ //Code to run on detection of a near miss - TODO: antialiasing\n            float local_dist_per_pix = unit_dist_per_pix *\n                                       (\n                                           (1. - perspectiveness) +\n                                           perspectiveness * distance(start_pos, pos)\n                                       );\n            if((min_h - dist_thresh) < local_dist_per_pix * float(EDGE_WIDTH) && DRAW_NEAR_MISS_EDGES){\n                fragColor.rgb = EDGE_COLOR;\n                return;\n            }\n            if((min_h - dist_thresh) < local_dist_per_pix && !pixel_dist_near_miss && NEAR_MISS_ANTI_ALIASING){\n                near_miss_pixel_ratio = (min_h - dist_thresh) / local_dist_per_pix;\n                pixel_dist_near_miss_on_this_pass = true;\n                pixel_dist_near_miss = true;\n            }\n            //resetting min_h\n            min_h = INF;\n        }\n        min_h = min(min_h, h);\n        \n        //Declarations for Cutview, should be optimized out if not used\n        vec3 cut_norm, cut_pos;\n        float cut_dist, pre_cut_h;\n        if(CUTVIEW) {\n            cut_norm = normalize(vec3(0., 0., -1.));\n            cut_pos  = vec3(0., 0., 0.);\n            cut_pos += 1. * sin(iTime/6.) * cut_norm;\n            cut_dist = Limit(cut_pos, cut_norm, pos);\n            pre_cut_h = h;\n            float dummy_combined_min;\n            h = Diff(h, cut_dist, dummy_combined_min);\n        }\n        \n        //Surface hit\n        if (    h < dist_thresh \n             || (pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING) \n           ){\n            // -- debug bailouts --\n            if(SHOW_COLLISION_DISTANCE){ //debug show distance from camera to collision point\n                fragColor.rgb = vec3(h / dist_thresh, 0, 0);\n                break;\n            }\n               \n            if(SHOW_CYCLES){ //debug show cycle count at collision point\n                fragColor.rgb = vec3(1. - 1./(1. + 0.01*(float(MAX_STEPS - i) + h / dist_thresh) ));\n                return;\n            }\n            \n            vec3 normal = get_normal(\n                                      (   pixel_dist_near_miss_on_this_pass //if this is a near miss anti aliasing pass\n                                       && NEAR_MISS_ANTI_ALIASING           //walk back a bit before determining the normal\n                                       ? pos - (ray + image_plane_vertical) * 3.5 * h               //to actually sample the correct surface\n                                       : pos\n                                      )\n                                    );\n            if(SHOW_NORMAL){ //debug show normal at collision point as color\n                fragColor.rgb = 0.5 +  0.5 * normal;\n                break;\n            }\n            // --\n            \n            //TODO: eliminate this duplicate\n            float local_dist_per_pix = unit_dist_per_pix *\n                                   (\n                                       (1. - perspectiveness) +\n                                       perspectiveness * distance(start_pos, pos)\n                                   );\n            \n            //inside edge detection - TODO: antialiasing\n            if( DRAW_INSIDE_EDGES && !(pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING) ){\n                int dummy_mat;\n                \n                float surface_projected_local_dist_per_pix =\n                        local_dist_per_pix;\n                                       \n                float inside_edge_detection_dist = EDGE_WIDTH * surface_projected_local_dist_per_pix + dist_thresh;\n                \n                float dummy_combined_min;\n                \n                if(Scene(pos + normal * (dist_thresh + inside_edge_detection_dist), dummy_mat, dummy_combined_min)\n                   < inside_edge_detection_dist){\n                    fragColor.rgb = EDGE_COLOR;\n                    return;\n                }\n            }\n            \n            //edge detections for outside edges that are the result of a bool operation\n            if(    DRAW_BOOL_EDGES\n                && combined_min - dist_thresh < EDGE_WIDTH * local_dist_per_pix\n              ){\n                fragColor.rgb = EDGE_COLOR;\n                return;\n            }\n            \n            // copying over the actual material that is to be evlauated\n            Material material = materials[material_ind];\n            \n            if(CUTVIEW && cut_dist < dist_thresh){\n                fragColor.rgb = material.color_diffuse;\n                if(pre_cut_h > -0.01 * ((1. - abs(dot(normal, cut_norm))) / (-pre_cut_h)) ){\n                    fragColor.rgb = vec3(0.);\n                }else{\n                    //vec2 stripe_normal = vec2(0.707 * cos(material.stripe_rot),\n                    //                          0.707 * sin(material.stripe_rot));\n                    vec3 stripe_normal =   cos(material.stripe_rot) * image_plane_horizontal\n                                         + sin(material.stripe_rot) * image_plane_vertical;\n                    //float stripe_d = dot(stripe_normal, uv.xy);\n                    float stripe_d = dot(pos - cut_pos, stripe_normal);\n                    if(mod(stripe_d, 0.1 / material.stripe_dens) < 0.01){\n                        fragColor.rgb = vec3(0.);\n                    }\n                }\n            } else if(DO_LIGHTING) {\n                //--- lighting calculations ---\n                bool do_specular = material.roughness < 1. && SPECULAR_LIGHT_SOURCES;\n                vec3 diffuse  = vec3(0.0),\n                     specular = vec3(0.0);\n                for(int lightsInd = 0; lightsInd < lightsListLength; lightsInd++){\n                    Light lightSrc = lightsList[lightsInd];\n                    //detect if the light is reachable from the current position\n                    //                                              done so it doesn't collide with originator\n                    float light_intensity = light_reachable( pos + normal * shadowDistThresh * 2., lightSrc, local_dist_per_pix);\n                    \n                    vec3 to_light = lightSrc.pos - pos;\n                    vec3 to_light_normalized = normalize(to_light);\n                    float light_strength = light_intensity * (LIGHTING_DISTANCE_FADE ? \n                                            10.0 / pow(length(to_light), 2.0)\n                                            : 1.);\n                    //Diffuse Calculation\n                    diffuse += lightSrc.color * light_strength\n                               * max(0., dot(normal, to_light_normalized));\n\n                    //Specular Calculation\n                    if( do_specular ){\n                        vec3 a = normal * dot(normal, -ray);\n                        vec3 reflected_ray = normalize(a + a -(-ray));\n                        specular += lightSrc.color * light_strength\n                                    * clamp(1. - 100./(1. + lightSrc.size)\n                                            * (1. - dot(to_light_normalized, reflected_ray)),\n                                            0., 1.);\n                    }\n                }\n                //---\n\n                //determining amount of sideglow (added light at low angle of incident)\n                float sideglow = ambient_light * clamp(1. - dot(normal, -ray), 0., 1.);\n                sideglow *= 1.8;\n\n                //--- final color determination ---\n                fragColor.rgb = material.color_diffuse*\n                                mix(max(\n                                        vec3(ambient_light),\n                                        sideglow\n                                       ), vec3(1.), diffuse);\n                if( do_specular ){\n                    fragColor.rgb += specular * material.color_specular * (1. - material.roughness);\n                }\n                \n                //alternative color determination -- outdated without specular\n                //fragColor.rgb = vec3((0.2 + diffuse) * material.color_diffuse * (1.0 - sideglow)\n                //                     + sideglow * material.color_sideglow);\n                //---\n            } else { // Branch to take if lighting based shading is disabled\n                mat3 view_relative = mat3(image_plane_horizontal, image_plane_vertical, image_plane_normal);\n                fragColor.rgb = material.color_diffuse\n                                * (ambient_light + (1. - ambient_light) *\n                                   max(\n                                       //Light always coming from top right, slightly towards the camera\n                                       clamp(dot(normal, view_relative * vec3(0.4, 1., -0.3)), 0., 1.),\n                                       //Low Angle of Incident  Sideglow\n                                       ambient_light * 2. * clamp(1. - dot(normal, -ray), 0., 1.)\n                                       ));\n            }\n            \n            if(pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING){\n                pixel_dist_near_miss_color = fragColor.rgb;\n            }else{\n                collided = true;\n                break;\n            }\n        }\n        \n        // setting the new position\n        if( STEPPING_SLOWDOWN )\n            h *= .8;\n        pos += ray * h;\n        trav_dist += h;\n        \n        // Distance from camera bailout\n        if(distance(pos, start_pos) > bailout_cam_dist){\n            if(BAILOUT_SPECIAL_COLOR)\n                fragColor.rgb = vec3(0., 0., 1.);\n            if(SHOW_CYCLES)\n                fragColor.rgb = (float(MAX_STEPS - i) / 100.) * vec3(1.0,0.4,0.2);\n            break;\n        }\n    }\n    \n    if(!collided && !SHOW_CYCLES && !SHOW_NORMAL && !BAILOUT_SPECIAL_COLOR && !SHOW_COLLISION_DISTANCE)\n        fragColor.rgba = vec4(background(ray), 0.);\n    \n    if(BAILOUT_SPECIAL_COLOR && i <= 0)\n        fragColor.rgb = vec3(1., 0., 0.);\n    \n    //mixing color of near miss, and actual destination color -- for Anti Aliasing\n    if(NEAR_MISS_ANTI_ALIASING)\n        fragColor.rgb = mix(pixel_dist_near_miss_color, fragColor.rgb, near_miss_pixel_ratio);\n    \n    //Gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/gamma) );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.y) * 2.0 - vec2((iResolution.x / iResolution.y), 1.0);\n    //override 3D - draw mouse controlled cross section of field values\n    if(FIELD_CROSS_SECTION){\n        float z_plane = 0.0;\n        if(iMouse.z > 0.0){\n            z_plane = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * 4.0;\n        }\n        int dummyMat;\n        float dummy_combined_min;\n        float sdf = Scene(vec3(uv * 4.0, z_plane), dummyMat, dummy_combined_min);\n        fragColor.rgb = (sdf >= 0.0 ? vec3(sdf) : vec3(-sdf, 0.0, 0.0));\n        return;\n    }\n    //actual normal 3d rendering\n    \n    //--- Ray and Camera calculation ---\n    //ray starting position offset for smooth perspective to othographic transition\n    float view_size = 1.2,\n          perspectiveness = sin(iTime/3.0)/ 2.0 + 0.5,\n          image_plane_distance = 1.;\n    perspectiveness = 1.0;\n    \n    vec2 camera_origin_shift = vec2(0.) * image_plane_distance;\n    //marching starts on a projection plane scaled by orthagonal view width\n    //and (1-perspectiveness) - which means that the rays of all fragments originate\n    //from the same point with a perspectiveness of 1\n    vec3 start_offset = vec3( (fragCoord - iResolution.xy * 0.5) * view_size * (1.0-perspectiveness) / iResolution.x, 0.0);\n    //ray to march on                                                     Projection Plane Distance (Modifying this will modyfy the FOV, but also bug out the AA)\n    //this is the direction of the start_offset to the same plane, set off by 1 on z and not scaled by 1-perspectiveness\n    vec3 ray =\n        vec3(\n             (fragCoord - iResolution.xy * 0.5)  * view_size / iResolution.x,\n              image_plane_distance\n            )\n        - (start_offset + vec3(camera_origin_shift, 0.));\n    //Approximated arc Length per pixel at unit sphere from starting point\n    float unit_dist_per_pix = view_size / (iResolution.x * length(ray));\n    //normalization of ray to length 1\n    ray = normalize(ray);\n    //starting camera position\n    vec3 pos = vec3( 0., 0.,-5.) + start_offset;\n    \n    //camera offset for horizontal scanline 3D\n    if(THREE_D && mod( fragCoord.y, 2.0 ) < 1.0)\n    \tpos += vec3(0.2, 0, 0);\n        \n    //helper vectors for shading\n    vec3 image_plane_vertical   = vec3(0., 1., 0.),\n         image_plane_horizontal = vec3(1., 0., 0.),\n         image_plane_normal     = vec3(0., 0., 1.);\n\n    //rotating the camera around the origin\n    vec2 angle = vec2(iTime * 0.2, 0.1);\n    //angle = vec2((M_PI / 2.) * 1., 0.);\n\n    if (MOUSECONTROL && iMouse.z >= 0.0  && iMouse.xyz != vec3(0)) angle = (iMouse.xy / iResolution.xy - 0.5) * 6.6;\n    \n    Rotate( pos, angle );\n    Rotate( ray, angle );\n    Rotate( image_plane_vertical,   angle );\n    Rotate( image_plane_horizontal, angle );\n    Rotate( image_plane_normal,     angle );\n    \n    //---\n    \n    mainMarch( fragColor, pos, ray, unit_dist_per_pix, perspectiveness, image_plane_vertical, image_plane_horizontal, image_plane_normal );\n    \n    //Dithering\n    if( DO_DITHERING )\n        fragColor.rgb += vec3(InterleavedGradientNoise(fragCoord.xy)/255.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    mainMarch( fragColor,\n               3. * fragRayOri,\n               normalize(fragRayDir),\n               0., // Dist per pix\n               1., // Perspectiveness (assuming hole camera model\n               vec3(0., 1., 0.),\n               vec3(1., 0., 0.),\n               vec3(0., 0., 1.)\n             );\n    //Dithering\n    if( DO_DITHERING )\n        fragColor.rgb += vec3(InterleavedGradientNoise(fragCoord.xy)/255.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3661, 3693, 3738, 3738, 3936], [3938, 3938, 3979, 3979, 4053], [4055, 4099, 4154, 4154, 4238], [4240, 4279, 4310, 4310, 4501], [4503, 4503, 4538, 4538, 4729], [4731, 4731, 4757, 4757, 4834], [4836, 4856, 4910, 4910, 4952], [4954, 4954, 4998, 4998, 5217], [5219, 5219, 5264, 5264, 5311], [5313, 5372, 5418, 5453, 5613], [5615, 5615, 5664, 5664, 5832], [5834, 5834, 5875, 5875, 5919], [5921, 5921, 5980, 5980, 6069], [6084, 6131, 6200, 6200, 6266], [6268, 6369, 6399, 6483, 7700], [7702, 7912, 7958, 7958, 8087], [9651, 9724, 9753, 9753, 10283], [10285, 10285, 10350, 10350, 12041], [23714, 23714, 23771, 23771, 26894], [26896, 26896, 26990, 26990, 27418]], "test": "untested"}
{"id": "fsfyDr", "name": "random noise attempt", "author": "tungster24", "description": "I am not good at noise generation, here's my crummy lil program", "tags": ["noise", "random", "noisegeneration"], "likes": 1, "viewed": 222, "published": 3, "date": "1641929979", "time_retrieved": "2024-07-30T17:10:46.373199", "image_code": "#define hardness 1\n//anything outside of -1 to 1 is unusable\n//negative values = softer\n//positive values = harder\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m = iMouse.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy;\n    vec4 col = vec4(0.0);\n    vec4 temp = vec4(0.0);\n    for(float i = 1.0;i<=512.0;i*=1.1) {\n        temp = texture(iChannel0,uv/i+i);\n        col = col+( temp* pow(i,float(-hardness)) );\n    }\n    col = vec4(\n    (normalize(col).r-0.4)*10.0\n    );\n    fragColor = vec4(\n    col\n    );\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 115, 172, 172, 539]], "test": "untested"}
{"id": "7sscz7", "name": "Accurate Float Printing 2", "author": "mla", "description": "Printing floating point numbers (fairly) accurately. This one generates the digits left to right, so is useful for left justified text.", "tags": ["float", "print", "ieee754"], "likes": 6, "viewed": 438, "published": 3, "date": "1641916088", "time_retrieved": "2024-07-30T17:10:47.239882", "image_code": "/////////////////////////////////////////////////////////////////////////////////\n//\n// Accurate Float Printing 2, Matthew Arcus, mla, 2022\n//\n// Now with left to right generation of characters\n//\n/////////////////////////////////////////////////////////////////////////////////\n//\n// Having only recently tried using the Shadertoy font textures, I thought\n// it would be fun see how well we can print floats - turns out pretty well, in fact.\n// Format is the same as C 'printf(\"%.*g\",digits,x)'. The printfloat function is\n// also (mostly) valid C++, so can be run in a test program over all floats,\n// which indicates we are at most out by one or maybe two in the last digit\n// (and we mostly agree with the printf output as well).\n//\n// Output is the frame number (indicated in top left), hashed with the row and\n// column, then converted to a float with uintBitsToFloat (so it's completely\n// deterministic given the frame number). For comparison there is a C++ program\n// attached that generates and prints the same numbers.\n\n// In the shader, subnormals are highlighted in green, NaNs in blue. Note that\n// most GPUs (in WebGL mode anyway) flush subnormals to zero (subnormals are\n// asterisked in the C++ program).\n//\n/////////////////////////////////////////////////////////////////////////////////\n\nconst int digits = 7;\nconst int nrows = 15, ncols = 3;\n\nconst uint EXPONENTMASK = 0x7f800000U;\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1; // Reverse order of rows\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n\n  // Number to display in this cell\n  //uint seed = 130024071U;  // inf\n  //uint seed = 8184123U;  // -inf\n  uint seed = uint(iFrame);\n  float x = float(seed);\n  uint h = ihash(uint(row) ^ (uint(column)<<16) ^ ihash(seed));\n  if (row > 0 || column > 0) x = uintBitsToFloat(h);\n\n  // Background color\n  vec3 col = vec3(1);\n  if (row > 0 && (h & EXPONENTMASK) == 0U) col = vec3(0,1,0); // Subnormal\n  else if (isnan(x)) col = vec3(0,0,1);\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = printfloat(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c > 0) {\n    float charstart = charwidth*float(charpos); // character start\n    uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  }\n  // Get coords for mipmap scaling - p and uv have discontinuities\n  vec2 uvscale = 0.5*fragCoord/(16.0*fsize); // 0.5 to sharpen a little\n  vec4 t = textureGrad(iChannel0,uv,dFdx(uvscale),dFdy(uvscale));\n  if (c > 0) col *= 1.0-t.x;\n  if (alert) col.gb = 1.0-col.gb;\n  outColor = vec4(col,1);  \n}\n// C++ program to generate and print test data.\n// Specify number of digits and seed on command line.\n/*\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nbool issubnormal(uint n) {\n  return n != 0 && (n & 0x7f800000) == 0;\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 3) {\n    fprintf(stderr, \"Usage: %s <digits> <frame>\\n\", argv[0]);\n    exit(0);\n  }\n  int digits = strtol(argv[1],0,0);\n  uint frame = strtoul(argv[2],0,0);\n  for (int row = 0; row < 15; row++) {\n    for (int col = 0; col < 3; col++) {\n      float x = frame;\n      uint n = 0;\n      if (row > 0 || col > 0) {\n        n = ihash(ihash(frame) ^ row ^ (col << 16));\n        memcpy(&x,&n,sizeof(x));\n      }\n      printf(\"%*.*g%s\",digits+7,digits,x,!issubnormal(n)?\" \":\"*\");\n    }\n    printf(\"\\n\");\n  }\n}\n*/", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sscz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1404, 1527, 1557, 1557, 1571], [1693, 1734, 1760, 1842, 1881], [4563, 4563, 4614, 4635, 6129]], "test": "untested"}
{"id": "fdscR7", "name": "Fractal Rope Sphere Thing", "author": "SnoopethDuckDuck", "description": "zero effort went into color, i like the idea tho\n\n(i changed it to a cube, thought it looked cooler)", "tags": ["raymarching", "template", "artofcode"], "likes": 17, "viewed": 442, "published": 3, "date": "1641884262", "time_retrieved": "2024-07-30T17:10:48.081631", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat2 M(float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th));\n}\n\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat GetDist(vec3 p) {\n    float time = 5. * p.y + 0.4 * iTime;\n    \n    vec2 uv = p.xz;\n    //uv -= 0.5 * vec2(cos(time), sin(time));\n    uv = M(time) * uv;\n   // uv *= 1. +  sin(0.6 * length(uv) - 0. * iTime);\n    float th = 3. * p.y - atan(p.z, p.x) - 0.5 * iTime;//-0. * iTime;\n    uv = abs(M(th) * uv );\n    \n    float m = 0.1 +  0.08 * thc(3., 2.4 * p.y + iTime);\n    float n = 4.;\n    for (float i = 0.; i < n; i++) {\n        th += 0.1 * iTime + p.y;\n        //th -= 0.5 * (1.-i/n) * thc(2., 4. * th - iTime);\n        uv = abs(M(th) * (uv - m));\n        m *= 0.5;\n    }\n\n    float d = max(abs(uv.x), abs(uv.y)) - m;\n    float d2 = max(max(abs(p.x), abs(p.y)), abs(p.z)) - 0.2;\n   // d = max(d, length(p + vec3(0., 0.08 * cos(iTime), 0.)) - 0.45);\n    d = max(d, d2);\n    //d = max(d, length(p) - 1.);\n    //float s = step(d, 1.4 * m);\n    \n    //float d = length(p.xz - 0.5 * vec2(cos(time), sin(time))) - 0.2;\n    \n    return 0.6 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 2.;\n    float time = 0.4 * iTime;\n    vec3 ro = vec3(r * cos(iTime), cos(0.7 * iTime), r * sin(iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 3.5 + 0.5 * cos(0.6 * iTime));\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        col *= texture(iChannel0,r).rgb;\n        col *= 1.2 + r.y + p.y;\n        //col *= 0.5 + 0.5 * thc(4., 12. * length(p) + 0.4 * iTime) * cos(4. * p.y + iTime);\n        //col *= 0.5 * (1. + thc(2., iTime + p.y * 4.));\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdscR7.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1576, 1576, 1632], [1654, 1654, 1683, 1683, 1724], [1726, 1726, 1749, 1749, 2671], [2673, 2673, 2707, 2707, 2918], [2920, 2920, 2944, 2944, 3134], [3136, 3136, 3186, 3186, 3377], [3379, 3379, 3436, 3436, 4389]], "test": "untested"}
{"id": "NdlyRM", "name": "eindacor_waves", "author": "Eindacor_DS", "description": "wave collisions? you betcha!", "tags": ["waves"], "likes": 0, "viewed": 20, "published": 3, "date": "1641867866", "time_retrieved": "2024-07-30T17:10:48.845589", "image_code": "#define SHOW_SOURCES false\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat getWaveVal(vec2 source, vec2 uv, float wavelength, float waveReach, float time) {\n    float dist = distance(source, uv);\n\n    float waveVal = sin(dist / wavelength - time);\n    \n    float waveFalloffCoeff = 4.;\n    \n    waveVal *= smoothstep(waveReach + waveFalloffCoeff * wavelength, waveReach - waveFalloffCoeff * wavelength, dist);\n    \n    return waveVal;\n}\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    uv -= vec2(.5 * aspectRatio, .5);\n    \n    float val = 0.;\n    vec3 color = vec3(0.);\n    \n    int numSources = 200;\n    float waveReach = .8f;\n    \n    float effectiveTime = iTime + 200.;\n    \n    for (int i=0; i<numSources; i++) {\n        float xSeed = hash(vec2(float(i)));\n        float ySeed = hash(vec2(float(100-i)));\n        \n        float wavelengthSeed = hash(vec2(xSeed, ySeed));\n        float wavelength = mix(.002, .8, wavelengthSeed);\n        \n        float timeScale = mix(1., 2., hash(vec2(float(-i))));\n        \n        float sourceScale = getHoldTransitionValue(1., 1., 0., 50., effectiveTime);\n        float waveReachScale = getHoldTransitionValue(1., 1., 0., 50., effectiveTime);\n        \n        vec2 source = (vec2(xSeed * aspectRatio, ySeed) * 2. - vec2(aspectRatio, 1.)) * .5;\n        \n        source *= sourceScale;\n        \n        if (SHOW_SOURCES && distance(uv, source) < .01) {\n            fragColor = vec4(1.);\n            return;\n        }\n        \n        vec3 randomColor = vec3(xSeed, ySeed, hash(vec2(ySeed, xSeed)));\n\n        float localVal = getWaveVal(source, uv, wavelength, waveReach * waveReachScale, effectiveTime * timeScale);\n        color += localVal * randomColor;\n        val += localVal;\n    }\n\n    // Output to screen\n    fragColor = vec4(clamp(color, vec3(0.), vec3(1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 74, 94, 94, 160], [162, 162, 249, 249, 529], [530, 530, 636, 636, 1040], [1042, 1042, 1099, 1149, 2608]], "test": "untested"}
{"id": "NsXyRM", "name": "Simple Fractal Idea", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 9, "viewed": 226, "published": 3, "date": "1641865915", "time_retrieved": "2024-07-30T17:10:49.625503", "image_code": "mat2 M(float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   \n    float th = 0.5 * (1. + thc(4., iTime)) * h21(floor(10. * uv)) - 0.1 * iTime;\n    uv = abs(M(th) * uv );\n    \n    float m = 0.18;\n    float n = 6.;\n    for (float i = 0.; i < n; i++) {\n        th += 0.3 * (1.-i/n) * thc(2., 4. * th - iTime);\n        uv = abs(M(th) * (uv - m));\n        m *= 0.5;\n    }\n\n    float d = mlength(uv);\n    float s = step(d, 1.4 * m);\n    \n    fragColor = vec4(s);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 74], [76, 76, 133, 133, 600]], "test": "untested"}
{"id": "7sfczM", "name": "Goodnight Moon", "author": "wyatt", "description": "<3", "tags": ["painting"], "likes": 42, "viewed": 661, "published": 3, "date": "1641856230", "time_retrieved": "2024-07-30T17:10:50.499167", "image_code": "Main\n    Q = B(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nMain \n    if (iFrame>1) discard;\n    U = 2.*(U-.5*R)/R.y;\n    { // sunset\n        Q = .5+.4*sin(4.4-.8*U.y+vec4(1,2,3,4));\n    }\n    Q += .2*fbm(2.*U).x;\n    { // Moon\n        vec2 r = U-vec2(-.8,.5);\n        float l = length(r);\n        float L = .15;\n        vec3 n = fbm(8.*U);\n        Q += vec4(.2+n.x)*exp(-200.*max(l-L,0.));\n    }\n    { // stars\n        for (float i = 10.; i >= 1.; i--)\n        for (int k = 0; k < 9; k++)\n        {\n            vec2 V = 10.*U*i;\n            vec2 u = round(V)+vec2(k%3,k/3)-1.;\n            \n                vec3 h = hash(u+1e3*i)*2.-1.;\n                vec3 n = fbm(V+u)*2.-1.;\n                vec2 r = u-V+.5*h.xy;\n                r.y *= 1.5;\n                float l = length(r);\n                float s = .1;\n                float z = 10.*sqrt(s*s-l*l);\n                vec2 dz = -40.*r*inversesqrt(s*s-l*l);\n                Q += exp(-1e2*l);\n            \n        }\n        \n    }\n    {// Evergreen Tress\n        for (float i = 0.; i < 4.; i++)\n        for (float k = -2.; k <= 2.; k++)\n        {\n            {\n                    vec2 V = 3.*U+hash(vec2(k,i)).xy*2.-1.;\n                    float x = round(V.x);\n                    V.x = V.x-x;\n                    V.y += abs(V.x);\n                    V.x += .4*(V.x)*(noise(40.*V.yy).x*2.-1.);\n                    vec3 n = noise(140.*V+x)+noise(10.*V+x)*2.-1.;\n                    vec3 h = hash(vec2(x));\n                    V.y += .2*h.z+.1*n.z;\n                    V += .1*h.xy;\n                    V += .1*((n.xy*2.-1.));\n                    V.x *= .8+.5*V.y;\n                    V.y *= .3;\n                    Q -= .1*exp(-10.*abs(2.*length(V)-.5));\n                    if (2.*length(V)<.5)\n                        Q = vec4(.8,.6,.3,1)*\n                        (.5+.5*sin(4.-.5*h.x+.9*n.z+vec4(1,2,3,4)));\n\n                    }\n             }\n    }\n    Q *= 1.-.7*fbm(3.*U).x;\n    { // Pebbles\n        U += .5;\n        for (float i = 10.; i >= 1.; i--)\n        for (int k = 0; k < 9; k++)\n        {\n            vec2 V = 5.*U*i;\n            vec2 u = round(V)+vec2(k%3,k/3)-1.;\n            if (u.y+3.<6.*fbm(.2*u.xx/i).x*i) {\n                vec3 h = hash(u+1e3*i)*2.-1.;\n                vec3 n = fbm(V+u)*2.-1.;\n                vec2 r = u-V+.5*h.xy+n.xy*.6;\n                float l = length(r);\n                float s = .3;\n                float z = 10.*sqrt(s*s-l*l);\n                vec2 dz = -40.*r*inversesqrt(s*s-l*l);\n                Q -= 2.*exp(-20.*abs(l-s));\n                if (l < s) Q = .8*(.5-.2*r.x-r.y)*\n                    (.5+.5*sin(-.5*hash(U*100.).x+1.+1.5*h.x+n.y+vec4(1,2,3,4)));\n            }\n        }\n        U += .3;\n        Q *= 1.-fbm(10.*U).x*Q;\n        for (float i = 10.; i >= 1.; i--)\n        for (int k = 0; k < 9; k++)\n        {\n            vec2 V = 1.*U*i;\n            vec2 u = round(V)+vec2(k%3,k/3)-1.;\n            if (u.y+1.<3.*fbm(.1*u.xx/i).x*i) {\n                vec3 h = hash(u+1e3*i)*2.-1.;\n                vec3 n = fbm(V+u)*2.-1.;\n                vec2 r = u-V+.5*h.xy+n.xy*vec2(1,1.);\n                r.y *= 1.5;\n                float l = length(r);\n                float s = .4;\n                float z = 10.*sqrt(s*s-l*l);\n                vec2 dz = -40.*r*inversesqrt(s*s-l*l);\n                Q -= .5*exp(-20.*abs(l-s));\n                if (l < s) Q = (.5+.5*sin(hash(U*100.).x+h.x+vec4(1,2,3,4)))*(.3-.2*r.x-r.y);\n            }\n        }\n    }\n    Q += .1*fbm(60.*U).x*Q;\n\n    Q = clamp(Q,0.,1.);\n}", "buffer_a_inputs": [], "common_code": "vec2 R; float T; int I;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Main void mainImage(out vec4 Q, in vec2 U) { Q = vec4(0); R = iResolution.xy; T = iTime; I = iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n\nvec3 hash (vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    vec3 \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nvec3 fbm (vec2 p)\n{\n    vec3 w = vec3(0);\n    float N = 5.;\n    for (float i = 1.; i < N; i++)\n    {\n        p *= 1.7*ei(.5);\n        w += noise(p)/N/i;\n    }\n    return w;\n}", "buffer_b_code": "Main \n    Q = B(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x <= 1.; x++)\n    for (float y = -1.; y <= 2.; y++)\n    {\n        vec2 V = U+vec2(x,y);\n        vec4 b = B(V);\n        float p = .1*length(b-Q)+10.*abs(fbm(.05*V).x-fbm(.05*U).x);\n        dQ += (b-Q)*exp(-2e3*p*p);\n    }\n    Q += .1*dQ;\n    if (I<2) Q = A(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7ssyzN", "name": "staircase-basic line", "author": "jorge2017a2", "description": "staircase-basic line", "tags": ["staircasebasicline"], "likes": 2, "viewed": 254, "published": 3, "date": "1641825911", "time_retrieved": "2024-07-30T17:10:51.332938", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nvec3 escalera(vec2 p, vec3 col, float med)\n{   float dfin;\n    vec2 a,b ;\n    float xold;\n    float yold;\n    float y;\n    a=vec2(0.0,0.0);\n    b=vec2(0.0,1.0);\n    dfin=9999.0;\n    \n    xold=0.0;\n    yold=0.0;\n    for(float x=0.0; x<med;x+=0.05)\n    {\n        y=floor(x);\n        a=vec2(xold,yold);\n        b=vec2(x,y);\n        float d1= sdSegment(p,a,b);\n        dfin=min(dfin,d1);\n        xold=x;\n        yold=y;\n    }\n    \n    //col=DrawFigDelgado(vec3(0.0), col, dfin );\n    col= DrawFig(vec3(0.0), col, dfin );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    \n    vec2 uv0=uv;\n    uv.x+=iTime*5.0;\n    //uv.y+=0.5+0.75*sin(iTime*0.5);\n    uv.y+=0.5;\n    //vec3 col=vec3(0.0,0.1,0.8);\n    vec3 col=vec3(1.0);\n    \n    uv.x= opRep1D( uv.x,5.0);\n    col= escalera(uv,col,2.5);\n    col= escalera(vec2(-uv.x,uv.y),col,2.5);\n    \n    uv.y=uv0.y-2.0;\n    uv.x=uv0.x-0.2-iTime;\n    uv.x= opRep1D(uv.x,20.0);\n    col= escalera(uv,col,10.0);\n    col= escalera(vec2(-uv.x,uv.y),col,10.0);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 337, 337, 382], [388, 388, 435, 435, 462], [463, 463, 506, 506, 533], [534, 534, 582, 582, 610], [614, 614, 676, 676, 806], [809, 809, 866, 866, 936], [938, 938, 1000, 1000, 1065], [1067, 1067, 1119, 1119, 1235], [1239, 1239, 1283, 1283, 1773], [1776, 1776, 1833, 1833, 2479]], "test": "untested"}
{"id": "7dlyzN", "name": "Minecraft Sphere API", "author": "JustACleverKid", "description": "Derived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n\nI made it so its isometric.\nThats literally it.", "tags": ["raytracing"], "likes": 5, "viewed": 400, "published": 3, "date": "1641825834", "time_retrieved": "2024-07-30T17:10:52.151749", "image_code": "// derived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t, out float t2) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   t2 = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool step_forward(in Ray R, inout float t, inout vec3 roundpoint, out int coord, in float max_t, in float cubeWidth, in float cubesRad){\n    vec3 point = R.Origin + t*R.Dir;\n    vec3 signDir = sign(R.Dir);\n    /// solve for param: point + param*Dir = roundpoint + 0.5*(signDir)*cubeWidth component by component\n    vec3 params = (roundpoint - point + 0.5*signDir*cubeWidth)/R.Dir;\n\n    // find out which wall we hit next\n    if(params.x < params.y){\n        if(params.x < params.z){ coord = 0;}\n        else{ coord = 2;}\n    }\n    else{\n        if(params.y < params.z){ coord = 1;}\n        else{ coord = 2;}\n    }\n    \n    t += params[coord];\n    vec3 move = vec3(0.0,0.0,0.0);\n    move[coord] += cubeWidth;\n    roundpoint += signDir*move;\n\n    if(length(roundpoint) < cubesRad){ \n        roundpoint -= signDir*move; // take a step back to the cube before we hit the solid cube\n        return false; } // we hit a cube \n    if(t > max_t){ coord = 3; \n        return false;\n    }  // meaning that we were tangent to the sphere of cubes and didnt hit anything\n \n    return true; // keep going\n}\n\nfloat mysmoothstep(in float x){\n    float t = clamp(x, 0.0, 1.0);\n    t = 1.0 - pow((1.0 - t),1.5); \n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float time = float(100 + iFrame)/100.0;\n   float cubeWidth = 1.0/time;  \n   //float cubeWidth = 0.2;\n   float sphereRad = 1.0;\n   float cubesRad = sphereRad - cubeWidth*0.5*sqrt(3.0); // cube with center within this rad is contained in sphere\n \n   vec3 red = vec3(1.0,0.0,0.0);\n   vec3 green = vec3(0.0,1.0,0.0);\n   vec3 blue = vec3(0.0,0.0,1.0);\n   \n   float beta = 3.14159 / 4.0 + 0.2; // * time; // * time;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera \n   Camera C = camera(\n       vec3(3.1*c, 2.0*s, 1.75),\n       vec3(0.0, 0.0, 0.0),\n       50.0       \n   );\n \n   Ray R = launch(C, fragCoord);\n   Sphere S = Sphere(vec3(0.0, 0.0, 0.0), sphereRad);\n   \n   fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n   \n   float t;\n   float max_t;\n   int coord;\n   \n   vec3 col = vec3(0.0,0.0,0.0);\n   if(intersect_sphere(R,S,t,max_t)) {\n      vec3 point = R.Origin + t*R.Dir;\n      vec3 roundpoint = round(point/cubeWidth)*cubeWidth;\n      \n      bool cont = true;\n      for(int i = 0; i <= 50; i++) { \n          cont = step_forward(R, t, roundpoint, coord, max_t, cubeWidth, cubesRad);\n          if(cont == false){break;}\n      }\n      if(coord <= 2){ // hit a solid cube\n          col[coord] = 1.0;\n          \n          vec3 point = R.Origin + t*R.Dir;\n          vec3 signOctant = -sign(point);\n          point -= roundpoint; // now relative to the cube center we just hit\n          point *= signOctant; // now moving in the positive direction sends us to potential solid cubes\n          point /= cubeWidth; // now in (-0.5,0.5)^2\n          \n          float brightness = 1.0;\n          float d = 0.3; // ambient occlusion darkness amount\n          \n          vec3 move1 = vec3(0.0,0.0,0.0);\n          move1[(coord + 1) % 3] += cubeWidth;\n          vec3 neighbour1 = signOctant*roundpoint + move1;\n          vec3 move2 = vec3(0.0,0.0,0.0);\n          move2[(coord + 2) % 3] += cubeWidth;\n          vec3 neighbour2 = signOctant*roundpoint + move2;\n          vec3 move3 = move1 + move2;\n          vec3 neighbour3 = signOctant*roundpoint + move3;\n          bool n1solid = (length(neighbour1) < cubesRad);\n          bool n2solid = (length(neighbour2) < cubesRad);\n          bool n3solid = (length(neighbour3) < cubesRad);\n          \n          if(n1solid){\n              brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 1) % 3]);\n          }\n          if(n2solid){\n              brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 2) % 3]);\n          }\n          \n          if(n3solid && (!n1solid && !n2solid)){\n              float s1 = mysmoothstep(0.5 - point[(coord + 1) % 3]);\n              float s2 = mysmoothstep(0.5 - point[(coord + 2) % 3]);\n              float foo = 1.0 - (1.0 - s1)*(1.0 - s2);\n              brightness *= (1.0 - d) + d*foo;\n          }\n          \n          col *= brightness;          \n          fragColor = vec4(col, 1.0);\n      }\n   }\n\n}\n \n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 314, 314, 612], [614, 614, 651, 651, 748], [798, 798, 871, 871, 1173], [1175, 1175, 1311, 1311, 2267], [2269, 2269, 2300, 2300, 2407], [2409, 2409, 2466, 2466, 5372]], "test": "untested"}
{"id": "7dfyRH", "name": "Accurate Float Printing", "author": "mla", "description": "Printing floating point numbers (fairly) accurately.", "tags": ["float", "print", "ieee754"], "likes": 31, "viewed": 498, "published": 3, "date": "1641822786", "time_retrieved": "2024-07-30T17:10:52.930666", "image_code": "/////////////////////////////////////////////////////////////////////////////////\n//\n// Accurate Float Printing, Matthew Arcus, mla, 2022\n//\n/////////////////////////////////////////////////////////////////////////////////\n//\n// Having only recently tried using the Shadertoy font textures, I thought\n// it would be fun see how well we can print floats - turns out pretty well, in fact.\n// Format is the same as C 'printf(\"%.*g\",digits,x)'. The printfloat function is\n// also (mostly) valid C++, so can be run in a test program over all floats,\n// which indicates we are out by one at most in the seventh digit\n// (but mostly we agree with the printf output). For 32 bit floats, that's about\n// as good as it gets (small differences in rounding can affect the last digit).\n// Testing for round trip ulp error, ie. print number (8 digit precision), read \n// back with scanf and see how many ulps we are from the original, average\n// error is well under 1 ulp, nothing with 4 or more, 142466 with 3 & all\n// with large magnitude exponents, eg. the number that printf prints as\n// 7.6135436e+25 is printed by this code as 7.6135448e+25 & I can live\n// with that, TBH.\n//\n// Output is the frame number (indicated in top left), hashed with the row and\n// column, then converted to a float with uintBitsToFloat (so it's completely\n// deterministic given the frame number). For comparison there is a C++ program\n// attached that generates and prints the same numbers.\n\n// In the shader, subnormals are highlighted in green, NaNs in blue. Note that\n// most GPUs (in WebGL mode anyway) flush subnormals to zero (subnormals are\n// asterisked in the C++ program).\n//\n/////////////////////////////////////////////////////////////////////////////////\n\nconst int digits = 7;\nconst int nrows = 15, ncols = 3;\n\nconst uint EXPONENTMASK = 0x7f800000U;\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\n// Get character at 'cindex' in printed representation of x, with\n// 'digits' significant digits. cindex is counted from the _right_\n// so right justified display is easier to handle.\nint printfloat(float x, int digits, int cindex) {\n  assert(digits >= 2);\n  assert(digits <= 9);\n  if (cindex < 0 || cindex >= digits+6) return 0; // Maximum number of chars\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    CHAR(F); CHAR(N); CHAR(I);\n    if (x < 0.0) CHAR(MINUS);\n  } else if (isnan(x)) {\n    CHAR(N); CHAR(A); CHAR(N);\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n  } else if (x == 0.0) {\n    CHAR(ZERO);\n    if (1.0/x < 0.0) CHAR(MINUS);\n  } else {\n    bool needminus = x < 0.0;\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // by multiplying or dividing by powers of 10.\n    // Need to be careful how we do this to minimize\n    // loss of accuracy, but it's basically equivalent to:\n    // while(x > ulimit) { x /= 10.0; exp++; }\n    // while(x < llimit) { x *= 10.0; exp--; }\n    // but with a little less rounding error.\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < ulimit/pmax) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    if (exp <= -digits-4) {\n      int e = -exp-digits+1;\n      CHAR(ZERO+e%10); CHAR(ZERO+e/10); CHAR(MINUS); CHAR(E);\n      exp = -digits+1;\n    } else if (exp > 0) {\n      int e = exp+digits-1;\n      CHAR(ZERO+e%10); CHAR(ZERO+e/10); CHAR(PLUS); CHAR(E);\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    while(n != 0) {\n      // Write out the digits, with a decimal point in the right place\n      CHAR(ZERO+n%10);\n      n /= 10; exp++;\n      if (exp == 0) {\n        CHAR(POINT);\n        if (n == 0) CHAR(ZERO); // No more, so need leading zero\n      }\n    }\n    if (exp < 0) {\n      // Add leading digits for 0 < x < 1\n      while(exp < 0) {\n        CHAR(ZERO); exp++;\n      }\n      // Decimal point and leading zero\n      CHAR(POINT); CHAR(ZERO);\n    }\n    // Finally, a minus sign if needed\n    if (needminus) CHAR(MINUS);\n  }\n  return 0; // No character\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1; // Reverse order of rows\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n\n  // Number to display in this cell\n  //uint seed = 130024071U;  // inf\n  //uint seed = 8184123U;  // -inf\n  uint seed = uint(iFrame);\n  float x = float(seed);\n  //x = uintBitsToFloat(0x1ffca1eu); //9.396223e-38 9.3962216e-38\n  //x = uintBitsToFloat(0x08780330u);\n  uint h = ihash(uint(row) ^ (uint(column)<<16) ^ ihash(seed));\n  if (row > 0 || column > 0) x = uintBitsToFloat(h);\n\n  // Background color\n  vec3 col = vec3(1);\n  if (row > 0 && (h & EXPONENTMASK) == 0U) col = vec3(0,1,0); // Subnormal\n  else if (isnan(x)) col = vec3(0,0,1);\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int((colwidth-p.x)/charwidth);\n  vec2 uv = vec2(0);\n  int c = printfloat(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c > 0) {\n    float charstart = colwidth-charwidth*float(charpos+1); // character start\n    uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  }\n  // Get coords for mipmap scaling - p and uv have discontinuities\n  vec2 uvscale = 0.5*fragCoord/(16.0*fsize); // 0.5 to sharpen a little\n  vec4 t = textureGrad(iChannel0,uv,dFdx(uvscale),dFdy(uvscale));\n  if (c > 0) col *= 1.0-t.x;\n  if (alert) col.gb = 1.0-col.gb;\n  outColor = vec4(col,1);  \n}\n// C++ program to generate and print test data.\n// Specify number of digits and seed on command line.\n/*\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nbool issubnormal(uint n) {\n  return n != 0 && (n & 0x7f800000) == 0;\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 3) {\n    fprintf(stderr, \"Usage: %s <digits> <frame>\\n\", argv[0]);\n    exit(0);\n  }\n  int digits = strtol(argv[1],0,0);\n  uint frame = strtoul(argv[2],0,0);\n  for (int row = 0; row < 15; row++) {\n    for (int col = 0; col < 3; col++) {\n      float x = frame;\n      uint n = 0;\n      if (row > 0 || col > 0) {\n        n = ihash(ihash(frame) ^ row ^ (col << 16));\n        memcpy(&x,&n,sizeof(x));\n      }\n      printf(\"%*.*g%s\",digits+7,digits,x,!issubnormal(n)?\" \":\"*\");\n    }\n    printf(\"\\n\");\n  }\n}\n*/", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1835, 1958, 1988, 1988, 2002], [5455, 5496, 5522, 5604, 5643], [5645, 5645, 5696, 5717, 7337]], "test": "untested"}
{"id": "sdscRr", "name": "box factory", "author": "FabriceNeyret2", "description": "Mouse controls, camera.  swap #4 for textu\n\nreference: ( but I do the symmetric way )\n[url]https://twitter.com/akira2768922/status/1475077131151769613[/url]\n[url]https://www.reddit.com/r/desmos/comments/ry7zo8/production_line_manufacturing_boxes_d/[/url]\n", "tags": ["origami", "reproduction"], "likes": 62, "viewed": 664, "published": 3, "date": "1641819413", "time_retrieved": "2024-07-30T17:10:53.699610", "image_code": "#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))                       // axial rotation\n#define rot3(P,A,a)   ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) ) // 3D rotation\n#define D(u)            vec4( vec3( smoothstep( 0., .1 ,  .5 - max(u.x,u.y) ) ), 1 ) // tile decoration\n//#define D(u)          texture( iChannel0, u )                            // tile decoration\n\nvoid mainImage(out vec4 O, vec2 U)\n{ \n    vec4  C = O-=O;\n    vec3  R = iResolution, c,A,\n          D = normalize(vec3(U+U-R.xy, 5.*R.y)),          // ray direction\n          p = vec3(0,0,-20), q,                           // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,6,0)/1e2*cos(.5*iTime+vec3(0,11,0))+vec3(0,.12,0);\n    M = vec3(0,.5,0) - 6.3*M;      \n    p.yz *= rot(M.y),                                     // camera rotations\n    p.xz *= rot(M.x); \n    D.yz *= rot(M.y),         \n    D.xz *= rot(M.x);\n    float T = mod(iTime,2.), n,i,t,a,s;\n    p.z += T - 7.;\n    for ( i=0.; i<10.; i++ ) {                            // --- folded parts ----------------\n        n = D.z > 0. ? 9.-i : i;                          // parse front to back\n        t = mod(T+n,6.), a = 1.57*fract(t);\n        vec2 CS = .707*sin(a+1.57/2.+vec2(1.57,0));\n        if (T<1.) c = vec3(3.,  0, -2.5), c.xy += CS, A = vec3( 0,0,1); // even roll\n        else      c = vec3(2.5, 0, -3. ), c.zy += CS, A = vec3(-1,0,0); // odd roll\n        c.xz -= floor(t/2.); c.z -= n;\n        if (mod(n,2.)>0.) c.x = -c.x, int(t)%2>0 ? c.x++ : c.z++, A.z = -A.z; // left side\n     // if ( (T>1. && n>3. ) || n>5. ) c = .5-vec3(0, 0, n<6. ? 10-int(t)%2 : 5+int(n) ), a=0.; // cubes tail\n        if ( (T>1. && n>3. ) || n>5. ) c = .5-vec3(0, n>4.?T+n-6.:0., n<6. ? 10-int(t)%2 : 5+int(n) ), // a = 0.;\n                                       A = vec3(-1,0,0), n!=6.-floor(T) ? a=0.: a;\n        q = p-c;\n     // if ( dot(q,q) - dot(q,D)*dot(q,D) < 1.  ) {\n            vec3 Pr = rot3(q,A,a), Dr = rot3(D,A,a),      // cube frame  \n                  v = (-.5*sign(Dr) - Pr ) / Dr ,P;       // intersection with cube planes\n     // if ( dot(Pr,Pr) - dot(Pr,Dr)*dot(Pr,Dr) < 1.  ) { // Bbox. why not working ?\n            int j;                                        // draw cube faces corresponding to folds\n            #define inter(i,s) P = abs(Pr + v[i]*Dr);                   \\\n                         j = int[](1,3,2,5,0,4)[ s Dr[i]>0.?3+i:i ];    \\\n                         if( v[i]>0. && max(P.x,max(P.y,P.z)) < .501 )  \\\n                        /**/ if( j <= int(T)+int(n/2.)*2 ) /**/         \\\n                          /**/  { int t = n<6. ? int(T):1; O += D( vec2( P[(i+1+t)%3], P[(i+2-t)%3] ) ); break;} /**/ \\\n                            //  { O[j%3] =j<3?.5:1.; O.a++; break; }   // attempt of time-consistant colors\n                            //  { O[i] =.5+step(s Dr[i],0.); return; } // debug : draw color cube\n            s = sign(c.x-.5);                             // left side \n            inter(0, s*); inter(1,); inter(2,);           // front cube faces\n            v = ( .5*sign(Dr) - Pr ) / Dr ,P;             // rear cube faces\n            inter(0,-s*); inter(1,-); inter(2,-);\n     // }\n    }\n    if ( O.a > 0. && ( D.y < 0. || D.z>0. && n+T > 6. ) ) return;\n                                                          // --- unfolded tiling -------------\n    q = p;                                                // intersection with plane y=0\n    t = -q.y/D.y; q += t*D;\n    if (t>0.) C += 1.-t/200., C.a = 1.;                   // pseudo shading\n\n    p = floor(q); if (3.*abs(p.x)-p.z > 10.+step(p.x,0.) ) C-=C;  // trim cells left by rolling cubes\n    if ( T > 1. &&  abs(p.x)<=2. && p.z == -9.+3.*abs(p.x)-step(p.x,0.) )  C-=C;\n    q.x += mod(ceil(q.z),2.);                             // offset\n    if  ( q.x < -2. || q.x > 4. || q.z < -10.) C-=C;      // tiling limits\n    \n    C *= D( abs( fract(q.xz) -.5) );                      // tiles decoration\n    \n    O = mix(O,C,C.a);                                     // --- blend folded and straight parts ---\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdscRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftc3zj", "name": "#Genuary Day 9 Architecture", "author": "cmarangu", "description": "My creation for #genuary #genuary2022 Genuary 2022 Day 9 day9 genuary9 nine Architecture\n// [url]https://genuary.art/prompts#jan9[/url]", "tags": ["voxel", "minecraft", "city", "genuary", "genuary2022"], "likes": 5, "viewed": 368, "published": 3, "date": "1641802677", "time_retrieved": "2024-07-30T17:10:54.643088", "image_code": "// Title: #Genuary Day 9 Architecture\n// Started: 2022 1/9\n// Tags: city, voxel, minecraft, genuary, genuary2022\n// Description: My creation for #genuary #genuary2022 Genuary 2022 Day 9 day9 genuary9 nine Architecture\n// [url]https://genuary.art/prompts#jan9[/url]\n\n\n//  i know more\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307\n// 816406286 208998628034 8253421170679821480865132823066470938446095505\n#define TAU 6.2831853071795864\n\n// frequency in THz\n#define freqr 430.\n#define freqg 545.\n#define freqb 660.\n\n\n\n#define arg mod(  float(iFrame)  /30./30. +0.9, 1.)\n\n\n//\n// sky map\n//\n\n//#define inter_sky vec4(vec3(0.), 1e9)\nconst vec4 inter_sky = vec4(vec3(0.), 1e9);\nfloat sky_map (in float freq, in vec3 d) {\n    #if 0\n    //vec3 col = texture(iChannel2, d).rgb;\n    #elif 0\n        vec3 col = vec3(1.);\n        col = vec3(0.);\n    #elif 0\n    vec3 col = vec3(.7, 1., 1.);\n    #else\n    vec3 col = vec3(0., 0., 100./255.);\n    #endif\n    //\n    if (freq == freqr) {\n        return col.r;\n    }\n    else if (freq == freqg) {\n        return col.g;\n    }\n    else if (freq == freqb) {\n        return col.b;\n    }\n}\n\n\n\n//\n// define world voxel pos\n//\n\nfloat blocktyp (vec3 pf) {\n    if (length(vec2(\n        pf.x+5.+16.*cos(pf.z*16./1000.*TAU),\n        pf.y-5.+16.*sin(pf.z*16./1000.*TAU))) < 2.) { return 2.; }\n    if (length(vec2(\n        pf.x+5.+16.*cos(pf.z*13./1000.*TAU),\n        pf.y-5.+16.*sin(pf.z*23./1000.*TAU))) < 2.) { return 2.; }\n    //if (length(vec2(pf.x, pf.y-5.)) < 2.) { return 2.; }\n    float h = -10.;\n    h += 8.*texture(iChannel1, vec2(pf.x/1000.+.5, fract(pf.z/1000.)) ).r;\n    //h += 10.*sin(pf.z/100.*TAU);\n    //h = 0.;\n    if (pf.y >= h+1.) {\n        return 0.;\n    }\n    return 1.;\n}\n\n\n\n\n\n//\n// intersect primitive shapes\n//\n\n// plane - one liner lol\n// #define SDF_plane(p, n) ( dot(normalize(p), n)*length(p) )\nfloat SDF_plane (vec3 p, vec3 n) { return dot(normalize(p), n)*length(p); }\n#define inter_plane_short(p, d, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, n) (\\\n//dot(n, d) > 1e-6 ? dot(-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n//\n// SDF\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.48), 0.) )-.015)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n#define inf vec2(1e-4, 0.)\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // test\n    //return inter_sphere(p, d, 1.);\n    //\n    // camp is unmodified p\n    vec3 camp = p;\n    //\n    #if 0\n    // space skip to sphere (.5, .5, .5) r=1.8 (causes bug)\n    vec4 temp;\n    temp = inter_sphere(p-vec3(.5), d, 1.8);\n    if (temp.w >= inter_sky.w) {\n        return inter_sky;\n    }\n    else {\n        if (length(p-vec3(.5)) > 1.8) {\n            p += d*temp.w;\n        }\n    }\n    //return temp;\n    #endif\n    //\n    //\n    float SDFp;\n    //for (int i=0; i<111222; ++i) {\n    //for (int i=0; i<11222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        //if (abs(SDFp) < 1e-1) {\n        if (abs(SDFp) < 5e-4) {\n            return vec4(\n                normalize(\\\n                    vec3(\n                        SDF(p+inf.xyy),\n                        SDF(p+inf.yxy),\n                        SDF(p+inf.yyx)\n                    )-SDFp\n                )*sign(SDFp),\n                length(p-camp)\n            );\n        }\n        p += d*abs(SDFp)*.5;\n        //p += d*abs(SDFp)*.99;\n        //p += d*abs(SDFp);\n        //if (abs(SDFp) > 10.) {\n        // sqrt(3) ~ 1.732\n        if (abs(SDFp) > 1.8) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 20., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    //pane1n = normalize(vec3(1., 10., 6.));\n    //pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p-pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p-pane1c, d, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p-pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        //blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        //blockhere = qf.x*0.+qf.y*10.+qf.z*10. <= 0.;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        blockhere = blocktyp(qf) != 0.;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\n\n\n\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    // mouse pos normalized -1 to 1 y aspect ratio x\n    //\n    vec2 maus = (iMouse.xy-iResolution.xy/2.)/(iResolution.y/2.);\n    if (iMouse.x == 0.) {\n        maus.x = 0.;\n        maus.y = 0.;\n    }\n    //\n    //\n    // view rotation matrices\n    //\n    #define phi clamp(maus.y*3., -1., 1.)*PI*.5\n    //#define phi -atan(1./sqrt(2.) )\n    mat2 zenith = transpose(\n        mat2(\n            cos(phi), cos(PI*.5+phi),\n            sin(phi), sin(PI*.5+phi)\n        )\n    );\n    #define theta maus.x*TAU\n    //#define theta -PI*.75\n    mat2 azimuth = transpose(\n        mat2(\n            cos(theta), cos(PI*.5+theta),\n            sin(theta), sin(PI*.5+theta)\n        )\n    );\n    //\n    //\n    // multisampling loop\n    //\n    fragColor = vec4(0., 0., 0., 1.);\n    // spw - width of multisample grid\n    // spp - number of random jitter/monte carlo integration per sub-pixel thing\n    #define spw 1.\n    #define spp 1.\n    float freq, ox, oy; vec3 rand;\n    //\n    #define numsamples spw*spw*spp\n    for (float samplei=0.; samplei<3.*numsamples; ++samplei) {\n        float samplei2 = samplei;\n        if (mod(samplei, 3.) == 0.) {\n            freq = freqr;\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            freq = freqg;\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            freq = freqb;\n        }\n        samplei2 = floor(samplei2/3.);\n        ox = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        oy = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        samplei2 += (float(iFrame)+fragCoord.x)*numsamples;\n        rand = vec3(\n            fract(\n                sin(\n                    mod(\n                        samplei2*1.234567890123,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*10.110010101,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*222.222222222,\n                        TAU\n                    )\n                )\n            )\n        );\n        #if 1\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.);\n        #else\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.)*vec2(1., -1.);\n        #endif\n        //\n        //\n        float retina = 0.;\n        float absorb = 1.;\n        //\n        #if 1\n        // perspective\n        //vec3 p = vec3(screen.x, screen.y, 0.);\n        //vec3 d = normalize(p-vec3(0., 0., -1.));\n        vec3 p = vec3(0.);\n        vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n        #else\n        // orthogonal\n        vec3 p = vec3(screen.x, screen.y, 0.)*4.*(sqrt(2.)/2.);///cos(30.*PI/180.);\n        vec3 d = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        //\n        p.zy = zenith*p.zy;\n        d.zy = zenith*d.zy;\n        p.zx = azimuth*p.zx;\n        d.zx = azimuth*d.zx;\n        //\n        d = normalize(d);\n        //p += vec3(0., 2., 0.);\n        //p -= d*20.;\n        p.z += arg*1000.;\n        //\n        //\n        //\n        //#define numbounces 50.\n        #define numbounces 3.\n        for (float bounces=0.; bounces<numbounces; ++bounces) {\n        //for (float bounces=0.; bounces<1.; ++bounces) {\n            //\n            if (absorb <= .1) {\n                break;\n            }\n            //\n            float samplei3 = bounces;\n            samplei3 += (float(iFrame)+fragCoord.x)*numbounces;\n            //\n            vec3 rand2 = vec3(\n                fract(\n                    sin(\n                        mod(\n                            samplei3*1.234567890123,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*10.110010101,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*222.222222222,\n                            TAU\n                        )\n                    )\n                )\n            );\n            //\n            vec4 inter_closest = inter_sky;\n            vec4 inter_current;\n            float inter_id;\n            //\n            #define tempc vec3(0., -1.1, 0.)\n            #define tempn normalize(vec3(0., 1., 0.))\n            //inter_current = inter_plane(p-tempc, d, tempn );\n            inter_current = inter_minecraft(p, d);\n            vec3 tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 2.;\n                //inter_id = blocktyp(floor(tempp))+1.;\n                //inter_id *= sign(SDF_plane(p-tempc, tempn ));\n                inter_id *= sign( SDF(fract(tempp)) );\n            }\n            #undef tempc\n            #undef tempn\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // too far - hits sky\n                break;\n            }\n            else {\n                p += d*inter_closest.w;\n                //\n                //\n                //\n                //\n                //if (abs(inter_id) == 1.) {}\n                //if (abs(inter_id) == 2.) {\n                if (blocktyp(floor(tempp)) == 2.) {\n                    //\n                    // hits building\n                    //\n                    //\n                    // Texture\n                    //\n                    //vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    vec3 TEXp = vec3(.0);\n                    vec2 win;\n                    if (abs(fract(p).y-.5) < .48) {\n                        win = fract(p.zy*2.);\n                        if (length(max(abs(win-vec2(.5))-vec2(.2), 0.) )-.015 < 0.) {\n                            TEXp = vec3(1., 1., 0.);\n                        }\n                    }\n                    else {\n                        TEXp = vec3(0.);\n                    }\n                    //\n                    #if 0\n                    #define temp 1.\n                    //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                        TEXp *= .5;\n                    }\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 0\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #else\n                    \n                    if (freq == freqr) {\n                        retina += absorb*TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        retina += absorb*TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        retina += absorb*TEXp.b;\n                    }\n                    absorb *= 0.;\n                    #endif\n                    //\n                    // environment light\n                    //\n                    //absorb *= .4;\n                    //if (abs(inter_id) == 2.) {\n                        //absorb *= 0.;\n                    //}\n                    //else if (abs(inter_id) == 3.) {\n                    //    d = reflect(d, inter_closest.xyz);\n                    //}\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n                else {\n                    //\n                    // hits ground\n                    //\n                    //implement brdf\n                    //implement different inter_id based on blocktyp(floor(p))\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    //TEXp = vec3(1.);\n                    TEXp = mix(vec3(0., 1., 1.), vec3(0., 0., 1.), fract(p).y)*.5;\n                    if (abs(fract(p).y-.5) > .48) {\n                        TEXp = vec3(.0, .0, .0);\n                    }\n                    else if (abs(fract(p).x-.5) > .48) {\n                        TEXp = vec3(.0, .9, .9);\n                    }\n                    else {\n                        TEXp = vec3(.0, .7, .7);\n                    }\n                    if (abs(fract(p).y-.5) < .48) {\n                        TEXp = mix(TEXp, vec3(0., 0., .9), fract(p.y));\n                    }\n                    else {\n                        /*TEXp += .2*pow(.5+.5*sin( (p.x*4.+\n                            (.5+.5*sin(p.z*TAU))\n                        )*TAU ), 4.);*/\n                        #if 1\n                        #define temp 1.\n                        //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                        if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                            TEXp += .25;\n                        }\n                        #endif\n                    }\n                    //\n                    #if 0\n                    #define temp 1.\n                    //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                        TEXp *= .5;\n                    }\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 0\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #else\n                    \n                    if (freq == freqr) {\n                        retina += absorb*TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        retina += absorb*TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        retina += absorb*TEXp.b;\n                    }\n                    //absorb *= 0.;\n                    #endif\n                    //\n                    // environment light\n                    //\n                    absorb *= .4;\n                    //if (abs(inter_id) == 2.) {\n                        //absorb *= 0.;\n                    //}\n                    //else if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    //}\n                    /*#if 1\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 0\n                    // specular refraction\n                    float eta = 1.01;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    */\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n            }\n            //\n        }\n        //\n        retina += absorb*sky_map(freq, d);\n        if (mod(samplei, 3.) == 0.) {\n            fragColor.rgb += retina*vec3(1., 0., 0.);\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            fragColor.rgb += retina*vec3(0., 1., 0.);\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            fragColor.rgb += retina*vec3(0., 0., 1.);\n        }\n    }\n    fragColor.rgb /= 1.*spw*spw*spp;\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[713, 713, 755, 755, 1158], [1195, 1195, 1221, 1221, 1756], [1799, 1886, 1920, 1920, 1961], [2068, 2164, 2207, 2207, 2527], [2925, 2925, 2958, 3042, 4210], [4211, 4211, 4250, 4288, 7544]], "test": "untested"}
{"id": "flcXW4", "name": "Path-Traced Black Hole v2", "author": "Zi7ar21", "description": "Path-Traced Black Hole v2: Electric Boogaloo\n\nStill more to be done, idk it's all just one big experiment... I've been doing more with C/C++ lately, I need to get back to doing more shaders.", "tags": ["pathtrace", "pathtracing", "pathtracer", "blackhole", "tracing", "traced", "tracer", "optics", "trace", "path", "hole", "optic", "black", "bh", "pathtraced"], "likes": 37, "viewed": 3540, "published": 3, "date": "1641790365", "time_retrieved": "2024-07-30T17:10:55.593546", "image_code": "// ####### Path-Traced Black Hole v2 #######\n// Made by Jacob Bingham (Zi7ar21) on January 9th, 2022\n// Merry (Late) Christmas! :)\n\n// Last Updated on January 22nd, 2022 at 02:46 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/flcXW4\n\n// Version 1: https://www.shadertoy.com/view/7tS3DW\n\n/*\n## Features\n\n- Gravitational Distortion\n- Monte-Carlo Bloom\n- Volumetric Path-Tracing\n*/\n\n/*\n# Zi7ar21's Epic License\n\nThis applies to...\n\n- Code I wrote\n  - You must respect the individual licenses of any snippets in the source that aren't mine\n\nYou are free to...\n\n- Use this code however you want (as long as it complies with this license)\n  - e.g. personal and commercial projects\n  - Especially open-source projects\n\nAs long as...\n\n- You use it ethically\n  - e.g. no using it for NFT's, which are unsustainable and stupid\n- You keep comments in the source that credit and link to snippets of code that aren't mine\n  - e.g. Comments such as \"PCG Random: https://www.pcg-random.org/\"\n  - Of course, you must also respect whatever licenses they use\n\nRemember, we are programmers, not lawyers! :)\n*/\n\n// Check out some of my friends!\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n// skythedragon\n// https://www.shadertoy.com/user/skythedragon\n\n// We have a Discord Server focused on STEM and Memes, DM me (@Zi7ar21#2168) if you're interested.\n\n// Render Preview\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the Image Export Buffer\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Preprocessor #####\n\n/*\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n/*\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n// ##### Parameters #####\n\n// Camera Field of View\n#define CAMERA_FOV 1.0\n\n// Tonemap Exposure\n#define EXPOSURE 1.0\n\n// Enable sRGB gamma thingy\n#define sRGB_transfer\n\n// Enable Monte-Carlo Bloom\n#define BLOOM\n\n// Radius of the Black Hole\n#define blackhole_radius 0.6\n\n// Timestep (smaller = slower)\n#define delta_t 0.05\n\n// Maximum number of times a light path can bounce before getting yeeted\n#define MAX_BOUNCES 4u\n\n// Use Gradient Noise instead of Value Noise (slower, should look nicer)\n//#define USE_GRADIENT_NOISE\n\n//\n#define MAX_DIST 4.0\n\n// Maximum steps a light path can take before getting yeeted\n#define MAX_STEPS 16384u\n\n// Camera Sensor Size (for DoF, unused by default, uncomment it in Buffer A)\n//#define sensorSize 0.035\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// ##### Maths #####\n\n// Rotate a 2-Component Vector\nvec2 rotate(vec2 vector, float theta)\n{\n    float s = sin(theta), c = cos(theta);\n    return vec2(vector.x * c - vector.y * s, vector.x * s + vector.y * c);\n}\n\n// Dot Product\n// for optimizations involving comparing length, for example:\n// min(length(vector0), length(vector1))\n// This can be simplified and save using an extra sqrt() by changing it to:\n// sqrt(min(dotp(vector0), dotp(vector1)))\n\nfloat dot_p(vec2 vector) { return dot(vector, vector); }\nfloat dot_p(vec3 vector) { return dot(vector, vector); }\nfloat dot_p(vec4 vector) { return dot(vector, vector); }\n\n// ##### Color Management #####\n\n// Sh*tty HDR Tonemap(tm)\nvec3 tonemap(vec3 color)\n{\n    color = smoothstep( 0.0, 1.0, 1.0 - exp(-color * EXPOSURE) );\n\n    #ifdef sRGB_transfer\n    // sRGB Color Component Transfer: https://www.color.org/chardata/rgb/sRGB.pdf\n    color  = vec3(\n    color.r > 0.0031308 ? (pow(color.r, 1.0 / 2.4) * 1.055) - 0.055 : color.r * 12.92,\n    color.g > 0.0031308 ? (pow(color.g, 1.0 / 2.4) * 1.055) - 0.055 : color.g * 12.92,\n    color.b > 0.0031308 ? (pow(color.b, 1.0 / 2.4) * 1.055) - 0.055 : color.b * 12.92);\n    #endif\n\n    return clamp(color, 0.0, 1.0);\n}\n\n/*\n// https://www.color.org/chardata/rgb/sRGB.pdf\nconst mat3 XYZ2sRGB = mat3(\n 3.2406255, -1.5372080, -0.4986286,\n-0.9689307,  1.8757561,  0.0415175,\n 0.0557101, -0.2040211,  1.0569959);\n*/\n/*\n// https://www.shadertoy.com/view/4s3cRr\nconst mat3 XYZ2sRGB = mat3(\n 3.2404542, -1.5371385, -0.4985314,\n-0.9692660,  1.8760108,  0.0415560,\n 0.0556434, -0.2040259,  1.0572252);\n*/\n/*\n// https://www.shadertoy.com/view/tsKczy\nconst mat3 XYZ2sRGB = mat3(\n 3.2409699419, -1.5373831776, -0.4986107603,\n-0.9692436363,  1.8759675015,  0.0415550574,\n 0.0556300797, -0.2039769589,  1.0569715142);\n*/\n\n// Every XYZ to sRGB matrix I find is slightly different, so here is my own:\nconst mat3 XYZ2sRGB = mat3(\n 3.240, -1.537, -0.499,\n-0.969,  1.876,  0.042,\n 0.056, -0.204,  1.057);\n\n// Convert XYZ to sRGB\nvec3 xyz2rgb(vec3 color_xyz)\n{\n    // I can't remember the order of GLSL matrix multiplication,\n    // so this function exists instead of doing it every time\n    return color_xyz * XYZ2sRGB;\n}\n\n// Convert sRGB to XYZ\nvec3 rgb2xyz(vec3 color_rgb)\n{\n    return color_rgb * transpose(XYZ2sRGB);\n}\n\n// idk what to cite, here are some shaders that all use this\n// https://www.shadertoy.com/view/tsKczy\n// https://www.shadertoy.com/view/MslSDl\n// https://www.shadertoy.com/view/MttyzB\nvec3 blackbodyXYZ(float t)\n{\n    // https://en.wikipedia.org/wiki/Planckian_locus\n    float u = (0.860117757 + 1.54118254E-4 * t + 1.28641212E-7 * t * t) / (1.0 + 8.42420235E-4 * t + 7.08145163E-7 * t * t);\n    float v = (0.317398726 + 4.22806245E-5 * t + 4.20481691E-8 * t * t) / (1.0 - 2.89741816E-5 * t + 1.61456053E-7 * t * t);\n\n    // https://en.wikipedia.org/wiki/CIE_1960_color_space\n    // https://en.wikipedia.org/wiki/XYZ_color_space\n\n    // Hippitty Hoppity through magic convert the planckian locus to some weird Color space linked to XYZ\n    vec2 xyy = vec2(3.0 * u, 2.0 * v) / (2.0 * u - 8.0 * v + 4.0);\n\n    // And then convert from the shart color space to XYZ\n    return vec3(xyy.x / xyy.y, 1.0, (1.0 - xyy.x - xyy.y) / xyy.y);\n}\n\n// ##### Random Number Generator #####\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\n// Random Number Generator Seed\nuint ns;\n\n// Uniform Random Value Between 0.0 and 1.0\nfloat rand()\n{\n    // Update RNG\n    ns = triple32(ns);\n\n    return float(ns) / float(0xFFFFFFFFu);\n}\n\n// 2-Component Uniform Random Vector\nvec2 rand2()\n{\n    vec2 vector;\n    vector.x = rand();\n    vector.y = rand();\n    return vector;\n}\n\n// 3-Component Uniform Random Vector\nvec3 rand3()\n{\n    vec3 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.z = rand();\n    return vector;\n}\n\n// 4-Component Uniform Random Vector\nvec4 rand4()\n{\n    vec4 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.z = rand();\n    vector.w = rand();\n    return vector;\n}\n\n// Uniformly distributied random point on a unit circle\nvec2 udir2()\n{\n    float z = rand();\n    float r = two_pi * z;\n    float s = sin(r), c = cos(r);\n    return vec2(s, c);\n}\n\n// Uniformly distributed random point on the surface of a unit sphere\nvec3 udir3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2( two_pi * z.x, acos(2.0 * z.y - 1.0) );\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// 2D Gaussian Distribution\nvec2 nrand2(vec2 mean, float sigma)\n{\n    vec2 z = rand2();\n    return mean + sigma * sqrt( -2.0 * log(z.x   ) ) * vec2(cos(two_pi * z.y), sin(two_pi * z.y) );\n}\n\n// 3D Gaussian Distribution\nvec3 nrand3(vec3 mean, float sigma)\n{\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxy ) ) * vec3(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w) );\n}\n\n// 4D Gaussian Distribution\nvec4 nrand4(vec4 mean, float sigma)\n{\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxyy) ) * vec4(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w), sin(two_pi * z.w) );\n}\n\n// ##### Misc #####\n\n// Blackman-Harris Pixel Filter\nvec2 pixel_filter(vec2 pixel_coord)\n{\n    // Gaussian Pixel Filter\n    //return nrand2(pixel_coord, 0.5);\n\n    // https://www.desmos.com/calculator/fcdor4uxyt\n    float r = pow(2.0 * acos(1.0 - rand()) / pi, 0.78539821704);\n    return pixel_coord + rand() * udir2();\n\n    // https://en.wikipedia.org/wiki/Window_function#BlackmanHarris_window\n    // w[n] = a0-a1*cos(2*pi*n/N)+a2*cos(4*pi*n/N)-a3*cos(6*pi*n/N)\n    // a0 = 0.35875; a1 = 0.48829; a2 = 0.14128; a3 = 0.01168\n    float n = 0.5 * rand() + 0.5;\n    float w = 0.35875 - 0.48829 * cos(2.0 * pi * n) + 0.14128 * cos(4.0 * pi * n) - 0.01168 * cos(6.0 * pi * n);\n    return pixel_coord + (udir2() * 2.0 * w);\n}", "buffer_a_code": "// ##### Rendering #####\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4  = fract( p4 * vec4(0.1031, 0.1030, 0.0973, 0.1099) );\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract( (p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat noise(vec3 p, int octave)\n{\n    #ifdef USE_GRADIENT_NOISE\n    // Inigo Quilez Gradient Noise\n    // https://www.shadertoy.com/view/Xsl3Dl\n\n    vec3 f = fract(p);\n    vec3 i = floor(p);\n\n    vec3 s = smoothstep(0.0, 1.0, f);\n\n    vec3 h0 = hash44( vec4(i + vec3(0, 0, 0), octave) ).xyz;\n    vec3 h1 = hash44( vec4(i + vec3(1, 0, 0), octave) ).xyz;\n    vec3 h2 = hash44( vec4(i + vec3(0, 1, 0), octave) ).xyz;\n    vec3 h3 = hash44( vec4(i + vec3(1, 1, 0), octave) ).xyz;\n    vec3 h4 = hash44( vec4(i + vec3(0, 0, 1), octave) ).xyz;\n    vec3 h5 = hash44( vec4(i + vec3(1, 0, 1), octave) ).xyz;\n    vec3 h6 = hash44( vec4(i + vec3(0, 1, 1), octave) ).xyz;\n    vec3 h7 = hash44( vec4(i + vec3(1, 1, 1), octave) ).xyz;\n\n    float v0 = dot( h0, f - vec3(0, 0, 0) );\n    float v1 = dot( h1, f - vec3(1, 0, 0) );\n    float v2 = dot( h2, f - vec3(0, 1, 0) );\n    float v3 = dot( h3, f - vec3(1, 1, 0) );\n    float v4 = dot( h4, f - vec3(0, 0, 1) );\n    float v5 = dot( h5, f - vec3(1, 0, 1) );\n    float v6 = dot( h6, f - vec3(0, 1, 1) );\n    float v7 = dot( h7, f - vec3(1, 1, 1) );\n\n    return smoothstep(-0.5, 0.5, mix(\n    mix(mix(v0, v1, s.x), mix(v2, v3, s.x), s.y),\n    mix(mix(v4, v5, s.x), mix(v6, v7, s.x), f.y),\n    s.z)\n    );\n    #else\n    \n    vec3 f = fract(p);\n    vec3 i = floor(p);\n\n    vec3 s = smoothstep(0.0, 1.0, f);\n\n    float t0 = hash44( vec4(i + vec3(0, 0, 0), octave) ).x;\n    float t1 = hash44( vec4(i + vec3(1, 0, 0), octave) ).x;\n    float t2 = hash44( vec4(i + vec3(0, 1, 0), octave) ).x;\n    float t3 = hash44( vec4(i + vec3(1, 1, 0), octave) ).x;\n    float t4 = hash44( vec4(i + vec3(0, 0, 1), octave) ).x;\n    float t5 = hash44( vec4(i + vec3(1, 0, 1), octave) ).x;\n    float t6 = hash44( vec4(i + vec3(0, 1, 1), octave) ).x;\n    float t7 = hash44( vec4(i + vec3(1, 1, 1), octave) ).x;\n\n    return mix(\n    mix(mix(t0, t1, s.x), mix(t2, t3, s.x), s.y),\n    mix(mix(t4, t5, s.x), mix(t6, t7, s.x), f.y),\n    s.z);\n    #endif\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec3 p, int iter)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < iter; i++)\n    {\n        value += atten * noise(scale * p, iter);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.5;\n    }\n\n    return accum != 0.0 ? value / accum : value;\n}\n\n// Basically copied and pasted from michael0884\n// https://rantonels.github.io/starless/\nvec3 gravitational_field(vec3 p)\n{\n    /*\n    vec3 r = p / blackhole_radius;\n    float R = length(r);\n    return -4.0 * 1.5 * r / pow(R, 5.0);\n    */\n\n    vec3 r = p / blackhole_radius;\n    float R = length(r);\n    return -6.0 * r / (R * R * R * R * R); // get rid of that nasty pow() calculation\n}\n\n// crappy redshift/blueshift approximation\nvec3 shift_color(vec3 color, float t) // color (rgb), wavelength (nm) \n{\n    /*\n    float k0 = smoothstep(0.0, 1.0,  t);\n    float k1 = smoothstep(0.0, 1.0, -t);\n \n    if(t > 0.0)\n    {\n        color = vec3(\n        mix(color.r, 0.0    , k0),\n        mix(color.g, color.r, k0),\n        mix(color.b, color.g, k0)\n        );\n    }\n    else\n    {\n        color = vec3(\n        mix(color.r, color.g, k1),\n        mix(color.g, color.b, k1),\n        mix(color.b, 0.0    , k1)\n        );\n    }\n\n    return color;\n    */\n\n    // convert rgb to xyz\n    color = rgb2xyz(color);\n\n    // shift approx\n    //color = ;\n\n    // convert xyz to rgb\n    color = xyz2rgb(color);\n\n    return color;\n}\n\nfloat sample_volume(in vec3 p, out vec3 c, out vec3 e)\n{\n    c = vec3(0.3, 0.2, 0.1);\n    e = vec3(0);\n\n    //if(dot_p(p.xz) > 8.0 || abs(p.y)  > 0.33)\n    if(dot_p(p.xz) > 8.0 || p.y * p.y > 0.3 * 0.3) // I think this might be slightly faster, doesn't matter\n    {\n        return 0.0;\n    }\n\n    float n0 = fbm(20.0 * vec3(rotate( p.xz, (8.0 * p.y) + ( 4.0 * length(p.xz) ) ), p.y).xzy, 8);\n\n    float d_falloff = length(vec3(0.12, 7.50, 0.12) * p);\n    float e_falloff = length(vec3(0.20, 8.00, 0.20) * p);\n\n    float t = rand();\n    e = xyz2rgb( blackbodyXYZ( (4000.0 * t * t) + 2000.0 ) );\n    e = clamp(e / max(max(max(e.r, e.g), e.b), 0.01), 0.0, 1.0);\n\n    //e *= 128.0 * max(n0 - e_falloff, 0.0) / (pow(dot_p(0.5 * p), 1.5) + 0.05);\n    e *= 128.0 * max(n0 - e_falloff, 0.0) / (dot_p(0.5 * p) + 0.05);\n\n    return 128.0 * max(n0 - d_falloff, 0.0);\n}\n\nvec3 sky_radiance(vec3 dir)\n{\n    return vec3(0);\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec3 att = vec3(1); // Light Attenuation\n    vec3 r   = vec3(0); // Emission\n\n    vec3 p = ro + (rand() * delta_t * rd);\n    vec3 v = rd;\n\n    uint bounces = 0u;\n\n    for(uint i = 0u; i < MAX_STEPS; i++)\n    {\n        if(bounces > MAX_BOUNCES) // light path bounced too many times, discard the sample\n        {\n            break;\n        }\n\n        if(dot_p(p) < blackhole_radius * blackhole_radius) // light fell into the black hole\n        {\n            return r;\n        }\n\n        if(dot_p(p) > 3.6 * 3.6) // light escaped the scene\n        {\n            r += att * sky_radiance( normalize(v) );\n            return r;\n        }\n\n        vec3 volume_color   ;\n        vec3 volume_emission;\n\n        float d = sample_volume(p, volume_color, volume_emission);\n\n        r += att * volume_emission * delta_t; // add emission\n\n        if(d > 0.0)\n        {\n            float absorbance = exp(-1.0 * delta_t * d);\n\n            if( absorbance < rand() ) // check if light decides to bounce\n            {\n                v = length(v) * reflect( normalize(v), udir3() );\n\n                att *= volume_color;\n\n                bounces++;\n            }\n        }\n\n        vec3 g = gravitational_field(p); // calculate gravitational influence on the light\n\n        v += g * delta_t; // update velocity\n        p += v * delta_t; // update position\n    }\n\n    //return vec3(0) ; // accumulate vec3(0)\n    return vec3(-1); // discards sample\n}\n\n/*\n// https://www.shadertoy.com/view/XtGBDW\n#define level 5u\n#define width (1u << level)\n#define area (width * width)\n\nuint hilbert_index(uvec2 p)\n{\n    uint index = 0u;\n\n    for(uint cur_level = width / 2u; cur_level > 0u; cur_level /= 2u)\n    {\n        uvec2 region = uvec2( greaterThan( ( p & uvec2(cur_level) ), uvec2(0u) ) );\n\n        index += cur_level * cur_level * ( (3u * region.x) ^ region.y );\n\n        if(region.y == 0u)\n        {\n            if(region.x == 1u)\n            {\n                p = uvec2(width - 1u) - p;\n            }\n\n            p.xy = p.yx;\n        }\n    }\n\n    return index;\n}\n\nvoid INIT_RNG()\n{\n    //ns = uint(iFrame) + 1u;\n    //ns = uint(iFrame) + uint(gl_FragCoord.x + gl_FragCoord.y * iResolution.x) + 1u;\n    ns = area * uint(iFrame) + hilbert_index( uvec2(gl_FragCoord.xy) ) + 1u;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Accumulation Buffer\n    fragColor = iFrame != 0 ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0.0);\n\n    // Initialize the Random Number Generator\n    ns = uint(iFrame) * uint(iResolution.x * iResolution.y) + uint(fragCoord.x + fragCoord.y * iResolution.x);\n    //INIT_RNG();\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0 * (pixel_filter(fragCoord) - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Bloom\n    #ifdef BLOOM\n    float r = rand();\n    if(r < 0.10)\n    {\n        uv = nrand2(uv, rand() * 0.015);\n    }\n    if(r > 0.90)\n    {\n        uv = nrand2(uv, rand() * 0.200);\n    }\n    #endif\n\n    mat3 rotmat = mat3(\n     0.8, -0.2, -0.0,\n     0.2,  0.8, -0.0,\n    -0.0, -0.0,  1.0);\n\n    // Normalize the Rotation Matrix\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n\n    /*\n    mat3 cam2world;\n\t{\n\t\tvec3 d = normalize(Target-Eye);\n\t\tvec3 r = normalize(cross(d, Up));\n\t\tvec3 u = cross(r, d);\n\t\tcam2world = mat3(r, u, d);\n\t}\n    */\n\n    vec3 ro = vec3(0.0, 0.2, 3.5);\n    vec3 rd = normalize(vec3(CAMERA_FOV * uv, -1.0) * rotmat);\n\n    // Render the Sample\n    vec3 color = radiance(ro, rd);\n\n    // Accumulate the Sample (reject if Inf or NaN)\n    fragColor += any( lessThan(color, vec3(0) ) ) || any( isinf(color) ) || any( isnan(color) ) ? vec4(0) : vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### Image Export #####\n// Shadertoy can export renders in the OpenEXR format!\n// Just press the little image icon buttom on the bottom right-hand side of the editor.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Compute and Output the Final Color\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb / texel.a : texel.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1643, 1661, 1718, 1753, 1939]], "test": "untested"}
{"id": "ssXyzN", "name": "Fractal Idea e", "author": "SnoopethDuckDuck", "description": "my first time playing with fractals basically", "tags": ["e"], "likes": 5, "viewed": 245, "published": 3, "date": "1641787558", "time_retrieved": "2024-07-30T17:10:56.359499", "image_code": "float newM(vec2 uv, float m) {\n    float m2 = 0.4 + 0.12 * cos(9. * length(uv) + 8. * atan(uv.y, uv.x) - iTime);\n    return 0.5 * mix(m, m2, 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 0.8 + 0.1 * cos(iTime);\n    float th = -0.1 * iTime;\n    mat2 M = mat2(cos(th), sin(th), -sin(th), cos(th));\n    uv = abs(M * uv);\n    \n    float m = 4. * newM(uv, 0.);\n    for (float i = 0.; i < 4.; i++) {\n        th += 4. * mlength(uv);\n        M = mat2(cos(th), sin(th), -sin(th), cos(th));\n        uv = abs(M * (uv - m));\n        m = newM(uv, m);\n    }\n\n    float d = length(uv - m );\n\n    float k = 0.75 * m;//0.75/iResolution.y;\n    float s = smoothstep(-k, k, -d + m);\n    //s = 2. * s * s;\n    vec3 e = vec3(1.);\n    vec3 col = s * pal(s * 2. * s + 0.15 * iTime, e, e, e, 0.4 * vec3(0.,0.33,0.66));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 148], [150, 150, 207, 207, 928]], "test": "untested"}
{"id": "ssfcRN", "name": "Magnet Simulation", "author": "wyatt", "description": "Rigid body physics + magnetism. ", "tags": ["magnetism"], "likes": 34, "viewed": 692, "published": 3, "date": "1641785278", "time_retrieved": "2024-07-30T17:10:57.413680", "image_code": "// Fork of \"Rigid Body Test 123\" by wyatt. https://shadertoy.com/view/fsscRr\n// 2022-01-10 00:45:24\n\nMain\n//if (iFrame % 8 > 0) discard;\nQ = sin(5.3+U.y/R.y+(1.+U.x/R.x)*vec4(1,2,3,4));\nQ *= .5*(exp(-30.*U.x/R.x)+exp(-30.*(R.x-U.x)/R.x)+exp(-30.*U.y/R.y)+exp(-30.*(R.y-U.y)/R.y));\nQ = 1.-Q;\nvec2 m = vec2(0);\nvec2 p = U;\nfor (float i = 0.; i < N; i++) {\n    vec4 a = A(vec2(i,0)+.5);\n    vec4 at= A(vec2(i,1)+.5);\n    vec2 aw = size(i)/2.;\n    float d = map(p,a,at,aw);\n    if (abs(d)<2.) Q = vec4(0);\n    else if (dot(p-a.xy,vec2(0,1)*ei(at.x))>0.&&\n        d<0.);\n    else if (d<0.) Q = vec4(1,.2,.5,0);\n    else {\n        m += mag(p,a,at);\n    }\n}\nQ *= 1.-.8*(Q.y)*length(m)*(.5+.5*sin(atan(m.x,m.y)+vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I; vec4 M;\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) {R=iResolution.xy;T=iTime;I=iFrame;M=iMouse;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define N min(5.+float(I/10),100.)\n\n\nvec2 size (float i) {\n    vec2 s = vec2(1,2.+3.5*i/100.)*.012*R.x;\n    return s;\n}\nvec2 mag (vec2 p, vec4 a, vec4 t) {\n    //https://en.wikipedia.org/wiki/Magnetic_moment#Magnetism\n    vec2 r = (p.xy-a.xy)*ei(-t.x);\n    vec2 m = vec2(0,1);\n    float l = length(r);\n    if (l >0.) return 1e3*(3.*r/l*dot(r/l,m)-m)/(l*l*l);\n    else return vec2(0);\n}\n#define dt .3\nvec2 vel (vec2 p, vec4 a, vec4 t) {\n    vec2 w = p.xy-a.xy;\n    if (length(w)>0.) w = vec2(-w.y,w.x);\n    return a.zw + w*t.y;\n}\nvec2 MF (vec2 p, vec4 a, vec4 t, vec4 b, vec4 bt) {\n    vec2 r = p.xy-a.xy;\n    vec2 m1 = vec2(0,300./sqrt(1.+N))*ei(t.x);\n    vec2 m2 = vec2(0,300./sqrt(1.+N))*ei(bt.x);\n    float l = length(r);\n    if (l>0.) {\n          vec2 rh = r/l;\n          return (m2*dot(m1,rh)+m1*dot(m2,rh)+rh*dot(m1,m2)-5.*rh*dot(m1,rh)*dot(m2,rh)) / ( l*l*l*l );\n    } else return vec2(0);\n}\nfloat map ( vec2 p, vec4 a, vec4 t, vec2 b )\n{ //iquilezles.org/articles/distfunctionsl\n  p = (p-a.xy)*ei(-t.x);\n  vec2 q = (abs(p) - b);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 norm (vec2 p, vec4 a, vec4 t, vec2 b)\n{   \n    vec2 e = vec2(1,0);\n    return 1./dt*normalize(vec2(\n        map(p+e.xy,a,t,b)-map(p-e.xy,a,t,b),\n        map(p+e.yx,a,t,b)-map(p-e.yx,a,t,b)\n    ));\n}", "buffer_a_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // magnetic force\n                    {\n                        vec2 r = q-b.xy;\n                        vec2 im = MF(q,Q,t,b,bt);\n                        if (length(r)>0.) {\n                            tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                            f += im*abs(dot(normalize(r),normalize(im)));\n                        }\n                    }\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw += 1e-3*(Q.xy-M.xy)*exp(-.001*length(Q.xy-M.xy));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(.5*R+.1*R.y*(1.+6.*U.x/N)*vec2(cos(36.*U.x/N),sin(36.*U.x/N)),0,0);\n        t = vec4(10.*U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // magnetic force\n                    {\n                        vec2 r = q-b.xy;\n                        vec2 im = MF(q,Q,t,b,bt);\n                        if (length(r)>0.) {\n                            tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                            f += im*abs(dot(normalize(r),normalize(im)));\n                        }\n                    }\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw += 1e-3*(Q.xy-M.xy)*exp(-.001*length(Q.xy-M.xy));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(.5*R+.1*R.y*(1.+6.*U.x/N)*vec2(cos(36.*U.x/N),sin(36.*U.x/N)),0,0);\n        t = vec4(10.*U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // magnetic force\n                    {\n                        vec2 r = q-b.xy;\n                        vec2 im = MF(q,Q,t,b,bt);\n                        if (length(r)>0.) {\n                            tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                            f += im*abs(dot(normalize(r),normalize(im)));\n                        }\n                    }\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw += 1e-3*(Q.xy-M.xy)*exp(-.001*length(Q.xy-M.xy));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(.5*R+.1*R.y*(1.+6.*U.x/N)*vec2(cos(36.*U.x/N),sin(36.*U.x/N)),0,0);\n        t = vec4(10.*U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // magnetic force\n                    {\n                        vec2 r = q-b.xy;\n                        vec2 im = MF(q,Q,t,b,bt);\n                        if (length(r)>0.) {\n                            tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                            f += im*abs(dot(normalize(r),normalize(im)));\n                        }\n                    }\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw += 1e-3*(Q.xy-M.xy)*exp(-.001*length(Q.xy-M.xy));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(.5*R+.1*R.y*(1.+6.*U.x/N)*vec2(cos(36.*U.x/N),sin(36.*U.x/N)),0,0);\n        t = vec4(10.*U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdfczN", "name": "sin * cos & sin + cos", "author": "samuelotherion", "description": "some shift set interferences", "tags": ["interference"], "likes": 5, "viewed": 292, "published": 3, "date": "1641767804", "time_retrieved": "2024-07-30T17:10:58.192597", "image_code": "#define V1 float\n#define V2 vec2\n#define V3 vec3\n#define V4 vec4\n\n#define T iTime\n#define R iResolution.xy\n#define D ( 1. / R )\n\nV1\n  amp   = .4,\n  count = 4.,\n  A     = 40.,\n  S     = .010,\n  C     = .011;\nV4 rct = V4( -6.28, -3., 2. * 6.28, 5. );\n\nV2 cvt( V2 p ) { return rct.xy + ( p * D ) * rct.zw; }\n\n\nV1 fct( V1 x, int id, float count ) {\n    \n    V1\n    s1 = sin(S * T),\n    c1 = cos(C * T),\n    s2 = sin(A * x * s1),\n    c2 = cos(A * x * c1);\n    \n    return\n        id < 2\n        \t? id < 1\n        \t\t? +0.5 + amp * c2\n        \t\t: -0.5 + amp * s2\n        \t: id < 3\n        \t\t? -2.0 + amp * (c2 + s2)\n                : +1.5 + amp * c2 * s2;\n}\n\nV4 plt( V2 p, int id, float count ) {\n    \n    V1 f0 = fct( p.x ,id, count );\n    \n    V2 df = V2( D.x, .125 * ( fct( p.x + 4. * D.x, id, count ) - fct( p.x - 4. * D.x, id, count ) ) ),\n       dy = V2( 0, p.y - f0 ),\n       p1 = p - V2( p.x, f0 ) - df * dot( df, dy ) / dot( df, df );\n    \n    V1 l = length( p1 );\n    \n    return smoothstep( 1., 0., l * .1 * R.y ) * (\n        id < 2\n        \t? id < 1\n        \t\t? V4( 1., 0.0, 0.0,  1. )\n        \t\t: V4( 0.0, 1., 0.0,  1. )\n        \t: id < 3\n        \t\t? V4( 1., .75, .0,  1. )\n        \t\t: V4( 0.1, 0.3, 1.,  1. )\n    \t);\n}\n\n\nvoid mainImage( out V4 o, V2 i ) {\n    \n    i = cvt( i );\n    \n    o = plt( i, 0, count );\n        \n    for( int j = 1; j < int( count ); ++ j ) {\n        \n        o += plt( i, j, count );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 266, 266, 304], [307, 307, 344, 344, 650], [652, 652, 689, 689, 1225], [1228, 1228, 1262, 1262, 1424]], "test": "untested"}
{"id": "NdXcR4", "name": "UV Texture Map Debugger", "author": "Yusef28", "description": "A quick uv map [Limit is 9]", "tags": ["texture", "uv", "map", "util"], "likes": 9, "viewed": 308, "published": 3, "date": "1641764857", "time_retrieved": "2024-07-30T17:10:58.955558", "image_code": "\n#define LETTER_SIZE 1./16.\n#define STEP_SIZE 1./2.\n#define FIRST_LETTER 64.\n#define FIRST_NUMBER 48.\n\nvec2 numToCoord(float a){\n    return vec2( mod(a,16.), 15.-floor(a/16.) );\n}\n\nvec3 C(vec2 uv, vec2 start, inout float moveX,float num){\n    moveX += STEP_SIZE/2.3;\n    if(uv.x < start.x           || \n       uv.x > start.x+STEP_SIZE || \n       uv.y < start.y           || \n       uv.y > start.y+STEP_SIZE){\n       return vec3(0.);\n    }\n    \n    uv -= start; uv /= STEP_SIZE; uv *= LETTER_SIZE;\n    uv += vec2(LETTER_SIZE*numToCoord(num));\n    return textureGrad(iChannel0,uv,dFdx(uv),dFdy(uv)).rrr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);// texture(iChannel0,uv).rgb;\n    \n    \n    float NUM = 8.;\n    vec2 st = fract(uv*NUM );\n    vec2 id = floor(uv*NUM );\n    float moveX = STEP_SIZE/4.;\n    float colNum = mod(id.x+(NUM-id.y)-1.,8.);\n    \n    col = 0.4+0.4*cos(vec3(0.,3.,4.)/3. + colNum);\n    col = mix(col,vec3(0.9),smoothstep(0.485,0.5,abs(st.x-0.5)));\n    col = mix(col,vec3(0.9),smoothstep(0.485,0.5,abs(st.y-0.5)));\n    col = mix(col,vec3(0.9),0.2*smoothstep(0.45,0.5,abs(fract(st.x*8.)-0.5)));\n    col = mix(col,vec3(0.9),0.2*smoothstep(0.45,0.5,abs(fract(st.y*8.)-0.5)));\n   \n    col = mix(col,vec3(1.),C(st,vec2(moveX,STEP_SIZE/2.),moveX,FIRST_LETTER+id.x+1.));\n    col = mix(col,vec3(1.),C(st,vec2(moveX,STEP_SIZE/2.),moveX,FIRST_NUMBER+NUM-id.y));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 128, 128, 179], [181, 181, 238, 238, 603], [605, 605, 662, 712, 1600]], "test": "untested"}
{"id": "fdXcR4", "name": "Spline Idea e 2", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 7, "viewed": 342, "published": 3, "date": "1641763743", "time_retrieved": "2024-07-30T17:10:59.733477", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    x = 4. * x * (1.-x);\n    x = x * x;\n    vec3 e = vec3(1.);\n    vec3 col2 = 2. * x * pal(mix(0.3, 0.35, 0.5 + 0.5 * thc(2., iTime)), e, e, e, vec3(0., 0.33, 0.66));\n    fragColor = vec4(0.06 + col2, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 P(float time) {\n    \n    // Offset y values from x values (so it doesnt just move diagonally)\n    float o = 0.01;\n    // Scale point locations to fit to screen\n    float sc = 0.8;\n    \n    // Next 4 points in sequence\n    // (bad approach - has a bottom-left bias) (does it tho?)\n    vec2 p0 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time))),      h21(vec2(o + floor(time))) );\n    vec2 p1 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 1.))), h21(vec2(o + floor(time + 1.))) );\n    vec2 p2 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 2.))), h21(vec2(o + floor(time + 2.))) );\n    vec2 p3 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 3.))), h21(vec2(o + floor(time + 3.))) );\n\n    float f = fract(time);\n\n    float t = 0.8;\n    mat4 M = mat4(   0,  1,     0,        0,\n                    -t,  0,     t,        0,\n                  2.*t,  t-3.,  3.-2.*t,  -t,\n                    -t,  2.-t,  t-2.,     t);\n    vec4 U = vec4(1., f, f*f, f*f*f);\n    vec4 Px = vec4(p0.x, p1.x, p2.x, p3.x);\n    vec4 Py = vec4(p0.y, p1.y, p2.y, p3.y);\n    return vec2(dot(Px, M * U), dot(Py, M * U));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;    \n    \n    vec2 uv2 = uv;\n   float time = 0.005 * h21(uv) + 1.8 * cos(3.5 * length(uv) + 0.5 * iTime) + 0.25 * iTime;\n    vec2 p = P(time);\n   // vec2 p2 = P(time - 0.5 * 0.1);\n    uv2 += p;\n    \n\n   // float th = pi/4. + atan(p.y - p2.y, p.x - p2.x);\n    float th = 1. * iTime;\n    mat2 R = mat2(cos(th), sin(th), -sin(th), cos(th));\n    uv2 *= R;\n    uv2 = abs(uv2);\n\n    vec2 pt = 0.15 * (0.5 + 0.5 * ths(2., iTime)) / sqrt(2.) * vec2(1);\n    //pt += 0.05 * vec2(cos(24. * uv.x + 4. * iTime), sin(24. * uv.y + 4. * iTime));\n    float d = length(uv2 - pt);\n    \n    float k = 2. / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.025);\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    x = 0.985 * clamp(x, 0., 1.);\n    s = max(x, s);\n    /*\n    float d = length(uv - p);\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.025);\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    x = 0.98 * clamp(x, 0., 1.);\n    s = max(x, s);\n    */\n    \n    //s = max(s, f * smoothstep(-k, k, -length(uv - p2) + 0.025));\n\n    fragColor = vec4(s);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Collection of functions I use a lot:\n\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 395]], "test": "untested"}
{"id": "fsXcRN", "name": "MinimalAtmosphere_GLSL", "author": "ForestCSharp", "description": "See https://github.com/Fewes/MinimalAtmosphere for original HLSL source", "tags": ["sky"], "likes": 8, "viewed": 437, "published": 3, "date": "1641763220", "time_retrieved": "2024-07-30T17:11:00.511398", "image_code": "// Copyright (c) 2021 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// -------------------------------------\n// Defines\n#define EPS                 1e-6\n#define PI                  3.14159265359\n#define INFINITY            1.0 / 0.0\n#define PLANET_RADIUS       6371000.0\n#define PLANET_CENTER       vec3(0, -PLANET_RADIUS, 0)\n#define ATMOSPHERE_HEIGHT   100000.0\n#define RAYLEIGH_HEIGHT     (ATMOSPHERE_HEIGHT * 0.08)\n#define MIE_HEIGHT          (ATMOSPHERE_HEIGHT * 0.012)\n\n// -------------------------------------\n// Coefficients\n#define C_RAYLEIGH          (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE               (vec3(3.996,  3.996,  3.996) * 1e-6)\n#define C_OZONE             (vec3(0.650,  1.881,  0.085) * 1e-6)\n\n#define ATMOSPHERE_DENSITY  1.0\n#define EXPOSURE            20.0\n\n// -------------------------------------\n// Math\nvec2 SphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\trayStart -= sphereCenter;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = 2.0 * dot(rayStart, rayDir);\n\tfloat c = dot(rayStart, rayStart) - (sphereRadius * sphereRadius);\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0)\n\t{\n\t\treturn vec2(-1);\n\t}\n\telse\n\t{\n\t\td = sqrt(d);\n\t\treturn vec2(-b - d, -b + d) / (2.0 * a);\n\t}\n}\nvec2 PlanetIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\nvec2 AtmosphereIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\n// -------------------------------------\n// Phase functions\nfloat PhaseRayleigh(float costh)\n{\n\treturn 3.0 * (1.0 + costh*costh) / (16.0 * PI);\n}\n\nfloat PhaseMie(float costh, float g)\n{\n\tg = min(g, 0.9381);\n\tfloat k = 1.55*g - 0.55*g*g*g;\n\tfloat kcosth = k*costh;\n\treturn (1.0 - k*k) / ((4.0 * PI) * (1.0-kcosth) * (1.0-kcosth));\n}\n\n// -------------------------------------\n// Atmosphere\nfloat AtmosphereHeight(vec3 positionWS)\n{\n\treturn distance(positionWS, PLANET_CENTER) - PLANET_RADIUS;\n}\nfloat DensityRayleigh(float h)\n{\n\treturn exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\nfloat DensityMie(float h)\n{\n\treturn exp(-max(0.0, h / MIE_HEIGHT));\n}\nfloat DensityOzone(float h)\n{\n\t// The ozone layer is represented as a tent function with a width of 30km, centered around an altitude of 25km.\n\treturn max(0.0, 1.0 - abs(h - 25000.0) / 15000.0);\n}\nvec3 AtmosphereDensity(float h)\n{\n\treturn vec3(DensityRayleigh(h), DensityMie(h), DensityOzone(h));\n}\n\n// Optical depth is a unitless measurement of the amount of absorption of a participating medium (such as the atmosphere).\n// This function calculates just that for our three atmospheric elements:\n// R: Rayleigh\n// G: Mie\n// B: Ozone\n// If you find the term \"optical depth\" confusing, you can think of it as \"how much density was found along the ray in total\".\nvec3 IntegrateOpticalDepth(vec3 rayStart, vec3 rayDir)\n{\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\tfloat  rayLength    = intersection.y;\n\n\tint    sampleCount  = 8;\n\tfloat  stepSize     = rayLength / float(sampleCount);\n\t\n\tvec3 opticalDepth = vec3(0);\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tvec3 localPosition = rayStart + rayDir * (float(i) + 0.5) * stepSize;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\t}\n\n\treturn opticalDepth;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{\n\t// Note that Mie results in slightly more light absorption than scattering, about 10%\n\treturn exp(-(opticalDepth.x * C_RAYLEIGH + opticalDepth.y * C_MIE * 1.1 + opticalDepth.z * C_OZONE) * ATMOSPHERE_DENSITY);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n\t// We can reduce the number of atmospheric samples required to converge by spacing them exponentially closer to the camera.\n\t// This breaks space view however, so let's compensate for that with an exponent that \"fades\" to 1 as we leave the atmosphere.\n\tfloat  rayHeight = AtmosphereHeight(rayStart);\n\tfloat  sampleDistributionExponent = 1.0 + clamp(1.0 - rayHeight / ATMOSPHERE_HEIGHT, 0.0, 1.0) * 8.0; // Slightly arbitrary max exponent of 9\n\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\trayLength = min(rayLength, intersection.y);\n\tif (intersection.x > 0.0)\n\t{\n\t\t// Advance ray to the atmosphere entry point\n\t\trayStart += rayDir * intersection.x;\n\t\trayLength -= intersection.x;\n\t}\n\n\tfloat  costh    = dot(rayDir, lightDir);\n\tfloat  phaseR   = PhaseRayleigh(costh);\n\tfloat  phaseM   = PhaseMie(costh, 0.85 /* Default */);\n\n\tint    sampleCount  = 64;\n\n\tvec3 opticalDepth = vec3(0);\n\tvec3 rayleigh     = vec3(0);\n\tvec3 mie          = vec3(0);\n\n\tfloat  prevRayTime  = 0.0;\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tfloat  rayTime = pow(float(i) / float(sampleCount), sampleDistributionExponent) * rayLength;\n\t\t// Because we are distributing the samples exponentially, we have to calculate the step size per sample.\n\t\tfloat  stepSize = (rayTime - prevRayTime);\n\n\t\tvec3 localPosition = rayStart + rayDir * rayTime;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\n\t\t// The atmospheric transmittance from rayStart to localPosition\n\t\tvec3 viewTransmittance = Absorb(opticalDepth);\n\n\t\tvec3 opticalDepthlight  = IntegrateOpticalDepth(localPosition, lightDir);\n\t\t// The atmospheric transmittance of light reaching localPosition\n\t\tvec3 lightTransmittance = Absorb(opticalDepthlight);\n\n\t\trayleigh += viewTransmittance * lightTransmittance * phaseR * localDensity.x * stepSize;\n\t\tmie      += viewTransmittance * lightTransmittance * phaseM * localDensity.y * stepSize;\n\n\t\tprevRayTime = rayTime;\n\t}\n\n\ttransmittance = Absorb(opticalDepth);\n\n\treturn (rayleigh * C_RAYLEIGH + mie * C_MIE) * lightColor * EXPOSURE;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //camera position\n    vec3 ray_start = vec3(0,0,0);\n    \n    vec2 mouse_vec = iMouse.xy/iResolution.xy;\n    \n    vec3 cam_dir = normalize(vec3(mouse_vec, 1.0));\n    vec3 u = normalize(cross(cam_dir, vec3(0., 1., 0.)));\n    vec3 v = cross(u, cam_dir);\n    float fdist = 0.3;\n    vec3 ray_dir = normalize(cam_dir*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n    \n    const float ray_length = 1000000000.0f;\n    vec3 light_dir = vec3(0.25,1,0);\n    vec3 light_color = vec3(1,1,1);\n    vec3 transmittance;\n    vec3 sky_color = IntegrateScattering(ray_start, ray_dir, ray_length, light_dir, light_color, transmittance);\n    \n    fragColor = vec4(sky_color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcRN.jpg", "access": "api", "license": "mit", "functions": [[1840, 1889, 1981, 1981, 2291], [2292, 2292, 2345, 2345, 2423], [2424, 2424, 2481, 2481, 2579], [2581, 2641, 2675, 2675, 2726], [2728, 2728, 2766, 2766, 2912], [2914, 2969, 3010, 3010, 3073], [3074, 3074, 3106, 3106, 3153], [3154, 3154, 3181, 3181, 3223], [3224, 3224, 3253, 3366, 3420], [3421, 3421, 3454, 3454, 3522], [4459, 4524, 4556, 4643, 4769], [4771, 4951, 5078, 5331, 7210], [7213, 7213, 7270, 7296, 7980]], "test": "untested"}
{"id": "fsXcz4", "name": "Tonemapping experiment", "author": "bjornornorn", "description": "Experiment with hue preserving tonemapping/output transforms. \n\nScaling chroma based on the derivative of the tone curve. This behave similarly to per channel tone mapping for low saturation colors, but preserves hue for saturated colors.", "tags": ["tonemapping", "tonemap", "oklab"], "likes": 25, "viewed": 2144, "published": 3, "date": "1641757410", "time_retrieved": "2024-07-30T17:11:01.363120", "image_code": "// Copyright(c) 2022 Bjrn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst float softness_scale = 0.2; // controls softness of RGB clipping\nconst float offset = 0.75; // controls how colors desaturate as they brighten. 0 results in that colors never fluoresce, 1 in very saturated colors \nconst float chroma_scale = 1.2; // overall scale of chroma\n\nconst mat3 rec2020toSrgb = mat3(\n    1.6603034854, -0.5875701425, -0.0728900602,\n    -0.1243755953,  1.1328344814, -0.0083597372,\n    -0.0181122800, -0.1005836085,  1.1187703262);\n\nconst mat3 displayP3toSrgb = mat3(\n    1.2248021163, -0.2249112615, -0.0000475721,\n    -0.0419281049,  1.0420298967, -0.0000026429,\n    -0.0196088092, -0.0786321233,  1.0983153702);\n\nconst mat3 SrgbToSrgb = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    \nconst mat3 sourceColorSpaceToSrgb = SrgbToSrgb; // change for different input color space\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = max(x, 0.0);\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    \n    x = max(x, 0.0);\n    vec3 r = (x*(c*x + d) + e);\n    return (a*x*(d*x + 2.0*e) + b*(e - c*x*x))/(r*r);\n}\n\nvec3 tonemap_per_channel(vec3 c)\n{\n    return s_curve(c);\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c_smooth,x-c_smooth)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n\n    return sqrt(a*a + b*b);\n}\n\nvec2 calculateMC(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float M = findCenterAndPurity(lms).x; \n    \n    return vec2(M, calculateC(lms));\n}\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec2 MC = calculateMC(rgb);\n    vec2 STnew = vec2((MC.x)/MC.y, (1.0-MC.x)/MC.y);\n    STnew = (STnew + 3.0*STnew*STnew*MC.y);\n    \n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec2 MC = calculateMC(rgb);\n    float Cnew = (1.0/((ST.x/(MC.x)) + (ST.y/(1.0-MC.x))));\n\n    return max(MC.y/Cnew, scale);\n}\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\nvec3 tonemap_hue_preserving(vec3 c)\n{\n    mat3 toLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n        \n    mat3 fromLms = mat3(\n        +4.0767416621f , -3.3077115913, +0.2309699292,\n        -1.2684380046f , +2.6097574011, -0.3413193965,\n        -0.0041960863f , -0.7034186147, +1.7076147010);\n        \n    vec3 lms_ = c*toLms;\n    vec3 lms = sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n    \n    vec2 MP = findCenterAndPurity(lms);\n    \n    // apply tone curve\n    \n    // Approach 1: scale chroma based on derivative of chrome curve\n    if (true)\n    { \n        float I = (MP.x+(1.0-offset)*MP.y);\n        // Remove comment to see what the results are with Oklab L\n        //I = dot(lms, vec3(0.2104542553f, 0.7936177850f, - 0.0040720468f));\n        \n        lms = lms*I*I;\n        I = I*I*I;\n        vec3 dLms = lms - I;\n\n        float Icurve = s_curve(vec3(I)).x;\n        lms = 1.0f + chroma_scale*dLms*d_s_curve(vec3(I))/Icurve;     \n        I = pow(Icurve, 1.0/3.0);\n\n        lms = lms*I;\n    }\n    \n    // Approach 2: Separate color into a whiteness/blackness part, apply scale to them independendtly\n    if (false)\n    {\n        lms = chroma_scale*(lms - MP.x) + MP.x;\n    \n        float invBlackness = (MP.x+MP.y);\n        float whiteness = (MP.x-MP.y);\n        \n        float invBlacknessC = pow(s_curve(vec3(invBlackness*invBlackness*invBlackness)).x, 1.0/3.0);\n        float whitenessC = pow(s_curve(vec3(whiteness*whiteness*whiteness)).x, 1.0/3.0);\n        \n        lms = (invBlacknessC+whitenessC)/2.0 + (lms-(invBlackness+whiteness)/2.0)*(invBlacknessC-whitenessC)/(invBlackness-whiteness);\n    }\n    \n    \n    // compress to a smooth approximation of the target gamut\n    { \n        float M = findCenterAndPurity(lms).x;\n        vec2 ST = approximateShape(); // this can be precomputed, only depends on RGB gamut\n        float C_smooth_gamut = (1.0)/((ST.x/(M)) + (ST.y/(1.0-M)));\n        float C = calculateC(lms);\n\n        lms = (lms-M)/sqrt(C*C/C_smooth_gamut/C_smooth_gamut+1.0) + M;\n    }\n    \n    vec3 rgb = lms*lms*lms*fromLms;\n\n    return rgb;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    // not quite sure this mapping is easy to invert, but should be possible to construct similar ones that do\n    \n    float grey = 0.2;\n        \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n    \n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color;\n    \n    const int N = 8;\n    \n    float time = 0.125*iTime;\n    \n    for (int i = 0; i <= N; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            float fi = float(i)/float(N);\n            float fj = float(j)/float(N);\n        \n            float x = 1.5*(fi-0.5*fj-0.5);\n            float y = 1.5*sqrt(3.0)/2.0*(fj-0.5);            \n            vec2 xyd = vec2(x,y)-uv;\n            \n            float d = min(0.0006/dot(xyd,xyd),1.0);\n            \n            vec3 c = vec3(fi-fj, fj, 1.0-fi);\n                   \n            c = c*sourceColorSpaceToSrgb;\n\n            color += pow(2.0,-3.0*cos(2.0*3.14159*time))*d*c;\n        }\n    }\n    \n    color = tonemap_hue_preserving(color);\n    color = softClipColor(color);\n    \n    //color = tonemap_per_channel(color);\n  \n    \n    // highlight colors that clip if any\n    float diff = length(color - clamp(color, 0., 1.));\n    if(diff != 0.)\n        color = vec3(0.5,0.5,0.5);    \n    \n    \n    // Output to screen\n    fragColor = vec4(pow(color,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcz4.jpg", "access": "api", "license": "mit", "functions": [[1927, 2105, 2127, 2127, 2308], [2310, 2335, 2359, 2359, 2578], [2580, 2580, 2614, 2614, 2639], [2641, 2641, 2675, 2816, 3409], [3411, 3411, 3431, 3431, 3692], [3694, 3694, 3722, 3864, 4483], [4485, 4485, 4511, 4511, 4628], [4630, 4630, 4667, 4667, 4860], [4862, 4862, 4913, 4913, 5042], [5044, 5044, 5069, 5069, 5909], [5911, 5911, 5948, 5948, 8095], [8097, 8097, 8132, 8132, 8310], [8312, 8312, 8344, 8578, 9137], [9139, 9139, 9196, 9196, 10327]], "test": "untested"}
{"id": "7slyR8", "name": "Genuary 2022 - Day8", "author": "z0rg", "description": "My participation to genuary 2022", "tags": ["generative", "genuary", "2022", "singlecurve"], "likes": 8, "viewed": 281, "published": 3, "date": "1641727659", "time_retrieved": "2024-07-30T17:11:02.129072", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\nfloat time;\n\n// Thanks IQ\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i < 16; ++i)\n    {\n\n        float f = (float(i)/16.-.5)*2.*.5;//+iTime*.5+float(i+1)*iTime*.1;\n        vec2 a = vec2(f-.5, sin(f+time)*.1);\n        vec2 b = vec2(f+.5,  sin(f*3.+time+1.)*.2);\n        float shape = sdSegment(uv, a,b)-.001;\n        col = mix(col, vec3(1.), 1.-sat(shape*iResolution.x*.5));\n    \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime*2.;\n    float off = .05;//sin(iTime)*.1;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = vec3(0.);\n    col.x = rdr(uv).x;\n    time = time+off;\n    col.y = rdr(uv).y;\n    time = time+off*2.;\n    col.z = rdr(uv).z;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slyR8.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[441, 454, 506, 506, 625], [1033, 1033, 1090, 1090, 1386]], "test": "untested"}
{"id": "fssyzH", "name": "Genuary 2022 - Day7", "author": "z0rg", "description": "My participation to genuary 2022\nCode is messy I know :p", "tags": ["generative", "sollewitt", "genuary", "2022"], "likes": 11, "viewed": 267, "published": 3, "date": "1641725993", "time_retrieved": "2024-07-30T17:11:02.905995", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .5\n#define GLOW_OPACITY .76\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\n// Thanks IQ\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// Thanks IQ\nfloat _rsqr(vec2 uv, vec2 s, float r)\n{\n    vec2 l = abs(uv)-s;\n    return min(length(max(l, 0.)+min(max(l.x, l.y), 0.))-r, max(l.x, l.y));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}", "buffer_a_code": "\n#define GROUND_MAT 0.\n#define WALL_MAT 1.\n#define CEILING_MAT 2.\n#define WALL2_MAT 3.\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x,max(l.y, l.z));\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n\n    vec2 acc = vec2(10000., -1.);\n    acc = _min(acc, vec2(-p.y, GROUND_MAT));\n    \n    acc = _min(acc, vec2(-(abs(p.x)-2.), WALL_MAT));\n    \n    acc = _min(acc, vec2(p.y+3., CEILING_MAT));\n    \n    acc = _min(acc, vec2(-p.z, WALL2_MAT));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 2.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\nreturn normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps, float maxDist)\n{\n    accLight = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        /*if (res.y == FLAME_MAT)\n        accLight += vec3(0.941,0.376,0.000)*(1.-sat(res.x/.05))*.05;*/\n        p+= rd*res.x;//*.0125;\n    }\n    return vec3(-1.);\n}\n\nfloat getShadow(vec3 ro, vec3 lpos, int steps)\n{\n    float maxDist = distance(ro, lpos);\n    vec3 rd = -normalize(lpos-ro);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < maxDist;++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return 0.;\n        p+= rd*res.x*.125;\n    }\n    return float(distance(p, ro) > maxDist);\n}\nvec3 getEnv(vec3 rd)\n{\n    return texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz*.5*vec3(0.941,1.000,1.000);//*.25;\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float stars = pow(texture(iChannel0, uv*5.*vec2(2.,1.)).x, 10.)*sat(-rd.y);\n    vec3 back = mix(vec3(0.910,0.671,0.588), vec3(0.176,0.180,0.345)*.75, pow(sat(-rd.y*2.+.2), .3)); \n    back += vec3(0.455,0.871,0.925)*pow(sat(-(rd.x-2.1)*.4+rd.y*2.),1.2)*.5;\n    back += vec3(0.733,0.416,0.208)*pow(sat(-(rd.x-1.9)*.4+rd.y*2.),3.);\n    back *= 1.-sat(length((uv-vec2(.75,0.1))*.5*vec2(2.,2.)));\n    return back+ vec3(1.)*stars+vec3(.2,.4,.7)*stars*1.;\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    vec3 lpos = vec3(0.,15.,-15.)+1.*(vec3(rand(), rand(), rand())-.5);\n    vec3 ldir= p-lpos;\n    vec3 lcol = vec3(1.000,0.796,0.659);\n    vec3 h = normalize(rd+ldir);\n    vec3 ambient = vec3(0.);\n    float ndotl = sat(dot(n, normalize(ldir)));\n    vec3 albedo = vec3(.1,.1,.1);\n    vec3 spec = vec3(1.,0.,0.);\n    float gloss = 1.;\n    if (res.z == GROUND_MAT)\n    {\n        albedo = mix(vec3(.5), vec3(0.000,0.616,0.875), .125)*.5;\n        ambient = vec3(.5);\n        ambient = 1.5*texture(iChannel3, p.xz*r2d(PI*.5)*vec2(.5,1.)).x*vec3(0.604,0.478,0.376);\n        //ambient = mix(ambient, vec3(1.000,0.298,0.220), sat((sin(length(p.xz)*20.)-.95)*400.));\n    }\n    if(res.z == CEILING_MAT)\n    {\n        vec3 lightCeil = mix(vec3(.5), 1.1*vec3(0.957,1.000,0.941), sat((sin(p.x*20.)+1.01)*10.)*sat((sin(p.z*10.)+1.01)*10.));\n        ambient = mix(lightCeil, vec3(.8), sat(_sqr(p.xz-vec2(0.,-5.), vec2(1.5,3.))*400.));\n    }\n    if (res.z == WALL2_MAT)\n    {\n        ambient = vec3(.45);\n    }\n    if (res.z == WALL_MAT)\n    {\n        ambient = vec3(.6);\n        if (p.x < 0.)\n            p.z = -p.z-9.5;\n        ambient = mix(ambient, vec3(0.), 1.-sat(_sqr(p.zy-vec2(-6.6,-1.5), vec2(1.3))*400.));\n        ambient = mix(ambient, vec3(0.), 1.-sat((length(p.zy-vec2(-3.,-1.5))-1.3)*400.));\n    }\n    if (res.z == WALL2_MAT)\n    {\n        ambient = vec3(0.090,0.263,0.447);\n        float cir = length(p.xy-vec2(0.,-1.5))-1.;\n        ambient = mix(ambient, vec3(0.820,0.102,0.129), 1.-sat((cir)*400.));\n        ambient = mix(ambient, vec3(0.953,0.667,0.031), 1.-sat((abs(cir)-.1)*400.));\n    }\n\n    \n    col = ambient;\n    if (getShadow(p+n*0.01,  lpos, 256) > 0.5)\n        col += albedo*pow(ndotl,1.)*2.*lcol;\n/*    if (res.z == FLAME_MAT)\n    {\n        col = 2.*mix(vec3(1.000,0.749,0.322), vec3(1.,1.,1.), sat(-dot(rd, n)));\n    }*/\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv.x *= -1.;\n    vec3 col = vec3(0.);\n    float xpos = sin(iTime*0.+.5)*2.2;\n    float offy = -.85;\n    float zoff = 5.9;\n    //uv *= r2d(.25);\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.008;\n    vec3 ro = vec3(0.,-1.25,-10.)+dof;\n    vec3 ta = vec3(0.,-1.25,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof*0.0025;\n    vec3 res = trace(ro, rd, 4096*4, 30.);\n    float maxdist = 20.;\n    float dist = maxdist;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getMat(res, rd, p, n);\n        col += accLight;\n        if (true)\n        {\n            vec3 lastCol = col;\n            for (int i = 0; i < 2; ++i)\n            {\n                vec3 refl = normalize(reflect(rd, n));\n                float spec = 1.;\n                if (res.z == GROUND_MAT)\n                    spec = .2;\n                refl = mix(refl, normalize(vec3(rand(), rand(), rand())-.5), spec);\n            \n                if (dot(refl, n) < 0.01)\n                    refl = -refl;\n                vec3 resrefl = trace(p+n*0.01, refl, 4096, 15.);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    float mult = 1.;\n                    if (res.z == CEILING_MAT)\n                        mult = 0.1;\n                    vec3 retCol = getMat(resrefl, refl, prefl, nrefl)*mult*lastCol*(1.-sat(resrefl.y/10.));\n                    col += retCol;\n                    lastCol = retCol;\n                    n = nrefl;\n                    p = prefl;\n                }\n                else\n                {\n                    //col += getEnv(refl);\n                    break;\n                }\n                \n                col += accLight;\n                rd = refl;\n            }\n\n\n        }\n    col = mix(col, vec3(0.), sat(exp(-dist*.05-.1)));\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float scaleF = 1.;\n    uv *= scaleF;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec2 off = (vec2(rand(), rand())-.5)*3.*vec2(1., -1.)/(iResolution.x*1.75/scaleF);\n    vec3 col = rdr(uv+off);\n\n    col = sat(col);\n    col = pow(col, vec3(.9));\n    \n    if (iFrame > 1)\n        col = mix(texture(iChannel1, fragCoord/iResolution.xy).xyz, col,  1.0 / float(iFrame + 1));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssyzH.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1179]], "test": "untested"}
{"id": "fsscRH", "name": "pixels factory", "author": "drschizzo", "description": "inspired by https://twitter.com/TatsuyaBot/status/1477856713332359171\n\n\n", "tags": ["raymarching"], "likes": 17, "viewed": 356, "published": 3, "date": "1641721890", "time_retrieved": "2024-07-30T17:11:03.679926", "image_code": "#define SIMPLE_BLUR_ \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    #ifndef SIMPLE_BLUR\n        vec3 col=vec3(0.);\n        float blur=(iResolution.x/300.)*pow(uv.y*1.3,2.);\n        float n=0.;\n        for(float i=-blur;i<=blur;i+=blur/2.)\n            for(float j=-blur;j<=blur;j+=blur/2.){\n                n++;\n                col+=texelFetch(iChannel0,ivec2(fragCoord+vec2(i,j)),0).rgb;\n            }\n\n        col/=n;\n    #else\n        vec3 col=textureLod(iChannel0,uv,pow(uv.y*1.3,2.)*3.).rgb;\n    #endif\n    \n    fragColor=pow(vec4(col,1.),vec4(0.45));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T iTime\n#define pi acos(-1.)\n\n\n \nfloat sdCylinder(vec3 p, float h,float r){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nstruct Hit{\n    float d;\n    float obj;\n    vec2 id;\n    float cy;\n};\n\nHit map(vec3 p){\n   \n    \n    p.xz*=mat2(cos(pi/2.),sin(pi/2.),-sin(pi/2.),cos(pi/2.));\n//     p.y-=(.5+.5*sin(p.z/5.)*3.);\n     \n\n    float d=p.y;\n    \n    d=max(d,-p.y-1.3);\n\n\n    float cy=1000.;\n    float c1=1000.;\n    \n    float obj=0.;\n    \n    float idz=p.z;\n    p.z=mod(p.z+2.,4.)-2.;\n    vec3 sp=p;\n    idz=idz-p.z;\n     \n    float t=iTime+100.+(pi*2.)*fract(sin(43.23*sin(idz+14.2)));\n    \n    float f=fract(t/2.);\n    float off=t*2.;\n    vec3 rp=p;\n    rp.x+=off;\n\n    rp.x=mod(rp.x+2.,4.)-2.;\n    float idx=floor(p.x-rp.x);\n    \n    float depth=.3;\n    float width=1.5;\n    \n    if(idx<0.){\n        if(idx<-6.){\n           // rp.z+=.1*sin(sp.x*.8+t*5.);\n            c1=min(c1,sdCylinder(rp,width,3.));\n        }\n        else{\n            float nb=5.;\n            for(float i=0.;i<nb;i++){\n                float s=idx>-4.1?smoothstep(i*(1./nb),(i+1.)*(1./nb),f):1.;\n                float de=depth*s;\n                float wi=width*s;\n                c1=min(c1,sdCylinder(rp-vec3(0,-i*depth,0),wi,de));\n                c1=min(c1,sdTorus(rp-vec3(0,-i*depth-.2,0),vec2(wi,.05)));\n                \n            }\n        }\n       d=opSmoothSubtraction(c1,d,.15);\n    }\n    \n    if(idx<-5.5){\n        \n\n\n        float y=idx>-7.?3.*pow(smoothstep(1.5,0.,f*1.5),2.):.32;\n        cy=sdCylinder(vec3(rp.x,p.y+y,rp.z),width,.5);\n        if(cy<d)\n            obj=1.;\n        d=min(d,cy);\n    \n    }\n    float c2=length(sp-vec3(0,1.5*pow(abs(sin((t-0.05)*pi/2.)),.5)+.5,0))-.8;\n    c2*=.8;\n    if(c2<d)\n        obj=2.;\n\n\n    \n    return Hit(opSmoothUnion(d,c2,.6),obj,vec2(p.x-rp.x+off+100.,idz+100.),min(cy,c2*.8));\n}\n\nvec3 normal(vec3 p){\n    vec2 e=vec2(0,.001);\n    float d=map(p).d;\n    return(normalize(d-vec3(map(p-e.yxx).d,\n                          map(p-e.xyx).d,\n                          map(p-e.xxy).d)));\n}\n\n\n\n\nmat3 cam(vec3 ro, vec3 lp) {\n\tvec3 cd = normalize(lp - ro); \n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); \n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 textNorm(vec2 p){\n    float a=texture(iChannel1,p).r;\n    float xL=texture(iChannel1,p+vec2(1.,0)).r;\n    float xR=texture(iChannel1,p+vec2(-1.,0)).r;\n    float yU=texture(iChannel1,p+vec2(0.,1.)).r;\n    float yD=texture(iChannel1,p+vec2(0.,-1.)).r;\n    \n    float xDelta = ((xL-xR)+1.)*0.5;\n     float         yDelta = ((yU-yD)+1.)*0.5;\n    \n    return normalize(vec3(xDelta,\n                          1.,\n                          yDelta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 prevcol=texture(iChannel2,fragCoord.xy/iResolution.xy);\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 ro=vec3(24.+iTime*2.,10.,8.);\n    vec3 fog=abs(sin(vec3(.8,.5,.3)+iTime/10.))*.6;//vec3(.6,.6,.8);\n    \n    vec3 rd=normalize(cam(ro,vec3(24.+iTime*2.+(sin(iTime/2.)),0.,-7.))*normalize(vec3(uv,-1.)));\n    float dt=0.;\n    float obj=0.;\n    vec2 ido=vec2(0.);\n    float cy=1000.;\n    for(float i=0.;i<100.;i++){\n        Hit h=map(ro+dt*rd);\n        obj=h.obj;\n        ido=h.id;\n        cy=h.cy;\n        float d=h.d;\n        dt+=d;\n        if(d<.001 || d > 100.)\n            break;\n    }\n            vec3 p=ro+dt*rd;\n\n    vec3 varcol=vec3(0.);\n    if(dt<250.){\n    \n        vec3 n=normal(p);\n        vec3 lpos=vec3(1.,3.5,6.);\n        float diff=clamp(dot(n,normalize(lpos)),0.1,1.);\n        \n        vec3 col=vec3(.3,.3,.3);\n        varcol=abs(sin(vec3(.8,.5,.3)+(ido.x+ido.y)));\n        if(obj==1.){\n            col=varcol;\n            diff=.8+.2*diff;\n            \n            }\n        else if(obj==2.){\n           col=varcol;\n            col+=texture(iChannel0,reflect(rd,n)).rgb*(1.-pow(max(0.,dot(-rd,n)),5.));\n        }\n        else{\n            vec3 ref=texture(iChannel0,reflect(-rd,n)).rgb*(1.-pow(max(0.,dot(-rd,n)),5.));\n\n\n            col=mix(ref+texture(iChannel1,vec2(p.x,p.z+iTime*2.)/10.).r*.3,varcol,pow(smoothstep(.6,0.,cy),2.));\n            \n        }\n        \n\n\n        \n        fragColor = vec4(col*vec3(clamp((diff),-1.,1.)),1.0);\n        \nfragColor=mix(fragColor,vec4(fog,1.),pow(clamp(-p.z/80.,0.,1.),.8));\n\n    }\n      else    \n          fragColor = vec4(vec3(0.),1.0);\n    \n    \n    \n    fragColor.a=cy;\n\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsscRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7lVXDc", "name": "RGB Gamut shape", "author": "bjornornorn", "description": "Plot alternating between:\n- sRGB gamut\n- a smoothed gamut, smaller than sRGB\n- sRGB gamut\n- sRGB gamut, stretched to have saddle points at the edges of the rgb cube", "tags": ["gamutshape"], "likes": 0, "viewed": 251, "published": 3, "date": "1641720909", "time_retrieved": "2024-07-30T17:11:04.447873", "image_code": "vec3 cbrt( vec3 x )\n{\n    return sign(x)*pow(abs(x), vec3(1.0/3.0));\n}\n\nfloat scurve(float x)\n{\n    return (3.0*x - x*x*x)/2.0;\n}\n\nvec3 scurve3(vec3 x)\n{\n    return (3.0*x - x*x*x)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 hl = fragCoord/iResolution.xy;\n\n    // map 2D plane to the boundary of the RGB cube\n    vec3 yuv = vec3(hl.y, sin(hl.x*2.0*3.1415), cos(hl.x*2.0*3.1415));\n    \n    mat3x3 toRGB = mat3x3(\n        1.0, 0.0, -2.0/sqrt(2.0),\n        1.0, -sqrt(3.0/2.0), 1.0/sqrt(2.0),\n        1.0, sqrt(3.0/2.0), 1.0/sqrt(2.0));\n        \n    vec3 rgb = yuv*toRGB;\n    float Y = yuv.x;\n    float C = 2.0*Y*(1.0-Y);\n    rgb = Y + C*(rgb-Y);\n\n    float maxRGB = max(rgb.r,max(rgb.g,rgb.b));\n    float minRGB = min(rgb.r,min(rgb.g,rgb.b));\n\n    float maxScale = (maxRGB - 0.5)/(0.5);\n    float minScale = (0.5 - minRGB)/(0.5);\n\n    float scale = 1.0/max(maxScale, minScale);\n\n    rgb = (rgb-0.5)*scale + 0.5;      \n\n    \n    if (int(iTime) % 4 == 1)\n    {\n        // Reduced smoothed gamut\n        // In 3d it would look like a cube with rounded corners\n        // Should treat black and white specially, so they aren't smoothed as well.\n    \n        Y = 0.5;\n    \n        float l = 1.0/sqrt(dot(rgb - Y,rgb - Y));\n        rgb = (rgb-Y)*l + Y;\n    \n        vec3 maxScale = (1.0-Y)/(rgb - Y);\n        vec3 minScale = (Y)/(Y - rgb);\n        \n        vec3 combinedScale = 0.5*((maxScale + minScale) + sign(rgb - Y)*(maxScale - minScale));\n\n        float p =  - 4.0;\n        float scale = pow(dot(pow(combinedScale, vec3(p)),vec3(1.0)), 1.0/p);\n        \n        rgb = (rgb-Y)*scale + Y;   \n    }\n\n    \n    if (int(iTime) % 4 == 3)\n    {\n        // Map rgb values so ridges are saddle points\n    \n        rgb = 0.5*(scurve3(2.0*rgb - 1.0)+1.0);\n    }\n    \n    \n    fragColor = vec4(pow(rgb,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 95, 95, 129], [131, 131, 153, 153, 187], [189, 189, 246, 246, 1839]], "test": "untested"}
{"id": "fslcR8", "name": "Marination", "author": "wyatt", "description": ": )", "tags": ["noise"], "likes": 27, "viewed": 507, "published": 3, "date": "1641695581", "time_retrieved": "2024-07-30T17:11:05.308571", "image_code": "vec2 hash(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n#define R iResolution.xy\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvoid mainImage(out vec4 Q, in vec2 U)\n{\n    Q = vec4(0);\n    { // water\n        U.y-=.1*R.y;\n        if (U.y < .2*R.y) {\n            U.y = .4*R.y-U.y;\n            vec2 v = U-vec2(.5,.2)*R;\n            v *= 1./(1.+v.y);\n            U.x += 6.*sin(1000.*v.y);\n            U.y += 6.*cos(2.*iTime+1000.*v.y);\n            U.y += 6.*sin(iTime+10.*v.x);\n            U += 4.*(hash(iTime+U)*2.-1.);\n        }\n    }\n    float h = 0.;\n    {  // cloud\n        vec2 v = U;\n        v.y -= R.y;\n        v.x += 5.*iTime;\n        for (float i = 10.; i <= 100.; i++)\n            h += hash(1e2*i+floor(-iTime*4e-2+v*ei(i)/i)).x/90.;\n        h = clamp(round(h*300.-144.-20.*v.y/R.y)/30.,0.,1.);\n        vec4 C = (.5+.5*sin(6.*max(h-.4,0.)+4.5+v.y/R.y+vec4(1,2,3,4)));\n        Q += mix(C,vec4(h),.5+.5*h);\n    }\n    { // Space Needle\n        vec2 v = U-vec2(.1,.5)*R;\n        vec2 u = U-vec2(.1,.55)*R;\n        if (abs(u.x) < 2.&&u.y<0.) Q = vec4(0);\n        if (abs(v.x)<-.2*v.y&&abs(v.x)>-.1*v.y) Q = vec4(1.+50.*v.x/R.x);\n        \n        v.x *= .4+.1*sin(v.y);\n        if (length(v)<.02*R.y) {\n            Q = vec4(0);\n            if (abs(v.y)>.01*R.y) Q = vec4(.5+100.*v.x/R.x);\n            if (abs(v.y)<.003*R.y) Q = vec4(.5+100.*v.x/R.x);\n        }\n        if (length(u)<.005*R.y) Q = mix(Q,vec4(1,0,0,1),(.5+.5*sin(iTime)));\n\n    }\n    {\n        // city\n        for (float j = -5.; j < 5.; j++)\n        for (float i = 1.; i < 3.; i++) {\n            vec2 v = 2.*(U-.5*R)/R.y;\n            v.x += .005*i;\n            v.y -= .005*i;\n            v.y -= .02*j;\n            v.x *= 1.4-.04*j*j;\n            vec2 u = vec2(floor(10.*v.x),0);\n            vec2 h = hash(.1*u+j);\n            h.x *= 6.*exp(-.01*u.x*u.x);\n            h.x = .1*h.x-.4;\n            if (fract(v.x*10.)>.4) {\n                if (v.y < h.x+.01) Q*=0.;\n                if (v.y < h.x) {\n                    Q = .2+.8*vec4(h.y,.4,1.-h.y,1);\n                    v = 50.*vec2(v.x,v.y-h.x);\n                    h = hash(v);\n                    float w = max(abs(fract(v.x)-.5),abs(fract(v.y)-.5));\n                    Q *= (.5+.05*j*j)*smoothstep(.4,.3,w)*max(0.,-1.+2.*hash(floor(.001*iTime*floor(v.x)*floor(v.y))+floor(v)).x);\n                }\n            }\n        }\n    }\n    {// Boardwalk\n    \n        if (abs(U.y-.2*R.y)<15.) Q *= 0.;\n        vec2 v = U-vec2(.8,.36)*R;\n        float t = .01*iTime+.5+.5*atan(v.y,-v.x)/3.14159;\n        float l = length(v);\n        float r = .15*R.y;\n        float s = smoothstep(.6,.7,abs(fract(t*20.)-1.));\n        s *= smoothstep(1.,0.,l-r);\n        s = max(s,smoothstep(5.,3.,abs(l-r)));\n        vec2 u = vec2(fract(40.*t),fract(.125*l))*2.-1.;\n        vec4 li = 2.*exp(-4.*dot(u,u))*(.6+.5*sin(-2.*iTime+.1*l+vec4(1,2,3,4)));\n        Q = mix(Q,li,s);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 153], [228, 228, 267, 267, 2975]], "test": "untested"}
{"id": "NsfczH", "name": "Turret Bases Stand,Gun,Doors", "author": "Yusef28", "description": "More experiments, lot's of unused code in common tab. Focusing more on OO concepts.", "tags": ["animated"], "likes": 14, "viewed": 269, "published": 3, "date": "1641682537", "time_retrieved": "2024-07-30T17:11:06.358763", "image_code": "#define VIEW 1.\nfloat sdCappedCylinder( vec3 p, float r, float h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderZ( vec3 p, float r, float h ){\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nstruct Base {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n};\n\nstruct Stand {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec3 gunAxelPos;\n};\n\nstruct Gun {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec2 bounds;\n    float angle;\n};\n\nstruct Door{\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec2 bounds;\n    float angle;\n};\n\nBase theBase;\nStand theStand;\nGun theGun;\nDoor theDoor;\n\n\nvoid initializeBase(){\n    theBase.dim = vec3(1.,0.01,1.) * WORLD_SCALE;\n    theBase.center = vec3(0.,0.,0.);\n    theBase.basis = IDENTITY;     \n}\n\nvoid initializeDoor(float time){\n    theDoor.dim = vec3(0.9,0.03,.44) * WORLD_SCALE;\n    theDoor.angle = pow(SEQ_1,1./5.);\n    theDoor.center = vec3(0.,0.2-theDoor.angle,0.9);\n    \n    theDoor.basis = rotateX(theDoor.angle*PI*0.5,theBase.basis);//theBase.basis;\n}\n\nvoid initializeStand(float time){\n    theStand.dim = vec3(0.5) * WORLD_SCALE;                \n    theStand.center = vec3(0.,theBase.dim.y + theStand.dim.y,0.) \n                   + theBase.center;           \n    theStand.center += vec3(0.,pow(SEQ_2,1./4.)*4.-4.,0.);\n    theStand.gunAxelPos = vec3(0.0,0.9,0.05);\n    theStand.basis = rotateY(SEQ_3*PI,theBase.basis);\n}\n\nvoid initializeGun(float time){\n    theGun.dim = vec3(0.25,.25,0.25)  * WORLD_SCALE;\n    theGun.center = vec3(0.,theStand.center.y+0.,0.)\n                 + theStand.center;\n    theGun.center = theStand.gunAxelPos+ theStand.center;\n    theGun.bounds = vec2(-PI/2.,PI/2.);\n    theGun.angle = 0.;//clamp(abs(fract(time/4.)-0.5)*PI,theGun.bounds.x,theGun.bounds.y);\n    theGun.basis = rotateX(theGun.angle-PI*.5 - PI*SEQ_4*0.5,theBase.basis);\n}\n\nvoid initializeObjects(float time){\n    \n    initializeBase();\n    initializeDoor(time);\n    initializeStand(time);                \n    initializeGun(time);\n}\n\nfloat globalID = -1.;\nfloat baseID = -1.;\nfloat standID = -1.;\nfloat gunID = -1.;\n\n\nvec3 testGunTexture_1(vec3 pos){\n\n    vec3 dims = vec3(0.3, 0.1+geoPath1D_b(pos.x*3.-1.99)*0.29, 0.6);\n    vec3 pos_01 = pos/dims;\n    \n    vec3 designs = vec3( max(S(abs(fract(pos_01.y)-0.5)-0.3),\n                       S(abs(8.*pos_01.z)-0.85)),\n                       \n    max(S(abs(fract(8.*pos_01.z)-0.5)-0.4),\n                       S(abs(pos_01.x/2.)-0.2)),\n                       \n    max(S(abs(fract(pos_01.y)-0.5)-0.2),\n                       S(abs(pos_01.x)-0.85)));\n    return designs;\n}\n\nvec3 testStandTexture_1(vec3 pos){\n    vec3 mirroredZ = vec3(abs(pos.x)-0.55,pos.yz);\n    vec3 dims = vec3(\n                0.15 -geoPath1D_b(pos.y*1.+0.7)*0.4*step(0.,mirroredZ.x),\n                0.6,\n                0.25 -geoPath1D_b(pos.y+2.7)*0.3*step(mirroredZ.z,0.) \n                );\n                \n    vec3 pos_01 = (pos-vec3(0.,0.8,0.0))/dims;\n         \n    vec3 designs = vec3(max(S(abs(fract(pos_01.y-0.3))-0.5),\n                       S(abs(pos_01.z*0.7)-0.5)\n                       ),\n                   max(S(abs(fract(pos_01.x)-0.5)-.5),\n                       S(abs(fract(pos_01.z*2.))-0.5)\n                       ),\n                       0.);\n    return designs;\n}\n\nfloat base(vec3 p){\n    vec3 pos = p * theBase.basis - theBase.center;\n    \n    vec3 dims = theBase.dim - vec3(0.,sin(p.z-PI/2.),0.)/4.;\n    \n    float d = sdBox(pos, dims);\n    \n    d = max(d,-sdBox(pos, vec3(0.9,11.,0.9)));\n    return d;\n}\n\nfloat door(vec3 p){\n    p.z = abs(p.z);\n    vec3 pos = (p  - theDoor.center) * theDoor.basis;\n    pos.z += theDoor.dim.z/1.;\n    //pos.y -= theDoor.dim.x*0.5;\n    pos.y -= sin(pos.z*1.6+2.2)/4. - 0.2;\n    \n    \n    float raisedSurface = smoothstep(0.6,0.55,abs(pos.x-0.1))/20.;\n    raisedSurface *= smoothstep(1.4,1.35,abs(pos.z*2.))*2./20.;\n    vec3 dims = theDoor.dim;\n    dims.y -= raisedSurface;\n    \n    float d = sdBox(pos,dims);\n    \n    return d;\n}\n\nfloat stand(vec3 p){\n    \n    vec3 pos = (p  - theStand.center)* theStand.basis;\n    \n    float cyl1 = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.05,0.),\n    cos(atan(pos.x,pos.z)*60.)/40. + .6,0.05)  - 0.01;\n    \n    float cyl2 = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.15,0.),\n    0.66,\n    0.05-smoothstep(0.9,0.85,length(pos.xz)/0.66)*0.035) - 0.015;\n    \n    float cyl3b = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.2,0.),\n    0.3-geoPath1D_b(pos.y*15.-0.4)*0.05,\n    0.15)- 0.015;\n    \n    float cyl4b = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.45,0.),\n    0.15,\n    0.2)- 0.015;\n    \n    //////////////////////finegeo start/////////////////////////\n    vec3 dims = vec3(0.7,0.09, 0.25);\n    vec3 pos_01 = (pos-vec3(0.,theStand.dim.y-0.26,0.))/dims;\n    \n    vec3 designs = vec3(0.,max(S(abs(pos_01.z)-0.5),\n                               S(abs((pos_01.x))-0.42)),0.)/30.;\n\n    /////////////////end of fine geo///////////////////////////   \n    \n    float legBottom = sdBox(pos-vec3(0.,theStand.dim.y-0.26,0.),\n    dims-designs);\n    \n    \n    \n    /////////////////////////for fine geo///////////////\n    vec3 mirroredZ = vec3(abs(pos.x)-0.55,pos.yz);\n   dims = vec3(\n                0.15 -geoPath1D_b(pos.y*1.+0.7)*0.4*step(0.,mirroredZ.x),\n                0.6,\n                0.25 -geoPath1D_b(pos.y+2.7)*0.3*step(mirroredZ.z,0.) \n                );\n                \n    pos_01 = (pos-vec3(0.,0.8,0.0))/dims;\n         \n    designs = vec3(max(S(abs(fract(pos_01.y-0.3))-0.5),\n                       S(abs(pos_01.z*0.7)-0.5)\n                       ),\n                   max(S(abs(fract(pos_01.x)-0.5)-.5),\n                       S(abs(fract(pos_01.z*2.))-0.5)\n                       ),\n                       0.)/100.;\n    float leg = sdBox(mirroredZ-vec3(0.,0.8,0.0), dims-designs.xyz);     \n     //////////////////////end of fine geo/////////////////     \n          \n    \n    \n    float gunAxel = sdCappedCylinder(pos.zxy-vec3(0.05,0.,0.9),\n    0.05,0.65) - 0.015;\n    \n    float topBarRidged = sdCappedCylinder(pos.zxy-vec3(0.05,0.,0.9),\n    0.15 - geoPath1D_b(pos.x*30.)*0.02,\n    0.33) - 0.015;\n    \n    float mirrorX_float = abs(pos.x)-0.4;\n    float topBarGaurd = sdCappedCylinder(vec3(pos.z,mirrorX_float,pos.y)-vec3(0.05,0.,0.9),\n    0.18,0.05) - 0.015;\n    \n    mirrorX_float = abs(pos.x)-0.45;\n    float sideCaps =  length(vec3(mirrorX_float,pos.y-0.9,pos.z-0.05))-0.2;\n        \n   \n    \n    float d = sdBox(pos, \n              theStand.dim);\n    d = 1000.;\n    float silvers = min(d, min(cyl2,cyl1));\n    silvers = min(silvers, cyl3b);\n    silvers = min(silvers, cyl4b);\n    silvers = min(silvers, sideCaps);\n    silvers = min(silvers, topBarRidged);\n    silvers = min(silvers, gunAxel);\n    \n    float blacks = 1000.;\n    blacks = min(blacks, legBottom);\n    blacks = min(blacks, leg);\n    blacks = min(blacks, topBarGaurd);\n    \n    standID = silvers < blacks ? 1. : 2.; \n    \n\n    return min(silvers, blacks);\n}\n\n\nfloat gun(vec3 p){\n\n    vec3 pos = (p*theStand.basis  - theGun.center) * theGun.basis ;\n              \n    float d = 100.;\n    \n    vec3 dims = vec3(0.3,.2+geoPath1D_b(pos.z*3.-1.99)*0.2,0.3);\n    vec3 pos_01 = pos/dims;\n\n    vec3 designs = vec3( 0.,\n    \n    max(S(abs(fract(1.*pos_01.z)-0.5)-0.4),\n                       S(abs(pos_01.x)-0.42)),\n                       \n    max(S(abs(fract(pos_01.y)-0.5)-0.2),\n                      S(abs(2.*pos_01.x)-0.85)));\n    designs /= 20.;\n    float charger = sdBox(pos,dims-designs);\n    \n    \n              \n    dims = vec3(0.3, 0.1+geoPath1D_b(pos.x*3.-1.99)*0.29, 0.6);\n    pos_01 = pos/dims;\n    \n    designs = vec3( max(S(abs(fract(pos_01.y)-0.5)-0.3),\n                       S(abs(8.*pos_01.z)-0.85)),\n                       \n    max(S(abs(fract(8.*pos_01.z)-0.5)-0.4),\n                       S(abs(pos_01.x/2.)-0.2)),\n                       \n    max(S(abs(fract(pos_01.y)-0.5)-0.2),\n                       S(abs(pos_01.x)-0.85)));\n                        \n    designs /= 20.;\n\n    float barrel = sdBox(pos-vec3(0.,0.,.8), dims-designs);\n\n\n\n\n    float cylBarrel1 = sdCappedCylinderZ(pos-vec3(0.,0.,1.),\n    0.12-geoPath1D(pos.z*34.)*0.05*step(pos.z,1.8),\n    0.9)- 0.015;\n    float cylBarrel2 = sdCappedCylinderZ(pos-vec3(0.,0.,1.3),\n    0.08,\n    0.9)- 0.015;\n    float cylBarrel3 = sdCappedCylinderZ(pos-vec3(0.,0.,2.4),\n    0.1 + clamp(geoPath1D(atan(pos.x,pos.y)*3.)*0.08,0.,0.03)\n        * smoothstep(2.4,2.45,pos.z),\n    0.25)- 0.015;\n    \n    float cylBarrelCut = sdCappedCylinderZ(pos-vec3(0.,0.,2.4),\n    0.08, 1.3)- 0.015;\n    \n    d = 10.;\n    \n    d = min(d, charger);\n    d = min(d, barrel);\n    d = min(d, cylBarrel1);\n    d = min(d, cylBarrel2);\n    d = min(d, cylBarrel3);\n    d = max(d, -cylBarrelCut);\n    \n    gunID = abs(cylBarrel2-d) < 0.001 || abs(cylBarrel1-d) < 0.001 \n    ? 1. : 2.;\n    \n    \n    return d;\n}\n\n\nfloat map(vec3 p){\n    //Split the world into coordinates,\n    vec2 floorID = vec2(0.);//floor(p.xz/4.-2.);\n    //p.xz = mod(p.xz,4.*WORLD_SCALE)-2.*WORLD_SCALE;\n    //initalize the objects in their current animated position,\n    initializeObjects(rnd2D(floorID)*800.+iTime);\n    //and return the distance field.\n    float alle = 1000.;\n    \n    float dGun = gun(p/WORLD_SCALE);\n    float dStand = stand(p/WORLD_SCALE);\n    float dBase = base(p/WORLD_SCALE);\n    float dDoor = door(p/WORLD_SCALE);\n    \n    alle = min(dGun,alle);\n    alle = min(dStand,alle);\n    alle = min(dBase,alle);\n    alle = min(dDoor,alle);\n    \n    if(abs(alle-dGun) < 0.001){\n        globalID = 1.;\n    }\n    else if(abs(alle-dStand) < 0.001){\n        globalID = 2.;\n    }\n    else if(abs(alle-dBase) < 0.001){\n       globalID = 3.;\n    }\n    else if(abs(alle-dDoor) < 0.001){\n      globalID = 4.;\n   }\n   // \n    return alle;\n    \n    //return min(gun(p),min(stand(p),min(100.,base(p))));\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.5;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 24; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d*0.75;\n    }\n    \n    return t;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 getObjectColor(vec3 p){\n\n//gun == 1\n//stand == 2\n//base == 3]\n    \n    vec3 gunPos = (p*theStand.basis  - theGun.center) * theGun.basis;\n    vec3 standPos = (p  - theStand.center)* theStand.basis;\n    \n    if(globalID == 1.){  return gunID == 1. ? \n                             vec3(0.7)          : \n                             mix(vec3(0.1),\n                             vec3(1.,0.,0.),\n                             testGunTexture_1(gunPos).z);\n                         }\n                         \n    else if(globalID == 2.){ return standID == 1. ?  \n                             vec3(0.7) : \n                             mix(vec3(0.1),\n                             vec3(1.,0.,0.),\n                             testStandTexture_1(standPos).x);\n                         }\n    else if(globalID == 3.){return vec3(0.9,0.,0.);}\n    else if(globalID == 4.){return vec3(.3);}\n    return vec3(globalID/3.);\n}\n\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    vec3 objCol = getObjectColor(sp)+0.25;\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., .6, .2)*spec*2.) ;//* atten;\n    float fogF = smoothstep(0., .95, t/FAR);\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n    return sceneCol;\n    \n}\n\nvec3 getCameraDirection(vec2 uv, vec3 ro, vec3 ta){\n\n    vec3 fwd = normalize(ta-ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(fwd,ri));\n    return normalize(uv.x*ri + uv.y*up + fwd*1.2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 ta,ro;\n    \n    if(VIEW == 1.){\n        ta = vec3(0.,2.,0.);\n        ro = vec3(0.,3.,9.5) * WORLD_SCALE;\n    }\n    else if(VIEW == 2.){\n        ta = vec3(0.,0.,0.);\n        ro = vec3(0.,7.,.5) * WORLD_SCALE;\n    }\n    \n\n   \n    if(iMouse.z > 0.5){\n        //float rotScale = 4.;\n        vec2 m = iMouse.xy/iResolution.xy;\n        //vec3 ro = vec3(0., 1., -3.);\n        ro.yz *= rot(-m.y*PI+1.);\n        ro.xz *= rot(-m.x*PI*2.);\n        //ro.xz *= rot(4.*(iMouse.x/iResolution.x)-rotScale/2.);\n        //ro.yz *= rot((iMouse.y/iResolution.y)*PI);\n    }\n    else{\n        //ro.yz *= rot(sin(iTime/4.)-0.2);\n        ro.xz *= rot(-iTime/3.);\n    }\n    vec3 rd = getCameraDirection(uv,ro,ta);\n    \n\n\n    vec3 lp = ro + vec3(0., 0., 1.);\n    //\n    \n    float planeT = pointOnPlane(ro,rd);\n    \n    \n   // initializeObjects();//(and animate them)\n    float t = trace(ro, rd);\n    \n    if(t < FAR){\n        vec3 pos = ro + rd*t; \n        vec3 sn = getNormal(pos);\n        col += doColor(pos, rd, sn, lp, t)/2.;\n        vec3 p = pos;\n        \n        /*\n        col = mix(col, vec3(1.,0.,0.),\n            step(0.01,shapeDecline(p.xz / WORLD_SCALE,0.,0.,0.,0.)));\n            \n        col = mix(col, vec3(1.),\n            step(0.01,complexMap(p.xz / WORLD_SCALE)));  \n            \n        col = mix(col, vec3(0.,0.,1.),\n            step(0.01,floppyDiskThing(p.xz / WORLD_SCALE))); \n            \n        col = mix(col, vec3(0.,0.,1.),\n            step(0.01,floppyDiskThing3(p.xz / WORLD_SCALE)));*/\n\n    }\n    if(rd.y >= 0.){\n    //    col = mix(col,vec3(0.8,0.8,0.9),pow(1.-rd.y,50.));\n    }\n    \n    if(planeT > 0. && t > FAR){\n        vec3 pos = ro + rd*planeT; \n        vec3 sn = vec3(0.,1.,0.);\n        vec2 vh = step(abs(fract(pos.xz)),vec2(0.04));\n       // float hori = step(abs(fract(pos.z)-0.5),0.04);\n        col += (vh.x+vh.y)/5.;//doColor(pos, rd, vec3(0.,1.,0.), lp, t);\n       // float sh = softShadow(ro +  sn*.0015, lp, 16.);\n       \n    }\n\n    //col = vec3(floppyDiskThing3(uv*3.));//shapeLadder(uv*2.));\n    float textureFrame;\n    vec2 uvFrame = abs(uv)-0.3;\n    float uvF = max(uvFrame.x,uvFrame.y);\n    //col += smoothstep(0.01,0.,abs(uvF-0.2));\n    fragColor = vec4(col,1.);//sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "#define PI acos(-1.)\n#define animator (sin(iTime)*0.5+0.5)\n#define startTime (iTime*4. +30.)\n#define newAnimator (sin(startTime)*0.5+0.5)\n\n\n#define sequence (abs(mod(startTime/4.,12.)-6.))\n\n#define SEQ_0 clamp(sequence,   0.,1.)\n#define SEQ_1 clamp(sequence-1., 0.,1.)\n#define SEQ_2 clamp(sequence-2.,0.,1.)\n#define SEQ_3 clamp(sequence-3.,0.,1.)\n#define SEQ_4 clamp(sequence-4.,0.,1.)\n#define SEQ_5 clamp(sequence-5.,0.,1.)\n\n#define IDENTITY mat3(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.))\n\n#define WORLD_SCALE 1.\n#define FAR 50.\n#define S(a) smoothstep(0.,0.05,a)\n\n#define ANIMATOR 0.5//abs(fract(time)-0.5)\nfloat rnd(float a){\n    return fract(sin(a)*45960.24562);\n}\n\nfloat rnd2D(vec2 id){\n    return fract(sin(dot(vec2(12.94,73.59),id))*45960.24562);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nfloat sdBox(vec3 pos, vec3 dim){\n    vec3 aPos = abs(pos) - dim;\n    return max(aPos.x, max(aPos.y,aPos.z) );\n}\n\nmat3 rotateX(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].yz *= theRotation;\n    basis[1].yz *= theRotation;\n    basis[2].yz *= theRotation;\n    return basis;\n}\n\nmat3 rotateY(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].xz *= theRotation;\n    basis[1].xz *= theRotation;\n    basis[2].xz *= theRotation;\n    return basis;\n}\n\nmat3 rotateZ(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].xy *= theRotation;\n    basis[1].xy *= theRotation;\n    basis[2].xy *= theRotation;\n    return basis;\n}\n\nfloat pointOnPlane(vec3 ro, vec3 rd){\n    vec3 pp = vec3(0.);\n    vec3 n = vec3(0.,1.,0.);\n    float t = (dot(pp,n)-dot(ro,n))/dot(rd,n);\n    return t < FAR ? t : -1.;\n}\n\nfloat geoPath1D(float dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.1, 0.35)*1.5;\n}\nfloat geoPath1D_b(float dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.0, 0.23)*1.4;\n}\n\nvec2 geoPath(vec2 dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.0, 0.35)*1.5;\n}\n\nvec2 geoBumpPath(vec2 dir){\n    return clamp(\n                abs(fract(dir/2.)-0.5),\n           0.0, 0.35)*1.5;\n}\n\nfloat shapeDecline(vec2 uv, \n    float height, float degree, float smoothStart, float smoothEnd){\n    vec2 decline = pow(smoothstep(1.,0.75,abs(uv)),vec2(4.)) *0.15;\n    return min(decline.x,decline.y);\n}\n\nfloat shapeSinGroove(vec2 uv,float height,\nfloat smoothStart,float smoothEnd){\n    //smoothstart = 0.75, smoothEnd = 0.7    \n    return smoothstep(smoothStart,smoothEnd,\n    abs(uv.x-sin(uv.y)))/height;//9.\n}\n\nfloat shapeGeoGroove(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    vec2 geoGroove = smoothstep(0.75,0.7,\n                abs(uv.xy+shiftToSide)-widen+geoPath(uv.yx))/height;//18.\n                \n    return min(geoGroove.x,geoGroove.y);\n}\nfloat shapeGeoGroove1D(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    float geoGroove = smoothstep(0.75,0.7,\n                abs(uv.x+shiftToSide)-widen+geoPath1D(uv.y))/height;//18.\n                \n    return geoGroove;\n}\nfloat shapeGeoGroove1D_b(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    float geoGroove = smoothstep(0.75,0.7,\n                abs(uv.x+shiftToSide)-widen+geoPath1D_b(uv.y))/height;//18.\n                \n    return geoGroove;\n}\nfloat shapeOutlineBump(vec2 uv){\n\n    vec2 outlineBump = smoothstep(0.08,0.0, \n                abs(abs(uv.xy)-0.96) ) * 0.05;\n    return max(outlineBump.x,outlineBump.y);\n}\n\nfloat shapeGeoBump(vec2 uv){\n\n    float widenSides = 0.99;\n    float widenBump = 0.6; //larger is thinner, thinnest is 1.4\n    vec2 geoBump = smoothstep(0.75,0.7, \n                     abs(abs(uv.xy)-widenSides+\n                     geoBumpPath(uv.yx))+widenBump)/15.;\n    return  max(geoBump.x,geoBump.y);\n}\n\nfloat shapeLadder(vec2 uv){\n    float sq = max(abs(uv.y)-0.3,abs(uv.x)-0.3);\n    uv *= rot(PI*0.25);\n    uv = abs(uv)-0.65;\n    uv *= rot(PI*0.25);\n    float d = smoothstep(0.2,0.18,abs(uv.x)-0.06) * \n              step(abs(uv.y)-0.2,0.1);\n              \n    uv.y = smoothstep(.2,0.2,abs(fract(uv.y*25.+0.24)-0.4));\n    vec2 bf = abs(uv)+vec2(0.22,-0.2);\n    float cut = max(bf.x,bf.y);\n    cut = smoothstep(0.3,0.2,cut);\n    d = min(d,cut);\n    \n    return d*step(sq,0.55);\n}\n\nfloat complexMap(vec2 uv){\n    //uv *= 2.;\n    \n    float d = smoothstep(0.,0.1,shapeGeoGroove1D(uv,.0,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D(uv,.06,12.))/18.;\n    d -= smoothstep(0.1,0.,shapeGeoGroove1D(uv,.2,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D(uv,.26,12.))/18.;\n    d -= smoothstep(0.1,0.,shapeGeoGroove1D(uv,.3,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D_b(uv,.49,12.))/18.;\n    return d;\n}\n\nfloat floppyDiskThing(vec2 uv){\n    vec2 spread = vec2(6., 2.2);\n    uv*=8.;\n    uv = abs(uv)-spread;\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    d = clamp(d,0.,1.);\n    d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\n\nfloat floppyDiskThing2(vec2 uv){\n    \n    uv*=2.;\n    //uv = abs(uv)-vec2(6.,1.5);\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n             \n    d = clamp(d,0.,1.);\n    \n    uv*=2.;\n    uv.y = abs(uv.y)-1.5;\n    float cut = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    cut = clamp(cut,0.,1.);    \n    d = min(d,cut);\n   // d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\nfloat floppyDiskThing3(vec2 uv){\n    uv*= 2.;\n    uv.x = abs(uv.x)-1.4;\n    uv*=2.;\n    //uv = abs(uv)-vec2(6.,1.5);\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n             \n    d = clamp(d,0.,1.);\n    \n    uv*=1.2;\n    uv.x -= 0.55;\n    uv.y = abs(uv.y)-1.2;\n    float cut = max(abs(uv.x*0.8)-0.3-geoPath1D(uv.y/1.)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    //cut = clamp(cut,0.,1.); \n    cut = smoothstep(0.9,0.4,cut);\n    d = max(d,cut);\n   // d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 67, 67, 174], [176, 176, 228, 228, 335], [742, 742, 764, 764, 888], [890, 890, 922, 922, 1153], [1155, 1155, 1188, 1188, 1523], [1525, 1525, 1556, 1556, 1966], [1968, 1968, 2003, 2003, 2126], [2212, 2212, 2244, 2244, 2711], [2713, 2713, 2747, 2747, 3399], [3401, 3401, 3420, 3420, 3642], [3644, 3644, 3663, 3663, 4100], [4102, 4102, 4122, 4122, 7053], [7056, 7056, 7074, 7074, 8938], [8941, 8941, 8959, 8999, 9908], [9909, 9909, 9939, 9939, 10249], [10250, 10250, 10283, 10283, 10483], [10485, 10485, 10512, 10512, 10720], [10722, 10722, 10750, 10788, 11631], [11633, 11633, 11703, 11703, 12407], [12409, 12409, 12460, 12460, 12657], [12660, 12660, 12716, 12716, 15033]], "test": "untested"}
{"id": "NsfcR8", "name": "Spline Idea e", "author": "SnoopethDuckDuck", "description": "Pretty good, not perfect.\n\nMaths stolen from here:\nhttps://www.cs.cmu.edu/~462/www/projects/assn2/assn2/catmullRom.pdf\n\nImproved version:\nhttps://www.shadertoy.com/view/mtKXRG", "tags": ["spline"], "likes": 9, "viewed": 308, "published": 3, "date": "1641680858", "time_retrieved": "2024-07-30T17:11:07.121725", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n\n    vec3 e = vec3(1.);\n    vec3 col2 = 2.5 * x * pal(mix(0.3, 0.35, 0.5 + 0.5 * thc(2., iTime)), e, e, e, vec3(0., 0.33, 0.66));\n    fragColor = vec4(0.06 + col2, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;      \n    // (multiplying by constant seems to be buggy)\n    float time = iTime;\n    \n    // Offset y values from x values (so it doesnt just move diagonally)\n    float o = 0.01;\n    // Scale point locations to fit to screen\n    float sc = 0.8;\n    \n    // Next 4 points in sequence\n    // (bad approach - has a bottom-left bias)\n    // (should be using integer hash, rounding errors ruin it)\n    vec2 p0 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time))),      h21(vec2(o + floor(time))) );\n    vec2 p1 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 1.))), h21(vec2(o + floor(time + 1.))) );\n    vec2 p2 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 2.))), h21(vec2(o + floor(time + 2.))) );\n    vec2 p3 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 3.))), h21(vec2(o + floor(time + 3.))) );\n\n    float f = fract(time);\n\n    float t = 0.8;\n    mat4 M = mat4(   0,  1,     0,        0,\n                    -t,  0,     t,        0,\n                  2.*t,  t-3.,  3.-2.*t,  -t,\n                    -t,  2.-t,  t-2.,     t);\n    vec4 U = vec4(1., f, f*f, f*f*f);\n    vec4 Px = vec4(p0.x, p1.x, p2.x, p3.x);\n    vec4 Py = vec4(p0.y, p1.y, p2.y, p3.y);\n    vec2 p = vec2(dot(Px, M * U), dot(Py, M * U));\n    \n    float d = length(uv - p);\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.025);\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    x = 0.98 * clamp(x, 0., 1.);\n    s = max(x, s);\n    s = max(s, f * smoothstep(-k, k, -length(uv - p2) + 0.025));\n\n    fragColor = vec4(s);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Collection of functions I use a lot:\n\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 357]], "test": "untested"}
{"id": "7ssyzr", "name": "GPU and OS detector v2", "author": "archee", "description": "This will guess your GPU manufacturer and OS based on the inaccuracy of math functions. Displaying resulting hashes at top-right corner. Please comment your hashes, if your GPU is shown unknown or wrong.", "tags": ["hash", "gpudetector", "determinism"], "likes": 57, "viewed": 1984, "published": 3, "date": "1641676510", "time_retrieved": "2024-07-30T17:11:07.883686", "image_code": "/*\nMath functions are implemented differently in each GPU and drivers.\nThis will run the same calculation compile time and runtime, \nand print the two results in the top-right corner.\nIt will guess your GPU and OS based on the hashes.\n\nReciptrocal, sqrt, sin all probably work with constants in a table for a polynom.\n\nSome results appear on multiple OS-es, so the OS can't always be guessed.\n\nIf your GPU is unknown or wrong, please comment your hashes and hardware description.\n\n*/\n#define DYN_ZERO min(0.,iTime) // forcing runtime calculation\nint hardwareHash(float start)\n{\n    float a=start;\n    for(int i=0;i<20;i++)\n    {\n        a=fract(normalize(vec3(a+0.1,6.11,5.22)).x*3.01);\n        a+=sin(sqrt(a)*100.3)*0.31;\n    }\n    return int(fract(fract(abs(a))*256.)*256.*256.);\n}\n\n// font and printing\nvec2 printCursor;\nfloat backGroundColor=0.;\nfloat printColor=0.;\n#define C(c) printCursor.x-=.5;char(printCursor,c);\nvoid char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return;\n\tprintColor= max(printColor, texture( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ) ).x+backGroundColor);\n}\nvoid printHex(int i)\n{\n    float div = 16.*16.*16.;\n    for(int j=3;j>=0;j--)\n    {\n        float digit = fract(float(i)/div/16.)*16.;\n        div/=16.;\n        C(int((digit<10.?48.:65.-10.)+digit));\n    }\n}\n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    uv /= min(iResolution.y,iResolution.x/1.9);\n    \n        \n    int hash_runtime = hardwareHash(0.+DYN_ZERO);\n    int hash_comptime = hardwareHash(0.);\n    \n   \n    int os=UNKNOWN;\n    int gpu=UNKNOWN;\n    int gldx=UNKNOWN;\n    \n    // nVidia\n    if (hash_runtime==0x1EC4) { gpu=NVIDIA; } // 3060 WindowsGL and Linux\n    if (hash_runtime==0xFA2D) { os=LINUX; gpu=NVIDIA; }  // 1050\n    if (hash_runtime==0x716D) { gpu=NVIDIA; } // Quatro\n    if (hash_runtime==0x7CD6) { os=LINUX; gpu=NVIDIA; } // 750\n    \n    // AMD\n    if (hash_runtime==0x58A4) { os=WINDOWS; gpu=AMD; gldx=GL;}// AMD GCN4\n    if (hash_runtime==0x3F8E) { os=((hash_runtime==hash_comptime)?OSXIOS:WINDOWS); gpu=AMD; gldx=ANGLE;}// AMD GCN4\n    if (hash_runtime==0x76B5) { os=LINUX; gpu=AMD; gldx=GL;}// AMD GCN4\n    if (hash_runtime==0x47EF) { gpu=AMD; } // AMD RDNA \n    if (hash_runtime==0xF04A) { gpu=AMD; os=WINDOWS; } // AMD RDNA angle\n    if (hash_runtime==0x40DC) { gpu=AMD; } // AMD GCN5  (Vega 64)\n    if (hash_runtime==0x553A) { gpu=AMD; os=OSXIOS; gldx=GL; } // CT:00E2 \n    \n    \n    // intel\n    if (hash_runtime==0x859D) { gpu=INTEL; } // Intel 7.gen // Windows?\n    if (hash_runtime==0x859C) { gpu=INTEL; } // some intel\n    if (hash_runtime==0xEEE7) { gpu=INTEL; } // Intel 2.gen or 7. gen linux?\n    if (hash_runtime==0x289F) { gpu=INTEL; os=OSXIOS; gldx=GL; }  // OSX ( Intel 2.gen Mac mini Catalina)\n    if (hash_runtime==0xE6DB) { gpu=INTEL; os=OSXIOS; gldx=GL; } // CT: 8DEA\n    if (hash_runtime==0x3F5F) { gpu=INTEL; } // Intel 11.gen Windows ANGLE\n    \n    // software rendering\n    if (hash_runtime==0xFDf0) { gpu=SOFTWARE; } // Linux?\n    if (hash_runtime==0x884E) { gpu=SOFTWARE; gldx=GL; }\n    if (hash_runtime==0x9CB8) { gpu=SOFTWARE; } // Linux?\n\n    // adreno\n    if (hash_runtime==0xF09B) { gpu=ANDROID; os=ANDROID; gldx=GL; }\n    \n    // mali\n    if (hash_runtime==0x5Af5) { gpu=MALI; os=LINUX; gldx=GL; } // Asus Tinkerboard\n    if (hash_runtime==0xACB3) { gpu=MALI; os=ANDROID; gldx=GL; }\n    \n    // apple\n    if (hash_runtime==0x89D8) { gpu=APPLE; os=OSXIOS; gldx=GL; } // CT=0xEE26 iPad 6.gen\n    if (hash_runtime==0x8C7B) { gpu=APPLE; os=OSXIOS; gldx=GL; } // CT=0xEE26 Apple A14\n    if (hash_runtime==0x9F12) { gpu=APPLE; os=OSXIOS; gldx=GL; } // CT=0xEE26 iPhone Safari\n    \n    // videocore ( raspberry pi )\n    if (hash_runtime==0xFFD0) { gpu=VIDEOCORE; os=LINUX; gldx=GL; } // rpi \n    \n    \n    if (hash_comptime==0x83CA) { gldx = GL; os=WINDOWS; }; // OpenGL Windows AMD\n    if (hash_comptime==0xFDF0) { gldx = GL; }; // OpenGL Windows, Linux (non-nVidia)\n    if (hash_comptime==0xE6DB) { gldx = GL; os=LINUX; }; // OpenGL Linux  AMD/Intel/Software\n    if (hash_comptime==0x1D23) { gldx = GL; } // only with nVidia, any OS\n    if (hash_comptime==0x239C) { gldx = ANGLE; os = WINDOWS; }; \n    if (hash_comptime==0x00E2) { gpu=AMD; os=OSXIOS; gldx=GL; }; // Maxbook AMD Radeon Pro 5500M\n    \n    \n    uv *= 10.;\n    int line = 9-int(uv.y);\n    int column = int(uv.x/5.);\n    printCursor = vec2(mod(uv.x,5.),fract(uv.y));\n    \n    if (column==0)\n    {\n        backGroundColor = (line==gpu)?0.5:0.;\n        if (line==UNKNOWN) { C(_u);C(_n);C(_k);C(_n);C(_o);C(_w);C(_n); }\n        if (line==NVIDIA) {C(_n);C(_V);C(_i);C(_d);C(_i);C(_a);}\n        if (line==AMD) {C(_A);C(_M);C(_D);}\n        if (line==INTEL) {C(_I);C(_n);C(_t);C(_e);C(_l);}\n        if (line==ADRENO) { C(_A);C(_d);C(_r);C(_e);C(_n);C(_o); }\n        if (line==MALI) {C(_M);C(_a);C(_l);C(_i);}\n        if (line==SOFTWARE) {C(_s);C(_o);C(_f);C(_t);C(_w);C(_a);C(_r);C(_e);}\n        if (line==APPLE) {C(_A);C(_p);C(_p);C(_l);C(_e);}\n        if (line==VIDEOCORE) {  C(_V);C(_C); } // videocore (raspberry pi)\n    }\n    if (column==1)\n    {\n        backGroundColor = (line==os)?0.5:0.;\n        if (line==UNKNOWN) { C(_u);C(_n);C(_k);C(_n);C(_o);C(_w);C(_n); }\n        if (line==WINDOWS) { C(_W);C(_i);C(_n); }\n        if (line==LINUX) { C(_L);C(_i);C(_n);C(_u);C(_x); }\n        if (line==OSXIOS) { C(_O);C(_S);C(_X); C(_slash); C(_i);C(_O);C(_S); }\n        if (line==ANDROID) { C(_A);C(_n);C(_d);C(_r);C(_o);C(_i);C(_d); };\n    }\n    if (column==2)\n    {\n        backGroundColor = (line==gldx)?0.5:0.;\n        if (line==UNKNOWN) { C(_u);C(_n);C(_k);C(_n);C(_o);C(_w);C(_n); }\n        if (line==GL) {C(_G);C(_L);}\n        if (line==ANGLE) { C(_A);C(_N);C(_G);C(_L);C(_E);}\n    }\n    if (column==3)\n    {\n        if (line==0 || line==1) printHex(line==0?hash_runtime:hash_comptime);\n    }\n    \n    \n    O = vec4(printColor,pow(printColor,2.0),pow(printColor,3.0),0.)*0.8;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define UNKNOWN 0\n#define WINDOWS 1\n#define LINUX 2\n#define OSXIOS 3\n#define ANDROID 4\n\n#define NVIDIA 1\n#define AMD 2\n#define INTEL 3\n#define ADRENO 4\n#define MALI 5\n#define APPLE 6\n#define SOFTWARE 7\n#define VIDEOCORE 8\n\n#define GL 1\n#define ANGLE 2\n\n#define _space 32\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n#define _slash 47\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 546, 577, 577, 783], [923, 923, 950, 950, 1115], [1116, 1116, 1138, 1138, 1323], [1326, 1326, 1365, 1365, 5907]], "test": "untested"}
{"id": "NsXcRH", "name": "Union Jack animated", "author": "Krischan", "description": "The animation from https://www.shadertoy.com/view/flsXRM combined with the golfed UK flag.", "tags": ["animated", "flag", "uk", "unionjack"], "likes": 4, "viewed": 320, "published": 3, "date": "1641664346", "time_retrieved": "2024-07-30T17:11:08.653628", "image_code": "#define S(U,w) min( p = smoothstep(-1., 1., ( abs(U) - w *vec2(.5,R.y/R) )/fwidth(U) ), p.y ).x\n\nvec3 Flag(vec2 U) {\n    \n    vec2 R = iResolution.xy, V, p,t;\n    U -= .5;\n    V = ( U + vec2(U.y,-U) ) / 1.4;\n    \n\tvec4 O;\n    O = mix( O = vec4(.78, .1, .2, 0), \n             1. + S(U,.166 ) * mix( O-1.,                            // s = .75;\n                                    -vec4(1, .9, .6, 0) * S(V,.125), //.166*s\n                                    S( V - .015 * sign(U), .038) )   //.05*s\n             , S(U,.1) ) \n      * ( 1. + (cos(t)*.3-.3)*( U+.5) ).x;\n\t  \n\t return O.rgb;\n}\n\nfloat vignette(vec2 U)\n{\n    return 16. * U.x * (1. - U.x) * U.y * (1. - U.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*7.-6.*iTime+uv.y*6.;\n    uv.y += sin(t)*.0125;\n    \n    vec3 col = Flag(uv);\n    \n    col += sin(t)*0.25; // highlights\n    col *= .7+cos(t)*.3; // shadows\n\n    col *= 1.0 - .6 * exp2(-1.75 * vignette(uv)); // vignette\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 588], [590, 590, 614, 614, 670], [672, 672, 729, 729, 1046]], "test": "untested"}
{"id": "NsfyRH", "name": "Stars and Stripes animated", "author": "Krischan", "description": "The animation from https://www.shadertoy.com/view/flsXRM combined with the golfed USA flag.", "tags": ["animated", "flags", "golf", "usa"], "likes": 1, "viewed": 267, "published": 3, "date": "1641662494", "time_retrieved": "2024-07-30T17:11:09.479420", "image_code": "vec3 Flag(vec2 U)\n{\n\tfloat r = 15. / iResolution.y;\n\tfloat q = mod(ceil((U *= r).x - .3), 2.);\n\tvec4 O = vec4(7, 1, 2, 4) * .1;\n\tO = (U.x < 11.7 && U.y > 7. ? O.zzwy : sin(2.69 * U.y) < 0. ? O/O : O)\n      + smoothstep(r,0.,length(U = vec2(fract(clamp(U.x + .7, 1., 12.)),\n        mod(clamp(U.y, 8. - q, 14. + q ) - q * .8, 1.62)) - .5)\n      * cos(abs(mod(atan(U.x, U.y) + .6, 1.26) - .6) - 1.26) - .1);\t\n\t\n\treturn O.rgb;\n}\n\nfloat vignette(vec2 U)\n{\n    return 16. * U.x * (1. - U.x) * U.y * (1. - U.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*7.-6.*iTime+uv.y*6.;\n    uv.y += sin(t)*.0125;\n    \n    vec3 col = Flag(uv*iResolution.xy);\n    \n    col += sin(t)*0.25; // highlights\n    col *= .7+cos(t)*.3; // shadows\n\n    col *= 1.0 - .6 * exp2(-1.75 * vignette(uv)); // vignette\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 424], [426, 426, 450, 450, 506], [509, 509, 566, 566, 898]], "test": "untested"}
{"id": "NdfyRH", "name": "German Flag animated", "author": "Krischan", "description": "The animation from https://www.shadertoy.com/view/flsXRM combined with the colors of the german flag", "tags": ["animated", "flags", "golf", "germany"], "likes": 4, "viewed": 236, "published": 3, "date": "1641660437", "time_retrieved": "2024-07-30T17:11:10.245372", "image_code": "#define RED vec3(193.0,18.0,28.0) / 255.\n#define BLACK vec3(1., 1., 1.) / 255.\n#define GOLD vec3(238., 201., 0.) / 255.\n\nvec3 Flag(vec2 U)\n{\n    vec3 col=mix(RED,BLACK,smoothstep(0.663,0.666,U.y));\n    return mix(GOLD,col,smoothstep(0.330,0.333,U.y));\n}\n\nfloat vignette(vec2 U)\n{\n    return 16. * U.x * (1. - U.x) * U.y * (1. - U.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*7.-6.*iTime+uv.y*6.;\n    uv.y += sin(t)*.0125;\n    \n    vec3 col = Flag(uv);\n\n    col += sin(t)*0.25; // highlights\n    col *= .7+cos(t)*.3; // shadows\n\n    col *= 1.0 - .6 * exp2(-1.75 * vignette(uv)); // vignette\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 140, 140, 253], [255, 255, 279, 279, 335], [338, 338, 395, 395, 708]], "test": "untested"}
{"id": "fdfyRH", "name": "Infinite Stair2", "author": "yasuo", "description": "Experimented the following stair distance function.\nhttps://www.shadertoy.com/view/ftVSDd", "tags": ["stair"], "likes": 16, "viewed": 301, "published": 3, "date": "1641660215", "time_retrieved": "2024-07-30T17:11:11.082135", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .0001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ZERO (min(iFrame,0))\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// https://www.shadertoy.com/view/ftVSDd\nfloat sdSquareStairs( in vec2 p, in float s, in float n )\n{\n    // constant for a given shape\n    const float kS2 = sqrt(2.0);\n    float w = 2.0*n+1.0;\n    \n    // pixel dependent computations\n    p = vec2( abs(p.y+p.x), p.y-p.x ) * (0.5/s);\n\n    float x1 = p.x-w;\n    float x2 = abs(p.x-2.0*min(round(p.x/2.0),n))-1.0;\n    \n    float d1 = dot2( vec2(x1, p.y) + clamp(0.5*(-x1-p.y), 0.0, w  ) );\n    float d2 = dot2( vec2(x2,-p.y) + clamp(0.5*(-x2+p.y), 0.0, 1.0) );\n\n    return sqrt(min(d1,d2)) *\n           sign(max(x1-p.y,(x2+p.y)*kS2)) *\n           s*kS2;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP2 = p;\n    p.xz*=0.9;\n    float mask = length(p.xz-vec2(0.,-0.5))-1.39;\n\n    p.y+=iTime*0.8;\n    p.x = abs(p.x)-0.9;\n    \n    vec3 prevP = p;\n    \n    p.y = mod(p.y,1.6)-0.8;\n    float stepNum = 2.0;\n    float s = 0.1;\n    float d = sdSquareStairs(p.xy,s,stepNum);\n    d = max((abs(p.z)-0.5),d);\n    \n    float d2 = sdSquareStairs(p.xy-vec2(0.1,-0.1),s,stepNum);\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.x*=-1.0;\n    p.x+=0.1;\n    p.y+=0.7;\n    p.z+=0.8;\n    p.y = mod(p.y,1.6)-0.8;\n    \n    d2 = sdSquareStairs(p.xy-vec2(0.1,-0.1),s,stepNum);\n    d2 = max((abs(p.z)-0.5),d2);\n    \n    float d3 = sdSquareStairs(p.xy-vec2(0.2,-0.2),s,stepNum);\n    d2 = max(-d3,d2);\n    \n    d = min(d,d2);\n    d = max(mask,d);\n    \n    p = prevP2;\n    \n    p.y+=2.0;\n    p.y+=iTime*0.8;\n    p.y = mod(p.y,1.6)-0.8;\n    p.z+=0.445;\n    d2 = B3D(p,vec3(0.65,0.1,1.00));\n    d = min(d,d2);\n    d = max(mask,d);\n    vec2 model = vec2(d,0.0);\n    \n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    //float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.); // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    return diffuseMaterial(n,rd,p,vec3(0.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    float t = iTime;\n\n    vec3 ro = vec3(0, 0.0, 2.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0.0), 0.5);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = mix(vec3(0.0),vec3(0.2,0.1,0.3),uv.y);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 257, 257, 311], [313, 313, 338, 338, 357], [359, 400, 459, 493, 961], [963, 963, 985, 985, 1951], [1953, 1953, 2011, 2011, 2278], [2280, 2280, 2304, 2304, 2505], [2507, 2507, 2549, 2549, 2744], [2746, 2787, 2836, 2836, 3130], [3132, 3132, 3189, 3189, 3799], [3801, 3801, 3860, 3860, 3908], [3910, 3910, 3967, 3967, 4814]], "test": "untested"}
{"id": "NdXcR8", "name": "Hidden Fractures", "author": "Tater", "description": "I started trying to make something that looks like a black opal diffraction, but this ended up being cooler. I still want to go back to the black opal idea eventually. ", "tags": ["3d", "raymarching", "refraction", "dispersion", "crystal"], "likes": 33, "viewed": 902, "published": 3, "date": "1641650757", "time_retrieved": "2024-07-30T17:11:11.941836", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MDIST 10.0\n#define STEPS 128.0\n#define FRAMEMIX 0.85\n//if you have a good PC you can increase this\n#define RAYS 4.0\n#define BOUNCES 8.0\n#define fs(i) (fract(sin((i)*114.514)*1919.810)) //from 0b5vr\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define flip(a) sign(mod(a,2.0)-0.5)\nfloat sc = 0.5;\n\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n//based on ideas from \n//https://www.shadertoy.com/view/fsVSzw\n//https://www.shadertoy.com/view/MscSDB\n//https://www.shadertoy.com/view/3ddGzn\n#define h13(n) fract((n)*vec3(12.9898,78.233,45.6114)*43758.5453123)\nvec2 vor(vec2 v, vec3 p, vec3 s){\n    p = abs(fract(p-s)-0.5);\n    float a = max(p.x,max(p.y,p.z));\n    float b = min(v.x,a);\n    float c = max(v.x,min(v.y,a));\n    return vec2(b,c);\n}\nfloat vorMap(vec3 p){\n    vec2 v = vec2(5.0);\n    v = vor(v,p,h13(0.96));\n    p.xy*=rot(1.2);\n    v = vor(v,p,h13(0.55));\n    p.yz*=rot(2.);\n    v = vor(v,p,h13(0.718));\n    return v.y-v.x; \n}\n\nvec2 map(vec3 p) {   \n    p.xz*=rot(iTime*0.1);\n    float a = length(p*vec3(1,1.0,1))-1.0;\n    float b = a;\n    b = max(-(b-0.)-(vorMap((p+iTime*0.01)*1.3)+0.1)*0.8,b);\n    vec2 c = vec2(b,1.0);\n    //vec2 d = vec2(a+0.8,2.0);\n    //c = (c.x<d.x)?c:d;\n    //c.x = max(p.z,c.x);\n    \n    return vec2(c.x*sc,c.y);\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd){\n    float s = sign(map(ro).x);\n    float rl = 0.;\n    vec3 p = ro;\n    vec2 d = vec2(0);\n    for(float i =0.; i<STEPS; i++){\n        p = ro+rd*rl;\n        d = map(p);\n        if(s*(d.x)<0.001){break;}\n        if(rl>MDIST){d.y=0.;break;}\n        rl+=d.x*s;\n    }\n    return vec3(rl,d.x,d.y);\n}\n\nvec3 norm(vec3 p, float d){\n    vec2 e = vec2(0.006,0);\n    return normalize( map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\n//idk just a bunch of garbage to make a light cubemap\n//partially based on blackle's fake ibl thing\nfloat lbox(vec3 rd, float size,float scl) {  \n    //return texture(iChannel0,rd).rgb;\n    float a = 0.;\n    vec3 n2 = rd;\n    rd *=scl;\n    rd = pmod(rd,vec3(1.5));\n    vec3 d= abs(rd);\n    a = 1.0-max(d.x,max(d.y,d.z))-size;\n    a*=max(n2.z*n2.y,0.);\n    //a*=max(sign(rd.y),0.);\n    a = clamp(a,0.,1.);\n    a = smoothstep(0.,0.3,a);\n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 rand =(vec2(fs(iTime),fs(iTime*0.3))-0.5)*0.5;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.,4,-4.5);\n   // ro.xz*=rot(-1.6);\n    bool click = iMouse.z>0.;\n    if(click){\n    ro.yz*=rot(1.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    \n    vec3 lk = vec3(0,0.0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(2.6)+uv.x*r+uv.y*cross(f,r));\n    vec3 rdo = rd;\n    vec3 roo = ro;\n    vec3 p = ro;\n    \n    //All rays will share the same initial raymarch so it stays outside the loop\n    sc = 0.9;\n    vec3 d = march(ro,rd);\n    p = ro+rd*d.x;\n    vec3 po = p;\n    vec3 n = norm(p,d.y);\n\n    if(d.z==0.||dot(rd,n)>0.0){\n        col = mix(vec3(0.208,0.200,0.302),vec3(0.0),length(uv));\n        fragColor = vec4(col,1.0);\n        return;\n    }\n\n    sc = 0.5;\n    \n    //Dispersion loop is inspired by tdhooper's method\n   // float rays = RAYS;\n   // if(iFrame == 0)rays+=20.0;\n    \n    //Dispersion loop\n    for(float i = 0.; i < RAYS; i++){\n        float wl = (i)/RAYS; \n        wl+=(h21(fragCoord+mod(iTime,60.0)))/RAYS;\n        float ior = 1.2+wl*0.6;\n        vec3 waveCol = pow(abs(hsv(vec3(wl*0.65+fs(floor(iTime*0.2+10.0)*0.2232),1.,1.8))),vec3(1.7));\n        bool skip = false;\n        //Bounce Loop\n        for(float j = 0.; j < BOUNCES; j++){\n            n = norm(p,d.y)*-flip(j);\n            ro = p-n*0.02;\n            vec3 flec = reflect(rd,n);\n            ior = 1.0/ior;\n            vec3 frac = refract(rd,n,ior);\n                              rd = frac;\n            if(frac==vec3(0)) rd = flec;\n            vec3 re = reflect(rd,n);\n            float fres = pow(max((1.-abs(dot(rd, n))), 0.), 5.);\n            col+=pow(smoothstep(0.1,0.2,lbox(re,0.5,1.4)),2.5)*\n            mix(waveCol,vec3(1),0.8)*pow((BOUNCES-j)/BOUNCES,2.0)*0.1;\n            col+=fres*0.3*waveCol;\n            d = march(ro,rd);\n            if(d.z<.5){\n                if(j<.5)skip = true;\n                break;\n            }\n            p = ro+rd*d.x;\n        }\n        if(skip)break;\n        col +=lbox(rd,0.5,1.0)*mix(waveCol,vec3(1),0.3);\n        ro = roo; rd = rdo; p = po;\n    }\n    col*=6./RAYS;\n    col = pow(col,vec3(0.95));\n   // col = smoothstep(0.,1.,col);\n    if(isnan(col.x)); //idk why this is nessecary \n\n    col = clamp(col,(0.),(1.));\n    vec3 buf = texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    float fm = FRAMEMIX*clamp(iTime*60.0,0.0,1.0);\n    if(iMouse.z<0.5)col = mix(col,buf,fm*clamp(0.016/iTimeDelta,0.,1.));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 119]], "test": "untested"}
{"id": "NlKXWt", "name": "Extruded Mobius Spiral", "author": "Shane", "description": "An extruded double Mobius spiral.", "tags": ["raymarch", "spiral", "atan", "mobius", "complex", "complex", "extrude"], "likes": 72, "viewed": 2011, "published": 3, "date": "1641647915", "time_retrieved": "2024-07-30T17:11:12.979063", "image_code": "/*\n\n    Extruded Mobius Spiral\n    ----------------------\n    \n    As you can see, this is an extruded Mobius spiral pattern. It's an \n    extension of MLA's nicely written \"Complex Atanh\" example. If you're \n    interested in complex transformations, Mobius spirals etc, that \n    particular example is the one I'd recommend looking at.\n    \n    Technically, there's not a lot to this: Perform the required 2D\n    transformations then pass the results into an extrusion algorithm.\n    The code looks more complicated than it has to be due to the decision \n    on my part to both extrude the cells and cater for three different \n    pylon shapes -- It seemed like a good idea at the time. :)\n    \n    A double spiral is a simple addition to the regular Mobius spiral \n    combination that most people use, but I couldn't for the life of me \n    remember how to produce one, so was pretty happy to see how to do \n    that in MLA's original. \n    \n    I wasn't really sure whether this would work or not, since I figured \n    mutating space so much prior to raymarching would make the surface \n    very difficult to home in on, but relatively speaking, things came\n    together surprisingly well, and I can thank MLA's attention to \n    function order, scaling, etc. Even so, the hackory police and the \n    Lipschitz Surface Constraint Commission probably won't be happy with \n    this example at all. :D\n    \n    Anyway, there are a few define options below: SHAPE, ROW_OFFSET, etc.\n    When using the one spiral option, the surface kind of has the feel of \n    a traced out Doyle spiral, but I'd like to produce the real thing at \n    some stage. \n\n\n\tBased on the following:\n    \n\t// The original and cleaner looking 2D version.\n    Complex Atanh - mla\n\thttps://www.shadertoy.com/view/tsBXRW \n    \n    // Another one of those shaders that somehow slipped under\n    // radar. Some of the visuals are strikingly beautiful.\n    Complex Atanh Revisited - mla\n    https://www.shadertoy.com/view/fldGRB\n\n*/\n\n\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Pylon cross section shape.\n// Square: 0, Circle: 1, Hexagon: 2.\n#define SHAPE 2\n\n// Colorful face decorations.\n#define FACE_DECO\n\n// Double spiral. The single version is cleaner, but not as interesting. \n// Thanks to Mla for this addition.\n#define DOUBLE_SPIRAL\n\n// Boring out holes in the blocks.\n//#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n//#define RIDGES\n\n// Originally for debug purposes, but it's decorative in its own way\n//#define VERT_LINES\n\n\n// The hexagons must use offset rows.\n#if SHAPE == 2\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n#ifdef ROW_OFFSET\n#if SHAPE >= 1\nconst vec2 rDim = vec2(1, 2.*.8660254);\n#else\nconst vec2 rDim = vec2(1, 2);\n#endif\n#else\nconst vec2 rDim = vec2(1, 2);\n#endif\n\n// Global tile scale.\nvec2 scale = vec2(1./8.);\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nfloat hash21(vec2 p){ \n    \n    /*\n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.333);\n    return fract((p3.x + p3.y)*p3.z);\n    */\n    \n    //p = mod(p, (vec2(B, A)*K));\n    \n    // IQ's vec2 to float hash.\n    //p = floor(p*32768.)/32768.;\n    return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); \n    \n}\n\n/*\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n#if SHAPE == 2\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n      // Flat top.\n      //const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      // Pointed top.\n      const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      // Flat top.\n      //return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      // Pointed top.\n      return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n    \n}\n#endif\n\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n     return (sin(6.2831*(p.y*2. + p.x) + iTime*2.)*.5 + .5); \n    \n    // Regular random values.\n    // This won't work for the sqrt(3.) scaling, but there are\n    // ways around it. It's not used in this example anyway.\n    //float h = hash21(p);\n    //return (sin(6.2831*h + iTime*2.)*.5 + .5);\n    \n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n\n// Global local 2D grid coordinates. Hacked in.\nvec2 gP; \n// A global responsible for tempering the height of the pylong near\n// the pylon center.\nfloat tempR;\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #if SHAPE == 2 // Hexagon.\n    vec2 hSc = vec2(1);//vec2(1, scale.y/scale.x*2./1.732);\n    #elif SHAPE == 1 // Circle with an offset.\n    #ifdef ROW_OFFSET\n    vec2 hSc = vec2(1);//vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    #endif\n    \n    \n    \n    float minSc = min(scale.x, scale.y);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]); // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + .5 + ps4[i])*s;\n        \n        p -= idi; // New local position.\n        \n \n        // The extruded block height. See the height map function, above.\n        // An extra line is needed for this example.\n        vec2 index = mod(idi, rDim.yx)/rDim.yx; \n        \n        // We also have an additional height tempering value for \n        // the spiral centers.\n        float h = hm(index)*tempR*.1;\n            \n         \n        #if SHAPE == 2\n        // Hexagon option: Multiply scale by \"vec2(1, 1.732/2.)\".\n        float di2D = sHexS(p, minSc/1.732 - .0035, .015);\n        #elif SHAPE == 1\n        // Circle.\n        #ifdef ROW_OFFSET\n        float di2D = length(p) - minSc/1.732 + .0035;\n        #else\n        float di2D = length(p) - l.x/2. + .0035;\n        #endif\n        #else\n        // Square.\n        float di2D = sBoxS(p, l/2. - .0035, .02);\n        #endif\n        \n        \n        \n        #ifdef HOLES\n        // Boring out the objects.\n        di2D = max(di2D, -(di2D + minSc/3.));\n        #endif\n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h - 1.), h + 1.);\n        \n         \n        \n        // Lego.\n        //float cap = opExtrusion(di2D + .0465, (q3.z + h - 1. + .035), h + 1.);\n        //di = min(di, cap);\n        \n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.5*tempR;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += smoothstep(-.5, .5, sin(di2D/minSc*6.2831*3.))*.01;\n        #endif\n        \n         \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;         \n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n            \n            gP = p;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n//////\n\n// Mla's complex functions: Most people have a copy of these lying\n// around. They're pretty easy to derive.\n//\nvec2 cMul(vec2 z, vec2 w){ return mat2(z, -z.y, z.x)*w; }\n\nvec2 cInv(vec2 z){ return vec2(z.x, -z.y)/dot(z, z); }\n\nvec2 cDiv(vec2 z, vec2 w){ return cMul(z, cInv(w)); }\n\nvec2 cLog(vec2 z){ return vec2(log(length(z)), atan(z.y, z.x)); }\n\n// Inverse hyperbolic tangent: The pattern looks loxodromic. I'm not \n// technically sure what you're supposed to call this particular \n// combination, but there's complex division and polar stuff, so it's\n// not surprising that it looks like a Mobius spiral combination. \nvec2 caTanh(vec2 z, float sc) {\n \n    // You could take the functions above and start grouping things if you \n    // wanted more compactness, and possibly speed, but I'm leaving it as is.\n    return cLog(cDiv(vec2(sc, 0) + z, vec2(sc, 0) - z));\n}\n\n//////\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n \n \n// The scene's distance function.\nfloat map(vec3 p){\n    \n   \n    // Back plane.\n    float fl = -p.z + .01;\n    \n    //////////////\n    // Complex transformations.\n\n    // Performing some complex operations on \"p.xy\" to make some cool looking\n    // Mobius spirals. Complex, as in the complex plane; The operations are\n    // actually quite simple. :)\n   \n    // Rotation about the XY plane. Equivalent to a 2D complex multiplication operation.\n    vec2 z = rot2(-sin(iTime/3.)*.65)*p.xy; // Same as: cmul(vec2(cos(a), sin(a))*c, z2);\n    // Tempering the extrusion height toward the spiral origins to lessen Moire effects\n    // and general artifacts.\n    const float sc = 1.5; // Effects spiral distance.\n    float r = min(length(z - vec2(sc, 0)), length(z - vec2(-sc, 0)));\n    tempR = r;\n    z = caTanh(-z, sc)/6.2831;\n \n    \n    #ifdef DOUBLE_SPIRAL\n    vec2 z2 = rot2(-cos(iTime/3.)*.65*2.)*p.xy;    \n    // Performing another inverse hyperbolic tangent operation. It's very simple\n    // to do, once someone shows you the answer. :)\n    const float sc2 = .75;\n    float r2 = min(length(z2.xy - vec2(sc2, 0)), length(z2.xy - vec2(-sc2, 0)));\n    tempR = min(tempR, r2);\n    z += caTanh(z2, sc2)/6.2831;\n    #endif \n    \n    // Tempering the height of the pylons eminating from the spiral centers.\n    // It looks way too messy if you don't do this.\n    tempR = smoothstep(.1, .5, tempR);\n\n    // More movement. Not necessary, but it looks more interesting.\n    z.y = fract(z.y + iTime*.1);\n    // More scaling.\n    z = cMul(rDim, z);\n    \n    // I like this addition, but I think it dizzies things too much.\n    //z.y -= iTime/6.;\n \n    // Set the XY plane coordinates to the new transformed ones.\n    p.xy = z;\n    \n    //////////////\n  \n \n    // Extrude.\n    vec4 d4 = blocks(p);\n    gID = d4; // Save the distance, cell ID, and 2D face distance.\n   \n    \n    // Object ID.\n    objID = d4.x < fl? 0. : 1.;\n    \n    // Minimum distance for the scene.\n    return min(d4.x, fl);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines. This one is pretty standard.\n// I'm assuming this one based on IQ's original.\nfloat calcAO(vec3 p, vec3 n){\n    \n    float occ = 1.; // Occlusion.\n    float ds = .01; // Analogous to sample spread. // .01*t           \n    float k = .05/ds;  // Intensity.\n    float dst = ds*2.; // Initial distance.          \n    \n    for(int i = 0; i<5; i++){\n        occ -= (dst - map(p + n*dst))*k;\n        dst += ds;\n        k *= .5;\n    }\n    \n    return clamp(occ, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef ROW_OFFSET\n    #if SHAPE >= 1\n    scale *= vec2(2./1.732, 1);\n    #endif\n    #endif\n    \n\t// Camera Setup.\n    // Slightly tilted camera, just to prove it's 3D. :)\n    vec3 ro = vec3(0, -1, -2.2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .1, .25); // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.5, 1, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    // Object ID.\n    float svObjID = objID;\n    \n    // Height tempering for the spiral centers.\n    float svTempR = tempR;\n    \n    // Pylon face local coordinates.\n    vec2 svP = gP;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6);   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Wrapping the colors properly.\n            vec2 index = mod(svGID.yz, rDim.yx)/rDim.yx; \n            //index = floor(index*8.)/8. + 1./16.;\n            \n\n            // Using the color index to produce two different colors.\n            vec3 col1 = .5 + .45*cos(6.2831*index.y + vec3(0, 1, 2)*2.);\n            vec3 col2 = .5 + .45*cos(6.2831*index.y + 3.14159/2.5 + vec3(0, 1, 2)*1.35);\n\n            texCol = col1;\n\n            // Debug coloring.\n            //texCol = mod(floor(index.x*16.), 2.)<.5? vec3(.05) :  texCol;\n            //texCol = mod(floor(index.y*8.), 2.)<.5?  vec3(.05) : vec3(.9);\n            //texCol = vec3(.05);\n             \n            \n            // The dark lines, etc, need to look crisp, so we need a derivative\n            // based smoothing factor. This can either be done the easy way via\n            // hardware, or the harder but more maliable and reliable way. The\n            // hardware version is below for a comparison.\n            #if 1\n            float di2D = svGID.w;\n            float tmp = map(sp - vec3(3./450., 0, 0)); // Nearby X sample.\n            float di2DX = gID.w; // dX.\n            tmp = map(sp - vec3(0, 3./450., 0)); // Nearby Y sample.\n            float di2DY = gID.w; // dY.\n            //tmp = map(sp - vec3(0, 0, 3./450.)); \n            //float di2DZ = gID.w;//\n            \n            vec3 dF = (vec3(di2DX, di2DY, 1e5) - di2D); // Rought partial differential.\n            // Technically not fwidth, but I prefer it.\n            float sf = length(dF.xy); // Fwidth: abs(dF.x) + abs(dF.y);\n            #else\n            // The one line hardware version. Much cheaper, but not always reliable.\n            float sf = fwidth(svGID.w);\n            #endif\n            \n            \n            #ifdef VERT_LINES\n            // Lines eminating from the center to the vertices.\n            #if SHAPE == 2\n            const float aNum = 6.;\n            vec2 z = rot2(3.14159/aNum)*svP; \n            //float ch = smoothstep(-sf, sf, (abs(fract(a*6. - .5) - .5) - .45)/6.);\n            #else\n            const float aNum = 4.;\n            vec2 z = svP; \n            #endif\n            float a = mod(atan(z.x, z.y), 6.2831)/6.2831;\n            a = (floor(a*aNum) + .5)/aNum;\n            z *= rot2(a*6.2831);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(z.x) - .001))*.95);     \n            #endif\n            \n            \n            #ifdef FACE_DECO\n            float rim = .04;\n            #ifdef ROW_OFFSET\n            #if SHAPE >= 1\n            rim /= .8660254;\n            #endif\n            #endif\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, svGID.w + rim))*.95);\n            texCol = mix(texCol, col2, (1. - smoothstep(0., sf, svGID.w + rim + .005)));\n            #endif\n \n \n            // Dark edges.\n            float h = hm(index); // Pylon height.\n            float lw = .0035;\n            float dS = abs(svGID.w) - lw/2.; // 2D face field value.\n            texCol = mix(texCol, texCol/3., (1. - smoothstep(0., sf, dS)));\n            dS = max(dS, abs(sp.z + h*.1*svTempR*2.) - lw/2.); // Just the rim.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, dS))*.95);\n             \n \n        }\n        else {\n            \n            // The dark floor in the background.\n            texCol = vec3(.05);\n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3217, 3250, 3272, 3272, 3330], [3333, 3333, 3354, 3774, 3846], [4198, 4225, 4282, 4282, 4580], [5337, 5358, 5378, 5378, 5684], [5686, 5714, 5761, 5761, 5851], [9431, 9543, 9569, 9569, 9600], [9602, 9602, 9620, 9620, 9656], [9658, 9658, 9684, 9684, 9711], [9713, 9713, 9731, 9731, 9778], [9780, 10053, 10084, 10240, 10299], [10389, 10423, 10441, 10469, 12379], [12381, 12402, 12438, 12487, 12926], [12929, 13029, 13065, 13407, 13679], [13682, 13873, 13925, 14006, 15273], [15276, 15400, 15429, 15429, 15786], [15789, 15789, 15845, 15878, 22937]], "test": "untested"}
{"id": "ftVXDt", "name": "Evo32 SMNCA Cycles", "author": "davidar", "description": "A rewrite of \"Evo32 SMNCA\" by Slackermanz: simplified simulation code in Common, two simulation updates per frame for less flickering, params stored in texture for better perf with large number of variations, cycling through 50 paramsets.\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 9, "viewed": 377, "published": 3, "date": "1641613560", "time_retrieved": "2024-07-30T17:11:14.126993", "image_code": "// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = texture(iChannel0, fragCoord/iResolution.xy).x;\n    fragColor.rgb = pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    fragColor = mix(fragColor, vec4(x), .3);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 5.;\n    float res = smnca(fragCoord, iChannel0, iChannel1, iResolution.xy, t);\n    vec2 m = 0.5 * iResolution.xy * vec2(noise(vec2(t,0)) + 1., noise(vec2(0,t)) + 1.);\n    if (iMouse.z > 0.) m = iMouse.xy;\n    if (length(m - fragCoord) < 32.) res = 0.;\n    if (iFrame < 2) res = noise(10.*fragCoord/iResolution.xy);\n    fragColor = vec4(clamp(res,0.,1.));\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NUM_PATTERNS 50\n\n//#define PATTERN(p,i) patterns[(32*int(p)+(i)) % patterns.length()]\n#define PATTERN(p,i) texelFetch(pat, ivec2(int(p) % NUM_PATTERNS, i), 0).x\n\nfloat smnca(vec2 fragCoord, sampler2D ch, sampler2D pat, vec2 R, float t)\n{\n\tfloat res = texture(ch, fragCoord/R).x;\n\n    const vec2 ring[8] = vec2[](vec2(1,0), vec2(3,0), vec2(2,0), vec2(5,3), vec2(5,2), vec2(9,7), vec2(4,2), vec2(12,9));\n\tconst float dt = .05;\n\n    // neighbourhood averages\n    float[8] nhdt;\n    float[8] tots;\n    for(int r = 0; r < 8; r++) nhdt[r] = tots[r] = 0.;\n    for(float i = -12.; i <= 12.; i++) {\n        for(float j = -12.; j <= 12.; j++) {\n            vec2 ij = vec2(i,j);\n            if (ij == vec2(0)) continue;\n            for(int r = 0; r < 8; r++) {\n                if(ring[r].y + .5 < length(ij) && length(ij) <= ring[r].x + .5) {\n                    tots[r]++;\n                    nhdt[r] += texture(ch, (fragCoord + ij)/R).x;\n                }\n            }\n        }\n    }\n    for(int r = 0; r < 8; r++) nhdt[r] /= tots[r];\n\n    // update rules\n    float a = smoothstep(.3, .7, fract(t));\n    vec4 rslt = vec4(res);\n    for(int i = 0; i < 16; i++) {\n        float lo = mix(PATTERN(t,2*i),   PATTERN(t+1.,2*i),   a);\n        float hi = mix(PATTERN(t,2*i+1), PATTERN(t+1.,2*i+1), a);\n        if(lo <= nhdt[i/2] && nhdt[i/2] <= hi)\n            rslt[i/4] += dt * (i%2==0 ? 1. : -1.);\n    }\n\n    // smoothing\n    for(int i = 0; i < 4; i++) rslt[i] += dt * (nhdt[2*i] + nhdt[2*i+1])/2.;\n    rslt /= 1. + dt;\n\n    // selection stage\n\tfloat res0 = res;\n\tfor(int i = 0; i < 4; i++)\n        if(abs(res0 - res) < abs(res0 - rslt[i]))\n            res = rslt[i];\n\n    return res;\n}\n\n\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 5.;\n    float res = smnca(fragCoord, iChannel0, iChannel1, iResolution.xy, t);\n    vec2 m = 0.5 * iResolution.xy * vec2(noise(vec2(t,0)) + 1., noise(vec2(0,t)) + 1.);\n    if (iMouse.z > 0.) m = iMouse.xy;\n    if (length(m - fragCoord) < 32.) res = 1.;\n    if (iFrame < 2) res = noise(10.*fragCoord/iResolution.xy);\n    fragColor = vec4(clamp(res,0.,1.));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// store params in texture for faster lookup\n\nconst float patterns[NUM_PATTERNS*32] = float[](\n\t\t0.264,0.293,0.156,0.287,\n\t\t0.411,0.305,0.200,0.093,\n\t\t0.467,0.345,0.127,-0.016,\n\t\t-0.108,0.079,0.098,0.370,\n\t\t0.209,0.030,0.222,0.144,\n\t\t0.187,0.199,0.294,0.194,\n\t\t0.277,0.170,0.178,0.007,\n\t\t0.261,0.335,-0.093,0.138,\n\n\t\t0.352,0.236,0.313,0.197,\n\t\t0.140,0.443,0.252,0.394,\n\t\t0.450,0.567,0.233,0.387,\n\t\t0.273,0.489,0.190,0.374,\n\t\t0.215,0.241,0.264,0.387,\n\t\t0.308,0.373,0.263,0.499,\n\t\t0.225,0.252,0.168,0.344,\n\t\t0.179,0.324,0.391,0.327,\n\n\t\t0.534,-0.129,0.041,0.683,\n\t\t0.228,0.562,-0.097,0.340,\n\t\t-0.043,0.209,-0.136,0.746,\n\t\t0.663,0.222,0.768,0.299,\n\t\t0.354,0.449,0.172,0.263,\n\t\t0.074,0.760,-0.020,0.060,\n\t\t0.133,0.198,0.200,0.516,\n\t\t0.320,0.429,0.378,0.710,\n\n\t\t0.378,0.228,0.196,-0.046,\n\t\t0.156,-0.055,0.017,0.055,\n\t\t0.065,0.255,0.115,0.395,\n\t\t-0.041,0.029,0.000,0.125,\n\t\t0.352,0.346,0.178,0.305,\n\t\t0.020,0.237,0.397,0.311,\n\t\t0.215,0.048,0.344,-0.009,\n\t\t0.359,0.244,0.022,0.174,\n\n\t\t0.243,0.598,0.011,0.053,\n\t\t0.573,0.110,0.068,0.347,\n\t\t0.231,0.483,0.274,0.552,\n\t\t0.161,-0.034,0.071,0.658,\n\t\t0.329,0.581,-0.005,0.371,\n\t\t0.094,0.342,0.059,0.049,\n\t\t0.676,0.480,0.476,0.323,\n\t\t0.018,0.106,0.457,0.398,\n\n\t\t0.176,0.435,0.008,0.039,\n\t\t0.416,0.080,0.049,0.252,\n\t\t0.168,0.351,0.199,0.401,\n\t\t0.117,-0.025,0.052,0.479,\n\t\t0.239,0.422,-0.003,0.269,\n\t\t0.068,0.249,0.043,0.035,\n\t\t0.492,0.349,0.346,0.235,\n\t\t0.013,0.077,0.332,0.289,\n\n\t\t0.447,0.266,0.266,0.354,\n\t\t-0.081,0.336,0.138,0.400,\n\t\t0.442,0.418,0.083,0.489,\n\t\t0.070,0.159,0.394,0.492,\n\t\t0.348,0.528,0.282,0.390,\n\t\t-0.072,0.280,0.285,0.386,\n\t\t0.171,-0.053,0.331,0.389,\n\t\t0.211,0.523,-0.027,-0.092,\n\n\t\t0.423,0.574,0.466,0.145,\n\t\t0.465,0.326,0.234,0.551,\n\t\t0.294,0.210,-0.097,0.082,\n\t\t0.544,-0.073,0.038,0.601,\n\t\t0.178,0.616,0.590,0.558,\n\t\t0.299,0.460,0.256,0.275,\n\t\t0.566,-0.087,-0.083,0.367,\n\t\t0.071,-0.109,0.122,0.607,\n\n\t\t0.476,0.646,0.524,0.163,\n\t\t0.523,0.367,0.264,0.620,\n\t\t0.330,0.237,-0.110,0.093,\n\t\t0.612,-0.082,0.042,0.676,\n\t\t0.200,0.693,0.664,0.628,\n\t\t0.336,0.517,0.288,0.309,\n\t\t0.637,-0.098,-0.094,0.413,\n\t\t0.080,-0.123,0.138,0.683,\n\n\t\t0.264,-0.312,-0.028,-0.024,\n\t\t0.330,0.266,0.043,0.673,\n\t\t0.187,0.313,-0.027,-0.010,\n\t\t0.374,-0.197,-0.122,0.086,\n\t\t0.092,-0.078,0.252,-0.163,\n\t\t0.295,0.686,0.267,0.184,\n\t\t-0.019,0.717,0.205,-0.017,\n\t\t-0.137,0.088,0.372,0.244,\n\n\t\t-0.049,0.085,-0.060,0.154,\n\t\t0.270,0.526,0.447,-0.064,\n\t\t0.447,0.037,0.369,0.455,\n\t\t0.246,-0.026,-0.083,-0.099,\n\t\t0.094,-0.062,0.102,0.093,\n\t\t0.085,0.263,0.183,0.384,\n\t\t0.135,0.215,0.084,0.507,\n\t\t0.280,0.156,0.122,0.330,\n\n\t\t-0.257,0.448,-0.315,0.808,\n\t\t1.412,2.749,2.338,-0.335,\n\t\t2.335,0.193,1.928,2.379,\n\t\t1.286,-0.138,-0.437,-0.518,\n\t\t0.492,-0.325,0.533,0.485,\n\t\t0.445,1.374,0.957,2.009,\n\t\t0.709,1.127,0.441,2.650,\n\t\t1.463,0.814,0.638,1.727,\n\n\t\t0.424,0.018,0.070,0.266,\n\t\t0.015,0.339,0.224,0.275,\n\t\t0.044,0.442,0.472,0.503,\n\t\t0.273,0.349,0.003,-0.083,\n\t\t0.100,0.077,-0.015,0.459,\n\t\t0.312,0.062,0.238,0.490,\n\t\t0.108,0.017,0.418,0.141,\n\t\t0.477,0.337,0.225,0.352,\n\n\t\t0.928,0.041,0.155,0.583,\n\t\t0.032,0.742,0.490,0.603,\n\t\t0.096,0.968,1.032,1.100,\n\t\t0.597,0.763,0.007,-0.183,\n\t\t0.220,0.169,-0.033,1.005,\n\t\t0.684,0.136,0.520,1.072,\n\t\t0.236,0.038,0.914,0.310,\n\t\t1.045,0.738,0.493,0.770,\n\n\t\t0.014,0.284,0.106,-0.075,\n\t\t0.366,0.497,0.018,0.362,\n\t\t0.018,0.267,0.072,0.520,\n\t\t0.034,-0.055,0.232,0.506,\n\t\t0.091,0.462,0.542,0.446,\n\t\t0.052,-0.049,0.228,-0.031,\n\t\t0.270,0.264,0.448,0.327,\n\t\t0.356,0.545,-0.032,0.269,\n\n\t\t-0.072,0.327,0.131,-0.044,\n\t\t0.369,-0.066,0.462,-0.013,\n\t\t0.092,0.282,0.276,0.490,\n\t\t0.221,0.175,0.388,0.520,\n\t\t0.432,0.187,-0.072,0.522,\n\t\t0.157,0.116,0.408,-0.004,\n\t\t0.211,0.547,0.145,0.080,\n\t\t0.208,0.336,0.446,0.236,\n\n\t\t-0.088,0.247,0.032,0.019,\n\t\t0.323,-0.035,0.403,-0.011,\n\t\t0.114,0.246,0.097,0.371,\n\t\t0.106,0.153,0.279,0.513,\n\t\t0.378,0.136,-0.063,0.457,\n\t\t0.137,-0.037,0.326,-0.010,\n\t\t0.251,0.493,0.182,0.091,\n\t\t0.265,0.310,0.375,0.161,\n\n\t\t-0.127,0.353,0.046,0.027,\n\t\t0.462,-0.050,0.577,-0.016,\n\t\t0.163,0.352,0.139,0.531,\n\t\t0.152,0.219,0.399,0.733,\n\t\t0.540,0.195,-0.090,0.653,\n\t\t0.196,-0.052,0.465,-0.014,\n\t\t0.359,0.704,0.260,0.131,\n\t\t0.378,0.443,0.536,0.230,\n\n\t\t0.065,0.065,0.035,0.138,\n\t\t0.119,0.062,0.063,0.045,\n\t\t-0.040,0.078,0.050,0.101,\n\t\t0.118,0.135,0.054,0.024,\n\t\t-0.003,0.065,0.180,0.022,\n\t\t0.082,0.064,0.020,-0.002,\n\t\t0.007,0.057,0.,0.118,\n\t\t0.147,0.145,0.102,0.059,\n\n\t\t-0.010,0.448,0.244,0.624,\n\t\t0.538,0.283,0.284,0.206,\n\t\t-0.014,0.353,0.228,0.509,\n\t\t0.531,0.610,0.244,0.108,\n\t\t0.250,0.292,0.810,-0.045,\n\t\t0.372,0.436,0.091,-0.013,\n\t\t0.032,0.104,-0.003,0.535,\n\t\t0.664,0.760,0.459,0.269,\n\n\t\t-0.032,0.048,-0.049,0.319,\n\t\t-0.058,-0.045,-0.027,0.232,\n\t\t0.225,-0.042,0.073,0.241,\n\t\t0.255,0.149,0.271,0.073,\n\t\t0.057,-0.051,0.154,0.027,\n\t\t0.068,0.093,0.056,0.203,\n\t\t0.217,0.322,0.288,0.021,\n\t\t0.154,0.283,0.209,0.184,\n\n\t\t-0.045,0.068,-0.069,0.447,\n\t\t-0.082,-0.063,-0.039,0.324,\n\t\t0.316,-0.059,0.102,0.338,\n\t\t0.357,0.209,0.379,0.103,\n\t\t0.080,-0.072,0.216,0.038,\n\t\t0.096,0.131,0.078,0.285,\n\t\t0.304,0.451,0.403,0.030,\n\t\t0.216,0.397,0.292,0.258,\n\n\t\t-0.065,0.097,-0.098,0.638,\n\t\t-0.117,-0.090,-0.055,0.464,\n\t\t0.451,-0.084,0.146,0.483,\n\t\t0.511,0.299,0.542,0.147,\n\t\t0.115,-0.103,0.309,0.055,\n\t\t0.137,0.187,0.112,0.407,\n\t\t0.435,0.644,0.576,0.043,\n\t\t0.309,0.567,0.418,0.369,\n\n\t\t-0.078,0.117,-0.118,0.766,\n\t\t-0.141,-0.109,-0.067,0.556,\n\t\t0.542,-0.101,0.175,0.580,\n\t\t0.613,0.359,0.650,0.176,\n\t\t0.138,-0.123,0.371,0.066,\n\t\t0.164,0.225,0.134,0.488,\n\t\t0.522,0.773,0.691,0.052,\n\t\t0.371,0.680,0.502,0.443,\n\n\t\t-0.014,0.115,0.041,-0.009,\n\t\t-0.015,-0.068,0.192,0.180,\n\t\t0.293,0.355,0.394,0.186,\n\t\t0.122,0.306,0.350,0.116,\n\t\t0.169,0.123,0.224,0.326,\n\t\t0.311,0.216,0.158,0.008,\n\t\t0.038,-0.059,0.109,0.299,\n\t\t0.355,0.284,0.108,0.265,\n\n\t\t-0.018,0.154,0.054,-0.012,\n\t\t-0.110,-0.164,0.306,0.240,\n\t\t0.344,0.474,0.509,0.249,\n\t\t0.163,0.408,0.467,0.155,\n\t\t0.160,0.164,0.299,0.435,\n\t\t0.414,0.288,0.210,0.011,\n\t\t0.051,-0.079,0.146,0.399,\n\t\t0.473,0.379,0.145,0.353,\n\n\t\t0.056,-0.052,0.101,0.339,\n\t\t-0.059,0.013,0.214,0.094,\n\t\t0.097,0.192,0.161,-0.058,\n\t\t0.137,0.082,0.192,-0.054,\n\t\t-0.008,0.048,-0.033,0.292,\n\t\t-0.004,0.005,0.267,0.327,\n\t\t0.023,0.047,0.326,0.245,\n\t\t0.095,0.056,0.121,0.089,\n\n\t\t0.001,-0.079,0.101,0.339,\n\t\t-0.035,0.013,0.214,0.123,\n\t\t0.097,0.252,0.161,-0.058,\n\t\t0.137,0.082,0.202,-0.038,\n\t\t-0.008,0.048,-0.033,0.292,\n\t\t-0.004,0.002,0.267,0.327,\n\t\t0.023,0.064,0.312,0.245,\n\t\t0.046,0.058,0.121,0.089,\n\n\t\t0.003,-0.208,0.273,1.085,\n\t\t-0.114,0.041,0.665,0.360,\n\t\t0.329,0.875,0.517,-0.215,\n\t\t0.394,0.407,0.648,-0.123,\n\t\t-0.029,0.175,-0.176,0.934,\n\t\t-0.015,-0.081,0.954,0.957,\n\t\t0.075,0.204,1.,0.705,\n\t\t0.153,0.203,0.328,0.286,\n\n\t\t0.045,-0.260,0.151,1.357,\n\t\t-0.134,0.251,0.837,0.177,\n\t\t0.464,0.599,0.589,-0.307,\n\t\t0.390,0.485,0.743,-0.197,\n\t\t-0.069,0.255,-0.155,0.992,\n\t\t-0.019,-0.063,1.153,1.197,\n\t\t-0.064,0.350,1.152,0.843,\n\t\t0.128,0.042,0.342,0.347,\n\n\t\t0.210,0.215,0.434,0.380,\n\t\t0.643,0.497,0.035,0.358,\n\t\t0.345,0.039,0.409,0.304,\n\t\t0.005,0.250,-0.040,0.656,\n\t\t0.383,0.415,0.217,-0.010,\n\t\t0.017,-0.120,0.486,0.489,\n\t\t0.212,0.381,-0.070,0.022,\n\t\t0.272,0.542,0.665,0.607,\n\n\t\t0.184,0.188,0.379,0.332,\n\t\t0.563,0.435,0.030,0.313,\n\t\t0.302,0.034,0.358,0.266,\n\t\t0.005,0.219,-0.035,0.574,\n\t\t0.335,0.363,0.189,-0.009,\n\t\t0.015,-0.105,0.425,0.428,\n\t\t0.185,0.334,-0.061,0.019,\n\t\t0.238,0.475,0.582,0.531,\n\n\t\t0.131,0.134,0.271,0.237,\n\t\t0.402,0.310,0.021,0.224,\n\t\t0.215,0.024,0.256,0.190,\n\t\t0.003,0.156,-0.025,0.410,\n\t\t0.239,0.259,0.135,-0.006,\n\t\t0.010,-0.075,0.304,0.305,\n\t\t0.132,0.238,-0.044,0.013,\n\t\t0.170,0.339,0.415,0.379,\n\n\t\t-0.085,0.017,0.212,0.087,\n\t\t0.201,0.128,0.396,-0.080,\n\t\t0.016,0.085,-0.020,0.265,\n\t\t0.212,0.432,0.442,0.317,\n\t\t0.139,0.272,0.229,0.256,\n\t\t0.289,0.114,0.155,0.428,\n\t\t0.178,-0.007,0.277,0.318,\n\t\t0.172,0.245,0.241,0.174,\n\n\t\t-0.171,0.034,0.425,0.174,\n\t\t0.402,0.257,0.793,-0.161,\n\t\t0.033,0.171,-0.041,0.531,\n\t\t0.425,0.864,0.885,0.634,\n\t\t0.278,0.545,0.458,0.512,\n\t\t0.579,0.229,0.311,0.857,\n\t\t0.357,-0.014,0.554,0.637,\n\t\t0.345,0.491,0.482,0.349,\n\n\t\t0.550,0.573,0.272,0.728,\n\t\t0.018,0.756,0.462,0.183,\n\t\t0.135,0.566,0.461,0.329,\n\t\t0.211,0.399,0.689,0.569,\n\t\t0.071,0.292,-0.062,0.387,\n\t\t0.333,0.043,0.304,0.751,\n\t\t0.169,-0.017,0.495,0.579,\n\t\t0.228,0.735,0.715,0.023,\n\n\t\t0.388,-0.035,0.197,0.329,\n\t\t0.390,0.063,0.258,-0.079,\n\t\t0.104,0.250,0.516,0.325,\n\t\t0.360,0.543,0.211,0.536,\n\t\t0.277,0.157,0.386,0.098,\n\t\t0.244,0.321,0.154,0.308,\n\t\t0.033,0.386,0.412,0.163,\n\t\t-0.001,0.442,0.067,0.286,\n\n\t\t0.339,-0.030,0.172,0.288,\n\t\t0.341,0.055,0.226,-0.069,\n\t\t0.091,0.219,0.452,0.284,\n\t\t0.315,0.475,0.184,0.469,\n\t\t0.242,0.137,0.337,0.086,\n\t\t0.213,0.281,0.135,0.269,\n\t\t0.029,0.337,0.361,0.142,\n\t\t-0.001,0.387,0.059,0.250,\n\n\t\t0.698,0.501,0.089,0.200,\n\t\t0.726,0.306,0.228,0.732,\n\t\t-0.106,0.182,0.144,0.249,\n\t\t-0.104,0.573,0.229,0.136,\n\t\t0.649,0.621,0.411,-0.048,\n\t\t0.030,-0.133,0.513,-0.063,\n\t\t0.258,0.323,0.298,0.395,\n\t\t-0.101,0.529,0.648,0.733,\n\n\t\t-0.001,0.272,-0.045,0.265,\n\t\t0.067,0.121,0.254,0.082,\n\t\t0.140,-0.023,0.258,0.155,\n\t\t0.173,0.299,0.154,-0.001,\n\t\t0.111,-0.002,0.039,0.188,\n\t\t0.279,0.208,0.095,0.053,\n\t\t0.292,0.168,0.169,0.309,\n\t\t-0.061,0.120,0.172,0.,\n\n\t\t-0.002,0.435,-0.072,0.425,\n\t\t0.108,0.193,0.407,0.131,\n\t\t0.224,-0.038,0.412,0.249,\n\t\t0.277,0.479,0.247,-0.002,\n\t\t0.178,-0.004,0.062,0.301,\n\t\t0.447,0.334,0.153,0.085,\n\t\t0.468,0.269,0.271,0.494,\n\t\t-0.098,0.193,0.276,0.,\n\n\t\t0.125,0.015,0.034,0.048,\n\t\t0.156,0.243,0.134,0.226,\n\t\t0.181,-0.031,0.159,0.083,\n\t\t0.200,0.141,0.125,0.255,\n\t\t0.104,0.267,0.159,-0.041,\n\t\t0.210,0.156,0.097,0.238,\n\t\t0.114,0.208,0.266,0.016,\n\t\t0.181,0.020,0.009,0.256,\n\n\t\t0.188,0.023,0.052,0.073,\n\t\t0.234,0.364,0.201,0.339,\n\t\t0.271,-0.047,0.239,0.125,\n\t\t0.300,0.212,0.188,0.383,\n\t\t0.156,0.400,0.239,-0.061,\n\t\t0.315,0.234,0.145,0.357,\n\t\t0.171,0.312,0.400,0.025,\n\t\t0.272,0.030,0.013,0.385,\n\n\t\t0.047,0.126,0.096,0.150,\n\t\t-0.024,0.017,-0.030,0.089,\n\t\t0.166,0.079,0.126,-0.018,\n\t\t0.065,0.105,-0.001,0.157,\n\t\t0.058,0.111,0.023,0.058,\n\t\t0.164,0.062,0.020,0.165,\n\t\t0.139,0.124,0.145,-0.036,\n\t\t0.089,0.167,0.196,0.099,\n\n\t\t0.083,0.221,0.168,0.264,\n\t\t-0.043,0.029,-0.052,0.157,\n\t\t0.291,0.138,0.221,-0.032,\n\t\t0.115,0.184,-0.002,0.274,\n\t\t0.101,0.195,0.040,0.102,\n\t\t0.287,0.108,0.035,0.288,\n\t\t0.244,0.217,0.254,-0.063,\n\t\t0.157,0.292,0.344,0.174,\n\n\t\t0.179,0.474,0.360,0.565,\n\t\t-0.093,0.064,-0.113,0.336,\n\t\t0.625,0.296,0.474,-0.069,\n\t\t0.246,0.395,-0.005,0.588,\n\t\t0.217,0.417,0.086,0.219,\n\t\t0.616,0.233,0.076,0.618,\n\t\t0.522,0.466,0.545,-0.136,\n\t\t0.337,0.627,0.737,0.374,\n\n\t\t0.156,0.415,0.315,0.495,\n\t\t-0.081,0.056,-0.099,0.294,\n\t\t0.547,0.259,0.415,-0.060,\n\t\t0.216,0.346,-0.004,0.515,\n\t\t0.190,0.365,0.076,0.192,\n\t\t0.539,0.204,0.067,0.541,\n\t\t0.457,0.408,0.477,-0.119,\n\t\t0.295,0.548,0.645,0.328,\n\n\t\t0.531,1.077,1.925,0.804,\n\t\t1.214,-0.131,1.438,1.760,\n\t\t1.136,1.506,0.902,-0.289,\n\t\t1.180,1.989,0.924,0.658,\n\t\t0.487,-0.094,0.643,0.912,\n\t\t1.906,0.217,1.423,0.646,\n\t\t0.863,1.189,-0.092,0.363,\n\t\t0.858,0.541,0.358,1.009,\n\n\t\t0.665,0.634,-0.082,0.130,\n\t\t-0.097,0.269,0.029,0.154,\n\t\t0.645,0.455,-0.068,0.350,\n\t\t0.178,0.364,0.442,0.213,\n\t\t0.206,-0.030,0.642,0.154,\n\t\t0.166,0.178,0.243,0.328,\n\t\t0.447,0.337,0.574,0.046,\n\t\t0.643,0.006,0.256,0.368,\n\n\t\t1.064,1.075,-0.128,0.201,\n\t\t-0.150,0.417,0.045,0.238,\n\t\t0.844,0.704,-0.106,0.541,\n\t\t0.358,0.712,0.685,0.330,\n\t\t0.319,-0.189,0.994,0.238,\n\t\t0.378,0.275,0.375,0.462,\n\t\t0.692,0.521,0.888,0.071,\n\t\t0.995,0.010,0.396,0.570/*,\n\n\t\t1.064,1.008,-0.009,0.239,\n\t\t-0.059,0.488,0.115,0.347,\n\t\t0.862,0.909,-0.090,0.541,\n\t\t0.358,0.711,0.703,0.448,\n\t\t0.333,-0.179,0.994,0.238,\n\t\t0.378,0.275,0.375,0.453,\n\t\t0.694,0.521,0.888,-0.027,\n\t\t0.995,-0.192,0.432,0.570,\n\n\t\t0.111,0.348,0.149,0.214,\n\t\t0.245,0.143,0.071,0.306,\n\t\t0.207,0.073,0.162,0.097,\n\t\t0.377,0.002,0.046,0.261,\n\t\t0.032,-0.011,0.227,0.010,\n\t\t0.175,0.046,0.125,0.228,\n\t\t0.362,0.135,0.168,0.164,\n\t\t0.385,0.369,0.269,-0.066,\n\n\t\t0.148,0.464,0.199,0.286,\n\t\t0.327,0.191,0.094,0.408,\n\t\t0.276,0.098,0.216,0.130,\n\t\t0.503,0.003,0.062,0.348,\n\t\t0.043,-0.014,0.303,0.014,\n\t\t0.233,0.062,0.167,0.304,\n\t\t0.483,0.180,0.224,0.219,\n\t\t0.514,0.492,0.358,-0.088,\n\n\t\t0.167,0.522,0.223,0.321,\n\t\t0.368,0.215,0.106,0.460,\n\t\t0.310,0.110,0.243,0.146,\n\t\t0.566,0.003,0.070,0.392,\n\t\t0.048,-0.016,0.341,0.016,\n\t\t0.262,0.070,0.188,0.343,\n\t\t0.544,0.203,0.252,0.246,\n\t\t0.578,0.553,0.403,-0.099,\n\n\t\t0.186,0.580,0.248,0.357,\n\t\t0.409,0.239,0.118,0.511,\n\t\t0.345,0.122,0.270,0.162,\n\t\t0.629,0.004,0.078,0.435,\n\t\t0.053,-0.018,0.379,0.017,\n\t\t0.291,0.078,0.209,0.381,\n\t\t0.604,0.226,0.280,0.273,\n\t\t0.642,0.615,0.448,-0.110,\n\n\t\t0.119,0.067,0.017,0.189,\n\t\t0.117,0.197,0.106,0.242,\n\t\t-0.017,0.278,0.102,0.061,\n\t\t0.169,0.038,0.075,0.139,\n\t\t-0.001,0.085,0.252,0.113,\n\t\t0.026,-0.010,0.,-0.013,\n\t\t0.132,0.009,0.151,0.290,\n\t\t0.070,0.300,-0.023,0.244,\n\n\t\t0.168,-0.035,0.254,0.178,\n\t\t0.190,0.245,0.077,0.228,\n\t\t0.382,0.287,0.284,0.212,\n\t\t0.222,0.312,0.081,0.094,\n\t\t0.202,-0.059,0.284,0.168,\n\t\t0.286,0.087,0.247,0.373,\n\t\t0.056,0.215,-0.066,0.303,\n\t\t0.101,0.139,0.223,0.345,\n\n\t\t0.196,-0.041,0.296,0.208,\n\t\t0.222,0.286,0.090,0.266,\n\t\t0.445,0.335,0.331,0.247,\n\t\t0.259,0.364,0.095,0.110,\n\t\t0.236,-0.069,0.331,0.196,\n\t\t0.334,0.101,0.289,0.435,\n\t\t0.066,0.250,-0.077,0.354,\n\t\t0.118,0.162,0.261,0.403,\n\n\t\t0.224,-0.048,0.338,0.238,\n\t\t0.254,0.327,0.103,0.304,\n\t\t0.509,0.383,0.379,0.282,\n\t\t0.296,0.416,0.108,0.126,\n\t\t0.270,-0.079,0.379,0.224,\n\t\t0.382,0.116,0.330,0.497,\n\t\t0.075,0.286,-0.088,0.405,\n\t\t0.135,0.186,0.298,0.460,\n\n\t\t0.253,-0.054,0.381,0.267,\n\t\t0.286,0.368,0.116,0.342,\n\t\t0.573,0.431,0.426,0.318,\n\t\t0.333,0.468,0.122,0.141,\n\t\t0.304,-0.089,0.426,0.252,\n\t\t0.430,0.131,0.371,0.560,\n\t\t0.084,0.322,-0.099,0.455,\n\t\t0.152,0.209,0.335,0.518,\n\n\t\t0.309,-0.065,0.465,0.327,\n\t\t0.349,0.450,0.142,0.418,\n\t\t0.700,0.527,0.521,0.388,\n\t\t0.407,0.573,0.149,0.173,\n\t\t0.371,-0.109,0.521,0.308,\n\t\t0.525,0.160,0.454,0.684,\n\t\t0.103,0.394,-0.121,0.556,\n\t\t0.186,0.255,0.410,0.633,\n\n\t\t0.365,-0.078,0.550,0.386,\n\t\t0.413,0.532,0.168,0.494,\n\t\t0.828,0.623,0.615,0.459,\n\t\t0.481,0.677,0.176,0.205,\n\t\t0.439,-0.129,0.615,0.364,\n\t\t0.621,0.189,0.536,0.809,\n\t\t0.122,0.465,-0.143,0.658,\n\t\t0.220,0.302,0.484,0.749,\n\n\t\t0.393,-0.083,0.592,0.416,\n\t\t0.444,0.573,0.181,0.532,\n\t\t0.891,0.671,0.663,0.494,\n\t\t0.518,0.729,0.190,0.220,\n\t\t0.473,-0.139,0.663,0.392,\n\t\t0.669,0.203,0.578,0.871,\n\t\t0.132,0.501,-0.154,0.708,\n\t\t0.237,0.325,0.522,0.806,\n\n\t\t0.414,0.069,0.235,-0.006,\n\t\t0.304,0.191,0.081,-0.044,\n\t\t0.290,0.399,0.263,-0.177,\n\t\t-0.005,0.234,0.057,0.034,\n\t\t0.203,0.244,0.237,0.163,\n\t\t0.381,0.439,0.001,-0.014,\n\t\t0.166,0.158,0.388,0.504,\n\t\t-0.067,0.059,0.166,0.292,\n\n\t\t0.223,0.300,0.152,0.273,\n\t\t0.141,0.194,-0.030,0.123,\n\t\t0.216,-0.039,0.208,0.142,\n\t\t0.307,0.006,0.103,0.045,\n\t\t0.306,0.084,0.169,0.095,\n\t\t0.328,0.108,0.189,0.024,\n\t\t0.305,0.030,0.034,0.164,\n\t\t-0.016,0.072,0.249,0.269,\n\n\t\t0.186,-0.012,0.169,-0.096,\n\t\t0.353,0.061,0.206,0.388,\n\t\t0.340,0.506,0.238,0.375,\n\t\t0.150,-0.079,0.350,0.292,\n\t\t0.484,0.031,0.535,0.313,\n\t\t0.310,0.182,0.549,0.401,\n\t\t-0.040,0.194,0.306,0.020,\n\t\t0.350,0.428,0.291,-0.013,\n\n\t\t-0.075,-0.098,-0.139,-0.114,\n\t\t0.165,0.082,0.035,-0.040,\n\t\t0.687,0.787,-0.141,0.394,\n\t\t0.066,0.289,0.037,0.444,\n\t\t-0.053,-0.018,0.540,-0.002,\n\t\t0.539,0.478,0.701,0.178,\n\t\t-0.027,0.027,0.588,0.184,\n\t\t0.085,0.423,0.125,0.161,\n\n\t\t0.081,0.111,0.004,0.039,\n\t\t0.172,-0.025,0.044,0.196,\n\t\t0.192,0.076,0.048,-0.025,\n\t\t-0.035,0.166,0.177,0.048,\n\t\t0.005,0.074,0.075,-0.035,\n\t\t0.158,-0.001,-0.004,0.052,\n\t\t0.070,0.156,-0.024,0.117,\n\t\t0.131,0.174,0.135,0.006,\n\n\t\t0.273,0.336,0.055,0.308,\n\t\t0.018,0.004,0.084,0.117,\n\t\t0.067,0.134,0.143,0.341,\n\t\t0.191,0.264,0.015,0.149,\n\t\t0.162,-0.036,0.235,0.180,\n\t\t0.037,0.037,0.188,0.132,\n\t\t0.311,-0.059,0.245,0.058,\n\t\t0.280,0.319,0.197,0.209,\n\n\t\t0.213,0.319,0.072,0.005,\n\t\t0.220,0.451,0.042,0.432,\n\t\t0.525,0.156,0.119,0.172,\n\t\t0.113,0.137,0.024,0.006,\n\t\t0.178,0.282,0.365,0.048,\n\t\t0.060,0.146,0.370,0.423,\n\t\t0.358,0.297,0.374,-0.076,\n\t\t0.228,0.192,0.107,0.542,\n\n\t\t0.655,0.412,-0.121,0.472,\n\t\t0.168,-0.027,0.250,0.308,\n\t\t0.095,0.438,0.466,0.272,\n\t\t0.512,0.481,-0.108,0.182,\n\t\t0.219,0.408,0.767,0.327,\n\t\t0.655,0.186,0.821,0.220,\n\t\t0.689,0.071,-0.024,0.655,\n\t\t0.307,0.694,0.411,0.137,\n\n\t\t0.257,0.403,0.419,0.549,\n\t\t0.239,-0.108,0.693,0.464,\n\t\t0.155,0.086,0.574,-0.132,\n\t\t0.666,0.336,0.172,0.728,\n\t\t-0.046,0.119,0.271,0.415,\n\t\t0.150,-0.009,0.755,0.642,\n\t\t-0.082,-0.023,0.486,0.336,\n\t\t0.749,0.107,0.322,-0.026,\n\n\t\t0.260,-0.066,0.257,0.013,\n\t\t0.136,0.172,0.256,0.191,\n\t\t0.204,0.164,0.034,0.301,\n\t\t0.164,0.226,0.177,0.405,\n\t\t0.396,-0.017,0.001,0.237,\n\t\t-0.073,0.310,-0.028,0.214,\n\t\t0.324,0.340,0.189,0.018,\n\t\t0.082,0.273,0.362,0.267,\n\n\t\t0.282,0.056,0.356,0.343,\n\t\t0.303,0.048,0.121,-0.055,\n\t\t0.288,0.081,0.170,0.376,\n\t\t0.382,-0.064,0.369,0.215,\n\t\t0.329,0.295,0.039,0.331,\n\t\t0.192,0.085,-0.018,-0.046,\n\t\t0.013,0.245,0.047,0.019,\n\t\t0.105,0.334,0.362,0.312,\n\n\t\t0.658,0.130,0.831,0.800,\n\t\t0.708,0.113,0.284,-0.129,\n\t\t0.672,0.189,0.398,0.879,\n\t\t0.891,-0.151,0.862,0.501,\n\t\t0.769,0.688,0.091,0.772,\n\t\t0.449,0.200,-0.044,-0.107,\n\t\t0.030,0.572,0.110,0.045,\n\t\t0.247,0.779,0.845,0.729,\n\n\t\t0.308,0.247,0.,0.115,\n\t\t0.170,0.178,0.272,0.174,\n\t\t0.078,0.138,0.158,0.329,\n\t\t0.050,0.172,0.328,0.129,\n\t\t-0.045,0.105,0.252,0.299,\n\t\t0.214,0.187,0.062,0.003,\n\t\t0.225,0.221,-0.022,0.198,\n\t\t0.190,0.262,0.304,0.029,\n\n\t\t0.370,0.296,0.,0.139,\n\t\t0.204,0.214,0.327,0.209,\n\t\t0.093,0.166,0.190,0.395,\n\t\t0.060,0.206,0.393,0.155,\n\t\t-0.054,0.126,0.303,0.358,\n\t\t0.257,0.224,0.074,0.003,\n\t\t0.271,0.265,-0.026,0.237,\n\t\t0.229,0.314,0.365,0.035,\n\n\t\t0.493,0.395,0.,0.185,\n\t\t0.273,0.286,0.436,0.279,\n\t\t0.124,0.221,0.254,0.527,\n\t\t0.080,0.275,0.525,0.207,\n\t\t-0.072,0.169,0.404,0.478,\n\t\t0.343,0.299,0.099,0.005,\n\t\t0.361,0.354,-0.035,0.317,\n\t\t0.305,0.419,0.486,0.046,\n\n\t\t0.298,-0.072,0.373,0.491,\n\t\t0.362,0.019,-0.039,0.389,\n\t\t0.381,0.359,0.136,0.357,\n\t\t0.555,0.109,-0.028,0.359,\n\t\t0.411,0.539,0.052,-0.047,\n\t\t0.030,0.276,0.577,0.323,\n\t\t0.055,-0.082,0.566,0.286,\n\t\t0.502,0.495,0.224,-0.044,\n\n\t\t0.155,0.044,0.067,0.154,\n\t\t-0.026,-0.029,-0.001,0.059,\n\t\t0.199,0.,-0.026,0.108,\n\t\t0.028,0.044,0.191,0.123,\n\t\t0.001,-0.022,0.022,0.181,\n\t\t-0.007,0.067,0.173,0.186,\n\t\t0.018,-0.020,0.021,0.172,\n\t\t0.140,0.199,-0.021,0.013,\n\n\t\t0.206,0.059,0.090,0.205,\n\t\t-0.035,-0.039,-0.002,0.079,\n\t\t0.266,-0.001,-0.035,0.144,\n\t\t0.037,0.059,0.255,0.164,\n\t\t0.002,-0.030,0.030,0.242,\n\t\t-0.010,0.089,0.231,0.248,\n\t\t0.024,-0.027,0.028,0.229,\n\t\t0.187,0.265,-0.028,0.018,\n\n\t\t0.258,0.074,0.112,0.256,\n\t\t-0.043,-0.049,-0.003,0.099,\n\t\t0.333,-0.001,-0.044,0.180,\n\t\t0.047,0.074,0.319,0.206,\n\t\t0.002,-0.038,0.037,0.302,\n\t\t-0.012,0.111,0.289,0.310,\n\t\t0.030,-0.034,0.036,0.286,\n\t\t0.234,0.332,-0.035,0.023,\n\n\t\t-0.021,0.036,0.439,0.007,\n\t\t0.530,0.236,0.023,0.196,\n\t\t0.610,-0.001,0.238,0.560,\n\t\t0.414,0.322,0.128,0.495,\n\t\t0.373,-0.089,0.326,0.292,\n\t\t0.125,0.076,0.130,-0.061,\n\t\t0.373,0.193,0.342,0.309,\n\t\t-0.092,0.601,0.473,-0.002,\n\n\t\t1.046,0.358,0.709,0.832,\n\t\t0.873,0.417,0.459,0.404,\n\t\t0.711,0.247,0.290,0.647,\n\t\t0.171,1.016,0.962,0.030,\n\t\t0.485,0.028,0.859,1.087,\n\t\t0.280,0.518,-0.172,0.902,\n\t\t0.626,0.774,0.013,0.173,\n\t\t0.331,-0.041,0.574,0.277,\n\n\t\t0.161,0.338,0.002,-0.034,\n\t\t-0.001,0.208,0.154,0.283,\n\t\t0.222,0.181,0.016,0.212,\n\t\t0.155,-0.027,0.284,0.243,\n\t\t0.325,0.083,0.239,0.068,\n\t\t0.307,0.121,0.287,0.033,\n\t\t0.019,-0.052,0.150,0.186,\n\t\t-0.002,0.266,0.335,0.095,\n\n\t\t0.139,0.045,0.075,-0.025,\n\t\t-0.019,0.111,0.092,-0.025,\n\t\t0.124,0.081,0.076,0.155,\n\t\t-0.022,0.066,-0.027,0.149,\n\t\t0.143,-0.003,-0.024,0.110,\n\t\t-0.007,0.115,-0.022,0.132,\n\t\t0.032,0.047,0.100,0.113,\n\t\t0.112,0.146,0.091,0.080,\n\n\t\t0.174,0.056,0.094,-0.031,\n\t\t-0.024,0.139,0.115,-0.032,\n\t\t0.155,0.101,0.096,0.194,\n\t\t-0.028,0.082,-0.033,0.187,\n\t\t0.179,-0.004,-0.030,0.137,\n\t\t-0.009,0.143,-0.027,0.166,\n\t\t0.040,0.058,0.125,0.142,\n\t\t0.140,0.183,0.114,0.100,\n\n\t\t0.209,0.067,0.113,-0.038,\n\t\t-0.029,0.167,0.138,-0.038,\n\t\t0.187,0.121,0.115,0.232,\n\t\t-0.034,0.099,-0.040,0.224,\n\t\t0.215,-0.005,-0.037,0.165,\n\t\t-0.011,0.172,-0.033,0.199,\n\t\t0.048,0.070,0.150,0.170,\n\t\t0.168,0.220,0.137,0.120,\n\n\t\t0.244,0.078,0.132,-0.044,\n\t\t-0.034,0.195,0.161,-0.045,\n\t\t0.218,0.141,0.134,0.271,\n\t\t-0.039,0.115,-0.047,0.262,\n\t\t0.251,-0.005,-0.043,0.193,\n\t\t-0.013,0.201,-0.039,0.232,\n\t\t0.056,0.082,0.175,0.199,\n\t\t0.196,0.257,0.160,0.140,\n\n\t\t0.279,0.090,0.151,-0.051,\n\t\t-0.039,0.223,0.184,-0.051,\n\t\t0.249,0.162,0.153,0.310,\n\t\t-0.045,0.132,-0.054,0.299,\n\t\t0.287,-0.006,-0.049,0.220,\n\t\t-0.015,0.230,-0.044,0.265,\n\t\t0.064,0.094,0.200,0.227,\n\t\t0.224,0.293,0.182,0.160,\n\n\t\t0.314,0.101,0.170,-0.057,\n\t\t-0.044,0.251,0.207,-0.058,\n\t\t0.280,0.182,0.172,0.349,\n\t\t-0.051,0.149,-0.061,0.337,\n\t\t0.323,-0.007,-0.055,0.248,\n\t\t-0.017,0.258,-0.050,0.298,\n\t\t0.072,0.106,0.225,0.256,\n\t\t0.252,0.330,0.205,0.180,\n\n\t\t-0.036,0.381,0.108,0.080,\n\t\t-0.094,0.182,0.254,0.503,\n\t\t0.520,0.501,0.039,0.427,\n\t\t0.064,0.378,0.245,0.455,\n\t\t0.295,-0.031,0.211,0.190,\n\t\t0.507,0.026,0.442,0.535,\n\t\t0.116,0.256,0.050,0.379,\n\t\t0.392,0.395,0.199,0.254,\n\n\t\t0.085,0.077,0.087,0.011,\n\t\t0.183,-0.023,-0.005,0.096,\n\t\t0.126,-0.028,0.050,0.188,\n\t\t0.075,0.179,0.077,-0.020,\n\t\t0.205,0.118,0.012,0.113,\n\t\t0.166,-0.027,0.108,0.172,\n\t\t0.106,0.089,0.032,-0.028,\n\t\t0.031,0.145,0.028,0.078,\n\n\t\t0.128,0.116,0.131,0.017,\n\t\t0.275,-0.034,-0.008,0.144,\n\t\t0.190,-0.043,0.075,0.282,\n\t\t0.112,0.269,0.116,-0.030,\n\t\t0.308,0.178,0.019,0.170,\n\t\t0.249,-0.041,0.162,0.258,\n\t\t0.159,0.133,0.049,-0.042,\n\t\t0.046,0.217,0.043,0.117,\n\n\t\t0.808,0.068,0.735,0.790,\n\t\t-0.070,0.280,0.200,0.323,\n\t\t-0.012,0.743,0.354,0.099,\n\t\t0.367,0.123,-0.036,0.489,\n\t\t0.692,0.313,0.797,-0.025,\n\t\t0.077,0.240,0.458,0.529,\n\t\t0.369,0.392,0.603,0.081,\n\t\t0.556,0.055,0.733,0.539,\n\n\t\t0.042,-0.014,0.017,0.094,\n\t\t0.069,0.023,0.101,0.013,\n\t\t0.079,0.035,0.038,-0.002,\n\t\t0.032,0.,0.006,0.026,\n\t\t0.089,0.043,0.053,0.096,\n\t\t-0.007,-0.003,0.090,0.048,\n\t\t0.031,0.063,0.077,0.081,\n\t\t0.059,0.043,0.094,-0.001,\n\n\t\t0.112,-0.039,0.125,0.279,\n\t\t0.185,0.063,0.270,0.034,\n\t\t0.163,0.093,0.057,-0.006,\n\t\t0.220,0.001,0.018,-0.012,\n\t\t0.304,0.086,0.142,0.256,\n\t\t-0.019,0.034,0.241,0.165,\n\t\t0.085,0.169,0.207,0.218,\n\t\t0.159,0.264,0.250,-0.003,\n\n\t\t0.140,-0.049,0.157,0.349,\n\t\t0.232,0.079,0.338,0.043,\n\t\t0.204,0.117,0.072,-0.007,\n\t\t0.276,0.001,0.023,-0.015,\n\t\t0.380,0.107,0.178,0.320,\n\t\t-0.024,0.043,0.301,0.206,\n\t\t0.106,0.211,0.259,0.272,\n\t\t0.199,0.330,0.313,-0.003,\n\n\t\t0.087,-0.031,0.204,0.037,\n\t\t0.036,0.039,0.069,0.180,\n\t\t0.056,0.170,0.158,0.148,\n\t\t0.005,0.102,0.059,0.186,\n\t\t-0.019,-0.021,0.028,0.192,\n\t\t0.045,0.062,-0.014,0.177,\n\t\t-0.006,0.021,0.131,-0.029,\n\t\t0.003,-0.024,0.079,0.052,\n\n\t\t0.466,-0.166,1.088,0.200,\n\t\t0.196,0.208,0.373,0.964,\n\t\t0.299,0.911,0.847,0.793,\n\t\t0.028,0.547,0.319,0.997,\n\t\t-0.102,-0.116,0.150,1.027,\n\t\t0.244,0.331,-0.079,0.946,\n\t\t-0.032,0.112,0.700,-0.155,\n\t\t0.017,-0.131,0.423,0.280,\n\n\t\t0.570,-0.163,1.360,0.250,\n\t\t0.267,0.304,0.495,1.240,\n\t\t0.374,1.139,1.059,0.991,\n\t\t-0.009,0.684,0.433,1.246,\n\t\t-0.120,-0.145,0.188,1.283,\n\t\t0.305,0.414,-0.098,1.183,\n\t\t-0.040,0.209,0.823,0.173,\n\t\t0.021,-0.187,0.591,0.351,\n\n\t\t0.753,0.731,0.394,0.614,\n\t\t0.474,-0.052,0.512,0.365,\n\t\t-0.104,0.006,0.803,-0.058,\n\t\t-0.110,-0.100,0.410,0.464,\n\t\t-0.041,0.679,0.247,0.166,\n\t\t0.618,0.326,0.520,0.643,\n\t\t0.392,0.554,0.242,0.047,\n\t\t0.705,0.566,0.520,0.330,\n\n\t\t0.879,0.853,0.459,0.716,\n\t\t0.553,-0.061,0.597,0.426,\n\t\t-0.121,0.007,0.937,-0.068,\n\t\t-0.128,-0.116,0.479,0.541,\n\t\t-0.048,0.793,0.289,0.194,\n\t\t0.721,0.381,0.607,0.750,\n\t\t0.457,0.647,0.283,0.055,\n\t\t0.822,0.661,0.607,0.385,\n\n\t\t0.942,0.914,0.492,0.768,\n\t\t0.592,-0.065,0.640,0.457,\n\t\t-0.130,0.007,1.004,-0.072,\n\t\t-0.137,-0.125,0.513,0.580,\n\t\t-0.052,0.849,0.309,0.208,\n\t\t0.772,0.408,0.651,0.804,\n\t\t0.490,0.693,0.303,0.059,\n\t\t0.881,0.708,0.651,0.413,\n\n\t\t0.590,0.111,0.150,0.993,\n\t\t0.232,0.977,0.040,-0.087,\n\t\t0.794,0.012,0.870,0.844,\n\t\t0.075,0.351,0.014,-0.166,\n\t\t0.169,0.513,0.229,0.752,\n\t\t0.731,0.689,0.146,1.031,\n\t\t0.351,0.637,0.058,-0.177,\n\t\t0.314,0.897,0.423,0.714,\n\n\t\t0.113,0.022,0.030,0.198,\n\t\t0.046,0.195,0.008,-0.017,\n\t\t0.158,0.002,0.174,0.168,\n\t\t0.,0.070,0.002,-0.033,\n\t\t0.033,0.102,0.031,0.150,\n\t\t0.146,0.137,0.029,0.206,\n\t\t0.070,0.127,0.011,-0.035,\n\t\t0.062,0.179,0.084,0.142,\n\n\t\t0.566,0.111,0.150,0.993,\n\t\t0.232,0.977,0.064,-0.087,\n\t\t0.794,0.012,0.870,0.844,\n\t\t0.,0.275,0.014,-0.161,\n\t\t0.169,0.513,0.155,0.752,\n\t\t0.731,0.689,0.171,1.031,\n\t\t0.351,0.680,0.058,-0.177,\n\t\t0.314,0.897,0.423,0.714,\n\n\t\t0.140,0.029,0.040,0.264,\n\t\t0.072,0.260,0.017,-0.011,\n\t\t0.211,0.003,0.232,0.225,\n\t\t0.,0.060,0.003,-0.043,\n\t\t0.045,0.136,0.029,0.200,\n\t\t0.195,0.184,0.045,0.275,\n\t\t0.093,0.181,0.015,-0.052,\n\t\t0.096,0.243,0.112,0.190,\n\n\t\t0.280,0.059,0.080,0.529,\n\t\t0.144,0.521,0.034,-0.023,\n\t\t0.423,0.006,0.464,0.450,\n\t\t0.001,0.121,0.007,-0.086,\n\t\t0.090,0.273,0.059,0.401,\n\t\t0.390,0.368,0.091,0.550,\n\t\t0.187,0.362,0.031,-0.105,\n\t\t0.193,0.487,0.225,0.381,\n\n\t\t0.490,0.103,0.140,0.927,\n\t\t0.252,0.912,0.060,-0.041,\n\t\t0.741,0.011,0.812,0.788,\n\t\t0.003,0.213,0.013,-0.151,\n\t\t0.158,0.479,0.104,0.702,\n\t\t0.682,0.643,0.160,0.962,\n\t\t0.327,0.634,0.054,-0.185,\n\t\t0.339,0.853,0.394,0.666,\n\n\t\t1.121,0.237,0.320,2.119,\n\t\t0.577,2.085,0.138,-0.094,\n\t\t1.695,0.026,1.856,1.802,\n\t\t0.007,0.487,0.031,-0.345,\n\t\t0.361,1.095,0.238,1.604,\n\t\t1.560,1.472,0.366,2.200,\n\t\t0.749,1.450,0.125,-0.423,\n\t\t0.775,1.950,0.902,1.524,\n\n\t\t1.261,0.266,0.360,2.384,\n\t\t0.649,2.346,0.155,-0.105,\n\t\t1.907,0.029,2.088,2.027,\n\t\t0.008,0.548,0.035,-0.388,\n\t\t0.407,1.231,0.268,1.805,\n\t\t1.755,1.656,0.412,2.475,\n\t\t0.842,1.632,0.140,-0.476,\n\t\t0.872,2.194,1.015,1.714,\n\n\t\t1.542,0.276,0.444,2.914,\n\t\t0.754,2.867,0.182,-0.129,\n\t\t2.331,0.036,2.553,2.478,\n\t\t0.010,0.686,0.111,-0.474,\n\t\t0.497,1.505,0.358,2.206,\n\t\t2.145,2.023,0.575,3.025,\n\t\t1.030,1.994,0.151,-0.556,\n\t\t1.066,2.682,1.241,2.095,\n\n\t\t0.420,0.075,0.121,0.794,\n\t\t0.205,0.782,0.049,-0.035,\n\t\t0.635,0.009,0.696,0.675,\n\t\t0.002,0.187,0.030,-0.129,\n\t\t0.135,0.410,0.097,0.601,\n\t\t0.585,0.551,0.156,0.825,\n\t\t0.280,0.544,0.041,-0.151,\n\t\t0.290,0.731,0.338,0.571,\n\n\t\t0.640,0.117,0.181,1.192,\n\t\t0.308,1.173,0.074,-0.074,\n\t\t0.953,0.014,1.044,1.013,\n\t\t-0.039,0.280,0.112,-0.194,\n\t\t0.203,0.615,0.138,0.902,\n\t\t0.877,0.828,0.204,1.237,\n\t\t0.403,0.816,0.062,-0.211,\n\t\t0.436,1.097,0.515,0.857,\n\n\t\t1.040,0.190,0.383,1.937,\n\t\t0.501,1.906,0.178,-0.120,\n\t\t1.549,0.024,1.697,1.647,\n\t\t-0.063,0.388,0.182,-0.315,\n\t\t0.330,1.,0.225,1.466,\n\t\t1.426,1.345,0.331,2.010,\n\t\t0.656,1.326,0.056,-0.439,\n\t\t0.709,1.783,0.825,1.393,\n\n\t\t1.120,0.205,0.413,2.086,\n\t\t0.539,2.053,0.192,-0.129,\n\t\t1.669,0.025,1.827,1.774,\n\t\t-0.068,0.418,0.196,-0.339,\n\t\t0.356,1.077,0.242,1.579,\n\t\t1.536,1.449,0.357,2.165,\n\t\t0.706,1.428,0.061,-0.473,\n\t\t0.763,1.920,0.889,1.500,\n\n\t\t1.200,0.219,0.442,2.235,\n\t\t0.578,2.199,0.205,-0.139,\n\t\t1.788,0.027,1.958,1.900,\n\t\t-0.073,0.448,0.210,-0.364,\n\t\t0.381,1.154,0.259,1.692,\n\t\t1.645,1.552,0.383,2.320,\n\t\t0.757,1.530,0.065,-0.507,\n\t\t0.818,2.057,0.952,1.607,\n\n\t\t0.107,0.015,0.055,0.204,\n\t\t0.053,0.201,0.,-0.003,\n\t\t0.157,0.007,0.179,0.169,\n\t\t-0.006,0.027,0.019,-0.020,\n\t\t0.022,0.095,0.017,0.148,\n\t\t0.150,-0.013,0.032,0.212,\n\t\t0.076,0.136,0.005,-0.042,\n\t\t0.075,0.188,0.087,0.147,\n\n\t\t0.274,0.036,0.110,0.409,\n\t\t0.124,0.403,-0.001,-0.007,\n\t\t0.314,-0.011,0.374,0.339,\n\t\t0.034,0.,0.017,-0.040,\n\t\t0.045,0.190,0.034,0.296,\n\t\t0.301,-0.027,0.064,0.425,\n\t\t0.152,0.273,0.011,-0.084,\n\t\t0.150,0.377,0.175,0.294,\n\n\t\t0.252,0.033,0.101,0.365,\n\t\t0.114,0.369,-0.001,-0.006,\n\t\t0.314,-0.010,0.345,0.312,\n\t\t0.031,0.,0.015,-0.037,\n\t\t0.042,0.198,-0.005,0.272,\n\t\t0.277,-0.025,0.058,0.391,\n\t\t0.140,0.251,0.010,-0.044,\n\t\t0.138,0.292,0.161,0.308,\n\n\t\t0.142,0.912,-0.114,0.024,\n\t\t0.161,0.012,0.317,0.424,\n\t\t0.913,0.615,0.264,0.872,\n\t\t0.449,0.520,0.714,0.318,\n\t\t0.281,-0.148,-0.111,0.628,\n\t\t0.231,0.578,0.065,0.945,\n\t\t0.675,0.753,0.721,0.050,\n\t\t0.047,0.731,0.253,0.012,\n\n\t\t0.042,0.300,0.018,-0.079,\n\t\t-0.015,0.025,0.225,0.092,\n\t\t0.351,0.197,0.084,0.286,\n\t\t0.160,0.167,0.232,0.070,\n\t\t0.108,-0.074,-0.066,0.201,\n\t\t0.074,0.198,-0.018,0.248,\n\t\t0.167,0.198,0.201,-0.001,\n\t\t0.015,0.242,0.046,-0.007,\n\n\t\t0.288,1.041,-0.079,-0.265,\n\t\t-0.053,-0.002,0.970,0.369,\n\t\t1.071,0.511,0.135,0.956,\n\t\t-0.064,0.557,0.751,0.235,\n\t\t0.486,-0.251,-0.243,0.632,\n\t\t0.137,0.604,0.124,0.634,\n\t\t0.536,0.641,0.861,-0.151,\n\t\t0.095,0.663,0.211,0.143,\n\n\t\t0.288,1.041,-0.079,-0.265,\n\t\t-0.053,-0.002,0.970,0.369,\n\t\t1.071,0.511,0.135,0.956,\n\t\t-0.064,0.557,0.751,0.235,\n\t\t0.486,-0.251,-0.243,0.632,\n\t\t0.137,0.604,0.124,0.634,\n\t\t0.536,0.641,0.861,-0.151,\n\t\t0.095,0.663,0.211,0.143,\n\n\t\t0.533,0.038,0.634,0.018,\n\t\t-0.136,-0.192,0.097,-0.151,\n\t\t-0.187,0.122,0.186,0.126,\n\t\t0.410,0.432,0.343,0.221,\n\t\t0.296,0.504,0.341,0.618,\n\t\t0.494,0.467,-0.147,0.129,\n\t\t0.060,0.481,0.558,0.628,\n\t\t0.523,-0.232,0.502,0.224,\n\n\t\t-0.011,-0.044,-0.041,-0.079,\n\t\t-0.041,0.172,0.116,0.306,\n\t\t0.354,0.299,0.195,0.234,\n\t\t0.340,0.011,0.155,0.379,\n\t\t0.226,0.043,-0.011,0.397,\n\t\t0.102,0.396,0.329,0.217,\n\t\t0.351,0.246,0.174,0.209,\n\t\t0.296,0.110,0.413,0.373,\n\n\t\t0.276,0.691,0.598,0.037,\n\t\t-0.040,0.642,0.379,0.371,\n\t\t0.078,-0.071,-0.011,0.750,\n\t\t0.629,0.156,0.590,-0.036,\n\t\t0.298,0.330,-0.162,0.650,\n\t\t0.021,0.271,0.163,0.756,\n\t\t0.519,0.320,0.008,0.219,\n\t\t0.445,-0.099,0.675,0.434,\n\n\t\t0.456,1.065,1.103,0.068,\n\t\t-0.101,1.168,0.689,0.750,\n\t\t0.143,-0.129,-0.020,1.105,\n\t\t1.143,0.362,1.074,0.048,\n\t\t0.542,0.627,-0.164,1.182,\n\t\t0.039,0.494,0.296,1.375,\n\t\t0.944,0.582,0.014,0.477,\n\t\t0.810,-0.180,1.228,1.011,\n\n\t\t0.398,0.932,0.965,0.059,\n\t\t-0.088,1.022,0.683,0.657,\n\t\t0.119,-0.113,-0.063,0.967,\n\t\t1.,0.281,0.940,0.054,\n\t\t0.474,0.548,-0.143,1.034,\n\t\t0.034,0.432,0.259,1.203,\n\t\t0.865,0.425,0.013,0.451,\n\t\t0.737,-0.157,1.075,0.885,\n\n\t\t0.327,0.815,0.844,0.052,\n\t\t-0.062,0.864,0.565,0.679,\n\t\t0.104,-0.139,-0.015,0.793,\n\t\t0.875,0.252,0.834,0.010,\n\t\t0.407,0.467,-0.083,0.852,\n\t\t0.133,0.401,0.249,1.053,\n\t\t0.708,0.368,0.011,0.500,\n\t\t0.562,-0.113,0.940,0.765,\n\n\t\t0.030,0.039,-0.071,0.367,\n\t\t0.663,0.398,0.062,0.217,\n\t\t0.563,0.539,0.520,-0.041,\n\t\t0.359,0.548,-0.089,-0.019,\n\t\t0.016,0.368,0.201,0.247,\n\t\t0.022,0.498,-0.100,0.034,\n\t\t0.656,0.062,0.296,0.593,\n\t\t-0.025,0.425,0.179,-0.041,\n\n\t\t0.027,0.036,-0.065,0.339,\n\t\t0.612,0.469,0.057,0.201,\n\t\t0.519,0.498,0.480,-0.038,\n\t\t0.331,0.505,-0.082,-0.018,\n\t\t0.014,0.418,0.185,0.228,\n\t\t0.020,0.460,-0.123,0.032,\n\t\t0.605,0.057,0.273,0.548,\n\t\t-0.023,0.392,0.165,-0.038,\n\n\t\t0.218,0.262,0.025,0.268,\n\t\t0.010,0.205,0.125,0.019,\n\t\t0.301,-0.031,0.196,0.230,\n\t\t0.317,0.074,0.260,0.213,\n\t\t-0.035,0.237,0.084,0.245,\n\t\t0.131,0.164,0.255,0.205,\n\t\t0.263,0.296,0.185,0.249,\n\t\t0.175,0.185,0.123,0.096,\n\n\t\t0.139,-0.003,0.306,0.330,\n\t\t0.394,0.120,-0.032,-0.024,\n\t\t0.148,0.348,-0.100,0.473,\n\t\t0.360,-0.021,0.400,0.021,\n\t\t0.099,0.171,0.007,0.299,\n\t\t0.310,0.065,-0.067,0.078,\n\t\t0.001,0.484,0.259,0.379,\n\t\t0.043,0.351,0.511,0.081,\n\n\t\t0.536,2.047,0.250,2.392,\n\t\t0.540,2.434,0.312,1.697,\n\t\t1.671,0.673,1.781,0.010,\n\t\t0.156,1.433,0.806,2.249,\n\t\t0.036,0.400,1.719,1.105,\n\t\t0.273,0.738,0.039,2.506,\n\t\t0.640,-0.331,0.861,1.339,\n\t\t0.933,1.456,2.493,0.962,\n\n\t\t0.506,2.047,0.136,2.392,\n\t\t0.540,2.434,0.335,1.697,\n\t\t1.671,0.588,1.781,0.040,\n\t\t0.156,1.433,0.719,2.249,\n\t\t0.053,0.347,1.719,1.105,\n\t\t0.273,0.738,0.039,2.506,\n\t\t0.640,-0.331,0.753,1.339,\n\t\t0.993,1.456,2.493,0.962,\n\n\t\t0.455,1.843,0.123,2.153,\n\t\t0.486,2.191,0.302,1.527,\n\t\t1.503,0.529,1.603,0.036,\n\t\t0.140,1.290,0.647,2.024,\n\t\t0.048,0.312,1.547,0.994,\n\t\t0.246,0.664,0.035,2.255,\n\t\t0.576,-0.297,0.677,1.205,\n\t\t0.893,1.310,2.243,0.866,\n\n\t\t0.240,0.087,-0.020,0.072,\n\t\t0.006,0.081,0.172,0.075,\n\t\t0.109,0.098,0.083,0.157,\n\t\t0.007,0.152,-0.025,0.093,\n\t\t0.004,0.108,0.195,0.128,\n\t\t0.160,0.099,0.014,0.253,\n\t\t0.216,0.223,0.245,0.166,\n\t\t0.219,0.204,0.057,0.184,\n\n\t\t0.962,0.348,-0.080,0.291,\n\t\t0.024,0.327,0.690,0.301,\n\t\t0.438,0.392,0.333,0.629,\n\t\t0.028,0.608,-0.101,0.372,\n\t\t0.019,0.433,0.782,0.513,\n\t\t0.642,0.399,0.058,1.015,\n\t\t0.864,0.894,0.982,0.664,\n\t\t0.876,0.817,0.231,0.738,\n\n\t\t1.683,0.610,-0.140,0.509,\n\t\t0.043,0.573,1.208,0.528,\n\t\t0.767,0.687,0.582,1.101,\n\t\t0.050,1.065,-0.177,0.651,\n\t\t0.034,0.757,1.369,0.898,\n\t\t1.124,0.698,0.102,1.777,\n\t\t1.513,1.565,1.720,1.162,\n\t\t1.533,1.431,0.405,1.292,\n\n\t\t0.481,0.172,-0.040,0.133,\n\t\t0.046,0.181,0.392,0.123,\n\t\t0.192,0.229,0.157,0.326,\n\t\t0.045,0.304,-0.050,0.222,\n\t\t-0.002,0.240,0.405,0.228,\n\t\t0.300,0.204,0.079,0.470,\n\t\t0.432,0.474,0.491,0.344,\n\t\t0.422,0.424,0.110,0.378,\n\n\t\t0.888,0.182,-0.118,0.148,\n\t\t-0.021,0.312,0.788,0.373,\n\t\t0.444,0.439,0.415,0.699,\n\t\t0.117,0.638,-0.253,0.419,\n\t\t0.037,0.297,0.685,0.380,\n\t\t0.548,0.195,0.142,0.957,\n\t\t0.840,0.910,0.985,0.545,\n\t\t0.830,0.816,0.205,0.737,\n\n\t\t0.666,0.140,-0.089,0.084,\n\t\t-0.018,0.234,0.591,0.279,\n\t\t0.333,0.312,0.311,0.524,\n\t\t0.088,0.478,-0.174,0.314,\n\t\t0.033,0.222,0.513,0.298,\n\t\t0.411,0.146,0.122,0.718,\n\t\t0.630,0.682,0.738,0.409,\n\t\t0.622,0.612,0.154,0.553,\n\n\t\t0.304,-0.029,0.564,-0.009,\n\t\t-0.174,0.284,0.686,0.384,\n\t\t0.709,0.937,0.554,0.600,\n\t\t0.446,0.488,-0.142,0.345,\n\t\t0.033,0.037,0.839,0.949,\n\t\t-0.089,0.429,0.453,0.135,\n\t\t0.373,-0.005,0.107,0.788,\n\t\t0.240,0.928,0.505,0.312,\n\n\t\t0.223,-0.021,0.438,-0.007,\n\t\t-0.207,0.208,0.503,0.243,\n\t\t0.520,0.687,0.406,0.440,\n\t\t0.327,0.446,-0.104,0.253,\n\t\t0.024,0.027,0.615,0.696,\n\t\t-0.065,0.314,0.332,0.099,\n\t\t0.273,0.029,0.180,0.600,\n\t\t0.176,0.681,0.371,0.206,\n\n\t\t0.280,-0.026,0.549,-0.008,\n\t\t-0.260,0.261,0.630,0.304,\n\t\t0.651,0.861,0.509,0.551,\n\t\t0.409,0.559,-0.130,0.317,\n\t\t0.030,0.034,0.771,0.872,\n\t\t-0.081,0.394,0.416,0.124,\n\t\t0.342,0.037,0.226,0.752,\n\t\t0.220,0.853,0.464,0.258,\n\n\t\t0.360,-0.034,0.706,-0.011,\n\t\t-0.334,0.336,0.811,0.391,\n\t\t0.838,1.107,0.655,0.708,\n\t\t0.527,0.719,-0.168,0.407,\n\t\t0.039,0.044,0.992,1.121,\n\t\t-0.105,0.506,0.535,0.160,\n\t\t0.440,0.047,0.291,0.967,\n\t\t0.283,1.097,0.597,0.331,\n\n\t\t0.749,-0.133,-0.070,0.549,\n\t\t0.464,0.018,0.380,0.517,\n\t\t0.418,0.564,0.420,-0.099,\n\t\t0.427,0.645,0.348,0.452,\n\t\t-0.053,0.514,0.750,0.505,\n\t\t0.329,0.459,0.255,0.007,\n\t\t-0.045,0.606,0.244,0.203,\n\t\t0.002,0.326,0.415,-0.004,\n\n\t\t0.818,-0.146,-0.076,0.599,\n\t\t0.507,0.020,0.415,0.564,\n\t\t0.456,0.615,0.458,-0.109,\n\t\t0.466,0.704,0.380,0.493,\n\t\t-0.058,0.560,0.819,0.551,\n\t\t0.359,0.501,0.279,0.007,\n\t\t-0.049,0.662,0.266,0.221,\n\t\t0.003,0.356,0.453,-0.004,\n\n\t\t0.954,-0.170,-0.089,0.699,\n\t\t0.591,0.024,0.484,0.658,\n\t\t0.532,0.717,0.534,-0.127,\n\t\t0.543,0.821,0.443,0.575,\n\t\t-0.068,0.654,0.955,0.643,\n\t\t0.419,0.584,0.325,0.009,\n\t\t-0.057,0.772,0.310,0.258,\n\t\t0.003,0.415,0.529,-0.005,\n\n\t\t1.022,-0.182,-0.096,0.749,\n\t\t0.633,0.025,0.519,0.705,\n\t\t0.570,0.769,0.572,-0.136,\n\t\t0.582,0.880,0.475,0.616,\n\t\t-0.072,0.700,1.023,0.689,\n\t\t0.449,0.626,0.348,0.009,\n\t\t-0.061,0.827,0.332,0.276,\n\t\t0.003,0.445,0.566,-0.005,\n\n\t\t0.466,-0.026,-0.116,0.056,\n\t\t0.587,0.317,0.281,0.535,\n\t\t1.071,1.124,-0.202,0.320,\n\t\t0.279,1.042,0.178,0.596,\n\t\t0.791,0.547,0.595,-0.053,\n\t\t0.632,1.122,0.449,0.416,\n\t\t0.337,0.673,0.086,0.154,\n\t\t0.060,0.489,-0.073,0.901,\n\n\t\t0.266,0.217,0.037,-0.063,\n\t\t-0.116,0.362,0.583,-0.067,\n\t\t0.227,0.025,0.630,0.248,\n\t\t0.248,-0.117,0.285,0.066,\n\t\t0.666,0.485,0.462,-0.099,\n\t\t0.587,-0.086,0.368,0.056,\n\t\t0.173,-0.091,0.537,0.605,\n\t\t0.045,0.590,0.012,0.437,\n\n\t\t0.263,-0.005,-0.060,-0.061,\n\t\t-0.001,0.068,-0.053,-0.024,\n\t\t0.288,0.080,0.117,0.341,\n\t\t0.227,-0.048,0.091,0.325,\n\t\t0.045,0.076,0.261,0.138,\n\t\t0.285,0.252,0.264,-0.032,\n\t\t0.334,0.211,0.232,0.086,\n\t\t0.128,0.248,-0.062,0.047,\n\n\t\t0.316,-0.006,-0.072,-0.074,\n\t\t-0.001,0.081,-0.063,-0.029,\n\t\t0.345,0.096,0.141,0.410,\n\t\t0.273,-0.058,0.110,0.391,\n\t\t0.054,0.092,0.313,0.166,\n\t\t0.342,0.303,0.317,-0.038,\n\t\t0.401,0.253,0.278,0.104,\n\t\t0.153,0.297,-0.074,0.057,\n\n\t\t0.305,0.257,0.048,0.240,\n\t\t-0.054,0.338,0.278,0.296,\n\t\t0.074,0.052,0.167,0.239,\n\t\t-0.059,0.301,0.221,0.329,\n\t\t0.335,0.188,0.204,0.277,\n\t\t0.328,0.044,0.179,0.318,\n\t\t0.268,0.069,0.276,0.265,\n\t\t-0.025,0.217,-0.039,0.215,\n\n\t\t1.077,1.329,0.068,0.568,\n\t\t-0.196,1.586,0.801,0.845,\n\t\t0.384,0.479,0.237,0.701,\n\t\t0.043,1.266,0.519,0.829,\n\t\t0.897,0.667,0.291,1.628,\n\t\t1.373,-0.348,0.723,0.884,\n\t\t0.740,-0.043,0.456,0.860,\n\t\t0.097,0.926,-0.192,0.731,\n\n\t\t0.502,0.686,0.032,0.265,\n\t\t-0.091,0.740,0.427,0.394,\n\t\t0.114,0.223,0.110,0.327,\n\t\t0.020,0.591,0.242,0.387,\n\t\t0.418,0.311,0.136,0.759,\n\t\t0.641,-0.162,0.337,0.412,\n\t\t0.345,-0.020,0.213,0.401,\n\t\t0.045,0.432,-0.089,0.341,\n\n\t\t1.053,1.286,-0.043,0.497,\n\t\t-0.172,1.388,0.802,0.627,\n\t\t0.214,0.443,0.054,0.717,\n\t\t0.038,1.190,0.558,0.597,\n\t\t0.685,0.667,0.255,1.424,\n\t\t1.201,-0.305,0.633,0.819,\n\t\t0.647,-0.037,0.399,0.753,\n\t\t0.085,0.810,-0.094,0.640,\n\n\t\t1.123,1.372,-0.046,0.530,\n\t\t-0.183,1.480,0.855,0.669,\n\t\t0.228,0.473,0.058,0.765,\n\t\t0.040,1.269,0.596,0.637,\n\t\t0.731,0.712,0.272,1.519,\n\t\t1.282,-0.325,0.675,0.874,\n\t\t0.690,-0.040,0.426,0.803,\n\t\t0.090,0.864,-0.100,0.682,\n\n\t\t-0.024,-0.031,0.181,0.182,\n\t\t0.088,-0.023,0.067,0.094,\n\t\t0.192,0.152,0.005,0.144,\n\t\t0.067,0.177,0.148,0.197,\n\t\t0.013,0.076,-0.023,0.105,\n\t\t0.109,0.084,-0.008,-0.019,\n\t\t0.191,0.002,0.044,0.066,\n\t\t0.077,0.157,0.078,0.090,\n\n\t\t-0.032,-0.042,0.241,0.243,\n\t\t0.117,-0.031,0.089,0.126,\n\t\t0.256,0.203,0.007,0.192,\n\t\t0.090,0.236,0.198,0.263,\n\t\t0.017,0.102,-0.031,0.140,\n\t\t0.146,0.113,-0.011,-0.026,\n\t\t0.254,0.003,0.059,0.088,\n\t\t0.103,0.210,0.104,0.120,\n\n\t\t-0.026,-0.034,0.198,0.199,\n\t\t0.124,-0.059,0.073,0.103,\n\t\t0.249,0.167,0.014,0.122,\n\t\t0.057,0.203,0.153,0.215,\n\t\t-0.016,0.090,-0.026,0.144,\n\t\t0.120,0.092,-0.024,-0.017,\n\t\t0.229,0.002,0.009,0.058,\n\t\t0.105,0.172,0.053,0.099,\n\n\t\t0.322,-0.044,0.191,0.354,\n\t\t0.338,0.070,0.336,0.127,\n\t\t0.376,0.360,0.475,-0.029,\n\t\t0.509,0.295,0.497,0.219,\n\t\t0.199,0.310,-0.066,-0.047,\n\t\t0.083,0.172,0.102,0.491,\n\t\t0.234,0.284,0.134,0.,\n\t\t0.304,0.358,0.419,0.525,\n\n\t\t0.483,-0.066,0.287,0.532,\n\t\t0.508,0.106,0.505,0.191,\n\t\t0.564,0.541,0.713,-0.043,\n\t\t0.763,0.443,0.746,0.328,\n\t\t0.299,0.466,-0.099,-0.071,\n\t\t0.124,0.258,0.154,0.737,\n\t\t0.352,0.426,0.201,0.001,\n\t\t0.457,0.537,0.629,0.788,\n\n\t\t0.189,0.041,0.061,0.090,\n\t\t0.121,0.094,0.118,-0.013,\n\t\t0.040,0.123,0.055,0.029,\n\t\t0.156,0.154,0.133,0.200,\n\t\t0.119,0.109,0.160,0.081,\n\t\t0.029,0.011,0.170,0.059,\n\t\t0.105,0.138,0.107,0.164,\n\t\t0.009,0.124,-0.020,0.160,\n\n\t\t0.209,-0.096,0.185,0.563,\n\t\t0.495,0.158,0.269,0.389,\n\t\t0.095,0.566,0.091,0.299,\n\t\t0.393,0.349,-0.075,0.566,\n\t\t-0.052,0.180,0.390,0.488,\n\t\t0.307,-0.074,-0.007,0.490,\n\t\t0.497,0.312,0.338,-0.001,\n\t\t-0.079,0.617,0.460,0.242,\n\n\t\t0.156,-0.027,0.243,0.392,\n\t\t0.318,0.419,0.459,0.083,\n\t\t0.406,0.136,0.292,0.247,\n\t\t0.030,0.180,0.358,0.281,\n\t\t0.359,0.300,0.305,0.207,\n\t\t0.211,0.038,0.203,0.016,\n\t\t0.065,0.007,0.213,0.220,\n\t\t0.335,0.232,0.220,0.402,\n\n\t\t0.393,0.010,0.161,0.433,\n\t\t0.219,-0.012,0.315,0.304,\n\t\t0.393,0.176,0.536,0.260,\n\t\t0.282,-0.093,-0.054,0.335,\n\t\t0.360,0.006,0.191,0.507,\n\t\t0.143,0.505,0.561,0.468,\n\t\t-0.098,0.465,0.429,0.013,\n\t\t0.234,0.379,0.056,0.488,\n\n\t\t0.306,0.343,0.086,0.395,\n\t\t-0.065,-0.053,0.367,0.410,\n\t\t0.032,0.087,0.075,0.218,\n\t\t-0.056,0.274,0.313,-0.025,\n\t\t0.102,0.135,0.237,0.215,\n\t\t0.069,0.022,0.388,0.006,\n\t\t0.284,0.366,0.371,-0.057,\n\t\t-0.025,-0.032,0.226,0.355,\n\n\t\t0.357,0.400,0.101,0.461,\n\t\t-0.076,-0.061,0.428,0.478,\n\t\t0.038,0.101,0.088,0.255,\n\t\t-0.065,0.320,0.365,-0.029,\n\t\t0.119,0.158,0.276,0.250,\n\t\t0.080,0.025,0.452,0.008,\n\t\t0.331,0.427,0.432,-0.067,\n\t\t-0.029,-0.037,0.264,0.415,\n\n\t\t0.144,0.352,0.030,0.030,\n\t\t0.080,0.116,-0.044,0.081,\n\t\t0.029,0.189,0.459,0.394,\n\t\t0.342,0.086,0.200,0.548,\n\t\t0.180,0.291,0.485,-0.096,\n\t\t-0.060,0.030,0.302,0.458,\n\t\t0.192,0.293,-0.049,0.364,\n\t\t0.207,-0.014,0.158,0.250,\n\n\t\t0.108,0.264,0.022,-0.019,\n\t\t0.060,0.111,-0.033,0.101,\n\t\t0.022,0.101,0.341,0.295,\n\t\t0.256,0.073,0.150,0.411,\n\t\t0.087,0.192,0.363,-0.072,\n\t\t-0.014,0.022,0.233,0.307,\n\t\t0.184,0.220,-0.036,0.273,\n\t\t0.155,-0.010,0.105,0.187,\n\n\t\t0.378,0.228,0.196,-0.046,\n\t\t0.156,-0.055,0.017,0.055,\n\t\t0.065,0.255,0.115,0.395,\n\t\t-0.041,0.029,0.,0.125,\n\t\t0.352,0.346,0.178,0.305,\n\t\t0.020,0.237,0.397,0.311,\n\t\t0.215,0.048,0.344,-0.009,\n\t\t0.359,0.244,0.022,0.174,\n\n\t\t0.271,0.370,0.035,0.289,\n\t\t-0.098,0.306,0.307,0.070,\n\t\t-0.022,-0.074,0.407,0.093,\n\t\t0.414,-0.098,0.135,0.249,\n\t\t0.121,0.401,0.336,0.498,\n\t\t0.074,0.196,0.172,0.425,\n\t\t0.380,0.056,0.404,0.065,\n\t\t0.345,0.400,0.055,0.515,\n\n\t\t0.312,0.221,0.431,0.483,\n\t\t0.509,0.386,0.223,0.072,\n\t\t-0.031,0.192,-0.015,0.140,\n\t\t-0.088,0.378,0.164,0.002,\n\t\t0.250,0.106,0.093,0.023,\n\t\t0.076,0.325,0.017,0.442,\n\t\t0.186,-0.068,0.378,0.102,\n\t\t0.,0.468,0.541,0.412,\n\n\t\t0.192,-0.073,0.716,0.378,\n\t\t-0.115,-0.109,0.140,0.631,\n\t\t0.110,0.186,0.625,0.599,\n\t\t-0.030,0.803,0.500,0.177,\n\t\t0.765,0.919,-0.071,0.940,\n\t\t0.512,0.740,0.845,-0.140,\n\t\t0.542,0.368,0.436,0.811,\n\t\t-0.093,0.493,-0.071,0.274,\n\n\t\t0.240,-0.092,0.895,0.473,\n\t\t-0.144,-0.136,0.175,0.789,\n\t\t0.138,0.233,0.782,0.749,\n\t\t-0.038,1.004,0.625,0.222,\n\t\t0.957,1.149,-0.089,1.176,\n\t\t0.640,0.925,1.056,-0.176,\n\t\t0.678,0.460,0.546,1.014,\n\t\t-0.116,0.617,-0.089,0.342,\n\n\t\t0.277,0.404,0.278,0.093,\n\t\t0.330,0.039,0.368,0.411,\n\t\t0.293,0.337,0.066,0.328,\n\t\t0.258,0.210,0.278,0.009,\n\t\t0.398,0.219,0.056,0.339,\n\t\t-0.041,-0.034,0.100,0.081,\n\t\t-0.013,0.133,0.089,0.293,\n\t\t0.210,0.289,0.292,0.074,\n\n\t\t0.323,0.471,0.325,0.108,\n\t\t0.385,0.045,0.430,0.480,\n\t\t0.342,0.393,0.078,0.383,\n\t\t0.301,0.245,0.325,0.011,\n\t\t0.464,0.256,0.065,0.396,\n\t\t-0.048,-0.040,0.117,0.095,\n\t\t-0.015,0.155,0.104,0.342,\n\t\t0.245,0.337,0.340,0.087,\n\n\t\t0.201,0.222,0.110,0.174,\n\t\t0.205,0.110,0.203,0.114,\n\t\t0.238,0.168,0.170,0.195,\n\t\t0.086,0.135,0.162,0.126,\n\t\t0.111,0.092,0.144,0.171,\n\t\t0.097,0.162,0.117,0.393,\n\t\t0.151,0.166,0.110,0.175,\n\t\t0.140,0.232,0.244,0.201,\n\n\t\t0.009,0.071,0.047,0.199,\n\t\t0.142,0.134,0.245,-0.026,\n\t\t0.013,0.014,0.050,0.064,\n\t\t-0.022,0.144,0.251,0.094,\n\t\t0.150,0.179,0.056,0.267,\n\t\t0.005,0.197,0.122,-0.036,\n\t\t0.153,0.028,0.212,0.076,\n\t\t0.222,-0.037,0.273,-0.043,\n\n\t\t0.046,0.112,0.069,0.255,\n\t\t0.116,0.077,0.280,0.020,\n\t\t0.035,0.061,0.017,0.066,\n\t\t-0.011,0.156,0.253,0.095,\n\t\t0.121,0.161,0.041,0.239,\n\t\t0.004,0.161,0.125,0.032,\n\t\t0.128,0.063,0.237,0.110,\n\t\t0.264,0.013,0.271,-0.019,\n\n\t\t0.145,0.074,0.338,0.486,\n\t\t0.049,0.256,0.213,0.094,\n\t\t0.334,0.335,0.502,0.087,\n\t\t0.074,0.493,0.106,0.029,\n\t\t0.359,0.306,0.181,0.327,\n\t\t0.454,0.128,0.266,0.507,\n\t\t0.091,0.450,0.231,0.310,\n\t\t0.357,0.341,0.267,0.407,\n\n\t\t-0.003,0.104,-0.056,0.195,\n\t\t0.480,0.450,0.078,0.459,\n\t\t0.058,0.004,0.520,0.072,\n\t\t0.410,0.592,0.529,0.498,\n\t\t0.395,0.606,0.572,0.296,\n\t\t0.476,0.130,-0.025,-0.109,\n\t\t0.468,0.233,0.031,0.373,\n\t\t0.666,0.537,0.382,0.536,\n\n\t\t0.105,-0.095,0.644,0.325,\n\t\t-0.034,-0.105,-0.072,0.682,\n\t\t0.277,0.119,0.504,0.445,\n\t\t0.412,0.001,-0.031,0.063,\n\t\t-0.083,0.467,0.589,0.080,\n\t\t0.445,0.575,0.335,0.076,\n\t\t0.572,0.315,0.430,-0.035,\n\t\t0.195,0.080,0.621,0.438,\n\n\t\t0.318,0.506,0.620,0.242,\n\t\t0.415,0.767,0.097,0.432,\n\t\t0.587,0.104,0.304,0.599,\n\t\t0.551,0.414,-0.121,0.151,\n\t\t0.387,0.324,0.607,0.123,\n\t\t0.107,0.492,0.568,-0.038,\n\t\t-0.075,0.276,0.503,-0.118,\n\t\t0.215,0.416,0.610,0.684,\n\n\t\t0.279,0.096,-0.048,0.225,\n\t\t0.012,0.138,0.147,0.297,\n\t\t0.238,0.297,-0.053,0.147,\n\t\t0.274,0.052,0.135,-0.017,\n\t\t0.045,0.134,0.044,0.071,\n\t\t0.336,0.226,0.172,0.342,\n\t\t0.004,0.082,0.337,0.128,\n\t\t0.150,0.157,0.039,0.086,\n\n\t\t0.447,0.154,-0.077,0.360,\n\t\t0.020,0.221,0.235,0.476,\n\t\t0.382,0.476,-0.086,0.236,\n\t\t0.438,0.083,0.217,-0.027,\n\t\t0.072,0.215,0.070,0.115,\n\t\t0.538,0.362,0.275,0.548,\n\t\t0.006,0.132,0.540,0.205,\n\t\t0.241,0.252,0.062,0.137,\n\n\t\t0.429,0.154,-0.057,0.360,\n\t\t0.020,0.221,0.235,0.476,\n\t\t0.382,0.476,-0.086,0.236,\n\t\t0.462,0.083,0.217,-0.019,\n\t\t0.055,0.215,0.089,0.093,\n\t\t0.538,0.379,0.250,0.548,\n\t\t0.006,0.134,0.560,0.186,\n\t\t0.222,0.227,0.062,0.137,\n\n\t\t0.130,0.195,0.224,0.267,\n\t\t0.103,0.097,-0.052,0.149,\n\t\t0.452,-0.075,0.245,-0.021,\n\t\t-0.071,0.068,0.331,0.461,\n\t\t0.333,0.105,0.407,0.212,\n\t\t0.205,0.187,0.038,0.112,\n\t\t0.143,0.301,0.268,0.202,\n\t\t0.287,0.209,0.154,0.328,\n\n\t\t0.167,0.251,0.288,0.344,\n\t\t0.133,0.125,-0.067,0.192,\n\t\t0.581,-0.097,0.315,-0.027,\n\t\t-0.091,0.088,0.425,0.593,\n\t\t0.429,0.136,0.524,0.273,\n\t\t0.264,0.240,0.049,0.144,\n\t\t0.184,0.387,0.345,0.260,\n\t\t0.369,0.269,0.198,0.422,\n\n\t\t0.297,0.447,0.512,0.612,\n\t\t0.236,0.222,-0.119,0.342,\n\t\t1.033,-0.172,0.560,-0.049,\n\t\t-0.162,0.157,0.756,1.055,\n\t\t0.763,0.241,0.932,0.486,\n\t\t0.470,0.427,0.088,0.257,\n\t\t0.327,0.689,0.613,0.462,\n\t\t0.656,0.478,0.352,0.751,\n\n\t\t0.050,0.131,0.112,0.043,\n\t\t0.194,0.199,0.400,0.267,\n\t\t0.443,0.078,0.182,0.098,\n\t\t0.174,0.470,0.174,0.464,\n\t\t-0.061,-0.018,0.302,0.427,\n\t\t0.132,0.341,0.401,0.279,\n\t\t-0.010,-0.079,0.231,0.328,\n\t\t0.250,0.424,0.109,0.389,\n\n\t\t0.065,0.197,0.142,0.056,\n\t\t0.199,0.230,0.514,0.351,\n\t\t0.570,0.100,0.234,0.126,\n\t\t0.224,0.618,0.237,0.597,\n\t\t-0.073,-0.023,0.362,0.552,\n\t\t0.190,0.438,0.525,0.359,\n\t\t0.003,-0.091,0.297,0.422,\n\t\t0.322,0.545,0.141,0.489,\n\n\t\t0.310,0.253,0.559,0.,\n\t\t0.268,0.735,0.014,0.496,\n\t\t0.819,0.749,0.539,0.832,\n\t\t0.167,0.755,-0.075,0.834,\n\t\t-0.055,0.786,0.608,0.380,\n\t\t0.046,-0.043,0.235,0.402,\n\t\t0.781,0.368,0.085,0.086,\n\t\t0.024,0.249,0.813,0.170,\n\n\t\t0.371,-0.099,0.254,-0.083,\n\t\t0.041,0.461,0.029,0.442,\n\t\t0.120,0.184,0.099,0.147,\n\t\t-0.056,0.309,0.428,0.144,\n\t\t-0.038,0.314,0.392,0.275,\n\t\t-0.060,-0.084,0.308,0.052,\n\t\t0.460,0.318,0.086,0.409,\n\t\t0.004,0.383,0.247,0.498,\n\n\t\t0.224,0.176,0.282,0.188,\n\t\t0.237,-0.053,0.330,0.156,\n\t\t-0.015,0.153,0.097,0.276,\n\t\t0.128,-0.013,0.330,0.101,\n\t\t0.163,0.248,0.275,0.130,\n\t\t0.284,0.312,0.289,0.310,\n\t\t0.352,-0.068,0.109,0.309,\n\t\t0.278,0.310,0.021,-0.060,\n\n\t\t0.299,0.234,0.376,0.251,\n\t\t0.316,-0.071,0.440,0.208,\n\t\t-0.020,0.204,0.130,0.368,\n\t\t0.171,-0.017,0.440,0.135,\n\t\t0.218,0.331,0.367,0.174,\n\t\t0.379,0.416,0.386,0.414,\n\t\t0.469,-0.091,0.146,0.412,\n\t\t0.371,0.413,0.028,-0.081,\n\n\t\t0.159,0.820,0.112,0.509,\n\t\t0.539,-0.065,-0.047,0.668,\n\t\t0.428,0.326,0.045,0.542,\n\t\t0.133,0.596,-0.130,0.323,\n\t\t-0.086,0.301,0.770,0.694,\n\t\t0.083,0.175,0.144,-0.047,\n\t\t0.189,0.217,0.458,0.627,\n\t\t-0.004,0.666,0.658,-0.009,\n\n\t\t0.171,0.884,0.120,0.548,\n\t\t0.581,-0.070,-0.051,0.720,\n\t\t0.462,0.351,0.049,0.583,\n\t\t0.143,0.642,-0.140,0.348,\n\t\t-0.093,0.324,0.829,0.747,\n\t\t0.090,0.189,0.156,-0.051,\n\t\t0.203,0.234,0.493,0.675,\n\t\t-0.004,0.717,0.708,-0.010,\n\n\t\t0.285,0.167,0.155,0.071,\n\t\t-0.047,-0.040,0.164,0.091,\n\t\t0.190,0.316,0.189,-0.029,\n\t\t-0.054,0.121,0.073,0.288,\n\t\t0.324,0.024,0.159,0.175,\n\t\t0.058,0.026,0.117,0.273,\n\t\t0.237,0.329,0.141,0.335,\n\t\t-0.019,-0.005,0.078,0.203,\n\n\t\t0.401,0.255,0.187,0.156,\n\t\t-0.066,-0.048,0.230,0.132,\n\t\t0.268,0.445,0.266,-0.041,\n\t\t-0.099,0.127,0.142,0.405,\n\t\t0.456,0.064,0.236,0.247,\n\t\t0.058,0.177,0.165,0.410,\n\t\t0.334,0.463,0.198,0.472,\n\t\t-0.026,-0.083,0.109,0.276,\n\n\t\t0.229,0.145,0.063,0.116,\n\t\t-0.038,-0.009,0.064,0.094,\n\t\t0.139,0.254,0.152,-0.066,\n\t\t-0.010,0.127,0.062,0.215,\n\t\t0.260,0.040,0.134,0.141,\n\t\t0.048,0.101,0.094,0.234,\n\t\t0.191,0.236,0.088,0.330,\n\t\t-0.015,-0.047,0.108,0.157,\n\n\t\t0.287,0.182,0.079,0.146,\n\t\t-0.047,-0.011,0.080,0.118,\n\t\t0.174,0.318,0.190,-0.082,\n\t\t-0.012,0.159,0.077,0.269,\n\t\t0.326,0.050,0.167,0.176,\n\t\t0.060,0.126,0.118,0.293,\n\t\t0.238,0.296,0.110,0.413,\n\t\t-0.019,-0.059,0.135,0.196,\n\n\t\t0.344,0.218,0.095,0.175,\n\t\t-0.057,-0.014,0.096,0.142,\n\t\t0.209,0.381,0.228,-0.099,\n\t\t-0.015,0.191,0.093,0.323,\n\t\t0.391,0.061,0.201,0.212,\n\t\t0.072,0.152,0.142,0.352,\n\t\t0.286,0.355,0.133,0.496,\n\t\t-0.022,-0.071,0.162,0.236,\n\n\t\t0.401,0.255,0.111,0.204,\n\t\t-0.066,-0.016,0.112,0.166,\n\t\t0.244,0.445,0.266,-0.115,\n\t\t-0.017,0.223,0.108,0.377,\n\t\t0.456,0.071,0.234,0.247,\n\t\t0.085,0.177,0.165,0.410,\n\t\t0.334,0.414,0.155,0.578,\n\t\t-0.026,-0.083,0.189,0.275,\n\n\t\t0.126,0.559,-0.082,0.389,\n\t\t0.219,0.361,0.483,0.399,\n\t\t0.523,0.411,0.450,0.628,\n\t\t0.825,0.026,0.275,0.864,\n\t\t0.098,0.709,0.441,0.480,\n\t\t-0.126,0.882,0.477,0.337,\n\t\t0.658,-0.035,0.749,0.418,\n\t\t0.705,0.318,0.035,-0.062,\n\n\t\t0.136,0.602,-0.089,0.419,\n\t\t0.236,0.389,0.521,0.430,\n\t\t0.564,0.442,0.484,0.676,\n\t\t0.888,0.028,0.297,0.930,\n\t\t0.105,0.763,0.475,0.517,\n\t\t-0.136,0.949,0.514,0.363,\n\t\t0.708,-0.038,0.806,0.450,\n\t\t0.760,0.342,0.037,-0.066,\n\n\t\t0.107,0.473,-0.070,0.329,\n\t\t0.186,0.305,0.409,0.337,\n\t\t0.443,0.347,0.380,0.531,\n\t\t0.698,0.022,0.233,0.731,\n\t\t0.083,0.600,0.373,0.406,\n\t\t-0.107,0.791,0.404,0.156,\n\t\t0.556,-0.030,0.633,0.354,\n\t\t0.597,0.269,0.029,-0.052,\n\n\t\t-0.132,0.853,0.890,0.233,\n\t\t0.761,0.700,-0.129,0.502,\n\t\t0.614,0.681,0.254,-0.139,\n\t\t-0.007,0.182,0.253,0.224,\n\t\t0.482,-0.043,0.459,0.037,\n\t\t0.388,0.770,0.781,0.470,\n\t\t0.563,0.324,-0.016,0.462,\n\t\t0.597,0.818,0.489,0.627,\n\n\t\t-0.153,0.984,1.027,0.269,\n\t\t0.878,0.808,-0.149,0.580,\n\t\t0.709,0.786,0.293,-0.160,\n\t\t-0.008,0.211,0.292,0.258,\n\t\t0.557,-0.049,0.530,0.042,\n\t\t0.448,0.888,0.902,0.542,\n\t\t0.649,0.374,-0.019,0.533,\n\t\t0.689,0.944,0.564,0.724,\n\n\t\t0.022,-0.045,0.128,0.018,\n\t\t0.049,0.128,0.073,0.239,\n\t\t0.245,0.136,0.273,0.181,\n\t\t0.090,0.074,0.015,0.169,\n\t\t0.175,0.033,0.095,0.059,\n\t\t0.163,0.226,0.159,-0.046,\n\t\t0.014,0.226,0.098,0.014,\n\t\t0.252,0.033,0.163,0.224,\n\n\t\t0.033,-0.067,0.192,0.027,\n\t\t0.074,0.192,0.109,0.359,\n\t\t0.368,0.204,0.410,0.272,\n\t\t0.135,0.111,0.022,0.253,\n\t\t0.263,0.050,0.143,0.089,\n\t\t0.244,0.340,0.238,-0.069,\n\t\t0.022,0.340,0.148,0.022,\n\t\t0.378,0.050,0.244,0.336,\n\n\t\t0.067,-0.135,0.384,0.055,\n\t\t0.149,0.385,0.219,0.718,\n\t\t0.737,0.409,0.820,0.544,\n\t\t0.270,0.222,0.045,0.507,\n\t\t0.526,0.100,0.287,0.179,\n\t\t0.489,0.680,0.477,-0.139,\n\t\t0.044,0.680,0.296,0.044,\n\t\t0.757,0.100,0.489,0.672,\n\n\t\t0.043,0.829,1.251,-0.356,\n\t\t0.843,0.995,0.002,0.594,\n\t\t0.774,0.791,0.938,1.052,\n\t\t0.875,0.479,-0.061,0.605,\n\t\t0.481,1.076,0.193,0.537,\n\t\t0.478,0.602,-0.163,0.846,\n\t\t0.150,0.989,0.374,0.892,\n\t\t0.042,0.692,0.023,0.266,\n\n\t\t0.037,0.725,1.094,-0.312,\n\t\t0.738,0.871,0.002,0.520,\n\t\t0.678,0.692,0.821,0.920,\n\t\t0.765,0.419,-0.054,0.529,\n\t\t0.421,0.941,0.169,0.470,\n\t\t0.418,0.526,-0.143,0.740,\n\t\t0.132,0.865,0.327,0.780,\n\t\t0.037,0.605,0.020,0.233,\n\n\t\t0.369,-0.089,0.028,0.472,\n\t\t0.158,0.389,-0.067,0.235,\n\t\t-0.029,0.145,-0.094,0.517,\n\t\t0.459,0.154,0.531,0.207,\n\t\t0.245,0.311,0.119,0.182,\n\t\t0.051,0.526,-0.013,0.041,\n\t\t0.092,0.137,0.138,0.357,\n\t\t0.222,0.297,0.261,0.492,\n\n\t\t0.534,-0.129,0.041,0.683,\n\t\t0.228,0.562,-0.097,0.340,\n\t\t-0.043,0.209,-0.136,0.746,\n\t\t0.663,0.222,0.768,0.299,\n\t\t0.354,0.449,0.172,0.263,\n\t\t0.074,0.760,-0.020,0.060,\n\t\t0.133,0.198,0.200,0.516,\n\t\t0.320,0.429,0.378,0.710,\n\n\t\t0.285,0.349,0.231,0.622,\n\t\t0.300,0.315,0.515,0.361,\n\t\t0.605,0.562,0.175,0.359,\n\t\t-0.010,0.584,0.461,0.218,\n\t\t0.267,-0.123,-0.008,0.319,\n\t\t0.331,0.486,0.157,0.601,\n\t\t0.188,0.093,0.200,0.205,\n\t\t0.052,0.420,0.050,0.226,\n\n\t\t0.373,0.037,0.078,0.187,\n\t\t0.032,0.284,0.174,0.408,\n\t\t0.248,0.205,0.676,0.354,\n\t\t0.226,0.021,0.443,0.376,\n\t\t0.228,0.128,0.152,0.407,\n\t\t0.095,0.236,0.360,0.049,\n\t\t0.234,0.114,0.316,0.383,\n\t\t0.230,0.337,0.313,0.078,\n\n\t\t0.154,0.166,0.174,0.189,\n\t\t0.003,0.144,0.144,0.190,\n\t\t0.228,0.301,0.086,0.128,\n\t\t0.148,0.186,0.146,0.166,\n\t\t0.151,0.093,0.058,0.268,\n\t\t0.066,0.089,0.152,0.287,\n\t\t0.087,0.163,0.249,0.234,\n\t\t0.127,0.129,0.182,0.088,\n\n\t\t0.185,0.199,0.209,0.227,\n\t\t0.004,0.173,0.173,0.228,\n\t\t0.274,0.361,0.103,0.153,\n\t\t0.177,0.223,0.175,0.199,\n\t\t0.182,0.112,0.070,0.322,\n\t\t0.080,0.106,0.183,0.345,\n\t\t0.105,0.196,0.299,0.280,\n\t\t0.153,0.155,0.219,0.105,\n\n\t\t0.295,0.317,0.424,0.314,\n\t\t0.294,0.337,0.209,0.440,\n\t\t0.700,1.074,0.236,0.641,\n\t\t0.411,0.718,0.269,0.388,\n\t\t0.289,0.240,0.252,0.821,\n\t\t0.242,0.480,0.394,0.973,\n\t\t0.302,0.436,0.253,0.526,\n\t\t0.249,0.549,0.617,0.424,\n\n\t\t0.331,0.251,0.262,0.268,\n\t\t0.174,0.167,0.145,0.344,\n\t\t0.388,0.597,0.181,0.448,\n\t\t0.197,0.348,0.211,0.287,\n\t\t0.149,0.179,0.176,0.307,\n\t\t0.190,0.364,0.185,0.504,\n\t\t0.189,0.302,0.166,0.394,\n\t\t0.176,0.295,0.390,0.335,\n\n\t\t0.352,0.236,0.313,0.197,\n\t\t0.140,0.443,0.252,0.394,\n\t\t0.450,0.567,0.233,0.387,\n\t\t0.273,0.489,0.190,0.374,\n\t\t0.215,0.241,0.264,0.387,\n\t\t0.308,0.373,0.263,0.499,\n\t\t0.225,0.252,0.168,0.344,\n\t\t0.179,0.324,0.391,0.327,\n\n\t\t0.389,0.252,0.399,0.251,\n\t\t0.178,0.482,0.321,0.501,\n\t\t0.573,0.721,0.283,0.457,\n\t\t0.324,0.591,0.191,0.409,\n\t\t0.273,0.289,0.403,0.493,\n\t\t0.392,0.495,0.318,0.636,\n\t\t0.286,0.263,0.214,0.412,\n\t\t0.282,0.368,0.432,0.424*/);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 2) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    int r = int(fragCoord.y);\n    int c = int(fragCoord.x);\n    fragColor = vec4(patterns[32*c+r]);\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 112, 112, 155], [157, 157, 214, 214, 428]], "test": "untested"}
{"id": "fsscRr", "name": "Rigid Body Test 123", "author": "wyatt", "description": "That was hard !", "tags": ["test"], "likes": 12, "viewed": 348, "published": 3, "date": "1641611393", "time_retrieved": "2024-07-30T17:11:15.092412", "image_code": "Main\n//if (iFrame % 4 > 0) discard;\nQ = vec4(0);\nfor (float i = 0.; i < N; i++) {\n    vec4 a = A(vec2(i,0)+.5);\n    vec4 at= A(vec2(i,1)+.5);\n    vec2 aw = size(i)/2.;\n    float m = map(U*1.1-.05*R.x,a,at,aw);\n    if (m<=0.) Q += i+1.;\n}\nQ = 1.-sin(Q+vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I; vec4 M;\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) {R=iResolution.xy;T=iTime;I=iFrame;M=iMouse;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define N 25.\n\n\nvec2 size (float i) {\n    vec2 s = vec2(1,6.+.5*i)*.02*R;\n    return s;\n}\n\n#define dt .2\nvec2 vel (vec2 p, vec4 a, vec4 t) {\n    vec2 w = p.xy-a.xy;\n    if (length(w)>0.) w = vec2(-w.y,w.x);\n    return a.zw + w*t.y;\n}\nfloat map ( vec2 p, vec4 a, vec4 t, vec2 b )\n{ //iquilezles.org/articles/distfunctionsl\n  p = (p-a.xy)*ei(-t.x);\n  vec2 q = (abs(p) - b);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 norm (vec2 p, vec4 a, vec4 t, vec2 b)\n{   \n    float n = map(p+vec2(0,1),a,t,b),\n          e = map(p+vec2(1,0),a,t,b),\n          s = map(p-vec2(0,1),a,t,b),\n          w = map(p-vec2(1,0),a,t,b);\n    return .5*vec2(e-w,n-s);\n}", "buffer_a_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0,-1e-2);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw -= 1e-3*(Q.xy-M.xy*1.1-.05*R.x)*exp(-.01*length(Q.xy-M.xy*1.1-.05*R));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(U.x*size.x*1.7,size.y+U.x*size.x*.5,0,0);\n        t = vec4(U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0,-1e-2);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw -= 1e-3*(Q.xy-M.xy*1.1-.05*R.x)*exp(-.01*length(Q.xy-M.xy*1.1-.05*R));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(U.x*size.x*1.7,size.y+U.x*size.x*.5,0,0);\n        t = vec4(U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0,-1e-2);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw -= 1e-3*(Q.xy-M.xy*1.1-.05*R.x)*exp(-.01*length(Q.xy-M.xy*1.1-.05*R));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(U.x*size.x*1.7,size.y+U.x*size.x*.5,0,0);\n        t = vec4(U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n\n    if (U.y>4.)discard;\n    Q = A(vec2(U.x,.5));\n    vec4 t = A(vec2(U.x,1.5));\n    vec4 oQ = A(vec2(U.x,2.5));\n    vec4 ot = A(vec2(U.x,3.5));\n    vec2 w = size(floor(U.x));\n    \n    if (U.y<2.) {\n        vec2 f = vec2(0,-1e-2);\n        float tor = 0.;\n        float h = 0.;\n        for(float j = 0.; j < N; j++) if (j!=floor(U.x)) {\n            vec4 b = A(vec2(j,0)+.5);\n            vec4 bt = A(vec2(j,1)+.5);\n            vec2 bw = size(j);\n            for (float x = 0.; x<=1.; x++)\n            for (float y = 0.; y<=1.; y++)\n            {\n                { \n                    vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n                    // my point in their box\n                    float m = map(q,b,bt,.5*bw);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n                { // their point in my box\n                    vec2 q = bw*(vec2(x,y)-.5)*ei(bt.x)+b.xy;\n                    float m = map(q,Q,t,.5*w);\n                    if (m<0.) {\n                        vec2 r = q-Q.xy;\n                        vec2 v = vel(q,b,bt)-vel(q,Q,t);\n                        float l = length(r);\n                        vec2 im = norm(q,b,bt,.5*bw)+v;\n                        tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                        f += im*abs(dot(normalize(r),normalize(im)));\n                        h += 1.;\n                    }\n                }\n            }\n        }\n        for (float x = 0.; x<=1.; x++)\n        for (float y = 0.; y<=1.; y++)\n        {\n            vec2 q = w*(vec2(x,y)-.5)*ei(t.x)+Q.xy;\n            vec4 b = vec4(.5*R.xy,0,0);\n            float m = -map(q,b,vec4(0),b.xy);\n            if (m<0.) {\n                vec2 r = q-Q.xy;\n                vec2 v = vel(q,b,vec4(0))-vel(q,Q,t);\n                float l = length(r);\n                vec2 im = -norm(q,b,vec4(0),.5*R.xy)+v;\n                tor -= dot(r,vec2(-im.y,im.x))/(w.x*w.y);\n                f += im*abs(dot(normalize(r),normalize(im)));\n                h += 1.;\n            }\n        }\n        if (h>0.) f/=h, tor/=h;\n        Q.zw += dt*(f);\n        Q.xy += dt*(.5*f+Q.zw);\n        t.y += dt*(tor);\n        t.x += dt*(.5*tor+t.y);\n        if (M.z>0.) Q.zw -= 1e-3*(Q.xy-M.xy*1.1-.05*R.x)*exp(-.01*length(Q.xy-M.xy*1.1-.05*R));\n        if (length(Q.zw)>1./dt) Q.zw = 1./dt*normalize(Q.zw);\n        if (abs(t.y)>dt) t.y = dt*sign(t.y);\n    }\n    \n    if(iFrame < 1) {\n        vec2 size = size(floor(U.x));\n        Q = vec4(U.x*size.x*1.7,size.y+U.x*size.x*.5,0,0);\n        t = vec4(U.x/N,0,0,0);\n    }\n    if (mod(U.y,2.)>1.) Q = t;\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsscRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7sfyzn", "name": "Spiral Heart Beat", "author": "ppsdf", "description": "My first shader, strongly inspired from @iq https://www.shadertoy.com/view/XsXSz4 and https://iquilezles.org/articles/distfunctions2d/distfunctions2d.htm\n\nImprovement & advice are welcome :)", "tags": ["spiral", "heart"], "likes": 3, "viewed": 280, "published": 3, "date": "1641597556", "time_retrieved": "2024-07-30T17:11:15.980039", "image_code": "float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdSpiral( vec2 p, float r )\n{\n    p.x *= (0.8+0.4*p.y*p.y);\n    //p.x = sign(p.x)*pow(abs(p.x),0.7);\n    return length(p)/(atan(abs(p.x),p.y)) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    m *= 1.5;\n\n    // distance\n    float ampl = amplitude(iTime);\n    //ampl = 0.;\n    float r = 0.65*(1.+0.1*ampl);\n    \n\t//float d = sdCircle(p,r);\n    vec2 offset = vec2(0.,-0.9);\n    p += offset;\n    float d = sdSpiral(p,r);\n    \n    // color\n#if 0\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n#else\n    vec3 col = (d>=0.0) ? vec3(0.2,0.8,0.8) : vec3(0.8,0.2,0.8);\n\tcol *= exp2(-2.0*abs(d));\n    col = mix(col,vec3(1.20),exp2(-22.0*abs(d)));\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(d)) );\n    col *= 1.0 + 0.5*smoothstep(-0.4,0.4,cos(100.0*d)); // comment to get uniform color\n#endif\n\n    // interactivity\n    if( iMouse.z>0.001 )\n    {\n    //d = sdCircle(m-p,r);\n    m += offset;\n    d = sdSpiral(m,r);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    float t = mod(time,T);\n    float c = cubicPulse(0.5,0.5,t/T);\n    //c=1.;\n    float a = amplitude(t)*pow(c,0.1);\n    a = 2.*a*exp(0.7*a);\n    //a = 1.0;\n    float y = sin(twopi*60.0*t)*a;\n    return vec2( y );\n}", "sound_inputs": [], "common_code": "float pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b)/(pow(a,a)*pow(b,b));\n    return k*pow(x,a)*pow(1.0-x,b);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nconst float T = 1.00; // pulse periode\nconst float pi = 3.141592653589793;\nconst float twopi = 6.283185307179586;\n\n\nfloat amplitude(float time)\n{\n    float T = 1.;\n    float t = mod(time,T);\n    float ampl = pcurve(t/T, 0.1,4.);\n    float ampl2 = pcurve(mod(t/T-0.15,1.), 0.1,4.);\n    return max(ampl,ampl2);\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [65, 65, 100, 100, 220], [222, 222, 279, 279, 1539]], "test": "untested"}
{"id": "sdXczr", "name": "Simple Interference Feedback", "author": "tarnith", "description": "Playing with layers of feedback sinusoid intereference patterns", "tags": ["interference", "feedback"], "likes": 13, "viewed": 306, "published": 3, "date": "1641589949", "time_retrieved": "2024-07-30T17:11:16.845725", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.xy; \n\tfragColor = pow(texture(iChannel1,uv), vec4(1./2.2) ); \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texuv = uv;\n    texuv -= .5;\n    texuv *= 2.;\n    texuv += .5;\n    uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    float waves = 0.;\n    waves -= w;\n    waves -= f*gainScalar;\n    col = vec3(waves);\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texuv = uv;\n    texuv -= .5;\n    texuv *= 1.001;\n    texuv += .5;\n    uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n  \n    vec3 col = vec3(0.);\n    float waves = 0.;\n    waves -= f*gainScalar;\n    waves -= f2*gainScalar;\n    col = vec3(waves);\n    fragColor = vec4(col,1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define gainScalar .8\n#define time iTime\n#define f texture(iChannel0,texuv).r\n#define f2 texture(iChannel1,texuv).r\n#define w sin(length(uv)*time*2.);", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 180]], "test": "untested"}
{"id": "7dXyzn", "name": "Neon ripples", "author": "kmaork", "description": "This is not what I planned to make...\nUse the mouse to explore.", "tags": ["2d", "interactive", "animation"], "likes": 10, "viewed": 459, "published": 3, "date": "1641579469", "time_retrieved": "2024-07-30T17:11:17.723378", "image_code": "float getBrightness(float x) {\n    return powerCycle(((x - 0.5) * 500.) + 0.5, 6.);\n}\n\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float noise = sqrt(fetchState(STATE_NOISE_X, fragCoord.x) * fetchState(STATE_NOISE_Y, fragCoord.y));\n    float br = getBrightness(noise);\n    fragColor = vec4(hsb2rgb(vec3(noise * 3. + 0.5, .8, br)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float SPEED = 0.2;\nconst int NUM_WAVES = 5;\nconst float[NUM_WAVES] X_FREQS = float[](4., 7., 9., 13., 17.);\nconst float[NUM_WAVES] X_DIRECTIONS = float[](0.1, 0.5, -0.2, 0.3, -0.4);\nconst float[NUM_WAVES] Y_FREQS = float[](5., 9., 10., 13., 16.);\nconst float[NUM_WAVES] Y_DIRECTIONS = float[](0.5, -0.3, 0.1, -0.4, 0.2);\nconst float DIV = 1. / float(NUM_WAVES);\n\nfloat getNoise(in float[NUM_WAVES] freqs, in float[NUM_WAVES] directions, in float pos, in float dp) {\n    float noise = 0.;\n    for (int i = 0; i < NUM_WAVES; ++i) {\n        float offset = SPEED * iTime * directions[i] + dp;\n        noise += sin((pos + offset) * freqs[i]) / 2. / freqs[i] + 0.5; //powerCycle((pos + offset) * freqs[i], 6.8);\n    }\n    return noise * DIV;\n}\n\nbool mouseClicked() {\n    return iMouse.w > 0.;\n}\n\nbool mouseDown() {\n    return (iMouse.z > 0.) && !mouseClicked();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float val;\n    vec2 offset = iFrame == 0 ? vec2(0, 0) : \n                                vec2(fetchState(STATE_CONTROL, CONTROL_OFFSET_X), fetchState(STATE_CONTROL, CONTROL_OFFSET_Y));\n    switch(int(fragCoord.y)) {\n    case STATE_NOISE_X:\n        val = getNoise(X_FREQS, X_DIRECTIONS, fragCoord.x / iResolution.x, offset.x);\n        break;\n    case STATE_NOISE_Y:\n        val = getNoise(Y_FREQS, Y_DIRECTIONS, fragCoord.x / iResolution.x, offset.y);\n        break;\n    case STATE_CONTROL:\n        switch (int(fragCoord.x)) {\n            case CONTROL_LAST_MOUSE_X:\n                val = iMouse.x;\n                break;\n            case CONTROL_LAST_MOUSE_Y:\n                val = iMouse.y;\n                break;\n            case CONTROL_OFFSET_X:\n                val = offset.x - (mouseDown() ? iMouse.x - fetchState(STATE_CONTROL, CONTROL_LAST_MOUSE_X) : 0.) / iResolution.x;\n                break;\n            case CONTROL_OFFSET_Y:\n                val = offset.y - (mouseDown() ? iMouse.y - fetchState(STATE_CONTROL, CONTROL_LAST_MOUSE_Y) : 0.) / iResolution.x;\n                break;\n        }\n        break;\n    default:\n        return;\n    }\n    fragColor = vec4(val, 0., 0., 0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int STATE_NOISE_X = 0;\nconst int STATE_NOISE_Y = 1;\nconst int STATE_CONTROL = 2;\nconst int CONTROL_LAST_MOUSE_X = 0;\nconst int CONTROL_LAST_MOUSE_Y = 1;\nconst int CONTROL_OFFSET_X = 2;\nconst int CONTROL_OFFSET_Y = 3;\n\n#define fetchState(bank, idx) texelFetch(iChannel0, ivec2(float(idx), float(bank) + 0.5), 0).x\n\nfloat powerCycle(in float x, in float deg) {\n    float w = sin(x);\n    float mag = pow(abs(w), 1. / deg);\n    return 0.5 * ((w > 0. ? mag : -mag) + 1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 85], [87, 87, 111, 111, 271], [273, 273, 328, 328, 539]], "test": "untested"}
{"id": "ssXyzn", "name": "stair pyramid", "author": "jorge2017a2", "description": "stair pyramid", "tags": ["stairpyramid"], "likes": 6, "viewed": 223, "published": 3, "date": "1641577222", "time_retrieved": "2024-07-30T17:11:18.603026", "image_code": "//----------image\n//por jorge2017a1-\n//stair pyramid---7-ene-2022\n//referencia IQ\n//https://www.shadertoy.com/view/7tKSWt\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   vec3 p0=p;\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.y=p.y-3.2;\n    \n    float  d1a=sdStairs(p.xy-vec2(-10.0,-3.0), vec2(1.,1.0), 10.0 );\n    float  d1b=sdStairs(vec2(-p.x,p.y)-vec2(-10.0,-3.0), vec2(1.,1.0), 10.0 );\n    \n    float  d2a=sdStairs(vec2(-p.z,p.y)-vec2(-10.0,-3.0), vec2(1.,1.0), 10.0 );\n    float  d2b=sdStairs(p.zy-vec2(-10.0,-3.0), vec2(1.,1.0), 10.0 );\n    float d2=sdBox( p, vec3(15.0,15.0,15.0) );\n    \n    d1a= intersectSDF(d1a, d2);\n    d1b= intersectSDF(d1b, d2);\n    d2a= intersectSDF(d2a, d2);\n    d2b= intersectSDF(d2b, d2);\n    \n    float d2a1a= intersectSDF(d2a, d1a);\n    float d2a1b= intersectSDF(d2a, d1b);\n    float d2b1b= intersectSDF(d2b, d1b);\n    float d2b1a= intersectSDF(d2b, d1a);\n    \n    res =opU3(res, vec3(d2a1a,3.0,-1.0));\n    res =opU3(res, vec3(d2a1b,2.0,-1.0));\n    res =opU3(res, vec3(d2b1b,4.0,-1.0));\n    res =opU3(res, vec3(d2b1a,5.0,-1.0));\n    //cuarto superior    \n    float d3a=sdBox( p-vec3(0.0,7.0,0.0), vec3(2.0,0.25,2.0) );\n    float d3b=sdBox( p-vec3(0.0,8.5,0.0), vec3(1.5,1.5,1.5) );\n    float d3c=sdBox( p-vec3(0.0,9.0,0.0), vec3(2.0,0.25,2.0) );\n    float sds1=sdSphere(p-vec3(0.0,12.0,0.0), 2.0 );\n    \n    res =opU3(res, vec3(d3a,6.0,-1.0));\n    res =opU3(res, vec3(d3b,6.0,-1.0));\n    res =opU3(res, vec3(d3c,6.0,-1.0));\n    res =opU3(res, vec3(sds1,2.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=20.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,15.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-10.0, 20.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-10.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n   \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 620, 620, 641], [642, 642, 674, 674, 758], [760, 804, 851, 851, 878], [879, 879, 922, 922, 949], [950, 950, 998, 998, 1026], [1027, 1065, 1101, 1101, 1146], [1147, 1212, 1246, 1246, 1342], [1343, 1343, 1377, 1377, 1468], [1469, 1469, 1503, 1503, 1594], [1595, 1595, 1629, 1629, 1724], [1726, 1726, 1751, 1751, 1770], [1772, 1772, 1825, 1837, 2717], [2720, 2720, 2745, 2745, 4188], [4190, 4190, 4214, 4214, 4376], [4378, 4378, 4427, 4427, 5058], [5060, 5060, 5096, 5096, 5341], [5343, 5343, 5380, 5380, 5654], [5656, 5656, 5739, 5739, 6313], [6315, 6315, 6408, 6408, 6538], [6540, 6540, 6572, 6572, 6769], [6771, 6819, 6847, 6847, 7035], [7037, 7037, 7084, 7084, 7310], [7312, 7312, 7405, 7405, 7740], [7743, 7743, 7770, 7770, 7880], [7882, 7882, 7940, 7940, 7992], [7995, 7995, 8018, 8018, 8158], [8160, 8160, 8191, 8191, 8903], [8905, 8905, 8942, 8942, 9212], [9215, 9215, 9272, 9272, 9877]], "test": "untested"}
{"id": "slySWV", "name": "GPU manufacturer detector", "author": "archee", "description": "This will display your GPU manufacturer's name if known, and a 16bit hash. Texture filters and math functions are implemented differently by each manufacturer. Please comment your hash, if no manufacturer's name is displayed.", "tags": ["text", "gpu"], "likes": 31, "viewed": 1353, "published": 3, "date": "1641574573", "time_retrieved": "2024-07-30T17:11:19.370973", "image_code": "/*\nA new concept with better hash function here:\nhttps://www.shadertoy.com/view/7ssyzr\n\nReading from texture is necessary, because otherwise it could be calculated compilation time.\nCPUs had a standard requiring all bits accuracy floating point math in + - / * sqrt, \nwhich is useful when developing multiplayer physics games. But SIMD functions are only required for accuracy within a certain range. so have to avoid those.\n\nGPUs have no such standard, they are just accurate to certain range.\nReciptrocal, sqrt, sin all probably work with constants  in a table for a polynom. \nJust one of these functions should be enough to tell what GPU you are using. \n*/\nuint hardwareHash()\n{\n    vec3 a = normalize(texture(iChannel1,vec2(0.50,0.52)).xyz);\n    a.x += sin(texture(iChannel1,vec2(0.51,0.52)).x)*0.1;\n    a.x += sqrt(texture(iChannel1,vec2(0.52,0.52)).x)*0.1;\n    return uint(fract(abs(a.x))*65536.*256.)&0xFFffu;\n}\n\n// font and printing\nvec2 printCursor;\nfloat printColor=0.;\n#define C(c) printColor+= char(printCursor,c).x;printCursor.x-=.5\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn texture( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ) );\n}\nvoid printHex(uint i)\n{\n    for(int j=3;j>=0;j--)\n    {\n        uint digit = uint((i>>(j*4))&15u);\n        C(int((digit<=9u?48u:65u-10u)+digit));\n    }\n}\n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    uv /= iResolution.y;\n    printCursor = ( uv - vec2(.1,0.4))*5.;\n    \n    uint hash = hardwareHash();\n    switch(int(hash))\n    {\n    // nVidia\n    case 0x204E:  // nVidia  (pascal, turion, ampere)\n    case 0x263F:  // nVidia RTX 2080 (turion, why different?)\n        C(_n);C(_V);C(_i);C(_d);C(_i);C(_a);\n        break;\n    \n    // AMD\n    case 0x23CB: // AMD GCN4  Win AngleDX, Linux  (rx 500 series, Vega 8)\n    case 0x2347: // AMD GCN4  Win OpenGL          (rx 500 series, Vega 8)\n    case 0x2148: // AMD GCN2    (r7 250 ultimate)\n    case 0x21C6: // AMD Terascale3  (A4-4000 APU)\n        C(_A);C(_M);C(_D);\n        break;\n        \n    // Intel\n    case 0x3DF3: // intel UHD 11th gen\n    case 0x2386: // Intel UHD 7th gen\n    case 0x1CB1: // Intel old (eg. HD graphics 3000) \n        C(_I);C(_n);C(_t);C(_e);C(_l);\n        break;\n        \n    // Mali   (Samsung, Mediatek and most ARM chipset)\n    case 0x7B5C:  // MALI-G52,G72\n    case 0x3B5C:  // Mali-G78 MP20  (Pixel 6)\n    case 0x3ACF:  // Mali-G78 MP12  (Samsung Exynoss 2100)\n    case 0x7A00:  // Asus Tinkerboard (low precision result)\n        C(_M);C(_a);C(_l);C(_i);\n        break;\n        \n    // Adreno\n    case 0x3CCD:  // Adreno  ( Qualcomm ARM SoCs)\n        C(_A);C(_d);C(_r);C(_e);C(_n);C(_o);\n        break;\n        \n    // software rendering\n    case 0x2659:  // lavapipe\n    case 0x3D59:  // llvmpipe\n    case 0x2B7D:  // MESA llvmpipe,  Chrome crashes, use Firefox\n        C(_s);C(_o);C(_f);C(_t);C(_w);C(_a);C(_r);C(_e);\n        break;\n        \n    // VideoCore\n    case 0x271F:  //  Raspberry PI \n        C(_V);C(_i);C(_d);C(_e);C(_o);C(_C);C(_o);C(_r);C(_e);\n        break;\n        \n//    default: // unknown\n//        C(_u);C(_n);C(_k);C(_n);C(_o);C(_w);C(_n);C(_space);  // Some implementation will crash if shader is too long\n    }\n    \n    printCursor = ( uv - vec2(.12,0.2))*10.;\n    printHex(uint(hash));\n    \n    O = vec4(printColor*0.8);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define _space 32\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slySWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 660, 681, 681, 918], [1046, 1046, 1073, 1073, 1214], [1215, 1215, 1238, 1238, 1368], [1371, 1371, 1410, 1410, 3337]], "test": "untested"}
{"id": "fd3SRn", "name": "Interference Patterns", "author": "tarnith", "description": "Wave interference", "tags": ["waves"], "likes": 5, "viewed": 278, "published": 3, "date": "1641573505", "time_retrieved": "2024-07-30T17:11:20.143906", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    vec3 col = vec3(0.);\n    for (float i = 0.; i < 5.; i++){\n      col += createWave(uv+(hashwithoutsine21(i*.1)-vec2(.5)),iTime);\n      }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec2 hashwithoutsine21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat createWave(vec2 origin, float rate){\n  \n  origin *= 100.;\n  \n  \n  return sin(length(origin)+rate); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 369]], "test": "untested"}
{"id": "7tKXWy", "name": "Hypotrochoids & Polygons", "author": "mla", "description": "Rolling polygons generate hypotrochoids and epitrochoids in interesting ways - see Mathologer video: [url]https://www.youtube.com/watch?v=oEN0o9ZGmOM[/url]\n\nLots of controls, see code header for details. 'x' to change display mode, 'a' to set P/M types. ", "tags": ["polygon", "golden", "mathologer", "hypotrochoids"], "likes": 42, "viewed": 972, "published": 3, "date": "1641558962", "time_retrieved": "2024-07-30T17:11:21.180135", "image_code": "/////////////////////////////////////////////////////////////////////////////////\n//\n// Hypotrochoids & Polygons. Created by Matthew Arcus, mla, 2022\n//\n// See Mathologer video: https://www.youtube.com/watch?v=oEN0o9ZGmOM for the\n// maths. A hypertrochoid is generated by two sets of polygons, sharing\n// vertices, rotating in circles (this is related to Daniel Bernoulli's Double\n// Generation Theorem - any hypertrochoid is generated by one circle rolling\n// around another in two different ways). This is still true for an epitrochoid,\n// where the circle rotates around the outside of a fixed circle - the other\n// generating configuration has a larger circle rotating around a smaller, but\n// making _internal_ contact.\n//\n// This shader has two display modes (switch with 'x') - the default where just\n// one polygon is shown from each set, as well as the fixed and rolling circles\n// generating the hypotrochoid (generally different for the two types of polygon),\n// the other mode shows all polygons, but doesn't show the circles as otherwise\n// the display gets too confusing (use 'c' and 'f' to show the circles anyway).\n//\n// To set the type P/M, press 'a', and use the mouse, pressing 'a'\n// again fixes the selected type. For M < P we get a hypotrochoid generated by\n// M-gons and P-M = N-gons. For M > P,  we get an epitrochoid generated by M-gons\n// and M-P = N-gons. In both cases the trochoid has P-fold symmetry.\n//\n// To set d, the distance of the generating point from the centre of the M-gon,\n// press 'd' & select a value with mouse-x. Press 'd' again to fix the selected value.\n//\n// Such modal UIs can be confusing, so we show some large blobs in the top left\n// indicating when modal input is being processed.\n//\n// Controls:\n// <mouse>: select parameters as described above\n// <up>/<down>: zoom in and out\n// <left>/<right>: change scale\n// 'x': switch display mode\n// 'a': set hypotrochoid type with mouse\n// 's': set polygon offsets with mouse (for star polygons)\n// 'd': set d parameter with mouse (relative point distance from circle centre)\n// 'c': show rolling circles in both modes\n// 'f': show fixed circles in both modes\n// 't': show trochoid\n// 'p': show points\n// 'm': show m-gons\n// 'n': show n-gons\n// 'h': hide text\n// 'z': slow down\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Type is P/M. M is the number of N-gons, N is the number of M-gons\n// For a hypotrochoid, P = M+N, for an epitrochoid, P = M-N\nint P = 9, M = 5, N; // Set N later from P and M\nfloat D = 1.2; // Relative distance of point from centre of travelling circle\nint offi = 0, offj = 0; // Set > 0.0 for star polygons\nfloat R = 1.0; // Radius of main fixed circle\nfloat r;       // Radius of main rolling circle, set later\nint mode = 0;\nfloat time;\n\n// Centre of the M-gons\nvec2 icentre(int i) {\n  float theta = TWOPI*(time + float(i))/float(N);\n  return (R-r)*vec2(cos(theta),sin(theta));\n}\n\n// Centre of the N-gons\nvec2 jcentre(int j) {\n  float phi = TWOPI*(time + float(j))/float(M);\n  float sign = M>P?1.0:-1.0;\n  return D*r*vec2(cos(phi),sign*sin(phi));\n}\n\n// The ith point of the jth N-gon, or the jth point of the ith M-gon\nvec2 point(int i, int j) {\n  return icentre(i) + jcentre(j); // Magic!\n}\n\n// The trochoid curve function.\nvec2 trochoid(float t) {\n  float theta = TWOPI*t;\n  float phi = (R-r)/r*theta;\n  // For epitrochoid, R-r is negative and all works out fine...\n  return vec2((R-r)*cos(theta)+D*r*cos(phi),\n              (R-r)*sin(theta)-D*r*sin(phi));\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  mode = int(key(CHAR_X));\n  vec2 z = 1.2*(2.0*fragCoord - iResolution.xy ) / iResolution.y;\n  z *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z = z.yx; // Make stars point upwards\n  vec4 amouse = keymouse(CHAR_A);\n  vec4 smouse = keymouse(CHAR_S);\n  vec4 dmouse = keymouse(CHAR_D);\n  if (amouse.x > 0.0) {\n    // set type\n    M = 2+int(14.0*amouse.y);\n    P = 2+int(14.0*amouse.x);\n  }\n  N = abs(M-P); \n  if (dmouse.x > 0.0) D = 4.0*dmouse.x;\n  if (smouse.x > 0.0) {\n    offi = int(5.0*smouse.x)%(N-1);\n    offj = int(5.0*smouse.y)%(M-1);\n  }\n  time = iTime;\n  if (mode == 1) time *= 0.5;\n  if (key(CHAR_Z)) time *= 0.5;\n  R = M>P?0.4:1.0;\n  R *= exp(0.1*float(keycount(KEY_LEFT)-keycount(KEY_RIGHT)));\n\n  r = R*float(M)/float(P);\n  float px = fwidth(length(z));\n  vec3 col = vec3(1,1,0.8);\n  float lwidth = 0.015;\n  lwidth *= exp(0.1*float(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP)));\n  float lwidth2 = 0.5*lwidth;\n  float bwidth = 0.2*lwidth;\n  float pwidth = 2.0*lwidth;\n  if (key(CHAR_Q)) {\n    vec3 tex = texture(iChannel0,fragCoord/iResolution.y).xyz;\n    float tfact = 0.5+0.75*dot(tex,tex);\n    col *= 0.5+0.5*sqrt(tex);\n    lwidth *= tfact;\n    lwidth2 *= tfact;\n    pwidth *= tfact;\n    bwidth *= tfact;\n  }\n\n  // Most, but not all, drawing happens within this radius.\n  float tlimit = 0.05+(abs(r-R)+D*r);\n  //assert(length(z) < tlimit);\n  bool inlimit = length(z) < tlimit;\n  if (mode == 0 || key(CHAR_F)) {\n    // Draw fixed circles\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(length(z)-R)-lwidth));\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(length(z)-D*R)-lwidth));\n  }\n  if (inlimit && !key(CHAR_T)) {\n    // Draw the curve: basic algorithm, take n points on the whole curve\n    // & run through points looking for points a,b,c in a row that\n    // \"bracket\" minimum, ie. f(a) > f(b) < f(c), so there must be (at\n    // least) one (local) minimum between a and c. Then use \"Golden Section\n    // search\" to refine the bracketed interval if it looks like we might\n    // be sufficiently close to the curve.\n    float d = 1e8;\n    // If M and N aren't coprime, we get GCD(M,N) separate trochoids.\n    // rotated by multiples of 2PI/(M-N) or 2PI/(M+N).\n    int cycles = gcd(M,N);\n    int T = 15*(M+N); // Total number of segments\n    float delta = float(M)/float(T); // Segment size\n    float testwidth = 10.0*lwidth*lwidth; // Squared width plus leeway\n    const int csize = 8;\n    float candidates[csize];\n    for (int cycle = 0; cycle < cycles; cycle++) {\n      int cindex0 = 0;\n      int cindex = 0;\n      vec2 z1 = rotate(z,TWOPI*float(cycle)/float(P));\n      float t0 = float(T*cycle/cycles);\n      vec2 p0 = trochoid(t0), p1 = trochoid(t0+delta);\n      float d0 = distance2(z1,p0), d1 = distance2(z1,p1);\n      for (int i = 0; i < T/cycles; i++) {\n        vec2 p2 = trochoid(t0+2.0*delta);\n        float d2 = distance2(z1,p2);\n        // Look for a bracketed minimum that is close enough.\n        if (d1 < d0 && d1 < d2 &&\n            (segment2(z1,p0,p1) < testwidth || segment2(z1,p1,p2) < testwidth)) {\n          //assert(length(p0) < length(p2));\n          // This shenanigans puts outward going arcs before inward going\n          // arcs, so, if we are lucky, we get a nice interwoven look.\n          if (length(p0) < length(p2)) {\n            candidates[cindex++] = t0;\n          } else {\n            for (int j = cindex; j > cindex0; j--) {\n              candidates[j] = candidates[j-1];\n            }\n            candidates[cindex0++] = t0;\n            cindex++;\n          }\n          if (cindex == csize) break;\n        }\n        t0 += delta;\n        d0 = d1; d1 = d2;\n        p0 = p1; p1 = p2;\n      }\n      //assert(cindex == 0);\n      if (cindex == 0) continue;\n      for (int i = 0; i < cindex; i++) {\n        float t0 = candidates[i], t1 = t0+delta, t2 = t0+2.0*delta;\n        vec2 p0 = trochoid(t0), p1 = trochoid(t1), p2 = trochoid(t2);\n        float d1 = distance2(z1,p1);\n        // Golden section search. We bracket the minimum\n        // with a,b,c, f(a) > f(b) < f(c). Then choose\n        // larger of the two interval (a,b),(b,c) and\n        // split by the golden section to give d. So\n        // eg. have a < d < b - if f(d) < f(b), then\n        // new interval (a,d,b) is bracketed, else\n        // (d,b,c) is bracketed.\n        for (int i = 0; i < 3; i++) {\n          bool left = t1-t0 > t2-t1;\n          float t3 = left ? t0+0.618*(t1-t0) : t2+0.618*(t1-t2);\n          vec2 p3 = trochoid(t3);\n          float d3 = distance2(z1,p3);\n          if (left) {\n            if (d3 < d1) {\n              // t3 is new best minimum\n              t2 = t1; t1 = t3;\n              p2 = p1; p1 = p3; d1 = d3;\n            } else {\n              t0 = t3; p0 = p3;\n            }\n          } else {\n            if (d3 < d1) {\n              // t3 is new best minimum \n              t0 = t1; t1 = t3;\n              p0 = p1; p1 = p3; d1 = d3;\n            } else {\n              t2 = t3; p2 = p3;\n            }\n          }\n        }\n        // Check distance to both segments\n        d = 1e8;\n        //assert (length(p0) < length(p1));\n        d = min(d,segment2(z1,p0,p1));\n        d = min(d,segment2(z1,p1,p2));\n        d = sqrt(d); // d has been distance squared up to now.\n        col = mix(vec3(1,0.8,0.3),col,smoothstep(-px,px,d-lwidth));\n        col = mix(vec3(0),col,smoothstep(-px,px,abs(d-lwidth)-bwidth));\n      }\n    }\n  }\n  if (mode == 0 || key(CHAR_C)) {\n    if (!key(CHAR_M)) {\n      for (int i = 0; i < N; i++) {\n        float t = distance2(z,icentre(i));\n        vec3 ccol = vec3(0);\n        col = mix(ccol,col,smoothstep(-px,px,abs(sqrt(t)-abs(r))-lwidth2));\n        if (mode == 0) break;\n      }\n    }\n    if (!key(CHAR_N)) {\n      for (int j = 0; j < M; j++) {\n        float t = distance2(z,jcentre(j));\n        vec3 ccol = vec3(0);\n        col = mix(ccol,col,smoothstep(-px,px,abs(sqrt(t)-abs(D*(R-r)))-lwidth2));\n        if (mode == 0) break;\n      }\n    }\n  }\n  if (inlimit && !key(CHAR_M)) {\n    float d = 1e8;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        vec2 p = point(i,j);\n        vec2 q = point(i,j+1+offj);\n        d = min(d,segment2(z,p,q));\n      }\n      if (mode == 0) break;\n    }\n    col = mix(vec3(0.7,0,0),col,smoothstep(-px,px,sqrt(d)-lwidth));\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(sqrt(d)-lwidth)-bwidth));\n  }\n  if (inlimit && !key(CHAR_N)) {\n    float d = 1e8;\n    for (int j = 0; j < M; j++) {\n      for (int i = 0; i < N; i++) {\n        vec2 p = point(i,j);\n        vec2 q = point(i+1+offi,j);\n        d = min(d,segment2(z,p,q));\n      }\n      if (mode == 0) break;\n    }\n    col = mix(vec3(0,0,0.8),col,smoothstep(-px,px,sqrt(d)-lwidth));\n    col = mix(vec3(0),col,smoothstep(-px,px,abs(sqrt(d)-lwidth)-bwidth));\n  }\n\n  if (inlimit && !key(CHAR_P)) {\n    // Show points\n    float d = 1e8;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        d = min(d,distance2(z,point(i,j)));\n        if (mode == 0 && i > 0) break;\n      }\n    }\n    col = mix(vec3(0),col,smoothstep(-px,px,sqrt(d)-pwidth));\n  }\n  // Show blobs for modes\n  vec2 scoord = 256.0*vec2(fragCoord.x,iResolution.y-fragCoord.y)/iResolution.y;\n  float sx = fwidth(scoord.x);\n  if (key(CHAR_A)) col *= smoothstep(-sx,sx,distance(scoord,vec2(15,15))-10.0);\n  if (key(CHAR_S)) col *= smoothstep(-sx,sx,distance(scoord,vec2(45,15))-10.0);\n  if (key(CHAR_D)) col *= smoothstep(-sx,sx,distance(scoord,vec2(75,15))-10.0);\n  if (!key(CHAR_H)) {\n    float fsize = iResolution.y/12.0;\n    vec2 fdim = vec2(0.4,1);\n    vec2 p = fragCoord/fsize;\n    vec2 uv = vec2(0);\n    int dochar = 0;\n    vec4 limits = vec4(0.3,0.7,0,1);\n    int chars[11];\n    int cindex = 0;\n    if (P/10 > 0) chars[cindex++] = 48+P/10;\n    chars[cindex++] = 48+P%10;\n    chars[cindex++] = 32+15;\n    if (M/10 > 0) chars[cindex++] = 48+M/10;\n    chars[cindex++] = 48+M%10;\n    for (int i = 0; i < cindex; i++) {\n      dochar += char(p,fdim*vec2(i,0),limits,chars[i],uv);\n    }\n    cindex = 0;\n    int dint = int(round(10.0*D));\n    chars[cindex++] = 48+dint/10;\n    chars[cindex++] = 0x2E; // .\n    chars[cindex++] = 48+dint%10;\n    // These calculations could be neater...\n    float xcoord = iResolution.x/fsize-float(cindex)*fdim.x-(1.0-fdim.x);;\n    for (int i = 0; i < cindex; i++) {\n      dochar += char(p,vec2(xcoord,0)+fdim*vec2(i,0),limits,chars[i],uv);\n    }\n    \n    //vec4 t = textureGrad(iChannel1,uv,dFdx(p/16.0),dFdy(p/16.0));\n    // textureLod seems to give sharper characters at low resolutions\n    vec4 t = textureLod(iChannel1,uv,0.0);\n    if (dochar > 0) col *= 1.0-t.x;\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.b = 1.0;\n  outColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (i == 2 && iMouse.z > 0.0 && key(j)) {\n    t = vec4(iMouse.xy/iResolution.xy,0,iTime);\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat distance2(vec2 p, vec2 q) {\n  p -= q;\n  return dot(p,p);\n}\n\nfloat segment2(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return distance2(p,b*h);\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n#define keymouse(key) (store(2,(key)));\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nint gcd(ivec2 v) {\n    while(bool(v = v.yx)) v.y %= v.x;\n    return v.y;\n}\n\nint gcd(int a, int b) {\n  return gcd(ivec2(a,b));\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nint char(vec2 p, vec2 q, vec4 limits, int c, inout vec2 uv) {\n    p -= q;\n    if (p.x<limits.x|| p.x>limits.y || p.y<limits.z|| p.y>limits.w) return 0;\n    uv = p/16.0 + fract(vec2(c,15-c/16)/16.0);\n    return 1;\n}\n\nint char(vec2 p, vec2 q, int c, inout vec2 uv) {\n  return char(p,q,vec4(0,1,0,1),c,uv);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2802, 2826, 2847, 2847, 2943], [2945, 2969, 2990, 2990, 3112], [3114, 3183, 3209, 3209, 3255], [3257, 3289, 3313, 3313, 3524], [3526, 3526, 3577, 3577, 12240]], "test": "untested"}
{"id": "7tKSWt", "name": "Stairs - distance", "author": "iq", "description": "Signed distance to a staircase. List of some other 2D distances at [url]https://www.shadertoy.com/playlist/MXdSRf[/url] and [url]www.iquilezles.org/articles/distfunctions2d/distfunctions2d.htm[/url]", "tags": ["2d", "distancefield", "sdf", "distance", "staircase", "stairs", "stair"], "likes": 22, "viewed": 1275, "published": 3, "date": "1641553002", "time_retrieved": "2024-07-30T17:11:21.953070", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a staircase. For a square staircase, please use\n// the much more efficient https://www.shadertoy.com/view/ftVSDd\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float id = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - id*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot2(wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float id = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - id*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (id<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    p -= vec2(-0.9,-0.5);\n    m -= vec2(-0.9,-0.5);\n    \n    // animate\n    float wi = 0.5 * (0.5+0.3*sin(iTime*1.1+0.0));\n    float he = wi *  (0.5+0.3*sin(iTime*1.3+2.0));\n    \n    float nu = 5.0;//1.0+floor( 4.95*(0.5 + 0.5*cos(3.0*iTime)) );\n \n    // distance\n    float d = sdStairs(p,vec2(wi,he),nu);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(160.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // interactivity\n    if( iMouse.z>0.001 )\n    {\n    d = sdStairs(m,vec2(wi,he),nu);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKSWt.jpg", "access": "api", "license": "mit", "functions": [[1347, 1347, 1372, 1372, 1391], [1393, 1393, 1446, 1458, 2331], [2333, 2333, 2390, 2426, 3396]], "test": "untested"}
{"id": "ftVSDd", "name": "Square Stairs - distance", "author": "iq", "description": "Signed distance to a square staircase. List of some other 2D distances at [url]https://www.shadertoy.com/playlist/MXdSRf[/url] and [url]www.iquilezles.org/articles/distfunctions2d/distfunctions2d.htm[/url]", "tags": ["2d", "distancefield", "sdf", "distance", "staircase", "stairs", "stair"], "likes": 26, "viewed": 732, "published": 3, "date": "1641532079", "time_retrieved": "2024-07-30T17:11:22.726002", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a staircase\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSquareStairs( in vec2 p, in float s, in float n )\n{\n    // constant for a given shape\n    const float kS2 = sqrt(2.0);\n    float w = 2.0*n+1.0;\n    \n    // pixel dependent computations\n    p = vec2( abs(p.y+p.x), p.y-p.x ) * (0.5/s);\n\n    float x1 = p.x-w;\n    float x2 = abs(p.x-2.0*min(round(p.x/2.0),n))-1.0;\n    \n    float d1 = dot2( vec2(x1, p.y) + clamp(0.5*(-x1-p.y), 0.0, w  ) );\n    float d2 = dot2( vec2(x2,-p.y) + clamp(0.5*(-x2+p.y), 0.0, 1.0) );\n\n    return sqrt(min(d1,d2)) *\n           sign(max(x1-p.y,(x2+p.y)*kS2)) *\n           s*kS2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n \n    // animate\n    float w = 1.0/8.0;\n    float n = floor( 3.95*(0.5 + 0.5*cos(iTime*3.0)) );\n \n    // distance\n    float d = sdSquareStairs(p,w,n);\n   \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(160.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // interactivity\n    if( iMouse.z>0.001 )\n    {\n    d = sdSquareStairs(m,w,n);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVSDd.jpg", "access": "api", "license": "mit", "functions": [[1246, 1246, 1271, 1271, 1290], [1292, 1292, 1351, 1385, 1853], [1855, 1855, 1912, 1948, 2752]], "test": "untested"}
{"id": "ftKSDd", "name": "menger sphere", "author": "jorge2017a2", "description": "menger sphere", "tags": ["mengersphere"], "likes": 46, "viewed": 563, "published": 3, "date": "1641527313", "time_retrieved": "2024-07-30T17:11:23.498936", "image_code": "//----------image\n//por jorge2017a1-\n\n//reference\n//https://www.shadertoy.com/view/wllXzX .. Mandelbulb Labyrinth\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n#define MENGER_ITERATIONS\t2\n\n#define dot2(x) \t\t\tdot(x, x)\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\nvec4 map(in vec3 p)\n{   //float ground = sdPlane(p, 1.8);\n    p.xz = mod(p.xz + 1.0, 2.0) -1.0;\n    p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d1,d2,d3;\n    \n    float t1=mod(itime,3.0);\n    float t2=mod(itime,4.0);\n    if (t1<t2)\n    {   \n     d1=sdSphere(p-vec3(-0.25,0.0,0.0), 0.5 );\n     d2=sdSphere(p-vec3(0.0,0.25,0.0), 0.5 );\n     d3=sdSphere(p-vec3(0.25 ,0.0,0.0), 0.5 );\n    } \n    else\n    {\n     d1=sdSphere(p-vec3(-0.25,0.0,0.0), 0.7 );\n     d2=sdSphere(p-vec3(0.0,0.25,0.0), 0.20 );\n     d3=sdSphere(p-vec3(0.25 ,0.0,0.0), 0.6 );\n    }\n\n    float d=min(min(d1,d2),d3);\n    vec4 res = vec4(d, 2.0, 0.0, 0.0);\n\t\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {  vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 5.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.3) / s;\n\n        if(c > d)\n        {   d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    return res;    \n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n   float planeDist1 = p.y-2.0;  //piso inf\n    vec4 v4= map(p);\n    res =opU3(res, vec3(v4.x,100.0,-1.0));\n    res =opU3(res, vec3(planeDist1,13.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;   \n}\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color)); colobj=coltex;}\n    return colobj;\n}\n\nvec3 linear2srgb(vec3 c) \n{   return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51; float b = 0.03;\n    float c = 2.43; float d = 0.59; float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*0.5,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;    \n \t light_pos1= vec3(-10.0, 20.0, -10.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 10.0, 10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    \n   vec3 ro=vec3(0.0,4.,0.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 576, 612, 612, 633], [634, 634, 666, 666, 750], [751, 795, 842, 842, 869], [870, 870, 913, 913, 940], [941, 941, 989, 989, 1017], [1077, 1077, 1114, 1114, 1141], [1143, 1143, 1164, 1200, 2231], [2233, 2233, 2258, 2258, 2478], [2480, 2480, 2504, 2504, 2666], [2668, 2668, 2717, 2717, 3348], [3350, 3350, 3386, 3386, 3631], [3633, 3633, 3670, 3670, 3939], [3941, 3941, 4024, 4024, 4601], [4602, 4602, 4651, 4651, 4894], [4896, 4896, 4989, 4989, 5119], [5121, 5121, 5153, 5153, 5350], [5352, 5352, 5445, 5445, 5737], [5739, 5739, 5766, 5766, 5874], [5876, 5876, 5934, 5934, 5986], [5988, 5988, 6011, 6011, 6139], [6141, 6141, 6172, 6172, 6884], [6886, 6886, 6943, 6943, 7469]], "test": "untested"}
{"id": "ftKSDt", "name": "stairs3D", "author": "Del", "description": "// Stairs using IQ's proper distance :)", "tags": ["sdf", "stairs", "repeat"], "likes": 4, "viewed": 248, "published": 3, "date": "1641516725", "time_retrieved": "2024-07-30T17:11:24.262893", "image_code": "// Stairs using IQ's proper distance :) - https://www.shadertoy.com/view/ftVSDd\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat stairs(vec2 p1)\n{\n    p1.y += 1.5;\n    float stepheight = 0.3;\n\n    float lim = 6.f; // 6 repeats either side...\n    float d = 1000.0;\n \n     for (float xx=-1.0;xx<=1.0;xx+=1.0) // is this referred to as 3tap?\n     {\n        vec2 pp = p1;\n        float id = clamp(floor(pp.x+xx),-lim,lim);\n        pp.x -= id+0.5;\n        pp.y -= id*stepheight;\n        float d1 = sdBox(pp,vec2(0.5,2.5+(id*stepheight)));\n        d = min(d,d1);\n     }\n    return d*0.9;\n}\n*/\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdStairs( in vec2 p, in float s, in float n )\n{\n    // constant for a given shape\n    const float kS2 = sqrt(2.0);\n    float w = 2.0*n+1.0;\n    \n    // pixel dependent computations\n    p = vec2( abs(p.y+p.x), p.y-p.x ) * (0.5/s);\n\n    float x1 = p.x-w;\n    float x2 = abs(p.x-2.0*min(round(p.x/2.0),n))-1.0;\n    \n    float d1 = dot2( vec2(x1, p.y) + clamp(0.5*(-x1-p.y), 0.0, w  ) );\n    float d2 = dot2( vec2(x2,-p.y) + clamp(0.5*(-x2+p.y), 0.0, 1.0) );\n\n    return sqrt(min(d1,d2)) *\n           sign(max(x1-p.y,(x2+p.y)*kS2)) *\n           s*kS2;\n}\nfloat opExtrusion( in vec3 p, float dd, in float h )\n{\n    float d = dd;\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\n\nfloat map( in vec3 pos )\n{\n    float d1 = sdStairs(pos.xy+vec2(8.0,0.0),0.5,4.0);\n    d1 = opExtrusion(pos.xzy,d1,3.0);\n    \n    float d = sdStairs( opRevolution(pos-vec3(8.0,0.0,0.0),5.0)*vec2(-1.0,1.0), 0.5,4.0)    ;\n    d = min(d,d1);\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 20.0*cos(an), 8.0, 20.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKSDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 668, 693, 693, 712], [714, 714, 767, 801, 1269], [1270, 1270, 1324, 1324, 1437], [1440, 1440, 1481, 1481, 1525], [1528, 1528, 1554, 1554, 1786], [1788, 1834, 1866, 1866, 2104]], "test": "untested"}
{"id": "slGXWd", "name": "Mario on an awful CRT TV", "author": "Hatchling", "description": "Mario code taken from: [SIG15] Mario World 1-1 by knarkowicz, please check out his shader here! https://www.shadertoy.com/view/XtlSD7", "tags": ["crt", "scanline", "vhs", "shadowmask", "ntsc"], "likes": 22, "viewed": 1329, "published": 3, "date": "1641503997", "time_retrieved": "2024-07-30T17:11:25.491608", "image_code": "// Taken from https://www.shadertoy.com/view/tdjyzz\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 pixelSize = 1.5/iResolution.xy;\n    \n    vec2 right = vec2(pixelSize.x, 0);\n    vec2 up = vec2(0, pixelSize.y);\n\n    // Input linear image + bloom.\n    vec3 colorC = texture(iChannel0, uv).rgb;\n    \n    //fragColor = vec4(colorC, 1.0);\n    //return;\n    \n    vec3 colorT = textureLod(iChannel0, uv + up, 0.5).rgb;\n    vec3 colorB = textureLod(iChannel0, uv - up, 0.5).rgb;\n    vec3 colorL = textureLod(iChannel0, uv - right, 0.5).rgb;\n    vec3 colorR = textureLod(iChannel0, uv + right, 0.5).rgb;\n    \n    right *= 2.0;\n    up *= 2.0;\n    \n    vec3 colorTR = textureLod(iChannel0, uv + up + right, 1.5).rgb;\n    vec3 colorTL = textureLod(iChannel0, uv + up - right, 1.5).rgb;\n    vec3 colorBR = textureLod(iChannel0, uv - up + right, 1.5).rgb;\n    vec3 colorBL = textureLod(iChannel0, uv - up - right, 1.5).rgb;\n        \n        \n    vec3 color = colorC + (colorT + colorB + colorL + colorR) * 0.03 + (colorTR + colorTL + colorBR + colorBL) * 0.01;    \n    //color = (colorT + colorB + colorL + colorR) * 0.03;   \n    //color = (colorTR + colorTL + colorBR + colorBL) * 0.01;    \n\n    // Tonemap \n    float lum = rbgToluminance(color);\n    color += vec3(lum * 0.01); // Allow colors to whiten when saturated.\n    color = color / (0.5 + mix(vec3(lum), color, 0.95));\n    \n    // Convert to gamma.\n\tcolor = pow(color, vec3(1.0/2.2));\n    \n\tfragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float SHADOWMASK_VERTGAPWIDTH = 0.02;\nconst float SHADOWMASK_VERTHARDNESS = 0.1;\n\nconst float SHADOWMASK_HORIZGAPWIDTH = -1.0;\nconst float SHADOWMASK_HORIZARDNESS = 0.8;\n\nconst float SHADOWMASK_RCOL_OFFSET = 0.0;\nconst float SHADOWMASK_GCOL_OFFSET = -0.3;\nconst float SHADOWMASK_BCOL_OFFSET = -0.6;\n\nconst float SCANLINE_RGAPWIDTH = 2.0;\nconst float SCANLINE_RHARDNESS = 1.0;\nconst float SCANLINE_ROFFSET = 0.0 + 0.08333333;\n\nconst float SCANLINE_GGAPWIDTH = 2.0;\nconst float SCANLINE_GHARDNESS = 0.5;\nconst float SCANLINE_GOFFSET = -0.1 + 0.08333333;\n\nconst float SCANLINE_BGAPWIDTH = 2.0;\nconst float SCANLINE_BHARDNESS = 0.3;\nconst float SCANLINE_BOFFSET = -0.15 + 0.08333333;\n\n// When increasing the overall scale, you may need to reduce the \"HARDNESS\" of the\n// CRT patterns to prevent aliasing.\n//const float OVERALL_SCALE = 240.0;\nconst float SHADOWMASK_UV_SCALE = 0.16;\nconst float SCANLINE_UV_SCALE = 60.0;\n\nconst float SINE_SCALE = 3.14159 * 2.0;\n\n\n// SHADOW MASK\n\nfloat Grille(float x, float offset, float multiplier)\n{\n\treturn smoothstep(0.0, 1.0, sin(x * SINE_SCALE) * multiplier + offset);    \n}\n\nfloat ShadowMaskRows(vec2 uv)\n{\n    // Stagger rows\n    uv.x *= 0.5;\n    uv.x -= round(uv.x);\n    if(uv.x < 0.0)\n        uv.y += 0.5;\n    \n    return Grille(uv.y, -SHADOWMASK_HORIZGAPWIDTH, SHADOWMASK_HORIZARDNESS);\n}\n\nfloat ShadowMaskSingleCol(float x)\n{\n    return Grille(x, -SHADOWMASK_VERTGAPWIDTH, SHADOWMASK_VERTHARDNESS);\n}\n\nvec3 ShadowMaskRGBCols(float x)\n{\n\treturn vec3\n    (\n        ShadowMaskSingleCol(x + SHADOWMASK_RCOL_OFFSET), \n        ShadowMaskSingleCol(x + SHADOWMASK_GCOL_OFFSET), \n        ShadowMaskSingleCol(x + SHADOWMASK_BCOL_OFFSET)\n    );    \n}\n\nvec3 ShadowMask(vec2 uv)\n{\n    return ShadowMaskRGBCols(uv.x) * ShadowMaskRows(uv);\n}\n\n// SCANLINE PATTERN\n\nfloat Scanline(float x, float offset, float multiplier)\n{\n\treturn tanh(sin(x * SINE_SCALE) * multiplier + offset) * 0.5 + 0.5;    \n}\n\nfloat Interlacing()\n{\n    // Add interlacing.\n    int frame = iFrame;\n    \n    // Add the following line to exaggerate interlacing effect.\n    //frame /= 2;\n    \n    return frame % 2 == 0 ? \n        0.5 : 0.0;\n}\n\nvec4 Sample(sampler2D sampler, vec2 uv, float resolution)\n{\n    if(uv.x < 0.0 || uv.x > 1.0) return vec4(0);\n    if(uv.y < 0.0 || uv.y > 1.0) return vec4(0);\n    \n    float interlacing = Interlacing();\n    \n    uv *= resolution;\n    \n    uv.y += interlacing;\n    float uvYFloor = floor(uv.y);\n    \n    vec2 uv1 = vec2(uv.x, uvYFloor+1.0);\n    vec2 uv2 = vec2(uv.x, uvYFloor);\n    \n    float t = uv.y - uvYFloor;\n    \n    t = smoothstep(0.0, 1.0, t);\n    //t = smoothstep(0.0, 1.0, t);\n    //t = smoothstep(0.0, 1.0, t);\n    \n    uv1.y -= interlacing;    \n    uv2.y -= interlacing;\n    \n    vec4 sample1 = texture(sampler, uv1 / resolution);\n    vec4 sample2 = texture(sampler, uv2 / resolution);\n    \n    return mix(sample2, sample1, vec4(t));\n}\n\nvec3 ScanlinesRGB(float y)\n{\n\ty += Interlacing() + 0.25;  \n    \n    // Real CRT images show differences in scattering and alignment\n    // between the RGB beams.\n    return vec3\n    (\n \t    Scanline(y + SCANLINE_ROFFSET, -SCANLINE_RGAPWIDTH, SCANLINE_RHARDNESS)   \n        ,\n \t    Scanline(y + SCANLINE_GOFFSET, -SCANLINE_GGAPWIDTH, SCANLINE_GHARDNESS)   \n        ,\n \t    Scanline(y + SCANLINE_BOFFSET, -SCANLINE_BGAPWIDTH, SCANLINE_BHARDNESS)   \n    );\n}\n\n// COMPOSITE\n// CRT curvature and vignetting credit goes to https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    vec2 sampleUV = curve(uv);\n    vec2 shadowMaskUV = sampleUV * min(iResolution.xy, vec2(1920, 1080)) * SHADOWMASK_UV_SCALE;\n    vec2 scanlineUV = sampleUV * SCANLINE_UV_SCALE;\n    \n    // Input signal.\n    vec3 color = Sample(iChannel0, sampleUV, SCANLINE_UV_SCALE).rgb;\n    \n    // Convert to linear.\n    color = pow(color, vec3(2.2));\n    \n    // Amplify.\n    color *= 4.0;\n    \n    // Vignette.\n    float vig = abs((1.0*16.0*sampleUV.x*sampleUV.y*(1.0-sampleUV.x)*(1.0-sampleUV.y)));\n\tcolor *= vec3(pow(vig,0.6));\n    \n    // Add scalines.\n    color *= ScanlinesRGB(scanlineUV.y) * 40.0;\n    \n    // Add shadowmask.\n    color *= ShadowMask(shadowMaskUV) * 500.0;\n\n\tfragColor = vec4(color, 1.0);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n\n// Adjust these values to control the look of the encoding.\n\n// Increasing this value increases ringing artifacts. Careful, higher values are expensive.\nconst int WINDOW_RADIUS = 20;\n\n// Simulated AM signal transmission.\nconst float AM_CARRIERSIGNAL_WAVELENGTH = 1.5;\n\n// Wavelength of the color signal. \nconst float COLORBURST_WAVELENGTH_ENCODER = 4.0;\nconst float COLORBURST_WAVELENGTH_DECODER = 4.0;\n\n// Lowpassing of luminance before encoding.\n// If this value is less than the colorburst wavelength,\n// luminance values will be interpreted as chrominance,\n// resulting in color fringes near edges.\nconst float YLOWPASS_WAVELENGTH = 2.0;\n\n// The higher these values are, the more smeary colors will be.\nconst float ILOWPASS_WAVELENGTH = 20.0;\nconst float QLOWPASS_WAVELENGTH = 40.0;\n\n// The higher this value, the blurrier the image.\nconst float DECODE_LOWPASS_WAVELENGTH = 5.5;\n\n// Change the overall scale of the NTSC-style encoding and decoding artifacts.\nconst float NTSC_SCALE = 2.;\n\nconst float PHASE_ALTERNATION = 3.1415927;\n\n// Amount of TV static.\nconst float NOISE_STRENGTH = 0.1;\n\n// Saturation control.\nconst float SATURATION = 3.0;\n\n// Offsets shape of window. This can make artifacts smear to one side or the other.\nconst float WINDOW_BIAS = +0.25;\n\nmat3 MatrixRGBToYIQ = mat3(0.299, 0.587, 0.114,\n                           0.595,-0.274,-0.3213,\n                           0.2115,-0.5227, 0.3112);\n\nmat3 MatrixYIQToRGB = mat3(1.0,  0.956,  0.619,\n                           1.0, -0.272, -0.647,\n                           1.0, -1.106, 1.703);\n\n// RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n// NOTE: Window functions expect a range from -1 to 1.\nfloat Sinc(float x)\n{\n    x *= PI;\n\treturn (x == 0.0) ? 1.0 : sin(x)/x;   \n}\n\nfloat WindowCosine(float x)\n{\n    x = atanh(x);\n    x += WINDOW_BIAS;\n    x = tanh(x);\n    \n\treturn cos(PI * x) * 0.5 + 0.5;    \n}\n\nfloat Encode(sampler2D sampler, in vec2 uv, in float pixelWidth, bool alternatePhase)\n{\n    vec3 yiq = vec3(0);\n\tfor(int i = -WINDOW_RADIUS; i <= WINDOW_RADIUS; i++)\n    {\n\t\t// Extend padding by one since we don't want to include a sample at the very edge, which will be 0.\n        float window = WindowCosine(float(i) / float(WINDOW_RADIUS+1)); \n        float sincY = Sinc(float(i)/YLOWPASS_WAVELENGTH)/YLOWPASS_WAVELENGTH;\n        float sincI = Sinc(float(i)/ILOWPASS_WAVELENGTH)/ILOWPASS_WAVELENGTH;\n        float sincQ = Sinc(float(i)/QLOWPASS_WAVELENGTH)/QLOWPASS_WAVELENGTH;\n        \n        vec2 uvWithOffset = vec2(uv.x + float(i) * pixelWidth, uv.y);\n\n        vec3 yiqSample = MatrixRGBToYIQ * clamp(texture(sampler, uvWithOffset).xyz, vec3(0.0), vec3(1.0));\n        \n    \tyiq.x += yiqSample.x * sincY * window;\n        yiq.y += yiqSample.y * sincI * window;\n        yiq.z += yiqSample.z * sincQ * window;\n    }\n    \n    float phase = uv.x * PI / (COLORBURST_WAVELENGTH_ENCODER * pixelWidth);\n    \n    if(alternatePhase)\n    {\n        phase += PHASE_ALTERNATION;\n    }\n    \n    float phaseAM = uv.x * PI / (AM_CARRIERSIGNAL_WAVELENGTH * pixelWidth);\n    \n    return (yiq.x \n         + sin(phase) * yiq.y\n         + cos(phase) * yiq.z\n         + 1.0) * 0.5  * sin(phaseAM);\n}\n\nvec3 Decode(sampler2D sampler, in vec2 uv, in float pixelWidth, ivec2 rng, bool alternatePhase)\n{\n    uint seed = uint(rng.y);\n    \n    float rowNoiseIntensity = RandomFloat01(seed);\n    rowNoiseIntensity = pow(rowNoiseIntensity, 500.0) * 1.0;\n    \n    float horizOffsetNoise = RandomFloat01(seed) * 2.0 - 1.0;\n    horizOffsetNoise *= rowNoiseIntensity * 0.1 * NOISE_STRENGTH;\n    //uv.x += horizOffsetNoise;\n    \n    float phaseNoise = RandomFloat01(seed) * 2.0 - 1.0;\n    phaseNoise *= rowNoiseIntensity * 0.5 * 3.1415927 * NOISE_STRENGTH;\n\n    float frequencyNoise = RandomFloat01(seed) * 2.0 - 1.0;\n    frequencyNoise *= rowNoiseIntensity * 0.1 * 3.1415927 * NOISE_STRENGTH;\n    \n    float alt = 0.0;  \n    if(alternatePhase)\n    {\n        alt = PHASE_ALTERNATION;\n    }\n    \n    \n    vec3 yiq = vec3(0);\n\tfor(int i = -WINDOW_RADIUS; i <= WINDOW_RADIUS; i++)\n    {\n\t\t// Extend padding by one since we don't want to include a sample at the very edge, which will be 0.\n        float window = WindowCosine(float(i) / float(WINDOW_RADIUS+1)); \n        \n        vec2 uvWithOffset = vec2(uv.x + float(i) * pixelWidth, uv.y);\n    \tfloat phase = uvWithOffset.x * PI / ((COLORBURST_WAVELENGTH_DECODER + frequencyNoise) * pixelWidth) + phaseNoise + alt;\n    \t//float phaseAM = uv.x * PI / (AM_SIGNAL_WAVELENGTH * pixelWidth);\n        \n        \n        float sincY = Sinc(float(i)/DECODE_LOWPASS_WAVELENGTH)/DECODE_LOWPASS_WAVELENGTH;\n        float sinI = sin(phase);\n        float sinQ = cos(phase);\n        //float sincI = Sinc(float(i)/ILOWPASS_WAVELENGTH)/ILOWPASS_WAVELENGTH;\n        //float sincQ = Sinc(float(i)/QLOWPASS_WAVELENGTH)/QLOWPASS_WAVELENGTH;\n        \n        float encodedSample = (max(0.0, texture(sampler, uvWithOffset).x) - 0.175) * 6.0;\n        \n    \tyiq.x += encodedSample * sincY * window;\n        yiq.y += encodedSample * sinI * window;\n        yiq.z += encodedSample * sinQ * window;\n        //yiq.y += yiqSample.y * sincI * window;\n        //yiq.z += yiqSample.z * sincQ * window;\n    }\n    \n    \n    yiq.yz *= SATURATION / float(WINDOW_RADIUS);\n    \n    return max(vec3(0.0), MatrixYIQToRGB * yiq);\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    \n    uint rngStateRow = uint(uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    uint rngStateCol = uint(uint(fragCoord.x) * uint(1973) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    fragColor.rgb = Decode(iChannel0, uv, pixelSize.x * NTSC_SCALE, ivec2(rngStateCol, rngStateRow), ((iFrame + 1) + int(fragCoord.y)) % 2 == 0);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// RNG algorithm credit: https://www.shadertoy.com/view/wtSyWm\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    uint rngStateRow = uint(uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    float encoded = Encode(iChannel0, uv, pixelSize.x * NTSC_SCALE, (iFrame + int(fragCoord.y)) % 2 == 0);\n    \n    float snowNoise = RandomFloat01(rngState) - 0.5;\n    float sineNoise = sin(uv.x * 200.0 + uv.y * -50.0 + fract(iTime * iTime) * 3.1415927 * 2.0) * 0.065;\n    float saltPepperNoise = RandomFloat01(rngState) * 2.0 - 1.0;\n    saltPepperNoise = sign(saltPepperNoise) * pow(abs(saltPepperNoise), 200.0) * 10.0;\n    float rowNoise = RandomFloat01(rngStateRow) * 2.0 - 1.0;\n    rowNoise *= 0.1;   \n    float rowSaltPepper = RandomFloat01(rngStateRow) * 2.0 - 1.0;\n    rowSaltPepper = sign(rowSaltPepper) * pow(abs(rowSaltPepper), 200.0) * 1.0;\n    \n    encoded += (snowNoise + saltPepperNoise + sineNoise + rowNoise + rowSaltPepper) * NOISE_STRENGTH; \n    \n    fragColor.rgb = vec3(encoded);\n    fragColor.a = 1.0;\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Interesting findings from original NES Super Mario Bros.:\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\n// -Overworld (main theme) drum sound uses only the APU noise generator\n\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n\nconst float MARIO_SPEED\t = 89.0;\nconst float GOOMBA_SPEED = 32.0;\nconst float INTRO_LENGTH = 2.0;\n\nvoid SpriteBlock( inout vec3 color, float x, float y )\n{\n    // black\n    float idx = 1.0;\n    \n    // light orange\n    idx = x < y ? 3.0 : idx;\n    \n    // dark orange\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\n    idx = x == 15.0 - y ? 2.0 : idx;\n    \n    color = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteHill( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    // dark green\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\n    \n    // black\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n}\n\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\n{\n    float offset = h * 16.0;\n\n    // light green\n\tfloat idx = 3.0;\n    \n    // dark green\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \n    \n    // black\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \n    \n    // transparent\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\n\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\n\tcolor = idx == 2.0 ? colorB \t\t: color;\n\tcolor = idx == 3.0 ? colorC \t\t: color;\n}\n\nvoid SpriteFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? 43690.0 : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\n{\n\tfloat idx = 0.0;\n\n    // second frame is flipped first frame\n    x = frame == 1.0 ? 15.0 - x : x;\n\n    if ( frame <= 1.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\n        idx = y ==  6.0 ? 43690.0 : idx;\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\n\t\tidx = y == 3.0 ? 43690.0 : idx;\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\n}\n\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\n{    \n\tfloat idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\n    }\n\telse\n\t{\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\n\t}\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 0.0 ? 21845.0 : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\n}\n\nvoid SpriteMushroom( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\n\tidx = y == 5.0 ? 43690.0 : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGround( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\n\tidx = y == 7.0 ? 1360.0  : idx;\n\tidx = y == 6.0 ? 6836.0  : idx;\n\tidx = y == 5.0 ? 27309.0 : idx;\n\tidx = y == 4.0 ? 27309.0 : idx;\n\tidx = y == 3.0 ? 27305.0 : idx;\n\tidx = y == 2.0 ? 27305.0 : idx;\n\tidx = y == 1.0 ? 6820.0  : idx;\n\tidx = y == 0.0 ? 1360.0  : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 3.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 4.0 )\n    {\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\n    }\n    else if ( frame == 5.0 )\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\n    }\n    else if ( frame == 6.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \n}\n\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n    }\n    \n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBrick( inout vec3 color, float x, float y )\n{    \n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \n    float xmod8 = floor( mod( x, 8.0 ) );\n    float ymod8 = floor( mod( y, 8.0 ) );\n    \n    // dark orange\n    float idx = 2.0;\n   \n    // black\n    idx = ymod4 == 0.0 ? 1.0 : idx;\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\n\n    // light orange\n    idx = y == 15.0 ? 3.0 : idx;\n\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid DrawCastle( inout vec3 color, float x, float y )\n{\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\n\t{\n\t\tfloat ymod4    = mod( y, 4.0 );\n\t\tfloat xmod8    = mod( x, 8.0 );\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\n\t\tfloat ymod8    = mod( y, 8.0 );\n\n\t\t// dark orange\n\t\tfloat idx = 2.0;\n\n\t\t// black\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \n\n\t\t// white\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\n\n\t\t// transparent\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\n\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n\t}\n}\n\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\n{\n    if ( x >= 0.0 && x <= 15.0 )\n    {\n        SpriteKoopa( color, x, y, frame );\n    }\n}\n\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\n{\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\n    DrawKoopa( color, x, worldY - 16.0, frame );    \n}\n\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\n{\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\n    t = 1.0 - abs( 2.0 * t - 1.0 );\n\n    questionY -= floor( t * 8.0 );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {            \n    \tif ( time >= questionHitTime )\n        {                \n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n            {\n                color = RGB( 231, 90, 16 );\n            }\n        }\n        else\n        {\n         \tSpriteQuestion( color, questionX, questionY, questionT );\n        }\n    }\n}\n\nvoid DrawW( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 || x >= 10.0 ) \n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawO( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\n             || ( x >= 2.0 && x <= 4.0 )\n             || ( x >= 9.0 && x <= 11.0 )\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawR( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 )\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\n             || ( x >= 8.0  && y <= 1.0 )\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawL( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( x <= 3.0 || y <= 1.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawD( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n    \tcolor = RGB( 255, 255, 255 );        \n        \n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\n           )\n        {\n            color = RGB( 0, 0, 0 );\n        }\n    }\n}\n\nvoid Draw1( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( y <= 1.0 )\n             || ( x >= 5.0 && x <= 8.0 )\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawM( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( y >= 4.0 && y <= 7.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\n{\n    color = RGB( 0, 0, 0 );\n        \n    float offset \t= 18.0;     \n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\n    float marioX\t= textX - offset * 4.0;\n    float marioY\t= textY + 16.0 * 3.0;\n\t\n    DrawW( color, textX - offset * 0.0, textY );\n    DrawO( color, textX - offset * 1.0, textY );\n    DrawR( color, textX - offset * 2.0, textY );\n    DrawL( color, textX - offset * 3.0, textY );\n    DrawD( color, textX - offset * 4.0, textY );\n    Draw1( color, textX - offset * 6.0, textY );\n    DrawM( color, textX - offset * 7.0, textY );\n    Draw1( color, textX - offset * 8.0, textY );\n    \n    if ( marioX >= 0.0 && marioX <= 15.0 )\n    {\n    \tSpriteMario( color, marioX, marioY, 4.0 );\n    }\n}\n\nfloat CoinAnimY( float worldY, float time, float coinTime )\n{\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\n}\n\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\n{\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\n}\n\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\n{\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\n}\n\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\n{\n    float mushroomPauseStart \t= 16.25;    \n    float mushroomPauseLength \t= 2.0;    \n    float flagPauseStart\t\t= 38.95;\n    float flagPauseLength\t\t= 1.5;\n\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\n    float worldX \t\t= pixelX + cameraX;\n    float worldY  \t\t= pixelY - 8.0;\n    float tileX\t\t\t= floor( worldX / 16.0 );\n    float tileY\t\t\t= floor( worldY / 16.0 );\n    float tile2X\t\t= floor( worldX / 32.0 );\n    float tile2Y\t\t= floor( worldY / 32.0 );    \n    float worldXMod16\t= mod( worldX, 16.0 );\n    float worldYMod16 \t= mod( worldY, 16.0 );\n\n\n    // default background color\n    color = RGB( 92, 148, 252 );\n\n    \n    // draw hills\n    float bigHillX \t = mod( worldX, 768.0 );\n    float smallHillX = mod( worldX - 240.0, 768.0 );\n    float hillX \t = min( bigHillX, smallHillX );\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\n    SpriteHill( color, hillX, hillY );\n\n\n    // draw clouds and bushes\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \n    float scCloudX  = min( sc1CloudX, sc2CloudX );\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\n    float sCloudX\t= min( scCloudX, sbCloudX );\n    float mCloudX\t= min( mcCloudX, mbCloudX );\n    float lCloudX\t= min( lcCloudX, lbCloudX );\n    float cloudX\t= min( cCloudX, bCloudX );\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\n    {\n        if ( cloudSeg == 1.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\n        }\n        if ( cloudSeg == 2.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\n        }\n        \n    \tSpriteCloud( color, cloudX, cloudY, isBush );\n    }\n\n    \n    \n    // draw flag pole\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \n    {\n        color = RGB( 189, 255, 24 );\n    }\n    \n    // draw flag\n    float flagX = worldX - 3160.0;\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\n    if ( flagX >= 0.0 && flagX <= 15.0 )\n    {\n    \tSpriteFlag( color, flagX, flagY );\n    }     \n    \n    // draw flagpole end\n    float flagpoleEndX = worldX - 3172.0;\n    float flagpoleEndY = worldY - 176.0;\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\n    {\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\n    }\n    \n    \n\n    // draw blocks\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\n         || ( tileX == 198.0 && tileY == 1.0 )\n       )\n    {\n        SpriteBlock( color, worldXMod16, worldYMod16 );\n    }\n    \n    \n    // draw pipes\n    float pipeY = worldY - 16.0;  \n    float pipeH\t= 0.0;    \n    float pipeX = worldX - 179.0 * 16.0;\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 163.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 57.0 * 16.0;\n        pipeH = 2.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 46.0 * 16.0;\n        pipeH = 2.0;\n    } \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 38.0 * 16.0;\n        pipeH = 1.0;\n    }         \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 28.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\n\t{\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\n\t}\n    \n    \n    // draw mushroom\n    float mushroomStart = 15.7;    \n    if ( time >= mushroomStart && time <= 17.0 )\n    {\n        float jumpTime = 0.5;\n        \n        float mushroomX = worldX - 1248.0;\n        float mushroomY = worldY - 4.0 * 16.0;\n        if ( time >= mushroomStart )\n        {\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\n        }\n        if ( time >= mushroomStart + 0.5 )\n        {\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\n        }\n        if ( time >= mushroomStart + 0.5 + 0.4 )\n        {\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\n        }\n        \n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\n        {\n        \tSpriteMushroom( color, mushroomX, mushroomY );\n        }\n    }\n\n    \n    // draw coins\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\n    float coinX \t= worldX - 2720.0;\n    float coinTime \t= 33.9;    \n    float coinY \t= CoinAnimY( worldY, time, coinTime );\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 1696.0;\n    \tcoinTime \t= 22.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \n    }\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 352.0;\n    \tcoinTime \t= 5.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\n    } \n    \n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\n    {   \n        SpriteCoin( color, coinX, coinY, coinFrame );\n    }\n\n    \n    // draw questions\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\n    }\n    \n    \n    // draw hitted questions\n    float questionHitTime \t= 33.9;\n    float questionX \t\t= worldX - 2720.0;\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 22.4;\n        questionX\t\t= worldX - 1696.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 15.4;\n        questionX\t\t= worldX - 1248.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 5.3;\n        questionX\t\t= worldX - 352.0;\n    }    \n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {\n    \tSpriteQuestion( color, questionX, questionY, questionT );\n    }\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n    {\n        color = RGB( 231, 90, 16 );\n    }    \n\n    \n    // draw bricks\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteBrick( color, worldXMod16, worldYMod16 );\n    }   \n    \n    \n    // draw castle flag\n    float castleFlagX = worldX - 3264.0;\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\n    {\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\n\t}\n    \n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\n\n    // draw ground\n    if ( tileY <= 0.0\n         && !( tileX >= 69.0  && tileX < 71.0 )\n         && !( tileX >= 86.0  && tileX < 89.0 ) \n         && !( tileX >= 153.0 && tileX < 155.0 ) \n       )\n    {\n        SpriteGround( color, worldXMod16, worldYMod16 );\n    }    \n    \n\n    // draw Koopa\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\n    \n    \n    // draw stomped walking Goombas\n    float goombaY \t\t\t= worldY - 16.0;        \n    float goombaLifeTime \t= 26.3;\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 25.3;\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n\t\tgoombaLifeTime \t= 23.5;\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n        goombaLifeTime \t= 20.29;\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 10.3;\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    }\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }    \n    \n    // draw walking Goombas\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }\n    \n\n    \n    // Mario jump\n    float marioBigJump1 \t= 27.1;\n    float marioBigJump2 \t= 29.75;\n    float marioBigJump3 \t= 35.05;    \n    float marioJumpTime \t= 0.0;\n    float marioJumpScale\t= 0.0;\n    \n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\n    \n    float marioJumpOffset \t\t= 0.0;\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\n    {\n        float t = ( time - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n    \n    // Mario land\n    float marioLandTime \t= 0.0;\n    float marioLandAplitude = 0.0;\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\n    \n    float marioLandLength = marioLandAplitude / 120.0;\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\n    {\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\n    }\n    \n    \n    // Mario flag jump\n    marioJumpTime \t\t= flagPauseStart - 0.3;\n    marioJumpLength \t= 1.5  * 0.45;\n    marioJumpAmplitude\t= 76.0 * 0.45;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \n    {\n        float time2 = time;\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \n        {\n            time2 = flagPauseStart;\n        }\n        else if ( time >= flagPauseStart )\n        {\n            time2 = time - flagPauseLength;\n        }\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n\n    // Mario base (ground offset)\n    float marioBase = 0.0;\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\n    {\n        marioBase = 16.0 * 3.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\n    {\n        marioBase = 16.0 * 7.0;\n    }\n\n    float marioX\t\t= pixelX - 112.0;\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\n    {\n    \tmarioFrame = 1.0;\n    }    \n    if ( time > mushroomPauseStart + 0.7 )\n    {\n        float t = time - mushroomPauseStart - 0.7;\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\n        {\n            // super mario offset\n            marioFrame += 4.0;\n        }\n    }    \n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\n    {\n        SpriteMario( color, marioX, marioY, marioFrame );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\n    float resMultX  = floor( iResolution.x / 224.0 );\n    float resMultY  = floor( iResolution.y / 192.0 );\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\n    \n    float time\t\t\t= iTime;\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\n\n    vec3 color = RGB( 92, 148, 252 );\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\n    if ( time < INTRO_LENGTH )\n    {\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\n    }    \n    \n\tfragColor.xyz \t= color;\n    fragColor.w\t\t= 1.0;\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 84, 84, 146], [148, 148, 205, 255, 1684]], "test": "untested"}
{"id": "7tGXWd", "name": "window to viewport", "author": "jorge2017a2", "description": "window to viewport", "tags": ["windowtoviewport"], "likes": 2, "viewed": 228, "published": 3, "date": "1641503764", "time_retrieved": "2024-07-30T17:11:26.263544", "image_code": "//por jorge2017a2\n//window to viewport\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\nvec3 casa1(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-1.0), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 ); //techo\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.2), 2.5, 0.7, 0.5 );\n    \n    col= DrawFigBorde(vec3(0.5,0.6,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d4 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );    \n    return col;\n}\n\nvec3 casa3(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.5,-5.3), vec2(1.2,3.2) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.6), 4.0, 1.9, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.2), 2.5, 0.7, 0.5 );\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(1.0,0.8,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\nvec3 casa2(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 ); //techo\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(0.4,0.8,1.00),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\nvec3 casasTdo(vec2 p, vec3 col)\n{\n    float d1= sdBox(p-vec2(1.0,3.0), vec2(10.0,10.0) );\n    col= DrawFigBorde(vec3(0.0,0.3,0.8),col, d1 );\n    col= casa3(p-vec2(0.0,6.0),col);\n    col= casa1(p-vec2(-4.0,0.0),col);\n    col= casa2(p-vec2(5.0,0.0),col);\n    return col;\n}\n\nvec2 CambiarPantallaFijo(vec2 uv )\n{   float xv,xvmin, xvmax;\n    float yv,yvmin, yvmax;\n    float xw,xwmin,xwmax;\n    float yw,ywmin,ywmax;\n    float sx,sy;\n    \n    xvmin=0.0; xvmax=5.0; yvmin=0.0; yvmax=5.0;\n    xwmin=0.0;  xwmax=6.5; ywmin=0.0; ywmax=7.0;\n    \n    xw=uv.x; yw=uv.y;\n    \n    sx=(xvmax-xvmin)/(xwmax-xwmin);\n    sy=(yvmax-yvmin)/(ywmax-ywmin);\n    xv=sx*(xw-xwmin)+xvmin;\n    yv=sy*(yw-ywmin)+yvmin;\n    return vec2(xv,yv);\n}\n\nvec2 CambiarPantallavariable(vec2 uv )\n{   float xv,xvmin, xvmax;\n    float yv,yvmin, yvmax;\n    float xw,xwmin,xwmax;\n    float yw,ywmin,ywmax;\n    float sx,sy;\n    float t=iTime*0.5;    \n    xvmin=0.0; xvmax=3.0;\n    yvmin=0.0; yvmax=3.0;\n    \n    xwmin=0.0; xwmax=5.0+4.0*sin(t);\n    ywmin=0.0; ywmax=5.0+4.0*cos(t);;\n    xw=uv.x;     yw=uv.y;\n    \n    sx=(xvmax-xvmin)/(xwmax-xwmin);\n    sy=(yvmax-yvmin)/(ywmax-ywmin);\n    xv=sx*(xw-xwmin)+xvmin;\n    yv=sy*(yw-ywmin)+yvmin;\n    \n    return vec2(xv,yv);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(0.0);\n    \n    uv= rotatev2(uv, radians(iTime*10.0));\n    uv=CambiarPantallaFijo(uv );\n    col= casasTdo(uv, col);\n    \n    uv=CambiarPantallavariable(vec2(-uv0.x,uv0.y) );\n    col= casasTdo(uv, col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 358, 358, 403], [409, 409, 456, 456, 483], [484, 484, 527, 527, 554], [555, 555, 603, 603, 631], [634, 634, 706, 706, 832], [834, 834, 896, 896, 1026], [1028, 1028, 1109, 1109, 1237], [1239, 1239, 1296, 1296, 1366], [1368, 1368, 1430, 1430, 1495], [1497, 1497, 1565, 1565, 1633], [1635, 1635, 1699, 1699, 1770], [1773, 1773, 1807, 1807, 1902], [1904, 1904, 1941, 1941, 2015], [2017, 2017, 2052, 2052, 2075], [2077, 2077, 2129, 2129, 2245], [2247, 2247, 2272, 2272, 2291], [2292, 2292, 2317, 2317, 2336], [2337, 2337, 2373, 2373, 2401], [2404, 2404, 2469, 2469, 2779], [2783, 2783, 2834, 2834, 3142], [3145, 3145, 3211, 3211, 3553], [3556, 3556, 3586, 3586, 4298], [4300, 4300, 4330, 4330, 5501], [5503, 5503, 5533, 5533, 6713], [6715, 6715, 6748, 6748, 6985], [6987, 6987, 7023, 7023, 7432], [7434, 7434, 7474, 7474, 7949], [7951, 7951, 8008, 8008, 8467]], "test": "untested"}
{"id": "7ltSRS", "name": "water/fire waves (short)", "author": "xnio94", "description": "2d waves\nshort code at twigl bit.ly/3zwyH6R", "tags": ["2d", "waves", "water", "sin"], "likes": 1, "viewed": 251, "published": 3, "date": "1641500520", "time_retrieved": "2024-07-30T17:11:27.035481", "image_code": "/*\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    i /= iResolution.xy*.25;  o-=o;\n    float z = sin(iTime-length(i-vec2(2.,0))*8.);\n    float d = 13. * length(sin(9.*i)) * z;\n    d = sqrt(sin(d)+1.)*.7;\n    o = vec4(.2,d,d+1.,1.0);\n    o += (o.bgra-o) * max(z,0.);   \n}\n*/\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    i /= iResolution.xy;  o-=o;\n    float z = sin(iTime-length(i-.5)*8.);\n    float d = 13. * length(sin(9.*i)) * z;\n    d = sqrt(sin(d)+1.)*.7;\n    o = vec4(.2,d,d+1.,1.0);\n    o += (o.bgra-o) * max(z,0.);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 314, 314, 526]], "test": "untested"}
{"id": "7tySWt", "name": "Sedimentation", "author": "wyatt", "description": "when making an erosion simulation, it's important not to forget sedimentation. What you take, you must return", "tags": ["fluid", "automata"], "likes": 29, "viewed": 544, "published": 3, "date": "1641494301", "time_retrieved": "2024-07-30T17:11:27.806419", "image_code": "// Controls in Common\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 \n        n = (C(U+vec2(0,1))),\n        e = (C(U+vec2(1,0))),\n        s = (C(U-vec2(0,1))),\n        w = (C(U-vec2(1,0)));\n    vec4 c = A(U).xyzw;\n    vec3 no = normalize(vec3(e.x-w.x+e.y-w.y,n.x-s.x+n.y-s.y,.5));\n    Q = vec4(1,.7,.4,1)-vec4(1,.5,0,0)*c.wwww;\n    float a = .5;\n    no.zy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    no.zx *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    Q*=max(0.,.2+.8*no.z);\n\t\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 c = C(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y)) \n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 c = C(U+u);\n        float f = 0.25*(a.w+c.x);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    // erosion \n    c.z;\n    // sedimentation\n    c.w;\n    Q.w += 1e-5;\n    if (Q.w>0.) Q.z = (Q.w*Q.z+c.z-c.w)/Q.w;\n    if (U.x<1.&&abs(U.y-.5*R.y)<20.) Q.w *= 0.;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    Q = clamp(Q,-3.,3.);\n    if(length(U-M)<.02*R.y)Q.w = 1.;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,.3);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float wa = 0.5*Q.w*min(i,.51);\n       float wb = 0.5*q.w*max(i-.51,0.);\n       dQ.xyz += Q.xyz*wa+q.xyz*wb;\n       dQ.w += wa+wb;\n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = C(U);\n    vec4 a = A(U);\n    vec4 \n        n = (C(U+vec2(0,1))),\n        e = (C(U+vec2(1,0))),\n        s = (C(U-vec2(0,1))),\n        w = (C(U-vec2(1,0)));\n    Q.x -= .0005*(Q.x-0.25*(n+e+s+w).x);\n    // erosion\n    Q.z = 1e-2*length(a.xy)*a.w;\n    // sedimentation\n    Q.w = 1e-2*max(1.-length(a.xy),0.)*a.w*a.z;\n    \n    Q.x -= Q.z-Q.w;\n    Q.x = clamp(Q.x,-2.,2.);\n    if (iFrame < 100)\n        Q = vec4(B(U).x,0,0,0);\n}", "buffer_c_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tySWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 64, 64, 484]], "test": "untested"}
{"id": "NtyXDd", "name": "Pipe Maze in SMB3", "author": "IWBTShyGuy", "description": "random generate pipe maze in SMB3", "tags": ["bitmap", "truchet"], "likes": 7, "viewed": 308, "published": 3, "date": "1641492099", "time_retrieved": "2024-07-30T17:11:28.685070", "image_code": "// Copyright  2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// bitmap reference\n// https://www.spriters-resource.com/nes/supermariobros3/sheet/81122/\n\nconst vec3 PALLET[] = vec3[](\n    vec3(0),\n    vec3(0xb0, 0xfc, 0xcc) / 255.0,\n    vec3(0x00, 0x90, 0x38) / 255.0,\n    vec3(0x00, 0x3c, 0x14) / 255.0,\n    vec3(0xa4, 0x00, 0x00) / 255.0,\n    vec3(0xfc, 0x98, 0x38) / 255.0,\n    vec3(0xfc, 0xbc, 0xb0) / 255.0\n);\n\nconst vec3 DARK_WHITE = vec3(0x17, 0x3f, 0x5b) / 255.0;\n\nconst uint BITMAP[] = uint[](\n    858993459U,858993459U,858993459U,858993459U,286331155U,286331153U,286331153U,823202065U,\n    286396963U,572662050U,842142242U,857944882U,286396963U,572662050U,842142242U,857944882U,\n    286396963U,572662050U,842142242U,857944882U,286396963U,572662050U,842142242U,857944882U,\n    286396963U,572662050U,842142242U,857944882U,286396963U,572662050U,842142242U,857944882U,\n    286396963U,572662050U,842142242U,857944882U,286396963U,572662050U,842142242U,857944882U,\n    286396963U,572662050U,842142242U,857944882U,286396963U,572662050U,842142242U,857944882U,\n    286396963U,572662050U,842142242U,857944882U,286396963U,572662050U,842142242U,857944882U,\n    858993459U,858993459U,858993459U,858993459U,858993459U,858993459U,858993459U,858993459U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    287384112U,572658209U,589504802U,53621555U,287384112U,572658209U,589504802U,53621555U,\n    1073741824U,1145324612U,1145324612U,71582788U,1145044992U,1431655765U,1431655765U,1146443093U,\n    1430536192U,1431655765U,1431655765U,1163150677U,1431651328U,1431655765U,1431655765U,1162241109U,\n    1431655424U,1431655765U,1431655765U,1162232917U,1431655488U,1431655765U,1431655765U,1163150676U,\n    1431655744U,1431655765U,1431655765U,1163220292U,1431655748U,1431655765U,1431655765U,1163215941U,\n    1431655764U,1431655765U,1431655765U,1163220309U,1431655764U,1431655765U,1431655765U,1163220309U,\n    1431655764U,1431655765U,1431655765U,1163220309U,1431655764U,1431655765U,1431655765U,1163220309U,\n    1431655764U,1431655765U,1431655765U,1163220309U,1431655764U,1431655765U,1431655765U,1163220309U,\n    1431655764U,1431655765U,1431655765U,1163220309U,1431655764U,1431655765U,1431655765U,1163220309U\n);\n\nconst int TILE[] = int[](\n    // tile 0\n    0, 0, 5, 0, 0,\n    0, 0, 5, 0, 0,\n    6, 6, 7, 6, 6,\n    0, 0, 5, 0, 0,\n    0, 0, 5, 0, 0,\n\n    // tile 1\n    0, 0, 5, 0, 0,\n    0, 0, 3, 0, 0,\n    6, 2, 0, 4, 6,\n    0, 0, 1, 0, 0,\n    0, 0, 5, 0, 0,\n    \n    // tile 2\n    0, 1, 5, 0, 0,\n    0, 5, 8, 6, 2,\n    6, 11, 0, 9, 6,\n    4, 6, 10, 5, 0,\n    0, 0, 5, 3, 0,\n\n    // tile 3\n    0, 0, 5, 0, 0,\n    0, 0, 8, 6, 2,\n    6, 6, 6, 6, 6,\n    4, 6, 10, 0, 0,\n    0, 0, 5, 0, 0,\n\n    // tile 4\n    0, 0, 8, 6, 10,\n    0, 0, 0, 0, 5,\n    6, 6, 10, 0, 8,\n    0, 0, 5, 0, 0,\n    0, 0, 5, 0, 0\n);\n\nint getBitmapIdx(in ivec2 U, in int unitIdx) {\n    switch (unitIdx) {\n        case 0: return 512;\n        case 1: return U.y < 16 ? (15 - U.y) * 32 + U.x : 512;\n        case 2: return U.x < 16 ? (15 - U.x) * 32 + 31 - U.y : 512;\n        case 3: return U.y > 15 ? (U.y - 16) * 32 + U.x : 512;\n        case 4: return U.x > 15 ? (U.x - 16) * 32 + 31 - U.y : 512;\n        case 5: return (31 - U.y % 16) * 32 + U.x;\n        case 6: return (31 - U.x % 16) * 32 + 31 - U.y;\n        case 7: return min(63 - U.y, 32 + U.y) * 32 + max(31 - U.x, U.x);\n        case 8: return min(63 - U.y, 32 + U.y) * 32 + max(sign(U.y - 15) * (31 - U.x), U.x);\n        case 9: return min(63 - U.y, 32 + U.y) * 32 + max(sign(15 - U.y) * (31 - U.x), U.x);\n        case 10: return min(63 - U.y, 32 + U.y) * 32 + max(31 - U.x, sign(15 - U.y) * U.x);\n        case 11: return min(63 - U.y, 32 + U.y) * 32 + max(31 - U.x, sign(U.y - 15) * U.x);\n    }\n}\n\nvec3 unitColor(in ivec2 U, in int unitIdx) {\n    int idx = getBitmapIdx(U, unitIdx);\n    return PALLET[(BITMAP[idx/8]>>idx*4)%16u];\n}\n\nvec3 darkUnitColor(in ivec2 U, in int unitIdx) {\n    int idx = getBitmapIdx(U, unitIdx);\n    switch ((BITMAP[idx/8]>>idx*4)%16u) {\n        case 1u:\n        case 4u:\n            return DARK_WHITE;\n        default:\n            return vec3(0);\n    }\n}\n\n// If one simply rotates and flips the bitmap, the highlights will be off.\n// These transformations are represented by substitutions.\nconst int ROT_UNIT[12] = int[](0, 2, 3, 4, 1, 6, 5, 7, 9, 10, 11, 8);\nconst int SYM_UNIT[12] = int[](0, 1, 4, 3, 2, 5, 6, 7, 11, 10, 9, 8);\n\nstruct Tile {\n    int idx;\n    bool rot;\n    bool sym;\n};\n\nint getUnitIdx(in ivec2 U, in Tile tile) {\n    if (tile.sym) U = ivec2(4 - U.x, U.y);\n    if (tile.rot) U = ivec2(4 - U.y, U.x);\n    int unitIdx = TILE[tile.idx * 25 + (4 - U.y) * 5 + U.x];\n    if (tile.rot) unitIdx = ROT_UNIT[unitIdx];\n    if (tile.sym) unitIdx = SYM_UNIT[unitIdx];\n    return unitIdx;\n}\n\nvec3 tileColor(in ivec2 U, in Tile tile) {\n    return unitColor(U % 32, getUnitIdx(U / 32, tile));\n}\n\nvec3 tileDarkColor(in ivec2 U, in Tile tile) {\n    return darkUnitColor(U % 32, getUnitIdx(U / 32, tile));\n}\n\nTile getTile(int randomIdx) {\n    switch (randomIdx) {\n        case 0: return Tile(0, false, false);\n        case 1: return Tile(1, false, false);\n        case 2: return Tile(2, false, false);\n        case 3: return Tile(2, false, true);\n        case 4: return Tile(3, false, false);\n        case 5: return Tile(3, true, false);\n        case 6: return Tile(3, false, true);\n        case 7: return Tile(3, true, true);\n        case 8: return Tile(4, false, false);\n        case 9: return Tile(4, true, false);\n        case 10: return Tile(4, false, true);\n        default: return Tile(4, true, true);\n    }\n}\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage(out vec4 O, in vec2 FC) {\n    ivec2 U = ivec2(FC + iTime * iResolution.x / 24.0);\n    vec3 c = tileColor(U % 160, getTile(int(hash(uvec3(U / 160, 1)).x * 12.0)));\n    if (c == vec3(0)) {\n        U = ivec2(FC + iTime * iResolution.x / 48.0);\n        c = tileDarkColor(U % 160, getTile(int(hash(uvec3(U / 160, 1)).y * 12.0)));\n    }\n    O = vec4(c, 1);\n}\n", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyXDd.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[3386, 3386, 3432, 3432, 4304], [4306, 4306, 4350, 4350, 4439], [4441, 4441, 4489, 4489, 4689], [5025, 5025, 5067, 5067, 5330], [5332, 5332, 5374, 5374, 5432], [5434, 5434, 5480, 5480, 5542], [5544, 5544, 5573, 5573, 6151], [6153, 6194, 6214, 6214, 6390], [6392, 6392, 6432, 6432, 6759]], "test": "untested"}
{"id": "NlGSWd", "name": "Genuary 2022 - Day6", "author": "z0rg", "description": "My participation to genuary 2022\nThe original creation I \"trade\" : https://www.instagram.com/p/CV-tjLSIgMu/\nMy friend does not generative though", "tags": ["generative", "genuary", "2022", "tradestyle"], "likes": 33, "viewed": 586, "published": 3, "date": "1641490824", "time_retrieved": "2024-07-30T17:11:29.550755", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if(a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    p.xy *= r2d(.25);\n        p.xz *= r2d(.25);\n\n    p -= vec3(1.,1.2,0.);\n    vec2 acc = vec2(10000.,-1.);\n    float shape = length(p)-1.;\n    shape = max(shape, -(length(p.xy)-.5));\n    shape = max(shape, -(length(p)-.8));\n    float mat = 0.0;\n    if (length(p) > .9)\n    {\n        mat = 1.;\n        float th = 0.04;\n        if (abs(length(p.xz)-.2)-th < 0.)\n            mat = 3.;\n        if (abs(length(p.yz)-.2)-th < 0.)\n            mat = 3.;\n    }\n       \n    if (length(p.xy) < .51)\n        mat = 2.;\n\n        \n    acc = _min(acc, vec2(shape, mat));\n    \n    float antena = max(max(length(p.xz)-.015, p.y+.5), -p.y-2.);\n    antena = min(antena, length(p-vec3(0.,-2.,0.))-.1);\n    acc = _min(acc, vec2(antena, 0.));\n    return acc;\n}\n\nfloat grass(vec2 uv)\n{\n    uv.x+= sin(uv.y*20.+iTime)*.02;\n    float h= mix(.01,.02, sat(sin(uv.x)*.5+.5));\n    return uv.y-h*asin(sin(uv.x*250.+sin(uv.y*2.)*20.+sat(3.+uv.y*15.)*iTime));\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  vec3 p = ro;\n  for (int i = 0; i<steps;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n    p+= rd*res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec2 buv = uv;\n    float baseT = iTime*.1;\n    float t = sin(baseT)*.5;\n    vec3 col = mix(vec3(0.694,0.827,0.824), vec3(0.796,0.882,0.871), sat(-uv.y));\n    \n    float xA = uv.x+t*.125;\n    float mountA = uv.y+.1-0.05*sin(xA*5.)+0.01*asin(sin(xA*10.));\n    vec3 mountACol = mix(vec3(0.627,0.710,0.690)*.8, vec3(0.702,0.784,0.765), sat(sin(14.6*length(vec2(xA,uv.y)-vec2(0.2,1.))*10.)*sin(length(vec2(xA,uv.y)-vec2(0.,1.))*50.)*1000.));\n    col = mix(col, mountACol, 1.-sat(mountA*40000.));\n    float xB = uv.x+t*.25;\n    float mountB = uv.y+.1-0.02*sin(xB*10.)+0.01*asin(sin(xB*10.));\n    col = mix(col, vec3(0.729,0.553,0.541), 1.-sat(mountB*40000.));\n    \n    vec3 ro = vec3(sin(t)*10.,0.,10.*cos(t));\n    vec3 ta = vec3(t*4.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, buv);\n    \n    vec3 res = trace(ro, rd, 128);\n    \n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        vec3 ldir = normalize(vec3(1.,-1.,1.));\n        \n        col = n*.5+.5;\n        if (res.z == 0.)\n            col = vec3(.1);\n        if (res.z == 1. || res.z == 3.)\n            col = mix(vec3(.8), vec3(.92), sat(dot(n,ldir)*100.));\n        if (res.z == 2.)\n            col = vec3(.4);\n        if (res.z == 3.)\n            col *= .75;\n    }\n    \n    \n    float xC = uv.x+t*.5;\n    float mountC = uv.y+.15-0.02*sin(xC*7.)+0.01*asin(sin(xC*10.));\n    col = mix(col, vec3(0.824,0.392,0.388), 1.-sat(mountC*40000.));\n    \n\n    float xD = uv.x+t;\n    float mountD = uv.y+.17-0.02*sin(-xD*10.+4.)+0.015*asin(sin(xD*7.));\n    mountD += .2+grass(uv);\n    col = mix(col, vec3(0.776,0.314,0.314), 1.-sat(mountD*40000.));\n    float xE = uv.x+t*2.;\n    float mountE = uv.y+.3-0.04*sin(-xE*10.+4.)+0.015*asin(sin(xE*7.));\n    mountE += .2+grass(uv);\n    col = mix(col, vec3(0.541,0.173,0.173), 1.-sat(mountE*40000.));\n    uv.y -= .2;\n    float xCloud = uv.x+t*.0125;\n    float cloud =  max(uv.y-asin(sin(xCloud*5.))*.02-sin(xCloud*5.-iTime*.25)*.03, -(uv.y+.03-.02*(sin(xCloud*5.+iTime*.25))));\n    \n    col = mix(col, vec3(0.776,0.875,0.863), 1.-sat(cloud*40000.));\n    \n    //col = vec3(1.)*sat(*40000.);\n//    float t3d = iTime*.1;\n\n    \n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float stp = .005;\n    \n    uv = floor(uv/stp)*stp;\n    vec3 col = rdr(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSWd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 448, 448, 506], [508, 508, 535, 535, 587], [589, 589, 607, 607, 1346], [1348, 1348, 1370, 1370, 1537], [1539, 1539, 1570, 1570, 1701], [1703, 1703, 1734, 1734, 1842], [1843, 1843, 1884, 1884, 2068], [2070, 2070, 2089, 2089, 4283], [4286, 4286, 4343, 4343, 4520]], "test": "untested"}
{"id": "slVSzy", "name": "Deterministic Ray Tracer", "author": "stack_overflow", "description": "This shader implements of a \"deterministic\" ray tracer (as contrary to MC). It was used for educational purpose only. It is close to a Whitted Path Tracer. It obviously misses the refraction part to keep the code simple.", "tags": ["raytracer", "whitted"], "likes": 10, "viewed": 564, "published": 3, "date": "1641479985", "time_retrieved": "2024-07-30T17:11:30.386520", "image_code": "// Simple Deterministic Ray Tracer\n// ================================\n//\n// This shadertoy renders a simplistic scene using a deterministic ray tracing\n// technique. It is close to a Whitted Ray but lacks refractions. Due to\n// limitation of GLSL, it is not trivial to implement a recursion needed in\n// such a ray tracer. While workaround may be possible, that would over\n// complicate the code.\n//\n// In fact, the main intent for this code was to showcase the basics of ray\n// tracing for educational purposes and KISS.\n\n\n#define T_MIN 0.01\n#define T_MAX 1000.0\n#define N_BOUNCES 5\n\n\nstruct ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\nstruct hit_rec \n{\n  vec3 position;\n  vec3 normal;\n  float dist;\n  int diff;\n  vec2 uv;\n};\n\n\n// ----------------------------------------------------------------------------\n// Materials\n// ----------------------------------------------------------------------------\n\n#define DIFF_GREEN        0\n#define DIFF_YELLOW       1\n#define DIFF_CHECKERBOARD 2\n\n\nbool checkerboard(in vec2 uv, float cols, float lines)\n{\n    uv = vec2(cols, lines) * uv;\n    \n    return (mod(uv.x + floor(mod(uv.y, 2.0)), 2.0) < 1.0);\n}\n\n\nvec3 eval_diffuse(in hit_rec rec) {\n    switch (rec.diff) {\n        case DIFF_GREEN:  return vec3(0.0, 0.8, 0.0);\n        case DIFF_YELLOW: return vec3(0.8, 0.8, 0.0);\n        case DIFF_CHECKERBOARD:\n            if (checkerboard(rec.uv, 6., 6.)) {\n                return vec3(.8, 0., 0.);\n            } else {\n                return vec3(.8);\n            }\n        default: return vec3(0.);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// Hit functions and Geometry\n// ----------------------------------------------------------------------------\n\n// Sphere\n\nstruct sphere\n{\n    vec3 center;\n    float radius;\n    int diff;\n};\n\n\nbool hit_sphere(in sphere s, in ray r, out hit_rec rec)\n{\n\tvec3 l = s.center - r.origin;\n    float u = dot(l, r.direction);\n    float l_sqr = dot(l, l);\n    float r_sqr = s.radius*s.radius;\n    \n    // No hit found so far\n    rec.dist = -1.0;\n    \n    if (u < 0.0 && l_sqr > r_sqr) {\n        return false;\n    }\n    \n    float m_sqr = l_sqr - u*u;\n    \n    if (m_sqr > r_sqr) {\n        return false;\n    }\n    \n    // Hit found\n    float q = sqrt(r_sqr - m_sqr);\n    \n    if (l_sqr > r_sqr) {\n        // outside\n        rec.dist = u - q;\n        rec.position = r.origin + rec.dist*r.direction;\n    \trec.normal   = normalize(rec.position - s.center);\n    } else {\n        // inside\n        rec.dist = u + q;\n        rec.position = r.origin + rec.dist*r.direction;\n    \trec.normal   = normalize(s.center - rec.position);\n    }\n    \n    rec.diff = s.diff;\n    \n    return true;\n}\n\n\n// ----------------------------------------------------------------------------\n\n// Triangle\n\nstruct triangle \n{\n    vec3 a, b, c;\n    vec2 uv_a, uv_b, uv_c;\n   \tint diff;\n};\n\n\nbool hit_triangle(in triangle t, in ray r, out hit_rec rec) \n{\n\tvec3 e1 = t.b - t.a;\n    vec3 e2 = t.c - t.a;\n    vec3 q = cross(r.direction, e2);\n    float a = dot(e1, q);\n    \n    // No hit found so far\n    rec.dist = -1.0;\n    \n    if (a < T_MIN) {\n        return false;\n    }\n    \n    float f = 1. / a;\n    vec3 s = r.origin - t.a;\n    float u = f * dot(s, q);\n    \n    if (u < 0. || u > 1.) {\n        return false;\n    }\n    \n    vec3 rt = cross(s, e1);\n    float v = f * dot(r.direction, rt);\n    \n    if (v < 0.0 || (u + v) > 1.0) {\n        return false;\n    }\n    \n    float w = (1. - u - v);\n\n    // Hit found\n    rec.dist     = f * dot(e2, rt);\n    rec.position = r.origin + rec.dist*r.direction;\n    rec.normal   = normalize(cross(e1, e2));\n    rec.diff = t.diff;\n    rec.uv = u * t.uv_b + v * t.uv_c + w * t.uv_a;\n    \n    return true;\n}\n\n\n// ----------------------------------------------------------------------------\n// Scene definition\n// ----------------------------------------------------------------------------\n\n// Lighting\n\nvec3 ambiant = vec3(0.01, 0.01, 0.05);\n\n\nstruct light\n{\n    vec3 position;\n    vec3 power;\n};\n\n\nconst int n_lights = 1;\n\nlight[1] lights = light[](\n     light(vec3(-3, 3., 1.), vec3(15.))\n);\n\n\n// ----------------------------------------------------------------------------\n\n// Geometry\n\nconst int n_spheres = 2;\n\nsphere[2] spheres = sphere[](\n    //           Center             radius     diffuse\n    sphere(vec3(-0.125, 0.25, 0.35),  0.25,  DIFF_GREEN),\n    sphere(vec3( 0.18,  0.25, -0.12), 0.25,  DIFF_YELLOW)    \n);\n\n\nconst int n_triangles = 2;\n\ntriangle[2] triangles = triangle[](\n    triangle(\n        // Coords\n        vec3(-1., 0., -1.), \n        vec3(-1., 0.,  1.),\n        vec3( 1., 0., -1.),\n        // uv\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    ),\n    triangle(\n        // Coords\n        vec3(-1., 0.,  1.),\n        vec3( 1., 0.,  1.), \n        vec3( 1., 0., -1.),\n        // uv\n        vec2(1, 0),\n        vec2(1, 1),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    )\n);\n\n\n// ----------------------------------------------------------------------------\n// Ray tracing\n// ----------------------------------------------------------------------------\n\n// Hit function to check if a ray hit something in the scene\nbool hit(in ray r_in, inout hit_rec rec) \n{\n    hit_rec curr_rec;\n    rec.dist = -1.;\n    \n    bool hit_found = false;\n    \n    // Find closest sphere intersection\n    for (int i = 0; i < n_spheres; i++) {\n        if (   hit_sphere(spheres[i], r_in, curr_rec) \n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }\n    }\n\n    // Find closest triangle intersection\n    for (int i = 0; i < n_triangles; i++) {\n        if (   hit_triangle(triangles[i], r_in, curr_rec)\n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }  \n    }\n    \n    return hit_found;\n}\n\n\n// Trace ray and return the resulting contribution of this ray\nvec3 trace_ray(in ray r, in int n_bounces)\n{\n    hit_rec rec;\n    \n    vec3 ret_col = vec3(0.);\n    vec3 attenuation = vec3(1.);\n    \n    for (int i = 0; i < n_bounces; i++) {\n        if (hit(r, rec)) {\n            // get the diffuse color\n            vec3 diffuse = eval_diffuse(rec);\n                \n            for (int l = 0; l < n_lights; l++) {\n                vec3 light_dir = lights[i].position - rec.position;\n                float light_dist = length(light_dir);\n\n                light_dir = normalize(light_dir);\n\n                // check if in shade: launch a ray from the lightsource to the sphere\n                ray shadow_ray = ray(lights[i].position, -light_dir);\n\n                hit_rec shadow_ray_rec;\n                hit(shadow_ray, shadow_ray_rec);\n\n                if (shadow_ray_rec.dist > light_dist - T_MIN) {\n                    // BRDF: the geometry is directly light by the lightsource\n                    float lambert = max(0., dot(light_dir, rec.normal));\n                    vec3 light_power = lights[i].power / (light_dist * light_dist);\n                    ret_col += attenuation * diffuse * lambert * light_power;\n                }\n            }\n            \n            // Ambiant lighting, always affecting the hitpoint\n            ret_col += attenuation * ambiant * diffuse;\n            \n            // Generate the reflected ray\n            r.direction = normalize(reflect(r.direction, rec.normal)); \n            r.origin = rec.position + r.direction * 5. * T_MIN;\n            \n            // Compute the Fresnel term using Schlick's approximation\n            float n1 = 1.;\n            float n2 = 2.1;\n            float r0 = (n1 - n2)/(n1 + n2);\n            r0 = r0*r0;\n            float fresnel = r0 + (1. - r0) * pow(1. - dot(rec.normal, r.direction), 5.);\n            \n            attenuation *= fresnel;\n        } else {\n            // No hit found, use the background instead\n            ret_col += attenuation * ambiant;\n            break;\n        }\n    }\n    \n    return ret_col;\n}\n\n\n// ----------------------------------------------------------------------------\n// Camera\n// ----------------------------------------------------------------------------\n\nstruct camera \n{\n  \tvec3 look_from;\n  \tvec3 look_at;\n    vec3 up;\n    float fov;\n    float aspect;\n};\n\n\n// Generate a primary ray\nray get_ray(in camera c, in vec2 uv) \n{\n\tfloat theta = c.fov * 3.14/180.0;\n    float h_height = tan(theta/2.0);\n    float h_width = c.aspect * h_height;\n    \n    vec3 w = normalize(c.look_from - c.look_at);\n    vec3 u = normalize(cross(c.up, w));\n    vec3 v = normalize(cross(w, u));\n    \n    vec3 ll = c.look_from - h_width*u - h_height*v - w;\n    vec3 horizontal = 2.0 * h_width * u;\n    vec3 vertical   = 2.0 * h_height * v;\n    \n    return ray(\n        c.look_from, \n        normalize(ll + uv.x*horizontal + uv.y*vertical - c.look_from)\n    );\n}\n\n\n// ----------------------------------------------------------------------------\n// Main image\n// ----------------------------------------------------------------------------\n\n// linear sRGB to gamma corrected sRGB\nfloat to_sRGB(in float c) {\n    if (abs(c) < 0.0031308) {\n        return c * 12.92;\n    } else {\n     \treturn 1.055 * pow(c, 1./2.4) - 0.055;        \n    }    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rotate the camera around\n\n    vec3 look_from = vec3(0., 1., 2.);\n    \n    float theta = iTime / 3.;\n    \n    mat3 rot = mat3(\n        cos(theta), 0., -sin(theta),\n        0., 1., 0.,\n        -sin(theta), 0., cos(theta));\n        \n    look_from = rot * look_from;\n    \n    camera cam = camera(\n        look_from,        // Look-from\n        vec3(0., 0., 0.), // Look-at\n        vec3(0., 1., 0.), // Up\n        35.,              // fov: 2.0*atan(sensor_width/(2.0*focal_length))\n        iResolution.x/iResolution.y\n    );\n    \n    // Generate a primary ray\n    ray r = get_ray(cam, uv);\n    \n    // Trace this ray\n    vec3 col = trace_ray(r, N_BOUNCES);\n    \n    // Linear to gamma corrected sRGB\n    for (int i = 0; i < 3; i++) {\n        col[i] = to_sRGB(col[i]);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[995, 995, 1051, 1051, 1150], [1153, 1153, 1188, 1188, 1551], [1826, 1826, 1883, 1883, 2702], [2882, 2882, 2944, 2944, 3731], [5181, 5242, 5285, 5285, 5950], [5953, 6016, 6060, 6060, 8046], [8324, 8350, 8389, 8389, 8899], [9077, 9116, 9143, 9143, 9277], [9280, 9280, 9335, 9385, 10264]], "test": "untested"}
{"id": "7tVXDc", "name": "Failed Spline Idea", "author": "SnoopethDuckDuck", "description": "The gradients mostly line up, but often come from the wrong direction.\n\n(change ichannel0 to buffer A in Image, to see simpler version)", "tags": ["e"], "likes": 6, "viewed": 275, "published": 3, "date": "1641472277", "time_retrieved": "2024-07-30T17:11:31.261182", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n\n    vec3 e = vec3(1.);\n    vec3 col2 = 2.5 * x * pal(mix(0.3, 0.35, 0.5 + 0.5 * thc(2., iTime)), e, e, e, vec3(0., 0.33, 0.66));\n    fragColor = vec4(col2, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;   \n\n    // Get random value with time\n    float time = 0.5 * cos(iTime) - 1. * iTime;\n    // Offset y values from x values\n    float o = 0.1;\n    float sc = 0.8;// + 0.5 * cos(iTime);\n    \n    // Next 4 points in sequence\n    // (bad approach - has a bottom-left bias)\n    vec2 p0 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time))),      h21(vec2(o + floor(time))) );\n    vec2 p1 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 1.))), h21(vec2(o + floor(time + 1.))) );\n    vec2 p2 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 2.))), h21(vec2(o + floor(time + 2.))) );\n    vec2 p3 = -sc * 0.5 + sc * vec2( h21(vec2(floor(time + 3.))), h21(vec2(o + floor(time + 3.))) );\n\n    //float l12 = length(p2 - p1);\n    //float l23 = length(p3 - p2);\n\n    vec2 d12 = normalize(p2 - p1);\n    vec2 d23 = normalize(p3 - p2);\n    \n    float k = 1.; // idk what value is good here\n    \n    // x0 lies on p2 -> p1 line, x1 lies on p3 -> p2 line\n    vec2 x0 = p1 - k * d12;\n    vec2 x1 = p2 - k * d23;\n    \n    // p0 -> x0 line\n    float m0 = (x0.y - p0.y) / (x0.x - p0.x);\n    float c0 = p0.y - m0 * p0.x;\n    \n    // p1 -> x1 line\n    float m1 = (x1.y - p1.y) / (x1.x - p1.x);\n    float c1 = p1.y - m1 * p1.x;\n    \n    // Intersect x1 -> p1 line with p0 -> x0 line to get A,\n    // Lerp (p0 -> A) -> (A -> p1)   \n    float Ax = -(c1 - c0) / (m1 - m0);\n    float Ay = m1 * Ax + c1;\n    vec2 A = vec2(Ax, Ay); \n    // (I think nearly parallel lines mess up A, make it go beyond bounds)\n    A = clamp(A, -0.5, 0.5);\n    \n    float f = fract(time);\n    //f = smoothstep(0., 1., f);\n    //f = 16. * f * f * (1.-f) * (1.-f); // <- useful to visualise how it fails\n    vec2 q0 = mix(p0, A, f);\n    vec2 qA = mix(A, p1, f);\n    vec2 q = mix(q0, qA, f);\n   \n    // Distance from point + strength to smoothstep away from it\n    float d = length(uv-q);\n    float k2 = 0.06 + d;\n\n    // Draw stuff\n    float s = smoothstep(-k2, k2, -d + 0.);\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    x = 0.98 * clamp(x, 0., 1.);\n    \n    fragColor = vec4(max(x, 2. * s));\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Collection of functions I use a lot:\n\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Get \"point\" from Buffer A\n    vec2 p = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xy;\n    \n    // Distance from point + strength to smoothstep away from it\n    float d = length(uv-p);\n    d = pow(4. * d * (1.-d), 2.);\n    float k = 0.2 + d;\n\n    // Draw stuff\n    float s = smoothstep(-k, k, -d + 0.);\n    float x = texelFetch( iChannel1, ivec2(fragCoord), 0 ).x;\n    x = 0.98 * clamp(x, 0., 1.);\n    \n    fragColor = vec4(max(x, 2. * s));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 350]], "test": "untested"}
{"id": "7lKXWc", "name": "Genuary 2022 - Day5", "author": "z0rg", "description": "My participation to genuary 2022\nDestroy a square", "tags": ["generative", "genuary", "2022", "destroysquare"], "likes": 4, "viewed": 237, "published": 3, "date": "1641463725", "time_retrieved": "2024-07-30T17:11:32.584644", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nvec3 rdr(vec2 uv, float t)\n{\n    vec3 col = vec3(0.);\n    float acc = 1000.;\n    const int cnt = 9;\n    for (int x = 0; x < cnt; ++x)\n    {\n        for (int y = 0; y < cnt; ++y)\n        {\n            vec2 cpos = (vec2(x, y)/float(cnt-1)-vec2(.5))*2.;\n            vec2 pos = .05*cpos*pow(mod(t*2.,5.),5.);\n\n            float shape = _sqr((uv-pos), vec2(.05)*abs(sin(t*2.)));\n            acc = min(acc, shape);\n        }\n    }\n    col = mix(col, vec3(1.), 1.-sat(acc*iResolution.x*.5));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    float off = sin(iTime)*.1;\n\n\n    vec3 col = vec3(0.);\n    col.x = rdr(uv,iTime).x;\n    col.y = rdr(uv,iTime+off).y;\n    col.z = rdr(uv,iTime+off*2.).z;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKXWc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[428, 428, 447, 447, 505], [506, 506, 535, 535, 587], [589, 589, 617, 617, 1091], [1093, 1093, 1150, 1150, 1400]], "test": "untested"}
{"id": "slKXD3", "name": "Melange", "author": "dr2", "description": "Lots of stuff...", "tags": ["voronoi", "reflection", "architecture", "polyhedron", "pentakis", "flextube"], "likes": 27, "viewed": 386, "published": 3, "date": "1641458788", "time_retrieved": "2024-07-30T17:11:34.062692", "image_code": "// \"Melange\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define REFL  1  // (= 0/1) with reflections (perhaps slower compile)\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir, qHit;\nvec2 qTube, aRotCs[2];\nfloat dstFar, tCur, tubeRad, radBs, radUp, hUp;\nint idObj;\nbool isRefl;\nconst int idStr = 1, idRail = 2, idFlr = 3, idPil = 4, idEdge = 5, idFace = 6,\n   idTube = 7, idSph = 8, idRing = 9;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nconst int nSeg = 3;\nconst int nTube = 5;\n\nstruct TbCon {\n  vec3 pLo, pHi;\n  vec2 sRotCs[2], tRotCs[2];\n  float chLen, segRad;\n};\nTbCon tbCon[nTube];\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid SetConf ()\n{\n  vec3 vp, s;\n  float segLen, segAng, a, aRot[2];\n  segLen = 2.;\n  hUp = 6.8 + 2.8 * sin (0.25 * pi * tCur);\n  tubeRad = 0.15;\n  radBs = 7.;\n  radUp = 4.;\n  aRot[0] = 0.05 * pi * sin (pi * 0.8 * tCur);\n  aRot[1] = 0.05 * pi * sin (pi * (0.8 * tCur + 0.5));\n  aRotCs[0] = sin (aRot[0] + vec2 (0.5 * pi, 0.));\n  aRotCs[1] = sin (aRot[1] + vec2 (0.5 * pi, 0.));\n  for (int k = 0; k < nTube; k ++) {\n    a = 2. * pi * float (k) / float (nTube);\n    tbCon[k].pLo.y = 0.;\n    tbCon[k].pLo.xz = Rot2D (vec2 (radBs, 0.), a);\n    tbCon[k].pHi.y = hUp;\n    s.xz = Rot2D (vec2 (radUp, 0.), a);\n    s.xy = Rot2D (vec2 (s.x, 0.), - aRot[0]);\n    s.zy = Rot2D (s.zy, - aRot[1]);\n    tbCon[k].pHi = vec3 (0., hUp, 0.) + s;\n    vp = tbCon[k].pHi - tbCon[k].pLo;\n    tbCon[k].chLen = 0.5 * length (vp) / float (nSeg);\n    segAng = max (1e-4, SecSolve (tbCon[k].chLen / segLen));\n    tbCon[k].segRad = segLen / segAng;\n    tbCon[k].sRotCs[0] = sin (segAng + vec2 (0.5 * pi, 0.));\n    tbCon[k].sRotCs[1] = sin (- segAng + vec2 (0.5 * pi, 0.));\n    tbCon[k].tRotCs[0] = sin (atan (vp.z, - vp.x) + pi + vec2 (0.5 * pi, 0.));\n    tbCon[k].tRotCs[1] = sin (asin (length (vp.xz) / length (vp)) + vec2 (0.5 * pi, 0.));\n  }\n}\n\nvec3 DodecSym (vec3 p)\n{   // (from \"Chinese Puzzle Balls 2\")\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat PentakDf (vec3 p, float rad, float dMin)\n{  // (pentakisdodecahedron from \"This Is Not A Reflected Pipe 2\")\n  vec3 q;\n  float d, a1, a2, s;\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  s = abs (dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) + rad);\n  d = SmoothMax (s - 0.1, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.1, 0.05);\n  DMIN (idEdge);\n  d = s - 0.05;\n  DMIN (idFace);\n  return dMin;\n}\n\nfloat TubesDf (vec3 p, float dMin)\n{  // (from \"Rock the Balls\")\n  vec3 q, pp;\n  vec2 b;\n  float d, s, pentRad;\n  pentRad = 3.5;\n  p.y -= 0.2;\n  q = p;\n  d = PrTorusDf (q.xzy, 0.5 * tubeRad, radBs);\n  q.y -= hUp;\n  q.xy = Rot2Cs (q.xy, aRotCs[0]);\n  q.zy = Rot2Cs (q.zy, aRotCs[1]);\n  d = min (d, PrTorusDf (q.xzy, 0.3 * tubeRad, radUp));\n  DMIN (idRing);\n  if (! isRefl) dMin = PentakDf (q, pentRad, dMin);\n  pp = p;\n  for (int k = VAR_ZERO; k < nTube; k ++) {\n    p = pp - tbCon[k].pLo;\n    p.xz = Rot2Cs (p.xz, tbCon[k].tRotCs[0]);\n    p.xy = Rot2Cs (p.xy, tbCon[k].tRotCs[1]);\n    p.xy = Rot2Cs (p.xy, tbCon[k].sRotCs[1]);\n    q = p;\n    d = PrSphDf (q, 1.1 * tubeRad);\n    DMIN (idSph);\n    s = 1.;\n    for (int j = 0; j < nSeg; j ++) {\n      q = p;\n      q.xy = Rot2Cs (vec2 (- q.y, q.x - tbCon[k].segRad), tbCon[k].sRotCs[0]);\n      b = vec2 (length (q.xy) - tbCon[k].segRad, q.z);\n      d = max (length (b) - tubeRad, dot (vec2 (abs (q.x), q.y), tbCon[k].sRotCs[0]));\n      p.xy = Rot2Cs (vec2 (q.y, - q.x), tbCon[k].sRotCs[0]);\n      p.x = - (p.x + tbCon[k].segRad);\n      s = - s;\n      if (d < dMin) qTube = atan (vec2 (- q.x, b.x), vec2 (- q.y, b.y)) * vec2 (tbCon[k].segRad, s);\n      DMIN (idTube);\n    }\n    q = p;\n    d = PrSphDf (q, 1.1 * tubeRad);\n    DMIN (idSph);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{  // (folly from \"Magic Tree 2\")\n  vec3 q, qs;\n  vec2 flShift, bcRad;\n  float dMin, d, s, aq, a, db, flGap, flRad, flWid, bcLen;\n  flGap = 4.;\n  flShift = vec2 (11.3, 3.9);\n  flRad = 9.85;\n  flWid = 1.7;\n  bcRad = vec2 (0.08, 0.05);\n  bcLen = 1.1;\n  dMin = dstFar;\n  q = p;\n  aq = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * aq / (2. * pi) + 0.5) / 4.));\n  qs.y = q.y;\n  qs.xz = Rot2D (q.xz + vec2 (flShift.x, 6.), -0.25 * pi);\n  db = PrBox2Df (qs.yz + vec2 (-8.9, 0.), vec2 (1.4, 0.5));\n  qs.xz = Rot2D (q.xz + vec2 (flShift.x, -6.), 0.25 * pi);\n  db = min (db, PrBox2Df (qs.yz + vec2 (-1.1, 0.), vec2 (1.2, 0.5)));\n  qs.y = q.y - flGap;\n  qs.xz = Rot2D (vec2 (q.x + flShift.x, abs (q.z) - 6.), -0.25 * pi);\n  q.xz = vec2 (- q.z, q.x + 6.);\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = vec2 (28. * a / (2. * pi), length (q.xz) - 8.);\n  q.y += 3.;\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  s = mod (q.x, 0.5 * sqrt (2.));\n  d = 0.3 * max (max (max (q.y - min (s, 0.5 * sqrt (2.) - s), abs (q.z) - 1.5), -0.07 - q.y),\n     qs.x - 0.1);\n  DMINQ (idStr);\n  q.z = abs (q.z);\n  q -= vec3 (- flShift.x, 1.4, 1.43);\n  d = max (min (PrCylDf (q.yzx, bcRad.x, 5.8), PrCylDf (vec3 (0.5 * mod (17.8 * a + 0.5, 1.) -\n     0.25, q.y + 0.7, q.z).xzy, bcRad.y, 0.7)), qs.x - 0.1);\n  DMIN (idRail);\n  q = p;\n  q.y = abs (qs.y + 0.05) - flShift.y;\n  d = PrCylAnDf (q.xzy, flRad, flWid, 0.15);\n  q.xz = qs.xz + vec2 (-2., 0.2);\n  d = min (d, PrBoxDf (q, vec3 (2.1, 0.15, 1.7)));\n  DMINQ (idFlr);\n  q = vec3 (p.x, abs (qs.y - 2.1) - flShift.y, p.z);\n  s = length (q.xz) - flRad;\n  d = min (length (vec2 (s + flWid - 0.15, q.y)) - bcRad.x,\n     max (length (vec2 (s - flWid + 0.15, q.y)) - bcRad.x, 2. - abs (qs.x - 2.)));\n  DMIN (idRail);\n  q.y = abs (qs.y - 1.) - flShift.y;\n  q.xz = Rot2D (p.xz, 2. * pi * (floor (128. * aq / (2. * pi) + 0.5) / 128.));\n  d = min (PrCylDf (vec3 (q.x + flRad - flWid + 0.15, q.yz).xzy, bcRad.y, bcLen),\n     max (PrCylDf (vec3 (q.x + flRad + flWid - 0.15, q.yz).xzy, bcRad.y, bcLen),\n     2. - abs (qs.x - 2.)));\n  DMIN (idRail);\n  d = max (min (PrCylDf (vec3 (qs.x - 2., abs (qs.y - 2.1) - flShift.y, qs.z - 1.45).yzx,\n     bcRad.x, 2.), PrCylDf (vec3 (mod (qs.x + 0.25, 0.5) - 0.25, abs (qs.y - 1.) - flShift.y,\n     qs.z - 1.45).xzy, bcRad.y, bcLen)), abs (qs.x - 2.) - 2.);\n  DMIN (idRail);\n  d = max (min (PrCylDf (vec3 (qs.x, abs (qs.y - 2.1) - flShift.y, qs.z), bcRad.x, 1.45),\n     max (PrCylDf (vec3 (qs.x, abs (qs.y - 1.) - flShift.y,\n     mod (qs.z + 0.25, 0.5) - 0.25).xzy, bcRad.y, bcLen), abs (qs.z) - 1.45)), - db);\n  DMIN (idRail);\n  d = min (PrCapsDf (vec3 (qs.x, abs (qs.y - bcLen) - flShift.y, qs.z - 1.43).xzy, 0.15, 1.2),\n     PrCapsDf (vec3 (qs.x, qs.y - bcLen, qs.z + 1.43).xzy, 0.15, flShift.y + 1.2));\n  DMINQ (idPil);\n  dMin = TubesDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.01, h);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.6);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 GrndNf (vec2 p, float d)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), (2. + 3. * d) * e.x)).xzy);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc, col4;\n  vec3 vn, col;\n  float dstObj, dstGrnd, r, s, sh, nDotL;\n  bool isBg;\n  SetConf ();\n  HexVorInit ();\n  isBg = false;\n  sh = 1.;\n  dstGrnd = dstFar;\n#if REFL\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    isRefl = (k == 1);\n    dstObj = ObjRay (ro, rd);\n    if (! isRefl && dstObj < dstFar && idObj == idFace) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n    } else break;\n  }\n#else\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n#endif\n  isRefl = false;\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    r = length (ro.xz);\n    if (idObj == idFlr) {\n      col4 = vec4 (0.9, 0.9, 1., 0.1);\n      if (abs (vn.y) > 0.99) {\n        if (r < 11.6) {\n          s = mod (2.42 * r, 2.);\n          col4 *= (0.8 + 0.2 * SmoothBump (0.08, 0.92, 0.02, fract (s))) *\n             (0.8 + 0.2 * SmoothBump (0.04, 0.96, 0.01,\n             fract (64. * atan (ro.z, - ro.x) / (2. * pi) + 0.5 * step (s, 1.))));\n        } else {\n          col4 *= 0.8 + 0.2 * SmoothBump (0.08, 0.92, 0.02, fract (2. * qHit.x));\n        }\n      } else if (abs (vn.y) < 0.01) col4 *= 0.8 +\n         0.2 * SmoothBump (0.2, 0.8, 0.03, fract (12. * ro.y));\n    } else if (idObj == idStr) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.9, 0.8, 0.2, 0.3);\n    } else if (idObj == idPil) {\n      col4 = vec4 (0.8, 0.7, 0.2, 0.3);\n    } else if (idObj == idTube) {\n      col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.6, 0.6, 1., 0.3),\n         step (0., sin (8. * pi * qTube.x + 3. * qTube.y)));\n    } else if (idObj == idSph) {\n      col4 = vec4 (0.7, 0.9, 0.7, 0.2);\n    } else if (idObj == idRing) {\n      col4 = vec4 (0.7, 0.9, 0.7, 0.2);\n    } else if (idObj == idEdge) {\n      col4 = vec4 (0.3, 0.3, 0.8, 0.3);\n    } else if (idObj == idFace) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.2);\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    r = length (ro.xz);\n    if (r < 8.1) {\n      vc = HexVor (4. * ro.xz);\n      vn = normalize (vec3 (- 0.9 * vc.yz, 1.)).xzy;\n      s = fract (16. * vc.w);\n      col4 = vec4 (HsvToRgb (vec3 (0.1 + 0.4 * step (2. * s, 1.) + 0.1 * fract (5. * s),\n         0.4 + 0.2 * fract (17. * s), 0.6 + 0.3 * fract (8. * s))) *\n         (0.6 + 0.4 * smoothstep (0., 0.2, vc.x)) * (0.7 + 0.3 * smoothstep (1.5, 2.5, r)), 0.2);\n    } else {\n      col4 = vec4 (mix (vec3 (0.4, 0.5, 0.3), vec3 (0.3, 0.4, 0.3),\n         0.2 + 0.6 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz))), 0.05);\n      vn = GrndNf (ro.xz, smoothstep (0.5, 0.8, dstGrnd / dstFar));\n    }\n  } else isBg = true;\n  if (! isBg) {\n    nDotL = max (dot (sunDir, vn), 0.);\n    if (dstObj < dstFar && idObj != idFlr && idObj != idStr) nDotL *= nDotL;\n    sh = 0.6 + 0.4 * ObjSShadow (ro + 0.01 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n       0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (dstObj >= dstFar && dstGrnd > 0.5 * dstFar) col = mix (col, vec3 (0.3, 0.4, 0.6),\n       pow (1. + rd.y, 16.));\n  } else col = SkyBgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 150.;\n  az = 0.;\n  el = -0.17 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2.5 * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    az -= 2.5 * pi * sin (0.003 * pi * tCur);\n    el += 0.15 * pi * cos (0.03 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 7. - 2. * cos (az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 5., -60.);\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 gVec[7], hVec[7];\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKXD3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1532, 1532, 1558, 1586, 1974], [1976, 1976, 1993, 1993, 3193], [3195, 3195, 3219, 3256, 3806], [3808, 3808, 3856, 3921, 4345], [4347, 4347, 4383, 4411, 5651], [5653, 5653, 5675, 5707, 8536], [8538, 8538, 8571, 8571, 8819], [8821, 8821, 8842, 8842, 9097], [9099, 9099, 9136, 9136, 9365], [9367, 9367, 9401, 9401, 10158], [10160, 10160, 10191, 10191, 10343], [10345, 10345, 10380, 10380, 13601], [13603, 13603, 13659, 13659, 14441], [14443, 14443, 14475, 14475, 14575], [14577, 14577, 14610, 14610, 14699], [14701, 14701, 14734, 14734, 14761], [14763, 14763, 14805, 14805, 14856], [14858, 14858, 14901, 14901, 14965], [14967, 14967, 15020, 15020, 15081], [15083, 15083, 15129, 15129, 15186], [15212, 15212, 15236, 15236, 15466], [15468, 15468, 15492, 15492, 15552], [15554, 15554, 15574, 15574, 15794], [15796, 15796, 15818, 15818, 16414], [16416, 16416, 16461, 16461, 16553], [16555, 16555, 16600, 16600, 16638], [16640, 16640, 16697, 16697, 16780], [16782, 16782, 16812, 16812, 16925], [16927, 16927, 16958, 16958, 17022], [17024, 17024, 17060, 17060, 17266], [17268, 17268, 17292, 17292, 17409], [17443, 17443, 17467, 17467, 17527], [17529, 17529, 17553, 17553, 17606], [17608, 17608, 17632, 17632, 17744], [17746, 17746, 17771, 17771, 17917], [17919, 17919, 17944, 17944, 18130], [18132, 18132, 18154, 18154, 18308], [18310, 18310, 18331, 18331, 18486]], "test": "untested"}
{"id": "7lVSD3", "name": "[Genuary 2022] Destructive Rain", "author": "oneshade", "description": "Another way to destroy a box.", "tags": ["particles", "box", "destroy", "genuary", "disintegrate"], "likes": 8, "viewed": 186, "published": 3, "date": "1641457269", "time_retrieved": "2024-07-30T17:11:35.053043", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float particles = texture(iChannel0, uv).x;\n    float rays = texture(iChannel1, uv).x;\n\n    fragColor = vec4(particles, 0.0, 0.0, 1.0);\n\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float dist = box(uv);\n    fragColor.rgb += max(0.0, smoothstep(unit, 0.0, dist) - rays);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rand(x) fract(485.375 * cos(284.583 * (x) + 824.587))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float unit = 4.0 / iResolution.x;\n\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, iFragCoord - ivec2(0, 1), 0);\n\n    if (iFragCoord.y < 1) {\n        float time = floor(float(iFrame) / 4.0) * 0.04;\n        uv.x = floor(uv.x / unit) * unit;\n        bool genBullet = abs(uv.x - 0.25 * sin(5.0 * time) - 0.5) < 0.005 && rand(uv.x - time) > 0.5;\n        float health = mix(0.25, 0.5, rand(uv.x + time));\n        fragColor = vec4(vec2(genBullet), health, 0.0);\n    }\n\n    float rays = texture(iChannel1, uv).x;\n\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    if (box(uv) < 0.0 && rays < 0.5) fragColor.w += 0.1;\n    if (fragColor.w > fragColor.z) fragColor = vec4(0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float box(in vec2 p) {\n    p.y -= 0.2;\n    p = abs(p) - 0.25;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = max(texture(iChannel0, uv), texture(iChannel1, uv));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 431]], "test": "untested"}
{"id": "7tyXWc", "name": "Scaled MNCA", "author": "davidar", "description": "Using mipmaps, resolution scaling, and some other micro-optimisations to speed up slackermanz's MNCA. About 45x faster than the original on my machine", "tags": ["2d", "simulation", "mipmap", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 12, "viewed": 332, "published": 3, "date": "1641448850", "time_retrieved": "2024-07-30T17:11:36.054366", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\n//\tShader developed by Slackermanz (optimised by davidar)\n//\n//\t\thttps://slackermanz.com\n//\n//\t\tDiscord:\tSlackermanz#3405\n//\t\tGithub:\t\thttps://github.com/Slackermanz\n//\t\tTwitter:\thttps://twitter.com/slackermanz\n//\t\tYouTube:\thttps://www.youtube.com/c/slackermanz\n//\t\tShadertoy: \thttps://www.shadertoy.com/user/SlackermanzCA\n//\t\tReddit:\t\thttps://old.reddit.com/user/slackermanz\n//\n//\t\tCommunities:\n//\t\t\tReddit:\t\thttps://old.reddit.com/r/cellular_automata\n//\t\t\tDiscord:\thttps://discord.com/invite/J3phjtD\n//\t\t\tDiscord:\thttps://discord.gg/BCuYCEn\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture( iChannel0, .5*fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\n//\tShader developed by Slackermanz (optimised by davidar)\n//\n//\t\thttps://slackermanz.com\n//\n//\t\tDiscord:\tSlackermanz#3405\n//\t\tGithub:\t\thttps://github.com/Slackermanz\n//\t\tTwitter:\thttps://twitter.com/slackermanz\n//\t\tYouTube:\thttps://www.youtube.com/c/slackermanz\n//\t\tShadertoy: \thttps://www.shadertoy.com/user/SlackermanzCA\n//\t\tReddit:\t\thttps://old.reddit.com/user/slackermanz\n//\n//\t\tCommunities:\n//\t\t\tReddit:\t\thttps://old.reddit.com/r/cellular_automata\n//\t\t\tDiscord:\thttps://discord.com/invite/J3phjtD\n//\t\t\tDiscord:\thttps://discord.gg/BCuYCEn\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n\nconst uint MAX_RADIUS = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), 105.507401); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n\n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(fragCoord.x > .5*iResolution.x || fragCoord.y > .5*iResolution.y) return;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n    float\tres_c\t= texelFetch(txdata, ivec2(gl_FragCoord.xy), 0).x;\t//\tOrigin value references\n    ivec2 pos = ivec2(gl_FragCoord.xy);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst uvec4 bitringdata = uvec4\n\t(\t32766u, \t\t62987u, \t32752u, \t\t2170u \t);\n\n\tconst uint[8] ubv \t\t= uint[8]\n\t(\t39879523u, \t\t526972426u, \t2727874005u, \t1461826227u, \n\t\t1300644632u, \t1298224u, \t\t95419984u, \t\t823214418u\t\t);\n\n\tconst uint[1] ubi \t\t= uint[1]\n\t(\t2390857921u \t\t\t\t\t\t\t\t\t\t\t\t\t);\n\n//\tParameters\n\tconst\tfloat \ts  = mnp *  64.0 *  96.0;\n\tconst\tfloat \tn  = mnp *  64.0 *  16.0;\n\n//\tNH Rings\n    vec4 sums;\n    vec4 tots;\n\tfor(int i = -(int(MAX_RADIUS)/2); i <= (int(MAX_RADIUS)/2); i++) {\n\t\tfor(int j = -(int(MAX_RADIUS)/2); j <= (int(MAX_RADIUS)/2); j++) {\n            int lod = 1;\n            float a = texelFetch(txdata, (pos + ivec2(i,j))>>lod, lod).x;\n            uint d = uint(.5 + 2.*sqrt(float(i*i+j*j)));\n            if(d < MAX_RADIUS) {\n                vec4 mask = vec4((bitringdata >> d) & 1u);\n                sums += mask * a;\n                tots += mask;\n            }\n        }\n    }\n\n\tvec4 nhv_r = sums/tots;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst uint bt = 8u;\n\n\tif( nhv_r[0] >= utp(ubv[0],bt,0u) && nhv_r[0] <= utp(ubv[0],bt,1u) ) { res_c += bsn(ubi[0], 0u)*s; }\n\tif( nhv_r[0] >= utp(ubv[0],bt,2u) && nhv_r[0] <= utp(ubv[0],bt,3u) ) { res_c += bsn(ubi[0], 1u)*s; }\n\tif( nhv_r[0] >= utp(ubv[1],bt,0u) && nhv_r[0] <= utp(ubv[1],bt,1u) ) { res_c += bsn(ubi[0], 2u)*s; }\n\tif( nhv_r[0] >= utp(ubv[1],bt,2u) && nhv_r[0] <= utp(ubv[1],bt,3u) ) { res_c += bsn(ubi[0], 3u)*s; }\n\n\tif( nhv_r[1] >= utp(ubv[2],bt,0u) && nhv_r[1] <= utp(ubv[2],bt,1u) ) { res_c += bsn(ubi[0], 4u)*s; }\n\tif( nhv_r[1] >= utp(ubv[2],bt,2u) && nhv_r[1] <= utp(ubv[2],bt,3u) ) { res_c += bsn(ubi[0], 5u)*s; }\n\tif( nhv_r[1] >= utp(ubv[3],bt,0u) && nhv_r[1] <= utp(ubv[3],bt,1u) ) { res_c += bsn(ubi[0], 6u)*s; }\n\tif( nhv_r[1] >= utp(ubv[3],bt,2u) && nhv_r[1] <= utp(ubv[3],bt,3u) ) { res_c += bsn(ubi[0], 7u)*s; }\n\n\tif( nhv_r[2] >= utp(ubv[4],bt,0u) && nhv_r[2] <= utp(ubv[4],bt,1u) ) { res_c += bsn(ubi[0], 8u)*s; }\n\tif( nhv_r[2] >= utp(ubv[4],bt,2u) && nhv_r[2] <= utp(ubv[4],bt,3u) ) { res_c += bsn(ubi[0], 9u)*s; }\n\tif( nhv_r[2] >= utp(ubv[5],bt,0u) && nhv_r[2] <= utp(ubv[5],bt,1u) ) { res_c += bsn(ubi[0],10u)*s; }\n\tif( nhv_r[2] >= utp(ubv[5],bt,2u) && nhv_r[2] <= utp(ubv[5],bt,3u) ) { res_c += bsn(ubi[0],11u)*s; }\n\n\tif( nhv_r[3] >= utp(ubv[6],bt,0u) && nhv_r[3] <= utp(ubv[6],bt,1u) ) { res_c += bsn(ubi[0],12u)*s; }\n\tif( nhv_r[3] >= utp(ubv[6],bt,2u) && nhv_r[3] <= utp(ubv[6],bt,3u) ) { res_c += bsn(ubi[0],13u)*s; }\n\tif( nhv_r[3] >= utp(ubv[7],bt,0u) && nhv_r[3] <= utp(ubv[7],bt,1u) ) { res_c += bsn(ubi[0],14u)*s; }\n\tif( nhv_r[3] >= utp(ubv[7],bt,2u) && nhv_r[3] <= utp(ubv[7],bt,3u) ) { res_c += bsn(ubi[0],15u)*s; }\n\n    res_c -= n;\n    \n    res_c = clamp(res_c,0.0,1.0);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(.5*iMouse.xy - fragCoord) < 14.0) {\n        res_c = round(mod(float(iFrame),2.0));\n    }\n    if (iFrame == 0) { res_c = reseed(0); }\n    fragColor=vec4(res_c);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[678, 678, 735, 735, 803]], "test": "untested"}
{"id": "NlKXDc", "name": "Basic Newton Fractal", "author": "oneshade", "description": "Simple example of a Newton's fractal for a personal website I am building. It's pretty much finished now but I'm having difficulty uploading it for other people to see, I'm not sure when I'll get it fixed.", "tags": ["fractal", "example", "basic", "iteration", "newton"], "likes": 9, "viewed": 186, "published": 3, "date": "1641448474", "time_retrieved": "2024-07-30T17:11:36.816329", "image_code": "// Complex arithmetic\nvec2 cconj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 cmul(in vec2 z, in vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(in vec2 z, in vec2 w) {\n    return cmul(z, cconj(w)) / dot(w, w);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 a = vec2(1.0, 0.0);\n    vec2 b = mouse;\n    vec2 c = vec2(-0.5, 0.866);\n\n    // Default to \"classic\" Newton fractal before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) b = vec2(-0.5, -0.866);\n\n    // Newton-Raphson method: z_new = z_old - f(z_old) / f'(z_old)\n    vec2 z = uv;\n    for (int i=0; i < 25; i++) {\n        vec2 za = z - a, zb = z - b, zc = z - c;\n        vec2 f = cmul(za, cmul(zb, zc)); // Cubic polynomial with roots a, b, and c\n        vec2 df = cmul(za + zb, zc) + cmul(za, zb);\n        z -= cdiv(f, df);\n    }\n\n    float distA = length(z - a);\n    float distB = length(z - b);\n    float distC = length(z - c);\n\n    // Color based on closest root\n    if (distA < min(distB, distC)) color.r = 1.0;\n    else if (distB < min(distA, distC)) color.g = 1.0;\n    else color.b = 1.0;\n\n    // Plot a point at each root\n    drawSDF(length(uv - a) - 0.05, vec3(0.5, 0.0, 0.0));\n    drawSDF(length(uv - b) - 0.05, vec3(0.0, 0.5, 0.0));\n    drawSDF(length(uv - c) - 0.05, vec3(0.0, 0.0, 0.5));\n\n    fragColor += vec4(color, 1.0);\n}\n\n// 2x2 supersampled AA\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.0, 0.5));\n    render(fragColor, fragCoord + 0.5);\n    fragColor /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 45, 45, 75], [77, 77, 110, 110, 175], [177, 177, 210, 210, 254], [336, 336, 390, 390, 1670], [1672, 1695, 1750, 1750, 1977]], "test": "untested"}
{"id": "NlVSD3", "name": "acos range visualize", "author": "Danielhu", "description": "A simple demonstration for acos", "tags": ["visualization"], "likes": 0, "viewed": 192, "published": 3, "date": "1641439319", "time_retrieved": "2024-07-30T17:11:37.642122", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float value = acos(uv.x * 5.0 - 2.5);\n    float display = step(value, uv.y * 10.0 - 5.0);\n\n    // Output to screen\n    fragColor = vec4(display, display, display, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 327]], "test": "untested"}
{"id": "slyXWc", "name": "Destroy Box | Genuary #5", "author": "byt3_m3chanic", "description": "Genuary 2022 | Day 5 - Destroy a Box\nMy weapon of Choice is noise. https://genuary.art/\nChanges each day based on Date uniform.", "tags": ["genuary5"], "likes": 26, "viewed": 361, "published": 3, "date": "1641433568", "time_retrieved": "2024-07-30T17:11:38.681342", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Genuary 2022 | Day 5 - Destroy a Box\n    Changes each day based on Date uniform.\n    \n    My weapon of Choice is noise. https://genuary.art/\n    in this b&w dither mode recently - its been fun.\n        \n    01/05/22 @byt3_m3chanic \n    \n    Thank you @Fabrice for text functions / @Shane for very compact noise and @iq for \n    shapes & FBM.\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n\n#define MAX_DIST \t85.\n#define MIN_DIST\t.0001\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// webGL2 variant with dynamic size\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbm( in vec3 x, float oct ) {\n    const float scale  = .8;\n    float a = 0.,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for( float i=0.; i<oct; i++ ) {      \n        float n = n3D(f*x*scale);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}\n//---------------------------------------------------------------\n// @iq SDF boxes\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 hp,hit;\nmat2 turn,hurn;\n\nvec2 map (vec3 p) {\n\n\tvec2 res = vec2(100.,-1.);\n    vec3 q = p;\n    q.yz*=turn;\n    q.xz*=hurn;\n    vec3 nv = q;\n    nv+=vec3(0,-7.4-iDate.z,0);\n\n    float b = sdBox(q,vec3(1));\n\n    if(b<res.x) {\n        float d = fbm(nv*.45,7.);\n        d -= .45;\n        b = max(b,-d/1.15);\n        hit=q;\n        res = vec2(b,2.);\n    }\n\n    return res;\n}\n\nvec2 refmap (vec3 p) {\n\tvec2 res = vec2(100.,-1.);\n    p.yz*=turn;\n    p.xz*=hurn;\n  \tfloat d = sdBox(p,vec3(1));\n    if(d<res.x) res = vec2(d,2.);\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float depth = 0.;\n    float m = -1.;\n    for (int i = 0; i<maxsteps;i++) {\n     \tvec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        m = dist.y;\n        // get ref map\n        if(m==2.){\n            float ref = refmap(pos).x;\n            if(ref<dist.x*.999) m = 5.;\n        }\n        if(dist.x<depth*MIN_DIST)break;\n        depth += dist.x*.75; \n        if(depth>50.) break;\n    }\n    return vec2(depth,m);\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = .0001*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nint face =0;\nvec3 material(float m, vec3 p, vec3 n) {\n    vec3 h=vec3(.05);\n    vec3 tn = n;\n    tn.yz*=turn;\n    tn.xz*=hurn;\n    vec3 aN = abs(tn);\n    ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n    face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n    \n    vec3 cuv=vec3(0);\n    // set coords\n    if(face==0) cuv = hp.zxy*vec3(1,1,-1);\n    if(face==1) cuv = hp.xyz*vec3(1,1,-1);\n    \n    if(face==2) cuv = hp.yzx*vec3(1,1,-1);\n    if(face==3) cuv = hp.yzx;\n    if(face==4) cuv = hp.xyz;\n    if(face==5) cuv = hp.yxz*vec3(1,1,-1);\n\n    if(m==2.) {\n        vec2 tv = cuv.xz*2.;\n\n        vec4 O = vec4(0);\n        vec2 U = (tv+vec2(1.25))/2.5;\n        O+=pInt(U,5.);\n        U = (tv+vec2(1.65,1.5))/.75;\n        low C(7);C(5);C(14);C(21);C(1);C(18);C(25);\n        O.x=smoothstep(.7,.85,O.x);\n        h = mix(h,vec3(1),O.x);\n    \n    }\n    \n    if(m==3.) h = vec3(.9);\n    if(m==5.) {\n        float d = fbm(hp*2.,5.);\n        d=floor(fract(d)*15.3)*2.5;\n        d=mod(d,2.);\n        float dt =abs(d)-.001;\n        d=smoothstep(.03,.9,d);\n        \n        dt=smoothstep(.02,.1,dt);\n        h = mix(vec3(.1),vec3(.2,.0,.0),d);\n        h = mix(vec3(.9,.4,.1),h,dt);\n    }\n    return h;    \n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec3 C = vec3(0.);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    float pxg = 156.;\n    uv = floor(uv*(pxg*R.x/R.y))/(pxg*R.x/R.y);pxg*=1.5;\n    \n    \n    float zoom = 4.5;\n    vec3 ro = vec3(uv*zoom,-zoom-5.5);\n    vec3 rd = vec3(0,0,1.);\n\n    mat2 rx,ry;\n    rx = rot(-.68);\n    ry = rot(.78);\n    turn = rot(T*35.*PI/180.);\n    hurn = rot(T*25.*PI/180.);\n    \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    vec2 t = marcher(ro,rd, 256);\n    \n    hp=hit;\n    if(t.x<50.){\n\t\tvec3 p = ro + rd * t.x;\n      \tvec3 nor = normal(p, t.x);\n        vec3 lpos = vec3(-5.,10.,5.5);\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(nor,l),.03,1.);\n\n        vec3 h = material(t.y,p,nor);\n \t\tC = diff * h ; \n  \n    } else {\n        C = vec3(0.200);\n    }\n\n    float CR = C.x;\n    vec3 KR = vec3(1.);\n    if(CR<.500&&(mod(   F.x,4.)==mod(F.y,4.))) KR=KR*.4;\n    if(CR<.250&&(mod(1.-F.y,4.)==mod(F.x,4.))) KR=KR*.35;\n    if(CR<.125&&(mod(   F.x,1.)==mod(F.y,2.))) KR=KR*.3;\n    if(CR<.065&&(mod(1.-F.x,2.)==mod(F.y,2.))) KR=KR*.1;\n    if(CR<.025&&(mod(   F.x,1.)==mod(F.y,1.))) KR=KR*.6;\n    if(CR<.015&&(mod(1.-F.x,1.)==mod(F.y,1.))) KR=KR*.8;\n\n    if(CR>.800&&(mod(   F.x,4.)==mod(F.y,4.))) KR+=.15;\n    if(CR>.900&&(mod(1.-F.x,2.)==mod(F.y,2.))) KR+=.15;\n    \n    KR=clamp(KR,vec3(0),vec3(1));\n    vec3 DR=KR;\n\n    KR=mix(KR,DR*C,.75);\n    KR=mix(vec3(.7),C,1.-KR);\n    \n    float d = fbm(vec3(0,0,T)+vec3(uv*5.,1.),6.)*.22;\n    float sq = sdBox(uv,vec2(.55,.55))+d;\n    float bk = abs(sq)-.015;\n    float tk = abs(sq)-.005;\n    sq=smoothstep(.01,.011,sq);\n    bk=smoothstep(.01,.011,bk);\n    tk=smoothstep(.01,.011,tk);\n    float mask=mix(0.,1.,sq);\n    KR=mix(KR,vec3(.1),mask);\n    KR=mix(vec3(.2),KR,bk); \n    KR=mix(vec3(.6),KR,tk);    \n    \n        \n    float hs = hash21(uv);\n    if(fract(hs*5.)>.65) KR=mix(KR,clamp(KR-.02,vec3(0),vec3(1)),mask);\n    if(hs>.75) KR=mix(KR,clamp(KR+.015,vec3(0),vec3(1)),1.);\n\n\n    O = vec4(pow(KR, vec3(0.4545)),1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyXWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[645, 645, 664, 664, 709], [710, 710, 731, 731, 793], [1025, 1025, 1051, 1051, 1221], [1222, 1258, 1286, 1286, 1406], [1408, 1572, 1590, 1590, 1900], [1901, 1988, 2023, 2023, 2257], [2258, 2341, 2371, 2371, 2458], [2459, 2459, 2495, 2495, 2575], [2607, 2607, 2626, 2626, 2950], [2952, 2952, 2974, 2974, 3117], [3119, 3119, 3165, 3165, 3592], [3594, 3669, 3699, 3699, 3935], [5154, 5154, 5195, 5195, 7188]], "test": "untested"}
{"id": "7lGSW3", "name": "SerenityOS Ladyball", "author": "frhun", "description": "A 3D rendition of the SerenityOS \"Ladyball\"", "tags": ["serenityos"], "likes": 3, "viewed": 387, "published": 3, "date": "1641427472", "time_retrieved": "2024-07-30T17:11:39.845231", "image_code": "const float INF  = 1./0., //If divide by zero error occurs, replace this with a very big number\n            M_PI = 3.14159;\n\n//--- Settings ---\n// Many of these settings cause really hacky control flow changes.\n// As long as they are only used as constants, that are known at\n// compile time, they should have no impact on performance.\n// But should they be unknown at compile time, they might have\n// severe performance impacts\n\nconst bool MOUSECONTROL = true\n\n         , SHOW_CYCLES              = false\n         , SHOW_COLLISION_DISTANCE  = false\n         , BAILOUT_SPECIAL_COLOR    = false\n         , SHOW_NORMAL              = false\n         , THREE_D                  = false\n         , FIELD_CROSS_SECTION      = false\n         , CUTVIEW                  = false //TODO: fix cutview\n         // EDGE DETECTION SETTINGS\n         , DRAW_NEAR_MISS_EDGES     = false\n         , DRAW_INSIDE_EDGES        = false\n         , DRAW_BOOL_EDGES          = false\n         \n         , DISTANCE_GROWING_THRESH  = false\n         , STEPPING_SLOWDOWN        = false\n         \n         , NEAR_MISS_ANTI_ALIASING  = true\n         , DO_LIGHTING              = true\n         ,   FAKE_SOFT_SHADOWS      = false //  \"realistic\" lighting\n         ,   LIGHTING_DISTANCE_FADE = true  //  sub settings\n         ,   SHADOW_NEAR_MISS_AA    = false // \n         ,   SPECULAR_LIGHT_SOURCES = true  // \n         \n         , DO_DITHERING             = true;\n\nconst int MAX_STEPS  = 500;\n\nconst float ambient_light    = 0.13,\n            base_dist_thresh = 0.001,\n            shadowDistThresh = 0.01,\n            numGradStep      = 0.0001,\n            bailout_cam_dist = 1000.,\n            gamma            = 2.2,    //setting gamma to easy to calculate values might result in a very slight speedup\n            EDGE_WIDTH       = 1.0;\n\nconst vec3 EDGE_COLOR = vec3(1., 0., 1.);\n\n//---\n\n//--- Lights ---\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float size;\n};\n\nLight lightsList[] = Light[](\n    Light(vec3(0.,0.,-5.),vec3(1.000,1.000,1.000)*5.,0.5),\n    Light(vec3(0.,5.,0.),vec3(1.000,1.000,1.000),1.)\n    );\nint lightsListLength = 2;\n\n//---\n\n//--- Materials ---\n\nstruct Material {\n    vec3 color_diffuse;\n    vec3 color_specular;\n    vec3 color_subsurface;\n    float roughness;\n    float stripe_dens;\n    float stripe_rot;\n};\n\nMaterial materials[] = Material[](\n        Material(vec3(1.), vec3(1.), vec3(0.), .8, 1.0, M_PI / 4.), //mutableMaterial\n        Material(vec3(0.333, 0.666, 1.), vec3(0.333, 0.666, 1.), vec3(0.4), .8, 1.0, M_PI / 4.), //standardMaterial\n        Material(vec3(.64, 0.11, 0.17),  vec3(.64, 0.11, 0.17),  vec3(0.4), .8, 3.0, M_PI / 4.), //redMaterial\n        Material(vec3(.0, 0.9, 0.1),     vec3(.0, 0.9, 0.1),     vec3(0.4), .8, 2.0, M_PI / 4.), //greenMaterial\n        Material(vec3(.0, 0.17, 0.8),    vec3(.0, 0.17, 0.8),    vec3(0.4), .8, 1.0, M_PI * 3. / 4.), //blueMaterial\n        Material(vec3(0.945,0.682,0.000),    vec3(.0, 0.17, 0.8),    vec3(0.4), .8, 1.0, M_PI / 4.), //yellowMaterial\n        Material(vec3(0.020,0.020,0.020), vec3(0.239,0.220,0.275), vec3(0.4), 1., 1.0, M_PI / 4.), //blackCoreMaterial\n        Material(vec3(0.976,0.008,0.008), vec3(0.878,0.106,0.141), vec3(0.4), 0.2, 1.0, M_PI / 4.), //redShellMaterial\n        Material(vec3(0.000,0.000,0.000), vec3(1.000,1.000,1.000), vec3(0.4), 0.0, 1.0, M_PI / 4.) //blackShellSpotMaterial\n    );\n\n// Material indices\nint mutableMaterial  = 0;\nint standardMaterial = 1;\nint redMaterial      = 2;\nint greenMaterial    = 3;\nint blueMaterial     = 4;\nint yellowMaterial   = 5;\nint blackCoreMaterial = 6;\nint redShellMaterial = 7;\nint blackShellSpotMaterial = 8;\n\n//---\n\n// Vector roation around origin\nvoid Rotate( inout vec3 vector, vec2 angle ){\n    vector.yz = cos(angle.y) * vector.yz\n                + sin(angle.y) * vec2(-1,1) * vector.zy;\n    vector.xz = cos(angle.x) * vector.xz\n                + sin(angle.x) * vec2(-1,1) * vector.zx;\n}\n\nvec3 rotate( in vec3 vector, vec2 angle){\n    vec3 result = vector;\n    Rotate(result, angle);\n    return result;\n}\n\n//--- signed distance field - functions ---\nfloat Diff(float A, float B, inout float combined_min){\n    combined_min = min(combined_min, max(abs(A), abs(B)));\n    return max(A, -B);\n}\n\n// Coordinate transformation functions\nvec3 toHorizontal( in vec3 p ){\n    vec3 result;\n    \n    result.x = atan(p.z, p.x); // Azimuth\n    \n    result.y = atan(p.y / length(p.xz)); // Attitude\n    \n    result.z = length(p); // Distance\n    \n    return result;\n}\n\nvec3 fromHorizontal( in vec3 pol ){\n    vec3 result;\n    \n    result.x = cos(pol.x) * cos(pol.y);\n    \n    result.y = sin(pol.y);\n    \n    result.z = sin(pol.x) * cos(pol.y);\n    \n    result *= pol.z;\n    \n    return result;\n}\n\nvec3 mirrorY( in vec3 p ){\n    vec3 result = p;\n    \n    result.y = abs(p.y);\n    \n    return result;\n}\n\n// -- Geometries --\nfloat Sphere( vec3 centre, float radius, vec3 point ){\n    return length(centre-point)-radius;\n}\n\nfloat Box(vec3 pos, vec3 size, vec3 point) {\n    vec3 d = abs(point - pos) - (size / 2.0);\n    \n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat Limit(vec3 pos, vec3 dir, vec3 point ){\n    return dot(point - pos, normalize(dir));\n}\n\n// the following functions are taken 1:1 from Inigo Quilez\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.yz) - w, p.x );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// --\n//---\n\n//Target Detection, and material determination\nvoid det(inout float f, inout int m, in float dist, in int material){\n    if(dist < f){\n        f = dist;\n        m = material;\n    }\n}\n\n// The Background Function - rays that don't hit objects, will be colored according to this function\nvec3 background( in vec3 ray){\n    // Background color constants, change these to change the background appearance\n    const vec3 ground      = pow( vec3(0.251,0.180,0.133), vec3(gamma)),\n               ground_haze = pow( vec3(0.522,0.341,0.200), vec3(gamma)),\n               ground_grid = pow( vec3(0.545,0.435,0.420), vec3(gamma)),\n               sky         = pow( vec3(0.251,0.184,0.129), vec3(gamma)),\n               sky_haze    = pow( vec3(0.082,0.055,0.031), vec3(gamma)),\n               sky_grid    = pow( vec3(0., 0., 0.), vec3(gamma));\n               \n    vec2 effective_ground_plane_coord = mod(ray.xz * (-3./ray.y), vec2(1.));\n    float dist_to_grid = min(abs(effective_ground_plane_coord.y - .5),\n                             abs(effective_ground_plane_coord.x - .5));\n    \n    vec3 col = mix(ground_haze,\n                   mix(ground_grid,\n                       ground,\n                       clamp(dist_to_grid * 30.,\n                             0.,\n                             1.)\n                       ),\n                   clamp(pow(-ray.y * 4., 1.3), 0., 1.)\n                   );\n    col = mix(mix(sky_haze,\n                  sky,\n                  clamp(ray.y, 0., 1.)\n                  ),\n              col,\n              clamp(-ray.y * 70., 0., 1.)\n              );\n                   \n    return col;\n}\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( in vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n//accumulated sdf function\nfloat Scene( in vec3 pos, inout int material, out float combined_min){\n    combined_min = INF;\n    #define D(dist, mat) det(f, material, dist, mat)\n    float f = INF;\n    \n    float shell_d = 0.95;\n    \n    vec3 ladyball_pos = pos;\n    //ladyball_pos += vec3(0., 0., 1.); //Offset for VR\n    Rotate(ladyball_pos, vec2(0., iTime*1.9));\n    \n    \n    D(\n        min(\n            Diff(\n                sdPie(opRevolution(ladyball_pos, 0.).yx, vec2(sin(M_PI/4.), cos(M_PI/4.)), shell_d),\n                ladyball_pos.z,\n                combined_min\n            ),\n            sdSolidAngle(\n                mirrorY(ladyball_pos),\n                vec2(sin(M_PI/4.), cos(M_PI/4.)),\n                shell_d\n            )\n        )-0.1,\n        redShellMaterial\n    );\n    \n    D( Sphere(vec3(0), 1., ladyball_pos), blackCoreMaterial);\n    \n    D( sdEllipsoid(ladyball_pos - vec3(0., 1. ,0.), vec3(0.4, 0.07, 0.4)), blackShellSpotMaterial);\n    \n    D( sdEllipsoid(rotate((ladyball_pos), vec2(0., -M_PI*0.3)) - vec3(0., 1. ,0.) , vec3(0.3, 0.07, 0.3)), blackShellSpotMaterial);\n    \n    D( sdEllipsoid(rotate((ladyball_pos), vec2(0., -M_PI*0.52)) - vec3(0., 1. ,0.) , vec3(0.2, 0.07, 0.2)), blackShellSpotMaterial);\n    \n    /*\n    // Axis indication spheres\n    pos += vec3(2, 2, 2);\n    D( Sphere(vec3(0, 0, 0), 0.1, pos), yellowMaterial);\n    D( Sphere(vec3(1, 0, 0), 0.1, pos), redMaterial);\n    D( Sphere(vec3(0, 1, 0), 0.1, pos), greenMaterial);\n    D( Sphere(vec3(0, 0, 1), 0.1, pos), blueMaterial);\n    */\n    return f;\n    #undef D\n}\n\n//calculating the surface normal/normalized field gradient - numerically\nvec3 get_normal(in vec3 pos){\n    vec3 normal;\n    int mat; //hacky - only needed to match the function signature\n    float combined_min; //hacky +1 - but should be optimized away anyways\n    normal.x = Scene(pos + vec3(numGradStep, 0, 0), mat, combined_min);\n    normal.y = Scene(pos + vec3(0, numGradStep, 0), mat, combined_min);\n    normal.z = Scene(pos + vec3(0, 0, numGradStep), mat, combined_min);\n    normal -= vec3(Scene(pos, mat, combined_min));\n    normal = normalize( normal ); //this makes distored (e.g. smooth) SDFs possible\n    return normal;\n}\n\nfloat light_reachable(vec3 pos, Light light, float dist_per_pix){\n    float intensity = 1.;\n    \n    vec3  light_diff_vec  = light.pos - pos;\n    float light_diff_dist = length(light_diff_vec),\n          trav_length     = 0.,\n          min_h           = INF;\n    vec3  ray             = normalize(light_diff_vec);\n    int mat; //currently unused, could be used for transparent objects\n    //path marching to light\n    for(int i = 0; i < 500; i++){\n        float combined_min; //only needed to match the function signature of Scene\n        float h = Scene( pos, mat , combined_min);\n        \n        if(h > min_h){\n            if(FAKE_SOFT_SHADOWS){\n                float shadow_width = light.size * ( trav_length / (light_diff_dist - trav_length));\n\n                intensity *= clamp((min_h * (light_diff_dist / (light_diff_dist - trav_length))) / shadow_width,\n                                   0., 1.);\n                min_h = INF;\n            }else if(SHADOW_NEAR_MISS_AA){\n                float local_dist_per_pix = dist_per_pix * ((light_diff_dist - trav_length) / light_diff_dist);\n                float miss_factor = (min_h - shadowDistThresh) / local_dist_per_pix;\n                intensity *= min(miss_factor, 1.);\n            }\n            \n            min_h = INF;\n        }\n        \n        //Fake Smooth Shadows\n        if(FAKE_SOFT_SHADOWS || NEAR_MISS_ANTI_ALIASING){\n            min_h = min(min_h, h);\n        }\n        \n        //Overshoot Detection\n        trav_length += h;\n        if( trav_length >= light_diff_dist)\n            break;\n        \n        //Collision Detection\n        if( h < shadowDistThresh){\n            intensity = 0.;\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    return intensity;\n}\n\nvoid mainMarch( out vec4 fragColor,\n                in vec3 pos,\n                in vec3 ray,\n                in float unit_dist_per_pix,\n                in float perspectiveness,\n                in vec3 image_plane_vertical,\n                in vec3 image_plane_horizontal,\n                in vec3 image_plane_normal\n                ){\n    \n    vec3 start_pos = pos;\n    \n    //constant background color/fragment color initialization goes here\n\tfragColor.rgb = vec3(1.);\n    \n    //-- edge detection values -- //TODO: check what values are still used\n    bool collided = false,\n         pixel_dist_near_miss = false;\n    vec3 pixel_dist_near_miss_color;\n    float near_miss_pixel_ratio = 1.,\n          min_h = INF,\n          h = INF, //elevation from nearest surface (Distance)\n          trav_dist = 0.;\n    int material_ind = standardMaterial;\n    //--\n    //main marching loop\n    int i; //declared outside to be used for BAILOUT_SPECIAL_COLOR\n    //        number of steps before bailout\n    for (i = MAX_STEPS; i > 0; i--){\n        float combined_min; //Variable to store the combined minimum of bool operations\n        h = Scene(pos, material_ind, combined_min);\n        \n        float dist_thresh = base_dist_thresh;\n        if( DISTANCE_GROWING_THRESH )\n            dist_thresh *= trav_dist;\n        \n        bool pixel_dist_near_miss_on_this_pass = false;\n        if(h > min_h){ //Code to run on detection of a near miss - TODO: antialiasing\n            float local_dist_per_pix = unit_dist_per_pix *\n                                       (\n                                           (1. - perspectiveness) +\n                                           perspectiveness * distance(start_pos, pos)\n                                       );\n            if((min_h - dist_thresh) < local_dist_per_pix * float(EDGE_WIDTH) && DRAW_NEAR_MISS_EDGES){\n                fragColor.rgb = EDGE_COLOR;\n                return;\n            }\n            if((min_h - dist_thresh) < local_dist_per_pix && !pixel_dist_near_miss && NEAR_MISS_ANTI_ALIASING){\n                near_miss_pixel_ratio = (min_h - dist_thresh) / local_dist_per_pix;\n                pixel_dist_near_miss_on_this_pass = true;\n                pixel_dist_near_miss = true;\n            }\n            //resetting min_h\n            min_h = INF;\n        }\n        min_h = min(min_h, h);\n        \n        //Declarations for Cutview, should be optimized out if not used\n        vec3 cut_norm, cut_pos;\n        float cut_dist, pre_cut_h;\n        if(CUTVIEW) {\n            cut_norm = normalize(vec3(0., 0., -1.));\n            cut_pos  = vec3(0., 0., 0.);\n            cut_pos += 1. * sin(iTime/6.) * cut_norm;\n            cut_dist = Limit(cut_pos, cut_norm, pos);\n            pre_cut_h = h;\n            float dummy_combined_min;\n            h = Diff(h, cut_dist, dummy_combined_min);\n        }\n        \n        //Surface hit\n        if (    h < dist_thresh \n             || (pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING) \n           ){\n            // -- debug bailouts --\n            if(SHOW_COLLISION_DISTANCE){ //debug show distance from camera to collision point\n                fragColor.rgb = vec3(h / dist_thresh, 0, 0);\n                break;\n            }\n               \n            if(SHOW_CYCLES){ //debug show cycle count at collision point\n                fragColor.rgb = vec3(1. - 1./(1. + 0.01*(float(MAX_STEPS - i) + h / dist_thresh) ));\n                return;\n            }\n            \n            vec3 normal = get_normal(\n                                      (   pixel_dist_near_miss_on_this_pass //if this is a near miss anti aliasing pass\n                                       && NEAR_MISS_ANTI_ALIASING           //walk back a bit before determining the normal\n                                       ? pos - (ray + image_plane_vertical) * 3.5 * h               //to actually sample the correct surface\n                                       : pos\n                                      )\n                                    );\n            if(SHOW_NORMAL){ //debug show normal at collision point as color\n                fragColor.rgb = 0.5 +  0.5 * normal;\n                break;\n            }\n            // --\n            \n            //TODO: eliminate this duplicate\n            float local_dist_per_pix = unit_dist_per_pix *\n                                   (\n                                       (1. - perspectiveness) +\n                                       perspectiveness * distance(start_pos, pos)\n                                   );\n            \n            //inside edge detection - TODO: antialiasing\n            if( DRAW_INSIDE_EDGES && !(pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING) ){\n                int dummy_mat;\n                \n                float surface_projected_local_dist_per_pix =\n                        local_dist_per_pix;\n                                       \n                float inside_edge_detection_dist = EDGE_WIDTH * surface_projected_local_dist_per_pix + dist_thresh;\n                \n                float dummy_combined_min;\n                \n                if(Scene(pos + normal * (dist_thresh + inside_edge_detection_dist), dummy_mat, dummy_combined_min)\n                   < inside_edge_detection_dist){\n                    fragColor.rgb = EDGE_COLOR;\n                    return;\n                }\n            }\n            \n            //edge detections for outside edges that are the result of a bool operation\n            if(    DRAW_BOOL_EDGES\n                && combined_min - dist_thresh < EDGE_WIDTH * local_dist_per_pix\n              ){\n                fragColor.rgb = EDGE_COLOR;\n                return;\n            }\n            \n            // copying over the actual material that is to be evlauated\n            Material material = materials[material_ind];\n            \n            if(CUTVIEW && cut_dist < dist_thresh){\n                fragColor.rgb = material.color_diffuse;\n                if(pre_cut_h > -0.01 * ((1. - abs(dot(normal, cut_norm))) / (-pre_cut_h)) ){\n                    fragColor.rgb = vec3(0.);\n                }else{\n                    //vec2 stripe_normal = vec2(0.707 * cos(material.stripe_rot),\n                    //                          0.707 * sin(material.stripe_rot));\n                    vec3 stripe_normal =   cos(material.stripe_rot) * image_plane_horizontal\n                                         + sin(material.stripe_rot) * image_plane_vertical;\n                    //float stripe_d = dot(stripe_normal, uv.xy);\n                    float stripe_d = dot(pos - cut_pos, stripe_normal);\n                    if(mod(stripe_d, 0.1 / material.stripe_dens) < 0.01){\n                        fragColor.rgb = vec3(0.);\n                    }\n                }\n            } else if(DO_LIGHTING) {\n                //--- lighting calculations ---\n                bool do_specular = material.roughness < 1. && SPECULAR_LIGHT_SOURCES;\n                vec3 diffuse  = vec3(0.0),\n                     specular = vec3(0.0);\n                for(int lightsInd = 0; lightsInd < lightsListLength; lightsInd++){\n                    Light lightSrc = lightsList[lightsInd];\n                    //detect if the light is reachable from the current position\n                    //                                              done so it doesn't collide with originator\n                    float light_intensity = light_reachable( pos + normal * shadowDistThresh * 2., lightSrc, local_dist_per_pix);\n                    \n                    vec3 to_light = lightSrc.pos - pos;\n                    vec3 to_light_normalized = normalize(to_light);\n                    float light_strength = light_intensity * (LIGHTING_DISTANCE_FADE ? \n                                            10.0 / pow(length(to_light), 2.0)\n                                            : 1.);\n                    //Diffuse Calculation\n                    diffuse += lightSrc.color * light_strength\n                               * max(0., dot(normal, to_light_normalized));\n\n                    //Specular Calculation\n                    if( do_specular ){\n                        vec3 a = normal * dot(normal, -ray);\n                        vec3 reflected_ray = normalize(a + a -(-ray));\n                        specular += lightSrc.color * light_strength\n                                    * clamp(1. - 100./(1. + lightSrc.size)\n                                            * (1. - dot(to_light_normalized, reflected_ray)),\n                                            0., 1.);\n                    }\n                }\n                //---\n\n                //determining amount of sideglow (added light at low angle of incident)\n                float sideglow = ambient_light * clamp(1. - dot(normal, -ray), 0., 1.);\n                sideglow *= 1.8;\n\n                //--- final color determination ---\n                fragColor.rgb = material.color_diffuse*\n                                mix(max(\n                                        vec3(ambient_light),\n                                        sideglow\n                                       ), vec3(1.), diffuse);\n                if( do_specular ){\n                    fragColor.rgb += specular * material.color_specular * (1. - material.roughness);\n                }\n                \n                //alternative color determination -- outdated without specular\n                //fragColor.rgb = vec3((0.2 + diffuse) * material.color_diffuse * (1.0 - sideglow)\n                //                     + sideglow * material.color_sideglow);\n                //---\n            } else { // Branch to take if lighting based shading is disabled\n                mat3 view_relative = mat3(image_plane_horizontal, image_plane_vertical, image_plane_normal);\n                fragColor.rgb = material.color_diffuse\n                                * (ambient_light + (1. - ambient_light) *\n                                   max(\n                                       //Light always coming from top right, slightly towards the camera\n                                       clamp(dot(normal, view_relative * vec3(0.4, 1., -0.3)), 0., 1.),\n                                       //Low Angle of Incident  Sideglow\n                                       ambient_light * 2. * clamp(1. - dot(normal, -ray), 0., 1.)\n                                       ));\n            }\n            \n            if(pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING){\n                pixel_dist_near_miss_color = fragColor.rgb;\n            }else{\n                collided = true;\n                break;\n            }\n        }\n        \n        // setting the new position\n        if( STEPPING_SLOWDOWN )\n            h *= .8;\n        pos += ray * h;\n        trav_dist += h;\n        \n        // Distance from camera bailout\n        if(distance(pos, start_pos) > bailout_cam_dist){\n            if(BAILOUT_SPECIAL_COLOR)\n                fragColor.rgb = vec3(0., 0., 1.);\n            if(SHOW_CYCLES)\n                fragColor.rgb = (float(MAX_STEPS - i) / 100.) * vec3(1.0,0.4,0.2);\n            break;\n        }\n    }\n    \n    if(!collided && !SHOW_CYCLES && !SHOW_NORMAL && !BAILOUT_SPECIAL_COLOR && !SHOW_COLLISION_DISTANCE)\n        fragColor.rgba = vec4(background(ray), 0.);\n    \n    if(BAILOUT_SPECIAL_COLOR && i <= 0)\n        fragColor.rgb = vec3(1., 0., 0.);\n    \n    //mixing color of near miss, and actual destination color -- for Anti Aliasing\n    if(NEAR_MISS_ANTI_ALIASING)\n        fragColor.rgb = mix(pixel_dist_near_miss_color, fragColor.rgb, near_miss_pixel_ratio);\n    \n    //Gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/gamma) );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.y) * 2.0 - vec2((iResolution.x / iResolution.y), 1.0);\n    //override 3D - draw mouse controlled cross section of field values\n    if(FIELD_CROSS_SECTION){\n        float z_plane = 0.0;\n        if(iMouse.z > 0.0){\n            z_plane = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * 4.0;\n        }\n        int dummyMat;\n        float dummy_combined_min;\n        float sdf = Scene(vec3(uv * 4.0, z_plane), dummyMat, dummy_combined_min);\n        fragColor.rgb = (sdf >= 0.0 ? vec3(sdf) : vec3(-sdf, 0.0, 0.0));\n        return;\n    }\n    //actual normal 3d rendering\n    \n    //--- Ray and Camera calculation ---\n    //ray starting position offset for smooth perspective to othographic transition\n    float view_size = 1.2,\n          perspectiveness = sin(iTime/3.0)/ 2.0 + 0.5,\n          image_plane_distance = 1.;\n    perspectiveness = 1.0;\n    \n    vec2 camera_origin_shift = vec2(0.) * image_plane_distance;\n    //marching starts on a projection plane scaled by orthagonal view width\n    //and (1-perspectiveness) - which means that the rays of all fragments originate\n    //from the same point with a perspectiveness of 1\n    vec3 start_offset = vec3( (fragCoord - iResolution.xy * 0.5) * view_size * (1.0-perspectiveness) / iResolution.x, 0.0);\n    //ray to march on                                                     Projection Plane Distance (Modifying this will modyfy the FOV, but also bug out the AA)\n    //this is the direction of the start_offset to the same plane, set off by 1 on z and not scaled by 1-perspectiveness\n    vec3 ray =\n        vec3(\n             (fragCoord - iResolution.xy * 0.5)  * view_size / iResolution.x,\n              image_plane_distance\n            )\n        - (start_offset + vec3(camera_origin_shift, 0.));\n    //Approximated arc Length per pixel at unit sphere from starting point\n    float unit_dist_per_pix = view_size / (iResolution.x * length(ray));\n    //normalization of ray to length 1\n    ray = normalize(ray);\n    //starting camera position\n    vec3 pos = vec3( 0., 0.,-5.) + start_offset;\n    \n    //camera offset for horizontal scanline 3D\n    if(THREE_D && mod( fragCoord.y, 2.0 ) < 1.0)\n    \tpos += vec3(0.2, 0, 0);\n        \n    //helper vectors for shading\n    vec3 image_plane_vertical   = vec3(0., 1., 0.),\n         image_plane_horizontal = vec3(1., 0., 0.),\n         image_plane_normal     = vec3(0., 0., 1.);\n\n    //rotating the camera around the origin\n    vec2 angle = vec2(iTime * 0.2, 0.1);\n    //angle = vec2((M_PI / 2.) * 1., 0.);\n\n    if (MOUSECONTROL && iMouse.z >= 0.0  && iMouse.xyz != vec3(0)) angle = (iMouse.xy / iResolution.xy - 0.5) * 6.6;\n    \n    Rotate( pos, angle );\n    Rotate( ray, angle );\n    Rotate( image_plane_vertical,   angle );\n    Rotate( image_plane_horizontal, angle );\n    Rotate( image_plane_normal,     angle );\n    \n    //---\n    \n    mainMarch( fragColor, pos, ray, unit_dist_per_pix, perspectiveness, image_plane_vertical, image_plane_horizontal, image_plane_normal );\n    \n    //Dithering\n    if( DO_DITHERING )\n        fragColor.rgb += vec3(InterleavedGradientNoise(fragCoord.xy)/255.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    mainMarch( fragColor,\n               3. * fragRayOri,\n               normalize(fragRayDir),\n               0., // Dist per pix\n               1., // Perspectiveness (assuming hole camera model\n               vec3(0., 1., 0.),\n               vec3(1., 0., 0.),\n               vec3(0., 0., 1.)\n             );\n    //Dithering\n    if( DO_DITHERING )\n        fragColor.rgb += vec3(InterleavedGradientNoise(fragCoord.xy)/255.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGSW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3657, 3689, 3734, 3734, 3932], [3934, 3934, 3975, 3975, 4049], [4051, 4095, 4150, 4150, 4234], [4236, 4275, 4306, 4306, 4497], [4499, 4499, 4534, 4534, 4725], [4727, 4727, 4753, 4753, 4830], [4832, 4852, 4906, 4906, 4948], [4950, 4950, 4994, 4994, 5213], [5215, 5215, 5260, 5260, 5307], [5309, 5368, 5414, 5449, 5609], [5611, 5611, 5660, 5660, 5828], [5830, 5830, 5871, 5871, 5915], [5917, 5917, 5976, 5976, 6065], [6080, 6127, 6196, 6196, 6262], [6264, 6365, 6395, 6479, 7696], [7698, 7908, 7954, 7954, 8083], [9647, 9720, 9749, 9749, 10279], [10281, 10281, 10346, 10346, 12037], [23710, 23710, 23767, 23767, 26890], [26892, 26892, 26986, 26986, 27414]], "test": "untested"}
{"id": "7lyXW3", "name": "FBM [ UI ]", "author": "Yusef28", "description": "The way the transitions happen is definitly inspired by the Synesthesia app which I tried a few months ago. Synesthesia is super powerful for exploring shader variations that exist in your code. Here I have it set up so you can draw the variation in.", "tags": ["2d", "noise", "fbm", "color", "ui", "util"], "likes": 11, "viewed": 323, "published": 3, "date": "1641422717", "time_retrieved": "2024-07-30T17:11:40.779732", "image_code": "float circle(vec2 p, float r, float sf)\n{    \n    return 1.0-smoothstep(r-EPS*sf, r+EPS*sf, length(p));\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    float c = length(p);\n    return abs(sin(c*50./r))*(1.0-smoothstep(r-EPS, r+EPS,c));\n}\nvec3 drawFancyCircle(vec3 col, \n                     vec2 uv,\n                     vec2 pos, \n                     float r){\n                     \n    vec2 light = vec2(1.);\n    float scale = 0.6/r;\n    vec3 tx1 = vec3(texture(iChannel1, \n    (pos)/r/2.)).rgb+0.;\n    \n    //super hacky texture call to lighting that allows\n    //me to shift the texture by the circle\n    //position, scale it by the texture radius,\n    //adjust aspect ratio, and ajust the center again\n    vec3 tx0 = vec3(texture(iChannel0, \n    ((pos)*scale*rot(iTime))*vec2(iResolution.y/iResolution.x,1.)+0.5\n    )).rgb;\n    \n    vec2 lightDir = normalize(light - max(pos,EPS));\n    //shadow circle\n    col = mix(col, vec3(0.0), circle(pos-lightDir*0.1*r,r,20.));\n    //rim lighting circle\n    col = mix(col, gold+dot(pos,-lightDir), circle(pos, r,1.));\n    //gold outer circle\n   // col = mix(col, gold-tx1.x+0.2, circle(pos, r*0.97, 1.));\n    //sin gradient on outer circle\n    col-=SIN(uv-pos,r)/4.;\n    //black inner circle\n    col = mix(col, vec3(0.1), circle(pos, r*0.7, 5.));\n    //grey center circle\n    col = mix(col, tx0, circle(uv-pos,r*0.6, 1.)); \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float asp = iResolution.y/iResolution.x;\n    // Time varying pixel color\n    vec3 col = load0(fragCoord).rgb;\n\n    // Output to screen\n    vec2 st = uv*UV_SCALE;\n    vec2 flST = floor(st);\n    vec2 frST = fract(st)-0.5;\n    //col += flST.y/8.;\n    float border = smoothstep(0.47,0.5, abs(frST.y));\n    col += border;\n    vec2 dotPos = vec2(uv.x*UV_SCALE,frST.y) -\n    vec2(load1(vec2(flST.y+0.5,1.5)).x,0.)*UV_SCALE/asp;\n    \n    float c = smoothstep(0.22,0.2,length(dotPos));\n    col += c;\n    col = drawFancyCircle(col, \n                    uv/100., \n                    dotPos,\n                    0.4);\n        \n    if(floor((iMouse.y/iResolution.y)*UV_SCALE) == flST.y){\n        col += vec3(0.5,0.,0.);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//return a cleared vector for the game state \nvec4 clear(){\n    return vec4(0.,0.,0.,1.);\n}\n\n//return all components of a new animation\nvec4 getNewAnimation(){\n                //time,frame,holding,clear\n    return vec4(iTime,iFrame,0.,0.);\n}\n\n//return all components of the current animation\nvec4 getGameState(){\n    return load0(GAME_STATE_ADDRESS);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if(iFrame < 1){\n    //initialize\n    \n        if(fragCoord == GAME_STATE_ADDRESS){\n            fragColor = getNewAnimation();\n        }\n        else if(fragCoord.x < NUMBER_OF_VARIABLES){\n            //set position\n            if(fragCoord.y == 0.5){\n                fragColor = vec4(vec3(rnd(fragCoord.x)),1.);\n            }\n            if(fragCoord.y == 1.5){\n                fragColor = vec4(vec3(rnd(fragCoord.x)),1.);\n            }\n        }\n    }\n    \n    else{\n    //update\n    \n        vec4 gameState = getGameState();\n        float startTime = gameState.x;\n        float frameNum = gameState.y;\n        float cleared = gameState.w;\n        //if we are at the game State Adress\n        if(fragCoord == GAME_STATE_ADDRESS){ \n\n                if(cleared == 1.){\n                    fragColor = getNewAnimation();\n                }\n                else if((iTime - startTime) > DURATION){\n                    fragColor.w = 1.;//clear();\n                }\n                else{\n                    fragColor = gameState;\n                }\n            }\n\n        else if(fragCoord.x < NUMBER_OF_VARIABLES){\n            \n            if(cleared == 1.){\n                if(fragCoord.y == 0.5){\n                        fragColor = mix(load0(fragCoord.xy),\n                                     vec4(vec3(load0(fragCoord.xy)),1.),0.02);\n                        }\n                if(fragCoord.y == 1.5){\n                        fragColor = vec4(vec3(load0(fragCoord.xy)),1.);\n                    }\n                }\n                else{\n                   \n                    vec2 uv = fragCoord/iResolution.y;\n                    vec2 st = uv*UV_SCALE;\n                    vec2 flST = floor(st);\n                    vec2 frST = fract(st)-0.5;\n                    vec2 m = iMouse.xy/iResolution.xy;\n                    vec2 flM = floor(m*UV_SCALE);\n                    vec2 frM = fract(m);\n                    \n                    if(fragCoord.y == 1.5){\n                        if(iMouse.z > 0.5 && flM.y+0.5 == fragCoord.x){\n                                fragColor = vec4(vec3(frM.x),1.);\n                            \n                        }     \n                        else{\n                            fragColor = load0(fragCoord.xy);\n                        }\n                    }\n                    else if(fragCoord.y == 0.5){\n                        fragColor = mix(load0(fragCoord.xy),\n                                    vec4(vec3(load0((fragCoord.xy+vec2(0.,1.) ))),1.),0.02);;\n                    }\n                }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define load0(ADDRESS) texture(iChannel0,ADDRESS/iResolution.xy)\n#define load1(ADDRESS) texture(iChannel1,ADDRESS/iResolution.xy)\n#define PI acos(-1.)\n#define DURATION 2.\n#define EPS 0.01\n#define NUMBER_OF_VARIABLES 12.\n#define GAME_STATE_ADDRESS vec2(NUMBER_OF_VARIABLES+5.5,0.5)\n\n#define _f1 load0(vec2(0.5,0.5)).x\n#define _f2 load0(vec2(1.5,0.5)).x\n#define _f3 load0(vec2(2.5,0.5)).x\n#define _f4 load0(vec2(3.5,0.5)).x\n#define _f5 load0(vec2(4.5,0.5)).x\n#define _f6 load0(vec2(5.5,0.5)).x\n#define _f7 load0(vec2(6.5,0.5)).x\n#define _f8 load0(vec2(7.5,0.5)).x\n#define _f9 load0(vec2(8.5,0.5)).x\n#define _f10 load0(vec2(9.5,0.5)).x\n#define _f11 load0(vec2(10.5,0.5)).x\n#define _f12 load0(vec2(11.5,0.5)).x\n#define _f13 load0(vec2(12.5,0.5)).x\n\n#define UV_SCALE 12.\n#define gold vec3(215., 254., 256.)/255.\nfloat rnd(float a){\n    return fract(sin(a)*45960.24562);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n", "buffer_b_code": "\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*4254.);  \n}\n\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\nfloat voronoi(vec2 uv){\n  \n    float d = 100.;\n    vec2 uvFL = floor(uv);\n    vec2 uvFR = fract(uv);\n  \n    for(float i = -1.; i <= 1.; i++){\n      for(float j = -1.; j <= 1.; j++){\n      \n        vec2 nachbar = vec2(i,j);\n        d = min(d, length( uvFR - noise(uvFL + nachbar)  - nachbar));\n      }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = vec4(0.,0.,0.,1.);\n  vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n  \n  uv*= clamp(_f11,0.5,1.)*2.;\n  uv.x+=_f12*2.;\n  uv.y+=_f13*1.;\n  vec3 col = vec3(0.0);\n  \n  float fa1 = smoothstep(0.2, 0.9,\n              abs( fract(fbm(uv + length(uv)*_f1*.5,5., 2.)*_f2*2.)-0.5) );\n  //float fa1 = smoothstep(0.2, 0.9,\n             // abs( fract(fbm(uv + length(uv)*0.5,5., 2.)*2.)-0.5) );\n  \n  float fb1 = fbm(uv*_f3*2. + vec2(3. ,3. ) ,5., 5.);\n  \n\n  \n  float fb2 = fbm(uv*_f4*3.+ fa1/(_f5*5.) ,4., 3.);\n    //float fb2 = fbm(uv*3.+ fa1/5. ,4., 3.);\n\n    float fb3 = fbm(uv*_f6*1.*rot(_f7) + vec2(1. ,47. ) + fb2*_f8*.5 , 3., 2.);\n   \n   \n    float fb3b = fbm(uv*_f9*2. + fb1*_f10*2. + vec2(sin(uv.x/4.),0.), 2., 2.);\n    float fb3c = fbm(uv + fb1*2. + vec2(3.), 4., 2.);\n\n    col = mix(col, vec3(0.,1.,1.),pow(fb3*1.1, 5.));\n    \n    col = mix(col, vec3(atan(vec2(uv.x,uv.y+0.4))*.8, 0.), pow(fb3,1.6));\n    //col = mix(col, vec3(0.,sin(uv.y),0.9), pow(fb2, 15.));\n    col = mix(col, vec3(0.,0.,0.),fa1*.9);    \n    col *= 1.5;\n    \n   \n    col = sin(vec3(1.,2.,9.)/80. + col + 6.1);\n    //col = mix(vec3(1.,0.,0.), vec3(1.), clamp(col*3.,0.,1.));\n    col = mix(col, vec3(.0,0.0,0.2),voronoi(uv*3.))*1.;\n    float dasBit = pow(dot(normalize(vec3(1.)),normalize(vec3(uv,1.))),9.);\n    col = mix(col, vec3(.9,0.9,0.9),pow(fb2,5.))*1.3 +dasBit;  \n    \n    //col = mix(col, vec3(.9, .0 ,1.), );\n    \n    col = mix(col, vec3(4.3), pow(fb3b, 4.) );\n    col = mix(col, vec3(2.,6.,9.)*.1, pow(fb3c, 4.) );\n    //col = mix(col, vec3(0.9,0.4,0.)*1., pow(fb3, 7.) );\n    \n    //when I use Flux it's this: \n    //fragColor = vec4(col*vec3(0.9,0.8,.4),1.0); //lol\n    //but that is actually only there because I forgot flux the first time lol\n    col *= 1.4;\n    //col =pow(col,vec3(1.,0.9, 1.));\n    fragColor = vec4(col*vec3(0.8,0.65,.2),1.0);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 105], [107, 130, 158, 158, 248], [249, 249, 373, 373, 1397], [1399, 1399, 1456, 1506, 2296]], "test": "untested"}
{"id": "slySD3", "name": "Bubble Bath", "author": "wyatt", "description": "bubbles", "tags": ["voronoi", "bubbles"], "likes": 36, "viewed": 570, "published": 3, "date": "1641422426", "time_retrieved": "2024-07-30T17:11:41.734180", "image_code": "// Sparkle \nMain \n    Q = .5*B(U)+.7*sin(4.5+.7*U.y/R.y+vec4(1,2,3,4));\n    for (float i = -20.; i <= 20.; i++) {\n        vec4 a = B(U+vec2(i,.5*i));\n        vec4 b = B(U+vec2(-.3*i,i));\n        Q += .6*vec4(2,1,1,1)*exp(-.004*i*i)*(.5+.5*sin(.4*i+vec4(1,2,3,4)))* \n            (pow(a,vec4(5))/sqrt(a.w)+\n              pow(b,vec4(5))/sqrt(b.w));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I; \n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; T = iTime; I = iFrame;\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define N 5\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\nfloat size(vec2 U) {\n    float y = round(U.y/20.)*20./R.y;\n    if (U.y>.5*R.y) y = round(U.y/5.)*5./R.y;\n    return 7.*(5.3-5.*pow(y,.2));\n}\nfloat pie (vec2 p, vec2 a, vec2 b, float sa, float sb) {\n    if (length(a-b)==0.) return 1e9;\n    return abs(dot(b-a,p-a)/dot(b-a,b-a)-(sa)/(sa+sb));\n}", "buffer_a_code": "// Save bubble position and calc force \nMain\n    Q = A(U);\n    float sz = size(U);\n    vec2 f = vec2(0,-1e-3);\n    \n    for (float x = -2.; x <= 2.;x++)\n    for (float y = -2.; y <= 2.;y++)\n    {\n        vec4 d = D(Q.xy+vec2(x,y));\n        vec4 a = A(d.xy);\n        float s = size(d.xy);\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        float w = sg(Q.xy+vec2(x,y),Q.xy,a.xy);\n        if (l>0.&&l<sz+s&&w<1.) {\n            f += .01*r/l*(l-sz-s);\n            f += .03*r/l*exp(-l/s/sz);\n        }\n    }\n    f *= 20./sz;\n    if (iMouse.z>0.) {\n        vec2 m = (Q.xy-iMouse.xy);\n        Q.zw += 1e-2*exp(-1e-2*length(m))*m;\n    }\n    \n    Q.zw += f;\n    Q.xy += f + Q.zw*10./sz;\n    \n    if (length(Q.zw)*10./sz>1.) Q.zw = normalize(Q.zw)/10.*sz;\n    \n    if(Q.x<sz) Q.x=sz,Q.zw*=0.;\n    if(Q.y<sz) Q.y=sz,Q.zw*=0.;\n    if(Q.x>R.x-sz) Q.x=R.x-sz,Q.zw*=0.;\n    if(Q.y>R.y-sz) Q.y=R.y-sz,Q.zw*=0.;\n    \n    if (I<1) {\n        vec2 v;\n        v.y = round(U.y/20.)*20.;\n        float s = 2.*size(vec2(0,v.y));\n        v.x = round(U.x/s)*s;\n        Q = vec4(v,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Display Bubbles \nMain \n    Q = vec4(0);\n    vec4 c = C(U);\n    vec4 d = D(U);\n    vec4 a = A(c.xy);\n    vec4 b = A(d.xy);\n    float sa = size(c.xy);\n    float sb = size(d.xy);\n    \n    vec2 v = U-a.xy;\n    if (length(U-a.xy)<sa) {\n        float z = sqrt(sa*sa-dot(v,v));\n        vec3 no = normalize(vec3(U,z)-vec3(a.xy,0));\n        Q = texture(iChannel1,reflect(no,-normalize(vec3(U.xy,0)-R.xyx)));\n        float l = abs(length(v)-sa);\n        float w = length(a.xy-b.xy)*pie(U,a.xy,b.xy,sa,sb);\n        l = min(l,w);\n        Q *= exp(-.01*l*l);\n    } \n    Q.w = sa;\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// track nearest bubble \nvoid X (inout vec4 Q, vec2 U, vec4 a) {\n    vec4 q = A(Q.xy);\n    vec4 b = A(a.xy);\n    if((length(U-b.xy)-size(a.xy))<(length(U-q.xy)-size(Q.xy)))\n        Q = a;\n}\nMain\n    Q = C(U);\n    X(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    X(Q,U,C(U+vec2(0,3)));\n    X(Q,U,C(U+vec2(3,0)));\n    X(Q,U,C(U-vec2(0,3)));\n    X(Q,U,C(U-vec2(3,0)));\n    \n    \n    X(Q,U,D(U+vec2(0,1)));\n    X(Q,U,D(U+vec2(1,0)));\n    X(Q,U,D(U-vec2(0,1)));\n    X(Q,U,D(U-vec2(1,0)));\n    \n    if(iFrame < 1) {\n        Q = vec4(U,0,0);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Track neighborhood network \nvoid Y (inout vec4 Q, vec2 U, vec4 c ,vec4 a) {\n    vec4 q = A(Q.xy);\n    vec4 b = A(a.xy);\n    float sa = size(Q.xy);\n    float sb = size(a.xy);\n    if (pie(U,c.xy,b.xy,sa,sb)<pie(U,c.xy,q.xy,sa,sb))\n        Q = a;\n}\nMain\n    Q = D(U);\n    vec4 c = A(C(U).xy);\n    Y(Q,U,c,D(U+vec2(0,1)));\n    Y(Q,U,c,D(U+vec2(1,0)));\n    Y(Q,U,c,D(U-vec2(0,1)));\n    Y(Q,U,c,D(U-vec2(1,0)));\n    Y(Q,U,c,D(U+vec2(1,1)));\n    Y(Q,U,c,D(U+vec2(1,-1)));\n    Y(Q,U,c,D(U-vec2(1,1)));\n    Y(Q,U,c,D(U-vec2(1,-1)));\n    \n    Y(Q,U,c,C(U+vec2(0,1)));\n    Y(Q,U,c,C(U+vec2(1,0)));\n    Y(Q,U,c,C(U-vec2(0,1)));\n    Y(Q,U,c,C(U-vec2(1,0)));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slySD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlySDc", "name": "#Genuary Day 5 Destroy a Square", "author": "cmarangu", "description": "My creation for #genuary #genuary2022 Genuary 2022 Day 5 day5 genuary5 05 five Destroy a Square\n[url]https://genuary.art/prompts#jan5[/url]", "tags": ["slice", "rubix", "slicing", "rubiks", "genuary", "genuary2022"], "likes": 13, "viewed": 289, "published": 3, "date": "1641421978", "time_retrieved": "2024-07-30T17:11:42.782378", "image_code": "// Title: #Genuary Day 5\n// Started: 2022 1/5\n// Tags: slice, rubix, slicing, rubiks, genuary, genuary2022\n// Description: My creation for #genuary #genuary2022 Genuary 2022 Day 5 day5 genuary5 05 five Destroy a Square\n// [url]https://genuary.art/prompts#jan5[/url]\n\n\n\n// i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582097494459230\n//7816406286208998628\n#define TAU PI*2.\n\n#define arg mod(float(iFrame)/60./6.+.6, 1.)\n\n\n\n\n\n\n\n\n\n// sky map\n#define sund normalize(vec3(0., 0., -1.))\nvec3 sky_map (vec3 d) {\n    //return abs(d);\n    //return vec3(1.);\n    // return vec3(0., 0., 100./255.);\n    return vec3(1., 0., 0.);\n    \n    float dimness = .5+.5*clamp(cos(d.y*PI), -.8, .8);\n    \n    //return texture(iChannel2, d).rgb;\n    \n    vec3 aus = vec3(0.);\n    float licht;\n    licht = clamp(dot(d, normalize(vec3(1., 1., 1.)) ), 0., 1.);\n    aus += vec3(1.)*pow(licht, 1.);\n    licht = clamp(dot(d, normalize(vec3(0., 1., 1.)) ), 0., 1.);\n    aus += vec3(0., 0., 1.)*pow(licht, 5.);\n    \n    \n    //vec2 pl = d.xz/d.y*6.;\n    //if (d.y < 0.) { aus += mod(floor(pl.x)+floor(pl.y), 2.); }\n    \n    //return clamp(aus, 0., 1.);\n    \n    float a = 2.;\n    float ah = dot(vec3(d.x, -abs(d.y), d.z), normalize(vec3(0., -a, 0.)) );\n    float h = a/ah;\n    float o = sqrt(h*h-a*a);\n    float th = atan(d.z, d.x);\n    // g is where it hits the ground/sky\n    vec2 g = vec2(cos(th)*o, sin(th)*o);\n    \n    // get ths sky color\n    float cloudamt = 0.;\n    cloudamt += .7*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt += .3*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt = pow(cloudamt, 2.);\n    // cloudamt *= .4;\n    // cloudamt += .0*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/90.).r;\n    \n    vec3 SKY_COLOR = vec3(.0, .5, 1.);\n    SKY_COLOR += cloudamt;\n        // dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n    if (d.y > .2) {\n        return clamp(SKY_COLOR*pow(dimness, .05), 0., 1.);\n    }\n    else {\n        // return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n        vec3 GROUND_COLOR = vec3(.3, .5, .3)*(\n            .0+.8*texture(iChannel1, g/5.).r);\n        \n        GROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-\n            2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n        GROUND_COLOR *= 4.;\n        GROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n        \n        float puddleamt = .5+.5*sin(g.x*o*.05);\n        puddleamt = .5*puddleamt+.5*texture(iChannel1, vec2(g.x, g.y)/20.).r;\n        puddleamt = pow(puddleamt, .3);\n        dimness = mix(dimness, 1., puddleamt)*.5;\n        \n        if (puddleamt > .8) {\n            float amt = (puddleamt-.3)/.6;\n            amt = clamp(amt, 0., 1.);\n            amt = pow(amt, 2.);\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n        }\n        if (-.2 <= d.y && d.y <= .2) {\n            float amt = (d.y+.2)/.4;\n            dimness = mix(\n                dimness,\n                mix(\n                    dimness*2.,\n                    1.,\n                    -puddleamt\n                ),\n                amt\n            );\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n        }\n        return clamp(GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.)), 0., 1.);\n    \n    }\n\n}\n\n\n\n\n\n// related to tracing onto things (return distance and normal)\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n// plane - one liner lol\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n\n#define inter_plane_short(p, d, c, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(c-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, c, n) (\\\n//dot(n, d) > 1e-6 ? dot(c-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n// sphere\n#define SDF_sphere(p, c, r) ( length(p-c)-r )\n\n// #define inter_sphere(p, d, c, r) ( dot(d, c-p)\n\n\n// SDF\n\n#define SDF_sq(p) ( length(max(abs(p)-vec3(.98,.98,.1), 0.))-.01 )\n//#define SDF_core(p) ( length(max(abs(p)-.8, 0.))-.015 )\n//#define SDF(p) max(SDF_sq(p), -SDF_core(p) )\n#define SDF(p) SDF_sq(p)\n//#define SDF(p) ( length(p)-2. )\n\n\n\n\n#define inf vec2(1e-3, 0.)\n\n#define dSDF(p) normalize(vec3(SDF(p+inf.xyy),SDF(p+inf.yxy),SDF(p+inf.yyx))-SDFp)*sign(SDFp)\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // return inter_sphere(p, d, vec3(0.), .5);\n    float SDFp;\n    \n    vec3 camp = p;\n    \n    //for (int i=0; i<1333222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        if (abs(SDFp) < 1e-4) {\n            return vec4(dSDF(p), length(p-camp));\n        }\n        //p += d*abs(SDFp)*.5;\n        p += d*abs(SDFp);\n        if (abs(SDFp) > 10.) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\n\n\nvoid shift_shard (inout vec3 p, inout vec3 d, vec3 c, vec3 n, float angtot, float amt, out mat3 rot) {\n    #define iv .4\n    //p += n*.1*clamp(amt/iv, 0., 1.);\n    //p += n*.01;\n    //p -= n*.1*clamp((amt-iv)/(1.-iv), 0., 1.);\n    //p += n*.05;\n    p += n*.2*amt;\n    \n    float arg4 = clamp((amt-iv)/(1.-iv), 0., 1.);\n    \n    #define easen 5.\n    //arg4 = 1.- pow(.3, floor(arg4*(easen*2.-1.)/2.-.5)+1.) * abs(sin(PI*( arg4*(easen*2.-1.)/2. - .5)  ));\n    #undef easen\n    \n    //arg4 = .5-.5*cos(arg4*PI);\n    \n    p -= c;\n    // d -= c;\n    \n    \n    // https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    float th = arg4*angtot;\n    float costh = cos(th);\n    float ONE_MIN = 1.-costh;\n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    p = rot*p;\n    d = rot*d;\n    \n    th = -th;\n    costh = cos(th);\n    ONE_MIN = 1.-costh;\n    /*rot = mat3(\n        cos(th)+n.x*n.x*(1.-cos(th)),     n.x*n.y*(1.-cos(th))-n.z*sin(th), n.x*n.z*(1.-cos(th))+n.y*sin(th),\n        n.y*n.x*(1.-cos(th))+n.z*sin(th), cos(th)+n.y*n.y*(1.-cos(th)),     n.y*n.z*(1.-cos(th))-n.x*sin(th),\n        n.z*n.x*(1.-cos(th))-n.y*sin(th), n.z*n.y*(1.-cos(th))+n.x*sin(th), cos(th)+n.z*n.z*(1.-cos(th))\n    );*/\n    \n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    //nc = n;\n    //nc = vec3(1., 0., 0.);\n    \n    p += c;\n    // d += c;\n    //#undef iv\n}\n\n\n#define numpanes 5\nvec4 inter_shattered (vec3 p, vec3 d, vec3 panec[numpanes],\n    vec3 panen[numpanes], float angtot[numpanes], inout vec3 pT, inout vec3 dT, out int midspace) {\n    //pT = p; dT = d; return inter_SDF(p, d);\n    float arg2 = min(arg*2., 2.-arg*2.);\n    //arg2 = max(1.+(arg2-1.)*1.0, 0.);\n    arg2 = min(arg2*1.4, 1.);\n    arg2 = max(1.-(1.-arg2)*1.4, 0.);\n    vec4 inter_closest;\n    vec4 inter_pane1;\n    vec4 inter_pane1T;\n    vec4 inter_SDF1;\n    //\n    float arg3; mat3 rottot = mat3(1.); mat3 rottot_; mat3 rot;\n    // for jumps\n    inter_closest = inter_sky;\n    pT = p;\n    dT = d;\n    midspace = 0;\n    //for (int i=0; i<numpanes; ++i) {\n    for (int i=numpanes-1; i>=0; --i) {\n        pT = p;\n        dT = d;\n        arg3 = clamp(arg2*float(numpanes)-float(i), 0., 1.);\n        if (arg3 == 0.) {continue;}\n        \n        if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n            // upper space - no transform\n            inter_pane1 = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            if (inter_pane1.w < inter_closest.w) {\n                inter_closest = inter_pane1;\n            }\n        }\n        else {\n            // keep track of plane in original space\n            inter_pane1 = inter_plane(p, d, panec[i], panen[i]);\n            // warp space and check stuff\n            shift_shard(pT, dT, panec[i], panen[i], angtot[i],\n                arg3, rot\n            );\n            \n            rottot_ = rottot;\n            // rottot = rot*rottot;\n            rottot = rottot * rot;\n            \n            inter_pane1T = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            \n            if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n                // midspace - can only trace onto 2 planes to escape\n                midspace += 1;\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n                if (inter_pane1.w < inter_closest.w) {\n                    // we are dealing in untransformed space\n                    // this one pane gets the texture coords of\n                    // upper space\n                    pT = p;\n                    dT = d;\n                    inter_closest = inter_pane1;\n                    inter_closest.xyz = rottot_ * inter_closest.xyz;\n                }\n            }\n            else {\n                // lower space - can only trace onto transformed\n                // pane or obj\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n            }\n            \n        }\n        p = pT;\n        d = dT;\n    }\n    if (midspace == 0) {\n        inter_SDF1 = inter_SDF(pT, dT);\n        if (inter_SDF1.w < inter_closest.w) {\n            inter_closest = inter_SDF1;\n        }\n        inter_closest.xyz = rottot*inter_closest.xyz;\n    }\n    \n    \n    \n    return inter_closest;\n    //return inter_sky;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 panec[numpanes];\n    vec3 panen[numpanes];\n    float angtot[numpanes];\n    \n    panec[0] = vec3(.0, .0, .0);\n    panec[1] = vec3(.0, .0, .0);\n    panec[2] = vec3(.0, .0, .0);\n    panec[3] = vec3(.0, .0, .0);\n    panec[4] = vec3(.0, .0, .0);\n    \n    panen[0] = normalize(vec3(2., 3., 0.));\n    panen[1] = normalize(vec3(0., 0., 1.));\n    panen[2] = normalize(vec3(2., 1., 0.));\n    panen[3] = normalize(vec3(-1., 6., 0.));\n    panen[4] = normalize(vec3(-1., 1., 0.));\n    \n    /*angtot[0] = PI;\n    angtot[1] = PI*.5;\n    angtot[2] = PI*.5;\n    angtot[3] = TAU/3.;\n    angtot[4] = PI;*/\n    angtot[0] = PI;\n    angtot[1] = PI/3.;\n    angtot[2] = PI;\n    angtot[3] = PI;\n    angtot[4] = PI;\n    \n    #define spw 1.\n    vec3 finalCol = vec3(0.);\n    float ox; float oy;\n    for (ox=0.; ox<spw; ++ox) {\n        for (oy=0.; oy<spw; ++oy) {\n            vec2 screen = (fragCoord.xy+vec2(ox, oy)/spw-iResolution.xy/2.)/iResolution.y;\n\n            // camera\n            #if 0\n            // perspective\n            vec3 camp = vec3(0., 0., -2.);\n            vec3 camd = normalize(vec3(screen.x, screen.y, .5));\n            //vec3 p = vec3(0.);\n            //vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n            #else\n            // orthogonal\n            vec3 camp = vec3(screen.x, screen.y, 0.)*6.*(sqrt(2.)/2.);///cos(30.*PI/180.);\n            vec3 camd = normalize(vec3(0., 0., 1.));\n            camp -= camd*4.;\n            #endif\n            \n            float ph = 0.;\n            float th = 0.;\n            th += clamp((arg-.1)/(1.-.1), 0., 1.)*TAU+PI;\n            //if (iMouse.z > 0.0001) {\n            if (iMouse.x >= 0.0001) {\n                ph = (iMouse.y/iResolution.y*2.-1.)*4.;\n                th = (iMouse.x/iResolution.x*2.-1.)*TAU;\n            }\n            mat2 zenith = mat2(\n                cos(ph), cos(PI*.5+ph),\n                sin(ph), sin(PI*.5+ph)\n            );\n            camd.yz *= zenith;\n            camp.yz *= zenith;\n            mat2 azimuth = mat2(\n                cos(th), cos(PI*.5+th),\n                sin(th), sin(PI*.5+th)\n            );\n            camd.xz *= azimuth;\n            camp.xz *= azimuth;\n\n            // retina color at point from raytracing\n            vec3 retina = vec3(0.);\n            float shiny = 1.;\n            vec4 inter_shattered1;\n            vec3 p = camp;\n            vec3 d = camd;\n            vec3 pT;\n            vec3 dT;\n            int midspace;\n            bool wasout;\n            bool isout;\n            vec3 pT2;\n            vec3 dT2;\n\n            //vec4 inter_cam = inter_plane(\n            //    p, d, normalize(p)*.5, normalize(p-vec3(0.))\n            //);\n            //p += d*inter_cam.w;\n\n            for (int bounces=0; bounces<37; ++bounces) {\n                if (shiny < .1) {\n                    break;\n                }\n                inter_shattered1 = inter_shattered(\n                    p, d, panec, panen, angtot, pT, dT, midspace\n                );\n                if (inter_shattered1.w >= inter_sky.w) {\n                    // too far - hits sky\n                    break;\n                }\n                else {\n                    p += d*inter_shattered1.w;\n                    pT += dT*inter_shattered1.w;\n\n\n                    wasout = midspace > 0 || SDF(pT) > 1e-3;\n                    inter_shattered(\n                        p+d*1e-2, d, panec, panen, angtot, pT2, dT2, midspace);\n\n                    if (abs(SDF(pT)) < 1e-3 ) {\n                    //if (abs(SDF(pT)) < 1e-3 || SDF(pT) < 1e-2 &&\n                    //    sign_shattered(p+d*1e-2, panec, panen) !=\n                    //    sign_shattered(p-d*1e-2, panec, panen) ) {\n                    //if (wasout != isout) {\n                    //if (abs(SDF(pT)) < 1e-3 ||\n                    //    wasout != (midspace > 0 || SDF(pT2+dT2*1e-2) > 1e-3)) {\n\n                        // hits object - have distance to intersection and normal\n\n                        /*//vec3 TEXp = .5+.5*(inter_shattered1.xyz);\n                        float SDFp = SDF(pT);\n                        vec3 seid = abs(dSDF(pT) );\n\n                        vec3 TEXp = vec3(0., 0., 0.);\n                        float ang1;\n\n                        ang1 = acos(dot(seid, vec3(0., 1., 0.) ));\n                        TEXp = mix(TEXp, vec3(0., 1., 1.), 1.-clamp(\n                            ang1/(PI*.5),\n                            0., 1.\n                        ));\n\n                        ang1 = acos(dot(seid, vec3(1., 0., 0.) ));\n                        TEXp = mix(TEXp, vec3(1., 1., 1.), 1.-clamp(\n                            ang1/(PI*.5),\n                            0., 1.\n                        ));\n\n                        ang1 = acos(dot(seid, vec3(0., 0., 1.) ));\n                        TEXp = mix(TEXp, vec3(0., 0., 1.), 1.-clamp(\n                            ang1/(PI*.5),\n                            0., 1.\n                        ));\n\n                        #if 1\n                        TEXp = mix(\n                            TEXp,\n                            vec3(.3),\n                            .0+.3*mod(floor(pT.x*9.+.001)+floor(pT.y*9.+.001)+floor(pT.z*9.+.001), 2.)\n                        );\n                        #endif\n                        //TEXp = abs(inter_shattered1.xyz);\n                        //TEXp = vec3(0.);\n                        */\n                        vec4 inter_closest = inter_shattered1;\n                        //vec3 specular = sky_map(reflect(camd, inter_closest.xyz));\n                        float specularh = clamp(dot(reflect(d, inter_closest.xyz), sund ), 0., 1.);\n                        //float specularh = length(specular)/sqrt(3.);\n                        vec3 TEXp;\n\n                        #define cz1 10.\n\n                        //if (mod(floor(pT.x*cz1-inf.x)+floor(pT.y*cz1-inf.x)+floor(pT.z*cz1-inf.x), 2.) < 1.) {\n                        //if (abs(SDF(pT)) < 1e-3 && !(length(pT-vec3(1., 0., 0.)) < .5) ) {\n                        //if (abs(SDF(pT)) < 1e-3) {\n                        if (true) {\n                            if (pT.z > 0.) {\n                                // pearly white\n                                float diffuse = clamp(dot(inter_closest.xyz, sund ), 0., 1.);\n                                // specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, 4.);\n                                float gx = clamp(.5+.5*pT.x, 0., 1.);\n                                float gy = clamp(.5+.5*pT.y, 0., 1.);\n                                TEXp = vec3(0., gx, gy)+specularh*.7;\n\n\n                                #define shininess .9993\n                                //#define shininess clamp(.5+2.*pT.y, 0.2, 1.)\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                            else {\n                                // shiny black\n                                float diffuse = clamp(dot(inter_closest.xyz, sund ), 0., 1.);\n                                // specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, .4);\n                                TEXp = vec3(.0)+specularh*.7;\n\n\n                                #define shininess .9993\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                        }\n                        else {\n                            // heres for blue bubble\n                            /*vec4 inter_inside = inter_sphere(camp, camd, closest_center, closest_r, true);\n                            vec2 glob = vec2(\n                                .5+.5*dot(inter_inside.xyz, normalize(vec3(0., -1., .5)) ),\n                                .5+.5*dot(inter_closest.xyz, normalize(vec3(0., -1., .5)) )\n                            );\n                            float glo = length(glob)/sqrt(2.);*/\n                            float glo = 1.-(.5+.5*p.y); //mod(p.y*cz1, 1.);\n\n                            glo = 3.*glo*glo-2.*glo*glo*glo;\n                            //glo = pow(glo, 1.7);\n\n                            specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                            specularh = pow(specularh, 1.5);\n\n                            float glo2 = pow(glo, 2.);\n                            TEXp = vec3(.0, .3, .5) + vec3(.0*glo2, .5*glo2, .5*glo) + vec3(1.)*specularh*.95;\n\n\n                            #define shininess .002999\n                            retina += TEXp*shiny*shininess;\n                            shiny *= 1.-shininess;\n                            //d = reflect(d, inter_shattered1.xyz);\n                            p += d*1e-3;\n                            #undef shininess\n                        }\n                    }\n                    else {\n                        // hits pane - translucency if want debug\n\n                        vec3 TEXp = abs(inter_shattered1.xyz)*0.+mod(\n                            floor(p.x+1e-3)+floor(p.y+1e-3)+floor(p.z+1e-3),\n                            2.\n                        );\n                        #define shininess .0\n                        retina += TEXp*shiny*shininess;\n                        shiny *= 1.-shininess;\n\n                        //d = reflect(d, inter_shattered1.xyz);\n                        p += d*1e-4;\n                        #undef shininess\n                    }\n                }\n            }\n\n            if (shiny == 1.) {\n                // white background if never hit obj\n                retina = vec3(0., 0., 100./255.);\n                shiny *= 0.;\n            }\n\n            // add sky color to last reflection/refaction etc.\n            retina += shiny*sky_map(d);\n            finalCol += retina;\n        }\n    }\n    finalCol /= float(spw*spw);\n    fragColor = vec4(finalCol, 1.);\n    \n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlySDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 517, 540, 623, 3384], [3696, 3796, 3847, 3847, 4173], [4650, 4650, 4683, 4731, 5157], [7054, 7054, 7213, 7259, 10113]], "test": "untested"}
{"id": "ftGXW3", "name": "Genuary 2022 - Day4", "author": "z0rg", "description": "My participation to genuary 2022\nNot a real fidenza because lazyness, but an idea that I had to make something that resembles\nhttps://tylerxhobbs.com/fidenza", "tags": ["generative", "genuary", "2022", "fidenza"], "likes": 22, "viewed": 407, "published": 3, "date": "1641399718", "time_retrieved": "2024-07-30T17:11:43.551322", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    col = pow(col, vec3(2.));\n    col = sat(col*15.);\n    col = mix(vec3(0.898,0.867,0.808), vec3(0.), col.x);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdr(vec2 uv, vec2 ouv, float t)\n{\n    vec3 col = vec3(0.);\n    \n    uv.y += sin(uv.x*3.+t*.5)*.1;\n    uv.x += sin((uv.y+uv.x)*2.-t*.35)*.3;\n    col = pow(texture(iChannel0, uv*.5).x, 12.)*vec3(1.)*10.;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = vec3(0.);\n    for (int i = 0 ; i < 200; ++i)\n        col += rdr(uv*2.5, ouv, float(i)*.01+iTime);\n    col /= 200.;\n    col = sat(col);\n    float sz = .25;\n    col = mix(col, vec3(0.), sat(max(abs(uv.x)-.47, abs(uv.y)-sz)*iResolution.x*.5));\n   col = mix(col, texture(iChannel1, ouv).xyz, .975);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXW3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 682]], "test": "untested"}
{"id": "7lVXWK", "name": "Genuary 2022 - Day1", "author": "z0rg", "description": "My participation to genuary 2022", "tags": ["generative", "genuary", "2022", "10000"], "likes": 15, "viewed": 340, "published": 3, "date": "1641398732", "time_retrieved": "2024-07-30T17:11:44.418004", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nfloat time;\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nfloat _shape(vec2 uv, float s, float id)\n{\n    return mix(_sqr(uv, vec2(s)), length(uv)-s, 5.*sin(time+id)); \n}\n\nvec3 rdr(vec2 uv)\n{\n    float sharp = iResolution.x*.75;\n    vec3 col = vec3(0.);\n    \n    vec2 rep = vec2(.005);\n    vec2 id = floor((uv+rep*.5)/rep);\n    \n    uv = mod(uv+rep*.5,rep)-rep*.5;\n    \n    float shape = _shape(uv, .001, id.x*.1+id.y*sin(time+id.x*.01)*.5);\n    if (abs(id.x) < 50. && abs(id.y) < 50.)\n        col = mix(col, vec3(1.), 1.-sat(shape*sharp));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    float off = sin(iTime)*.2;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = vec3(0.);\n    col.x = rdr(uv).x;\n    time = iTime+off;\n    col.y = rdr(uv).y;\n    time = iTime+off*2.;\n    col.z = rdr(uv).z;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXWK.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[442, 442, 471, 471, 523], [525, 525, 567, 567, 636], [638, 638, 657, 657, 1029], [1032, 1032, 1089, 1089, 1373]], "test": "untested"}
{"id": "flVSRG", "name": "Worley Noise Prototype", "author": "Remming_Senegal", "description": "Attempting to program worley noise myself for a future cloud + gas project.\n\nNot a big project, just a proof of concept.", "tags": ["procedural", "noise", "hash", "dot"], "likes": 5, "viewed": 290, "published": 3, "date": "1641397129", "time_retrieved": "2024-07-30T17:11:45.232826", "image_code": "vec3 Rand3D( vec3 pos ) // Less resource demanding to use the blue noise texture\n{\n\treturn textureLod( iChannel0, (pos.xy+pos.z)/256.0, 0.0 ).rgb;\n}\n\n// Look at how I just copied the code from my voronoi shader. How convenient!\n// https://www.shadertoy.com/view/sttGzB\nvoid worley( in vec3 p, out vec3 coord, out float distToBorder, out float color)\n{\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    distToBorder = 5.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = Rand3D( n + g );\n        vec3 r = g + o - f;\n        float d = length(r);\n\n        if(d<distToBorder)\n        {\n            distToBorder = d;\n            coord = r;\n            color = o.x;\n        } \n    }\n\n    // coord is like the local coordinate of the voronoi\n    // Adding p turns it into a universal coordinate\n    // That's a poor way of explaining it, so comment the line to see what I mean\n    coord += p;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0 - 1.0)/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 7.0;\n    \n    //the 3D model\n    vec3 xyz = vec3(uv,iTime);\n    vec3 coord;\n    float distToBorder;\n    float color;\n    worley(xyz,coord,distToBorder,color);\n    \n    // The other outputs the 3D voronoi function returns\n    //vec3 col = coord;\n    //vec3 col = vec3(color);\n    vec3 col = vec3(distToBorder);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 82, 82, 148], [150, 269, 351, 351, 1116], [1118, 1118, 1175, 1225, 1719]], "test": "untested"}
{"id": "stKSDK", "name": "Genuary 2022 - Day2", "author": "z0rg", "description": "My participation to genuary 2022", "tags": ["generative", "dithering", "genuary", "2022"], "likes": 9, "viewed": 323, "published": 3, "date": "1641385377", "time_retrieved": "2024-07-30T17:11:46.155359", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 grad(float f)\n{\n    return mix(vec3(0.184,0.141,0.498), vec3(0.996,0.620,0.263), f);\n}\n\nvec3 rdr(vec2 ouv, vec2 fragCoord)\n{\n    vec3 col = vec3(0.);\n    \n    col = texture(iChannel0, (ouv)).xyz;\n    col = grad(col.z-texture(iChannel1, fragCoord/16.).x);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = rdr(uv, fragCoord);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n    \n    return vec2(_sph(p, 1.), 0.);\n}\n\nvec3 accLight;\n\nvec3 lPos = vec3(5.,-5.,5.);\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.0001)\n            return vec3(res.x, distance(p, ro), res.y);\n        vec3 h = normalize(rd+(lPos-p));\n        accLight += vec3(1.)*(1.-sat(res.x/.5))*.1*sat(sat(dot(normalize(p),h))+.3);//*sat(dot(normalize(p), rd));\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    \n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n    accLight = vec3(0.);\n    vec3 col = vec3(0.078,0.063,0.137);\n    \n    col = mix(col, vec3(0.239,0.216,0.565), 1.-sat((length(uv-vec2(.3))-.1)*3.));\n    col = mix(col, vec3(0.239,0.216,0.565), 1.-sat((length(uv-vec2(-.3,.3))-.1)*3.));\n    col = mix(col, vec3(0.408,0.216,0.565), 1.-sat((length(uv-vec2(.3,-.3))-.1)*3.));\n    col += sat(length(uv*.75))*sat(pow(texture(iChannel1, uv*4.).x,20.)*5.*2500./iResolution.x)*texture(iChannel1, uv*5.+vec2(iTime*.25, 0.)).x;\n   \n    float rad = 5.;\n    float t = 1.5+0.*iTime*.25;\n    vec3 ro = vec3(sin(t)*rad,-3.,cos(t)*rad);\n    vec3 ta = vec3(0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    float depth = -1.0f;\n    // Might be good to use raytracing here, may be way lighter\n    vec3 res = trace(ro, rd, 50);\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        //col = n*.5+.5;\n        // If you look carefully and move the camera you'll notice \n        // that I don't account for seamless transition as originally \n        // I used a custom texture that does it pretty well\n        // You know shadertoy custom texture...\n        vec2 coords = vec2(atan(p.x, p.z)+iTime*.25, acos(p.y))*vec2(1./(PI*2.),1./(PI))-vec2(0.,PI);\n        \n       // float earth = 1.-texture(iChannel0, coords)-).x;\n        vec2 deform = vec2(1., 2.)*4.;\n        vec2 rep = deform*.003;\n        vec2 id = floor((coords+rep*.5)/rep);\n\n        vec2 mapcoord = mod(coords+rep*.5,rep)-rep*.5;\n        \n        float earth2 = 1.-texture(iChannel0, id*rep*.5).x;\n        earth2 = sat(pow(earth2, 10.)*10.);\n        vec3 h = normalize(rd+(lPos-p));\n        float NdH =dot(n,h);\n        vec3 rgb = vec3(0.239,0.216,0.565)*sat(sat(NdH)+.2);\n        \n        col = rgb;\n        if (earth2 > 0.01)\n        col = mix(rgb, vec3(0.843,0.643,0.918), 1.-sat(_cir(mapcoord/deform,sat(earth2)*.0005)*4000.));\n        \n        col += 2.*vec3(0.239,0.216,0.565)*(1.-sat(-dot(rd, n)*1.5))*sat(sat(NdH*1.)+.25);\n        col += vec3(0.408,0.216,0.565)*(1.-sat(-dot(rd, n)*3.5));\n    }\n    else\n        col += mix(vec3(0.239,0.216,0.565)*.1, vec3(0.408,0.216,0.565), 1.)*accLight;\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*3.);\n    if (true) // Not so cheap antialiasing\n    {\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKSDK.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 417, 417, 488], [490, 490, 526, 526, 674], [676, 676, 733, 733, 847]], "test": "untested"}
{"id": "7lcSR2", "name": "Genuary 2022 - Day3", "author": "z0rg", "description": "My participation to genuary 2022", "tags": ["space", "generative", "genuary", "2022"], "likes": 7, "viewed": 275, "published": 3, "date": "1641385373", "time_retrieved": "2024-07-30T17:11:47.012068", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb, vec3(1.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW .9\n#define GLOW_OPACITY .4\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.)\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x) + abs(v.y);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n    \n//    acc = _min(acc, vec2(length(p)-1., 0.));\n    \n    float ground = max(-p.y, p.z);\n    acc = _min(acc, vec2(ground, 0.));\n    \n    float th = .2;\n    float rad = 1.;\n    float windowCircle = max(max(length(p.xy)-rad, abs(p.z-th)-.2), -(length(p.xy)-(rad-th)));\n    acc = _min(acc, vec2(windowCircle, 0.));\n    \n    vec3 pu = p-vec3(0.,0.,th);\n    float stpa = PI*2./12.;\n    float an = atan(pu.y, pu.x);\n    float b = mod(an+stpa*.5,stpa)-stpa*.5;\n    pu.xy = vec2(sin(b), cos(b))*length(p.xy);\n    \n    float upperWindow = _cube(pu-vec3(0.,1.9,0.), vec3(th*.5, 1., 2.));\n    upperWindow = max(upperWindow, p.z-th);\n    upperWindow = max(upperWindow, -(length(p.xy)-abs(cos(p.z*.25))));\n    acc = _min(acc, vec2(upperWindow, 0.));\n    \n    float th2 = .2;\n    float rad2 = 1.1;\n    float hull = max(max(length(p.xy)-rad2, abs(p.z-th2)-5.2), -(length(p.xy)-(rad2-th)));\n    hull = max(hull, p.z+1.75);\n    acc = _min(acc, vec2(hull, 0.));\n\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-\n    vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\n\n\nvec3 getEnv(vec3 rd)\n{\n    vec3 lightA = 2.*sat(length(rd.xy*2.))*vec3(1.,1.,2.)*pow(texture(iChannel0, .5*vec2(atan(rd.y, rd.x), length(rd.xy)*.1-iTime*.1)).x, 5.);\n    vec3 lightB = sat(length(rd.xy*4.))*vec3(0.310,0.137,0.780)*pow(texture(iChannel0, .1*vec2(atan(rd.y, rd.x)+1., length(rd.xy)*.1-iTime*.05)).x, 3.);\n     vec3 lightC = sat(length(rd.xy*2.))*vec3(1.000,0.302,0.639)*pow(texture(iChannel0, .25*vec2(atan(rd.y, rd.x), length(rd.xy)*.1-iTime*.2)).x, 1.)*.5;\n    vec3 stars = sat(length(rd.xy*1.))*vec3(1.)*pow(texture(iChannel0, .5*vec2(atan(rd.y, rd.x), length(rd.xy)*2.-iTime*.5)).x, 5.)*.5;\n\n    return stars + (lightA + lightB + lightC)*1.5 \n    + vec3(0.400,0.882,0.875)*pow(1.-sat(lenny(rd.xy)),15.)*2.\n        + .75*vec3(0.722,0.863,1.000)*pow(1.-sat(lenny(rd.xy)),3.)*1.*(1.+0.2*rand());\n\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.);\n    vec3 lpos = vec3(0.,-4.,2.);\n    vec3 ldir = lpos-p;\n    vec3 h = normalize(ldir+rd);\n    col = vec3(.5)*pow(texture(iChannel2, p.xz*.25).x,5.); // ambient\n    col += vec3(1.000,0.502,0.675)*pow(sat(dot(n,h)),5.);\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,-.2,-3.8);\n    vec3 ta = vec3(0.,-0.5,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        float spec = .8*pow(texture(iChannel2, p.xz*2.).x,2.5);\n        vec3 diff = normalize(reflect(rd, n)+spec*(vec3(rand(), rand(), rand())-.5));\n\n        vec3 resdiff = trace(p+n*0.01, diff, 64);\n        if (resdiff.y > 0.)\n        {\n            vec3 pdiff = p+diff*resdiff.y;\n            vec3 ndiff = getNorm(pdiff, resdiff.x);\n            \n            col += getMat(resdiff, diff, pdiff, ndiff); \n        }\n        else\n            col += getEnv(diff);\n    }\n    else\n        col = getEnv(rd);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    seed = texture(iChannel0, uv).x+iTime;\n    vec2 off = (vec2(rand(), rand())-.5)*2.;\n    vec3 col = rdr(uv+off/iResolution.xx);\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .95);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcSR2.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1175]], "test": "untested"}
{"id": "slGXDV", "name": "Random Particle Thing", "author": "SnoopethDuckDuck", "description": "Code hardly different from what its forked from - simple example of technique with actual particle", "tags": ["e"], "likes": 8, "viewed": 317, "published": 3, "date": "1641351972", "time_retrieved": "2024-07-30T17:11:47.782010", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n\n    vec3 e = vec3(1.);\n    vec3 col2 = 3. * x * pal(mix(0.3, 0.35, 0.5 + 0.5 * thc(2., iTime)), e, e, e, vec3(0., 0.33, 0.66));\n    fragColor = vec4(col2, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvec2 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;   \n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    \n    // Replace 0.05, e.g. 0.1 -> more fluid-like\n    uv += 0.05 * iTime;\n    \n    ivec2 px = ivec2(fragCoord);\n    vec2 p = Cell(px);\n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        fragColor = vec4(0.);\n        p = vec2(0.5,0.5);\n    } \n    \n    // Distorted grid\n    vec2 ipos = floor(sc * uv);\n    \n    // Get random value with time\n    float spd = 2.;\n    float lh = h21(vec2(floor(spd * iTime)));\n    float nh = h21(vec2(floor(spd * iTime + 1.)));\n    float rand = mix(lh, nh, smoothstep(0., 1., fract(spd * iTime)));\n    \n    // Speed of particle (distance moved each frame)\n    float m = 10. / iResolution.y;\n    \n    // Angle of particle (remove h21() to see an actual particle)\n    float th = 4. * 2. * pi * rand;\n   \n    // Vector from angle\n    vec2 b = vec2(thc(1., th), ths(1., th));\n    \n    // New point\n    vec2 p2 = p + m * b;\n    //p2 = clamp(p2, vec2(0.1), vec2(0.9));\n    //p2 = fract(p2); // <- torus\n    p2 = mix(vec2(0.5), p + m * b, 0.905);\n    fragColor = vec4(p2.xy, 0., 1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Collection of functions I use a lot:\n\n#define pi 3.14159\n#define sc 10.\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Get \"point\" from Buffer A\n    vec2 p = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xy - 0.5;\n    \n    // Distance from point + strength to smoothstep away from it\n    float d = length(uv-p);\n    float k = 0.04 + d;\n\n    // Draw stuff\n    float s = smoothstep(-k, k, -d + 0.);\n    float x = texelFetch( iChannel1, ivec2(fragCoord), 0 ).x;\n    x = 0.97 * clamp(x, 0., 1.);\n    \n    fragColor = vec4(max(x, 2. * s));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 349]], "test": "untested"}
{"id": "7lGXDV", "name": "BUFFER_PAINTER", "author": "SimonOakey", "description": "first try paint with the buffer & trying to import from glslsandbox  > https://glslsandbox.com/e#78298.7", "tags": ["paint", "buffer"], "likes": 6, "viewed": 406, "published": 3, "date": "1641351109", "time_retrieved": "2024-07-30T17:11:48.583867", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    \n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 rot(vec2 _uv, float _a){\n\n\tfloat s = sin(_a);\n\tfloat c = cos(_a);\n\treturn _uv*mat2(c,-s,s,c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     \n     vec2 uv = ( fragCoord.xy / iResolution.xy );\n      \n       \n    vec2 pos = fragCoord.xy/iResolution.xy;\n    \n    \n    // change wobble freqency over time\n\tfloat freq_one = sin(iTime*1.5 + uv.x*3.)*5.+6.;\n\tfloat freq_two = sin(iTime*.75 + uv.y*3.)*5.+15.;\n\t\n\t// wobble here\n\t uv.x += sin(uv.y*freq_one+ iTime*3.1) *.001;\n\t uv.y += sin(uv.x*freq_two+ iTime*4.1) *.001;\n    \n    uv.y += sin(iTime*.4)*.001;\n     uv.x += sin(iTime*.4)*.001;\n    \n        \n    vec2 rmp = iMouse.xy;\n     rmp.x /= iResolution.x;\n     rmp.y /= iResolution.y;\n\t//rmp.x *= iResolution.x/iResolution.y;\n\tfloat lmp = length(rmp-uv)/.4;\n\n\t// Distort away from mouse\n\tfloat mdStrength = 0.13 * pow((1.0 - length(rmp)), 3.0);\n\tfloat mdAngle = atan(iMouse.y, iMouse.x);\n\t  // uv.x += mdStrength * cos(mdAngle);\n\t // uv.y += mdStrength * sin(mdAngle);\n    \n    // --------------------------------------------\n\t\t\n\t// this is a forked piece of code to \"rectify\" the pixels a bit\n\tfloat jitter = 0.125;\n\tuv.x += (fract(sin(uv.x*345.3 + uv.y*423.3 + iTime*426.4) * 345.3)- 0.5) / iResolution.x * jitter;\n\tuv.y += (fract(sin(uv.x*234.8 + uv.y*264.8 + iTime*521.3) * 634.7)- 0.5) / iResolution.y * jitter;\n    \n    \n\tvec3 col = vec3(.5);\n\t \n\tfragColor = vec4(col.rgb ,1.0);\n\t\n\t\n     // still the crappier buffer read out, but it looks nice :)\n\tcol = texture(iChannel0,uv).xyz ;\n\t fragColor = vec4(col.rgb ,1.0);\n\t \n\t// change the brush over time\n\tfloat color_change_freq = ( sin(iTime*.1)*.9+1. )*2.1;\n\tfloat brush_color_freq = ( sin(iTime*.3)*.9+1. )*13. ;\n\t \n\t// oscillate thriough colors along the dist\n\t col.x  =  (sin(iTime* .32 * color_change_freq + lmp*brush_color_freq));\n\t col.y  =  (sin(iTime*.13 * color_change_freq + lmp*brush_color_freq));\n\t col.z  =  (sin(iTime*.62 * color_change_freq + lmp*brush_color_freq));\n\t\n\t// overpaint the buffer with some new input\n\t if (lmp < .4 ) {\n\t \t fragColor += vec4( col, 1. )*5. * (.4-lmp) ;\n\t }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 117, 294]], "test": "untested"}
{"id": "slySDV", "name": "GreenFreeze", "author": "AcChosen", "description": "Its green.", "tags": ["idk"], "likes": 1, "viewed": 178, "published": 3, "date": "1641348123", "time_retrieved": "2024-07-30T17:11:49.419631", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   // vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(0.0,1.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slySDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 265, 306]], "test": "untested"}
{"id": "7tyXWV", "name": "Distorted Particle Thing", "author": "SnoopethDuckDuck", "description": "really like this technique - press R to reset.\n\nBuffer A describes \"particle\" -> Buffer B draws based off \"particle\" position -> Image provides color", "tags": ["e"], "likes": 6, "viewed": 383, "published": 3, "date": "1641346972", "time_retrieved": "2024-07-30T17:11:51.782314", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n\n    vec3 e = vec3(1.);\n    vec3 col2 = 3. * x * pal(mix(0.3, 0.35, 0.5 + 0.5 * thc(2., iTime)), e, e, e, vec3(0., 0.33, 0.66));\n    fragColor = vec4(col2, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvec2 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;   \n    \n    // Replace 0.05, e.g. 0.1 -> more fluid-like\n    uv += 0.05 * iTime;\n    \n    ivec2 px = ivec2(fragCoord);\n    vec2 p = Cell(px);\n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        fragColor = vec4(0.);\n        p = vec2(0.5,0.5);\n    } \n    \n    // Distorted grid\n    vec2 ipos = floor(sc * uv);\n    \n    // Get random value with time\n    float spd = 1.;\n    float lh = h21(vec2(floor(spd * iTime)));\n    float nh = h21(vec2(floor(spd * iTime + 1.)));\n    float rand = mix(lh, nh, smoothstep(0., 1., fract(spd * iTime)));\n    \n    // Speed of particle (distance moved each frame)\n    // e.g. 30. -> more cube-like\n    float m = 4. / iResolution.y;\n    \n    // Angle of particle (remove h21() to see an actual particle)\n    float th = 0.5 * pi * cos(100. * h21(ipos) + 2. * iTime) + 2. * pi * rand;\n   \n    // Vector from angle\n    vec2 b = vec2(cos(th), sin(th));\n    \n    // New point (clamped)\n    vec2 p2 = p + m * b;\n    p2 = clamp(p2, vec2(0.1), vec2(0.9));\n    \n    fragColor = vec4(p2.xy, 0., 1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Collection of functions I use a lot:\n\n#define pi 3.14159\n#define sc 10.\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Get \"point\" from Buffer A\n    vec2 p = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xy - 0.5;\n    \n    // Distance from point + strength to smoothstep away from it\n    float d = length(uv-p);\n    float k = mix(0.1, 0.5, 0.5 + 0.5 * thc(3., 0.7 * iTime)) + d;\n\n    // Draw stuff\n    float s = smoothstep(-k, k, -d + 0.);\n    float x = texelFetch( iChannel1, ivec2(fragCoord), 0 ).x;\n    x = 0.95 * clamp(x, 0., 1.);\n    \n    fragColor = vec4(max(x, 2. * s));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 349]], "test": "untested"}
{"id": "flGSWV", "name": "Generalized Cantor set", "author": "NinjaKoala", "description": "Generalized cantor set. These share a lot of the properties of the cantor set\n(compact, nowhere dense, cardinality equal to the reals, etc)\nbut don't have measure zero except for p_0=1/3 (which is the usual cantor set)\n\nChange p_0 with mouse", "tags": ["2d", "fractal", "cantor", "smith", "volterra"], "likes": 3, "viewed": 227, "published": 3, "date": "1641346262", "time_retrieved": "2024-07-30T17:11:52.664954", "image_code": "//#define DISTANCE\n#define FILTER 2 //0: box, 1: tent, 2: lanczos\n\nconst int max_iterations=9;\n#ifndef DISTANCE\nconst int aa=32;\n#else\nconst int aa=1;\n#endif\n\nconst float pi=3.1415926535;\nconst float filter_radius=2.;\n\nfloat sinc(float x0){\n    if(x0==0.){\n        return 1.;\n    }\n    else{\n        return sin(pi*x0)/(pi*x0);\n    }\n}\n\nfloat lanczos(float x0, float a0){\n    if(abs(x0)<a0){\n        return sinc(x0)*sinc(x0/a0);\n    }\n    else{\n        return 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    float dis=1e38;\n    float border=1./iResolution.x;\n    \n    float col_sum=0.;\n    float weight_sum=0.;\n    for(int x=0;x<aa;x++){\n        float offset=float(x)/(float(aa)-1.)*2.*filter_radius-filter_radius;\n        \n        float aa_offset=offset/iResolution.x;\n        vec2 p1=uv+vec2(aa_offset,0);\n\n        int num_iterations=int((1.-p1.y)*float(max_iterations));\n\n        float col=0.;\n\n        float p_0=mix(1./3.,0.,mouse.x);\n        //float p_0=1./3.;\n        float q_0=(1.-p_0)/2.;\n\n        float p_n=p_0;\n        float q_n=q_0;\n        float m_n=.5;\n        for(int i=0;i<num_iterations;i++){\n            p1.x=abs(p1.x-m_n);\n            #ifdef DISTANCE\n            dis=min(dis,p1.x-p_n/2.);\n            #else\n            if(p1.x<p_n/2.){\n                col=1.;\n            }\n            #endif\n            m_n=(p_n+q_n)/2.;\n            p_n=q_n*p_0;\n            q_n=q_n*q_0;\n        }\n        #ifndef DISTANCE\n        #if FILTER == 0\n        col_sum+=col/float(aa);\n        weight_sum+=1./float(aa);\n        #elif FILTER == 1\n        col_sum+=col*(filter_radius-offset);\n        weight_sum+=(filter_radius-offset);\n        #else\n        col_sum+=col*lanczos(offset,filter_radius);\n        weight_sum+=lanczos(offset,filter_radius);\n        #endif\n        #endif\n    }\n    #ifdef DISTANCE\n    fragColor=vec4(1.-smoothstep(0.,border,dis));\n    #else\n    fragColor=vec4(pow(col_sum/weight_sum,1.0/2.2));\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 240, 240, 334], [336, 336, 370, 370, 470]], "test": "untested"}
{"id": "7lGSWV", "name": "bouncy ball", "author": "ArmandB", "description": "a ball that bounces when you pull it away from the center", "tags": ["buffers"], "likes": 4, "viewed": 274, "published": 3, "date": "1641340998", "time_retrieved": "2024-07-30T17:11:53.536624", "image_code": "float PointToLineSegment(vec2 a, vec2 b, vec2 p) {\n  float l2 = (b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y);\n  if (l2 == 0.0) return distance(p, a);\n  float t = max(0.0, min(1.0, dot(p - a, b - a) / l2));\n  vec2 projection = a + t * (b - a);\n  return distance(p, projection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.2,0.2,0.2);\n    \n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy/2.0)/iResolution.y;\n    float pxunit = 1.0/iResolution.y;\n\n    vec4 pos_and_vel = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    if (iMouse.z >= 0.0) {\n        col += vec3(1,0,0)*clamp((0.01-length(uv)+length(m)),0.0,1.0);\n    }\n    col = mix(col, vec3(1), 1.0-smoothstep(0.2,0.2+pxunit, length(uv-pos_and_vel.xy)));\n    col = mix(col, vec3(1,0.5,0), 1.0-smoothstep(0.01,0.01 + pxunit, PointToLineSegment(pos_and_vel.xy, pos_and_vel.xy + pos_and_vel.zw, uv)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(0,0)){\n        vec4 pos_and_vel = texelFetch(iChannel0, ivec2(0, 0), 0);\n        if (mod(float(iFrame), 60.0/fps) < 0.01){\n            if (pos_and_vel == vec4(0)){\n                pos_and_vel = vec4(0.5, 0.5, 0.1, 0.1);\n            }\n            if (sign(iMouse.z) == 1.0) {\n                vec2 m = iMouse.xy/iResolution.xy - 0.5;\n                m.x *= iResolution.x/iResolution.y;\n                pos_and_vel.xy = m;\n                pos_and_vel.zw = vec2(0);\n            } else {\n                vec2 pos = pos_and_vel.xy;\n                vec2 vel = pos_and_vel.zw;\n                vel = (vel - pos)/2.0;\n                pos += vel;\n\n                pos_and_vel = vec4(pos,vel);\n            }\n        }\n        col = pos_and_vel;\n    }\n    fragColor = vec4(col);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float fps = 60.0;\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 275], [277, 277, 334, 334, 996]], "test": "untested"}
{"id": "ftGSDV", "name": "The Exorcist", "author": "dean_the_coder", "description": "Recreating one of the movie posters from The Exorcist (1973).\n(Best viewed full-screen.)", "tags": ["3d", "raymarching", "bw", "character", "horror", "movie", "reproduction", "cineshader"], "likes": 107, "viewed": 7995, "published": 3, "date": "1641332670", "time_retrieved": "2024-07-30T17:11:54.754368", "image_code": "// 'The Exorcist' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ftGSDV (YouTube: https://youtu.be/NseO7v3iylU)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Recreating one of the movie posters from The Exorcist (1973).\n// (Best viewed full-screen.)\n//\n// Tricks to get the performance:\n//  - No 'max dist' check in main marching loop, as all\n//    primary rays will hit something.\n//  - Dedicated marching loop for the spotlight effect\n//    (avoiding adding overhead to the main scene when\n//    calculating normals, shadows, etc).\n//  - The man is 2D (with very subtle animation), and\n//    mostly rounded boxes.\n//  - Lots of axis folding(/reflection).\n//    There's only one window, one brick pillar, one\n//    fence rail, one window shutter, ...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA\t// Disable this line for extra performance.\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t,\n      fade = 1.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(.45, .2);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p) {\n\tp.x -= clamp(p.x, 0., 10.);\n\treturn length(p) - .1;\n}\n\nfloat tor(vec3 p) {\n\tconst vec2 t = vec2(.24, .05);\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nvec3 rayDir(vec2 uv) {\n\tvec3 r = normalize(cross(vec3(0, 1, 0), vec3(0, 0, 1)));\n\treturn normalize(vec3(0, 0, 1.5) + r * uv.x + cross(vec3(0, 0, 1), r) * uv.y);\n}\n\nvec3 toWorld(vec3 p) {\n\tp.yz *= mat2(.99875, .04998, -.04998, .99875);\n\tp.y += 1.2;\n\tp.xz -= vec2(2.1875, 17);\n\tp.xz *= mat2(.96891, .2474, -.2474, .96891);\n\treturn p;\n}\n\nfloat beam(vec3 p) {\n\tp -= vec3(-15, 16.4, 42);\n\tp.xy += p.z * vec2(.49, -.44);\n\treturn min(p.z + 62.4, box(p, vec3(2, 3.5, 50)));\n}\n\nHit map(vec3 p) {\n\tp = toWorld(p);\n\n\t// Lamp.\n\tvec3 q = p + vec3(3.9, 1.9, 2);\n\tfloat l = length(q.xz),\n\t      d = l - .2 + .01 * p.y;\n\td = smin(d, cyl(q) - .05, .5);\n\tq.y = abs(q.y - .8) - .25;\n\td = min(d, tor(q));\n\tHit h = Hit(d, 8, q);\n\n\t// Pavement.\n\td = min(max(p.y + 2.1, p.z), box(p + vec3(0, 2, 1.8), vec3(99, .1, 1.8)));\n\tminH(d, 1, p);\n\n\t// Fence walls. (mirror x)\n\tq = p;\n\tq.x = abs(q.x + .8) - 11.;\n\td = box(q - vec3(0, -.5, 0), vec3(8, .15, .4));\n\tminH(d, 4, q);\n\td = cap(q + vec3(7.5, -.5, 0));\n\tminH(d, 9, q);\n\td = box(q - vec3(0, -1.4, 0), vec3(8, .75, .2));\n\n\t// Pillars.\n\tq.x = abs(p.x) - 4.;\n\tif (p.x > 0.) q.x = abs(q.x) - 1.4; // Make right-most pillar.\n\td = min(d, box(q, vec3(.5, 2, .5))); // Driveway pillars.\n\td = min(d, box(q - vec3(0, 1.6, 0), vec3(.55, .1, .55)));\n\tminH(d, 3, q);\n\n\t// Pillar tops.\n\tif (p.x < 4.) {\n\t\tq.y -= 2.6;\n\t\tl = length(q);\n\t\tfloat f = max(l - .5, q.y);\n\t\td = f < d ? smin(d, f, .25) : f;\n\t\td = smin(d, l - .35, .1);\n\t\tminH(d, 4, q);\n\t}\n\n\t// House.\n\td = min(box(p - vec3(12.5, 0, 24), vec3(5, 25, 18)), 42.1 - p.z);\n\n\t// 90 degree fold to make windows appear on both walls.\n\tq = p - vec3(7.5, 0, 42);\n\tif (q.x > q.z) {\n\t\tq.xz = q.zx;\n\t\tq.x += 3.;\n\t}\n\n\t// Windows.\n\tq.xy += vec2(15.75, -9.3);\n\tq.xy = abs(abs(q.xy) - 7.25);\n\td = max(d, -box(q, vec3(2.7, 5.2, 2)));\n\tminH(d, 3, q);\n\tq.z -= .7;\n\td = box(q, vec3(2.7, 5.2, .2));\n\tminH(d + .1, 6, q);\n\tminH(box(q - vec3(4, 0, 0), vec3(1.25, 5.2, 1)), 7, q);\n\tq.x = abs(q.x - 1.25) - .6;\n\tq.y = abs(abs(q.y) - 2.5) - 1.2;\n\td = max(d, -box(q, vec3(.45, 1, 1.2)));\n\tminH(d, 5, q);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - vec3(-7.5, 6.5, 25));\n\tvec3 ld = normalize(vec3(-7.5, 6.5, 25) - p);\n\tfor (float i = Z0; i < 30.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nbool puddle(vec3 p) { return p.z > -3.4 && step(.45, n21(p.xz * 2.) + .13) < .5; }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tfloat c;\n\tvec3 ld = normalize(vec3(-7.5, 6.5, 25) - p);\n\tvec2 spe = vec2(10, 1);\n\tif (h.id == 3) {\n\t\th.p.x += .1;\n\t\tc = .02 + max2(S(.04, 0., abs(fract(vec2(h.p.y * 2., h.p.x + .5 * step(.5, fract(h.p.y - .25)))) - .5))) * .06;\n\t}\n\telse if (h.id == 1) {\n\t\tfloat f = step(h.p.z, -3.61);\n\t\tc = mix(.1, .01, f) + .1 * step(h.p.z + 3.2, 0.) * S01(abs(fract(h.p.x * .3) - .5) * 60. + f);\n\t\tif (f > .5) {\n\t\t\tf = step(.66, abs(fbm(h.p * 20.)));\n\t\t\tspe.y = 5.5 * f;\n\t\t\tc += .3 * f;\n\t\t}\n\t}\n\telse if (h.id == 7) {\n\t\tc = .15;\n\t\tc *= .2 + .8 * S01(4. * abs(fract(h.p.y * 3.15) - .5));\n\t}\n\telse if (h.id == 6) c = mix(.008, S(25., 0., length(p.xy - vec2(-20, 10))), step(p.x, -3.));\n\telse if (h.id == 4) c = .25;\n\telse if (h.id == 8) {\n\t\tc = .6;\n\t\tspe = vec2(50, 30);\n\t}\n\telse c = .15; // Rails, window frame\n\treturn mix((sat(.1 + .9 * dot(ld, n)) + (sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y)) * (.1 + .9 * shadow(p)) * mix(aof(p, n, .2), aof(p, n, 2.), .7) * c, 1., S(.7, 1., 1. + dot(rd, n)) * .01) * vec3(.4, .32, .28);\n}\n\nvec3 scene(vec3 rd, vec2 uv) {\n\tt = mod(iTime, 30.);\n\tfade = min(1., abs(t));\n\n\t// March the scene.\n\tfloat i, od, g, f, man,\n\t      d = 0.;\n\tvec3 op, n, col,\n\t     p = vec3(0);\n\tHit h;\n\tfor (i = Z0; i < 80.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp = d * rd;\n\t}\n\n\tod = d;\n\top = p;\n\tn = N(p, d);\n\tcol = lights(p, rd, n, h);\n\n\t// Make puddles reflective.\n\tif (h.id == 1 && puddle(h.p)) {\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\td = 0.;\n\t\tfor (i = Z0; i < 50.; i++) {\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += .005 + .9 * lights(p, rd, N(p, d), h);\n\t}\n\n\t// March the spotlight.\n\tg = 0.;\n\td = 0.;\n\tp = vec3(0);\n\tfor (i = Z0; i < 80.; i++) {\n\t\tvec3 q = toWorld(p);\n\t\tfloat sdf = beam(q) + (h31(q) - .5) * .3;\n\t\tg += .5 / (.01 + pow(abs(sdf), 1. + 4. * S(-80., 125., q.z)));\n\t\td += sdf;\n\t\tif (d >= od) break;\n\t\tp = d * rd;\n\t}\n\n\t// Add fog.\n\tf = fbm(rd * 8. + t * vec3(.05, -.07, .2));\n\tcol = mix(col, vec3(4, 3.2, 2.8), sat(g) * f * .3 * S(26.5, 60., op.z));\n\n\t// Man.\n\tuv -= vec2(.175, .059);\n\tuv.x += (uv.y + .5) * (uv.y + .5) * sin(t) * .01;\n\tvec2 tuv = uv;\n\tuv *= mat2(.90045, -.43497, .43497, .90045);\n\tman = step(.1, step(0., length(uv + vec2(0, .1122)) - .12) + step(0., length(uv - vec2(0, .1122)) - .12));\n\n\t// Hat.\n\tf = step(0., box2d(uv, vec2(.014 - .2 * uv.y, .024 + .01 * sin(abs(uv.x) * 8.))) - .01) + step(uv.y, 0.);\n\tman *= step(.1, f);\n\n\t// Face.\n\tuv *= mat2(.995, .09983, -.09983, .995);\n\tf = step(0., box2d(uv, vec2(.019 + .3 * uv.y, .032)) - .007) + step(0., uv.y);\n\tman *= step(.1, f);\n\n\t// Collar.\n\ttuv += vec2(.004, .03);\n\tman *= step(0., box2d(tuv, vec2(.02 - .3 * tuv.y, .01)));\n\n\t// Torso.\n\ttuv += vec2(.005, .104);\n\ttuv *= mat2(.995, -.09983, .09983, .995);\n\tman *= step(0., box2d(tuv, vec2(.07 - .2 * tuv.y + sin(tuv.y * 18.) * .01, .099 - .3 * abs(tuv.x))) - .005);\n\n\t// Hands.\n\ttuv.x = abs(tuv.x);\n\ttuv *= mat2(.96891, .2474, -.2474, .96891);\n\ttuv += vec2(-.033, .095);\n\tman *= step(0., box2d(tuv, vec2(.01 + .05 * tuv.y, .01)) - .008);\n\n\t// Briefcase.\n\ttuv = uv + vec2(-.01, .293);\n\ttuv *= mat2(.95534, .29552, -.29552, .95534);\n\tman *= step(0., box2d(tuv, vec2(.034 - .05 * tuv.y, .04 + .05 * tuv.x)) - .005);\n\tman *= step(0., box2d(tuv - vec2(.014, .054), vec2(.01, .005)) - .003);\n\n\t// Jacket bottom.\n\tman *= step(0., box2d(tuv - vec2(.074, .02), vec2(.05, .046)) - .003);\n\n\t// Legs.\n\ttuv -= vec2(.053, -.08);\n\ttuv *= mat2(.99875, .04998, -.04998, .99875);\n\tman *= step(0., box2d(tuv, vec2(.016 + (sin(tuv.y * 80. - 2.25) - tuv.y * 40.) * mix(5e-4, .0015, step(0., tuv.x)), .06)) - .004);\n\ttuv -= vec2(.055, .01);\n\ttuv *= mat2(.99875, .04998, -.04998, .99875);\n\tman *= step(0., box2d(tuv, vec2(.016 + (sin(tuv.y * 60.) - tuv.y * 40.) * mix(5e-4, .0015, step(0., tuv.x)), .065)) - .004);\n\tif (tuv.y > -.06) col *= man;\n\treturn col;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0)\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 col = scene(rayDir(uv), uv);\n#ifdef AA\n\tif (fwidth(col.r) > .01) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++) {\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += scene(rayDir(uv + (vec2(dx, dy) - .5) / R.xy), uv + (vec2(dx, dy) - .5) / R.xy);\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n\n#endif\n\tcol += .003 * h21(fc);\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGSDV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1458, 1458, 1478, 1478, 1575], [1577, 1577, 1596, 1596, 1617], [1619, 1619, 1638, 1638, 1979], [1981, 1981, 2000, 2000, 2026], [2028, 2028, 2047, 2047, 2174], [2176, 2176, 2215, 2215, 2297], [2299, 2299, 2319, 2319, 2343], [2345, 2345, 2365, 2365, 2399], [2401, 2401, 2430, 2430, 2501], [2503, 2503, 2530, 2530, 2601], [2603, 2603, 2622, 2622, 2733], [2735, 2735, 2754, 2754, 2809], [2811, 2811, 2830, 2830, 2930], [2932, 2932, 2954, 2954, 3094], [3096, 3096, 3118, 3118, 3265], [3267, 3267, 3287, 3287, 3399], [3401, 3401, 3418, 3418, 4987], [4989, 4989, 5014, 5014, 5233], [5235, 5235, 5257, 5257, 5558], [5560, 5588, 5624, 5624, 5660], [5662, 5662, 5683, 5683, 5744], [5746, 5746, 5791, 5791, 6858], [6860, 6860, 6890, 6890, 9738], [9809, 9809, 9854, 9854, 10306]], "test": "untested"}
{"id": "NtGXDV", "name": "growing circles color", "author": "avin", "description": "growing circles", "tags": ["circles", "radial"], "likes": 7, "viewed": 288, "published": 3, "date": "1641332372", "time_retrieved": "2024-07-30T17:11:55.646981", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;     \n    \n    float l = length(uv);\n    \n    float t = iTime * 2.;\n    float id = floor(l*10. - t)/10.;            \n    float coutour = .7 + smoothstep(.0, .25 ,fract(l*10. - t))*.3;    \n           \n    vec3 col = (hue(id*1.25).rgb) * (1. - l*.5) * vec3(coutour);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 486]], "test": "untested"}
{"id": "NtySWV", "name": "another 2d drawing", "author": "jorge2017a2", "description": "another 2d drawing", "tags": ["another2ddrawing"], "likes": 3, "viewed": 195, "published": 3, "date": "1641329589", "time_retrieved": "2024-07-30T17:11:56.651296", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 FiguraUno(vec2 p, vec3 col)\n{   vec2 p0=p;\n    float d0= sdCircle( p-vec2(0.0,1.3), 1.0 )    ;\n    float d1=sdBox(p-vec2(0.0,0.0), vec2(1.0,1.5) );\n    \n    //ojo \n    float d2a= sdCircle( p-vec2(0.0,0.9), 0.8 );\n    float d2b= sdCircle( p-vec2(0.0,0.9), 0.75 );\n    float d2c= sdCircle( p-vec2(0.0,0.9), 0.4 );\n    float d2d= sdBox(p-vec2(0.0,0.3), vec2(1.0,0.5) );\n    d2a=differenceSDF(d2a,d2d);\n    d2b=differenceSDF(d2b,d2d);\n    d2c=differenceSDF(d2c,d2d);\n    \n    vec2 p3=Rotate(p-vec2(1.,0.0), vec2(-1.0,0.0), radians(45.0*sin(iTime)) );\n    float d3a=sdBox(p3-vec2(0.5,0.0), vec2(2.0,0.5) );\n    float d3b= sdTriangleIsosceles(p3-vec2(-1.0,-1.0), vec2(0.5,0.7) );\n    float d3c= sdTriangleIsosceles(p3-vec2(-0.2,-1.3), vec2(0.45,1.0) );\n    float d3d= sdTriangleIsosceles(p3-vec2(0.5,-0.8), vec2(0.45,0.5) );\n    float d3e= sdTriangleIsosceles(p3-vec2(1.3,-1.5), vec2(0.45,1.2) );\n    float d3f= sdTriangleIsosceles(p3-vec2(2.0,-1.8), vec2(0.25,1.5) );\n    \n    float d3g= sdCircle( p3-vec2(-0.3,0.1), 0.25 );\n    float d3h= sdCircle( p3-vec2(-1.0,0.1), 0.15 );\n    \n    d0= unionSDF(d0, d1);\n    \n    float d4a=sdBox(p-vec2(0.0,-2.5), vec2(0.5,1.0) );\n    col= DrawFigBorde(vec3(1.0,0.5,0.8), col,d4a );\n    col= DrawFigBorde(vec3(1.0,0.5,0.3), col,d0 );\n    \n    //ojo\n    col= DrawFigBorde(vec3(0.0), col,d2a );\n    col= DrawFigBorde(vec3(1.0), col,d2b );\n    col= DrawFigBorde(vec3(0.0), col,d2c );\n    col= DrawFigBorde(vec3(0.5,0.5,0.3), col,d3a);\n    col= DrawFigBorde(vec3(1.0), col,d3b);\n    col= DrawFigBorde(vec3(1.0), col,d3c);\n    col= DrawFigBorde(vec3(1.0), col,d3d);\n    col= DrawFigBorde(vec3(1.0), col,d3e);\n    col= DrawFigBorde(vec3(1.0), col,d3f);\n    col= DrawFigBorde(vec3(0.5,0.6,0.4), col,d3g);\n    col= DrawFigBorde(vec3(0.8,0.6,0.4), col,d3h);    \n    return col;\n}\n\nvec3 HacerPuerta(vec2 p, vec3 col)\n{   vec2 p0=p;\n    p.y-=1.5;\n    float d0= sdCircle(p-vec2(0.0,1.3), 1.0 )    ;\n    float d1=sdBox(p-vec2(0.0,0.5), vec2(1.0,1.0) );\n    float d1a=sdBox(p-vec2(0.0,0.5), vec2(0.05,1.0) );\n    p=p0;\n    float r1, r2,he ;\n    r1=3.5;\n    r2=1.0;\n    he=1.5;\n    float d2= sdTrapezoid( p,r1,r2,he);\n    col= DrawFigBorde(vec3(0.5), col,d0);\n    col= DrawFigBorde(vec3(0.5), col,d1);\n    col= DrawFigBorde(vec3(0.0), col,d1a);\n    col= DrawFigBorde(vec3(0.3,0.3,0.3), col,d2);\n    return col;\n}\n    \n    \nvec3 HacerChico(vec2 p, vec3 col)\n{   vec2 p0=p;    \n    //cabeza\n    float d1a= sdCircle( p-vec2(0.0,0.9), 0.5 );\n    //ojo\n    p.x=abs(p.x)-0.2;\n    float d1b= sdCircle( p-vec2(0.0,0.9), 0.1 );\n    //boca\n    p=p0;\n    float d2a= sdCircle( p-vec2(0.0,0.7), 0.2 );\n    float d2b=sdBox(p-vec2(0.0,0.9), vec2(0.27,0.2) );\n    d2a=differenceSDF(d2a,d2b);\n    \n    //sombrero\n    float d3a= sdTriangleIsosceles(vec2(p.x, -p.y)-vec2(0.0,-2.0), vec2(0.7,0.8) );\n    //pansa\n    float d4a=sdBox(p-vec2(0.0,-0.3), vec2(0.5,0.7) );\n    \n    \n    p.y+=0.8;\n    p.x-=0.2;\n    //brazo izq\n    vec2 v0A = vec2(-0.8,0.9);\n    vec2 v1A = vec2(-1.3,0.9);\n    vec2 v2A = vec2(-0.5,-0.3);\n    float b1 =abs( sdBezier( p, v0A,v1A,v2A ))-0.08; \n    \n    p.x=p0.x+0.25;\n    //brazo der\n    vec2 v0B = vec2(0.5,0.9);\n    vec2 v1B = vec2(1.3,0.5);\n    vec2 v2B = vec2(1.4,1.8);\n    float b2 =abs( sdBezier( p-vec2(0.3,0.2), v0B,v1B,v2B ))-0.08; \n    \n    //pierna\n    p.y+=0.8;\n    p.x-=0.8;\n    vec2 v0C = vec2(-0.8,0.9);\n    vec2 v1C = vec2(0.0,0.9);\n    vec2 v2C = vec2(-0.5,-0.3);\n    float b3 =abs( sdBezier( p, v0C,v1C,v2C ))-0.08; \n    \n    //pierna\n    p=p0;\n    p.y+=1.7;\n    p.x-=1.2;\n    vec2 v0D = vec2(-0.8,0.9);\n    vec2 v1D = vec2(0.0,0.9);\n    vec2 v2D = vec2(-0.5,-0.3);\n    float b4 =abs( sdBezier( p, v0D,v1D,v2D ))-0.08; \n    \n    col= DrawFigBorde(vec3(0.5), col,abs(d1a));\n    col= DrawFigBorde(vec3(0.0), col,d1b);\n    col= DrawFigBorde(vec3(0.0), col,d2a);\n    col= DrawFigBorde(vec3(0.0), col,abs(d3a)-0.03);\n    col= DrawFigBorde(vec3(0.0), col,abs(d4a)-0.01);\n    col= DrawFigBorde(vec3(0.0), col, b1+0.05 );\n    col= DrawFigBorde(vec3(0.0), col, b2+0.05 );\n    col= DrawFigBorde(vec3(0.0), col, b3+0.05 );\n    col= DrawFigBorde(vec3(0.0), col, b4+0.05 );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=3.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(0.0,0.1,0.8);\n    \n    col=pow(col,  vec3(0.554545));\n    col= HacerPuerta(uv-vec2(0.0,0.7),col);\n    col= HacerChico(uv-vec2(-1.0,0.2),col);\n    uv.y-=2.0;\n    col= FiguraUno(uv-vec2(-4.0,0.0), col);\n    col= FiguraUno(vec2(-uv.x,uv.y)-vec2(-4.0,0.0), col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//https://www.shadertoy.com/view/MlKcDD\n//referencia Iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=(q+4p)=q(1+4p/q)=q(1+w) instead. Now we approximate\n        //  by a linear Taylor expansion into hq(1+w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p/q,-p/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p/q)p/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtySWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 338, 338, 383], [389, 389, 436, 436, 463], [464, 464, 507, 507, 534], [535, 535, 583, 583, 611], [614, 614, 686, 686, 812], [814, 814, 876, 876, 1006], [1008, 1008, 1089, 1089, 1217], [1219, 1219, 1276, 1276, 1346], [1348, 1348, 1410, 1410, 1475], [1477, 1477, 1545, 1545, 1613], [1615, 1615, 1679, 1679, 1750], [1753, 1769, 1817, 1817, 1895], [1898, 1898, 1932, 1932, 2028], [2029, 2029, 2063, 2063, 2154], [2155, 2155, 2189, 2189, 2280], [2281, 2281, 2315, 2315, 2410], [2412, 2412, 2449, 2449, 2523], [2525, 2525, 2560, 2560, 2583], [2585, 2585, 2637, 2637, 2753], [2755, 2802, 2827, 2827, 2846], [2847, 2847, 2883, 2883, 2911], [2914, 2914, 2979, 2979, 3289], [3293, 3293, 3344, 3344, 3652], [3654, 3654, 3688, 3688, 5461], [5463, 5463, 5499, 5499, 5988], [5999, 5999, 6034, 6034, 7777], [7779, 7779, 7836, 7836, 8318]], "test": "untested"}
{"id": "7lVXDy", "name": "Fork Neon Balls - Production Ti", "author": "tiagonicastro", "description": "Neon effect (simple additive-composition)", "tags": ["2d"], "likes": 7, "viewed": 432, "published": 3, "date": "1641319562", "time_retrieved": "2024-07-30T17:11:57.556875", "image_code": "float stepping(float t){\n    if(t<0.)return -1.+pow(1.+t,2.);\n    else return 1.-pow(1.-t,2.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    uv = normalize(uv) * length(uv);\n    for(int i=0;i<12;i++){\n        float t = iTime + float(i)*3.141592/12.*(5.+1.*stepping(sin(iTime*3.)));\n        vec2 p = vec2(cos(t),sin(t));\n        p *= cos(iTime + float(i)*3.141592*cos(iTime/8.));\n        vec3 col = cos(vec3(0,1,-1)*3.141592*2./3.+3.141925*(iTime/2.+float(i)/5.)) * 0.5 + 0.5;\n        fragColor += vec4(0.05/length(uv-p*0.9)*col,1.0);\n    }\n    fragColor.xyz = pow(fragColor.xyz,vec3(3.));\n    fragColor.w = 1.0;\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 96], [97, 97, 154, 154, 712]], "test": "untested"}
{"id": "7tVSDy", "name": "Speed of Light: 10m/s", "author": "incription", "description": "the distance field moves in time as well. The step size is reduced in half to help any temporal anomalies (where v > dS). I attempted adding doppler shifting but I don't know how to make it shift down as well as up. Help appreciated. Mouse: move and pause", "tags": ["raymarching", "light", "c"], "likes": 5, "viewed": 252, "published": 3, "date": "1641318927", "time_retrieved": "2024-07-30T17:11:58.646960", "image_code": "// \"ShaderToy Tutorial - Ray Marching Operators 2\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This is the starting point for a YouTube tutorial:\n// https://youtu.be/Vmb7VGBVZJA\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define C 10.\n#define BOXSPEED 5.\n\n#define PI 3.14159\n\nvec4 GetDist(vec3 p, float t) {\n    float plane = p.y;\n    \n    // d(cos(t)*10)/dt\n    vec3 v = vec3(-sin(t)*BOXSPEED, 0, 0);\n    float box = sdBox(p-vec3(cos(t)*BOXSPEED, 1, -3), vec3(1));\n    \n    float rotationalSpeed = 0.7;\n    float rotational = rotationalSpeed * t * PI * 2.;\n    vec3 rbp = p-vec3(0,1,0);\n         rbp.xz *= Rot(rotational);\n    float rotatingBox = sdBox(rbp, vec3(1));\n    \n    float speedBoxSpeed = C * 0.99;\n    float speedBox = sdBox(p - vec3(C * 10. - speedBoxSpeed * t, 3, -5), vec3(1));\n   \n    //The plane is not moving\n    if(plane < box) v = vec3(0);\n    \n    //The rotating box is only moving rotationally, so we calculate it by revs * r\n    if(rotatingBox < plane && rotatingBox < box) { float _ = rotationalSpeed * 1.;\n                            v = vec3(sin(rotational) * _, 0, cos(rotational) * _); }\n                            \n    if(speedBox < rotatingBox) vec3(speedBoxSpeed, 0., 0.);\n                            \n    float d = min(plane, box);\n          d = min(d, rotatingBox);\n          d = min(d, speedBox);\n    return vec4(d, v);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float t) {\n\tfloat dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, t).x / 2.;\n        dO += dS;\n        if(iMouse.z < .5) t -= dS / C;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, t);\n}\n\nvec3 GetNormal(vec3 p, float t) {\n\tfloat d = GetDist(p, t).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, t).x,\n        GetDist(p-e.yxy, t).x,\n        GetDist(p-e.yyx, t).x);\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, float t) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p, t);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l, t).x;\n   // if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 light(float l) {\n    vec3 i = vec3(0);\n    for(float w=400.;w<800.;w+=400./1.) {\n        i += spectral_zucconi(w * l);\n    }\n    return i / 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0., 4, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 v = vec3(cos(iTime), 0., 0.);\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec2 r = RayMarch(ro, rd, iTime);\n    float d = r.x;\n    float t = r.y;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p, t);\n    \tcol = vec3(dif);\n        \n        vec3 vreal = v - GetDist(p, t).yzw;\n        float v = length(vreal);\n        float l = length(1. / sqrt(1. - ((v * v) / (C * C))));\n        \n        if(iMouse.z > .5) l = 1.;\n        col *= spectral_zucconi(550.*l);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "mat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVSDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[411, 411, 442, 442, 1491], [1493, 1493, 1535, 1535, 1801], [1803, 1803, 1836, 1836, 2046], [2048, 2048, 2081, 2081, 2361], [2363, 2363, 2405, 2405, 2600], [2602, 2602, 2623, 2623, 2753], [2755, 2755, 2812, 2812, 3646]], "test": "untested"}
{"id": "stKXDy", "name": "Hans Solo's Dream", "author": "xenn", "description": "Basic Kleinian group limit set with fully dynamic GI (+ temporal reprojection denoising and some weird hacky thing where I try to accumulate encoded lighting data from neighboring pixels) plus a bunch of very superfluous postprocess effects. ", "tags": ["3d", "raymarching", "fractal", "math", "gi", "global", "dof", "bokeh", "pathtracing", "kleinian", "montecarlo", "apollonian"], "likes": 9, "viewed": 410, "published": 3, "date": "1641317276", "time_retrieved": "2024-07-30T17:11:59.971419", "image_code": "// Fork of \"Kleinian Landdrape\" by xenn. https://shadertoy.com/view/NtKSRK\n// 2022-01-04 17:27:29\n\n// Fork of \"Kleinian Landscape\" by amoser. https://shadertoy.com/view/WttBRr\n// 2022-01-01 13:05:44\n\n// Final post-processing\n// \n\n// Sample scene color with FXAA, 0-1 range uvs\nvec4 sceneColor(vec2 uv)\n{\n    vec4 outColor = vec4(FXAA(uv, iChannel1, 1.0/iResolution.xy), 1.0);\n    \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvAspectCorrected = uv - 0.5;\n    uvAspectCorrected = vec2(uvAspectCorrected.x*(iResolution.x/iResolution.y), uvAspectCorrected.y);\n    uvAspectCorrected += 0.5;\n    \n    // Fringe\n\tconst int fringeSamples = 6;\n    float fringeAmount = fringeStrength*saturate(distance(uvAspectCorrected, vec2(0.5))-fringeStart);\n\n    vec4 outColor = vec4(0);\n\n    if(fringeAmount > 0.0)\n    {\n        for(int i = 0; i < fringeSamples; i++)\n        {\n            float fringe = 1.0+(float(i-fringeSamples/2)*fringeAmount)/float(fringeSamples);\n            outColor += vec4(sceneColor(((uv-0.5)*fringe + 0.5)))*HUE(mod(0.85-1.0*float(i)/float(fringeSamples), 1.0));\n        }\n        outColor /= float(fringeSamples)*0.6;\n    }\n    else\n    {\n        outColor = vec4(sceneColor(uv));\n    }\n\n    \n    // Vignette\n    outColor *= pow(saturate(1.25-1.5*distance(uv, vec2(0.5))), 0.9);\n    outColor += 0.001*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    // Saturation / discolor highlights\n    outColor = mix(outColor, vec4(1, 1, 0.66, 1)*vec4(dot(outColor.rgb, luma)), 1.0-saturate(1.05-dot(outColor.rgb, luma))); \n    \n    // Saturation / discolor shadows\n    outColor = mix(outColor, vec4(0.6, 0.8, 1, 1)*vec4(dot(outColor.rgb, luma)), saturate(0.3-3.0*dot(outColor.rgb, luma))); \n    \n    // Tonemap + color grade\n   \toutColor = toneMap(outColor, vec3(0.95,0.95,0.85), vec3(1.15, 1.3, 1.3));\n    \n    // Ungraded tonemap\n    outColor = toneMap(outColor, vec3(1), vec3(1));\n    \n    fragColor = pow(outColor, vec4(1.0/gamma));\n    \n    // For debugging depth\n    //fragColor = vec4(1.0-UDEPTH(fragCoord)*maxDepth);\n    // For debugging GI\n\t//fragColor = textureLod(iChannel0, uv, 0.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"FMS_Cat @ Shader Royale #1\" by FMS_Cat. https://shadertoy.com/view/wsccWj\n// 2021-07-20 03:21:18\n\n// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// There are several artifacts that is difficult to ignore :(\n\n\n#define BEAT (time*138.0/60.0)\n//#define PI 3.14159265\n#define time iTime * 0.1\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.25,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat seed;\n\nfloat fractsin(float v)\n{\n  return fract(sin(v*1021.445)*34.59);\n}\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\nvec3 randsphere()\n{\n  float t=PI*2.*rand();\n  float p=acos(rand()*2.-1.);\n  return vec3(sin(p)*sin(t),cos(p),sin(p)*cos(t));\n}\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\nfloat sdbox(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n// ======= map!!!!!!!!!! ====================================\nvec4 map(vec3 p)\n{\n  vec3 pt=p;\n  vec3 haha=lofi(pt,5.0);\n  float scrphase=mod(999.9*fractsin(haha.y+haha.z+3.88),PI*2.0);\n  float scr=(mod(haha.y+haha.z,2.0)*2.0-1.0)*20.0*smoothstep(-0.5,0.5,sin(time*0.5+scrphase));\n  pt.x+=scr;\n  haha=lofi(pt,5.0);\n  float phase=BEAT/(6.0+(.020*sin(iTime)));\n  phase+=dot(haha,vec3(2.75,.625,1.625));\n  phase=easeceil(phase,-11.0);\n  pt=mod(pt,5.0)-2.5;\n  vec3 pm=pt;\n  pt.yz=rot2d(.5*PI*phase+.25*PI)*pt.yz;\n  float clampBox=sdbox(pt,vec3(2.25,1.5,1.8));\n  pt=ifs(pt,vec3(3.6,3.0+0.4*phase,3.1),vec3(3.0,2.3,3.5));\n  pt=mod(pt-.5,1.)-.5;\n  float dist=sdbox(pt,vec3(.17));\n  dist=max(dist,clampBox);\n  return vec4(\n    dist,\n    sin(PI*fract(phase)),\n    step(0.0,0.01-abs(pt.x+pt.y)),\n    abs(pm.x)+abs(pm.y)+abs(pm.z)\n  );\n}\n\nvec3 normalFunc(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx).x-map(p-d.yxx).x,\n    map(p+d.xyx).x-map(p-d.xyx).x,\n    map(p+d.xxy).x-map(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n)\n{\n  float accum=0.;\n  for(int i=0;i<32;i++){\n    vec3 d=(0.02+0.02*float(i))*randsphere();\n    d=dot(d,n)<.0?-d:d;\n    //accum+=step(map(p+d).x,0.0)/64.0;\n    accum+=linearstep(0.12,0.0,map(p+d).x)/64.0;\n  }\n  return 1.0-sqrt(saturate(6.0*accum));\n}\n\nvec2 glitch(vec2 v)\n{\n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-30.0*mod(BEAT,8.0))-0.1)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  o=vec4(0,0,0,1);\n  seed=texture(iChannel0,p).x;\n  seed+=time;\n  \n  vec2 po=p;\n  p=glitch(p);\n  \n  vec3 ro=vec3(4.0*time,0,lofi(BEAT,8.0));\n  vec3 rd=vec3(p,-1);\n  rd.z+=0.6*length(p);\n  float camphase=lofi(BEAT,8.0)+mod(BEAT,8.0)*0.005;\n  rd.yz=rot2d(0.33*camphase+0.03*sin(3.0*time))*rd.yz;\n  rd.zx=rot2d(0.78*camphase+0.03*cos(3.0*time))*rd.zx;\n  rd.xy=rot2d(0.048*camphase)*rd.xy;\n  rd=normalize(rd);\n  vec3 fp=ro+rd*5.0;\n  ro+=0.002*randsphere();\n  rd=normalize(fp-ro);\n  \n  vec4 dist;\n  float rl=0.01;\n  float glow=10.0;\n  vec3 rp=ro+rl*rd;\n  for(int i=0;i<33;i++){ // nice\n    dist=map(rp);\n    glow=dist.y;\n    rl+=dist.x*0.7;\n    rp=ro+rl*rd;\n  }\n  \n  float fog=exp(-0.1*max(0.,rl-5.0));\n  o.xyz+=(1.0-fog)*vec3(1.);\n  \n  vec3 n2=normalFunc(rp,vec2(0.0,1E-2+4E-2*dist.y));\n  vec3 n=normalFunc(rp,vec2(0.0,2E-3));\n  float edge=saturate(length(n-n2));\n  float gorge=dist.z;\n\n  o.xyz+=fog*0.01*vec3(15.0,1.0,1.5)*glow;\n  \n  if(dist.x<1E-3)\n  {\n    float ao=aoFunc(rp,n);\n    o.xyz+=fog*vec3((0.4-0.1*gorge)*ao);\n    o.xyz+=fog*edge*dist.y*vec3(15.0,1.0,1.5);\n    //o.xyz+=fog*gorge*vec3(2.0,15.0,5.0)*exp(-10.0*mod(time+dist.w,1.0));\n  }\n  \n  o.xyz+=length(p-po)*2.0*sin(3.0+4.0*o.x+vec3(0.0,2.0,4.0));\n  o.xyz=pow(o.xyz,vec3(0.4545));\n  o.xyz-=0.2*length(p);\n  o.xyz=vec3(\n    smoothstep(0.1,0.9,o.x),\n    linearstep(0.0,0.8,o.y),\n    smoothstep(-0.2,1.1,o.z)\n  );\n  o.xyz*=1.0+0.1*sin(vec3(0.,1.,2.)+fragCoord.y*2.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Kleinian Landscape\n//\n// Except where otherwise specified or cited, all work is my own and available under\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Constants, helper functions\n// \n\n#define CLAMP_INDIRECT\n#define ANIMATE_CAMERA\n#define ANIMATE_SUN\n#define INTERACTIVE\n#define ROUGHNESS_MAP\n#define INDIRECT_GATHER_CHECK_DIRECTION\n\n\n////////// GENERAL\n\n#define PI 3.1415926536\n\nconst float gamma = 2.2;\n\n// Dynamic range; keep as low as possible since these buffers are packed with very low precision\nconst float hdrScale = 2.0;\nconst float depthScale = 1.;\nconst float maxDepth = 2.0;\nconst float depthDistributionExponent = 1.0;\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\nconst float goldenAngle = 2.4;\n\n#ifdef TEMPORAL_JITTER\n\tconst float AAjitter = 1.0;\n#else\n\tconst float AAjitter = 0.0;\n#endif\n\nfloat saturate(float a)\n{\n    return clamp(a, 0.0, 1.0);\n}\n\n// from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// from Fabrice Neyret\n#define ROT(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define HUE(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0) ) )\n\n\n\n// Buffer unpacking\n#define UBOUNCE_COLOR(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).y))\n#define UBOUNCE_POSITION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).z))\n#define UBOUNCE_LIGHT(coord) (texelFetch(iChannel2, ivec2(coord), 0))\n#define UBOUNCE_LIGHT_BLUR(coord) UBOUNCE_LIGHT(coord)\n\n#define UDIRECT_ILLUMINATION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).x))\n#define UNORMAL(coord) (((unpack(texelFetch(iChannel0, ivec2(coord), 0).w)).xyz - 0.5)*2.0)\n#define UDEPTH(coord) (pow(texelFetch(iChannel0, ivec2(coord), 0).w, depthDistributionExponent))\n\n#define UDEPTH_CHANNEL1(coord) (texelFetch(iChannel1, ivec2(coord), 0).w)\n#define UBASE_COLOR(coord) vec3((unpack(texelFetch(iChannel0, ivec2(coord), 0).x)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).y)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).z)).w)\n\n// Color packing from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint packSnorm4x8(vec4 x) \n{\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 unpackSnorm4x8(uint x) \n{\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\n\n////////// SCENE\n\nstruct pointLight\n{\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 color;\n};\n    \nstruct directionalLight\n{\n    vec3 worldPosition;\n    float angle;\n    vec3 color;\n};\n    \nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float metal;\n};\n\nvec3 initialSunDirection = normalize(vec3(-0.2, 0.7, -0.4));\nvec3 initialSunColor = 1.25*vec3(1.0,0.60,0.3);\n// \"Moon\" is just sun reflected and re-colored when it crosses horizon line\nvec3 moonColor = 1.5*vec3(1.0,0.60,0.3)*vec3(0.25, 0.45, 0.75);\nvec3 skyColor = vec3(0);\n\n// Sphere inversion fractal, similar to iq's \"Apollonian\" (https://www.shadertoy.com/view/4ds3zn) but with octogonal symmetry\nfloat map(vec3 p, inout vec4 orbitTrap)\n{\n    const float s = 1.0;//0.97;\n    const float horizontalWrap = sqrt(s*2.0)/2.0;\n    \n\tfloat scale = 1.0;\n\n\torbitTrap = vec4(1000.0); \n    \n    for(int i=0; i<9; i++)\n\t{\n        p.xz /= horizontalWrap;\n        vec3 pOffset = (0.5*p+0.5);\n\n        vec3 pOffsetWrap = 2.0*fract(pOffset);\n        \n        p = -1.0 + pOffsetWrap;\n        p.xz *= horizontalWrap;\n        \n\t\tfloat r2 = dot(p,p);\n\t\t\n        if(i < 2)\n        {\n\t        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);\n        }\n        if(i > 2)\n        {\n            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);\n        }\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat fractal = 0.33*abs(p.y)/scale;\n    return fractal;\n}\n\nfloat sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)\n{\n    return map(p, orbitTrap);\n}\n\nvec3 calcNormal(in vec3 position)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    vec4 dummyOrbitTrap;\n\n    return normalize( \n        vec3(\n        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))\n    \t);\n}\n\nvec3 getSky(ray cameraRay, vec3 sunDirection, vec3 sunColor)\n{\n    // TODO could take dot product with some random hemisphere samples to create fake stars\n    vec3 bgColor = vec3(1.0);\n\n    #ifdef WATER\n        if(cameraRay.direction.y < 0.0)\n        {\n            cameraRay.direction *= vec3(1, -1, 1);\n            bgColor *= waterColor;\n        }\n    #endif\n\n    bgColor *= skyColor + saturate((dot(cameraRay.direction, sunDirection)-.9975)*800.0)*sunColor*80.0 + saturate(dot(cameraRay.direction, sunDirection)+0.75)*sunColor*0.015;\n\treturn bgColor;\n}\n\n\n////////// PATH TRACING\n    \nconst int unpackedNone = 0;\n\n// TODO flags for applying filters to packed textures\n/*\nconst int unpackedDirect = 1;\nconst int unpackedBounce = 2;\nconst int unpackedDepth = 3;\nconst int unpackedBaseColor = 4;\n*/\n\n// from hornet, who says:\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleLevel0(sampler2D sceneTexture, vec2 uv, float mipLevel)\n{\n    return textureLod(sceneTexture, uv, mipLevel);\n}\nvec4 SampleTextureCatmullRom(sampler2D sceneTexture, vec2 uv, vec2 texSize, float mipLevel, int getPacked)\n{\n    vec4 result = vec4(0.0);\n    if(getPacked == unpackedNone)\n    {\n        // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n        // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n        // location [1, 1] in the grid, where [0, 0] is the top left corner.\n        vec2 samplePos = uv * texSize;\n        vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n        // Compute the fractional offset from our starting texel to our original sample location, which we'll\n        // feed into the Catmull-Rom spline function to get our filter weights.\n        vec2 f = samplePos - texPos1;\n\n        // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n        // These equations are pre-expanded based on our knowledge of where the texels will be located,\n        // which lets us avoid having to evaluate a piece-wise function.\n        vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n        vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n        vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n        vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n        // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n        // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n        vec2 w12 = w1 + w2;\n        vec2 offset12 = w2 / w12;\n\n        // Compute the final UV coordinates we'll use for sampling the texture\n        vec2 texPos0 = texPos1 - vec2(1.0);\n        vec2 texPos3 = texPos1 + vec2(2.0);\n        vec2 texPos12 = texPos1 + offset12;\n\n        texPos0 /= texSize;\n        texPos3 /= texSize;\n        texPos12 /= texSize;\n        \n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos0.y), mipLevel) * w0.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos0.y), mipLevel) * w12.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos0.y), mipLevel) * w3.x * w0.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos12.y), mipLevel) * w0.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos12.y), mipLevel) * w12.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos12.y), mipLevel) * w3.x * w12.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos3.y), mipLevel) * w0.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos3.y), mipLevel) * w12.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos3.y), mipLevel) * w3.x * w3.y;\n    }\n    \n    return result;\n}\n\n\nvec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)\n{\n    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;\n    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;\n    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;\n    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));\n    \n    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);\n}\n\n// from tux: https://www.shadertoy.com/view/lsj3z3\nvec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)\n{\n    vec3 signs = sign(normal);\n    \n    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;\n    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;\n    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;\n    \n    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n  \n    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));\n}\n    \n\n// from iq\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)\n{\n    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);\n    vec2 random = hash22(randomSeed);\n    float u = random.x;\n    float v = random.y;\n    \n    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n\n// Camera projection stuff\nvec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) \n{\n    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;\n    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;\n    return vec3(\n        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), \n\t    (-1.0 + x2 + y2) / (1.0 + x2 + y2),\n        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));\n}\nvec2 stereographicSphereToPlane(vec3 cartPointOnSphere) \n{\n    return vec2(\n        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), \n        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));\n}\nvec2 cameraRayToUv(ray cameraRay, float projectionDist)\n{\n    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);\n    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));\n    return uv;\n}\nray uvToCameraRay(vec2 uv, float projectionDist)\n{\n    ray cameraRay;\n    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));\n    return cameraRay;\n}\n\n\n////////// POST\n\n// Bloom settings\nconst float bloomIntensity = 0.32;\nconst float bloomRadius = 0.006;\n\n// Fringe/chromatic aberration settings\nconst float fringeStrength = 0.51;\nconst float fringeStart = 0.4;\n\n// Bokeh settings\nconst float bokehScale = 0.0075;\nconst float bokehClamp = 0.0125;\nconst float bokehForceSharp = 0.001;\nconst float bokehFringe = 0.6;\nfloat bokehAspectRatio = 1.75;\n\n// FXAA settings\nconst float spanMax = 3.0;\nconst float reduceMult = (1.0/spanMax);\nconst float reduceMin = (1.0/48.0);\nconst float subPixelShift = (1.0/4.0);\n\nvec3 FXAA( vec2 uv2, sampler2D tex, vec2 rcpFrame) \n{\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + subPixelShift)));\n   \n    float lumaTopLeft = dot(textureLod(tex, uv.zw, 0.0).xyz, luma);\n    float lumaTopRight = dot(textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomLeft = dot(textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomRight = dot(textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaCenter  = dot(textureLod(tex, uv.xy, 0.0).xyz,  luma);\n\n    float lumaMin = min(lumaCenter, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));\n\n    vec2 direction;\n    direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));\n    direction.y =  ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));\n\n    float dirReduce = max(\n        (lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (0.25 * reduceMult),\n        reduceMin);\n    float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + dirReduce);\n    \n    direction = min(vec2( spanMax,  spanMax),\n          max(vec2(-spanMax, -spanMax),\n          direction * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + direction * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + direction * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// \"Airy disc\" bloom, complete gibberish and not based on anything physical; I just like the way it looks.\nvec4 getBloom(sampler2D sceneTexture, vec2 uv, vec2 resolution, float seed, float aspectRatio)\n{ \n    vec2 randomSeed = (uv*resolution * .152 + seed);\n    float random = hash12(randomSeed)*PI*2.0;\n\n    float stepsCenter = 7.0;\n    float stepsRing = 6.0;\n    float mipLevel = log2(resolution.x)/2.25;\n    vec4 outColor = vec4(0);\n    \n    float bloomSum = 0.0;\n    float weight = 0.0;\n    float totalBloom = 0.0;\n\n    vec2 radius = vec2(bloomRadius);\n    radius.y *= aspectRatio;\n\n    vec2 offsetUv = uv;\n    \n    for(float j = 1.0; j < (stepsCenter + 1.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsCenter + 1.0), 0.75))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 1.0;\n        \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsCenter), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    radius *= 2.0;\n    \n    for(float j = 2.0; j < (stepsRing + 2.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsRing + 2.0), 0.25))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 0.5;\n       \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsRing), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    return outColor/totalBloom;\n}\n\nvec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)\n{\n    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);\n    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);\n    \n    vec3 x = clamp(graded.xyz,0.0001,0.999);\n    \n    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);\n}", "buffer_b_code": "// Final indirect light \n//\n// Makes use of what we computed in Buffer A.\n// Recalculates screen space normals (they couldn't be stored properly in the buffer packing scheme without precision issues).\n\n// Recalculate world position from depth, texture coordinate for reconstructing normal\n// TODO optimize, or use a simpler camera projection\nvec3 reCalcWorldPosition(vec2 uv)\n{\n    vec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n    ray currentRay;\n    \n    // Current frame ray direction, camera ray and direction must match Buffer A\n\n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n    mouseLocation += iTime/9.0;\n    #endif\n\n    #ifdef INTERACTIVE\n    mouseLocation += 0.002*iMouse.x;\n    #endif\n\n    currentRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    currentRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    currentRay.direction.xyz = normalize(currentRay.direction.xzy); \n\n    \n    // Recover world position of current frame intersection point from ray direction\n    float pixelDepthForReprojection = UDEPTH(uv*iResolution.xy)*depthScale;\n    return (currentRay.direction)*pixelDepthForReprojection + currentRay.origin;\n}\n\n// Reconstructs screen space normal for deferred rendering. Bad.\nvec3 reCalcNormalFast(vec2 uv)\n{\n    float offsetPixel = 1.0;\n    \n    vec3 center = reCalcWorldPosition(uv);\n    \n    // Only sample two points, but vary which ones per frame in the hopes that temporal AA will smooth out artifacts\n    if(iFrame % 4 == 0)\n    {\n        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));\n        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));\n    \n        return normalize(cross(up-center, center-right));\n    }\n    else if(iFrame % 4 == 1)\n    {\n        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));\n        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(center-down, left-center));\n    }\n    else if(iFrame % 4 == 2)\n    {\n        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));\n        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(up-center, left-center));\n    }\n    else\n    {\n        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));\n        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(center-down, center-right));\n    }\n}\n\n// Reconstructs normal for deferred rendering using distance function. Slow.\nvec3 reCalcNormalSlow(vec2 uv)\n{\n    float offsetPixel = 1.0;\n    vec3 center = reCalcWorldPosition(uv);\n    return calcNormal(center);\n}\n\n// Get the indirect lighting from a \"virtual point light\" as stored in Buffer A\nvec3 getVirtualLightContribution(vec2 uv, vec2 offsetUv, vec3 baseColor, float roughness, vec3 camHitNormal, vec3 camHitPosition, out float dotProduct, out float brdfRef)\n{\n    // Avoid hotspots from lights nearly touching geometry\n    float minDistance = 0.2;\n    \n    vec3 lightPosition = UBOUNCE_POSITION(offsetUv*iResolution.xy).xyz*depthScale;\n    \n    // Diffuse\n    float diffuse = saturate(dot(normalize(camHitNormal), normalize(lightPosition - camHitPosition)))*0.9;\n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n    \tmouseLocation += iTime/9.0;\n    #endif\n\n    #ifdef INTERACTIVE\n    \tmouseLocation += 0.002*iMouse.x;\n    #endif\n    vec3 camOrigin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    float specular = GGX(normalize(camHitNormal), -normalize(camHitPosition - camOrigin), normalize(lightPosition - camHitPosition), roughness, 0.1);\n    \n    \n    float lightDistance = max(distance(lightPosition, camHitPosition), minDistance);\n    float lightDistance2 = lightDistance*lightDistance;\n    dotProduct = dot(reCalcNormalFast(uv), reCalcNormalFast(offsetUv));\n    \n    brdfRef = diffuse + specular;\n    \n    return ((UBOUNCE_COLOR(offsetUv*iResolution.xy).rgb))/lightDistance2;\n}\n\n// This is where we accumulate the \"point lights\" from neighboring pixels that we stored in Buffer A\n// Requires some ad hoc corrections since this causes us to miss some occlusion/shadows, but since everything is localized to nearby pixels it works pretty OK?\nvec3 accumulateLights(vec2 uv)\n{\n    int steps = 32;\n    vec2 radius = max(vec2(.01), 13.0/iResolution.xy);\n    const float goldenAngle = 2.4;    \n    \n    float depth = UDEPTH(uv*iResolution.xy)*depthScale;\n    vec3 baseColor = UBASE_COLOR(uv*iResolution.xy)/hdrScale;\n    vec3 camHitNormal = reCalcNormalSlow(uv);\n    vec3 camHitPosition = reCalcWorldPosition(uv);\n    \n    vec2 offsetUv = uv;\n    vec3 sum = vec3(0);\n    float totalBlur = 0.0;\n    float weight = 1.0; \n    float dotProduct = 1.0;\n    float brdfRef = 1.0;\n    // Counterproductive to apply pixel jitter to low-discrepency points...\n    //float seed = nrand(uv*iResolution.xy + vec2(mod(iTime*131.5,4096.0), mod(iTime*535.1,4096.0)));\n    float seed = hash11(mod(iTime*33.1, 1024.0));\n    mat2 rot = ROT(mod(seed, 2.0*PI));\n    \n    #ifdef ROUGHNESS_MAP\n    \tfloat roughness = saturate(pow(triPlanarMapCatRom(iChannel2, 5.0, camHitNormal, camHitPosition*7.0, iChannelResolution[2].xy), vec3(2.0)).r*2.0);\n    #else\n    \tconst float roughness = 0.4;\n    #endif\n    \n    // Start with \"correct\" GI contribution (i.e. the path that was actually sent for this pixel)\n    sum += getVirtualLightContribution(uv+0.0, uv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);\n    sum *= brdfRef;\n    totalBlur += 1.0;\n  \n    for(float i = 0.0; i < float(steps); i++)\n    {       \n        // Rotated Hammersley disc kernel\n        //offsetUv = uv + ((hammersleyDisk(int(i), steps)))*radius*rot;\t\n        // Spiral kernel\n        offsetUv = uv + (radius*pow(((i+1.0)/float(steps)), 0.5))*vec2(sin(mod((i+1.0)*goldenAngle+seed, 2.0*PI)), cos(mod((i+1.0)*goldenAngle+seed, 2.0*PI)));\n\n        dotProduct = 1.0;\n        vec3 sampledIndirect = getVirtualLightContribution(uv, offsetUv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);\n        float sampledDepth = UDEPTH(floor(offsetUv*iResolution.xy))*depthScale;\n\n        // TODO magic numbers\n        weight = 1.0;\n        \n        // Add hoc occlusion part 1\n        #ifdef INDIRECT_GATHER_CHECK_DIRECTION\n        \tif((dotProduct < 0.7) || distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)\n        #else\n            if(distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)\n        #endif\n        {\n            weight = 0.0;\n        }\n        \n        // Ad hoc occlusion part 2\n        float curOcclusion = saturate(200000.0*(depth-sampledDepth-0.03));\n        weight *= saturate(1.0-curOcclusion);\n\n        sum += brdfRef*sampledIndirect*weight;\n        totalBlur += weight;\n    }\n    \n    // Fade into shadow when we don't have good sample coverage\n    sum *= smoothstep(1.0, 2.0, totalBlur);\n    \n    return hdrScale*(baseColor*sum)/totalBlur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 baseColor = UBASE_COLOR(fragCoord)/hdrScale;\n    vec3 indirectLight = accumulateLights(uv);\n    #ifdef CLAMP_INDIRECT\n\t    indirectLight = min(indirectLight, vec3(hdrScale/2.0));\n    #endif\n    float depth = UDEPTH(fragCoord);\n    \n    float currentDepthMin = 100000.0;\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,0))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,0))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(0,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(0,-1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,-1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,-1))*1.0, currentDepthMin);\n    \n    fragColor = vec4(indirectLight, pow(currentDepthMin, 1.0/depthDistributionExponent));\n}", "buffer_b_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Temporal AA / denoise\n//\n// Lots more terrible ad hoc corrections to reduce ghosting, \"fireflies\" etc.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n       \n    vec2 fragCoordDejittered = fragCoord;\n    vec2 uvDejittered = uv;\n    \n    vec3 currentDirect = UDIRECT_ILLUMINATION(fragCoordDejittered).rgb*hdrScale;\n    currentDirect = max(vec3(0), currentDirect);\n    \n    vec3 currentIndirect = vec3(0);\n    \n    currentIndirect = UBOUNCE_LIGHT(fragCoordDejittered).rgb*hdrScale;\n    currentIndirect = max(vec3(0), currentIndirect);\n    currentIndirect = clamp(currentIndirect, vec3(0.0001), vec3(hdrScale));\n       \n    float currentDepth = UDEPTH(fragCoordDejittered)*depthScale;\n    \n    float currentDepthMax = 0.0;\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,0))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,0))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(0,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(0,-1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,-1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,-1))*depthScale, currentDepthMax);\n\n    float currentDepthMin = 100000.0;\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,0))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,0))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(0,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(0,-1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,-1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,-1))*depthScale, currentDepthMin);\n    \n    float oldDepthMax = 0.0;\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,0)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,0)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(0,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(0,-1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,-1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,-1)), oldDepthMax);\n\n\n    float oldDepthMin = 100000.0;\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,0)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,0)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(0,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(0,-1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,-1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,-1)), oldDepthMin);\n    \n    ray currentRay;\n    // Current frame ray direction, camera ray and direction must match Buffer A\n    \n    \n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n\t    mouseLocation += /*0.01*iMouse.x+*/ + iTime/9.0;\n    #endif\n    \n    #ifdef INTERACTIVE\n\t    mouseLocation += 0.002*iMouse.x;\n    #endif\n  \n    currentRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    currentRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    currentRay.direction.xyz = normalize(currentRay.direction.xzy); \n\n    // Recover world position of current frame intersection point from ray direction\n    float pixelDepthForReprojection = UDEPTH(uv*iResolution.xy)*depthScale;\n    vec3 currentWorldPosition = normalize(currentRay.direction)*pixelDepthForReprojection*2.0 + currentRay.origin;\n\n    // Previous frame data\n    vec3 prevRayOrigin = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    vec3 prevWorldPosition = currentWorldPosition+(currentRay.origin - prevRayOrigin);\n    vec3 prevRayDirection = prevWorldPosition-prevRayOrigin;\n    float prevPixelDepth = length(prevRayDirection);\n    prevRayDirection = normalize(prevRayDirection);\n    \n    // Find warped UV coords based on world space position of this pixel at previous frame\n    prevRayDirection.xzy = prevRayDirection.xyz;\n    vec2 prevUv = stereographicSphereToPlane(normalize(prevRayDirection))*1.5 + 0.5;\n    prevUv = vec2(prevUv.x/(iResolution.x/iResolution.y), prevUv.y);\n       \n    // Store temporal reprojection parameters\n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store latest camera pos for reprojection\n        fragColor.xyz = currentRay.origin;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Copy second-latest camera pos for reprojection\n        fragColor.xyz = texelFetch(iChannel1, ivec2(0,0), 0).xyz;\n        return;\n    }\n    \n    // Sample history color with Catmull-Rom filter\n    // since bilinear results in too much blurring from repeated re-sampling of reprojected history\n    vec3 oldColor = textureLod(iChannel1, prevUv, 0.0).rgb;\n    vec3 oldColorSharp = SampleTextureCatmullRom(iChannel1, prevUv, iChannelResolution[1].xy, 0.0, 0).rgb;\n   \n    // HW filtering is fine for depth\n    float oldDepth = textureLod(iChannel1, prevUv, 0.0).w*depthScale;\n    \n    bool offscreen = false;\n    float mixWeight = 0.0;\n    \n    // Don't read offscreen pixels or region reserved for non-color (camera) data\n    vec2 borderPadding = 1.0*vec2(1.0/(ceil(iResolution.x)), 1.0/(ceil(iResolution.y)));\n    if(prevUv.x <= borderPadding.x || prevUv.y <= borderPadding.y || prevUv.x >= 1.0 - borderPadding.x || prevUv.y >= 1.0 - borderPadding.y ||\n       (floor(prevUv.y*iResolution.y) <= 1.0 && floor(prevUv.x*iResolution.x) <= 10.0))\n    {\n        offscreen = true;\n    }\n\t\n    // TODO dilate motion vector, i.e. take longest in neighborhood?\n    // BUG for some reason this seems to behave differently based on overall distance to camera -- precision issue?\n    mixWeight = max(0.0,(50.0*(sqrt(currentDepth)-sqrt(oldDepth)-0.01)));\n    //mixWeight += saturate(200.0*(currentDepth-oldDepth));\n    mixWeight = (mixWeight + 0.04);\n\n    vec2 biasUv = vec2(0);\n   \t\n    mixWeight = saturate(mixWeight);\n\n    // Don't use Catmull-Rom for newly-unoccluded regions since they are extremely noisy\n    if(mixWeight < 0.1 && !offscreen)\n    {\n        oldColor = oldColorSharp;\n    }\n    \n    if(offscreen)\n    {\n       mixWeight = 1.0;\n    }\n    \n    #ifdef CLAMP_INDIRECT      \n        vec3 blurredGi1 = textureLod(iChannel2, uvDejittered, 1.5).rgb*hdrScale;\n        currentIndirect = min(currentIndirect, blurredGi1 + 0.01);\n        currentIndirect = max(currentIndirect, blurredGi1 - 0.02);\n\n        vec3 blurredGi2 = textureLod(iChannel2, uvDejittered, 2.5).rgb*hdrScale;\n        currentIndirect = min(currentIndirect, blurredGi2 + 0.03);\n        currentIndirect = max(currentIndirect, blurredGi2 - 0.04);\n\n        if(mixWeight > 0.15 || offscreen)\n        {\n            // Blur indirect pixels more when we don't have history data\n            vec3 blurredGi3 = textureLod(iChannel2, uvDejittered, 4.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi3 + 0.005);\n            currentIndirect = max(currentIndirect, blurredGi3 - 0.04);\n\n            vec3 blurredGi4 = textureLod(iChannel2, uvDejittered, 5.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi4 + 0.01);\n            currentIndirect = max(currentIndirect, blurredGi4 - 0.08);\n\n            // For debugging. Also happens to look neat.\n            //currentIndirect = vec3(1,0,0);\n        }\n        else\n        {\n            vec3 blurredGi5 = textureLod(iChannel2, uvDejittered, 4.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi5 + 0.08);\n            currentIndirect = max(currentIndirect, blurredGi5 - 0.1);\n        }\n    #endif\n    \n    //currentDirect += bloomIntensity*getBloom(iChannel1, prevUv, iChannelResolution[0].xy, mod(iTime*139.8 + iMouse.x, 4096.0), bokehAspectRatio*iResolution.x/iResolution.y).rgb;\n       \n    vec3 combinedColor = mix(oldColor, currentDirect + currentIndirect, mixWeight);\n    \n    if(currentDepth >= maxDepth - 0.01)\n    {\n        vec3 sunDirection = initialSunDirection;\n        vec3 sunColor = initialSunColor;\n        #ifdef ANIMATE_SUN\n            sunDirection.yz *= ROT(mod(iTime*0.05, PI*2.0));\n            sunDirection.xy *= ROT(sin(mod(iTime*0.025, PI*2.0)));\n            // \"moon\"\n            if (sunDirection.y <= 0.0)\n            {\n                float colorMix = smoothstep(0.0, -0.2, sunDirection.y);\n                if(sunDirection.y <= -0.2)\n                {\n                    sunDirection.y += 0.2;\n                    sunDirection.y *= -1.0;\n                    sunDirection.y -= 0.2;\n                }\n                sunColor = mix(sunColor, moonColor, colorMix);\n            }\n        #endif\n\n        combinedColor.rgb = getSky(currentRay, sunDirection, sunColor);\n    }\n    \n    combinedColor = clamp(combinedColor, vec3(0.0001), 2.0*vec3(hdrScale));\n\n\n\n    // For debugging\n    //float minMaxVisualize = distance(currentDepthMin, oldDepthMin) + distance(currentDepthMax, oldDepthMax);\n \n    float combinedDepth = currentDepth/depthScale;\n    \n    // For debugging\n    //fragColor = vec4(vec3(minMaxVisualize), combinedDepth);\n    //fragColor = vec4(vec3(mixWeight), combinedDepth);\n    //fragColor = vec4(vec3(biasUv, 0.0), combinedDepth);\n    //fragColor = vec4(vec3(distance(oldDepthMax, oldDepthMin)), combinedDepth);\n    //fragColor = vec4(vec3(distance(currentDepthMax, currentDepthMin)), combinedDepth);\n    //fragColor = vec4(blurGi(uv), combinedDepth);\n    //fragColor = vec4(currentDirect + currentIndirect, combinedDepth);\n    \n    fragColor = vec4(combinedColor, combinedDepth);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Bokeh with fake color fringing + autofocus, anamorphic (including realistic \"swirly\" artifacts near edges)\n//\n// Ended up quite hairy/hacky from to trying to avoid edge/background bleed artifacts, but works pretty well.\n// I originally wanted to do a separable version but didn't have enough buffers left, so it's fairly slow.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 randomSeed = (fragCoord * .152 + iTime * 1500. + iMouse.x);\n    float random = hash12(randomSeed)*PI*2.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float depth = textureLod(iChannel0, uv, 0.0).w*(depthScale*(-1.0 * cos(iTime)));\n        \n    // Autofocus\n    float focalDepth = texelFetch(iChannel1, ivec2(0), 0).w;\n    float focalDepthNew = min(min(min(textureLod(iChannel0, vec2(0.5, 0.25), 5.5).w*(depthScale*(1.0 * sin(iTime))), textureLod(iChannel0, vec2(0.6, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.4, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.5, 0.5), 8.0).w*depthScale);\n    focalDepth = mix(focalDepth, focalDepthNew, 0.05);\n    \n    vec2 offsetUv = vec2(0);\n    vec4 foregroundColor = vec4(0);\n    vec4 backgroundColor = vec4(0);\n    vec4 midgroundColor = vec4(0);\n    vec4 midgroundColorNoFringe = vec4(0);\n    vec4 totalColor = vec4(0);\n    \n    const float steps = 32.0;\n    const float stepsSmooth = 24.0;\n    \n    vec2 radiusClamp = vec2(bokehClamp);\n    radiusClamp.y *= iResolution.x/iResolution.y;\n    \n    // Radius of circle of confusion based on depth at current pixel\n    vec2 trueRadius = vec2(bokehScale);\n    trueRadius.y *= iResolution.x/iResolution.y;\n    trueRadius *= 1.0-focalDepth/depth;\n  \n    vec2 erodedRadius = vec2(1);\n    vec2 smoothedRadius = vec2(0);\n    \n    const float additionalDilation = 1.25;\n    const float searchMipLevel = 0.0;\n    \n    // Preprocess, estimate kernel size etc.\n    for(float i = 0.0; i < stepsSmooth; i++)\n    {   \n        vec2 searchRadius = additionalDilation/**vec2(1.0/bokehAspectRatio, 1)*/*(radiusClamp*pow((i)/steps, 0.5));\n        offsetUv = uv + searchRadius*vec2(sin(i*goldenAngle/* + random*/), cos(i*goldenAngle/* + random*/));\n        \n        float depthGathered = textureLod(iChannel0, offsetUv, searchMipLevel).w*(depthScale+(-1.0 * cos(iTime)));\n\n        vec2 radiusGathered = vec2(bokehScale);\n        radiusGathered.y *= iResolution.x/iResolution.y;\n        radiusGathered *= 1.0-focalDepth/depthGathered;\n        \n        if(length(radiusGathered) >= length(radiusClamp))\n        {\n            radiusGathered = radiusClamp;\n        }\n        \n        smoothedRadius += abs(radiusGathered);\n        erodedRadius = min(abs(radiusGathered), erodedRadius);\n    }\n    smoothedRadius /= stepsSmooth;\n    \n    // Main blur\n    // Limited radius\n    vec2 radiusBias = vec2(bokehForceSharp);\n    radiusBias.y *= iResolution.x/iResolution.y;\n    vec2 radius = max(vec2(0), smoothedRadius-radiusBias);\n    radius /= (1.0-bokehForceSharp);\n    \n    float totalBlur = 0.0;\n    bool fringeValid = true;\n    \n    // Try to sample from lower-res mips to reduce noise, but don't want to go too low and introduce any visible blockiness\n    float mipLevel = min(max(log2(length(erodedRadius*iResolution.xy/3.0))+0.5, 0.0), max(log2(length(min(smoothedRadius, trueRadius)*iResolution.xy/3.0))-1.5, 0.0));   \n    mipLevel = min(mipLevel, 2.0);\n  \n    vec4 currentColor;\n    vec4 colorFringed;\n    float falloff = 1.0;\n    float vignette = 1.0;\n    if(length(radius) > 1.0/length(iResolution.xy))\n    {\n        for(float i = 0.5; i < steps; i++)\n        {   \n            vec2 offset = (radius*pow(i/steps, 0.5))*vec2(sin(i*goldenAngle + random), cos(i*goldenAngle + random));\n            \n            // \"Swirly\" bokeh\n            offset *= ROT(atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)-PI);\n            if(offset.y >= radius.y-3.0*(radius.y)*distance(uv, vec2(0.5)))\n            {\n                vignette = saturate(offset.y - (radius.y-3.0*(radius.y)*distance(uv, vec2(0.5))));\n                vignette = saturate(1.0 - 0.8*vignette/radius.y);\n                vignette = saturate(0.0001 + vignette);\n                offset.y /= 1.0+saturate(1.0-vignette)/2.0;\n                \n            }\n            offset *= ROT(-atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)+PI);\n\n            offset *= vec2(1.0/bokehAspectRatio, 1);\n            \n            offsetUv = uv + offset;\n\n            falloff = ((i+1.0)/steps);\n\n            // Using dilated depth to reduce bleed\n            float depthGathered = textureLod(iChannel2, offsetUv, 0.0).w*depthScale;\n\n            vec2 radiusGathered = vec2(bokehScale);\n            radiusGathered.y *= iResolution.x/iResolution.y;\n            radiusGathered *= 1.0-focalDepth/depthGathered;\n            radiusGathered *= vec2(1.0/bokehAspectRatio, 1);\n          \n            float distanceFromCenter = distance(offsetUv, uv);\n\n            if((depthGathered > depth && length(trueRadius) < bokehScale/6.0 /*&& length(radiusGathered) > length(trueRadius)*/))\n            {\n                float factor = smoothstep(bokehScale/80.0, bokehScale/6.0, length(trueRadius));\n                offsetUv = mix(uv, offsetUv, factor);\n            }\n            float curMipLevel = mipLevel;\n            currentColor = textureLod(iChannel0, offsetUv, mipLevel);\n            colorFringed = currentColor * 12.1*vec4(1.0, 0.16, 0.3, 1.0) * HUE(mod((0.2 + 0.3*float(i)/float(steps-1.0)), 1.0)) * falloff;\n            totalBlur += 1.0*vignette;\n\n            // Is the sample we gathered at a depth such that it would actually be scattered onto the current pixel?\n            if((length(radiusGathered) < distanceFromCenter*0.66))\n            {\n                fringeValid = false;\n                currentColor = vec4(0,0,0,1);\n                colorFringed = vec4(0,0,0,1);\n                totalBlur -= 1.0*vignette;\n            }\n             \n            midgroundColor += mix(currentColor, colorFringed, bokehFringe)*vignette;\n            midgroundColorNoFringe += currentColor*vignette;\n        }\n        // If we rejected some samples, the color fringe would become biased\n        if(!fringeValid)\n        {\n            midgroundColor = midgroundColorNoFringe;\n        }\n        else\n        {\n            midgroundColor = mix(midgroundColorNoFringe, midgroundColor, smoothstep(0.0, 4.0/length(iResolution.xy), length(radius)));\n        }\n        if(totalBlur > 0.0)\n        {\n\t        midgroundColor /= totalBlur;\n        }\n        else\n        {\n            midgroundColor = textureLod(iChannel0, uv, 0.0);\n        }\n    }\n    else\n    {\n        midgroundColor = textureLod(iChannel0, uv, 0.0);\n        // For debugging\n        //midgroundColor = vec4(1,0,0,1)*textureLod(iChannel0, uv, 0.0)*steps;\n    }\n    \n    totalColor += midgroundColor;\n    \n    // Bloom\n    totalColor += bloomIntensity*getBloom(iChannel0, uv, iChannelResolution[0].xy, mod(iTime*13.8 + iMouse.x, 1024.0), bokehAspectRatio*iResolution.x/iResolution.y);\n    \n    // Auto exposure\n    float exposure = texelFetch(iChannel1, ivec2(1, 0), 0).w;\n    float exposureNew = length(textureLod(iChannel0, vec2(0.5, 0.5), 8.0).rgb)*3.0 + 0.5;\n    exposure = mix(exposure, exposureNew, 0.05);  \n    exposure = max(exposure, 0.0) + 0.001;\n    totalColor /= exposure;\n\n    float outAlpha = 0.0;\n    \n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store focal depth\n        fragColor.w = focalDepth;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Store exposure\n        fragColor.w = exposure;\n        return;\n    }\n    \n    fragColor = vec4(totalColor.rgb, fragColor.w);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 277, 303, 303, 403]], "test": "untested"}
{"id": "stKXDG", "name": "Idling", "author": "Panacea", "description": "Original shader 'Booting' by: andremichelle\nImproved/optimized by: FabriceNeyret2\nAnd recolored by me.", "tags": ["random"], "likes": 11, "viewed": 297, "published": 3, "date": "1641311938", "time_retrieved": "2024-07-30T17:12:00.992689", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.* u- iResolution.xy ) / iResolution.y;\n    \n    float a = atan(U.y, U.x),\n          l = length(U),\n          x = 48.* ( l-.3 + sin(iTime)*.06125 ),\n          c = abs(cos(x*2.) / x ) * 1.75,\n          t = iTime*.75,\n          d =   sin(a*1.+t*0.5)\n              + sin(a*2.-t*1.2)\n              + sin(a*3.+t*1.5)\n              + sin(a*2.-t*1.7)\n              + sin(a*1.+t*3.8);\n\n    O = vec4(.0,.8,.0,.5) * (.05 + c*d*.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 478]], "test": "untested"}
{"id": "NlKXDy", "name": "2D Wave Lattice 2", "author": "FabriceNeyret2", "description": "variant from oneshade's \"2D Wave Lattice\" [url]https://shadertoy.com/view/ftySRt[/url]\n\ntry any other odd number >= 7\nIt tend to blue noise, since it is the same frequency in all directions ( i.e. PSD = ring ).", "tags": ["2d", "waves", "quasiquasicrystal", "bluenoise", "lattice"], "likes": 19, "viewed": 461, "published": 3, "date": "1641305145", "time_retrieved": "2024-07-30T17:12:02.059836", "image_code": "// variant from oneshade's \"2D Wave Lattice\" https://shadertoy.com/view/ftySRt\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 2.*(u+u - R) / R.y;\n\n    float n = 13., TAU = 6.283, a=0.;\n    \n    for (O-=O; a < TAU; a += TAU / n)\n        O += sin( dot(U, vec2(cos(a), sin(a))) * 40. + iTime + a\n                  + fract(1e4*sin(1e4*a))*iTime ); // random phase\n\n     O = .5 + O / sqrt(n)/4.;    // normalization\n  // O = .5 + .5*O/fwidth(O);    // B & W variant\n  // O = smoothstep(-1.,1.,O/fwidth(O)); // B & W variant\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 116, 116, 554]], "test": "untested"}
{"id": "ftVXWG", "name": "Horse Mane", "author": "wyatt", "description": "JFA rendering a bunch of strings", "tags": ["jfa"], "likes": 21, "viewed": 425, "published": 3, "date": "1641294020", "time_retrieved": "2024-07-30T17:12:03.093073", "image_code": "Main \n    Q = vec4(0);\n    float a = .1;\n    vec4 d = D(U);\n    vec4 b = B(d.xy);\n    if (length(b.xy-b.zw)<10.)\n    Q = (.5+.5*sin(1.+.5*sin(.16*d.x)+vec4(1,2,3,4)))*exp(-sg(U,b.xy,b.zw));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T; int I;\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; T = iTime; I = iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define N 7\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}", "buffer_a_code": "Main\n    float x = floor(U.x)+.5;\n    float y = U.y;\n    Q = A(vec2(x,y));\n    \n    vec2 f = vec2(3e-5,-1e-4);\n    \n    for(float i = -20.; i <=20.; i++)\n    {\n        vec4 q = A(mod(vec2(x,y+i),R));\n        vec2 r = q.xy-Q.xy;\n        float l = length(r);\n        if (l>0.&&l<10.){\n            f += r/l/40.*(l-abs(i));\n        }\n    }\n    if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n    Q.zw += f;\n    Q.xy += f+Q.zw;\n    \n    if (R.y-U.y<2.||I<1) {\n        U.x = x+10.*sin(2e-3*float(I)+x)+10.*sin(5e-3*float(I)+.1*x);\n        Q = vec4(U,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n    Q = vec4(A(U).xy,A(U-vec2(0,1)).xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void X (inout vec4 Q, vec2 U, vec4 a) {\n    vec4 q = B(Q.xy);\n    vec4 b = B(a.xy);\n    if(sg(U,b.xy,b.zw)<sg(U,q.xy,q.zw))\n        Q = a;\n}\nMain\n    Q = C(U);\n    if (I%N==0) Q=vec4(U,0,0);\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tX(Q,U,C(U+vec2(0,k)));\n    \tX(Q,U,C(U+vec2(k,0)));\n    \tX(Q,U,C(U-vec2(0,k)));\n    \tX(Q,U,C(U-vec2(k,0)));\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void X (inout vec4 Q, vec2 U, vec4 a) {\n    vec4 q = B(Q.xy);\n    vec4 b = B(a.xy);\n    if(sg(U,b.xy,b.zw)<sg(U,q.xy,q.zw))\n        Q = a;\n}\nMain\n    Q = D(U);\n    X(Q,U,D(U+vec2(0,1)));\n    X(Q,U,D(U+vec2(1,0)));\n    X(Q,U,D(U-vec2(0,1)));\n    X(Q,U,D(U-vec2(1,0)));\n    X(Q,U,vec4(Q.x,Q.y+1.,0,0));\n    X(Q,U,vec4(Q.x,Q.y-1.,0,0));\n    X(Q,U,C(U));\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "slKXRW", "name": "circle of silence", "author": "ersteller", "description": "Here is my attempt on visualizing fft in polar coordinates. \n\nIt would be really cool if i could get the soundcloud stream to work :(\n\nFork from https://www.shadertoy.com/view/4lGSzy", "tags": ["fft", "music", "vfx", "polar", "coordinates", "dubstep"], "likes": 3, "viewed": 275, "published": 3, "date": "1641286358", "time_retrieved": "2024-07-30T17:12:03.882961", "image_code": "//Fork from https://www.shadertoy.com/view/4lGSzy\n\n// inspired by vfx used by DSG https://www.youtube.com/watch?v=Qg1qZq5yjps\n\n\n#define time iTime\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(float n){\n    return pow(Semitone,(n-8.))*440./48000.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*2.0-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    //p.y+=0.5;  // for fft draw pos\n    \n    // polar coordinates \n    vec2 st = vec2(atan(p.x, p.y)/(1.*3.1415),length(p));  // x is now angle and y is radius\n    \n    st.x = abs(st.x);\n    // uv = st;\n\n    vec3 col = vec3(0.0);\n    \n    float nBands = 96.0;\n    float i = floor(st.x*nBands);\n    // float f = fract(uv.x*nBands);\n    float band = KeyToFrequency(i);\n    \n    // first texture row is frequency data\n\tfloat fft  = textureLod( iChannel0, vec2(band,0.25), 0.0 ).x; \n    float s = fft;\n    s *= s;  // improve signal to noise\n    \n    // second texture row is the sound wave\n\tfloat wave = textureLod( iChannel0, vec2(uv.x,0.75), 0.0 ).x;\n    \n    /* Gradient colors and amount here */\n    float roffset = 0.4;\n    const int nColors = 5;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.0,1.0,1.0);\n    colors[1] = vec3(0.0,0.0,1.0);\n    colors[2] = vec3(0.0,1.0,1.0);\n    colors[3] = vec3(1.0,1.0,0.0);\n    colors[4] = vec3(1.0,0.0,0.0);\n    \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    // the circle of silence\n    col+= vec3(1.-smoothstep(0.,0.01,(st.y-s*.75)-roffset));\n    \n    //col += vec3(1.0-smoothstep(0.0,0.01,p.y-s*1.5));\n    col *= gradCol;\n\n    //col = mix(vec3(0.0),col,smoothstep(-0.01,0.01,p.y));\n\n    //col *= smoothstep(0.125,0.375,f);\n    //col *= smoothstep(0.875,0.625,f);\n    \n\n    \n    col += 1.0 - smoothstep(0.0, 0.01, abs(0.8*wave - uv.y - 0.3));\n    col = clamp(col, 0.0, 1.0);\n\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 190, 190, 249], [360, 360, 390, 390, 437], [439, 439, 496, 496, 2191]], "test": "untested"}
{"id": "7lGSWG", "name": "Anemone", "author": "xenn", "description": "Custom mandelbox by loicvdb. https://shadertoy.com/view/3t3GWH mixed with a nice cube map sky thingy someone kindly made. Luscious colours, thanks whoever you are, I forget", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 15, "viewed": 456, "published": 3, "date": "1641282028", "time_retrieved": "2024-07-30T17:12:05.399905", "image_code": "// Fork of \"Psynthetika spectrum muted tun\" by xenn. https://shadertoy.com/view/7tyXRG\n// 2022-01-04 07:39:48\n\n// Forkmerge with \"Fork mandelbulb rogo1965 883\" by rogo1965. https://shadertoy.com/view/slGSR3\n// 2022-01-04 07:38:29\n\n// Forkmerge with \"Kleinian Landscape\" by amoser. https://shadertoy.com/view/WttBRr\n// 2021-11-28 02:34:24\n\n// Final post-processing\n// \n\n// Sample scene color with FXAA, 0-1 range uvs\nvec4 sceneColor(vec2 uv)\n{\n    vec4 outColor = vec4(FXAA(uv, iChannel1, 1.0/iResolution.xy), 1.0);\n    \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvAspectCorrected = uv - 0.5;\n    uvAspectCorrected = vec2(uvAspectCorrected.x*(iResolution.x/iResolution.y), uvAspectCorrected.y);\n    uvAspectCorrected += 0.5;\n    \n    // Fringe\n\tconst int fringeSamples = 6;\n    float fringeAmount = fringeStrength*saturate(distance(uvAspectCorrected, vec2(0.5))-fringeStart);\n\n    vec4 outColor = vec4(0);\n\n    if(fringeAmount > 0.0)\n    {\n        for(int i = 0; i < fringeSamples; i++)\n        {\n            float fringe = 1.0+(float(i-fringeSamples/2)*fringeAmount)/float(fringeSamples);\n            outColor += vec4(sceneColor(((uv-0.5)*fringe + 0.5)))*HUE(mod(0.85-1.0*float(i)/float(fringeSamples), 1.0));\n        }\n        outColor /= float(fringeSamples)*0.6;\n    }\n    else\n    {\n        outColor = vec4(sceneColor(uv));\n    }\n\n    \n    // Vignette\n    outColor *= pow(saturate(1.25-1.5*distance(uv, vec2(0.5))), 0.9);\n    outColor += 0.001*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    // Saturation / discolor highlights\n    outColor = mix(outColor, vec4(1, 1, 0.66, 1)*vec4(dot(outColor.rgb, luma)), 1.0-saturate(1.05-dot(outColor.rgb, luma))); \n    \n    // Saturation / discolor shadows\n    outColor = mix(outColor, vec4(0.6, 0.8, 1, 1)*vec4(dot(outColor.rgb, luma)), saturate(0.3-3.0*dot(outColor.rgb, luma))); \n    \n    // Tonemap + color grade\n   \toutColor = toneMap(outColor, vec3(0.95,0.95,0.85), vec3(1.15, 1.3, 1.3));\n    \n    // Ungraded tonemap\n   // outColor = toneMap(outColor, vec3(1), vec3(1));\n    \n    fragColor = pow(outColor, vec4(1.0/gamma));\n    \n    // For debugging depth\n //   fragColor = vec4(1.0-UDEPTH(fragCoord)*maxDepth);\n    // For debugging GI\n\t//fragColor = textureLod(iChannel0, uv, 0.0);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 9; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.062;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, iTime*0.2);// rotation of mb\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<96; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n     \n    pixel_size = 1.0/(iResolution.x * 3.0);\n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.01, 2.2, 0.01);\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n\tvec3 rd = normalize(uv.x*cs + uv.y*cu + /*zoom*/(5.5- (1.0*sin(iTime/4.)))*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.2); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n    float halo= clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           vec3 n=nor(p); \n           float shadow = softshadow(p, sundir, 10.0 );\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * shadow; \n           lin += 0.8 * bac * sun; \n           lin += 0.6 * sky * skycolor*shadow; \n           lin += 3.0 * spe * shadow; \n\n\t\t   res.y = pow(clamp(res.y, 0.0, 1.0), 0.95);\n\t\t   vec3 tc0 = 0.5 + 0.5 * cos(-6.0*iTime + 9.2 * res.y + vec3(0.9, 0.0, 0.0));\n           col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    //col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n }", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor + vec3(1.2) * (1.0*factor);\n    fragColor = vec4(col, 1.0);\n//}\n// float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 coloro = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor * vec3(1.2) * (1.0/factor);\n//    fragColor = vec4(col, 1.0);\n//void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n//{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n//    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    vec3 groundCol = coloro;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 colo = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_b_code": "//first DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Kleinian Landscape\n//\n// Except where otherwise specified or cited, all work is my own and available under\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Constants, helper functions\n// \n\n#define CLAMP_INDIRECT\n#define ANIMATE_CAMERA\n#define ANIMATE_SUN\n#define INTERACTIVE\n#define ROUGHNESS_MAP\n#define INDIRECT_GATHER_CHECK_DIRECTION\n\n\n////////// GENERAL\n\n#define PI 3.1415926536\n\nconst float gamma = 2.2;\n\n// Dynamic range; keep as low as possible since these buffers are packed with very low precision\nconst float hdrScale = 2.0;\nconst float depthScale = 8.0;\nconst float maxDepth = 1.0;\nconst float depthDistributionExponent = 1.0;\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\nconst float goldenAngle = 2.4;\n\n#ifdef TEMPORAL_JITTER\n\tconst float AAjitter = 1.0;\n#else\n\tconst float AAjitter = 0.0;\n#endif\n\nfloat saturate(float a)\n{\n    return clamp(a, 0.0, 1.0);\n}\n\n// from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// from Fabrice Neyret\n#define ROT(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define HUE(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0) ) )\n\n\n\n// Buffer unpacking\n#define UBOUNCE_COLOR(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).y))\n#define UBOUNCE_POSITION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).z))\n#define UBOUNCE_LIGHT(coord) (texelFetch(iChannel2, ivec2(coord), 0))\n#define UBOUNCE_LIGHT_BLUR(coord) UBOUNCE_LIGHT(coord)\n\n#define UDIRECT_ILLUMINATION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).x))\n#define UNORMAL(coord) (((unpack(texelFetch(iChannel0, ivec2(coord), 0).w)).xyz - 0.5)*2.0)\n#define UDEPTH(coord) (pow(texelFetch(iChannel0, ivec2(coord), 0).w, depthDistributionExponent))\n\n#define UDEPTH_CHANNEL1(coord) (texelFetch(iChannel1, ivec2(coord), 0).w)\n#define UBASE_COLOR(coord) vec3((unpack(texelFetch(iChannel0, ivec2(coord), 0).x)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).y)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).z)).w)\n\n// Color packing from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint packSnorm4x8(vec4 x) \n{\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 unpackSnorm4x8(uint x) \n{\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\n\n////////// SCENE\n\nstruct pointLight\n{\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 color;\n};\n    \nstruct directionalLight\n{\n    vec3 worldPosition;\n    float angle;\n    vec3 color;\n};\n    \nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float metal;\n};\n\nvec3 initialSunDirection = normalize(vec3(-0.2, 0.7, -0.4));\nvec3 initialSunColor = 0.25*vec3(0.7,0.50,0.3);\n// \"Moon\" is just sun reflected and re-colored when it crosses horizon line\nvec3 moonColor = 1.5*vec3(0.70,0.50,0.3)*vec3(0.25, 0.45, 0.75);\nvec3 skyColor = vec3(0);\n\n// Sphere inversion fractal, similar to iq's \"Apollonian\" (https://www.shadertoy.com/view/4ds3zn) but with octogonal symmetry\nfloat map(vec3 p, inout vec4 orbitTrap)\n{\n    const float s = 1.0;//0.97;\n    const float horizontalWrap = sqrt(s*2.0)/2.0;\n    \n\tfloat scale = 1.0;\n\n\torbitTrap = vec4(1000.0); \n    \n    for(int i=0; i<9; i++)\n\t{\n        p.xz /= horizontalWrap;\n        vec3 pOffset = (0.5*p+0.5);\n\n        vec3 pOffsetWrap = 2.0*fract(pOffset);\n        \n        p = -1.0 + pOffsetWrap;\n        p.xz *= horizontalWrap;\n        \n\t\tfloat r2 = dot(p,p);\n\t\t\n        if(i < 2)\n        {\n\t        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);\n        }\n        if(i > 2)\n        {\n            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);\n        }\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat fractal = 0.33*abs(p.y)/scale;\n    return fractal;\n}\n\nfloat sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)\n{\n    return map(p, orbitTrap);\n}\n\nvec3 calcNormal(in vec3 position)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    vec4 dummyOrbitTrap;\n\n    return normalize( \n        vec3(\n        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))\n    \t);\n}\n\nvec3 getSky(ray cameraRay, vec3 sunDirection, vec3 sunColor)\n{\n    // TODO could take dot product with some random hemisphere samples to create fake stars\n    vec3 bgColor = vec3(1.0);\n\n    #ifdef WATER\n        if(cameraRay.direction.y < 0.0)\n        {\n            cameraRay.direction *= vec3(1, -1, 1);\n            bgColor *= waterColor;\n        }\n    #endif\n\n    bgColor *= skyColor + saturate((dot(cameraRay.direction, sunDirection)-.9975)*800.0)*sunColor*80.0 + saturate(dot(cameraRay.direction, sunDirection)+0.75)*sunColor*0.015;\n\treturn bgColor;\n}\n\n\n////////// PATH TRACING\n    \nconst int unpackedNone = 0;\n\n// TODO flags for applying filters to packed textures\n/*\nconst int unpackedDirect = 1;\nconst int unpackedBounce = 2;\nconst int unpackedDepth = 3;\nconst int unpackedBaseColor = 4;\n*/\n\n// from hornet, who says:\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleLevel0(sampler2D sceneTexture, vec2 uv, float mipLevel)\n{\n    return textureLod(sceneTexture, uv, mipLevel);\n}\nvec4 SampleTextureCatmullRom(sampler2D sceneTexture, vec2 uv, vec2 texSize, float mipLevel, int getPacked)\n{\n    vec4 result = vec4(0.0);\n    if(getPacked == unpackedNone)\n    {\n        // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n        // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n        // location [1, 1] in the grid, where [0, 0] is the top left corner.\n        vec2 samplePos = uv * texSize;\n        vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n        // Compute the fractional offset from our starting texel to our original sample location, which we'll\n        // feed into the Catmull-Rom spline function to get our filter weights.\n        vec2 f = samplePos - texPos1;\n\n        // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n        // These equations are pre-expanded based on our knowledge of where the texels will be located,\n        // which lets us avoid having to evaluate a piece-wise function.\n        vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n        vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n        vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n        vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n        // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n        // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n        vec2 w12 = w1 + w2;\n        vec2 offset12 = w2 / w12;\n\n        // Compute the final UV coordinates we'll use for sampling the texture\n        vec2 texPos0 = texPos1 - vec2(1.0);\n        vec2 texPos3 = texPos1 + vec2(2.0);\n        vec2 texPos12 = texPos1 + offset12;\n\n        texPos0 /= texSize;\n        texPos3 /= texSize;\n        texPos12 /= texSize;\n        \n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos0.y), mipLevel) * w0.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos0.y), mipLevel) * w12.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos0.y), mipLevel) * w3.x * w0.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos12.y), mipLevel) * w0.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos12.y), mipLevel) * w12.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos12.y), mipLevel) * w3.x * w12.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos3.y), mipLevel) * w0.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos3.y), mipLevel) * w12.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos3.y), mipLevel) * w3.x * w3.y;\n    }\n    \n    return result;\n}\n\n\nvec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)\n{\n    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;\n    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;\n    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;\n    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));\n    \n    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);\n}\n\n// from tux: https://www.shadertoy.com/view/lsj3z3\nvec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)\n{\n    vec3 signs = sign(normal);\n    \n    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;\n    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;\n    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;\n    \n    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n  \n    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));\n}\n    \n\n// from iq\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)\n{\n    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);\n    vec2 random = hash22(randomSeed);\n    float u = random.x;\n    float v = random.y;\n    \n    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n\n// Camera projection stuff\nvec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) \n{\n    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;\n    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;\n    return vec3(\n        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), \n\t    (-1.0 + x2 + y2) / (1.0 + x2 + y2),\n        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));\n}\nvec2 stereographicSphereToPlane(vec3 cartPointOnSphere) \n{\n    return vec2(\n        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), \n        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));\n}\nvec2 cameraRayToUv(ray cameraRay, float projectionDist)\n{\n    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);\n    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));\n    return uv;\n}\nray uvToCameraRay(vec2 uv, float projectionDist)\n{\n    ray cameraRay;\n    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));\n    return cameraRay;\n}\n\n\n////////// POST\n\n// Bloom settings\nconst float bloomIntensity = 0.2;\nconst float bloomRadius = 0.006;\n\n// Fringe/chromatic aberration settings\nconst float fringeStrength = 0.1;\nconst float fringeStart = 0.4;\n\n// Bokeh settings\nconst float bokehScale = 0.0075;\nconst float bokehClamp = 0.0125;\nconst float bokehForceSharp = 0.001;\nconst float bokehFringe = 0.6;\nfloat bokehAspectRatio = 1.75;\n\n// FXAA settings\nconst float spanMax = 3.0;\nconst float reduceMult = (1.0/spanMax);\nconst float reduceMin = (1.0/48.0);\nconst float subPixelShift = (1.0/4.0);\n\nvec3 FXAA( vec2 uv2, sampler2D tex, vec2 rcpFrame) \n{\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + subPixelShift)));\n   \n    float lumaTopLeft = dot(textureLod(tex, uv.zw, 0.0).xyz, luma);\n    float lumaTopRight = dot(textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomLeft = dot(textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomRight = dot(textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaCenter  = dot(textureLod(tex, uv.xy, 0.0).xyz,  luma);\n\n    float lumaMin = min(lumaCenter, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));\n\n    vec2 direction;\n    direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));\n    direction.y =  ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));\n\n    float dirReduce = max(\n        (lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (0.25 * reduceMult),\n        reduceMin);\n    float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + dirReduce);\n    \n    direction = min(vec2( spanMax,  spanMax),\n          max(vec2(-spanMax, -spanMax),\n          direction * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + direction * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + direction * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// \"Airy disc\" bloom, complete gibberish and not based on anything physical; I just like the way it looks.\nvec4 getBloom(sampler2D sceneTexture, vec2 uv, vec2 resolution, float seed, float aspectRatio)\n{ \n    vec2 randomSeed = (uv*resolution * .152 + seed);\n    float random = hash12(randomSeed)*PI*2.0;\n\n    float stepsCenter = 7.0;\n    float stepsRing = 6.0;\n    float mipLevel = log2(resolution.x)/2.25;\n    vec4 outColor = vec4(0);\n    \n    float bloomSum = 0.0;\n    float weight = 0.0;\n    float totalBloom = 0.0;\n\n    vec2 radius = vec2(bloomRadius);\n    radius.y *= aspectRatio;\n\n    vec2 offsetUv = uv;\n    \n    for(float j = 1.0; j < (stepsCenter + 1.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsCenter + 1.0), 0.75))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 1.0;\n        \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsCenter), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    radius *= 2.0;\n    \n    for(float j = 2.0; j < (stepsRing + 2.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsRing + 2.0), 0.25))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 0.5;\n       \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsRing), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    return outColor/totalBloom;\n}\n\nvec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)\n{\n    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);\n    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);\n    \n    vec3 x = clamp(graded.xyz,0.0001,0.999);\n    \n    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);\n}\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * 2.5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * 2.5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "buffer_d_code": "// Bokeh with fake color fringing + autofocus, anamorphic (including realistic \"swirly\" artifacts near edges)\n//\n// Ended up quite hairy/hacky from to trying to avoid edge/background bleed artifacts, but works pretty well.\n// I originally wanted to do a separable version but didn't have enough buffers left, so it's fairly slow.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 randomSeed = (fragCoord * .152 + iTime * 1500. + iMouse.x);\n    float random = hash12(randomSeed)*PI*2.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float depth = textureLod(iChannel0, uv, 0.0).w*depthScale;\n        \n    // Autofocus\n    float focalDepth = texelFetch(iChannel1, ivec2(0), 0).w;\n    float focalDepthNew = min(min(min(textureLod(iChannel0, vec2(0.5, 0.25), 5.5).w*depthScale, textureLod(iChannel0, vec2(0.6, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.4, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.5, 0.5), 8.0).w*depthScale);\n    focalDepth = mix(focalDepth, focalDepthNew, 0.05);\n    \n    vec2 offsetUv = vec2(0);\n    vec4 foregroundColor = vec4(0);\n    vec4 backgroundColor = vec4(0);\n    vec4 midgroundColor = vec4(0);\n    vec4 midgroundColorNoFringe = vec4(0);\n    vec4 totalColor = vec4(0);\n    \n    const float steps = 32.0;\n    const float stepsSmooth = 24.0;\n    \n    vec2 radiusClamp = vec2(bokehClamp);\n    radiusClamp.y *= iResolution.x/iResolution.y;\n    \n    // Radius of circle of confusion based on depth at current pixel\n    vec2 trueRadius = vec2(bokehScale);\n    trueRadius.y *= iResolution.x/iResolution.y;\n    trueRadius *= 1.0-focalDepth/depth;\n  \n    vec2 erodedRadius = vec2(1);\n    vec2 smoothedRadius = vec2(0);\n    \n    const float additionalDilation = 1.25;\n    const float searchMipLevel = 0.0;\n    \n    // Preprocess, estimate kernel size etc.\n    for(float i = 0.0; i < stepsSmooth; i++)\n    {   \n        vec2 searchRadius = additionalDilation/**vec2(1.0/bokehAspectRatio, 1)*/*(radiusClamp*pow((i)/steps, 0.5));\n        offsetUv = uv + searchRadius*vec2(sin(i*goldenAngle/* + random*/), cos(i*goldenAngle/* + random*/));\n        \n        float depthGathered = textureLod(iChannel0, offsetUv, searchMipLevel).w*depthScale;\n\n        vec2 radiusGathered = vec2(bokehScale);\n        radiusGathered.y *= iResolution.x/iResolution.y;\n        radiusGathered *= 1.0-focalDepth/depthGathered;\n        \n        if(length(radiusGathered) >= length(radiusClamp))\n        {\n            radiusGathered = radiusClamp;\n        }\n        \n        smoothedRadius += abs(radiusGathered);\n        erodedRadius = min(abs(radiusGathered), erodedRadius);\n    }\n    smoothedRadius /= stepsSmooth;\n    \n    // Main blur\n    // Limited radius\n    vec2 radiusBias = vec2(bokehForceSharp);\n    radiusBias.y *= iResolution.x/iResolution.y;\n    vec2 radius = max(vec2(0), smoothedRadius-radiusBias);\n    radius /= (1.0-bokehForceSharp);\n    \n    float totalBlur = 0.0;\n    bool fringeValid = true;\n    \n    // Try to sample from lower-res mips to reduce noise, but don't want to go too low and introduce any visible blockiness\n    float mipLevel = min(max(log2(length(erodedRadius*iResolution.xy/3.0))+0.5, 0.0), max(log2(length(min(smoothedRadius, trueRadius)*iResolution.xy/3.0))-1.5, 0.0));   \n    mipLevel = min(mipLevel, 2.0);\n  \n    vec4 currentColor;\n    vec4 colorFringed;\n    float falloff = 1.0;\n    float vignette = 1.0;\n    if(length(radius) > 1.0/length(iResolution.xy))\n    {\n        for(float i = 0.5; i < steps; i++)\n        {   \n            vec2 offset = (radius*pow(i/steps, 0.5))*vec2(sin(i*goldenAngle + random), cos(i*goldenAngle + random));\n            \n            // \"Swirly\" bokeh\n            offset *= ROT(atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)-PI);\n            if(offset.y >= radius.y-3.0*(radius.y)*distance(uv, vec2(0.5)))\n            {\n                vignette = saturate(offset.y - (radius.y-3.0*(radius.y)*distance(uv, vec2(0.5))));\n                vignette = saturate(1.0 - 0.8*vignette/radius.y);\n                vignette = saturate(0.0001 + vignette);\n                offset.y /= 1.0+saturate(1.0-vignette)/2.0;\n                \n            }\n            offset *= ROT(-atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)+PI);\n\n            offset *= vec2(1.0/bokehAspectRatio, 1);\n            \n            offsetUv = uv + offset;\n\n            falloff = ((i+1.0)/steps);\n\n            // Using dilated depth to reduce bleed\n            float depthGathered = textureLod(iChannel2, offsetUv, 0.0).w*depthScale;\n\n            vec2 radiusGathered = vec2(bokehScale);\n            radiusGathered.y *= iResolution.x/iResolution.y;\n            radiusGathered *= 1.0-focalDepth/depthGathered;\n            radiusGathered *= vec2(1.0/bokehAspectRatio, 1);\n          \n            float distanceFromCenter = distance(offsetUv, uv);\n\n            if((depthGathered > depth && length(trueRadius) < bokehScale/6.0 /*&& length(radiusGathered) > length(trueRadius)*/))\n            {\n                float factor = smoothstep(bokehScale/80.0, bokehScale/6.0, length(trueRadius));\n                offsetUv = mix(uv, offsetUv, factor);\n            }\n            float curMipLevel = mipLevel;\n            currentColor = textureLod(iChannel0, offsetUv, mipLevel);\n            colorFringed = currentColor * 12.1*vec4(1.0, 0.16, 0.3, 1.0) * HUE(mod((0.2 + 0.3*float(i)/float(steps-1.0)), 1.0)) * falloff;\n            totalBlur += 1.0*vignette;\n\n            // Is the sample we gathered at a depth such that it would actually be scattered onto the current pixel?\n            if((length(radiusGathered) < distanceFromCenter*0.66))\n            {\n                fringeValid = false;\n                currentColor = vec4(0,0,0,1);\n                colorFringed = vec4(0,0,0,1);\n                totalBlur -= 1.0*vignette;\n            }\n             \n            midgroundColor += mix(currentColor, colorFringed, bokehFringe)*vignette;\n            midgroundColorNoFringe += currentColor*vignette;\n        }\n        // If we rejected some samples, the color fringe would become biased\n        if(!fringeValid)\n        {\n            midgroundColor = midgroundColorNoFringe;\n        }\n        else\n        {\n            midgroundColor = mix(midgroundColorNoFringe, midgroundColor, smoothstep(0.0, 4.0/length(iResolution.xy), length(radius)));\n        }\n        if(totalBlur > 0.0)\n        {\n\t        midgroundColor /= totalBlur;\n        }\n        else\n        {\n            midgroundColor = textureLod(iChannel0, uv, 0.0);\n        }\n    }\n    else\n    {\n        midgroundColor = textureLod(iChannel0, uv, 0.0);\n        // For debugging\n        //midgroundColor = vec4(1,0,0,1)*textureLod(iChannel0, uv, 0.0)*steps;\n    }\n    \n    totalColor += midgroundColor;\n    \n    // Bloom\n    totalColor += bloomIntensity*getBloom(iChannel0, uv, iChannelResolution[0].xy, mod(iTime*13.8 + iMouse.x, 1024.0), bokehAspectRatio*iResolution.x/iResolution.y);\n    \n    // Auto exposure\n    float exposure = texelFetch(iChannel1, ivec2(1, 0), 0).w;\n    float exposureNew = length(textureLod(iChannel0, vec2(0.5, 0.5), 8.0).rgb)*3.0 + 0.5;\n    exposure = mix(exposure, exposureNew, 0.05);  \n    exposure = max(exposure, 0.0) + 0.001;\n    totalColor /= exposure;\n\n    float outAlpha = 0.0;\n    \n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store focal depth\n        fragColor.w = focalDepth;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Store exposure\n        fragColor.w = exposure;\n        return;\n    }\n    \n    fragColor = vec4(totalColor.rgb, fragColor.w);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 416, 442, 442, 542]], "test": "untested"}
{"id": "flGSDy", "name": "Molecule", "author": "wyatt", "description": "Fractal with interference pattern", "tags": ["interference"], "likes": 6, "viewed": 276, "published": 3, "date": "1641278218", "time_retrieved": "2024-07-30T17:12:06.547836", "image_code": "// Fork of \"Microscopy 101\" by wyatt. https://shadertoy.com/view/NlKSzG\n// 2022-01-04 06:32:20\n\n\nMain \n{\n    R = iResolution.xy;T = iTime;\n    Q.x = length(A(U).xy);\n    Q.y = length(B(U).xy);\n    Q.z = length(C(U).xy);\n    Q /= float(iFrame);\n    //Q = map(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Wavelength\n#define H 8.\n//Brightness\n#define F 70.\n// Iterations\n#define I 20.\n\n\n// Window of Samples\n#define W .2*R.y\n// Number of Samples\n#define N 15.\n\n\n\n\nvec2 R;\nfloat T;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159265359\n#define _sin(a) sin(mod(a,2.*pi))\n#define _cos(a) cos(mod(a,2.*pi))\nvec4 map (vec2 u) {\n    u = 1.1*(u-.5*R)/R.y;\n    vec4 c = vec4(0);\n    float j = 0.;\n    for (float i = 1.; i < I; i++)\n    {\n        float d = length(u)-.2;\n        c += .02/i/i*exp(-1e2*d*d)*(.5+.5*\n            sin(2.+i+vec4(1,2,3,4))\n        );\n        u.x = abs(u.x);\n        u -= vec2(.6,0);\n        u = 2.4*vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y);\n        if (length(u)>4.)break;\n    }\n    return F*c;\n}\n// Dave H\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n", "buffer_a_code": "Main \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q = A(U);\n    vec3 eye = vec3(U,R.y);\n    for (float i = 0.; i<N; i++)\n    {\n        vec2 v = U+H*(hash22(vec2(i,iFrame))-.5);\n        vec4 m = map(v);\n        vec3 u = vec3(v,m.x);\n        float l = W*(length(eye-u));\n        Q.xy += vec2(_cos(l),_sin(l))/N;\n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q = A(U);\n    vec3 eye = vec3(U,R.y);\n    for (float i = 0.; i<N; i++)\n    {\n        vec2 v = U+H*(hash22(vec2(i,iFrame))-.5);\n        vec4 m = map(v);\n        vec3 u = vec3(v,m.y);\n        float l = W*(length(eye-u));\n        Q.xy += vec2(_cos(l),_sin(l))/N;\n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q = A(U);\n    vec3 eye = vec3(U,R.y);\n    for (float i = 0.; i<N; i++)\n    {\n        vec2 v = U+H*(hash22(vec2(i,iFrame))-.5);\n        vec4 m = map(v);\n        vec3 u = vec3(v,m.z);\n        float l = W*(length(eye-u));\n        Q.xy += vec2(_cos(l),_sin(l))/N;\n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flySWy", "name": "Fractal Night", "author": "oneshade", "description": "WOW (look around with the mouse, change parameters)\nExperimenting with this crazy fractal I discovered ---> [url=https://www.shadertoy.com/view/ssVXDm]https://www.shadertoy.com/view/ssVXDm[/url]", "tags": ["fractal", "psychedelic", "abstract", "vangogh"], "likes": 12, "viewed": 397, "published": 3, "date": "1641274255", "time_retrieved": "2024-07-30T17:12:13.084359", "image_code": "#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Please tell me if it would be better to comment this out by default\n// I tried prerendering it in Cubemap A but I couldn't get the right look\n#define AA\n\n// Time freeze\n#define iTime 9.73\n\n// vec4(a, b, c, d) = a + bi + cj + dk\nvec4 qmul(in vec4 p, in vec4 q) {\n    return vec4(p.x * q.x - p.y * q.y - p.z * q.z - p.w * q.w,\n                p.x * q.y + p.y * q.x + p.z * q.w - p.w * q.z,\n                p.x * q.z - p.y * q.w + p.z * q.x + p.w * q.y,\n                p.x * q.w + p.y * q.z - p.z * q.y + p.w * q.x);\n}\n\nvec4 qconj(in vec4 p) {\n    return vec4(p.x, -p.yzw);\n}\n\nvec4 qinv(in vec4 q) {\n    return qconj(q) / dot(q, q);\n}\n\nvec3 qNewton(in vec4 q) {\n    vec4 a = vec4(1.5 + 0.1 * cos(iTime) + 0.01, 2.0, 1.0, 0.25);\n    vec4 b = vec4(-1.0, 0.65 + 0.1 * sin(iTime), 2.0 + 0.1 * sin(2.0 * iTime - 0.2), -0.1);\n    vec4 c = vec4(-1.2, 1.25, 1.5, 1.3 + cos(0.5 * iTime + 0.1));\n\n    for (int i=0; i < 100; i++) {\n        vec4 qa = q - a, qb = q - b, qc = q - c;\n        vec4 f = qmul(qa, qmul(qb, qc));\n        vec4 df = qmul(qa + qb, qc) + qmul(qa, qb);\n        q -= qmul(f, qinv(df));\n    }\n\n    return 0.5 * vec3(q.x, mix(q.y, q.w, 0.8), q.z);\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(-0.39, -0.02);\n    mouse *= PI;\n\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    //fragColor += texture(iChannel0, vec2(atan(rd.z, rd.x), atan(rd.y, length(rd.xz))) / vec2(TAU, PI) + 0.5);\n    float norm10 = pow(pow(abs(rd.x), 10.0) + pow(abs(rd.y), 10.0) + pow(abs(rd.z), 10.0), 0.1);\n    fragColor.rgb += qNewton(10.0 * vec4(rd / norm10 * 1.5, sin(iTime)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n\n    #ifdef AA\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.0, 0.5));\n    render(fragColor, fragCoord + 0.5);\n    fragColor /= 4.0;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flySWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 283, 316, 316, 571], [573, 573, 596, 596, 628], [630, 630, 652, 652, 687], [689, 689, 714, 714, 1209], [1211, 1211, 1265, 1265, 2019], [2021, 2021, 2076, 2076, 2329]], "test": "untested"}
{"id": "NtGXDG", "name": "Night Escape", "author": "wyatt", "description": "Sometimes sophia lets me leave at night.", "tags": ["fbm"], "likes": 44, "viewed": 800, "published": 3, "date": "1641272883", "time_retrieved": "2024-07-30T17:12:14.013874", "image_code": "Main \n\n U = 2.*(U-.5*R)/R.y;\n float d = 1.+1.9*(U.y);\n vec2 u = U*3./d;\n if (d<0.) {\n    u=-u;\n    u.x += 5.*(fbm(.1*u)*2.-1.);\n    u.y += 5.*(fbm(.01*u)*2.-1.);\n    U.x += .2*(fbm(.03*u+.01*T)*2.-1.);\n    U.y += .5*(fbm(.01*u)*2.-1.);\n }\n d = abs(d);\n u.x += sin(u.y);\n float cloud = clamp(1.-.01*(pow(5.*fbmt(10.+u+.01*T),3.)),0.,1.);\n float night = .8*clamp(.5-.05*u.x,0.,1.);\n float stars = .5+.5*clamp(2e6*pow(fbm(29.*u),15.),0.,1.);\n vec4 sunset = .2+.5*sin(-.9-.1*u.y+2e-2*u.x+vec4(1,2,3,4));\n sunset = mix(sunset,2.-2.*vec4(stars),night);\n Q = mix(vec4(exp(-.01*u.x*u.x)),sunset,cloud);\n float mountain = 17.*pow(fbm(vec2(10.+.05*U.x,0)),7.);\n Q *= vec4(1.-step(d-mountain,0.));\n}", "image_inputs": [], "common_code": "vec2 R; float T; int I;\n#define Main void mainImage(out vec4 Q, in vec2 U) {R = iResolution.xy; T = iTime; I = iFrame;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbmt (vec2 p) {\n    float w = 0.;\n    #define N 11.\n    for (float i = 0.; i < N; i++)\n    {\n        p *= 1.7*ei(1e-3*T);\n        w += noise(p)/N;\n    }\n    return w;\n}\nfloat fbm (vec2 p) {\n    float w = 0.;\n    #define N 11.\n    for (float i = 0.; i < N; i++)\n    {\n        p *= 1.7*ei(.5);\n        w += noise(p)/N;\n    }\n    return w;\n}\nvec4 pw (vec4 p, float a) {\n    return vec4(pow(p.x,a),pow(p.y,a),pow(p.z,a),pow(p.w,a));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlGSWG", "name": "Static Spiral thing", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 12, "viewed": 300, "published": 3, "date": "1641260189", "time_retrieved": "2024-07-30T17:12:14.938402", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec4 col = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    float x = length(col.xyz);\n    \n    vec3 e = vec3(1.);\n    vec3 col2 = 2. * col.xyz * pal(mix(0.31, 0.97, 0.5 + 0.5 * thc(100000., x + 2. * length(uv) - iTime)), e, e, e, vec3(0., 0.33, 0.66));\n    fragColor = vec4(col2, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvec2 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    ivec2 px = ivec2(fragCoord);\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    vec2 p = Cell(px);\n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        fragColor = vec4(0.);\n        p = vec2(0.5,0.5);\n        //return;\n    } \n    \n    vec2 ipos = floor(sc * uv);\n    \n    float h = h21(uv);\n    float m = 2. / iResolution.y;\n    float th = iTime - 8. * log(r) + 0.1 * pi * thc(4., 20. * a + iTime);//0.1 * pi * thc(1., 4. * r + iTime);//2. * pi * h21(vec2(0.01 * iTime)); // not perfect\n    vec2 b = vec2(thc(12., th), ths(12., th));\n    \n    vec2 p2 = p + m * b;\n   // p2 = clamp(p2, vec2(0.), vec2(1.));\n    fragColor = vec4(p2.xy, 0., 1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define sc 10.\n\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "buffer_b_code": "#define KEYBOARD iChannel2\n#define KEY_RESET 82\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 ipos = floor(sc * uv)/sc;\n\n    vec2 p = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xy - 0.5;\n    \n    if (key_down(KEY_RESET)) {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    float r = 0.5;\n    float d = length(uv-p);\n    float k = 0.1 + d;\n\n    float s = step(d, 0.005);// + 0.05 * thc(4., 10. * length(p) - iTime));\n    s = smoothstep(-k, k, -d + 0.);\n    float x = texelFetch( iChannel1, ivec2(fragCoord), 0 ).x;\n    //s = 4. * s * s * s;\n    //col *= 0.995;\n    //col = max(0., col - 0.001);\n\n    vec3 e = vec3(1.);\n    x = clamp(x, 0., 1.);\n    vec3 col = max(vec3(x), clamp(2. * s, 0., 1.));//* pal(1.+ 0. * iTime, e, e, e, vec3(0., 0.33, 0.66)));\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 417]], "test": "untested"}
{"id": "ftySRt", "name": "2D Wave Lattice", "author": "oneshade", "description": "Weird wave patterns.", "tags": ["2d", "waves", "quasiquasicrystal", "lattice"], "likes": 23, "viewed": 276, "published": 3, "date": "1641258502", "time_retrieved": "2024-07-30T17:12:15.826028", "image_code": "#define TAU 6.28318530718\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float n = 5.0;\n    for (float a=0.0; a < TAU; a += TAU / n) {\n        vec2 dir = vec2(cos(a), sin(a));\n        color += sin(dot(uv, dir) * TAU * 6.0 + iTime + a);\n    }\n\n    fragColor = vec4(0.5 + 0.5 * color / n, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftySRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 81, 81, 402]], "test": "untested"}
{"id": "7tKSzt", "name": "Parabola with Focal Point", "author": "Yusef28", "description": "Experimenting with text and parabolas\nMouse Enabled", "tags": ["intersection", "x", "quadratic", "y0"], "likes": 5, "viewed": 270, "published": 3, "date": "1641246573", "time_retrieved": "2024-07-30T17:12:16.834334", "image_code": "vec2 numToCoord(float a){\n    return vec2( mod(a,16.), 15.-floor(a/16.) );\n}\n\nvec3 C(vec2 uv, vec2 start, inout float moveX,float num){\n    moveX -= STEP_SIZE/2.;\n    if(uv.x < start.x           || \n       uv.x > start.x+STEP_SIZE || \n       uv.y < start.y           || \n       uv.y > start.y+STEP_SIZE){\n       \n       return vec3(0.);\n    }\n    \n    uv -= start; uv /= STEP_SIZE; uv *= LETTER_SIZE;\n    uv += vec2(LETTER_SIZE*numToCoord(num));\n    return textureGrad(iChannel1,uv,dFdx(uv),dFdy(uv)).rrr;\n}\n\n//takes a float and prints the first 4 digits\nvoid generateDigits(vec2 uv, vec2 start, float moveX, \n                     float theNumber, float theSign, inout vec3 col){\n    \n    float s = 1.;\n    float count = 0.;\n    \n    float FN = fract(theNumber)*100.;\n    float ones = floor(mod(FN,10.));\n    //after decimal\n    col += C(uv, vec2(moveX,start.y), moveX, FIRST_NUMBER + ones);\n    float tens = floor(FN/10.);\n    col += C(uv, vec2(moveX,start.y), moveX, FIRST_NUMBER + tens);\n    //decimal point\n    col += C(uv, vec2(moveX,start.y), moveX, FIRST_NUMBER -2.);\n    FN = floor(theNumber);\n    //before decimal\n    while(FN >= 1.){\n        float n = floor(mod(FN,10.));\n        col += C(uv, vec2(moveX,start.y), moveX, FIRST_NUMBER + n);\n        FN /= 10.;\n    }\n    \n    col += C(uv, vec2(moveX,start.y), moveX, FIRST_NUMBER -3. -2.*step(0.,theSign));\n    \n}\n\nfloat parabolaX(vec2 vx, vec2 p, vec2 uv, float fp){\n    float y = (pow(uv.x-vx.x,2.) / 4.* fp) - vx.y;\n    return 1.0-smoothstep(0.02,0.15,abs(y-uv.y)/fwidth(y-uv.y)/20.);\n}\n/*\nfloat parabolaY(vec2 vx, vec2 p, vec2 uv, float fp){\n    float x = (pow(uv.y-vx.y,2.) / 4.* fp) - vx.x;\n    return 1.0-smoothstep(0.02,0.15,abs(x-uv.x)/fwidth(x-uv.x)/20.);\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = grid(uv,texture(iChannel0,uv).x);\n    float scale = 8.;\n    uv *= scale;\n    float fp = iMouse.z > 0.5 ? \n               (scale*iMouse.y/iResolution.y)-scale*0.5 : \n               sin(iTime)*3.5;\n    \n    float parabola = parabolaX(vec2(0.0), vec2(1.), uv, fp);\n    col = mix(col, vec3(1.,.2,0.5), parabola);\n    vec2 focalPoint = vec2(0.,fp);\n    \n    //intersection point 2\n    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-focalPoint)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-focalPoint)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n    uv = fragCoord/iResolution.xy;\n    float moveX = 0.;\n    float level = fp/8.+0.47;\n    //col += texture(iChannel1,uv).xxx;\n    generateDigits(uv, vec2(0.,level), 0.93, abs(fp), sign(fp), col);\n    f = 1.0-smoothstep(0.01,0.05,abs(level-uv.y)/fwidth(level-uv.y)/20.);\n    col = mix(col, vec3(1.,0.7,0.), f*step(0.6,uv.x));\n    \n    \n    fragColor = vec4(col*vig(fragCoord/iResolution.xy),1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LETTER_SIZE 1./16.\n#define STEP_SIZE 1./15.\n#define FIRST_LETTER 64.\n#define FIRST_NUMBER 48.\n\n#define _a 1.\n#define _b 2.\n#define _c 3.\n#define _d 4.\n#define _e 5.\n#define _f 6.\n#define _g 7.\n#define _h 8.\n#define _i 9.\n#define _j 10.\n#define _k 11.\n#define _l 12.\n\n#define _m 13.\n#define _n 14.\n#define _o 15.\n#define _p 16.\n#define _q 17.\n#define _r 18.\n#define _s 19.\n#define _t 20.\n#define _u 21.\n#define _v 22.\n#define _w 23.\n#define _x 24.\n#define _y 25.\n#define _z 26.\n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIGN         //\n      //                                   //\n      /////////////////////////////////////\n      \nvec3 grid(vec2 uv, float tex)\n{\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    return col;\n}\n\nfloat vig(vec2 uv){\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    return pow(vig, 0.15);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 76], [78, 78, 135, 135, 507], [509, 555, 679, 679, 1371], [1373, 1373, 1425, 1425, 1547], [1548, 1729, 1786, 1838, 2907]], "test": "untested"}
{"id": "stVSzt", "name": "Bokeh Fractal", "author": "wyatt", "description": "looped a dragon with bokeh disks", "tags": ["ifs"], "likes": 26, "viewed": 552, "published": 3, "date": "1641242231", "time_retrieved": "2024-07-30T17:12:18.077010", "image_code": "Main \n    Q = vec4(0.);\n    vec3 u;\n    vec4 c;\n    U = (U-.5*R)/R.y;\n    for (float i = 0.; i < N; i++)\n    {\n        u = A(vec2(i+.5,.5)).xyz;\n        c = B(vec2(i+.5,.5));\n        float d = .2*abs(u.z);\n        float l = (length(u.xy-U)-d);\n        Q += c*(smoothstep(1e-2,0.,l)+.5*exp(-1e4*l*l))/(1.+400.*d);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) {R=iResolution.xy,T=iTime;\n\n#define D 9. \n#define N exp2(D)\n\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid shape (in float i, out vec3  u, out vec4 c) \n{\n    u = vec3(0);\n    c = vec4(0);\n    float r = .1;\n    for (float j = 0.; j < D; j++) {\n         float a = mod(i,2.)*2.-1.;\n         c += .2*sin(1.3*a+vec4(1,2,3,4));\n         u.xy  *= ei(-a+.001*T);\n         u.xz *= ei(.2+.1*sin(.31*T));\n         u.y += r;\n         u.x -= a*r;\n         r *= .5;\n         i = floor(i/2.);\n    }\n    u.xz  *= ei(.174*T);\n    u *= 2.5;\n}", "buffer_a_code": "Main\n\n    vec3 u;\n    float i = floor(U.x);\n    shape(i,u,Q);\n    \n    Q.xyz = u;\n\n}", "buffer_a_inputs": [], "buffer_b_code": "Main\n\n    vec3 u;\n    float i = floor(U.x);\n    shape(i,u,Q);\n    \n    //Q.xyz = u;\n\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7lVXRt", "name": "DeathStar - distance 3D", "author": "iq", "description": "Exact distance to a sphere cut by another sphere. Basically a revolution operator ([url]https://www.shadertoy.com/view/4lyfzw[/url]) applied to a moon ([url]https://www.shadertoy.com/view/WtdBRS[/url])", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "sphere", "sphere", "primitives", "cut"], "likes": 33, "viewed": 4260, "published": 3, "date": "1641238198", "time_retrieved": "2024-07-30T17:12:18.843959", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a sphere cut by another sphere. Note\n// that doing the boolean subtration of a sphere from another\n// sphere using max() won't produce a correct Euclidean distance\n// than cab be used for rounding. This shape is basically a\n// revolution operator (https://www.shadertoy.com/view/4lyfzw)\n// applied to a moon (https://www.shadertoy.com/view/WtdBRS)\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p2, in float ra, float rb, in float d )\n{\n    vec2 p = vec2( p2.x, length(p2.yz) );\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( p.x*b-p.y*a > d*max(b-p.y,0.0) )\n    {\n        return length(p-vec2(a,b));\n    }\n    else\n    {\n        return max( (length(p          )-ra),\n                   -(length(p-vec2(d,0))-rb));\n    }\n}\n\nfloat map( in vec3 pos )\n{\n    float ra = 0.5;\n    float rb = 0.35+0.20*cos(iTime*1.1+4.0);\n    float di = 0.50+0.15*cos(iTime*1.7);\n    return sdDeathStar(pos, ra, rb, di );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.003, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 1.0*sin(0.38*iTime+3.0);\n\tvec3 ro = vec3( 1.0*cos(an), -0.1, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.57703);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXRt.jpg", "access": "api", "license": "mit", "functions": [[1574, 1669, 1737, 1737, 2070], [2072, 2072, 2098, 2098, 2248], [2250, 2295, 2382, 2382, 2641], [2643, 2689, 2721, 2721, 2960]], "test": "untested"}
{"id": "7tVXRt", "name": "CutHollowSphere - distance 3D", "author": "iq", "description": "Exact distance to a hollow sphere cut by a plane. Basically a revolution operator ([url]https://www.shadertoy.com/view/4lyfzw[/url]) applied to a 2D arc ([url]https://www.shadertoy.com/view/wl23RK[/url])", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "sphere", "sphere", "primitives", "cut"], "likes": 36, "viewed": 2879, "published": 3, "date": "1641238193", "time_retrieved": "2024-07-30T17:12:19.741559", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a hollow sphere cut by a plane. Basically a\n// revolution operator (https://www.shadertoy.com/view/4lyfzw)\n// applied to a 2D arc (https://www.shadertoy.com/view/wl23RK)\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat map( in vec3 pos )\n{\n    pos.xy = (mat2(3,4,-4,3)/5.0)*pos.xy;\n    float r = 0.5;\n    float h = 0.2 + 0.2*cos(iTime*1.0);\n    float t = 0.01;\n    return sdCutHollowSphere(pos, r, h, t );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = sin(0.2*iTime);\n\tvec3 ro = vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.57703);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVXRt.jpg", "access": "api", "license": "mit", "functions": [[1396, 1470, 1532, 1532, 1716], [1718, 1718, 1744, 1744, 1912], [1914, 1959, 2046, 2046, 2304], [2306, 2352, 2384, 2384, 2623]], "test": "untested"}
{"id": "slKSRt", "name": "Clelia Curve2", "author": "NinjaKoala", "description": "Another try at rendering a 3D parametric curve. Still not perfectly glitch free.\n(See https://www.shadertoy.com/view/NlVSDz for the previous try and header comment for details)", "tags": ["3d", "distance", "curve", "newton", "parametric"], "likes": 3, "viewed": 244, "published": 3, "date": "1641235204", "time_retrieved": "2024-07-30T17:12:20.634173", "image_code": "/*\nFollowup to https://www.shadertoy.com/view/NlVSDz\n\nIn a first step, parameter values are found such that\nthe corresponding points on the curve have exactly the distance\ncurve_width to the ray.\n\nThis is done using Newton's method.\n\nOf these, the parameter value which corresponds to\nthe point nearest to the camera is taken.\n\nIn a second step, this parameter value is altered by another iteration\nmethod which finds the point on the curve which is nearest to the ray.\n(It finds the local minimal distance, which is why it can't get to the wrong branch of the curve.)\n\nThe idea is that the first iteration finds out which branch of the curve is hit first,\nand gets a parameter value that is only slightly off from that which we actually want,\nwhich is then found by the second iteration.\n\nI haven't thorougly compared the performance of this method to other methods\n(Raymarching with line segments or bezier segments approximation\nor directly raymarching with the used distance approximation),\nmaybe i will do this later on.\n*/\n\nconst float pi=3.1415925;\n\nconst int num_iterations=6;\nconst int num_start_params=32;\n\nconst int marching_steps=10;\nconst int num_iterations2=3;\n\nconst float curve_width_sq=.003;\nconst float eps=.0001;\n\nconst int clelia_fac1=1;\nconst int clelia_fac2=4;\n\nconst float radius=1.;\n\nconst float rotation_speed=.5;\n\n//#define SHOW_PARAMETER\n\n\nconst float clelia_fac=float(clelia_fac1)/float(clelia_fac2);\nconst float clelia_period=float(clelia_fac2)*2.*pi;\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(float x){\n\treturn vec3(spectral(x),spectral(x+pi/2.),spectral(x-pi));\n}\n\nmat2 rot(float t){\n\treturn mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 parametric(float t){\n\t//clelia curve\n\tt*=clelia_period;\n\tvec3 p = radius*vec3(cos(t)*cos(clelia_fac*t),cos(t)*sin(clelia_fac*t),sin(t));\n    p.yz*=rot(mod(rotation_speed*iTime,2.*pi));\n\treturn p;\n}\n\nvec3 parametric_diff(float t){\n\t//clelia curve\n\tt*=clelia_period;\n\tvec3 p = clelia_period*radius*vec3(-clelia_fac*cos(t)*sin(clelia_fac*t)-sin(t)*cos(clelia_fac*t),\n\t                                   clelia_fac*cos(t)*cos(clelia_fac*t)-sin(t)*sin(clelia_fac*t),\n\t                                   cos(t));\n\n    p.yz*=rot(mod(rotation_speed*iTime,2.*pi));\n\treturn p;\n}\n\nfloat parametric_normal_iteration3d(float t, vec3 p0){\n\tvec3 p0_to_p=parametric(t)-p0;\n\tvec3 tang=parametric_diff(t);\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,p0_to_p)/l_tang;\n}\n\nfloat ray_to_curve_dis_sq(vec3 ro, vec3 rd, float t0){\n\tvec3 p0=parametric(t0);\n\tfloat s0=dot(p0-ro,rd);\n\tvec3 p1=ro+s0*rd-p0;\n\treturn dot(p1,p1);\n}\n\nfloat ray_to_curve_dis_sq_diff(vec3 ro, vec3 rd, float t0){\n\tvec3 p0=parametric(t0);\n\tvec3 p0_diff=parametric_diff(t0);\n\tfloat s0=dot(p0-ro,rd);\n\tvec3 p1=ro+s0*rd-p0;\n\treturn 2.*dot(p1,dot(p0_diff,rd)*rd-p0_diff);\n}\n\nbool parametric_curve_newton_trace(vec3 ro, vec3 rd, out vec3 p0, out vec3 nor, out float t1){\n\n\tfloat t0=0.;\n\tfloat d0=1e38;\n\tt1=1e38;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tfloat t=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt-=(ray_to_curve_dis_sq(ro,rd,t)-curve_width_sq)/ray_to_curve_dis_sq_diff(ro,rd,t);\n\t\t}\n\t\tvec3 p1=parametric(t);\n\n\t\tfloat d1=dot(p1-ro,rd);\n\n\t\tif(abs(ray_to_curve_dis_sq(ro,rd,t)-curve_width_sq)<eps && d1<d0){\n\t\t\tt1=t;\n\t\t\td0=d1;\n\t\t}\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\tif(t1!=1e38){\n\t\tvec3 p1=ro+d0*rd;\n\t\tfor(int i=0;i<marching_steps;i++){\n\t\t\tfor(int j=0;j<num_iterations2;j++){\n\t\t\t\tt1=parametric_normal_iteration3d(t1,p1);\n\t\t\t}\n\n\t\t\tp0=parametric(t1);\n\t\t\td0=dot(p0-ro,rd);\n\t\t\tp1=ro+d0*rd;\n\t\t}\n\n\t\tp1-=rd*sqrt(curve_width_sq-dot(p1-p0,p1-p0));\n\t\tnor=normalize(p1-p0);\n\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, 3);\n    vec3 rd = normalize(vec3(uv, 0.) - vec3(0,0,1));\n\n\tvec3 nor, p0;\n\tfloat t0;\n\n\tbool hit = parametric_curve_newton_trace(ro,rd,p0,nor,t0);\n\n    if(hit){\n        vec3 light = vec3(0, 1, 4);\n        \n        float dif = clamp(dot(nor, normalize(light - p0)), 0., 1.);\n        dif *= 5. / dot(light - p0, light - p0);\n        \n\t\t#ifdef SHOW_PARAMETER\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1)*vec4(to_col(t0*2.*pi),1);\n\t\t#else\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1);\n\t\t#endif\n    }\n    else{\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1482, 1482, 1506, 1506, 1582], [1584, 1584, 1605, 1605, 1667], [1669, 1669, 1687, 1687, 1733], [1735, 1735, 1760, 1776, 1937], [1939, 1939, 1969, 1985, 2308], [2310, 2310, 2364, 2364, 2496], [2498, 2498, 2552, 2552, 2646], [2648, 2648, 2707, 2707, 2863], [2865, 2865, 2959, 2959, 3712], [3714, 3714, 3770, 3770, 4469]], "test": "untested"}
{"id": "NlVSzd", "name": "growing circles", "author": "avin", "description": "growing circles", "tags": ["circles", "radial"], "likes": 8, "viewed": 361, "published": 3, "date": "1641231840", "time_retrieved": "2024-07-30T17:12:21.566680", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;     \n    \n    float l = length(uv);\n    \n    float t = iTime;\n    float d = floor(l*10. - t)/10. + t/10. + l/3.;\n   \n    vec3 col = vec3(1. - d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 302]], "test": "untested"}
{"id": "NlVXRd", "name": "transparency and shading test", "author": "terraquoia", "description": "Experimenting with some ideas. NOT optiimized.\nTests :\n- combo sphere and rounded box with smoothmin\n- combo transparency with purpose made raymarcher and a reflection from source shader\n- added hash13() pseudo-rnd func to raymarcher to avoid banding", "tags": ["transparency", "cube", "sphere", "shading", "smoothmin"], "likes": 2, "viewed": 285, "published": 3, "date": "1641229467", "time_retrieved": "2024-07-30T17:12:22.462285", "image_code": "/*\nmodified version of\n\nhttps://www.shadertoy.com/view/Xtd3z7\n\nmade by jlfwong\n\nit is a mess and not a priority. i'm publishing this modification so others can take a look at and use it.\nthere are other pieces of code borrowed from other shaders. not much of this is my \"original code\" :)\nthus same GPL/MIT freedom to use parts of this code applies.\n\nto reiterate in more detail from my comment box:\n- sphere and rounded box SDFs are animated by altering input point for box and radius for sphere\n- combined a sphere and a rounded edge box with smoothmin function smin() to form a metaball-like geometry\n- added transparency with a dedicated volume raymarcher\n- added hash13() pseudo-random function into volume raymarcher to avoid banding\n- combined the transparency with lighting code from source shader producing a nice surface reflection\n\ntake this apart, shut off parts of code, change parameters and generally have fun !\n*/\nconst int MAX_MARCHING_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 1e-2; // could go finer but artefacts show up, related to marching steps.\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sceneSDF(vec3 samplePoint)\n{\n    float d = sdRoundBox(samplePoint-vec3(cos(iTime)*2.2,sin(iTime)*1.5,0.0), vec3(0.8), .1);\n    //last parameter 1.1 is smoothing factor. larger value = bigger \"weld\" between two SDFs\n    d = smin(sdSphere(samplePoint,cos(iTime)*0.3+0.6), d, 1.1);\n    return d;\n}\n\nvec4 applyFog(vec3 originalRGB,float dist)\n{\n    float b = .1;\n\tfloat c = .6 / b;\n\tfloat fogAmount = (1.0 - exp(-dist * b));\n\tvec3 fogColor = vec3 (0.5, 0.6, 0.7);\n\treturn vec4(mix(originalRGB, fogColor, fogAmount), fogAmount);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 rayMarchVolumetric (vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    float entry = 0.0;\n    float exit = 0.0;\n    //find closest point\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        float d = sceneSDF(p);\n        if (d < EPSILON)\n        {\n            entry = depth;\n            break;\n        }\n        depth += d;\n    }\n    //if closest point beyond draw limit, exit with blank\n    if (depth > MAX_DIST) return vec4(0.0, 0.0, 0.0, 0.0);\n    //now find farthest point by working backwards until surface hit from behind\n    depth = MAX_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        float d = sceneSDF(p);\n        if (d < EPSILON)\n        {\n            exit = depth;\n            break;\n        }\n        depth -= d;\n    }\n    float occlusion = 0.0;\n    depth = entry; //starting position\n    // depth step. take difference between closest and farthest points and slice it up into 20 segments\n    float dstep = abs(exit - entry) / 20.0;\n    int sanity = 0; //always but ALWAYS have this in your loops. else you may crash the machine :)\n    float occlusion_offsetted = 0.0;\n    //collect occlusion along the ray\n    while (depth <= exit && occlusion < 0.95) // occlusion capped to 0.95 so some transparency is always present\n    {\n        if (sanity++ > 100) break;\n        vec3 p = ro + depth * rd;\n        float d = sceneSDF(p);\n        if (d < EPSILON)\n        {\n            occlusion += dstep * hash13(p);\n            // slightly offsetted. note that offset will be relative to scene size (or total space being rendered)\n            occlusion_offsetted += dstep * hash13(p+vec3(1e-2, 1e-2,1e-2));\n        }\n        depth += dstep;// * hash13(p);\n    }\n    vec3 origColor = vec3(0.1, 0.2, 0.3);\n    //reuse existing variable. basically take average of the two samples\n    occlusion = occlusion + occlusion_offsetted / 2.0;\n    //now feed in the difference between closest and farthest points\n    return applyFog(origColor, occlusion);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON)\n        {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),        \n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0)\n    {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0)\n    {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    //fragColor = vec4(color, 1.0);\n\n    vec4 color2 = rayMarchVolumetric (eye, worldDir);\n    \n    fragColor = vec4(mix(color2.xyz, color, color2.w), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVXRd.jpg", "access": "api", "license": "gpl-1.0-plus", "functions": [[1119, 1119, 1154, 1154, 1178], [1180, 1180, 1225, 1225, 1316], [1318, 1318, 1357, 1357, 1448], [1450, 1450, 1484, 1484, 1750], [1752, 1752, 1796, 1796, 1981], [1983, 1983, 2006, 2006, 2109], [2111, 2111, 2155, 2155, 4157], [4159, 4159, 4250, 4250, 4576], [4590, 4590, 4655, 4655, 4787], [4789, 4789, 4818, 4818, 5136], [5138, 5630, 5744, 5744, 6342], [6344, 6714, 6799, 6799, 7599], [7601, 7928, 7977, 8012, 8238], [8240, 8240, 8296, 8296, 9272]], "test": "untested"}
{"id": "NtVXRt", "name": "Imaginative Concentration", "author": "Cleric", "description": "hi", "tags": ["fractal"], "likes": 0, "viewed": 230, "published": 3, "date": "1641223860", "time_retrieved": "2024-07-30T17:12:23.300045", "image_code": "#define PI 3.14159265359\n#define JERK_INTERVAL 0.3\n#define JERK_SPEED .25\n#define SPIRAL_TRANS_BEGIN 5.0\n#define SPIRAL_TRANS_END (SPIRAL_TRANS_BEGIN + 10.0)\n#define SPIRAL_CENTER (SPIRAL_TRANS_END + 5.0)\n#define UNVEIL_START (SPIRAL_CENTER - 5.0)\n#define UNVEIL_END (UNVEIL_START + 15.0)\n#define FRACT_TUNE_START (UNVEIL_END - 5.)\n#define FRACT_TUNE_END (UNVEIL_END + 10.)\n#define TOTAL_T (FRACT_TUNE_END + 15.0)\n\n\nfloat nextFloat(inout int seed) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    seed ^= seed << 13;\n    seed ^= seed >> 17;\n    seed ^= seed << 5;\n    return -1. + 2.*abs(fract(float(seed) / 3141.592653)); // float -1 .. 1\n}\n\nmat2 rotate2D(float rad) {\n    float cs = cos(rad);\n    float sn = sin(rad);\n    return mat2(cs, sn, -sn, cs);\n}\n\nvec2 mandelpent_iter(vec2 z, vec2 c, float t) {\n    #define RAYS 5.0\n    #define ANG (360.0*PI/180.0/RAYS)\n    #define HALF_ANG (ANG/2.0)\n    #define R .51\n    #define D .76\n    \n    float scale = 1.82;// + 12.5*smoothstep(FRACT_TUNE_END, FRACT_TUNE_START, t);\n    \n    float rad = -t/4.0;//radians(15.0);\n    \n    // general rotation\n    mat2 M = rotate2D(rad);\n    z = M*z;\n\n    \n\n    float ang = atan(z.y, z.x);\n    float p = floor(mod((ang - PI/2.0 + HALF_ANG)/ANG, RAYS));\n    float rot = -ANG*p;\n\n\n\n    float d = D + .1*sin(3.0*t);\n    float radius = R*smoothstep(FRACT_TUNE_END-2.0, FRACT_TUNE_END, t) + .1*sin(t);\n    scale = scale + .1*sin(3.0*t);//*.2*sin(ang);\n    M = rotate2D(rot);\n    z = M*z;\n    if (z.y > d)\n        z.y = d - (z.y - d);\n    M[0][1] = -M[0][1]; // transpose matrix (reverse rotation)\n    M[1][0] = -M[1][0];\n    z = M*z;\n\n    float rr = dot(z,z);\n    float m = scale;\n    if (rr < radius*radius) {\n        m = scale/(radius*radius);\n    }\n    else if (rr < 1.0) {\n        m = scale/rr;\n    }\n    return z*m + c;\n}\n\nvec2 ifsgeneric_iter(vec2 z, vec2 c_, float t) {\n    #define VERT 2\n    float d = 1e10;\n    vec2 np;\n    for (int i = 0; i < VERT; i++) {\n        float deg = float(i)*360.0/float(VERT)/180.0*PI;\n        vec2 p = vec2(cos(deg+t), sin(deg+t));\n        float td = dot(z-p, z-p);\n        if (td < d) {\n            np = p;\n            d = td;\n        }\n    }\n\n    z = np + (z - np)*2.;\n    float rad = t;\n    mat2 M = rotate2D(rad);\n    z = M*z;\n    return z;\n}\n\nvec3 mandelpent(vec2 c, float t) {\n    #define ITER 15\n    \n    vec2 z = c;\n    int n;\n    \n    for(int i = 0; i <= ITER; i++) {\n        n = i;\n        z = mix(ifsgeneric_iter(z, c, t), mandelpent_iter(z, c, t),\n            //iMouse.x/iResolution.x\n            smoothstep(FRACT_TUNE_START, FRACT_TUNE_END, t)\n            );\n        float mz = dot(z,z);\n        if (mz > 124.0)\n            break;\n    }\n    float comp = float(n)/float(ITER);\n    return vec3(1.,.9 - comp*.5,.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, TOTAL_T);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    \n    \n    \n    \n    \n    \n    float step = floor(t/JERK_INTERVAL);\n    int randSeed = int(step)*12345678;\n    \n    \n    vec2 curr_xy = vec2(nextFloat(randSeed), nextFloat(randSeed));\n    randSeed = (int(step) + 1)*12345678;\n    vec2 next_xy = vec2(nextFloat(randSeed), nextFloat(randSeed));\n    \n    float next_trans = step*JERK_INTERVAL + JERK_INTERVAL;\n    float trans_weight = smoothstep(next_trans-JERK_SPEED, next_trans, t);\n    vec2 blob_xy = mix(curr_xy, next_xy, trans_weight);\n    \n    \n    vec2 spiral_xy = vec2(cos(t*2.*PI), sin(t*2.*PI));\n    spiral_xy *= 1. - smoothstep(SPIRAL_TRANS_BEGIN, SPIRAL_CENTER, t);\n    \n    float spiral_weight = smoothstep(SPIRAL_TRANS_BEGIN, SPIRAL_TRANS_END, t);\n    \n    blob_xy = mix(blob_xy, spiral_xy, spiral_weight);\n    blob_xy *= .5;\n    \n    \n    \n    \n    \n    float ang = atan(uv.x, uv.y);\n    float r = length(uv);\n    float veil_mask = (.5 + cos(\n        .5*PI*t\n        + 12.*ang\n        )/2.0)\n        * (.5 + cos(\n        -2.*PI*t\n        + 12.*ang\n        - r*50.\n        )/2.);\n        \n    vec2 blob_xy_0 = uv - blob_xy;\n    float thought_mask = 1. - smoothstep(UNVEIL_START, UNVEIL_END, t)*.96;\n    vec3 fract_color = mandelpent(uv, t);\n\n    veil_mask = mix(.5+veil_mask/5., 1., smoothstep(FRACT_TUNE_START, FRACT_TUNE_END, t));\n    veil_mask *= clamp(1.0 - length(blob_xy_0)*15.*thought_mask, 0., 1.);\n    \n    fragColor = vec4(fract_color*veil_mask, 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 416, 449, 548, 697], [699, 699, 725, 725, 811], [813, 813, 860, 860, 1859], [1861, 1861, 1909, 1909, 2317], [2319, 2319, 2353, 2353, 2798]], "test": "untested"}
{"id": "flVSRt", "name": "A squiggle", "author": "SnoopethDuckDuck", "description": "its a bit weird.\nBuffer A tracks a moving point, buffer B draws it, Image draws buffer B\n(lots of unused + unpolished code)", "tags": ["e"], "likes": 6, "viewed": 252, "published": 3, "date": "1641223020", "time_retrieved": "2024-07-30T17:12:24.065997", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec4 col = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n\n    fragColor = col;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvec2 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    ivec2 px = ivec2(fragCoord);\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    vec2 p = Cell(px);\n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        fragColor = vec4(0.);\n        p = vec2(0.5,0.5);\n        //return;\n    } \n    \n    vec2 ipos = floor(sc * uv);\n    \n    float h = h21(uv);\n    float m = 2. / iResolution.y;//h - 0.5 + 0.5 * cos(iTime);\n    float th = iTime + 28. * r + 0.5 * pi * cos(1. * a + iTime);//0.1 * pi * thc(1., 4. * r + iTime);//2. * pi * h21(vec2(0.01 * iTime)); // not perfect\n    vec2 b = vec2(thc(4., th), ths(4., th));\n    \n    vec2 p2 = p + m * b;\n    //p2 = clamp(p2, vec2(0.), vec2(1.));\n    fragColor = vec4(p2.xy, 0., 1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define sc 10.\n\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n\n", "buffer_b_code": "#define KEYBOARD iChannel2\n#define KEY_RESET 82\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 ipos = floor(sc * uv)/sc;\n\n    vec2 p = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xy - 0.5;\n    \n    if (key_down(KEY_RESET)) {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    float r = 0.5;\n    float d = length(uv-p);\n    float k = 0.4 + d;\n\n    float s = step(d, 0.005);// + 0.05 * thc(4., 10. * length(p) - iTime));\n    s = smoothstep(-k, k, -d + 0.);\n    float x = texelFetch( iChannel1, ivec2(fragCoord), 0 ).x;\n    //s = 4. * s * s * s;\n    //col *= 0.995;\n    //col = max(0., col - 0.001);\n\n    vec3 e = vec3(1.);\n    x = clamp(x, 0., 1.);\n    vec3 col = max(vec3(x), s * pal(s + iTime, e, e, e, vec3(0., 0.33, 0.66)));\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 209]], "test": "untested"}
{"id": "stGXR3", "name": "Fork Remnant X rogo1965 315", "author": "rogo1965", "description": "Binary subdivision finds the surface really well with this fractal. Two light sources with shadows, and near surface glows. MOUSE X TO TIME WARP", "tags": ["3d", "fractal", "raymarch", "sound", "music", "remnant"], "likes": 10, "viewed": 875, "published": 3, "date": "1641210250", "time_retrieved": "2024-07-30T17:12:25.032414", "image_code": "// Remnant X\n// by David Hoskins.\n// Thanks to boxplorer and the folks at 'Fractalforums.com'\n// HD Video:- https://www.youtube.com/watch?v=BjkK9fLXXo0\n\n// #define STEREO\n\nvec3 sunDir  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .0, .0);\n\n\n#define SCALE 2.8\n#define MINRAD2 .35\nfloat minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\n#define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)\nfloat absScalem1 = abs(SCALE - 1.0);\nfloat AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));\nvec3 surfaceColour1 = vec3(1.9, 0.0, 0.0);\nvec3 surfaceColour2 = vec3(.0, 1.9, 0.0);\nvec3 surfaceColour3 = vec3(.0, 0.0, 1.9);\nvec3 fogCol = vec3(1.0, 0.0, 0.0);\nfloat gTime;\n\n\n//----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -99.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//----------------------------------------------------------------------------------------\nfloat Map(vec3 pos) \n{\n\t\n\tvec4 p = vec4(pos,1);\n\tvec4 p0 = p;  // p.w is the distance estimate\n\n\tfor (int i = 0; i < 18; i++)\n\t{\n\t\tp.xyz = clamp(p.xyz*(1.0-0.05*sin(iTime*4.0)), -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\tfloat r2 = dot(p.xyz, p.xyz)*(1.0-0.05*sin(iTime*8.0));\n\t\tp *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n\t\t// scale, translate\n\t\tp = p*scale + p0;\n\t}\n\treturn ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Colour(vec3 pos, float sphereR) \n{\n\tvec3 p = pos;\n\tvec3 p0 = p;\n\tfloat trap = 1.0;\n    \n\tfor (int i = 0; i < 6; i++)\n\t{\n        \n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale.xyz + p0.xyz;\n\t\ttrap = min(trap, r2);\n\t}\n\t// |c.x|: log final distance (fractional iteration count)\n\t// |c.y|: spherical orbit trap at (0,0,0)\n\tvec2 c = clamp(vec2( 0.3333*log(dot(p,p))-1.0, sqrt(trap) ), 0.0, 1.0);\n\n    float t = mod(length(pos) - gTime*250., 16.0);\n    surfaceColour1 = mix( surfaceColour1, vec3(.4, 5.0, 0.), pow(smoothstep(0.0, .4, t) * smoothstep(0.9, .6, 0.2*t), 10.0));\n\treturn mix(mix(surfaceColour1, surfaceColour2, c.y), surfaceColour3, c.x);\n}\n\n\n//----------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 pos, float distance)\n{\n    distance *= 0.001+.0001;\n\tvec2 eps = vec2(distance, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t    Map(pos+eps.yxy) - Map(pos-eps.yxy),\n\t    Map(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n//----------------------------------------------------------------------------------------\nfloat GetSky(vec3 pos)\n{\n    pos *= 2.3;\n\tfloat t = Noise(pos);\n    t += Noise(pos * 2.1) * .5;\n    t += Noise(pos * 4.3) * .25;\n    t += Noise(pos * 7.9) * .125;\n\treturn t;\n}\n\n//----------------------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 12; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = Map(rO + halfwayT*rD); \n        //if (abs(d) < 0.001) break;\n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.0005, d));\n\n    }\n\n\treturn halfwayT;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)\n{\n\tfloat t = .05 + 0.05 * texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy).y;\n\tvec3 p = vec3(0.0);\n    float oldT = 0.0;\n    bool hit = false;\n    float glow = 1.0;\n    vec2 dist;\n\tfor( int j=0; j < 100; j++ )\n\t{\n\t\tif (t > 12.0) break;\n        p = rO + t*rD;\n       \n\t\tfloat h = Map(p);\n        \n\t\tif(h  <0.0005)\n\t\t{\n            dist = vec2(oldT, t);\n            hit = true;\n            break;\n        }\n       \tglow += clamp(.05-h, 0.0, .4);\n        oldT = t;\n      \tt +=  h + t*0.001;\n \t}\n    if (!hit)\n        t = 1000.0;\n    else       t = BinarySubdivision(rO, rD, dist);\n    return vec2(t, clamp(glow*.85, 0.0, 4.0));\n\n}\n\n//----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\n//----------------------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\t\n\n\t// Then...\n\t#define CONTRAST 1.08\n\t#define SATURATION 1.5\n\t#define BRIGHTNESS 1.5\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Noise...\n\t//rgb = clamp(rgb+Hash(xy*iTime)*.1, 0.0, 1.0);\n\t// Vignette...\n\trgb *= .5 + 0.5*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\t\n\n    rgb = pow(rgb, vec3(0.47 ));\n\treturn rgb;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 12; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(9.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 LightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n        float a = max(dot(normalize(spotLight), dir), 0.0);\n\t\tg = pow(a, 500.0);\n        g +=  pow(a, 5000.0)*.2;\n    }\n   \n    return vec3(.6) * g;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-.78 + 3. * sin(2.14*t),.05+2.5 * sin(.942*t+1.3),.05 + 3.5 * cos(3.594*t) );\n\treturn p;\n} \n    \n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\n\tgTime = (iTime+m)*.01 + 15.00;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\t\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y, 2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos\t= CameraPath(gTime);\n    vec3 camTar\t\t= CameraPath(gTime + .01);\n\n\tfloat roll = 13.0*sin(gTime*.5+.4);\n\tvec3 cw = normalize(camTar-cameraPos);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\n\tvec3 cv = normalize(cross(cu,cw));\n    cw = RotationMatrix(cv, sin(-gTime*20.0)*.7) * cw;\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\n\t#ifdef STEREO\n\tcameraPos += .008*cu*isRed; // move camera to the right\n\t#endif\n\n    vec3 spotLight = CameraPath(gTime + .03) + vec3(sin(gTime*18.4), cos(gTime*17.98), sin(gTime * 22.53))*.2;\n\tvec3 col = vec3(0.0);\n    vec3 sky = vec3(0.03, .04, .05) * GetSky(dir);\n\tvec2 ret = Scene(cameraPos, dir,fragCoord);\n    \n    if (ret.x < 900.0)\n    {\n\t\tvec3 p = cameraPos + ret.x*dir; \n\t\tvec3 nor = GetNormal(p, ret.x);\n        \n       \tvec3 spot = spotLight - p;\n\t\tfloat atten = length(spot);\n\n        spot /= atten;\n        \n        float shaSpot = Shadow(p, spot);\n        float shaSun = Shadow(p, sunDir);\n        \n       \tfloat bri = max(dot(spot, nor), 0.0) / pow(atten, 1.5) * .15;\n        float briSun = max(dot(sunDir, nor), 0.0) * 0.3;\n        \n       col = Colour(p, ret.x);\n       col = (col * bri * shaSpot) + (col * briSun* shaSun);\n        \n       vec3 ref = reflect(dir, nor);\n       col += pow(max(dot(spot,  ref), 0.0), 10.0) * 2.0 * shaSpot * bri;\n       col += pow(max(dot(sunDir, ref), 0.0), 10.0) * 2.0 * shaSun  * bri;\n    }\n    \n    col = mix(sky, col, min(exp(-ret.x+1.5), 1.0));\n    col += vec3(pow(abs(ret.y), 2.)) * vec3(.02, .04, .1);\n\n    col += LightSource(spotLight-cameraPos, dir, ret.x);\n\tcol = PostEffects(col, xy);\t\n\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Remnant X\n// by David Hoskins.\n\n#define TAU  6.28318530718\n\nfloat n1 = 0.0;\nfloat n2 = 0.0;\nfloat n3 = 0.0;\nfloat n4 = 0.0;\nfloat fb_lp = 0.0;\nfloat fb_hp = 0.0;\nfloat hp = 0.0;\nfloat p4=1.0e-24;\n\nfloat gTime;\nfloat beat;\n\n\n#define N(a, b) if(t > a){x = a; n = b;}\n#define K(a) if(t > a) x = a;\n#define BRING_IN\n\n#define _sample (1.0 / iSampleRate)\n\n// Low pass resonant filter...\nfloat Filter(float inp, float cut_lp, float res_lp)\n{\n\tfb_lp \t= res_lp+res_lp/(1.0-cut_lp + 1e-20);\n\tn1 \t\t= n1+cut_lp*(inp-n1+fb_lp*(n1-n2))+p4;\n\tn2\t\t= n2+cut_lp*(n1-n2);\n    return n2;\n}\n\n//----------------------------------------------------------------------------------\nfloat Tract(float x, float f, float bandwidth)\n{\n    float ret = sin(TAU * f * x) * exp(-bandwidth * 2.14159265359 * x);\n    return ret;\n}\n\n//----------------------------------------------------------------------------------\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 3.4337) * .5;\n}\n\n//----------------------------------------------------------------------------------\nfloat Noise(float time, float pitch)\n{\n    float ret = Hash(floor(time * pitch));\n\treturn ret;\n}\n\n//----------------------------------------------------------------------------------\nfloat noteMIDI(float n)\n{\n\treturn 440.0 * exp2((n - 69.0) / 12.0);\n}\n\n//----------------------------------------------------------------------------------\nfloat Saw(float time, float pitch)\n{\n    float f1 = fract(time * pitch);\n    float f2 = fract(time * pitch * .99);\n    float f3 = fract(time * pitch * 2.01);\n    float f4 = fract(time * pitch * 4.01);\n    return (f1+f2*.7+f3*.4+f4*.3)*.8 - 1.0;\n}\n\n\n//----------------------------------------------------------------------------------\nfloat Kick()\n{\n    #ifdef BRING_IN\n    if (beat < 24.0) return 0.0;\n    #endif\n    float x = 0.0;\n    float t = mod(beat, 8.0);\n    \n    K(0.0);\n    K(0.5);\n    K(4.0);\n    K(6.0);\n    K(7.5);\n    \n    t = t-x;\n    float vol = exp(-t*.5);\n    \n    float kick = sin(t*220.0* exp(-t* .75));\n    \n    kick = (1.5 * kick - 0.5 * kick * kick * kick);\n    \n    \n    return kick * vol * .4;// * smoothstep(0.0, .3, t);\n}\n\n//----------------------------------------------------------------------------------\nvec2 Cymbals()\n{\n\t#ifdef BRING_IN\n    if (beat < 31.0) return vec2(0.0);\n    #endif\n    \n    float x = 0.0;\n    float n = 0.0;\n    float t = mod(beat+.2, 8.0);\n\n    N(0.0, .2);\n    N(0.5, .5);\n    N(2.5, .75);\n    N(3.0, 1.0);\n    N(4.0, .2);\n    N(4.5, .7);\n    N(6.5, 1.0);\n    N(7.0, .6);\n    N(7.75, .8);\n    t = t-x;\n    \n    float vol = exp(-pow(abs(t), .4)*1.3) * .4 * n * smoothstep(0.0, .3, t);\n\tvec2 cym = vec2(Noise(t, 8000.0), Noise(t, 10000.0));\n   \n    return cym * vol;\n}\n\n//----------------------------------------------------------------------------------\nfloat Snare()\n{\n    float x = 0.0;\n    float n = 0.0;\n    #ifdef BRING_IN\n    if (beat < 40.0) return 0.0;\n    #endif\n    float t = mod(beat, 16.0);\n    \n    N(1.0, 1.0);\n    N(3.0, 1.0);\n    N(3.25, .5);\n    N(5.0, 1.0);\n    N(5.25, .5);\n    N(7.0, 1.0);\n    N(7.25, .5);\n    N(7.5, 1.0);\n    \n    N(9.0, 1.0);\n    N(11.0, 1.0);\n    N(11.25, .5);\n    N(13.0, 1.0);\n    \n    N(13.5, .25);\n    N(13.75, .3);\n    N(14.0, .35);\n    N(14.25, .4);\n    N(14.5, .5);\n    N(14.75, .45);\n    N(15.0,  .7);\n    N(15.25, .6);\n    N(15.5,  1.0);\n    N(15.75, .8);\n\n    t = t-x;\n    \n    float vol = exp(-pow(abs(t), .7) * 1.5) * n * .3;\n    \n    float sna = sin(t * 487.0 * exp(-t*.2)) * .65;\n\tsna += Noise(t+mod(gTime, .521), 5400.0 * exp(-t*.2));    \n    \n    return sna * vol;\n}\n\n//----------------------------------------------------------------------------------\nfloat Bass()\n{\n    float n;\n    float x = 0.0;\n    float t = mod(beat, 16.0);\n    \n    N(0.0, 36.0);\n    N(4.0, 35.0);\n    N(6.0, 34.0);\n    N(8.0, 33.0);\n\n    float p = noteMIDI(float(n));\n    t = t-x;\n    float vol = exp(-t*.25) * smoothstep(0.0, .05, t) * .5;\n    float saw = 0.0;\n    float low = (cos(beat*.15)+1.0) *.45 + .05;\n    float res = .7-(cos(t*2.)) *.2;\n\n    for (int i = 0; i < 80; i++)\n    {\n        float s = Saw(gTime-(float(i)* _sample), p) * .7;\n        s += Noise(gTime-(float(i) * _sample), p*16.0) *.3;\n        saw = Filter(s, low, res);\n    }\n    return saw*vol;\n}\n\n//----------------------------------------------------------------------------------\nfloat Lead()\n{\n    float n;\n    float x = 0.0;\n    \n    #ifdef BRING_IN\n\tif (beat < 16.0) return 0.0;\n    #endif\n\n    float t = mod(beat+.15, 32.0);\n    \n    N(0.0, 58.0);\n    N(.5, 60.0);\n    N(2.0, 48.0);\n    N(4.0, 59.0);\n    N(6.0, 58.0);\n    N(8.0, 57.0);\n    \n    N(16.0, 58.0);\n    N(16.5, 60.0);\n    N(18.0, 48.0);\n    N(20.0, 59.0);\n    N(22.0, 60.0);\n    N(24.0, 64.0);\n\n    N(31.0, 54.0);\n    N(31.5, 56.0);\n\n    float p = noteMIDI(float(n));\n    t = t-x;\n    float vib = sin(TAU*5.0*gTime) * smoothstep(0.3, 2.0, t) * .001;\n    float vol = exp(-t*.3) * smoothstep(0.0, .4, t) * .05;\n    float t1 = 500.0  + sin(gTime*TAU*.312)*400.0;\n    float t2 = 1200.0 + sin(gTime*TAU*.13)*400.0;\n    \n    // Vocal tract simulating varying vowel sounds...\n\tfloat s = Tract(mod(gTime+vib, 1.0 / p), t1, 90.0);\n   \ts += Tract(mod(gTime+vib, 1.0 / p), t2, 120.0);\n   \ts += Tract(mod(gTime+vib, 1.0 / p), 2500.0, 160.0);\n    // Octave down harmony...\n  \ts += Tract(mod(gTime+vib, 2.0 / p), t1, 90.0);\n   \ts += Tract(mod(gTime+vib, 2.0 / p), t2, 120.0);\n   \ts += Tract(mod(gTime+vib, 2.0 / p), 2500.0, 160.0);\n\n    s+= (Noise(t, t1)+ Noise(t, t2))*.75;\n\n    return s * vol;\n}\n\n//----------------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n\tgTime = time;\n\tbeat = time * 1.5;\n    \n   \tvec2 audio = vec2(0.0, 0.0);\n    \n    float b1 = Bass();\n    float b2 = -b1;\n    float kick = Kick();\n    float snare = Snare();\n    vec2 cymb = Cymbals();\n    float lead = Lead();\n    \n    audio = vec2(b1, b2);\n    audio += vec2(kick);\n    audio += vec2(snare);\n    audio += cymb;\n    audio += vec2(lead);\n    \n    return clamp(audio * 1.5 * smoothstep(180.0, 172.0, time) * smoothstep(0.0, 1.0, time), -1.0, 1.0);\n    \n    //return vec2(0.0); // Disabled.\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 784, 810, 810, 1020], [1022, 1113, 1135, 1135, 1545], [1547, 1638, 1677, 1677, 2389], [2392, 2483, 2525, 2525, 2758], [2760, 2851, 2875, 2875, 3026], [3028, 3119, 3176, 3176, 3459], [3461, 3552, 3607, 3607, 4243], [4245, 4336, 4356, 4356, 4425], [4428, 4519, 4556, 4590, 4973], [4975, 5066, 5105, 5105, 5285], [5287, 5378, 5423, 5423, 5895], [5897, 5988, 6043, 6043, 6252], [6254, 6345, 6373, 6373, 6482], [6489, 6580, 6637, 6637, 8649]], "test": "untested"}
{"id": "ftGXzt", "name": "Approval Seeking Behavior N", "author": "IWBTShyGuy", "description": "All I think about when I'm on SNS: Twitter, Instagram, GitHub, and, of course, Shadertoy! :)", "tags": ["3d", "raymarching", "modeling", "love", "approvalseeking"], "likes": 23, "viewed": 457, "published": 3, "date": "1641208676", "time_retrieved": "2024-07-30T17:12:26.108536", "image_code": "// Copyright  2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 3\n#endif\n\n/******************** 3D ToolKit ********************/\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n#define rotate3D(axis, angle) mat3(\\\n    axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\\\n    axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\\\n    axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\\\n)\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n/******************** Hash & Noise ********************/\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise(vec3 x) {\n    uvec3 s = uvec3(ivec3(floor(x)) + 2147483647);\n    vec3 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(\n            mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n            mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n            t.y\n        ),\n        mix(\n            mix(hash(s + e.xxy), hash(s + e.yxy), t.x),\n            mix(hash(s + e.xyy), hash(s + e.yyy), t.x),\n            t.y\n        ),\n        t.z\n    );\n}\n\n\n/******************** SDFs ********************/\nconst int CLICK[] = int[](67, 108, 105, 99, 107, 32, 127);\nconst int CLICK_STAR[] = int[](67, 108, 105, 99, 107, 32, 28);\nconst int I_want_your_Love[] = int[](73, 32, 119, 97, 110, 116, 32, 121, 111, 117, 114, 32, 76, 111, 118, 101);\nconst int I_want_your_Fav[] = int[](73, 32, 119, 97, 110, 116, 32, 121, 111, 117, 114, 32, 70, 97, 118, 32);\n\nfloat dot2(in vec2 a) { return dot(a,a); }\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHeart( in vec2 p ) {\n    p.x = abs(p.x);\n    return p.y + p.x > 1.0 ?\n    sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0 :\n    sqrt(min(dot2(p-vec2(0.00,1.00)), dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdLetter(in vec2 uv, in int idx) {\n    if (idx == 127) return sdHeart(vec2(uv.x * 2. - 1., uv.y * 2. - .5)) / 2.0;\n    uv = (clamp(uv, 0., 1.) + vec2(idx % 16, 15 - idx / 16)) / 16.;\n    return textureLod(iChannel0, uv, 0.0).w - .5;\n}\n\nfloat ratioDeform(in float t) { return clamp(0.5 + sin(t * 2.0 * PI), 0.0, 1.0); }\nfloat sdDeformed(in vec2 p, in float t) { return mix(sdStar5(p, 0.7, 0.4), sdHeart(p + vec2(0, 0.5)), ratioDeform(t)); }\nfloat sdDeformed3D(in vec3 p, in float t) { return length(vec2(max(sdDeformed(p.xy, t), 0.0), max(abs(p.z) - 0.05, 0.0))); }\nfloat sdRing(in vec3 p, in float r, in float h) { return length(vec2(length(p.zx) - r, max(abs(p.y) - h, 0.0))); }\n\nconst mat3 CENTER_OBJECT_ROT = rotate3D(normalize(vec3(1, 1, 0)), 0.45);\nconst mat3 LETTER_RING1_ROT = rotate3D(normalize(vec3(-0.5, 1, -1)), 0.45);\nconst vec3 LETTER_RING1_DISP = vec3(-0.04, 0, 0);\nconst mat3 LETTER_RING2_ROT = rotate3D(normalize(vec3(-0.5, 1, 1)), 0.45);\nfloat sdCenterObject(in vec3 p, in float t) { return sdDeformed3D(CENTER_OBJECT_ROT * p, t) - 0.05; }\nfloat sdLetterRing1(in vec3 p) { return sdRing(LETTER_RING1_ROT * (p + LETTER_RING1_DISP), 0.85, 0.05) - 0.01; }\nfloat sdLetterRing2(in vec3 p) { return sdRing(LETTER_RING2_ROT * p, 1.0, 0.05) - 0.01; }\nfloat sdStarHeartScene(in vec3 p, in float t) { return min(min(sdCenterObject(p, t), sdLetterRing1(p)), sdLetterRing2(p)); }\n\nvec3 normalStarHeartScene(in vec3 p, in float t) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec3(\n        sdStarHeartScene(p + e.xyy, t) - sdStarHeartScene(p - e.xyy, t),\n        sdStarHeartScene(p + e.yxy, t) - sdStarHeartScene(p - e.yxy, t),\n        sdStarHeartScene(p + e.yyx, t) - sdStarHeartScene(p - e.yyx, t)\n    ));\n}\n\nint getObjectIDStarHeart(in vec3 p, in float t) { return sdLetterRing1(p) < 1.0e-3 ? 1 : sdLetterRing2(p) < 1.0e-3 ? 2 : 0; }\n\nvec2 uvLetterRing1(in vec3 p, in float t) {\n    p = LETTER_RING1_ROT * (p + LETTER_RING1_DISP); vec2 uv = normalize(p.zx);\n    return vec2(\n        fract((acos(uv.x) * sign(uv.y) / PI + 1.0) / 2.0 + t * 0.01),\n        (p.y + 0.05) / 0.1\n    );\n}\n\nvec2 uvLetterRing2(in vec3 p, in float t) {\n    p = LETTER_RING2_ROT * p; vec2 uv = normalize(p.zx);\n    return vec2(\n        fract((acos(uv.x) * sign(uv.y) / PI + 1.0) / 2.0 + t * 0.01),\n        (p.y + 0.05) / 0.1\n    );\n}\n\nvec3 colorCenterObject(in vec3 p, in vec3 dir, in float t) {\n    vec3 normal = normalStarHeartScene(p, t);\n    float c = microfacet(normal, dir, dir, 0.5, 0.5);\n    return vec3((c + 0.1) / 1.1, (1.0 - ratioDeform(t)) * c, 0);\n}\n\nvec3 colorLetterRing1(in vec3 p, in vec3 dir, in float t) {\n    vec3 normal = normalStarHeartScene(p, t);\n    vec2 uv = uvLetterRing1(p, t);\n    int tapeWidth = int(0.85 * 2.0 * PI / 0.1 / 0.75) - 1;\n    uv.x *= float(tapeWidth);\n    int idx = int(floor(uv.x)) % (tapeWidth / 7);\n    uv.x = fract(uv.x) * 0.72 + 0.14;\n    float c = 0.0, c0 = smoothstep(0.49, 0.51, abs(uv.y - 0.5));\n    if (idx < CLICK.length()) {\n        c = mix(\n            sdLetter(uv, CLICK_STAR[idx]),\n            sdLetter(uv, CLICK[idx]),\n            ratioDeform(t)\n        );\n        c = clamp(1.0e-4 / (1.0e-8 + c * c) - 0.02, 0.0, 1.0);\n    }\n    vec3 col = vec3(microfacet(normal, dir, dir, .3, .8)) * 0.075;\n    col = col * (1.0 - c) + vec3(c * c * c, c, c * c);\n    col = col * (1.0 - c0) + c0 * vec3(1,0,0) * microfacet(normal, dir, dir, .1, .9);\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 colorLetterRing2(in vec3 p, in vec3 dir, in float t) {\n    vec3 normal = normalStarHeartScene(p, t);\n    vec2 uv = uvLetterRing2(p, -t);\n    int tapeWidth = int(2.0 * PI / 0.1 * 2.0) - 6;\n    uv.x *= float(tapeWidth);\n    int idx = int(floor(uv.x)) % (tapeWidth / 7);\n    uv.x = fract(uv.x) * 0.54 + 0.23;\n    float c = 0.0, c0 = smoothstep(0.49, 0.51, abs(uv.y - 0.5));\n    if (idx < I_want_your_Love.length()) {\n        float w = dot(normal, dir);\n        w = (1.0 + w) * 15.0 / iResolution.x;\n        float c1 = mix(\n            sdLetter(uv, I_want_your_Fav[idx]),\n            sdLetter(uv, I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c = clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        // I tried a few different patterns of AA, but this looks the most effective.\n        // If you have a better method, please let me know.\n        c1 = mix(\n            sdLetter(uv + vec2(w, w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(w, w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c1 = mix(\n            sdLetter(uv + vec2(-w, w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(-w, w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c1 = mix(\n            sdLetter(uv + vec2(w, -w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(w, -w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c1 = mix(\n            sdLetter(uv + vec2(-w, -w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(-w, -w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c /= 5.0;\n    }\n    vec3 col = vec3(microfacet(normal, dir, dir, .3, .8)) * 0.075;\n    col = col * (1.0 - c) + vec3(c * c * c, c, c * c);\n    col = col * (1.0 - c0) + c0 * vec3(1,0,0) * microfacet(normal, dir, dir, .1, .9);\n    return clamp(col, 0.0, 1.0);\n}\n\nconst vec3 BACK_GROUND = pow(vec3(0, 5, 10) / 255.0, vec3(2.2));\nconst float STAR_INTERVAL = 1.0 / 15.0;\n\nfloat cellStar(in vec2 uv, in vec2 nbr, in float t) {\n    vec2 xy = uv + nbr; vec3 rand = noise(vec3(floor(xy), 1));\n    if (rand.z < 0.3) return 0.0;\n    vec2 disp = (2.0 * rand.xy - 1.0) * 0.6;\n    vec2 r = fract(xy) + uv - xy - disp - 0.5;\n    float c = length(r) * STAR_INTERVAL;\n    c = clamp(5.0e-4 / c, 0.0, 1.0);\n    float a = noise(vec3(floor(xy), t * 30.0 * noise(vec3(1, floor(xy))).x)).x;\n    return c * c * mix(0.1, 1.0, a);\n}\n\nfloat star(in vec2 uv, in float t) {\n    uv.x += t * 0.01; uv /= STAR_INTERVAL;\n    float c = 0.0;\n    for (int k = 0; k < 25; k++)\n        c += cellStar(uv, vec2(k / 5, k % 5) - 2., t);\n    return clamp(c, 0.0, 1.0);\n}\n\nvoid starHeartSceneWithA(out vec4 fragColor, in vec2 U, in float t) {\n    vec2 r = iResolution.xy;\n    Camera camera = Camera(\n        vec3(0,0,2),\n        vec3(0,0,-1),\n        vec3(0,1,0),\n        PI / 4.0,\n        r.x / r.y\n    );\n    Ray ray = cameraRay(camera, U/r);\n\n    float dist0, dist = 0.0; vec3 p, ro = ray.origin, rd = ray.direction;\n    for (int i = 0; ++i < 255\n        && (dist0 = sdStarHeartScene(p = ro + dist * rd, t)) > 1.0e-4\n        && (dist += dist0) < 12.0;);\n\n    vec3 col = vec3(0);\n    if (dist < 12.0) {\n        switch (getObjectIDStarHeart(p, t)) {\n            case 0: col = colorCenterObject(p, rd, t); break;\n            case 1: col = colorLetterRing1(p, rd, t); break;\n            case 2: col = colorLetterRing2(p, rd, t); break;\n        }\n    } else {\n        float c = star(U/r.y, t);\n        col = BACK_GROUND * (1.0 - c) + c;\n    }\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), dist);\n}\n\nvoid starHeartScene(out vec4 O, in vec2 U, in float t) {\n    starHeartSceneWithA(O, U, t);\n    \n    // smart anti-aliasing\n    // reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n    // If defined, visualize anti-aliased pixels.\n    //#define VISUALIZE_AA\n    #ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1 && O.w < 12.0) {\n        vec4 o;\n    #if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              starHeartSceneWithA(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5, t);\n              O += o;\n        }\n        O /= 5.0;\n    #elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              starHeartSceneWithA(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0, t);\n              O += o;\n        }\n        O /= 9.0;\n    #endif\n    #ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n    #endif\n    }\n    #endif\n    O.xyz = pow(O.xyz, vec3(.4545));\n    O.w = 1.0;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) { starHeartScene(O, U, iTime); }\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXzt.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[487, 608, 653, 653, 1060], [1683, 1683, 1775, 1775, 2852], [2854, 2952, 2972, 2972, 3213], [3215, 3215, 3235, 3235, 3677], [4073, 4073, 4096, 4096, 4115], [4116, 4167, 4195, 4195, 4384], [4386, 4437, 4488, 4488, 4866], [4868, 4868, 4908, 4908, 5108], [5110, 5110, 5141, 5141, 5192], [5193, 5193, 5234, 5234, 5313], [5314, 5314, 5357, 5357, 5438], [5439, 5439, 5488, 5488, 5553], [5829, 5829, 5874, 5874, 5930], [5931, 5931, 5963, 5963, 6043], [6044, 6044, 6076, 6076, 6133], [6134, 6134, 6181, 6181, 6258], [6260, 6260, 6310, 6310, 6601], [6603, 6603, 6652, 6652, 6728], [6730, 6730, 6773, 6773, 6975], [6977, 6977, 7020, 7020, 7200], [7202, 7202, 7262, 7262, 7429], [7431, 7431, 7490, 7490, 8293], [8295, 8295, 8354, 8354, 10375], [10483, 10483, 10536, 10536, 10922], [10924, 10924, 10960, 10960, 11143], [11145, 11145, 11214, 11214, 12065], [13006, 13006, 13045, 13045, 13076]], "test": "untested"}
{"id": "flKXR3", "name": "Fork Mouse Juli rogo1965 771", "author": "rogo1965", "description": "Julia fractal. Use your mouse to change how it renders! Uses orbit trapping for coloring. Mandelbrot is rendered in the background to aid in finding interesting Julia constants.", "tags": ["fractal", "julia", "mouse", "orbit"], "likes": 2, "viewed": 221, "published": 3, "date": "1641206360", "time_retrieved": "2024-07-30T17:12:27.251480", "image_code": "#define ITERS 32\n\nstruct Window {\n    float x;\n    float y;\n    float w;\n    float h;\n};\n\nvec2 complexFromUv(in Window win, in vec2 uv) {\n    return vec2(uv.x * win.w + win.x,\n                uv.y * win.h + win.y);\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 juliaPalette(in float t) {\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), \n                      vec3(1.0, 1.0, 0.5), vec3(0.80, 0.90, 0.30));\n}\n\nvec3 mbrotPalette(in float t) {\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), \n                      vec3(1.0, 1.0, 0.5), vec3(0.80, 0.90, 0.30));\n}\n\nfloat julia(in vec2 c, in vec2 z, in vec2 target) {\n    float x;\n    float d = 1e20;\n    for (int j = 0; j < ITERS; j++) {\n        if (z.x * z.x + z.y * z.y > 4.0) {\n            return d;\n        }\n        \n        x = z.x * z.x - z.y * z.y + c.x;\n        z.y = 2.0 * z.x * z.y + c.y;\n        z.x = x;\n        \n        d = min(d, length(z - target));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    Window win = Window(-1.5, -1.0, 3.0, 2.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 z = complexFromUv(win, uv);\n    vec2 c = complexFromUv(win, iMouse.xy / iResolution.xy);\n    \n    vec2 t = vec2(sin(iTime) + 0.1 * sin(iTime * 2.0), \n                  cos(iTime) + 0.1 * cos(iTime * 2.0));\n    \n    t *= sin(iTime * 2.1) * 1.5;\n\n    vec3 j = juliaPalette(pow(julia(c, z, t), 0.3));\n    //vec3 m = mbrotPalette(pow(julia(z, z, t), 0.7));\n    float amt = 0.75 + 0.25 * sin(iTime * 0.1);\n    fragColor = vec4(j,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 137, 137, 216], [218, 218, 288, 288, 331], [333, 333, 364, 364, 499], [501, 501, 532, 532, 667], [669, 669, 720, 720, 1041], [1043, 1043, 1100, 1100, 1635]], "test": "untested"}
{"id": "ftGSRt", "name": "retro clock with time settings", "author": "4eckme", "description": "retro", "tags": ["mouse", "retro", "clock", "minutes", "hours"], "likes": 5, "viewed": 243, "published": 3, "date": "1641201587", "time_retrieved": "2024-07-30T17:12:28.151075", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o=fragCoord-iResolution.xy/2.0;\n    \n    int x=int(float(32)-mod(float(fragCoord.x-iResolution.x/2.0),float(64)));\n    int y=int(float(32)-mod(float(fragCoord.y-iResolution.y/2.0),float(64)));\n    int xx=int(float(32)-mod(float(fragCoord.x-iResolution.x/2.0),float(64)));\n    int yy=int(float(32)-mod(float(fragCoord.y-iResolution.y/2.0),float(64)));\n    \n    float d=iDate.w;\n    vec2 m;if(abs(iMouse.x-iResolution.x/2.0)<=320.0&&abs(iMouse.y-iResolution.y/2.0+132.0)<36.0){\n        m.x=clamp(iMouse.x-iResolution.x/2.0,-270.0,270.0);\n        d=mod(d+(m.x)*180.0-6.0,3600.0*24.0);\n    }\n    \n    fragColor=vec4(0);\n    if(abs(o.x)<320.-32.0&&abs(x-1)!=abs(y)&&abs(x)!=abs(y)){\n        if(abs(o.y)<=64.0&&abs(xx)>16&&(abs(x)>16||abs(y)>16)&&x*x>=y*y){\n            fragColor=vec4(0.9);\n            if(o.x<-160.0)fragColor*=abc(o,0,int(d/3600.0/10.0),d);\n            else if(o.x<-32.0)fragColor*=abc(o,0,int(mod(d/3600.0,10.0)),d);\n            else if(o.x<160.0)fragColor*=abc(o,0,int(mod(d,3600.0)/60.0/10.0),d);\n            else if(o.x>160.0)fragColor*=abc(o,0,int(mod(mod(d,3600.0)/60.0,10.0)),d);\n        }if(mod(abs(o.x),128.0)>64.0&&abs(o.y)<=80.0&&abs(yy)>16&&(abs(x)>16||abs(y)>16)&&x*x<=y*y){\n            fragColor=vec4(1.0);\n            if(o.x<-160.0)fragColor*=abc(o,1,int(d/3600.0/10.0),d);\n            else if(o.x<-32.0)fragColor*=abc(o,1,int(mod(d/3600.0,10.0)),d);\n            else if(o.x<160.0)fragColor*=abc(o,1,int(mod(d,3600.0)/60.0/10.0),d);\n            else if(o.x>160.0)fragColor*=abc(o,1,int(mod(mod(d,3600.0)/60.0,10.0)),d); \n        }\n    }\n    \n    if(abs(o.y+180.0-48.0)<1.0&&(int(abs(o.x))>=265&&int(abs(o.x))<275||abs(o.x-m.x)<=5.0||abs(o.x)<5.0)){\n        if(abs(o.x-m.x)<5.0)fragColor=vec4(0,0.7,1.0,0.0);\n    }\n\n    vec2 R=iResolution.xy;\n    vec2 fc1=(o-vec2(96.0-R.x/18.0,135.0-R.y/16.0))/R*8.0;\n    vec2 fc2=(o-vec2(-96.0-R.x/18.0,135.0-R.y/16.0))/R*8.0;\n    fragColor+=texture(iChannel1,(fc1))*vec4(0,0.75,0.5,1);\n    fragColor+=texture(iChannel0,(fc2))*vec4(0,0.75,0.5,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float time){\n    \n    float t = time;\n    vec2 res=vec2(\n        sin(6.2831*1960.0*t*float(abs(sin(t*3.1415))<0.1)),\n        sin(6.2831*1080.0*t*float(abs(sin(t*3.1415+1.0))<0.1))\n    );return res;\n}", "sound_inputs": [], "common_code": "float abc(vec2 xy, int pos, int n, float t){\n    if(abs(xy.x)>16.5){\n        if(n==9)return float(0==pos&&(mod(abs(xy.x+32.0),128.0)<64.0||mod(abs(xy.x+32.0),128.0)>64.0&&xy.y>0.0)||pos==1);\n        if(n==7)return float(0==pos&&mod(abs(xy.x+32.0),128.0)<64.0||1==pos&&xy.y>16.0);\n        if(n==8)return float(abs(xy.x)>32.0);\n        if(n==6)return float(0==pos&&(mod(abs(xy.x+32.0),128.0)<64.0&&xy.y<0.0||mod(abs(xy.x+32.0),128.0)>64.0)||pos==1);\n        if(n==5)return float(0==pos&&(mod(abs(xy.x+32.0),128.0)<64.0&&xy.y<0.0||mod(abs(xy.x+32.0),128.0)>64.0&&xy.y>0.0)||pos==1);\n        if(n==4)return float(0==pos&&(mod(abs(xy.x+32.0),128.0)<64.0||mod(abs(xy.x+32.0),128.0)>64.0&&xy.y>0.0)||pos==1&&abs(xy.y)<16.0);\n        if(n==3)return float(0==pos&&mod(abs(xy.x+32.0),128.0)<64.0||pos==1);\n        if(n==2)return float(0==pos&&(mod(abs(xy.x+32.0),128.0)>64.0&&xy.y<0.0||mod(abs(xy.x+32.0),128.0)<64.0&&xy.y>0.0)||pos==1);\n        if(n==1)return float(0==pos&&(mod(abs(xy.x+32.0),128.0)<64.0));\n        if(n==0)return float((0==pos||1==pos&&abs(xy.y)>16.0)&&n==0);\n    } return float(int(mod(t*2.0,2.0))==0&&xy.y<0.0||int(mod(t*2.0,2.0))==1&&xy.y>0.0);\n}\n\nfloat days(float y, float m){\n    if(mod(y,4.0)==0.0&&m==2.0) return 29.0;\n    if(m==2.0) return 28.0;\n    if(m==4.0||m==6.0||m==9.0||m==11.0)return 30.0;\n    return 31.0;\n}\nvec4 ymd(vec4 iDate,vec3 iResolution,vec4 iMouse){\n    float Y=iDate.x;float m=iDate.y+1.0;float d=iDate.z;float s=iDate.w;\n    vec2 mm;if(abs(iMouse.x-iResolution.x/2.0)<=320.0&&abs(iMouse.y-iResolution.y/2.0+132.0)<36.0){\n        mm.x=clamp(iMouse.x-iResolution.x/2.0,-270.0,270.0);\n        float ss=s+(mm.x)*180.0-6.0;\n        if(ss>=3600.0*24.0){\n            d+=1.0;\n        } else if(ss<0.0) {\n            d-=1.0;\n        }\n        if(d==0.0){\n            m-=1.0;\n            if(m==0.0){\n                m=12.0;\n                Y-=1.0;\n            }\n            d=days(Y,m);\n        }\n        if(d==days(Y,m)+1.0){\n            d=1.0;\n            m+=1.0;\n            if(m==13.0){\n                m=1.0;\n                Y+=1.0;\n            }\n        }\n    }\n    return vec4(Y,m,d,0);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord/=7.0/8.0;fragCoord.x-=16.0;\n    vec2 o=fragCoord-iResolution.xy/2.0;\n    \n    int x=int(float(32)-mod(float(fragCoord.x-iResolution.x/2.0),float(64)));\n    int y=int(float(32)-mod(float(fragCoord.y-iResolution.y/2.0),float(64)));\n    int xx=int(float(32)-mod(float(fragCoord.x-iResolution.x/2.0),float(64)));\n    int yy=int(float(32)-mod(float(fragCoord.y-iResolution.y/2.0),float(64)));\n    \n    fragColor=vec4(0);float d=iDate.x;\n    if(abs(o.x)>16.5&&abs(o.x)<320.-32.0&&abs(x-1)!=abs(y)&&abs(x)!=abs(y)){\n        if(abs(o.y)<=64.0&&abs(xx)>16&&(abs(x)>16||abs(y)>16)&&x*x>=y*y){\n            fragColor=vec4(0.9);\n            if(o.x<-160.0)fragColor*=abc(o,0,int(mod(d,10000.0)/1000.0),d);\n            else if(o.x<-32.0)fragColor*=abc(o,0,int(mod(d,1000.0)/100.0),d);\n            else if(o.x<160.0)fragColor*=abc(o,0,int(mod(d,100.0)/10.0),d);\n            else if(o.x>160.0)fragColor*=abc(o,0,int(mod(d,10.0)),d);\n        }if(mod(abs(o.x),128.0)>64.0&&abs(o.y)<=80.0&&abs(yy)>16&&(abs(x)>16||abs(y)>16)&&x*x<=y*y){\n            fragColor=vec4(1.0);\n            if(o.x<-160.0)fragColor*=abc(o,1,int(mod(d,10000.0)/1000.0),d);\n            else if(o.x<-32.0)fragColor*=abc(o,1,int(mod(d,1000.0)/100.0),d);\n            else if(o.x<160.0)fragColor*=abc(o,1,int(mod(d,100.0)/10.0),d);\n            else if(o.x>160.0)fragColor*=abc(o,1,int(mod(d,10.0)),d); \n        }\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord/=7.0/8.0;fragCoord.x-=16.0;\n    vec2 o=fragCoord-iResolution.xy/2.0;\n    \n    int x=int(float(32)-mod(float(fragCoord.x-iResolution.x/2.0),float(64)));\n    int y=int(float(32)-mod(float(fragCoord.y-iResolution.y/2.0),float(64)));\n    int xx=int(float(32)-mod(float(fragCoord.x-iResolution.x/2.0),float(64)));\n    int yy=int(float(32)-mod(float(fragCoord.y-iResolution.y/2.0),float(64)));\n    \n    fragColor=vec4(0);float m=iDate.y+1.0;float d=iDate.z;\n    if(abs(o.x)>16.5&&abs(o.x)<320.-32.0&&abs(x-1)!=abs(y)&&abs(x)!=abs(y)){\n        if(abs(o.y)<=64.0&&abs(xx)>16&&(abs(x)>16||abs(y)>16)&&x*x>=y*y){\n            fragColor=vec4(0.9);\n            if(o.x<-160.0)fragColor*=abc(o,0,int(mod(d,100.0)/10.0),d);\n            else if(o.x<-32.0)fragColor*=abc(o,0,int(mod(d,10.0)),d);\n            else if(o.x<160.0)fragColor*=abc(o,0,int(m/10.0),d);\n            else if(o.x>160.0)fragColor*=abc(o,0,int(mod(m,10.0)),d);\n        }if(mod(abs(o.x),128.0)>64.0&&abs(o.y)<=80.0&&abs(yy)>16&&(abs(x)>16||abs(y)>16)&&x*x<=y*y){\n            fragColor=vec4(1.0);\n            if(o.x<-160.0)fragColor*=abc(o,1,int(mod(d,100.0)/10.0),d);\n            else if(o.x<-32.0)fragColor*=abc(o,1,int(mod(d,10.0)),d);\n            else if(o.x<160.0)fragColor*=abc(o,1,int(m/10.0),d);\n            else if(o.x>160.0)fragColor*=abc(o,1,int(mod(m,10.0)),d); \n        }\n    }\n}", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "stGXDw", "name": "RM Rubin", "author": "ersteller", "description": "Here is a rotating hexagonal pyramid consisting of capsules and triangles. \n", "tags": ["raymarch", "sdf", "hexagonal", "pyramid"], "likes": 2, "viewed": 229, "published": 3, "date": "1641193816", "time_retrieved": "2024-07-30T17:12:28.997812", "image_code": "\n// https://iquilezles.org/articles/distfunctions\n// and \n// https://www.shadertoy.com/view/wdf3zl\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n\n#define MAX_STEPS 100 \n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a; \n    vec3 ap = p-a;   // vec from a to p\n    float t = dot(ab,ap) /dot(ab,ab);   \n    t = clamp (t, 0.,1.);\n    vec3 c = a + t*ab;\n    return length (p-c)-r;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdFace (vec3 p, vec3 a, vec3 b, vec3 c)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec3 rotateY(vec3 center, vec3 p, float rot ){\n    vec3 cp = p - center;\n    return vec3(\n            cp.x*cos(rot)-cp.z*sin(rot),\n            cp.y*1.,\n            cp.x*sin(rot)+cp.z*cos(rot)\n        ) + center;\n}\n\nvec4 minD(vec4 rgbdA, vec4 rgbdB){\n    return rgbdA.w < rgbdB.w ? rgbdA : rgbdB;\n}\n\nvec4 GetDist (vec3 p){\n    \n    float d=MAX_DIST;\n    vec4 colD= vec4(0,0,0,d);\n    \n    float thic =0.06;                  // capsul thicknes\n    float rot = iTime*0.5;             // rotation offset\n    float scale = 1.5;\n    vec3 tr = vec3(0,1, 6.);\n     \n    // scale and translate\n    vec3 A = vec3(1,0,0)*scale+tr;       \n    vec3 B = vec3(0,-1.2,0)*scale+tr;    // bottom point\n    vec3 C = vec3(0,1.2,0)*scale+tr;     // top point\n    vec3 D = vec3(0.5,0,0.866)*scale+tr;\n    \n    for (float i = rot; i <= 2.*3.1415+rot; i+=3.1415/3.){\n        // faces \n        float ADC = sdFace(p, rotateY(tr,A,i),rotateY(tr,D,i),C);;\n        colD = minD(colD, vec4(1,0.7,0.7,ADC));\n        float ADB = sdFace(p, rotateY(tr,A,i),rotateY(tr,D,i),B);;\n        colD = minD(colD, vec4(0.7,0.7,1,ADB));\n        \n        float AB = sdCapsule(p, rotateY(tr,A,i),rotateY(tr,B,i), thic);\n        colD = minD(colD,vec4(0.,0.9,0.7,AB));\n        float AC = sdCapsule(p, rotateY(tr,A,i),rotateY(tr,C,i), thic);\n        colD = minD(colD,vec4(0.,0.7,1,AC));\n        float AD = sdCapsule(p, rotateY(tr,A,i),rotateY(tr,D,i), thic);\n        colD = minD(colD,vec4(1,1,0.,AD));\n    }   \n    return colD;   \n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p).w;             // d is distance to next surface from p and < SURF_DIST on surfaces \n    if (d > SURF_DIST) return vec3(0);  // if we have not hit a surface dont bother searching normals in the sky\n    vec2 e = vec2(.01,0);\n    vec3 n = d - vec3(   \n        GetDist(p-e.xyy).w,   \n        GetDist(p-e.yxy).w,   \n        GetDist(p-e.yyx).w);\n    return normalize(n);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd){\n    float dO=0.;  \n    vec4 colD= vec4(0);;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;  // move p to origin and then distance to origin in ray direction \n        colD  = GetDist(p);     // get new distance from the new point p to closest body\n        float dS = colD.w;\n        dO += dS;               // advance by the new distance\n        \n        if (dO > MAX_DIST){\n            dO = MAX_DIST;\n            break;\n        }        \n        if ( dS < SURF_DIST) {\n            break;\n        }\n    }\n    colD.w = dO;\n    return colD;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    vec3 cam = vec3(0,2,0);\n    vec3 ro = cam;\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.2, 1));\n \n    vec4 resRM = RayMarch(ro, rd);\n    float d = resRM.w;      // there are color components in the result\n      \n    if(d > 10.1 ) d= 20.;   // d = MAX_DIST;\n    d /= 4.;                // normalize 1 to 0\n    d = 2.-d;               // improve highlights\n    \n    // create a color \n    col = vec3(resRM.r*d, resRM.g*d, resRM.b*d);\n    \n    // background colorgradient\n    if (col.x <= 0.01 && col.y <= 0.01 && col.z <= 0.01 ) col=vec3(0.25,uv.y*0.4+.3,uv.y*0.8+.3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 275, 275, 454], [456, 456, 481, 481, 500], [502, 502, 549, 549, 1046], [1048, 1048, 1094, 1094, 1261], [1263, 1263, 1297, 1297, 1345], [1347, 1347, 1369, 1369, 2529], [2531, 2531, 2554, 2554, 2946], [2948, 2948, 2980, 2980, 3550], [3552, 3552, 3609, 3609, 4327]], "test": "untested"}
{"id": "NlGSRt", "name": "Fractal knots 2", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 6, "viewed": 325, "published": 3, "date": "1641193740", "time_retrieved": "2024-07-30T17:12:29.810638", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    //a = -(a);\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    //float offset1 = iTime/1000.;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            //float scale = scale + col.x/16.;\n            //uv += float(i)*ceil(t2)/4.; //lace pattern\n\n            //uv /= -scale-col.x;\n            uv /= -scale;\n            //uv -= offset + (t2.yx)/(1.+(col.x+col.y+col.z)/3.);\n            uv -= offset + (t2.yx)/(scale);\n            //uv -= float(k%3);\n\n            //uv += iTime/1000.-(t2.yx)/(scale);\n\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            //t2 = triangle_wave(uv.yx-.5,scale);\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2 = triangle_wave(uv.yx+.5+float(i),scale);\n            \n            t3 = triangle_wave(uv,scale);\n            \n            uv.yx = (t2+t3)/scale;\n            //t2 /= 1.+temp;\n            //offset += offset1;\n\n        }\n        //uv = uv/(1.-(uv.x+uv.y)/8.);\n        //offset += .5/scale;\n        col.x = abs(uv.y+uv.x-col.x);\n        col = col.yzx;\n        \n        //col.x = abs(uv.y+uv.x-col.x*2.);\n        //col = abs(col.yzx-1.);\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 136, 248], [250, 250, 307, 307, 1751]], "test": "untested"}
{"id": "7lVXzc", "name": "Mosaic fractal 6", "author": "jarble", "description": "A fractal with mosaic-like patterns.", "tags": ["fractal", "mosaic"], "likes": 2, "viewed": 195, "published": 3, "date": "1641191764", "time_retrieved": "2024-07-30T17:12:30.890750", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.*1.5;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){    \n            uv /= -scale;\n            uv -= offset +(t2.yx)/(scale);\n            \n            //uv += iTime/1000. - (t2.yx)/(scale);\n\n            t2 = -triangle_wave(uv.yx-.5,scale);\n            \n            t3 = triangle_wave(uv,scale);\n            \n            uv.yx = (t2+t3)/(scale);\n            col.x = abs(uv.y-uv.x+col.x);\n\n        }        \n        col = col.yzx;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1053]], "test": "untested"}
{"id": "stKSzc", "name": "CutSphere - distance 3D", "author": "iq", "description": "Exact distance to a sphere cut by a plane. Beware doing the max() of a sphere and a plane won't produce an exact Euclidean distance.  Based on sdCutDisk() at [url]https://www.shadertoy.com/view/ftVXRc[/url]", "tags": ["procedural", "3d", "raymarching", "distancefields", "sphere", "primitives", "plane", "cut"], "likes": 23, "viewed": 2145, "published": 3, "date": "1641180984", "time_retrieved": "2024-07-30T17:12:31.739481", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a sphere cut by a plane. Beware doing the max() of\n// a sphere and a plane won't produce an exact Euclidean distance.\n// Based on sdCutDisk(): https://www.shadertoy.com/view/ftVXRc\n//\n// It is a useful primitive when combined with rounding/inflating, which\n// cannot be done with the non-Euclidean max() approach, since you can do\n// things like mushroom heads.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\nfloat map( in vec3 pos )\n{\n    if( sin(iTime*0.8)>-0.1 )\n    {\n    pos.yz = (mat2(-4,3,-3,-4)/5.0)*pos.yz;\n    return sdCutSphere(pos, 0.5, -0.2 );\n    }\n    else\n    {\n    pos.y += 0.1;\n    float d = sdCutSphere(pos, 0.5, 0.2 ) - 0.1;\n    return min( d, max(length(pos.xz)-0.15,pos.y-0.2) );\n    }\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.8*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKSzc.jpg", "access": "api", "license": "mit", "functions": [[1588, 1643, 1699, 1699, 1990], [1992, 1992, 2018, 2018, 2292], [2294, 2340, 2372, 2372, 2611]], "test": "untested"}
{"id": "slVXRc", "name": "Explosion Shader", "author": "pancakespeople", "description": "Oh no! A bomb went off in London!", "tags": ["explosion", "shockwave", "bomb"], "likes": 8, "viewed": 870, "published": 3, "date": "1641180099", "time_retrieved": "2024-07-30T17:12:32.665006", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x + 0.5;\n    float radius = length(uv - 0.5) + 0.1 - iTime / 20.0;\n    float angle = atan(uv.y - 0.5, uv.x - 0.5);\n    float distortion = smoothstep(0.1, 0.2, radius) * smoothstep(0.3, 0.2, radius) * smoothstep(0.0, 1.0, radius);\n    vec4 light = vec4(1.0, 0.8, 0.7, 1.0) * smoothstep(0.5, 0.0, radius) * 1.75 - iTime / 20.0;\n    \n    uv += distortion * vec2(cos(angle), sin(angle));\n\n    vec4 col = texture(iChannel0, uv);\n    col += light;\n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 590]], "test": "untested"}
{"id": "7lKXRc", "name": "2d-3d fake house", "author": "jorge2017a2", "description": "2d-3d fake house", "tags": ["2d3dfakehouse"], "likes": 3, "viewed": 199, "published": 3, "date": "1641178347", "time_retrieved": "2024-07-30T17:12:33.535678", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n\n//2d-3d fake house\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 nubes(vec2 p, vec3 colOut)\n{  vec2 centro=vec2(0.0,0.0);\n    float c1= sdCircle(p-vec2(0.01,0.05), 0.105);\n    float c2= sdCircle(p-vec2(0.15,0.02), 0.065);\n    float c3= sdCircle(p-vec2(-0.12,0.02), 0.065);\n    float b1=sdBox(p-vec2(0.0,-0.04), vec2(0.3,0.05 ) );\n    float res=unionSDF(c1, c2);\n    res=unionSDF(res, c3);\n    res=differenceSDF(res,b1 );\n    colOut=DrawFigBordeR(vec3(1.0), colOut, res,0.001 );\n  return colOut;  \n}\n\n\nvec3 HacerCielo(vec2 p, vec3 col)\n{   float d1= sdBox(p-vec2(0.0,1.5),vec2(3.0,0.5) );\n    vec3  colCielo=vec3(0.45,0.7,1.0)-p.y*0.125;\n    col=DrawFigBorde(colCielo, col, d1 );\n    return col;\n}\n\nvec3 HacerCactus(vec2 p, vec3 col)\n{   float d1= sdBox(p-vec2(-0.5,1.1),vec2(0.025,0.1) );\n    // animation\n    float tt=4.7;\n    float t =            3.14* (0.5+0.5*cos(tt));\n    vec2  w = vec2(0.20,0.15)*(0.5+0.5*cos(11.7*vec2(0.37,0.7)+vec2(0.0,2.0)));\n    float d2 = sdHorseshoe(p-vec2(-0.5,1.15),vec2(cos(t),sin(t)), 0.065, w);\n    d1= unionSDF(d1, d2);\n    col= DrawFigBorde(vec3(1.0,0.8,0.8), col, d1 );\n    return col;\n\n}\n\n\nvec3 casa1(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-1.0), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    \n    col= DrawFigBorde(vec3(0.5,0.6,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d4 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );    \n    return col;\n}\n\nvec3 casa3(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.5,-5.3), vec2(1.2,3.2) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.6), 4.0, 1.9, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(1.0,0.8,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\nvec3 casa2(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(0.4,0.8,1.00),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\n\nvec3 HacerPasto(vec2 p, vec3 col)\n{   vec2 p0=p;\n    float d0= sdBox(p-vec2(0.0,-0.5),vec2(4.0,1.5) );\n    col= DrawFigBorde(vec3(0.25,0.7,0.3),col,d0);\n    col= casa1(p*8.0-vec2(4.0,-3.0), col);\n    col= casa3(p*8.0-vec2(-14.0,6.0), col);\n    col= casa2(p*8.0-vec2(1.0,6.0), col);\n    col= HacerCactus(p,col);\n    return col;\n}\n\nvec3 HacerTodo(vec2 uv)\n{  vec3 col=vec3(0.45,0.7,1.0)-uv.y*0.125;\n    col=HacerPasto(uv-vec2(0.0,0.1), col);\n    vec2 uv2=uv*0.5;\n        uv2.x+= opRep1D(iTime*0.5, 4.0 );\n        col= nubes(uv2*1.5-vec2(0.0,0.4), col);\n        col= nubes(uv2*1.5-vec2(0.5,0.6), col);\n        col= nubes(uv2*2.5-vec2(-1.5,0.7), col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=1.3;\n    uv*=esc;\n    vec2 uv0=uv;\n    \n    float scaling = 3.0;\n    vec3 ro=vec3(-0.5,0.0,2.0);\n    vec3 rd=vec3(uv.x,uv.y,1.0)-ro;\n    rd= rotate_y(rd, radians(120.0));\n    \n    uv = vec2(rd.x/rd.z, rd.y/rd.z) * scaling;\n    \n    vec3  col=vec3(0.0);\n    \n    if (uv.x<0.3)\n    {    \n        uv.x+=1.0;\n        uv*=1.0+sin(iTime)+0.2;\n        uv.x=opRep1D(uv.x,6.0);\n        col=  HacerTodo(uv);\n    }\n    else\n    {   uv.x-=mod(iTime,5.0);\n        uv=vec2(-uv.x+3.0,-uv.y);\n         col= HacerTodo(uv);\n    }\n    \n    col=pow(col,  vec3(0.4754545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 359, 359, 404], [410, 410, 457, 457, 484], [485, 485, 528, 528, 555], [556, 556, 604, 604, 632], [635, 635, 707, 707, 833], [835, 835, 897, 897, 1027], [1029, 1029, 1110, 1110, 1238], [1240, 1240, 1297, 1297, 1367], [1369, 1369, 1431, 1431, 1496], [1498, 1498, 1566, 1566, 1634], [1636, 1636, 1700, 1700, 1771], [1774, 1774, 1808, 1808, 1904], [1905, 1905, 1939, 1939, 2030], [2031, 2031, 2065, 2065, 2156], [2157, 2157, 2191, 2191, 2286], [2289, 2289, 2326, 2326, 2400], [2402, 2402, 2437, 2437, 2460], [2462, 2462, 2514, 2514, 2630], [2632, 2632, 2657, 2657, 2676], [2677, 2677, 2702, 2702, 2721], [2722, 2722, 2758, 2758, 2786], [2789, 2789, 2854, 2854, 3164], [3167, 3167, 3233, 3233, 3575], [3577, 3577, 3643, 3643, 3913], [3915, 3915, 3966, 3966, 4272], [4275, 4275, 4308, 4308, 4713], [4716, 4716, 4751, 4751, 4911], [4913, 4913, 4949, 4949, 5342], [5345, 5345, 5375, 5375, 6079], [6081, 6081, 6111, 6111, 7282], [7284, 7284, 7314, 7314, 8486], [8489, 8489, 8524, 8524, 8817], [8819, 8819, 8844, 8844, 9154], [9156, 9156, 9213, 9213, 9936]], "test": "untested"}
{"id": "ftVXRc", "name": "Cut Disk - distance 2D", "author": "iq", "description": "Signed distance to a disk that's been clipped by a line", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "disk"], "likes": 25, "viewed": 1546, "published": 3, "date": "1641163740", "time_retrieved": "2024-07-30T17:12:34.302629", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk that's been clipped by a line\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n// r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    p.x = abs(p.x);\n    \n    // select circle or segment\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n\n    return (s<0.0) ? length(p)-r :        // circle\n           (p.x<w) ? h - p.y     :        // segment line\n                     length(p-vec2(w,h)); // segment corner\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n   \n    // animation\n    float ra = 0.75;\n    float he = ra*clamp(cos(iTime*0.8),-0.999999,0.999999);\n   \n    // distance\n    float d = sdCutDisk(p,ra,he);\n   \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(128.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // interactivity\n    if( iMouse.z>0.001 )\n    {\n    d = sdCutDisk(m,ra,he);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVXRc.jpg", "access": "api", "license": "mit", "functions": [[1272, 1294, 1348, 1348, 1709], [1713, 1713, 1770, 1806, 2611]], "test": "untested"}
{"id": "flKSzc", "name": "Numerical bug in mod()", "author": "ShnitzelKiller", "description": "This shader demonstrates that it is possible for the output of mod(x, y) to be outside the range (0, y). Each dot represents a seed for which the noise function results in a value below 0 or above maxval.", "tags": ["mod", "bug"], "likes": 2, "viewed": 206, "published": 3, "date": "1641162918", "time_retrieved": "2024-07-30T17:12:35.153353", "image_code": "#define maxval 3\n\n//This noise function should return values strictly in the range 0 <= x < maxval\nvec2 hash2D(vec2 uv) {\n    return mod(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)), float(maxval));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord/10.) + iTime;\n\n    vec2 noise = hash2D(uv);\n\n    // Highlight any values of the noise function that are >= maxval or < 0\n    fragColor = vec4(step(float(maxval),noise.xxy) + (1.-step(0., noise.xyy)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 99, 121, 121, 196], [198, 198, 255, 255, 492]], "test": "untested"}
{"id": "NlyXRc", "name": "Primary Color Competition", "author": "SpinningCube", "description": "Wait a second or so, then watch the primary color regions expand and reshape themselves", "tags": ["cellularautomata"], "likes": 3, "viewed": 239, "published": 3, "date": "1641161713", "time_retrieved": "2024-07-30T17:12:35.967177", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = 2.*texture(iChannel0, uv); // Brightened for a cleaner look\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Experiments with Cellular Automata\n\nfloat rv, gv, bv;\n\nvec3 primaryColor(in vec3 c) { // Finds the most dominant color channel or else returns grey if no color channel is dominant\n    \n    float f = 0.25; // grey threshold\n    \n    if (c.r - c.g > f && c.r - c.b > f) {\n        return rv * vec3(c.r, 0., 0.);\n    }\n    if (c.g - c.r > f && c.g - c.b > f) {\n        return gv * vec3(0., c.g, 0.);\n    }\n    if (c.b - c.r > f && c.b - c.g > f) {\n        return bv * vec3(0., 0., c.b);\n    }\n    //return vec3((c.r + c.g + c.b)/3.);\n    return vec3(0.555);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 pv = 1./iResolution.xy; // Space between pixels in uv coordinates; numerator controls resolution\n    \n    vec3 col;\n    \n    float Time = float(iFrame)/60.;\n    \n    if (Time > 1.5) {\n    \n        vec3 m = texture(iChannel0, uv).rgb;\n    \n        // Controls how much strengths fluctuate\n        float variance = 0.35;\n        \n        // Controls the strength of each primary color and thus its ability to spread\n        rv = variance * (sin(Time) + 1.) + 1.;\n        gv = variance * (sin(Time + 2.0943951) + 1.) + 1.;\n        bv = variance * (sin(Time + 4.18879) + 1.) + 1.;\n        //rv = 1.;\n        //gv = 1.;\n        //bv = 1.;\n        \n        vec3 r = primaryColor(texture(iChannel0, uv + vec2(pv.x, 0.)).rgb);\n        vec3 l = primaryColor(texture(iChannel0, uv + vec2(-pv.x, 0.)).rgb);\n        vec3 u = primaryColor(texture(iChannel0, uv + vec2(0., pv.y)).rgb);\n        vec3 d = primaryColor(texture(iChannel0, uv + vec2(0., -pv.y)).rgb);\n        \n        vec3 s = (r + l + u + d)/3.95; // imperfect average of surrounding colors\n        col = 1.2*mix(m, s, 0.7);\n        col = vec3(tanh(col.r), tanh(col.g), tanh(col.b)); // Sigmoid to prevent overexposure, also mixes with previous color\n    }\n    else { // Initial Conditions\n        col = texture(iChannel1, 1.*uv).rgb * 9. * vec3(1.01, 1., 1.15); // Abstract 1\n    }\n\n    // Output to screen\n    fragColor = 1.*vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 251]], "test": "untested"}
{"id": "flKXz3", "name": "Beach Side", "author": "wyatt", "description": "I pray my computer gets as big as the Eiffel tower so I could simulate the world for 72 hours", "tags": ["fluid", "automata"], "likes": 4, "viewed": 329, "published": 3, "date": "1641155453", "time_retrieved": "2024-07-30T17:12:36.765044", "image_code": "// Fork of \"In Air\" by wyatt. https://shadertoy.com/view/7tVXDw\n// 2022-01-02 04:36:02\n\n// Fork of \"Water Fall\" by wyatt. https://shadertoy.com/view/NtKGWD\n// 2021-12-30 04:31:49\n\nMain \n    Q = .5-.5*sin(.8+3.*(1.-U.y/R.y)+vec4(1,2,3,4));\n    //Q*=0.;\n    U *= N;\n    vec4 f = A(U),b=B(U);\n    if (U.y>0.&&R.y/N-U.y>0.)\n        Q = mix(Q,vec4(.3,.6,1,1),min(f.w,1.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; float T;\n#define N 2.\nvec2 o(vec2 v) {\n    v.x = v.x + R.x*floor(N*v.y/R.y);\n    v.y = mod(v.y,R.y/N);\n    return v;\n}\nvec2 oo(vec2 v) {\n    v = clamp(v,vec2(0),R*vec2(N,1./N)-1.);\n    v.y = v.y + R.y/N*floor(v.x/R.x);\n    v.x = mod(v.x,R.x);\n    return v;\n}\n#define A(U) texture(iChannel0,oo(U)/R)\n#define B(U) texture(iChannel1,oo(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) {R=iResolution.xy,T=iTime;\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n", "buffer_a_code": "// Forces \nMain\n    U = o(U);\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.03*(a.w*(a.w-.8)+b.w);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q.y -= .1/R.y;\n    Q = clamp(Q,-2.,2.);\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(0,0,0.*sin(iTime),1.);\n    \n    if (iFrame < 1) {\n        Q = vec4(0);\n        if (U.y<.4*R.y/N) Q = vec4(-0.2,0,0,.8);\n        \n    }\n    \n    if (U.y<1.) Q.w = 0.;\n    if (U.y<4.) Q.y += .05;\n    if (U.x<1.) Q.w = 0.;\n    if (U.x<4.) Q.x += .05;\n    if (R.y/N-U.y<1.) Q.w = 0.;\n    if (R.y/N-U.y<5.) Q.y -= .05;\n    if (R.x*N-U.x<2.) Q.w = 0.;\n    if (R.x*N-U.x<4.) Q.x -= .05;\n    if (U.y<(-.6*R.x+.5*U.x)/R.x/N*R.y-4.) Q.w *= 0.;\n    if (U.y<(-.6*R.x+.5*U.x)/R.x/N*R.y) Q.y += .02,Q.x-=.05;\n    \n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n    U = o(U);\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       {\n           float j = .5+.5*smoothstep(.6,0.,Q.w*q.w);\n           float k = .5+.5*smoothstep(.6,0.,Q.w*q.w);\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.w += wa+wb;\n            \n            dQ.xyz += Q.xyz*wa+q.xyz*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces \nMain\n    U = o(U);\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.5*(a.w+b.w);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q = clamp(Q,-2.,2.);\n    \n    if (iFrame < 1) {\n        Q = vec4(0);\n        if (U.y>.4*R.y/N) Q = vec4(0,0,0,.05);\n    }\n    \n    if (U.y<1.) Q.w = 0.;\n    if (U.y<4.) Q.y += .05;\n    if (U.x<1.) Q.w = 0.;\n    if (U.x<4.) Q.x += .05;\n    if (R.y/N-U.y<1.) Q.w = 0.05;\n    if (R.y/N-U.y<4.) Q.y -= .0;\n    if (R.x*N-U.x<4.) Q.w = 0.05;\n    if (R.x*N-U.x<4.) Q.x -= .0;\n    if (U.y<(-.6*R.x+.5*U.x)/R.x/N*R.y-4.) Q.w = 0.05;\n    if (U.y<(-.6*R.x+.5*U.x)/R.x/N*R.y) Q.y += .02,Q.x-=.05;\n    \n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n    U = o(U);\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n           float j = .5+.5*smoothstep(.1,0.,Q.w*q.w);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(j+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtVSzy", "name": "Metal Globe", "author": "Flyguy", "description": "Vector map of the earth delta-encoded into 8-bit vectors used to trace out the SDF.\nSign is generated using a simple even-odd point in N-gon check.", "tags": ["raymarching", "sdf", "earth", "compression", "ngon", "encoding", "globe"], "likes": 50, "viewed": 933, "published": 3, "date": "1641151657", "time_retrieved": "2024-07-30T17:12:37.711513", "image_code": "#define VIEW_SDF 0\n\nconst int MAX_ITER = 70;\n\nconst float GLOBE_RAD = 50.0;\nconst float GRID_LINES = 26.0;\nconst float GRID_THICK = 0.6;\nconst float LAND_THICK = 2.0;\nconst float BORDER_CHAMFER = 0.15;\n\nconst float MAT_BACKGROUND = 0.;\nconst float MAT_SILVER = 1.;\nconst float MAT_GOLD = 2.;\n\nvec2 sdGlobeMap(vec3 p, float mat)\n{\n   vec2 texc = vec2(\n        atan(p.y, p.x)/tau + 0.5,\n        1.- atan(length(p.xy), p.z)/pi + 1.0\n    );\n    float sdf = texture(iChannel0,texc,0.).x;\n    \n    return vec2(sdf*length(p), mat); \n}\n\nvec2 sdGlobeShell(vec3 p)\n{\n    vec2 dland = sdGlobeMap(p, MAT_GOLD);\n    dland = opSChamfer(BORDER_CHAMFER, opN(sdSphere(p, GLOBE_RAD, MAT_GOLD)), dland); \n    dland = opS(sdSphere(p, GLOBE_RAD-LAND_THICK, MAT_GOLD), dland); \n    \n    return dland;\n}\n\nvec2 sdGrid(vec3 p)\n{\n    float gridrad = GLOBE_RAD - LAND_THICK - GRID_THICK;\n    vec3 plon = Revolve(AngRep(p.xyz,tau/GRID_LINES).zxy);\n    vec3 plat = AngRep(Revolve(p.xyz).xzy, tau/GRID_LINES);\n    \n    vec2 dgrid = sdSphere(plon - vec3(gridrad,0,0), GRID_THICK, MAT_SILVER);\n    dgrid = opS(sdCylinder(p, sin(pi/GRID_LINES)*gridrad, MAT_SILVER), dgrid);\n    dgrid = opU(sdSphere(plat - vec3(gridrad,0,0), GRID_THICK, MAT_SILVER), dgrid);\n    \n    return dgrid;\n}\n\nvec2 Map(vec3 p)\n{\n    vec2 d = opN(sdSphere(p,200.0, MAT_BACKGROUND));\n    \n    d = opU(d, sdGrid(p));\n    d = opU(d, sdGlobeShell(p));\n    \n    return d;\n}\n\nvec4 MarchRay(vec3 orig, vec3 dir)\n{\n    vec3 mPos = orig;\n    vec3 lPos = orig;\n    float mat = 0.;\n    \n    for(int i = 0;i < MAX_ITER;i++)\n    {\n        vec2 dMap = Map(mPos);\n        \n        if(dMap.x < eps)\n        {\n            mat = dMap.y;\n            break;\n        }\n        else\n        {\n            lPos = mPos;\n            mPos += dir*dMap.x;\n        }   \n    }\n    \n    return vec4(mPos, mat);\n}\n\nvec3 Normal(vec3 p)\n{\n    vec2 offs = vec2(eps,0);\n    float c = Map(p).x;\n    return normalize(vec3(\n        Map(p+offs.xyy).x - c,\n        Map(p+offs.yxy).x - c,\n        Map(p+offs.yyx).x - c\n    ));\n}\n\nvec4 textureTriPlanar(sampler2D tex, vec3 p, vec3 n, float lod)\n{\n    n = abs(n);\n    n /= n.x+n.y+n.z;\n    vec4 tx = texture(tex, p.yz, lod);\n    vec4 ty = texture(tex, p.zx, lod);\n    vec4 tz = texture(tex, p.xy, lod);\n    vec4 to = vec4(0);\n    to = mix(to,tx,n.x);\n    to = mix(to,ty,n.y);\n    to = mix(to,tz,n.z);\n    return to;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y - res/2.0;\n    vec2 m = iMouse.xy/iResolution.xy - 0.5;\n    \n    m = (iMouse.xy == vec2(0)) ? vec2(iTime*0.4, -0.7*cos(iTime*0.2)) //Thumbnail\n                               : m*vec2(tau,pi); //Mouse look\n    \n    //Camera\n    mat3 camMat = Rotate(vec3(m.y, 0.0, m.x));\n    vec3 orig = vec3(0,-130,0) * camMat;\n    vec3 dir = normalize(vec3(uv.x,0.9,uv.y)) * camMat;\n    \n    vec4 hit = MarchRay(orig, dir);\n    vec3 nrm = Normal(hit.xyz);\n    \n    vec3 col = vec3(0); \n    \n    if(hit.w == MAT_BACKGROUND) //Background\n    {\n        col = texture(iChannel1,dir.xzy,0.).rgb;\n    }\n    \n    if(hit.w == MAT_SILVER) //Grid silver-metallic\n    {\n        vec3 env = texture(iChannel1,reflect(dir, nrm).xzy,0.).rgb;\n        env = env*0.9+0.1;\n        col = vec3(0.95)*env;\n\n        float shadow = smoothstep(0.0,3.0,sdGlobeShell(hit.xyz).x);\n        shadow = mix(1.0, shadow, max(0.,dot(normalize(hit.xyz),nrm)));\n        shadow = shadow*0.5+0.5;\n        col *= shadow;\n    }\n    \n    if(hit.w == MAT_GOLD) //Map gold-metallic \n    {\n        vec4 tex = textureTriPlanar(iChannel2, hit.xyz*0.01, nrm, 0.);\n        nrm = normalize(nrm + tex.xyz*0.05);\n        vec3 env = texture(iChannel1,reflect(dir, nrm).xzy,0.).rgb;\n        env = env*0.9+0.1;\n        col = vec3(0.15,0.1,0.04)*env*9.;\n        \n        float shadow = smoothstep(0.0,3.0,sdGrid(hit.xyz).x);\n        shadow = mix(1.0, shadow, max(0.,-dot(normalize(hit.xyz),nrm)));\n        shadow = shadow*0.5+0.5;\n        col *= shadow;\n    }\n    \n    fragColor = vec4(col, 0);\n    \n    #if(VIEW_SDF == 1)\n        float _dist = 2.*texelFetch(iChannel0, ivec2(fragCoord),0).r;\n        fragColor.rgb = mix(vec3(0.3,0.5,1),vec3(1,0.7,0.3),step(0.,_dist));\n        fragColor.rgb *= 0.9+0.1*(-cos(_dist*300.0));\n        fragColor.rgb *= smoothstep(0.002,0.005,abs(_dist)); \n        fragColor.rgb *= 1.0/(1.0+abs(_dist)*15.);\n    #endif\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Constants\nconst float inf = 1e3;\nconst float eps = 0.03;\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n//Transformation / Domain Modification Functions\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//Angular Repeat\nvec3 AngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n//Revolve (radial extrude) around Z\nvec3 Revolve(vec3 p)\n{\n    return vec3(length(p.xy), 0.0, p.z);\n}\n\n\n//SDF Combination Operators\n//Union\nvec2 opU(vec2 a, vec2 b) \n{ \n    return (a.x < b.x) ? a : b;\n}\n\n//Subtract\nvec2 opS(vec2 a, vec2 b)\n{\n    return (-a.x > b.x) ? vec2(-a.x,a.y) : b;\n}\n\n//Intersection\nvec2 opI(vec2 a, vec2 b)\n{\n    return (a.x > b.x) ? a : b;\n}\n\n//Negate\nvec2 opN(vec2 a)\n{\n    return vec2(-a.x,a.y);\n}\n\n//Subtract with 's' x 45deg chamfer at boundary. \nvec2 opSChamfer(float s, vec2 a, vec2 b)\n{\n    return vec2(max(max(-a.x, b.x), -((a.x+-b.x)-s)/sqrt(2.0)), a.y);\n}\n\n\n//SDF Functions\nvec2 sdCylinder(vec3 p, float r, float mat)\n{\n  return vec2(length(p.xy)-r, mat);\n}\n\nvec2 sdPlane(vec3 p, vec3 n, float h, float mat)\n{\n  return vec2(dot(p,normalize(n)) + h, mat);\n}\n\nvec2 sdSphere(vec3 p, float r, float mat)\n{\n  return vec2(length(p)-r, mat);\n}\n\nvec2 sdTorus(vec3 p, vec2 t, float mat)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, mat);\n}\n", "buffer_a_code": "//Earth map SDF\n\nconst int VECS_PER_FRAME = 50; //# of vectors to decompress per frame.\nconst int VECT_COUNT = 3040; //Total # of vectors (4096 max).\nconst int SHAPE_COUNT = 101; //Total # of shapes (256 max).\nconst float MAX_EXTENT = 756.0; //Max X/Y dim of the vector image for scaling (1024 max).\nconst vec2 ASPECT = vec2(2,1);\n\n//Maps a linear address to a location in a 2D region.\nivec2 IdxToUV(int addr, ivec2 base, ivec2 size)\n{\n    return ivec2(addr % size.x, (addr / size.x) % size.y) + base;\n}\n\n//Maps a location in a 2D region to a linear address.\nint UVToIdx(ivec2 uv, ivec2 base, ivec2 size)\n{\n    uv -= base;\n    return (uv.x + uv.y * size.x);\n}\n\n//Outputs vector & shape data to the alpha channel on the 1st frame.\n//Data will be sampled from the alpha channel on following frames.\n//Avoids performace issues caused by the large arrays.\nvec4 Initialize(ivec2 uv)\n{\n    int i = UVToIdx(uv, ivec2(0), ivec2(iResolution.xy));\n    \n    int vecdata = 0;\n    \n    //Vector data\n    //Each int contains 4 bytes, each byte is a vector with 2 signed 4-bit (-8 - +7) components.\n    const int vects[] = int[VECT_COUNT/4](\n        0x4F0E2F41,0x412F3F5D,0x411F0E20,0xCF0DFF0F,0xEF0E200F,0xD1E2A0D3,0xFEFFD102,0xF0EEE0E1,\n        0x13E0DEE2,0x11130324,0xCE0C4E20,0xE0E1DFFE,0x2303E1DF,0x17325032,0xDEB4F212,0x0E2AEBDC,\n        0x311D204F,0x21D20212,0x02D0FF0E,0x01D02F22,0x010F1F21,0x311EEFE1,0x31435531,0x11E10152,\n        0xCEDFE0E1,0xD0CEFEE0,0x0FEF0ECD,0x2F0F1F30,0xD0C20121,0x12F2D1F2,0xFEDFD0F1,0xFEE0CED0,\n        0x3E11202F,0x4F51212F,0xE201315D,0xAFE12301,0x2E0EDEE0,0xD09E605F,0x3DCDFCEF,0x403E3AED,\n        0xEF400E3F,0x20710ED0,0x3E5F0ECE,0xDC0C3B20,0x09CFDC0D,0x304C0DBB,0x606E4121,0x21305F7E,\n        0x7671402F,0x71534602,0x03336134,0x616202C1,0xD0F1122F,0x112F2101,0xDFC004C5,0xD0FEF0F1,\n        0xD201E1B5,0x70706201,0x91F11171,0xE102C0D1,0xC4C19191,0x94C0D392,0x9F9F9191,0xEF0F9E9E,\n        0x2102F1E0,0x1E3F2F1F,0x1FFEF3D0,0x2203F2CE,0xD0EFB03E,0xAFAFD0DF,0xDCCFAFAF,0x725F7F3D,\n        0x52505F41,0x52315234,0xD0B1C1F1,0xFE2F31F2,0x1E3101D1,0x02D206FF,0xFEE0C4B4,0x2B4D300B,\n        0x0EEE0F2E,0xEFE33331,0xF2223EFE,0xEFE1B512,0x0C2EEE0C,0x2F20142F,0x03F0DF21,0xD2EF1E30,\n        0xE0021F40,0xA0EF3FFF,0x22E190FF,0x301F3041,0xF1034E11,0x0E2E0EF0,0x2102E0EF,0x1EFFEC20,\n        0x1EFF1EED,0xE2C0FF0D,0x42D5C2F3,0xC1024301,0x2D33F103,0xF103103D,0x2F331302,0x1CFD1C0D,\n        0x1BDDD234,0xFEF2122E,0xE0FEEE0D,0x3114E203,0xE0EE0E4F,0x0D2F2104,0x2104F0FE,0x43314B19,\n        0x36322243,0x03350714,0xE9F9DEE1,0xE0CDBBDC,0x02FFD3E1,0x312EEED1,0xFFD0E103,0x0D2F1A0B,\n        0x0214552D,0xE1BCC2F2,0x30120712,0xAE0E0D2B,0x5151E2A0,0x04E22240,0xFC09DEE2,0xF332302C,\n        0xF212F2F2,0x1E0BEFF3,0xED0C201F,0x2F2206E0,0x01F2F00E,0x1727072F,0x03F30732,0xF3073755,\n        0x17240335,0x03311207,0x11F507E7,0xE2F603F2,0x12F105E0,0x4E4D0317,0xF5172331,0xD70607D3,\n        0x022112E7,0xF4E50232,0x22202B21,0x05202D20,0x32C21433,0x300E3E22,0x0143F322,0x21F24131,\n        0xE11336F2,0xE0ED1ECE,0xCF9FB2FE,0xAE9092D0,0xE7E7D7C7,0x032503E7,0x274403E4,0x43023227,\n        0x05640224,0x36440422,0x230525F3,0x03B31230,0x030717F5,0xF7F7E334,0x02471704,0x22E7D313,\n        0x22273631,0x440331E2,0xF5E4C407,0xD203F707,0x44A72203,0x124F2147,0xD20317E3,0x41320614,\n        0x2204E2F3,0xE7C322E2,0xD4053305,0x022507E0,0x05D30225,0xF7F70731,0x03F0E3F7,0x22E507D2,\n        0xE1C5F6D4,0xE712E322,0xBA0C9DC6,0x03C4B0CC,0xF715E531,0xF707F7E7,0x90909007,0x90909090,\n        0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,\n        0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,\n        0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,\n        0x09090909,0x09090909,0x09090909,0x70707070,0xEE707070,0xFE1F22F1,0x1F4002C1,0x1F30F1D0,\n        0xD3D2D00F,0x0E4D3F20,0x0F2F03E0,0x0F2F11D1,0xD02001E0,0x5D2002C1,0xFBEEE0ED,0x4243F3D2,\n        0xCC0D1F21,0x2254E1DF,0x01D0FF21,0xE1CF1F31,0xFD2F2021,0x30F303D0,0xE2DF0E2D,0x91EE3021,\n        0x4002E0FF,0xB72F5011,0xC4E0D2B7,0xE1D2EFD0,0x2CD0B4E0,0xFE2D7D1E,0x0B4E0BBF,0x7D203220,\n        0x5EFE2E3B,0x31205C21,0xB0D422D1,0xEF0274C2,0x2E3F02D2,0x14F2DF0D,0xEFFE0D3E,0xF22F34E3,\n        0xDE301FDF,0xCE1031F1,0xEE2F32F1,0xDFDE1D0D,0xAFA2BF9F,0xA1417003,0x4E4022B2,0x40F2315F,\n        0x312EED1E,0x742F4307,0x9CD2B321,0xEDE0A3D0,0xEF90DEA0,0x2BFD3EFD,0x524F7F6F,0x741362E2,\n        0x02B1A0AE,0x5E4F5032,0x95A494E5,0x21C2F1B0,0x90DFE0C2,0x03E1E5E0,0xEF02D421,0x3A09FFC5,\n        0x2F216AFE,0x4F7D6C0E,0x3E5F2F7E,0xDF405D5E,0xC0CD1EDE,0x31C3B034,0xE37E5042,0xD5B0CE91,\n        0xBFA003B0,0x203FEEED,0xD202502F,0x301E2011,0xEEC11D2F,0x303E405F,0xB3217141,0xCEFEC0E4,\n        0xA2E0EF3C,0xBFB0BEB0,0x2ECDEBEE,0xB03F0FBC,0x307E0FBE,0x72163265,0x414232E2,0x525F412F,\n        0x0F316101,0x0F2001E0,0x2001F1FF,0x3101D00E,0x01B3DF0F,0xD00E1F7F,0xFF0F3101,0x2002F1F0,\n        0xE0CC0F1F,0xF15033E2,0xED111FFF,0x05E1DE0F,0x0D2E2032,0x0C2002E1,0xE203B3FE,0x2012F212,\n        0xEF1D1D3E,0x1F2001F1,0xE20533D3,0x3D0CCED1,0x21201D1D,0xE1EEFD0D,0xD2FE1FFF,0x0311D4F3,\n        0x3F4E2031,0x2D0DD0EE,0x0FFE2F0E,0xCB0DFD5F,0x13F4E0FD,0xDFF132E2,0x04E1F5F2,0x20320626,\n        0x0E4D0D1E,0x3F02F1E0,0x43517203,0x46142361,0x25172342,0x3E303346,0x2F540261,0x41E33F40,\n        0x2FFE203E,0x32033013,0x09202337,0x6DEC2FF9,0x1B093A0C,0x1DFCF9F9,0x09EFFCFB,0x1DFE2DEF,\n        0x0BEFEBF9,0xF4E0ECED,0xEEE90BEE,0x07C5D1D3,0x9294D717,0xD2BEF3D0,0x1DC02204,0xB3B1CFDE,\n        0xE29494D0,0xE102D303,0xD10E3FFE,0xC91F2101,0xBFD0EEBF,0x9BCCCEA0,0xA09291BF,0x7F6E0EDF,\n        0x2EFE5D20,0x2E0DBF0A,0x90DDBB1D,0x91C090BF,0xF2E2D0D2,0x22613215,0xDED0E323,0x07DF9F90,\n        0x9F9FC302,0x0234C392,0x334043C3,0xD1014213,0x2111F1FF,0xE203C3E2,0x31D20332,0xC4C1D0E1,\n        0xB604E2B2,0xC0D191C2,0xD402E2D2,0x04E5E0E2,0x91F4D2A4,0x9D9D9E90,0x9F9F9F90,0x9AFBAD9E,\n        0xADBFB1BE,0xFEAD9E9C,0x9EB1C12B,0xD0CE0DDB,0xF2C02DDE,0xDFAFFEE0,0xC0D3D0DD,0xC0DDD0CC,\n        0xDBD3C392,0x7E6B3B0C,0x2E52707F,0x30025172,0x417170FE,0x7172713F,0x71717070,0x70717070,\n        0x4C5C6E40,0x5E7E506D,0x703E7D7F,0x503F2042,0x42414371,0x5F4E7060,0x5BEEBF0F,0x401F3D4E,\n        0x7B3D497D,0x3C4C59DC,0x7D712F5D,0x7B403E7C,0xC00E6E7E,0x93C1E1D2,0x0FB0C292,0x5B502F7C,\n        0x7D7F7C41,0x7D206E6A,0x715F707E,0x7A7F2070,0x5C5F213E,0x0EFE2F4F,0x5A7D2D5F,0xDF3B0A3B,\n        0x402FEDEB,0xBCCCE0BD,0xFCEBDCDD,0x03322420,0x1B204343,0x3DFD6FFC,0x2304735E,0x3DFE0A30,\n        0x0324322D,0x2E6903F1,0x36431530,0xF7E5F526,0xE3E7F7F7,0x06173202,0xE233B333,0xF4D60312,\n        0x303E2E6F,0x2F3BEBCD,0xE7153073,0xF5E4D403,0x0350C422,0x93DEE213,0xE0FED0D6,0x27E5E00B,\n        0x5003433E,0x423F3033,0x0DBDE207,0xE2D2B4CF,0x5302A0F4,0x6F3E2A50,0x16E21653,0x0397E407,\n        0xB0C304D3,0xDFE1B7E4,0xC2FF6ABC,0x1DCEB3F2,0x6B2B1AC1,0x323EFB1C,0x32411205,0x0DDEFD3F,\n        0xEC5D522F,0xD2EFB01D,0xD3D4CECC,0xCC2D0DE0,0xCE61213C,0xDFEE0ECD,0xB1BECDFD,0xE513A1F3,\n        0xA1F6D4C3,0xFFD002E0,0x407E33D3,0x4E4F4323,0x2F42102F,0x14E54160,0xC39103A5,0xA3C26234,\n        0xE3C4A2C2,0x90D1F2E0,0x9203D2CF,0xED4EEFB0,0x623E0B2F,0x990E2273,0x1DD0E20B,0x14DFFD5C,\n        0xF3C0DEC3,0xB00242D3,0xFDEDE00E,0xFD533EBC,0x29B1CEA9,0x09091B0B,0x1CDD0BF9,0xDA0DFE0E,\n        0xEC3AFFE3,0xC402D2BD,0xDFF215F4,0x132D09EC,0xED2C2F2D,0xEFE0F3D2,0xE0FDE0E3,0x3F2103E3,\n        0xD2C10220,0x3507F706,0xFC0A1C3F,0x1706111B,0x222F44E6,0x05314402,0x14362445,0xEF0F2012,\n        0x2E1102F1,0x0E3101D0,0x11F20221,0xE412503F,0xF2E0FEE0,0x35372122,0x130323C1,0x1E3E12F2,\n        0x04E20220,0x3E11C7E5,0x2F21300E,0x12533222,0xDFD0F2D2,0xE1E090F1,0xF1EEDFE0,0x2F402133,\n        0x23203F60,0x01C0E131,0x21021231,0x0760F2E1,0x27362F24,0x04C23227,0x24320222,0xE507C603,\n        0x07C1CED1,0x024206D7,0xA0D305E2,0x023202F2,0x310615F1,0x124E2102,0xE7D0E3F2,0x0707B605,\n        0xF607B1F3,0xE2D0F233,0xF7053031,0xC1E4C7D7,0xF0C40412,0xFECFFEEE,0x2F0B3E3C,0x0EDEE0FF,\n        0x0BD0E1C1,0x0FEEA9EB,0x0DEE0D2E,0xDECF1EFF,0xE1DFF2F0,0xC0EFFEE0,0xAEFECFFD,0x5F7F7FDD,\n        0x42246351,0x1F413344,0x0C4EDBCF,0xFFE1E0AA,0xFF0D3EF9,0x9B9A0B09,0x02D2F2CC,0x32C30211,\n        0x90D10110,0xFEE0E191,0xFEC1D0DF,0x707070EF,0xA0CE2F20,0x9C9C9DBF,0xAC2F0EDD,0xC2D0CDCF,\n        0xEDEF90C1,0x31201EFE,0x300E2F70,0xDD0E2E31,0x2F322F0F,0xFE0FDFCC,0x32C102E1,0xDECCD0E4,\n        0xD1A2D2E0,0x9EE2EFC0,0xDB9C9E9D,0xE0EFFCCC,0xFFDFD0E1,0x32401F0E,0xAC0E2F30,0xA2C293CF,\n        0x9BCD9091,0x1E600FEF,0xB0EF6C7D,0xC0B1E19F,0x90D1C3D3,0x2EFF91D1,0x306F6E6C,0x41705D4F,\n        0x7F7F703F,0x50502EBC,0x5F5E4F3E,0xEE0DEDFF,0x9DFEDED0,0xDFFEADEE,0xB0AF90F1,0x5E0FBDBE,\n        0x406E5F6F,0x7F7F7F3F,0x5D0EEE50,0xFC6D5D30,0x5D29FB1F,0x6B0DEE1F,0xFF0F2E7E,0xD193C1EF,\n        0xA0E10111,0xB1226304,0xD0B3E3D1,0xFECE9DAD,0xDFEE0DD0,0xEDCCFDDE,0x5D0FDE0E,0x6E11207F,\n        0x3E4E304E,0x4F3E7F30,0xB10E5D7E,0x90939192,0x9491C2D1,0xC2B0D293,0x02252622,0x9E9E9FD0,\n        0x9C9B9D9E,0xAF9ECDBF,0xF19190C1,0xBFC09190,0xACCECCCE,0xBB9FB092,0xCF9D9FC0,0x1DECBC9C,\n        0x0FFF0EEC,0x7E515F3D,0x7F707E7D,0x2F7E7E7F,0x73715170,0x7E413F7F,0x3F7D7D7F,0x4E707141,\n        0x0B1F7E0A,0x0D2DFEB9,0x4D7B0ECC,0x4E5D5F6D,0x423F604E,0x503F5071,0x6252502F,0x12424261,\n        0x43737074,0xE1013142,0x17076607,0xE1DFD323,0xC201DFC0,0xB7C1E304,0x02337012,0x2203C7C5,\n        0x4203F103,0x2F702171,0x3E0DDE0F,0x2E0EEF0F,0x705E3EFF,0x0EDE0E3F,0xDFDEC0B3,0x7D5F3E0F,\n        0x4E3C4D7F,0xFE3F0F2F,0xD1E1E2C0,0xD3E1F2E2,0x0E1FFFE1,0xCEE0D1F0,0xFFD0FF0F,0xF212204B,\n        0x3F400211,0x5E4D2D4D,0x0DBC0F3E,0xD0DF0F1E,0xB0CEDDEE,0xFFFACECE,0xFF0F4E0E,0x203F302E,\n        0x335F7041,0x42F5F205,0x204B6E60,0x01300422,0x211044F2,0x34314312,0x23606F14,0xD3910111,\n        0x01F1F3E0,0x6034E237,0x2C41C462,0x0B1F2621,0x4F413F1D,0x21432341,0xD0DC0E1F,0xB0CDEDDE,\n        0x9FBCE0C3,0x5CDF0DDF,0x0E207D20,0x6E3E0DBC,0x21661070,0x63115303,0x23202F54,0x053431F2,\n        0xE513F437,0x03E204D1,0xDFD1D5C7,0x1C1CFDFE,0x01E3C1D0,0xE302202F,0x13212F12,0x0D3F0E2F,\n        0x13E1DCEE,0x13F2D122,0xAFEFFE21,0x3111E1A0,0x3231303F,0xE1B1E11F,0xF2313001,0x2EFE2F20,\n        0x312123FE,0xDEDFEF30,0x512130EF,0x02421032,0xE1F1D1E1,0x21012301,0x1322201D,0xEFFFEFD1,\n        0xF2C301D3,0x0AEED0D1,0xFD0C2E2D,0x3F1DFEEE,0x0EEFE0E3,0xD3D0E2CD,0x0121E1D0,0xB2EF0DC1,\n        0xFEEEA0E1,0x2F0F3E1E,0x3E313140,0x303F4E20,0x2344422F,0xF1DEEC0F,0x0DFD3234,0x2112F3F0\n    );\n    \n    //Shape data\n    //Bit layout:31--Index--20,19--YPos--10,9--XPos--0\n    //Defines the vertex index and absolute location of each shape's 1st point.\n    const int shapes[] = int[SHAPE_COUNT](\n        0x00094D65,0x02997D57,0x037A4137,0x048A0CB5,0x04EA00BA,0x0539A0BB,0x0582F2C0,0x0713A2CE,\n        0x08A34292,0x09639E9F,0x0FE2B9F4,0x10625117,0x10A290E7,0x1114F5CC,0x12B7381A,0x1305E4A1,\n        0x135770B4,0x146724BF,0x14B73CC9,0x159724D6,0x15E78CBE,0x16288967,0x1668BD75,0x17283D94,\n        0x17783DA9,0x17DB358C,0x1A0B35C8,0x1A7B49DD,0x1B1B3DE3,0x1B7B3DEB,0x1BCA89DA,0x1D3A7DC8,\n        0x1D8B2E30,0x1E6B2237,0x1EE79662,0x1F5AE689,0x201AE295,0x20AA9EE0,0x210A16F1,0x2150C400,\n        0x3734DADB,0x3774CAD8,0x37C4F2C0,0x380496BC,0x38754EB3,0x38B55AB4,0x38F562AD,0x393592A7,\n        0x3985AAA3,0x3A255E6D,0x3A957276,0x3AE58E7C,0x3B35BE72,0x3B95BA6D,0x3BE60E6F,0x3C75D284,\n        0x3EF5525D,0x3F456261,0x3F95625B,0x3FF5C244,0x40368E5B,0x4076A65D,0x40B60668,0x42763E53,\n        0x4406920B,0x44864A2A,0x46F6926A,0x47B72660,0x49B8EA8C,0x4C39F8DA,0x4C7A14BF,0x4CCA78BE,\n        0x4D09784C,0x4D697405,0x4DA9E005,0x4E19C022,0x4E7B0872,0x4EBB187A,0x4F3B2C93,0x4F7B208A,\n        0x503AE087,0x508AF488,0x514AC895,0x524AF87D,0x543B0486,0x5489D504,0x5A6ADD3A,0x5AA1C8ED,\n        0x5AF8A0CE,0x7D3B54E1,0x81EB04A4,0x8249B588,0x828A41B9,0xB5C904B0,0xB698ECAE,0xB758E8B2,\n        0xB8196243,0xB898AD9D,0xBB08FDCE,0xBD48B8BB,0xBDA8CCC2\n    );\n    \n    //Output vectors (hi-byte = shape index, lo-byte = 8-bit vector\n    if(i < VECT_COUNT) \n    {\n        int bytevec = (vects[i/4] >> ((i%4)*8));\n        int shpidx = 0;\n        for(int j = 0;j < SHAPE_COUNT;j++)\n        {\n            if(i >= ((shapes[j]>>20)&0xFFF))\n            {\n                shpidx = j;\n            }\n            else\n            {\n                break;\n            }\n        }\n        \n        vecdata = ((shpidx&0xFF) << 8) | (bytevec&0xFF);\n    }\n    else\n    {\n        i -= VECT_COUNT;\n        \n        //Output shape origins (X/Y)\n        //1 component per-pixel since only the alpha channel is free.\n        if(i < SHAPE_COUNT*2)\n        {\n            vecdata = (shapes[i/2] >> 10*(i%2))&0x3FF;\n        }\n        else //Output 0s for every other address.\n        {\n            vecdata = 0;\n        }\n    } \n    \n    return vec4(1e6, 0, 0, vecdata);\n}\n\n//Get 8-bit vector 'i' from alpha channel\n//and unpack into a vec2 (X,Y) and shape index (Z).\nvec3 GetVector(int i)\n{\n        int v = int(texelFetch(iChannel0, IdxToUV(i, ivec2(0), ivec2(iResolution.xy)), 0).a);\n        \n        int vx = bool(v&0x08) ? -((~v+1)&0x0F) : v&0x0F;\n        v = v >> 4;\n        int vy = bool(v&0x08) ? -((~v+1)&0x0F) : v&0x0F;\n        v = v >> 4;\n        \n        return vec3(vec2(vx, vy) / MAX_EXTENT, v&0xFF);\n}\n\n//Get the absolute location of the 1st of shape 'i'.\nvec2 GetShapeOrigin(int i)\n{\n    i = VECT_COUNT+i*2;\n    ivec2 iRes = ivec2(iResolution.xy);\n    return vec2(\n        texelFetch(iChannel0, IdxToUV(i  , ivec2(0), iRes), 0).a,\n        texelFetch(iChannel0, IdxToUV(i+1, ivec2(0), iRes), 0).a\n    ) / MAX_EXTENT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    \n    //Initialize vector data on 1st frame, stored in alpha channel.\n    if(iFrame == 0) \n    {\n        fragColor = Initialize(ivec2(fragCoord));\n    }\n    //Create SDF from the vector data.\n    else if(iFrame <= (VECT_COUNT/VECS_PER_FRAME+1))\n    {\n        int vidx = (iFrame-1)*VECS_PER_FRAME;\n        vec2 p = fragCoord / iResolution.xy;\n        vec2 p0 = fragColor.yz; \n        float sdf = fragColor.x;\n        \n        for(int i = 0;i < VECS_PER_FRAME;i++)\n        {\n            if(vidx >= VECT_COUNT) { break; } //Stop if loop goes past the last vector.\n            \n            vec3 curvec = GetVector(vidx);\n            vec3 prevec = GetVector(vidx-1);\n            \n            //Get the abs. position for the 1st point.\n            //If the shape index changes, set p0 to the abs. position of the new shape.\n            if(vidx == 0 || curvec.z != prevec.z)\n            {\n                p0 = GetShapeOrigin(int(curvec.z));\n            }\n\n            vec2 p1 = p0 + curvec.xy;\n\n            //Line drawing\n            vec2 line = p1 - p0;\n            float frac = dot(p - p0,line) / dot(line,line);\n            vec2 pnear = (p0 + line * clamp(frac, 0.0, 1.0)) - p;\n            pnear.x = mod(pnear.x+0.5,1.0)-0.5; //Make SDF tile horizontally.\n            float dline = length(pnear * ASPECT);\n            sdf = min(abs(sdf), dline) * sign(sdf); //Combine with SDF (ignoring sign)\n            \n            //N-Gon filling for sign\n            if(p.y >= min(p0.y,p1.y) && p.y < max(p0.y,p1.y)) //If p.y is between the highest & lowest point.\n            {\n                if(p.x > mix(p0.x, p1.x, (p.y-p0.y)/(p1.y-p0.y))) //If p.x is to the left of the line.\n                {\n                    sdf = -sdf; //Flip the sign\n                }\n            }\n            \n            \n            p0 = p1;\n            vidx++;\n        }\n\n        fragColor.xyz = vec3(sdf, p0); \n        \n        //Clear y/z/w channels, put resolution into y,z for re-scaling.\n        if(vidx >= VECT_COUNT)\n        {\n            fragColor = vec4(fragColor.x,iResolution.xy,0);\n        }\n    }\n    else\n    {\n        //Re-scale texture when going full-screen (doesn't work when exiting full screen).\n        vec2 preres = texelFetch(iChannel0,ivec2(0),0).yz;\n        \n        if(preres.xy != iResolution.xy)\n        {\n            vec2 uv = (fragCoord / iResolution.xy) * (preres.xy/iResolution.xy); \n            fragColor.x = texture(iChannel0,uv,0.).x;\n            fragColor.yz = iResolution.xy;\n        }\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 329, 329, 527], [529, 529, 556, 556, 780], [782, 782, 803, 803, 1249], [1251, 1251, 1269, 1269, 1408], [1410, 1410, 1446, 1446, 1821], [1823, 1823, 1844, 1844, 2026], [2028, 2028, 2093, 2093, 2363], [2365, 2365, 2422, 2422, 4383]], "test": "untested"}
{"id": "flVSR3", "name": "Multiple Neighborhood CA 1", "author": "SlackermanzCA", "description": "Continuous Multiple Neighborhood Cellular Automata", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 17, "viewed": 2094, "published": 3, "date": "1641149435", "time_retrieved": "2024-07-30T17:12:38.720815", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   1694635498u, 4226095085u, 1298962833u, 2020130155u, \n    2135025562u, 1647829197u, 378160727u, 1189818446u, \n    1149496229u, 1394460231u, 4274265852u, 1633367525u, \n    3535141065u, 11399993u, 3916609242u, 2744234335u, \n    1397185018u, 1104173041u, 2665923850u, 228527032u, \n    1292958959u, 3022458443u, 2875885750u, 613726745u, \n    1718357156u, 402491926u, 1442626199u, 2009006056u, \n    1825253316u, 1912176025u, 755378218u, 1256568828u, \n    355755581u, 2952268854u, 1508497480u, 820966431u, \n    1604554186u, 1013188591u, 488723696u, 3903464415u, \n    1575565095u, 1974733383u, 1611216358u, 1343267470u, \n    354827142u, 1763231215u, 1191183137u, 2138085688u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1061561997u, 1122038610u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nstruct ConvData {\n\tvec4 \tvalue;\n\tfloat \ttotal;\n};\n\n\nConvData ring( float r ) {\n\n\tconst float psn = 32768.0;\n\n\tfloat tot = 0.0;\n\tvec4  val = vec4(0.0,0.0,0.0,0.0);\n\n\tfloat sq2\t= sqrt(2.0);\n\n\tfloat o_0 = r + 0.5;\n\tfloat o_1 = sq2 * o_0;\n\tfloat o_2 = o_1 / 2.0;\n\tfloat o_3 = sqrt( o_0*o_0 - r*r );\n\tfloat o_4 = o_2 - ( floor(o_2) + 0.5 );\n\tfloat o_5 = floor( o_2 ) + floor( o_4 );\n\n\tfloat i_0 = r - 0.5;\n\tfloat i_1 = sq2 * i_0;\n\tfloat i_2 = i_1 / 2.0;\n\tfloat i_3 = sqrt( i_0*i_0 - r*r );\n\tfloat i_4 = i_2 - ( floor(i_2) + 1.0 );\n\tfloat i_5 = floor( i_2 ) + floor( i_4 );\n\n\tfloat d_0 = ( i_5 ) + 1.0 - ( o_5 );\n\n\tfor(float i = 1.0; i < floor( i_2 ) + 1.0 - d_0; i++) {\n\n\t\tfloat j_0 = sqrt( o_0*o_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_1 = sqrt( i_0*i_0 - (i+0.0)*(i+0.0) );\n\t\tfloat j_2 = ( 1.0 - abs( sign ( (floor( i_2 ) + 1.0) - i ) ) );\n\n\t\tfor(float j = floor( j_1 ) + j_2; j < floor( j_0 ); j++) {\n\t\t\tval += floor(gdv(ivec2( i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i,-(int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-i, (int(j)+1)), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1), i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2( (int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1),-i), txdata) * psn);\n\t\t\tval += floor(gdv(ivec2(-(int(j)+1), i), txdata) * psn);\n\t\t\ttot += 8.0 * psn; } }\n\n//\tOrthagonal\n\tval += floor(gdv(ivec2( r, 0), txdata) * psn);\n\tval += floor(gdv(ivec2( 0,-r), txdata) * psn);\n\tval += floor(gdv(ivec2(-r,-0), txdata) * psn);\n\tval += floor(gdv(ivec2(-0, r), txdata) * psn);\n\ttot += 4.0 * psn;\n\n//\tDiagonal\n//\tTODO This is not quite perfect\n\tfloat k_0 = r;\n\tfloat k_1 = sq2 * k_0;\n\tfloat k_2 = k_1 / 2.0;\n\tfloat k_3 = sqrt( k_0*k_0 - r*r );\n\tfloat k_4 = k_2 - ( floor(k_2) + 1.0 );\n\tfloat k_5 = floor( k_2 ) + floor( k_4 );\n\n\tfloat dist = round(k_2);\n\n\tif( sign( o_4 ) == -1.0 ) {\n\t//\tval += gdv(ivec2( (floor(o_5)+1), floor(o_5)+1), txdata);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2( (floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0),-(floor(o_5)+1.0)), txdata) * psn);\n\t\tval += floor(gdv(ivec2(-(floor(o_5)+1.0), (floor(o_5)+1.0)), txdata) * psn);\n\t\ttot += 4.0 * psn; }\n\n\treturn ConvData( val, tot ); }\n\n\nvec4 conv( float r ) {\n\tConvData nh = ring( r );\n\treturn \tnh.value / nh.total; }\n    \nvec4 bitmake(ConvData[MAX_RADIUS] rings, uint bits, uint of) {\n\tvec4  sum = vec4(0.0,0.0,0.0,0.0);\n\tfloat tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings[i].value; tot += rings[i].total; } }\n\treturn sum / tot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tConvData[MAX_RADIUS] nh_rings_m;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) { nh_rings_m[i] = ring(float(i+1u)); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  128.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub[2],  ub[3],\n\t\tub[4],  ub[5],  ub[6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tvec4[12] smnca_res = vec4[12](res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c,res_c);\n\n\tvec4 conv1 = conv(1.0);\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n                \n\t\tvec4 nhv = bitmake( nh_rings_m, nb[i/2u], (i & 1u) * 16u );\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 0u) && nhv[cho] <= utp( ur[i], 8u, 1u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * res_c[chm]; }\n\n\t\tif( nhv[cho] >= utp( ur[i], 8u, 2u) && nhv[cho] <= utp( ur[i], 8u, 3u)) {\n\t\t\tsmnca_res[i/4u][chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * res_c[chm]; } }\n\n\tuvec4 dev_idx = uvec4(0u,0u,0u,0u);\n    \n\tvec4 dev = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < 6u; i++) {\n\t\tvec4 smnca_res_temp = abs(res_c - smnca_res[i]);\n\t\tif(smnca_res_temp[0] > dev[0]) { dev_idx[0] = i; dev[0] = smnca_res_temp[0]; }\n\t\tif(smnca_res_temp[1] > dev[1]) { dev_idx[1] = i; dev[1] = smnca_res_temp[1]; }\n\t\tif(smnca_res_temp[2] > dev[2]) { dev_idx[2] = i; dev[2] = smnca_res_temp[2]; }\n\t\tif(smnca_res_temp[3] > dev[3]) { dev_idx[3] = i; dev[3] = smnca_res_temp[3]; } }\n\n\tres_v[0] = smnca_res[dev_idx[0]][0];\n\tres_v[1] = smnca_res[dev_idx[1]][1];\n\tres_v[2] = smnca_res[dev_idx[2]][2];\n\tres_v[3] = smnca_res[dev_idx[3]][3];\n\n    res_c = ((res_v + (conv1 * (s*2.13333))) / (1.0 + (s*2.13333)))- 0.01 * s;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]], "test": "untested"}
{"id": "7tGXR3", "name": "Floating Line", "author": "Kingfish404", "description": "indoor practice", "tags": ["helloshader"], "likes": 1, "viewed": 184, "published": 3, "date": "1641125854", "time_retrieved": "2024-07-30T17:12:39.495743", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    \n    if((uv.x-0.5)*(uv.x-0.5)+(uv.y-0.5)*(uv.y-0.5)<0.05){\n        col = vec3(1.0,0.4,0.4);\n    }else if(uv.y < cos(iTime)*0.25+0.4){\n        col = vec3(0.0,0.5,0.7);\n    }else if(uv.y < sin(iTime*2.5)*0.25+0.5){\n        col = vec3(1.0,1.0,1.0);\n    }else {\n        col = vec3(0.4,0.8,1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,0.4);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 525]], "test": "untested"}
{"id": "slGSR3", "name": "Fork mandelbulb rogo1965 883", "author": "rogo1965", "description": "a mandelbulb", "tags": ["raymarching", "fractal", "cineshader"], "likes": 25, "viewed": 5092, "published": 3, "date": "1641121908", "time_retrieved": "2024-07-30T17:12:40.269673", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 9; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.2;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, iTime*0.2);// rotation of mb\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<96; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n     \n    pixel_size = 1.0/(iResolution.x * 3.0);\n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.01, 2.2, 0.01);\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + /*zoom*/5.0*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.2); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n    float halo= clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           vec3 n=nor(p); \n           float shadow = softshadow(p, sundir, 10.0 );\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * shadow; \n           lin += 0.8 * bac * sun; \n           lin += 0.6 * sky * skycolor*shadow; \n           lin += 3.0 * spe * shadow; \n\n\t\t   res.y = pow(clamp(res.y, 0.0, 1.0), 0.95);\n\t\t   vec3 tc0 = 0.5 + 0.5 * cos(-6.0*iTime + 9.2 * res.y + vec3(0.9, 0.0, 0.0));\n           col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    //col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGSR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[190, 190, 221, 221, 339], [571, 571, 588, 588, 1203], [1206, 1206, 1221, 1221, 1282], [1287, 1287, 1332, 1332, 1566], [1569, 1569, 1594, 1594, 1805], [1807, 1807, 1849, 1849, 2866], [2869, 2869, 2928, 2928, 5000]], "test": "untested"}
{"id": "ftGSzc", "name": "Night Garden*", "author": "wyatt", "description": "... Thanks Fabrice, now animated with faked dof", "tags": ["dof"], "likes": 32, "viewed": 454, "published": 3, "date": "1641109253", "time_retrieved": "2024-07-30T17:12:41.086490", "image_code": "vec2 R;\nfloat T;\n\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat ln (vec3 p, vec3 a, vec3 b) {\n    float l = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n    return mix(.75,1.,l)*length(p-a-(b-a)*l);\n}\nvec4 map (vec3 u) {\n    u.xz *= ei(1.1+T);\n    u.xy *= ei(1.1);\n    float d = 1e9;\n    vec4 c=vec4(0);\n    float sg = 1e9;\n    float l = .08;\n    u.y = abs(u.y);\n    u.y+=.1;\n    mat2 M1 = ei(1.);\n    float w = 0.02;\n    mat2 M2 = ei(.6);\n    mat2 M3 = ei(.4+.2*sin(T));\n    for (float i = 1.; i < 20.; i++)\n    {\n        sg = ln(u,vec3(0),vec3(0,l,0))/l;\n        d = min(d,sg*l-w);\n        w *= .7;\n        u.y -= l;\n        u.xz *= M1;\n        u.xz = abs(u.xz);\n        u.zy *= M3;\n        l *= .75;\n        c += exp(-sg*sg)*(.7+.5*sin(2.+3.*i/16.+vec4(1,2,3,4)));\n    }\n    return vec4(c.xyz,d);\n}\n\n\nvoid mainImage(out vec4 Q, vec2 U ) {\n    R = iResolution.xy; T = iTime;\n    Q = vec4(0);\n    vec3 p = vec3( .3*(U-.5*R)/R.y, 2);\n    vec3 d = normalize( vec3(0,0,.74) - p );\n    for (float i = 0.; i < 30.; i++){\n        vec4 x = map(p);\n        float f = 1./(1.+1e3*abs(p.z-.2));\n        p += d* max( abs(x.w), 2e-5/f );\n        Q += .01*x*exp(-1e3*(x.w*x.w)*f);\n       \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 103, 103, 205], [206, 206, 225, 225, 806], [809, 809, 846, 846, 1188]], "test": "untested"}
{"id": "ftySRc", "name": "Night Garden", "author": "wyatt", "description": "Integrating an aperture to get a depth of field. ", "tags": ["dof"], "likes": 29, "viewed": 503, "published": 3, "date": "1641096705", "time_retrieved": "2024-07-30T17:12:41.856431", "image_code": "// Fork of \"MRI\" by wyatt. https://shadertoy.com/view/7lySRK\n// 2022-01-02 03:55:13\n\n// Fork of \"Microscopy 102 Test\" by wyatt. https://shadertoy.com/view/ftGXzV\n// 2021-12-31 22:06:32\n\n// Fork of \"Microscopy 101\" by wyatt. https://shadertoy.com/view/NlKSzG\n// 2021-12-31 17:42:39\n\n\nMain \n    Q = .8*atan(A(U)/float(iFrame));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nfloat T;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) {R = iResolution.xy;T = iTime;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159265359\n#define _sin(a) sin(mod(a,2.*pi))\n#define _cos(a) cos(mod(a,2.*pi))\n\n\nfloat ln (vec3 p, vec3 a, vec3 b) {\n    float l = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n    return mix(.69,.9,l)*length(p-a-(b-a)*l);\n}\nvec4 map (vec3 u) {\n    u.y += .03;\n    u.xz *= ei(1.1);\n    u.xy *= ei(1.5);\n    float d = 1e9;\n    vec4 c=vec4(0);\n    float sg = 1e9;\n    float l = .1;\n    u.y = abs(u.y);\n    u.y+=.1;\n    mat2 M1 = ei(.9);\n    float w = 0.05;\n    for (float i = 1.; i < 20.; i++)\n    {\n        sg = ln(u,vec3(0),vec3(0,l,0))/l;\n        d = min(d,sg*l-w);\n        w *= .69;\n        u.y -= l;\n        u.xz *= M1;\n        u.xz = abs(u.xz);\n        u.xy *= M1;\n        l *= .66;\n        c += .2*i*exp(-sg*sg)*(.5+.5*sin(2.+4.*i/16.+vec4(1,2,3,4)));\n    }\n    return vec4(c.xyz,d);\n}\n// Dave H\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n", "buffer_a_code": "Main \n    Q = A(U);\n    vec3 p = vec3(.18*(U-.5*R)/R.y,2.0408);\n    float i = float(iFrame);\n    vec2 a = .05*vec2(sin(i),cos(i));\n    p.xy += a;\n    vec3 f = vec3(-a,.74);\n    vec3 d = normalize(f-p);\n    d.xy += a;\n    d = normalize(d);\n    p.z += 0.;\n    for (float i = -0.; i < 60.;i++){\n        vec4 x =  map(p);\n        p += d*max(abs(x.w),1e-4);\n        Q += .02*x*exp(-1e7*x.w*x.w);\n       \n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftySRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlySz3", "name": "2D Wave Equation", "author": "oneshade", "description": "A solution to the 2D wave equation.", "tags": ["2d", "waves", "sinusoidal", "boundaries", "pde"], "likes": 24, "viewed": 534, "published": 3, "date": "1641087298", "time_retrieved": "2024-07-30T17:12:42.712143", "image_code": "// https://www.desmos.com/calculator/nl0ncpf8aw\n\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n#define wavelet(k, p, t) k.x * sin(k.y * p.x) * sin(k.z * p.y) * cos(length(k.yz) * t)\nfloat mapScene(in vec3 p, out vec3 color) {\n    float tilt = -0.5;\n    float co = cos(tilt), si = sin(tilt);\n    p.yz *= mat2(co, -si, si, co);\n\n    float turn = 0.25 * iTime;\n    co = cos(turn), si = sin(turn);\n    p.xz *= mat2(co, -si, si, co);\n\n    p.xz += RHO;\n    p.y += 0.5;\n\n    float time = iTime;\n    float height = wavelet(vec3(1.0, 1.0, 2.0), p.xz, time);\n    height += wavelet(vec3(0.4, 2.0, 3.0), p.xz, time);\n    height += wavelet(vec3(0.1, 5.0, 2.0), p.xz, time);\n    float liquid = p.y - height;\n\n    float cutout = max(abs(p.x - RHO), abs(p.z - RHO)) - RHO;\n    cutout = max(cutout, -p.y - 1.25);\n    float box = max(abs(cutout - 0.05) - 0.05, p.y - 0.25);\n    liquid = max(liquid, cutout);\n\n    float ground = p.y + 1.5;\n\n    float dist = box;\n    color = vec3(0.8, 0.2, 0.0) * (1.0 - pow(0.5 + 0.5 * sin(3.0 * PI * (p.y + 0.05)), 25.0));\n    if (liquid < dist) { color = vec3(0.0, 0.25, 1.0); dist = liquid; }\n    if (ground < dist) { color = vec3(1.2); dist = ground; }\n\n    return dist * 0.25;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 color = vec3(0.0);\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy, color) - mapScene(p - e.xyy, color),\n                          mapScene(p + e.yxy, color) - mapScene(p - e.yxy, color),\n                          mapScene(p + e.yyx, color) - mapScene(p - e.yyx, color)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 light = vec3(-0.58, 0.58, 0.58);\n    vec3 sky = mix(vec3(1.0), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * rd.y);\n    vec3 shade = vec3(0.0);\n\n    float t = 0.0;\n    for (int i=0; i < 300; i++) {\n        vec3 p = ro + rd * t;\n        vec3 color = vec3(0.0);\n        float dist = mapScene(p, color);\n        if (dist < 0.001) {\n            vec3 nor = getNormal(p);\n            shade = color * max(0.2, dot(nor, light));\n            break;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += dist;\n    }\n\n    shade = mix(shade, sky, smoothstep(0.7, 0.99, t / 20.0));\n    fragColor.rgb = pow(max(shade, 0.0), vec3(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlySz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 231, 231, 1204], [1206, 1206, 1233, 1233, 1545], [1547, 1547, 1602, 1602, 2395]], "test": "untested"}
{"id": "stGXzK", "name": "google", "author": "xnio94", "description": "a single-pass shader that draws google logo", "tags": ["text", "short", "google", "singlepass"], "likes": 5, "viewed": 263, "published": 3, "date": "1641086694", "time_retrieved": "2024-07-30T17:12:43.560874", "image_code": "/*\n//original code with color\n#define s smoothstep\nvec2 u;float x,y,z,t;\n#define h(r,a,b) (1.-s(z,.01,abs(x*x+y*y-r*r)-.17*r))*s(z,.01,abs(atan(y,x)-a)/3.14-b)/.01\n#define k(a,b,p) ((1.-s(z,.01,abs(x+p*y)-a))*(1.-s(z,.01,abs(y-p*x)-b)))/.01\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    u=i/iResolution.y*4.-2.;\n    t=iTime/2.;t=sin(t*2.)+cos(t/.17)+sin(t)*2.;t=sin(t*2.)+3.;u+=sin(u*t+t*5.)/5.;//wobble\n    x=u.x+.5;y=u.y;\n    //G\n    o.z+=h(.7,.39,.12);x-=.4;o.z+=k(.38,.09,z);\n    //oo\n    x-=.9;y+=.3; o.x+=h(.4,z,-x);x--; o.xy+=h(.4,z,-x);x--; //fix by @iq, h(,9.,z) also work great by @FabriceNeyret2\n    //g\n    o.z+=h(.4,z,z);\n    y+=.5;x=-x;o.z+=h(.4,1.57,.66);x=-x-.39;y-=.5;\n    o.z+=k(.09,.5,z);\n    //L\n    x-=.3;y-=.2;o.y+=k(.1,.7,z);\n    //e\n    x-=.7;y+=.2;o.x+=h(.4,z,.16);y-=.08;o.x+=k(.14,.8,-1.8);\n    o*=.03;\n}\n*/\n#define s smoothstep\nvec2 u,v;float x,y;\n#define g(r) (1.-s(0.,.0001,abs(x*x+y*y-r*r)-.02*r))\n#define h(r,a,b) (g(r)*s(0.,.001,abs(atan(y,x)-a)/3.14-b))\n#define gg g(.05)\n#define k(a,b,p) ((1.-s(0.,.001,abs(x+p*y)-a))*(1.-s(0.,.001,abs(y-p*x)-b)))\nfloat google()\n{\n    float c;    \n    x+=.4;y+=.3;\n    c=h(.08,.39,.12);\n    x-=.04;\n    c+=k(.05,.011,0.);\n    x-=.12;\n    y+=.033;\n    c+=g(.05);\n    x-=.13;\n    c+=g(.05);    \n    x-=.13;\n    c+=g(.05);\n    y+=.06;\n    x=-x;\n    c+=h(.05,1.57,.66);\n    x=-x;y-=.06;\n    x-=.05;\n    c+=k(.011,.06,0.);\n    x-=.04;y-=.02;\n    c+=k(.011,.08,0.);\n    x-=.09;y+=.02;\n    c+=h(.05,0.,1./6.);\n    y-=.01;\n    c+=k(.018,.1,-1.8);\n    \n    return c;\n}\nvoid mainImage( out vec4 o, in vec2 i )\n{\n\n    u = i/iResolution.y-.5;    //u*=iTime;\n    v=u*.45-.3;\n    float zom =5.;\n    float t = iTime/3.;\n    u=mod(u+.3*vec2(cos(t),sin(t)),vec2(.8,.3)/zom)*zom-.5;\n    //u=mod(u,1./zom)*zom-.5;\n    \n    x=u.x;y=u.y;\n    float j = google();\n    x=v.x;y=v.y;\n    //j*=1.-google();\n    j=max(j,0.);\n    x=v.x;y=v.y;\n    j*=clamp(google(),0.,1.);\n    o = vec4(vec3(j), 1.0);\n    //o = vec4(vec3(s(0.,.001,length(u-.5)-.1)), 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1083, 1083, 1099, 1099, 1528], [1529, 1529, 1570, 1570, 1997]], "test": "untested"}
{"id": "NtGSz3", "name": "Camera control example", "author": "vipiao", "description": "Simple shader for camera control.\nUse WASD for translating the camera.\nUse arrow keys to rotate camera.\nHold C or V to increase or decrease translational velocity.\nHold R or T to zoom in and out.", "tags": ["raymarching", "reflection", "control", "infinite"], "likes": 4, "viewed": 378, "published": 3, "date": "1641086113", "time_retrieved": "2024-07-30T17:12:44.525295", "image_code": "\n# define MAX_NUM_STEPS 75\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\n\nfloat sdSphereWorld(in vec3 pos){\n    pos = mod(pos, 1.0);\n    return sdSphere(pos, vec3(0.5), 0.25);\n}\n\nvec3 normalSphereWorld(in vec3 pos){\n    float sd = sdSphereWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdSphereWorld(pos - e.xyy),\n    \tsdSphereWorld(pos - e.yxy),\n    \tsdSphereWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    float zoom = texelFetch(iChannel0, ivec2(CAMERA_ZOOM, 0), 0).x;\n    vec3 viewDir = normalize(forward*0.8*zoom + right * uv.x + up * uv.y);\n    \n    // Calculate color.\n    vec3 color = vec3(0.1,0,0);\n    vec3 reflectionConstant = vec3(1.0);\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.0;\n    int maxNumSteps = MAX_NUM_STEPS;\n    int numSteps = 0;\n    float minDist = 0.001;\n    vec3 prevPos = pos;\n    float prevSD = 0.0;\n    float sd = 0.0;\n    for(; numSteps < maxNumSteps; numSteps++){\n        prevSD = sd;\n        sd = sdSphereWorld(pos);\n        if(sd < minDist){\n            // Collision with sphere.\n            pos = mix(pos, prevPos, (minDist - sd) / (prevSD - sd));\n            \n            vec3 normal = normalSphereWorld(pos);\n            if(dot(dir, normal) < 0.0){\n                dir = reflect(dir, normal);\n                reflectionConstant *= 0.8;\n                if(mod(pos.x, 0.1) < 0.01 || mod(pos.y, 0.1) < 0.01 || mod(pos.z, 0.1) < 0.01){\n                    if(mod(pos.x, 2.0) < 1.0){\n                        reflectionConstant.x *= 0.4;\n                    }\n                    if(mod(pos.y, 2.0) < 1.0){\n                        reflectionConstant.y *= 0.4;\n                    }\n                    if(mod(pos.z, 2.0) < 1.0){\n                        reflectionConstant.z *= 0.4;\n                    }\n                }\n            }\n            //\n        }\n        prevPos = pos;\n        pos += normalize(dir) * sd;\n        dist += sd;\n        color += vec3(0.04,0.05,0.06) * sd * reflectionConstant;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --Global variables.\n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_T  = 84;\n\n//\nconst int PREVIOUS_TIME = 0;\n\nconst int CAMERA_POS = 2;\nconst int CAMERA_SENSITIVITY = 3;\nconst int CAMERA_DIRECTION = 4;\nconst int CAMERA_ZOOM = 5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.03;\n            prevColor.r = 0.03;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 1000.){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.00001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Zoom.\n    float zoom = texelFetch(iChannel0, ivec2(CAMERA_ZOOM, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_ZOOM,0)){\n        if(zoom == 0.){\n            zoom = 1.0;\n            prevColor.r = 1.0;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_R,0), 0 ).x > 0.5){\n            prevColor.r *= 1.02;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_T,0), 0 ).x > 0.5){\n            prevColor.r /= 1.02;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,1,0);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        bool arrowRight = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        float rotationSensitivity = 0.018/zoom;\n        if(arrowRight){\n            forward = normalize(forward + right*rotationSensitivity);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*rotationSensitivity);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*rotationSensitivity);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*rotationSensitivity);\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,0,1)));\n    \tvec3 up = cross(right, forward);\n        prevColor.xyz = normalize(forward);\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel1, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(wDown){\n        \tprevColor.xyz += forward*sensitivity;\n        }\n        if(sDown){\n        \tprevColor.xyz -= forward*sensitivity;\n        }\n        if(dDown){\n        \tprevColor.xyz += right*sensitivity;\n        }\n        if(aDown){\n        \tprevColor.xyz -= right*sensitivity;\n        }\n        if(spaceDown){\n        \tprevColor.xyz += up*sensitivity;\n        }\n        if(shiftDown){\n        \tprevColor.xyz -= up*sensitivity;\n        }\n    }\n    \n    \n    \n    // Write data/color.\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 89, 89, 131], [133, 133, 166, 166, 236], [238, 238, 274, 274, 505], [507, 507, 564, 564, 2633]], "test": "untested"}
{"id": "flKXzK", "name": "my_perlin", "author": "Venay", "description": "Perlin Noise practice", "tags": ["noise", "perlin"], "likes": 1, "viewed": 185, "published": 3, "date": "1641053476", "time_retrieved": "2024-07-30T17:12:45.382004", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (fragCoord-.5*iMouse.xy)/iMouse.y;\n    \n    fragColor = vec4(perlin(uv*15.));\n}", "image_inputs": [], "common_code": "#define v01 vec2(0,1)\n#define v10 vec2(1,0)\nfloat r21(vec2 p){\n    p = fract(p*vec2(233.65,987.56));\n    p += dot(p,p+456.645);\n    return fract(p.x*p.y);\n}\nvec2 r22(vec2 p){\n    float n = r21(p);\n    return vec2(n, r21(p +n));\n}\nvec2 toMinusOneOne(vec2 v){return v*2.-1.;}\n\nfloat perlin(vec2 uv){\n    vec2 id=floor(uv);\n    vec2 gv=fract(uv);\n    \n    vec2 r00 = toMinusOneOne( r22(id) );\n    vec2 r01 = toMinusOneOne( r22(id+v01) );\n    vec2 r10 = toMinusOneOne( r22(id+v10) );\n    vec2 r11 = toMinusOneOne( r22(id+1.) );\n    \n    vec2 g00 = gv;\n    vec2 g01 = gv-v01;\n    vec2 g10 = gv-v10;\n    vec2 g11 = gv-1.;\n    \n    float d00 = dot(r00,g00);\n    float d01 = dot(r01,g01);\n    float d10 = dot(r10,g10);\n    float d11 = dot(r11,g11);\n    \n    vec2 w = gv*gv*(3.-2.*gv);\n    float x1 = mix(d00,d10,w.x);\n    float x2 = mix(d01,d11,w.x);\n    float x  = mix(x1, x2, w.y);\n    x = x*.5+.5;\n    \n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 259]], "test": "untested"}
{"id": "slVSRy", "name": "Apparent motion illusion", "author": "sheepmaster", "description": "Apparent motion illusion; see comments for details.", "tags": ["2d", "sdf", "illusion", "opticalillusion", "motion"], "likes": 10, "viewed": 239, "published": 3, "date": "1641051619", "time_retrieved": "2024-07-30T17:12:46.309525", "image_code": "// The apparent motion is created by having a foreground object\n// that is cycling through a series of colors\n// (either rainbow colors or black and white)\n// while shifting the phase forward or backwards\n// where the edges are orthogonal to the perceived motion\n// (see https://jake.vision/blog/motion-illusions\n// for a detailed explanation).\n// Using a signed distance function for the object\n// allows us to get the gradient of the SDF\n// and therefore the normal of the edge at the same time\n// (see https://iquilezles.org/articles/distgradfunctions2d),\n// so the phase shift is just the dot product of the negative gradient\n// with the apparent movement vector.\n// The object can be easily changed by picking a different SDF.\n\n// Width of the border area, in pixels.\nconst float BORDER_WIDTH = 1.;\n\n// How far the edges of the object are phase-shifted.\nconst float PHASE_SHIFT_SPEED = 7.;\n\n// Period of the foreground color cycle, in seconds.\nconst float PERIOD = 1.0;\n\n// Whether the colors are cycling through a rainbow\n// or between black and white.\nconst bool RAINBOW_COLORS = false;\n\n// Whether the apparent movement is in a circle\n// or growing / shrinking.\nconst bool CIRCULAR_MOVEMENT = true;\n\n// Period for the circular movement, in seconds.\nconst float CIRCULAR_MOVEMENT_PERIOD = 8.;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.5, 0.5, 1.);\n\nconst float TAU = 8. * atan(1.);\n\nvec3 hue(float h) {\n    return clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n}\n\n// Returns a vector consisting of the signed distance function\n// of the desired object (an annulus, or ring) in the first component,\n// and the gradient of the SDF in the second and third component.\nvec3 sdgAnnulus(in vec2 p, in float r, in float w) {\n    float l = length(p);\n    return vec3(abs(l - r) - w * 0.5, sign(l - r) * p / l);\n}\n\nvec3 foregroundColor(float phase) {\n    if (RAINBOW_COLORS) {\n        return hue(phase);\n    } else {\n        return vec3((cos(phase * TAU) + 1.) * .5);\n    }\n}\n\nvec2 movement(vec2 p) {\n    if (CIRCULAR_MOVEMENT) {\n        float theta = fract(iTime / CIRCULAR_MOVEMENT_PERIOD) * TAU;\n        return vec2(sin(theta), cos(theta));\n    } else {\n        return p / length(p);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy * vec2(0.5, 1.);\n    float scale = 2. / min(res.x, res.y);\n\tvec2 p = (mod(fragCoord, res) - res * 0.5) * scale;\n    float tileSign = sign(fragCoord.x / res.x - 1.);\n\n\tvec3 sdg = sdgAnnulus(p, 0.5, 0.2);\n    \n    float phase = fract(iTime / PERIOD);\n    float maxPhaseShift = BORDER_WIDTH / (PHASE_SHIFT_SPEED * PERIOD);\n    float phaseShift = dot(movement(p), -sdg.yz) * maxPhaseShift * tileSign;\n    \n    vec3 col = foregroundColor(\n        mix(phase, phase + phaseShift, smoothstep(-BORDER_WIDTH * scale, 0., sdg.x))\n    );\n    col = mix(col, BACKGROUND_COLOR, smoothstep(0., scale, sdg.x));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1386, 1386, 1405, 1405, 1482], [1484, 1684, 1736, 1736, 1823], [1825, 1825, 1860, 1860, 1985], [1987, 1987, 2010, 2010, 2204], [2206, 2206, 2261, 2261, 2920]], "test": "untested"}
{"id": "NtKSzK", "name": "HappyNewYear2022", "author": "yasuo", "description": "Happy New Year!", "tags": ["2022"], "likes": 23, "viewed": 290, "published": 3, "date": "1641050860", "time_retrieved": "2024-07-30T17:12:47.263973", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p.x)-s.x,abs(p.y)-s.y)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define YELLOW vec3(0.76,0.7,0.0)\n\nfloat hash(vec2 p){\n    vec2 rand = fract(sin(p*123.456)*567.89);\n    rand += dot(rand,rand*34.56);\n    return fract(rand.x*rand.y);\n}\n\nfloat tigerBodyPaint(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.05,0.08));\n    float a = radians(-20.0);\n    p.x+=0.02;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    return d;\n}\n\nfloat hempParts(vec2 p){\n    vec2 prevP = p;\n    \n    p.x = abs(p.x)-0.033;\n    p*=Rot(radians(-30.0));\n    \n    float d = B(p,vec2(0.002,0.07));\n    p = prevP;\n    p.y+=0.062;\n    float d2 = B(p,vec2(0.07,0.002));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y-=0.02;\n    d2 = B(p,vec2(0.002,0.035));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.04;\n    p.x = abs(p.x)-0.033;\n    p*=Rot(radians(-55.0));\n    d2 = B(p,vec2(0.002,0.04));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat hempParts2(vec2 p){\n    vec2 prevP = p;\n    p.y = abs(p.y)-0.058;\n    p.y*=-1.0;\n    float d = hempParts(p);\n    return d;\n}\n\nfloat hempParts3(vec2 p){\n    vec2 prevP = p;\n\n    float d = hempParts2(p);\n\n    p*=Rot(radians(60.0));\n    \n    float d2 = hempParts2(p);\n    d = min(d,d2);\n    p*=Rot(radians(60.0));\n    d2 = hempParts2(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat tigerBodyPaint2(vec2 p){\n    p*=1.5;\n    vec2 prevP = p;\n\n    p.x = mod(p.x,0.24)-0.12;\n    p.y = mod(p.y,0.42)-0.21;\n    float d = hempParts3(p*Rot(radians(90.0)));\n    p = prevP;\n    p.x+=0.12;\n    p.y+=0.21;\n    p.x = mod(p.x,0.24)-0.12;\n    p.y = mod(p.y,0.42)-0.21;\n    float d2 = hempParts3(p*Rot(radians(90.0)));\n    \n    return min(d,d2);\n}\n\nvec3 spring(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.1,0.015));\n    p.x-=0.1;\n    p.y=abs(p.y)-0.05;\n    float d2 = abs(length(p)-0.05)-0.015;\n    d = min(d,d2);\n    col = mix(col,vec3(0.6)*brightness,S(d,0.0));\n    return col;\n}\n\nvec3 tigerHead(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    \n    float d = B(p,vec2(0.17,0.1));\n    float a = radians(45.0);\n    p.y = abs(p.y)-0.22;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    \n    a = radians(70.0);\n    p.y+=0.1;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    \n    a = radians(-50.0);\n    p.y-=0.205;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x-=0.07;\n    p.y-=0.15;\n    float d2 = B(p,vec2(0.05,0.05));\n    \n    p.x = abs(p.x)-0.031;\n    a = radians(20.0);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d,d2);\n    \n    col = mix(col,YELLOW*brightness,S(d,0.0));\n    \n    p = prevP;\n    p.x-=0.07;\n    p.y-=0.15;\n    d = B(p,vec2(0.05,0.05));\n    \n    p.x = abs(p.x)-0.02;\n    a = radians(20.0);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    d = max(abs(p.y-0.005)-0.03,d);\n    \n    col = mix(col,vec3(0.7,0.0,0.0)*brightness,S(d,0.0));    \n    \n    p = prevP;\n    d = length(p-vec2(-0.03,0.04))-0.04;\n    col = mix(col,vec3(1.0)*brightness,S(d,0.0));\n    \n    d = length(p-vec2(-0.03,0.04))-0.025;\n    col = mix(col,vec3(.0)*brightness,S(d,0.0));\n        \n    d = length(p-vec2(-0.11,0.06))-0.015;\n    col = mix(col,vec3(0.0)*brightness,S(d,0.0));\n    \n    p.x-=0.12;\n    p.y+=0.03;\n    p*=Rot(radians(-30.));\n    d = B(p,vec2(0.07,0.01));\n    p = prevP;\n    d = max(p.x-0.17,d);\n    col = mix(col,vec3(1.0)*brightness,S(d,0.0));\n    \n    p = prevP;\n    \n    p.x+=0.06;\n    p.y+=0.03;    \n    p*=Rot(radians(15.));\n    d = B(p,vec2(0.13,0.01));\n    p = prevP;\n    d = max(-p.x-0.17,d);\n    col = mix(col,vec3(1.0)*brightness,S(d,0.0));    \n    \n    p.x-=0.11;\n    p.y-=0.053;\n    p*=2.0;\n    p*=Rot(radians(45.0));\n    d = tigerBodyPaint(p);\n    \n    p.x-=0.08;\n    p.y-=0.001;\n    d2 = tigerBodyPaint(p);\n    \n    d = min(d,d2);\n    col = mix(col,vec3(0.0)*brightness,S(d,0.0)); \n    \n    return col;\n}\n\nvec3 tigerBody(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    \n    float d = B(p,vec2(0.25,0.2));\n    float a = radians(40.0);\n    p.x = abs(p.x)-0.37;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    \n    a = radians(-10.0);\n    p.x = abs(p.x)-0.26;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    \n    a = radians(-10.0);\n    p.x = abs(p.x)-0.159;\n    p.y+=0.23;\n    \n    float d2 = B(p,vec2(0.07,0.05));\n    p.x = abs(p.x)-0.06;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    d2 = d;\n    col = mix(col,YELLOW*0.98*brightness,S(d,0.0));\n    \n    p = prevP;\n    d = tigerBodyPaint2(p);\n    d = max(d2,d);\n    col = mix(col,YELLOW*0.58*brightness,S(d,0.0));\n    \n    p = prevP;\n    d2 = max(p.y+0.25,d2);\n    col = mix(col,vec3(1.0)*brightness,S(d2,0.0));\n    \n    p = prevP;\n    d = length(p-vec2(0.1,-0.03))-0.07;\n    col = mix(col,vec3(1.0)*brightness,S(d,0.0));\n    d = length(p-vec2(0.1,-0.03))-0.055;\n    col = mix(col,vec3(0.0)*brightness,S(d,0.0));\n        \n    d = length(p-vec2(-0.13,-0.14))-0.04;\n    col = mix(col,vec3(1.0)*brightness,S(d,0.0));\n    d = length(p-vec2(-0.13,-0.14))-0.025;\n    col = mix(col,vec3(0.0)*brightness,S(d,0.0));\n    \n    p.x+=0.03;\n    p.y-=0.11;\n    p.y*=0.9;\n    d = tigerBodyPaint(p);\n    \n    d2 = tigerBodyPaint(p-vec2(0.1,0.0));\n    d = min(d,d2);\n    \n    d2 = tigerBodyPaint(p-vec2(-0.1,0.0));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0)*brightness,S(d,0.0));\n    \n    p = prevP;\n    p.x+=0.23;\n    p.y-=0.05;\n    d = B(p,vec2(0.02,0.14));\n    a = radians(-40.0);\n    p.y = abs(p.y);\n    p.y-=0.117;\n    \n    d = max(-dot(p,vec2(cos(a),sin(a))),d);    \n    \n    col = mix(col,vec3(0.7,0.0,0.0)*brightness,S(d,0.0));\n    \n    p = prevP;\n    \n    p.x-=0.01;\n    p.y+=0.133;\n    p.x*=1.5;\n    p.y*=-1.2;\n    d = tigerBodyPaint(p-vec2(-0.04,0.0));\n    \n    d2 = tigerBodyPaint(p-vec2(0.04,0.0));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0)*brightness,S(d,0.0));\n    \n    return col;\n}\n\nvec3 tail(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    \n    p.x+=0.04;\n    float mask = B(p,vec2(0.2,0.06));\n    p = prevP;\n    float d = B(p,vec2(0.2,0.1));\n    float d2 = d;\n    d = max(-mask,d);\n    col = mix(col,YELLOW*0.98*brightness,S(d,0.0));\n    \n    p.x+=iTime*0.1;\n    p*=Rot(radians(45.0));\n    p.x = mod(p.x,0.05)-0.025;\n    d = abs(p.x)-0.01;\n    d = max(d2,d);\n    d = max(-mask,d);\n    col = mix(col,vec3(0.0)*brightness,S(d,0.0));  \n    \n    return col;\n}\n\nvec2 animateBody(vec2 p){\n    float frame = mod(iTime,0.4);\n    if(frame<0.2){\n        p.y-=0.01;\n    } else {\n        p.y+=0.01;\n    }\n    return p;\n}\n\nvec3 tiger(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    \n    // shadow\n    p-=vec2(0.1,-0.35);\n    p.x*=0.2;\n    p.y*=1.5;\n    float frame = mod(iTime,0.4);\n    float s = 0.1;\n    if(frame<0.2){\n        s = 0.09;\n    }\n    float d = length(p)-s;\n    col = mix(col,vec3(0.0),S(d,-0.1));    \n    p = prevP;\n    \n    p = animateBody(p);  \n    \n    // spring\n    p-=vec2(0.4,-0.1);\n    s = 1.0;\n    frame = mod(iTime,0.4);\n    if(frame<0.1){\n        s = 1.0;\n    } else if(frame>=0.1 && frame<0.2){\n        s = 2.5;\n    } else if(frame>=0.2 && frame<0.3){\n        s = 5.0;\n    } else if(frame>=0.3 && frame<0.4){\n        s = -2.5;\n    }\n    \n    p.y*=s;\n    col = spring(p,col,brightness);\n    \n    // tail\n    p = prevP;\n    p = animateBody(p); \n    col = tail(p-vec2(0.25,0.15),col,brightness);    \n    \n    // head\n    animateBody(p);\n    p*=Rot(radians(sin(iTime*5.0)*5.0));\n    col = tigerHead(p-vec2(-0.3,0.0),col,brightness);\n\n    // body\n    p = prevP;\n    p = animateBody(p);\n    col = tigerBody(p-vec2(0.11,-0.05),col,brightness);\n    \n    return col;\n}\n\nvec3 darumaMain(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x *= mix(0.1,2.0,smoothstep(-1.0,1.0,p.y));\n    float d = length(p)-0.15;\n    col = mix(col,vec3(0.8,0.2,0.2),S(d,0.0));\n    p = prevP;\n    \n    p.y-=0.04;\n    p.y*=1.4;\n    p.x *= mix(0.1,2.0,smoothstep(-1.0,1.0,p.y));\n    d = length(p)-0.1;\n    col = mix(col,vec3(0.9,0.8,0.7),S(d,0.0));\n    p = prevP;\n    \n    p.x = abs(p.x)-0.035;\n    p.y-=0.04;\n    d = length(p)-0.028;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = length(p)-0.02;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    p = prevP;\n    \n    p.x = abs(p.x)-0.03;\n    p.y-=0.08;\n    p*=Rot(radians(-20.0)); \n    p.y*=4.0;\n    d = length(p)-0.025;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    p = prevP;\n    \n    p.x = abs(p.x)-0.03;\n    p.y+=0.005;\n    p*=Rot(radians(10.0)); \n    p.y*=3.0;\n    d = length(p)-0.02;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    p = prevP;    \n    \n    p.x = abs(p.x)-0.02;\n    p.x *= mix(5.0,0.01,smoothstep(-1.0,1.0,p.y));\n    p.y+=0.09;\n    d = length(p)-0.03;\n    col = mix(col,vec3(0.8,0.6,0.2),S(d,0.0));\n    \n    p.x = abs(p.x)-0.1;\n    p.y-=0.01;\n    d = length(p)-0.03;\n    col = mix(col,vec3(0.8,0.6,0.2),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.09;\n    p.x *= mix(5.0,0.01,smoothstep(-1.0,1.0,p.y));\n    p.y+=0.06;\n    d = length(p)-0.03;\n    col = mix(col,vec3(0.8,0.6,0.2),S(d,0.0));\n    return col;\n}\n\nvec3 daruma(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    // shadow\n    p.x*=0.5;\n    p.y*=1.5;\n    p.y+=0.22;\n    float d = length(p)-0.1;\n    col = mix(col,vec3(0.0),S(d,-0.12));\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*5.0)*10.0));\n    col = darumaMain(p,col);\n    return col;\n}\n\nfloat charZero(vec2 p, float speed){\n    vec2 prevP = p;\n    p.y+=0.07;\n    p.y+=iTime*speed;\n    p.y = mod(p.y,0.14)-0.07;\n    float d = abs(B(p,vec2(0.02,0.04)))-0.01;\n    \n    p = prevP;\n    d = max(B(p,vec2(0.05,0.07)),d);\n    return d;\n}\n\nfloat charTwo(vec2 p, float speed){\n    vec2 prevP = p;\n    p.y+=0.07;\n    p.y+=iTime*speed;\n    p.y = mod(p.y,0.14)-0.07;\n    float d = B(p,vec2(0.03,0.05));\n    p.x+=0.02;\n    p.y-=0.02;\n    d = max(-B(p,vec2(0.03,0.008)),d);\n\n    p.x-=0.04;\n    p.y+=0.04;\n    d = max(-B(p,vec2(0.03,0.008)),d);\n    \n    p = prevP;\n    d = max(B(p,vec2(0.05,0.07)),d);\n    \n    return d;\n}\n\nfloat flower(vec2 p){\n    vec2 prevP = p;\n    p = DF(p,1.25);\n    p-=vec2(0.05,0.05);\n    float d = length(p)-0.05;\n    p = prevP;\n    float d2 = length(p)-0.05;\n    d = min(d,d2);\n    \n    p = DF(p,3.0);\n    p-=vec2(0.02,0.02);\n    p*=Rot(radians(45.0));\n    d2 = B(p,vec2(0.003,0.03));\n    d = max(-d2,d);\n    p = prevP;\n    p = DF(p,3.0);\n    p-=vec2(0.04,0.04);\n    d2 = length(p)-0.008;\n    d = max(-d2,d);\n    return d;\n}\n\nfloat pine(vec2 p){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.055;\n    p*=Rot(radians(45.0));\n    float d = length(p)-0.05;\n    p.y+=0.01;\n    float d2 = B(p,vec2(0.004,0.02));\n    d = max(-d2,d);\n    p = prevP;\n    \n    p.y-=0.025;\n    d2 = length(p)-0.05;\n    p.y+=0.01;\n    d2 = max(-B(p,vec2(0.004,0.02)),d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 mailSticker(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x *= mix(-3.0,8.,smoothstep(-1.0,1.0,p.y));\n    float d = B(p,vec2(0.2,0.15));\n    float d2 = d;\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    \n    p = prevP;\n    p.x+=iTime*0.05;\n    p.y-=0.08;\n    p.y+=cos(p.x*100.0)*0.012;\n    d = -p.y;\n    d = max(d2,d);\n    col = mix(col,vec3(1.0,0.7,0.7),S(d,0.0));\n    \n    p = prevP;\n    \n    d = length(p-vec2(0.08,0.18))-0.05;\n    d = max(-d2,d);\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    \n    p.y-=0.035;\n    d = abs(B(p,vec2(0.2,0.23)))-0.01;\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    \n    return col;\n}\n\nvec3 bottomUITex(vec2 p){\n    vec2 prevP = p;\n    p*=70.0;\n    p.y-=iTime*5.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = hash(id);\n\n    return vec3(n);\n}\n\n// UI\nvec3 drawUI(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    //mail sticker\n    p*=1.5;\n    p.x+=0.89;\n    p.y-=0.4;\n    col = mailSticker(p,col);\n    p = prevP;\n    \n    // top right\n    p.x-=0.08;\n    p.y-=0.38;\n    float d = abs(B(p,vec2(0.05,0.07)))-0.005;\n    p.x= abs(p.x)-0.12;\n    float d2 = abs(B(p,vec2(0.05,0.07)))-0.005;\n    d = min(d,d2);\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    p = prevP;\n    \n    p.x-=0.27;\n    p.y-=0.38;\n    d = B(p,vec2(0.016,0.006));\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    \n    p = prevP;\n    p.x-=0.51;\n    p.y-=0.38;\n    p.x= abs(p.x)-0.058;\n    p.x= abs(p.x)-0.058;\n    p.x= abs(p.x)-0.058;\n    d2 = abs(B(p,vec2(0.05,0.07)))-0.002;\n    d = min(d,d2);\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    p = prevP;\n    \n    d = charTwo(p-vec2(0.335,0.38),0.1);\n    d2 = charZero(p-vec2(0.452,0.38),0.15);\n    d = min(d,d2);\n    d2 = charTwo(p-vec2(0.568,0.38),0.2);\n    d = min(d,d2);\n    d2 = charTwo(p-vec2(0.685,0.38),0.25);\n    d = min(d,d2);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    p = prevP;\n    \n    // bottom\n    p.y+=0.42;\n    d = B(p,vec2(0.23,0.04));\n    d2 = d;\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    \n    p.x+=iTime*0.1;\n    p.y+=cos(p.x*30.0)*0.025;\n    d = abs(p.y)-0.005;\n    d = max(d2,d);\n    col = mix(col,vec3(1.0,0.6,0.6),S(d,0.0));\n    \n    p = prevP;\n    p.y+=0.42;\n    p.x = abs(p.x)-0.5;\n    d = B(p,vec2(0.23,0.04));\n    col = mix(col,(bottomUITex(p)*0.2)+vec3(1.0,0.6,0.6),S(d,0.0));\n    \n    p = prevP;\n    p.x+=0.6;\n    p.y+=0.23;\n    p*=Rot(radians(iTime*20.0));\n    d = flower(p);\n    col = mix(col,vec3(1.0,0.6,0.6),S(d,0.0));\n    \n    p = prevP;\n    p.x-=0.6;\n    p.y+=0.3-sin(iTime*2.0)*0.01;\n    \n    d = pine(p);\n    col = mix(col,vec3(1.0,0.6,0.6),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec3 col = vec3(0.9);\n    \n    p.x*=-1.8;\n    p.y*=1.8;\n    p.y-=0.5;\n    p.x+=iTime*0.3;\n    p.x = mod(p.x,4.0)-2.0;\n    col = tiger(p*2.0,col,0.8);\n    p = prevP;\n    \n    p*=1.3;\n    p.y-=0.15;\n    p.x+=iTime*0.5;\n    p.x-=5.3;\n    p.x = mod(p.x,4.0)-2.0;\n    col = tiger(p*2.0,col,0.9);\n    p = prevP;\n    \n    p.y+=0.01;\n    p.x-=iTime*0.5;\n    p.x+=0.3;\n    p.x = mod(p.x,2.0)-1.0;\n    col = daruma(p,col);\n    \n    p = prevP;\n    col = tiger(p,col,1.0);\n    float t = iTime;\n    if(t<=0.0){\n        t = 1.0;\n    }\n    col+=hash(p*t*0.1)*0.3;\n    \n    col = drawUI(p,col);\n\n    /*\n    col = vec3(0.9);\n    float d = pine(p);\n    col = mix(col,vec3(1.0,0.3,0.3),S(d,0.0));\n    */\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 379, 379, 494], [496, 496, 525, 525, 685], [687, 687, 711, 711, 1172], [1174, 1174, 1199, 1199, 1304], [1306, 1306, 1331, 1331, 1549], [1551, 1551, 1581, 1581, 1905], [1907, 1907, 1955, 1955, 2177], [2179, 2179, 2230, 2230, 4097], [4099, 4099, 4150, 4150, 6114], [6116, 6116, 6162, 6162, 6603], [6605, 6605, 6630, 6630, 6756], [6758, 6758, 6805, 6805, 7833], [7835, 7835, 7869, 7869, 9207], [9209, 9209, 9239, 9239, 9500], [9502, 9502, 9538, 9538, 9744], [9746, 9746, 9781, 9781, 10121], [10123, 10123, 10144, 10144, 10550], [10552, 10552, 10571, 10571, 10909], [10911, 10911, 10946, 10946, 11545], [11547, 11547, 11572, 11572, 11724], [11726, 11732, 11762, 11762, 13525], [13527, 13527, 13584, 13584, 14386]], "test": "untested"}
{"id": "slySzV", "name": "image rotation around 2 points", "author": "lomateron", "description": "everytime you rotated an image around one point you where also rotating it around another point hiding at infinity\nin 3D happens something similar, rotating 3D space around a line, this line is a ring with inifite radius", "tags": ["2d"], "likes": 8, "viewed": 317, "published": 3, "date": "1641037831", "time_retrieved": "2024-07-30T17:12:48.190495", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 2.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 m = 2.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    \n    vec2 v = u;\n    v = v/dot(v,v)-vec2(.5,0);//bring the black point at infinity into view\n    v = v/dot(v,v);\n    v = cos(atan(v.y,v.x)+iTime-vec2(.0,.5)*3.14159265)*length(v);//rotate image\n    \n    vec4 o = texture(iChannel0,v);\n         o = mix(o,vec4(1),step(0.,1.-8.*length(u-vec2(0,0))));//white point\n         o = mix(o,vec4(0),step(0.,1.-8.*length(u-vec2(2,0))));//black point\n             \n    fragColor = o;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slySzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 606]], "test": "untested"}
{"id": "NlKSzy", "name": "Icosahedral Double Weave", "author": "Shane", "description": "Attaching a double sided Truchet weave to the triangle cells of a subdivided icosahedron.", "tags": ["bezier", "map", "truchet", "pattern", "icosahedron", "spherical", "polyhedron", "weave"], "likes": 70, "viewed": 1486, "published": 3, "date": "1641029428", "time_retrieved": "2024-07-30T17:12:49.437162", "image_code": "/*\n\n    Icosahedral Double Weave\n    ------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Icosahedral Double Weave\n    ------------------------\n    \n    Quite some time ago, BigWIngs constructed a Truchet pattern consisting of\n    segments that entered and exited from two points on each side of a repeat \n    polygon cell, which I thought was pretty awesome. He also cube mapped the \n    results. After that, a lot of people, including myself, produced a heap of \n    variations. I coded an icosahedral one not long afterwards, but Flockaroo, \n    who codes a lot faster than me, was able to post one straight away, so my \n    version has sat around gathering pixel dust on my hard-drive, as they say. :)\n    \n    Anyway, I dusted off the code not long ago, addressed a few problems that \n    had been bugging me, prettied it up a bit, and now it's done... two years\n    after starting. :D You can never be sure, but as far as I can tell, \n    everything should line up perfectly with no fudge figures, etc. I've \n    rendered it in a similar style to BigWIngs's cube-mapped original to pay \n    hommage, but put some of my own touches in as well. \n    \n    Producing one of these patterns, or any icosahedral cell based pattern,\n    comes down to how easily you can uniquely identify and obtain the cell \n    information from one of the individual polygons. There are three main ways \n    to go about it: Brute force iteration, folding space, and spherical \n    coordinates. Each have their merits, but I went with the latter.\n    \n    Working with polyhedra, spherical coordinates, etc, can be a little tricky \n    and offputting, and attaching Beziers can add to the confusion, so \n    unfortunately, there aren't a lot of working examples to refer to. However, \n    if you are new but interested in this kind of thing, I'd suggest looking at \n    Flockaroo's examples.\n    \n    The algorithm I hacked together to produce the icosahedral cell information \n    is reasonbly fast and it works, but it could definitely be improved. It's \n    not as fast as Flockaroo's new function, and it would have been nice to drop \n    that in, but I think there are some wrapping issues that would need to be \n    ironed out first. TDHooper has a really promising algorithm based on folding \n    techniques, but I wasn't able to use it to correctly produce the cell \n    information I was after. Mattz also has some nicely written stuff, but I \n    haven't really had a chance to peruse through it.\n    \n    Once you have the triangle information, it's a matter of randomly connecting\n    the entry and exit points with curves. I was hoping to find a better way,\n    but unfortunately was forced to use piecewise Bezier curves. They get the job \n    done, but I'll be looking for something better when producing more \n    sophisticated examples. \n   \n\n    \n\n\tInspired by:\n    \n    // The original: I'd imagine BigWIngs is pretty busy these days being\n    // YouTube code famous, and all that, but I hope he still finds time \n    // for more posts. :)\n    Cube-mapped Double Quad Truchet - BigWIngs\n    https://www.shadertoy.com/view/wlSGDD\n    \n\t// I think Flockaroo produced this from inception in a day. It takes me \n    // that long just to choose a color. :D\n    tri truch ballala  - flockaroo\n\thttps://www.shadertoy.com/view/tl23DK\n    \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Color: Green 0, Pinkish Red: 1, Blue: 2.\n#define COLOR 0\n\n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 2\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n*/\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    \n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3.);\n    p.yz *= rot2(iTime/6.); \n    \n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 2.))) - 16.);\n     // Flat plane back wall.\n    //float wall = -p.z + 2.;\n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n    \n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n    \n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n///////\n\n/* \n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r){\n\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n \n\n// IQ's polynomial-based smooth minimum function.\nvec3 smin( vec3 a, vec3 b, float r){\n\n   vec3 f = max(1. - abs(b - a)/r, 0.);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n/////////\n\n\n\n// vec4 swap.\n//void swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout vec4 a, inout vec4 b){ a = a + b; b = a - b; a = a - b; }\n\n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : - 1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n\n\n    return q;\n}\n\n\n\n\n/////////\n\n// IQ's line distance formula.\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\n    //return abs(dot(cross(a, b)/length(a - b), normalize(p)));\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Standard cubic Bezier interpolation.\nvec4 bezierT(in float t){ \n    float u = 1. - t;\n    return vec4(u*u*u, t*u*u*3., t*t*u*3., t*t*t);\n}\n\n// Cubic Bezier spline -- Not cheap, unfortunately, but thankfully,\n// it's good enough for this example. I was hoping there'd be a better way,\n// but so far, it appears to be the only way.\nfloat distSpline(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n\n    // Distance.\n    float d = 1e5, t = 0.;\n    \n    mat4x3 m43 = mat4x3(p0, p1, p2, p3);\n    \n    // It's not absolutely necessary, but I'm mapping the points\n    // to the surface of the sphere as I go along.\n    vec3 bc1 = normalize(p0)*.5;//normalize(m43*bezierT(0.))*.5;\n\n    // Several lines to approximate a smooth curve. Ouch! :) It's being called\n    // outside the raymarching loop, so we can get away with it.\n    const int N = 16;\n    for(int i = 0; i<N; i++){    \n        vec3 bc2 = m43*bezierT(float(i + 1)/float(N));\n        bc2 = normalize(bc2)*.5; // Mapping to the surface of the sphere.\n        d = min(d, distLine(p, bc1, bc2));\n        bc1 = bc2;\n    }\n   \n    return d;\n}\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n#if SCHEME == 0\nconst float scale = 1./2.;\n#elif SCHEME == 1\nconst float scale = 1./2.5;\n#else\nconst float scale = 1./3.;\n#endif\n\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n\nfloat gTri;\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle. These have been expanded 3 fold to \n    // account for GPU inaccuracies when dealing with irrational numbers. On a GPU, \n    // \"1./3.\" and \"1. - 2./3.\" are not the same thing, but they need to be for hash \n    // logic to work. However \"1.\" and \"3. - 2.\" are precisely the same.\n    if(gTri<0.){\n        vID = vec2[3](vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = vec2[3](vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.;//(v[0] + v[1] + v[2])/3.;//\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n     // Centered ID.\n    vec2 ctrID = vID[2]; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;\n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n \n \n \n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n\n//////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .5, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        // General scene color.\n        //\n        \n        #if COLOR == 0\n        vec3 lCol = vec3(.45, .9, .2);\n        lCol = mix(lCol.zyx, lCol, clamp(rd.y*2. + 1., 0., 1.));\n        #elif COLOR == 1\n        vec3 lCol = vec3(1.75, .12, .35);\n        lCol = mix(lCol, vec3(1.2, .7, .1), clamp(rd.y*2. + .8, 0., 1.)*.2);\n        #else\n        vec3 lCol = mix(vec3(.2, .6, 1.5), vec3(.1, .9, .7), clamp(rd.y*2. + 1., 0., 1.)*.5);\n        #endif\n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            vec3[3] gVert, gVertID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, gVertID, rad);\n   \n            gVert[0] = sphericalToWorld(gVertID[0]);//vec3(0, rad, 0);\n            gVert[1] = sphericalToWorld(gVertID[1]);\n            gVert[2] = sphericalToWorld(gVertID[2]);\n            \n            \n            vec3[3] v = gVert, vID = gVertID;\n            \n            // Edge mid points, edge tangents and exit and entry points.\n            vec3[3] vE, vN;\n            vec3[6] vE2;\n            \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n            \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = 0; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    v[0] = vE[0]; v[2] = vE[1];\n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    v[0] = vE[2]; v[1] = vE[1];\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    v[1] = vE[0]; v[2] = vE[2];\n                }\n                else {\n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n                }\n                \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n                vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n                vE[2] = normalize(mix(v[2], v[0], .5))*rad;                \n            }\n            #endif\n            /////    \n            \n  \n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            vec3 ctr = normalize((v[0] + v[1] + v[2]))*rad;\n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = ctr;\n            \n \n\n\n            // Icosahedral cell boundary.\n            //\n            // Rendering lines on a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float line = min(min(ep.x, ep.y), ep.z) - .0035;\n \n            \n            \n            // Calculating the tangent vectors for each edge, as well as the two\n            // entry and exit points on each side of the mid-edge point. All are\n            // used to produce the random curves within each triangle cell.\n            for(int i = 0; i<3; i++){\n                \n                // Edge tangent vectors.\n                vN[i] = normalize(cross(v[(i + 1)%3] - v[i], v[i]));\n                // Cheap shortcut, but not quite accurate.\n                //vN[i] = normalize(mix(v[(i + 2)%3], vE[i], .95) - vE[i]);\n                // Due to the spherical correction in the Bezier function,\n                // this could be used.\n                //vN[i] = normalize(v[(i + 2)%3] - vE[i]);\n                \n                // Edge entry points -- One on each side of the mid point.\n                float mOffs = .5/2.6; // Edge mid point offset.\n                vE2[i*2] = normalize(mix(v[i], v[(i + 1)%3], .5 - mOffs))*rad;\n                vE2[i*2 + 1] = normalize(mix(v[i], v[(i + 1)%3], .5 + mOffs))*rad;\n\n            } \n\n            \n\n            // Shuffling the 6 array points and normals by shuffling an array of indices. I \n            // think this is the FisherYates method, but don't quote me on it. It's been a \n            // while since I've used a shuffling algorithm, so if there are inconsistancies, etc,\n            // feel free to let me know -- It seems to work though, so that's a good sign. :)\n            //\n            // For various combinatorial reasons, some non overlapping tiles will probably be \n            // rendered more often, but generally speaking, the following should suffice.\n            //\n            // Indices for randomization.\n            int[6] iRnd = int[6](0, 1, 2, 3, 4, 5);\n            //int[6] iRnd = int[6](0, 2, 4, 1, 3, 5);\n            //\n            for(int i = 5; i>0; i--){\n\n                // Using the cell ID and shuffle number to generate a unique random number.\n                float fi = float(i);\n\n                // Random number for each triangle: The figure \"id\" is unique for\n                // each triangle, and \"id + fi/24.\" should be unique for each iteration.\n                float rs = hash31(id + fi/24. + .0273);\n\n                // Other array point we're swapping with.\n                //int j = int(floor(mod(rs*6e6, fi + 1.)));\n                // I think this does something similar to the line above, but if not, let us know.\n                int j = int(floor(rs*(fi + .9999)));\n                //swap(iRnd[i], iRnd[j]);\n                // Swap.\n                int tmp = iRnd[i]; iRnd[i] = iRnd[j]; iRnd[j] = tmp;\n\n            } \n\n            // Rendering the spline curves between entry and exit points. There are six\n            // alltogether. We're indexing into random indices, and that creates the \n            // randomness, strangely enough. :)\n            vec3 ln = vec3(1e5);\n            for(int i = 0; i<3; i++){\n                \n                // Two random indices pointing to random entry and exit points.\n                int iR = iRnd[(i*2)];\n                int iRN = iRnd[(i*2 + 1)%6];\n\n                // How far we wish to nudge out the second Bezier point in the direction\n                // of the edge normal... That's an artform in its own right, which is\n                // just another way to say, I'm guessing. :)\n                float ndg = length(vE2[iR] - vE2[iRN])/2.5;\n                //if(ndg<.001) ndg *= 2.;\n                // Based purely on observation, exit and entry points on the same edge \n                // need the tangent points edged out more. \n                if(iR/2 == iRN/2) ndg *= 2.;//length(vE2[iR])/6. + length(vE2[iRN])/6.;\n                \n                // Take four points and render a spline curve. Rendering spline curves\n                // is simple enough, but if you're not sure\n                ln[i] = distSpline(lq, vE2[iR], vE2[iR] + vN[iR/2]*ndg, \n                                       vE2[iRN] + vN[iRN/2]*ndg, vE2[iRN]); \n\n\n            }\n\n            // Give the edge some thickness.\n            #if SCHEME > 1\n            ln -= .01;\n            #else\n            ln -= .02;\n            #endif\n            \n            \n            \n            // Rendering the vertices, borders and Bezier curvers.\n            \n            \n            // Smoothing factor.\n            float sf = .003; \n            \n            // Initial background color.\n            texCol = vec3(.05); \n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line ))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line))*.9);\n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z) - .01;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .005));\n\n \n            // Rendering the bezier curves themselves. \n            for(int i = 0; i<3; i++){\n                //float sh = max(.15 - ln[i]/.01, 0.);\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., ln[i] - .01))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, ln[i] - .0085));\n                texCol = mix(texCol, lCol*1.2, 1. - smoothstep(0., sf, ln[i]));\n                #if SCHEME <= 1\n                texCol = mix(texCol, lCol/2.6, 1. - smoothstep(0., sf, abs(ln[i] + .011) - .0025));\n                #else\n                texCol = mix(texCol, lCol/2.6, 1. - smoothstep(0., sf, ln[i] + .006));\n                #endif\n            }\n            \n    \n            \n        }\n        else if(objID==1){ \n        \n            //  Wall.\n            \n            \n            // Texture coordinates and normal.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            \n            // Rotating the pattern for a different perspective.\n            //txP.xy *= rot2(3.14159/6.);\n         \n            // Intial background color.\n            texCol = vec3(.04);\n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            vec2[3] v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            vec4 p4 = getTriVerts(txP.xy, vID, v);\n            vec2 p = p4.xy;\n            vec2 id = p4.zw;\n            float tri = gTri;\n            vec2 triID = id;// + (vID[0] + vID[1] + vID[2])/3.;\n            \n            // Smoothing factor.\n            float sf = .003;\n            \n            // Nearest vertex ID.\n            float vert = 1e5;\n            \n            vec2 vertID;\n            for(int i = 0; i<3; i++){\n                float vDist = length(p - v[i]);\n                if(vDist<vert){\n                    vert = vDist;\n                    vertID = id + vID[i];\n                }\n            }\n            \n            \n            \n            vert -= .0275;\n             \n            // Border triangles, bump highlights, etc. It was made up on the spot, and\n            // I'm pretty sure there'd be better ways to do it. 3D bump mapping would\n            // be better, but I'm keeping things simple and cheaper.\n            vec2 q = p*vec2(1, tri);\n            float tr = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3. + .01)/1.;\n            float trr = length(q);\n            q -= ld.xy*.005*(tri<0.? vec2(1) : vec2(1, -1));\n            //float tr2 = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3. + .01)/1.;\n            float trr2 = length(q);\n            //float b = max(tr2 - tr, 0.)/.005;\n            float b2 = max(trr2 - trr, 0.)/.005;\n       \n            // Blinking vertex color.\n            float rndVert = hash21(vertID);\n            float rnd = smoothstep(.9, .97, sin(rndVert*6.2831 + iTime)*.5 + .5);\n            lCol = mix(vec3(.1), lCol, rnd);\n            \n            // Triangle pattern.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., tr - .005))*.5);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, tr - .005))*.9);\n            texCol = mix(texCol, vec3(.05) + vec3(.2, .4, 1)*lCol*b2*.3, 1. - smoothstep(0., sf, tr));\n            texCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., sf, abs(tr + .025) - .005));\n         \n            // Vertices.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., vert - .015))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .015));\n            texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .015));\n\n            \n            // Last minite 2D simplex weave pattern: Create 3 arcs about each vertex\n            // point, then randomly render each over one another. I have one of these\n            // on Shadertoy somewhere.\n            vec3 v3 = vec3(length(p - v[0]), length(p - v[1]), length(p - v[2])); \n            //vert = min(min(v3.x, v3.y), v3.z) - .01;\n            //\n            // Random rotation.\n            float rndI = hash21(id);\n            if(rndI<.333) v3 = v3.yzx;\n            else if(rndI<.666) v3 = v3.zxy;\n            \n            // Arc distance fields.\n            float sl = length(v[0] - v[2])/2.;\n            vec3 arc = abs(v3 - sl) - .025;\n            // Double arc: Cool, but a little busy for this example.\n            //arc = abs(arc - .025) - .025; \n            \n            // Rendering the arc shadows, stroke, main layer, etc, over the top of one another.\n            for(int i = 0; i<3; i++){\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., arc[i] - .01))*.35);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, arc[i] - .01));\n                texCol = mix(texCol, vec3(.07), 1. - smoothstep(0., sf, arc[i]));\n                texCol = mix(texCol, vec3(.07)/2.6, 1. - smoothstep(0., sf, arc[i] + .015));\n            }\n \n            \n        }\n        /*\n        // Extra objects.\n        else if(objID==2){ \n\n            texCol = vec3(1);\n        }\n        else { // Wall.\n   \n            texCol = vec3(1);\n        }\n        */\n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .5, .2)*spec*freS*sh*2. + vec3(.2, .4, 1)*fre*sh);\n \n\n\n            // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(aCol, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 169, 287, 519]], "test": "untested"}
{"id": "7lyXzK", "name": "Viscous ball planet", "author": "ShnitzelKiller", "description": "Draw new mass with the mouse. Hold E to erase with the mouse. Try out fullscreen mode. Increasing numHashes improve mass conservation as particles will \"merge\" less often, at the cost of performance.", "tags": ["particles", "planet", "physics"], "likes": 9, "viewed": 290, "published": 3, "date": "1641025778", "time_retrieved": "2024-07-30T17:12:50.237024", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/diameter;\n    ivec2 id = ivec2(floor(uv));\n    //ivec2 stripes = id % 2;\n    //fragColor = vec4(vec3(0.1*float(abs(stripes.x-stripes.y))), 1.);\n    fragColor = vec4(0.,0.,0.,1.);\n    vec3 bgcol = vec3(0.);\n    float totalW = 0.01;\n    for (int i=-2; i<=2; i++) {\n        for (int j=-2; j<=2; j++) {\n            ivec2 disp = ivec2(i, j);\n            ivec2 otherid = id+disp;\n            if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n            for (int k=0; k<hashEdge; k++) {\n                for (int l=0; l<hashEdge; l++) {\n                    ivec2 offset = ivec2(k, l);\n                    vec4 state = texelFetch(iChannel0, otherid*hashEdge+offset,0);\n                    if (state.xy == vec2(-1.)) continue;\n                    float dist = length(state.xy-fragCoord);\n                    float W = smoothstep(diameter*2.,0.,dist);\n                    totalW += W;\n                    //fragColor.xyz -= vec3(0.5, state.zw+.5)*smoothstep(diameter+1., diameter, dist);\n                    //fragColor.xyz = abs(fragColor.xyz);\n                    vec2 cd = normalize(state.xy - iResolution.xy*.5);\n                    vec2 angframe = vec2(cd.x*state.w-cd.y*state.z,dot(state.zw, cd));\n                    fragColor.yzx += W*vec3(0.5, angframe+.5);\n                }\n            }\n        }\n    }\n    fragColor.xyz /= totalW;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//grid hashing\n\nvoid mainImage( out vec4 state, in vec2 fragCoord )\n{\n    ivec2 maxIndex = particleEdge * hashEdge;\n    ivec2 ind = ivec2(floor(fragCoord.xy));\n    \n    if (ind.x >= maxIndex.x || ind.y >= maxIndex.y) discard;\n    state = texelFetch(iChannel0, ind, 0);\n    ivec2 id = ind/hashEdge; //cell id\n    if (iMouse.z > 0.) {\n        float mousedist = length(iMouse.xy*float(hashEdge)/diameter-fragCoord);\n        float keystate = texelFetch(iChannel3, ivec2(69.,0),0).x;\n        if (keystate > 0.5 && mousedist < float(hashEdge*drawRadius)) {\n            state = vec4(-1.,-1.,0.,0.);\n        } else if (ind % hashEdge == ivec2(0) && mousedist < float(hashEdge*drawRadius)) {\n            \n            state = vec4(vec2(id) * diameter+diameter*.5, 0.,0.);\n        }\n    }\n    if (iFrame == 0) {\n        //initialization\n        if (ind % (hashEdge) == ivec2(0)) {\n            state = vec4(vec2(id)*diameter+diameter*.5, (noise2D(fragCoord)*2.-1.)*speed);\n        } else {\n\t\t\tstate = vec4(-1., -1., 0., 0.);\n        }\n    } else {\n        //update\n        \n        //particle leaving the cell\n        if (ivec2(floor(state.xy/diameter)) != id) state = vec4(-1., -1., 0., 0.);\n        \n        //particle entering the cell\n        for (int i=-1; i<=1; i++) {\n            for (int j=-1; j<=1; j++) {\n                ivec2 disp = ivec2(i, j);\n                if (disp == ivec2(0)) continue;\n                ivec2 otherid = id + disp;\n                if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n                //check every bin inside the other cell for particles entering this cell\n                for (int k=0; k<hashEdge; k++) {\n                    for (int l=0; l<hashEdge; l++) {\n                        ivec2 offset = ivec2(k, l);\n                        vec4 otherstate = texelFetch(iChannel0, otherid*hashEdge + offset, 0);\n                        ivec2 id2 = ivec2(floor(otherstate.xy/diameter));\n                        if (id2 == id) {\n                            for (int h=0; h<numHashes; h++) {\n                                //receive the particle if this is the right bin\n                                ivec2 hashOffset = hash2D(otherstate.xy+float(h)*12345.);\n                                ivec2 hashInd = id*hashEdge+hashOffset;\n                                vec2 state0 = texelFetch(iChannel0, hashInd, 0).xy;\n                                if (state0 == vec2(-1.)) {\n                                    if (hashInd == ind) {\n                                        state = otherstate;\n                                        return;\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//state update\n\n//x,y = position\n//z,w = velocity\n//x,y are negative if unoccupied\n#define hardstep(h) (step(0., h)*2.-1.)\n\nvoid mainImage( out vec4 state, in vec2 fragCoord )\n{\n    ivec2 maxIndex = particleEdge * hashEdge;\n    ivec2 ind = ivec2(floor(fragCoord.xy));\n    ivec2 id = ind/hashEdge; //cell id\n\n    if (ind.x >= maxIndex.x || ind.y >= maxIndex.y) discard;\n    \n    state = texelFetch(iChannel0, ind, 0);\n    \n    if (state.xy != vec2(-1.)) {\n\n        //collision detection\n        vec2 impulse = vec2(0.);\n        //vec2 push = vec2(0.);\n        //int collisions = 0;\n        for (int i=-2; i<=2; i++) {\n            for (int j=-2; j<=2; j++) {\n                ivec2 disp = ivec2(i, j);\n                if (disp == ivec2(0)) continue;\n                ivec2 otherid = id + disp;\n                if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n                //check every bin inside the other cell for particles entering this cell\n                for (int k=0; k<hashEdge; k++) {\n                    for (int l=0; l<hashEdge; l++) {\n                        ivec2 offset = ivec2(k, l);\n                        vec4 otherstate = texelFetch(iChannel0, otherid*hashEdge + offset, 0);\n                        if (otherstate.xy == vec2(-1.)) continue;\n                        vec2 r = state.xy-otherstate.xy;\n                        //center of mass frame\n                        vec2 v_cm = (state.zw+otherstate.zw)/2.;\n                        vec2 v0 = state.zw-v_cm;\n                        #ifdef gooey\n                        float rn = length(r);\n                        float vproj = dot(v0, r)/rn;\n                        float r2 = 2.*diameter-rn;\n                        float force = mix(0.3*r2-0.1*vproj, -2./(rn*rn), step(0.,-r2));\n                        impulse += r/rn*force;\n                        #else\n                        float vproj = dot(v0, r)/dot(r, r);\n                        if (length(r) < diameter*2.) {\n                            //collisions++;\n                            //move the particles apart\n                            //push += r/20.;\n                            \n                            //compute collision impulse\n                            impulse -= (1.+restitution)*min(0.,vproj)*r;\n                        }\n                        #endif\n                    }\n                }\n            }\n        }\n        \n        state.zw += impulse;\n        vec2 centervec = iResolution.xy/2. - state.xy;\n        float d = length(centervec);\n        float d2 = d*d;\n        float gr2 = gradius*gradius;\n        float g_out = gr2/d2;\n        float g_in = d/gradius;\n        vec2 g = (gravity/gr2 * mix(g_in, g_out, step(gradius, d))/d) * centervec;\n        state.zw += g;\n        //enforce maximum speed\n        float v = length(state.zw);\n        state.zw *= min(v, maxspeed)/v;\n        state.xy += state.zw;\n        \n        #ifdef walls\n        vec2 bounds = diameter*vec2(particleEdge)-1.;\n        if (state.xy != vec2(-1.)) {\n            vec2 sgn = hardstep(state.xy)*hardstep(bounds-state.xy);\n            state.zw *= sgn;\n            state.zw *= mix(restitution, 1., step(0., sgn.x*sgn.y));\n            state.xy = min(state.xy, bounds);\n            state.xy = max(state.xy, 0.);\n        }\n        #endif\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//to turn on blob physics instead of hard collisions:\n#define gooey\n\n//to turn on world boundaries, uncomment:\n//#define walls\n\n//number of bins per cell is hashEdge * hashEdge\n//cannot be greater than diameter\n#define hashEdge 3\n\n//real world scale of the cells (and particles)\n#define diameter 3.\n\n//maximum number of times to try binning a particle\n#define numHashes 3\n\n//number of particles is particleEdge.x * particleEdge.y\n#define particleEdge ivec2(floor(iResolution.xy/diameter))\n\n//starting speed\n#define speed 1.\n//maxspeed must be smaller than diameter\n#define maxspeed 2.9\n#define restitution 0.75\n#define gradius 75.\n\n#ifdef gooey\n#define gravity 5e2\n#define drawRadius 10\n#else\n#define gravity 1e3\n#define drawRadius 10\n#endif\n\n\nvec2 noise2D(vec2 uv) {\n    return fract(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)));\n}\n\nivec2 hash2D(vec2 uv) {\n    return ivec2(floor(clamp(mod(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)), float(hashEdge)), 0., float(hashEdge))));\n}\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1475]], "test": "untested"}
{"id": "NtKXRy", "name": "fast deep mandelbrot zoom", "author": "peabrainiac", "description": "A zoom deep into the mandelbrot set, rendered in real time in a shader. I should probably put an explainer or something here, but it's 5am and I am very tired.", "tags": ["mandelbrot", "zoom"], "likes": 28, "viewed": 765, "published": 3, "date": "1641010586", "time_retrieved": "2024-07-30T17:12:51.100714", "image_code": "// shader that renders a zoom deep into the mandelbrot set with minimal effort.\n// works by storing the current position relative to a nearby minibrot, and\n// switching between reference minibrots as needed. iterations are also skipped\n// as a result, allowing this to compute even the millions of iterations occuring\n// towards the later part of the zoom with relatively few actual computations.\n\n// the final minibrot here has a period of around 647000 and occurs at a zoom of\n// around 1e97, from which we zoom in further by a factor 1e6 or so.\n\nconst float BAILOUT = 4096.0;\n\nstruct Minibrot {\n    vec2 position;\n    vec2 scale;\n    vec2 a;\n    float approximationRadius;\n    float period;\n    float innerApproximationRadius;\n};\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // minibrots that this zoom passes by, in order. generated using another (currently private) shader.\n    // those values are all relative to the previous minibrot each, which is also why we got fractional periods occuring here.\n    Minibrot[] minibrots = Minibrot[](\n        Minibrot(vec2(0.0,0.0),vec2(1.0000000,0.0),vec2(1.0000000,0.0),1e310,1.0000000,1e310),\n        Minibrot(vec2(-1.7548777,7.6738615e-13),vec2(0.019035511,8.2273679e-14),vec2(-9.2988729,1.7585520e-11),0.14589541,3.0000000,0.14539978),\n        Minibrot(vec2(0.26577526,7.9269924e-14),vec2(1.7697619e-7,-5.1340973e-17),vec2(270.20074,4.0151175e-8),0.000077616154,24.666666,0.0063840700),\n        Minibrot(vec2(-108.77785,-54.851582),vec2(-0.0066274544,-0.0015506834),vec2(-1.3899392,-12.041053),2.4771779,2.0540543,2.4771934),\n        Minibrot(vec2(7.1870313,8.6428413),vec2(-0.0000022837414,-0.0000032153393),vec2(-220.36572,-444.80170),0.036942456,2.4868422,0.037870880),\n        Minibrot(vec2(-1568.3745,271.39987),vec2(0.000062814426,-0.00053683209),vec2(32.133900,28.593172),1.9547913,1.8042328,1.9547923),\n        Minibrot(vec2(-39.815723,-13.059175),vec2(2.0205009e-8,-1.0168816e-8),vec2(-6508.9990,-1532.6521),0.0095185349,2.5542521,0.0094131418),\n        Minibrot(vec2(-36646.895,-15671.298),vec2(0.000033099699,-0.000025827576),vec2(-145.93997,-50.201008),3.9468935,1.7830081,3.9468935),\n        Minibrot(vec2(45.757519,-169.32626),vec2(-3.0256565e-11,4.0970952e-11),vec2(62932.395,-125135.27),0.0021758196,2.5608499,0.0021774585),\n        Minibrot(vec2(-1356.5258,127.47163),vec2(-1.4676038e-11,-1.9145330e-10),vec2(-49048.219,-52953.777),0.091265261,2.3904953,0.091265261),\n        Minibrot(vec2(617.66748,-1510.6793),vec2(-1.3358331e-11,1.0865342e-11),vec2(80652.148,-227075.38),0.089992270,2.4183233,0.089992270),\n        Minibrot(vec2(-3096.2500,389.08243),vec2(-5.4140579e-13,-3.8956390e-12),vec2(-331122.59,-380331.28),0.14324503,2.4135096,0.14324503),\n        Minibrot(vec2(-4897.3506,-2047.1642),vec2(5.5859196e-13,-4.3974197e-13),vec2(1120745.9,388190.56),0.16162916,2.4143343,0.16162916),\n        Minibrot(vec2(-8970.1211,-2440.9661),vec2(8.1748722e-14,-1.0900626e-13),vec2(-2423142.8,-1211603.1),0.17583868,2.4141929,0.17583868)\n    );\n    \n    // relative to the innermost minibrot\n    vec4 cameraPosition = vec4(-1.2517219,-0.2642476,-1.5803953e-7,1.3786521e-6);\n    float zoomOutLog = max(0.0,104.5-0.4*iTime);\n    \n    vec2 dc = cmul(vec2(10.0/length(iResolution),0.0),cameraPosition.zw);\n    vec2 c = cameraPosition.xy/pow(10.0,zoomOutLog)+cmul(dc,vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5));\n\n    int minibrotIndex = 13;\n    Minibrot minibrot = minibrots[minibrotIndex];\n    \n    // some ugly trickery to avoid c and dc overflowing to infinity - instead multiplying the zoom factor\n    // with them directly, it is gradually cancelled out with the innermost minibrot scales\n    while(minibrotIndex>0&&zoomOutLog>20.0){\n        c = minibrot.position/pow(10.0,zoomOutLog)+cmul(c,minibrot.scale);\n        dc = cmul(dc,minibrot.scale);\n        c /= length(minibrot.scale);\n        dc /= length(minibrot.scale);\n        zoomOutLog += log(length(minibrot.scale))/log(10.0);\n        minibrotIndex--;\n        minibrot = minibrots[minibrotIndex];\n    }\n    \n    c *= pow(10.0,zoomOutLog);\n    dc *= pow(10.0,zoomOutLog);\n    \n    // actual algorithm starts here.\n    while(length(c.xy)>minibrot.approximationRadius/length(minibrot.scale)){\n        c = minibrot.position+cmul(c,minibrot.scale);\n        dc = cmul(dc,minibrot.scale);\n        minibrotIndex--;\n        minibrot = minibrots[minibrotIndex];\n    }\n    \n    vec2 z = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    float escapeRadius = minibrotIndex==0?BAILOUT:max(4.2,(minibrot.innerApproximationRadius)*dot(minibrot.a,minibrot.a));\n    for (int i=0;i<500;i++){\n        if (dot(z,z)>escapeRadius){\n            if (minibrotIndex==0){\n                break;\n            }else{\n                z = cdiv(z,minibrot.a);\n                dz = cdiv(dz,minibrot.a);\n                c = minibrot.position+cmul(c,minibrot.scale);\n                dc = cmul(dc,minibrot.scale);\n                minibrotIndex--;\n                minibrot = minibrots[minibrotIndex];\n                escapeRadius = minibrotIndex==0?BAILOUT:max(4.2,(minibrot.innerApproximationRadius)*dot(minibrot.a,minibrot.a));\n            }\n        }\n        dz = 2.0*cmul(dz,z)+dc;\n        z = cmul(z,z)+c;\n    }\n    fragColor.xyz = vec3(max(0.0,1.0-(dot(z,z)<BAILOUT?0.0:sqrt(dot(z,z)/dot(dz,dz))*0.5*log(dot(z,z)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[734, 734, 760, 760, 816], [818, 818, 844, 844, 909]], "test": "untested"}
{"id": "7lySRK", "name": "MRI", "author": "wyatt", "description": "Integrating an aperture to get a depth of field. Happy New Year!", "tags": ["dof"], "likes": 33, "viewed": 636, "published": 3, "date": "1641000072", "time_retrieved": "2024-07-30T17:12:51.844725", "image_code": "// Fork of \"Microscopy 102 Test\" by wyatt. https://shadertoy.com/view/ftGXzV\n// 2021-12-31 22:06:32\n\n// Fork of \"Microscopy 101\" by wyatt. https://shadertoy.com/view/NlKSzG\n// 2021-12-31 17:42:39\n\n\nMain \n    Q = A(U)/float(iFrame);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nfloat T;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) {R = iResolution.xy;T = iTime;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159265359\n#define _sin(a) sin(mod(a,2.*pi))\n#define _cos(a) cos(mod(a,2.*pi))\n\n\nfloat ln (vec3 p, vec3 a, vec3 b) {\n    float l = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n    return mix(.7,1.,l)*length(p-a-(b-a)*l);\n}\nvec4 map (vec3 u) {\n    \n    u.xz *= ei(.9);\n    u.xy *= ei(1.5);\n    float d = 1e9;\n    vec4 c=vec4(0);\n    float sg = 1e9;\n    float l = .1;\n    u.y = abs(u.y);\n    u.y+=.1;\n    mat2 M1 = ei(2.);\n    mat2 M2 = ei(.4);\n    float w = 0.05;\n    for (float i = 0.; i < 18.; i++)\n    {\n        sg = ln(u,vec3(0),vec3(0,l,0))/l;\n        d = min(d,sg*l-w);\n        w *= .66;\n        u.y -= l;\n        u.xz *= M1;\n        u.xz = abs(u.xz);\n        u.xy *= M2;\n        l *= .75;\n        c += exp(-sg*sg)*(.5+.5*sin(3.1*i/16.+vec4(1,2,3,4)));\n    }\n    return vec4(c.xyz,d);\n}\n// Dave H\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n", "buffer_a_code": "Main \n    Q = A(U);\n    vec3 p = vec3(.4*(U-.5*R)/R.y,2.02);\n    float i = float(iFrame);\n    vec2 a = .05*sqrt(fract(i/200.))*vec2(sin(i),cos(i));\n    p.xy += a;\n    vec3 f = vec3(-a,.74);\n    vec3 d = normalize(f-p);\n    d.xy += a;\n    d = normalize(d);\n    p.z += 0.;\n    for (float i = -0.; i < 60.;i++){\n        vec4 x =  map(p);\n        p += d*max(abs(x.w),1e-4);\n        Q += .02*x*exp(-1e7*x.w*x.w);\n       \n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lySRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlySzV", "name": "other tests 02", "author": "jorge2017a2", "description": "//other tests 02 ---REFLECT  --n4", "tags": ["raymarch", "reflect"], "likes": 7, "viewed": 203, "published": 3, "date": "1640999659", "time_retrieved": "2024-07-30T17:12:52.765264", "image_code": "/// ------Image\n//por jorge2017a2-\n//other tests 02 ---REFLECT  --n4\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    \n    res =opU3(res, vec3(planeDist1,201.0,7.0)); //inf\n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    /*\n    res =opU3(res, vec3(planeDist3,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist4,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist5,-1.0 ,8.0)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n    */\n    res =opU3(res, vec3(planeDist3,2.0,-1.0)); \n    res =opU3(res, vec3(planeDist4,3.0,-1.0)); \n    res =opU3(res, vec3(planeDist5,4.0,-1.0)); \n    \n          p.y=p.y-5.0;\n   \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,5.0), 6.0 );\n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    res =opU3(res, vec3(sdsp2,201.0,-1)); \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        \n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        t += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     \n     \n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    //lin = pow(lin,vec3(0.4545));\n    lin = pow(max(lin, 0.), vec3(0.4545)); ////shane-1-ene-2021\n    return lin;\n}\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj=vec3(0.0); \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }  \n        \n    if (id_material>-1.0 && id_color==-1)\n    { colobj=vec3(0.5);\n      colobj*=getMaterial(p, id_material); \n      return colobj;\n    }\n    \n    if (id_material>-1.0 && id_color>199)\n    {  colobj=vec3(0.25);\n       colobj*=getMaterial(p, id_material); \n       return colobj;\n    }\n    return colobj;\n}\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{  vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n \n  /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    { vec3 colref;\n      for(int i=0; i<2; ++i)\n      {  t=RayMarch(ro,rd, MAX_STEPS);\n         Obj=mObj;\n         if(t>MAX_DIST)\n           {\n             colobj= render_sky_color(rd);\n             return  colobj;\n           }  \n     \n        if( t<MIN_DIST || t>MAX_DIST ) break;\n        \n        p=ro+rd*t;\n        n=GetNormal(p);\n        rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        colref=  Getluz( p,ro,rd, n, colobj ,light_pos1);\n        colref+= Getluz( p,ro,rd, n, colobj ,light_pos2);\n        colref/=1.25;\n       }\n     col+=colref/(float(REFLECT));\n   } \n   return col;\n} \n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n    col= renderReflect(Obj,  ro,  rd,  col );\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 20.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   //ro= getMouse(ro);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlySzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 525, 525, 546], [547, 547, 593, 593, 680], [682, 726, 773, 773, 800], [801, 801, 844, 844, 871], [872, 872, 920, 920, 948], [950, 975, 1009, 1009, 1105], [1106, 1106, 1140, 1140, 1231], [1232, 1232, 1266, 1266, 1357], [1358, 1398, 1432, 1432, 1527], [1528, 1568, 1593, 1593, 3207], [3209, 3260, 3284, 3284, 3446], [3448, 3448, 3497, 3497, 4128], [4131, 4131, 4167, 4167, 4412], [4414, 4414, 4441, 4441, 4458], [4460, 4460, 4496, 4496, 4588], [4589, 4589, 4635, 4635, 4760], [4763, 4763, 4837, 4837, 6458], [6459, 6459, 6539, 6539, 6662], [6664, 6664, 6696, 6696, 6893], [6895, 6943, 6971, 6971, 7159], [7161, 7161, 7208, 7208, 7439], [7441, 7493, 7586, 7586, 8056], [8941, 8941, 8972, 8972, 9612], [9614, 9663, 9689, 9689, 9799], [9801, 9801, 9859, 9859, 9911], [9913, 9962, 10019, 10019, 10635]], "test": "untested"}
