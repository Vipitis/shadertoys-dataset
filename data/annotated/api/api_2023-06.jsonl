{"id": "dsScWV", "name": "VDropRotate2", "author": "Del", "description": "remix of https://www.shadertoy.com/view/tdGXWm", "tags": ["2d", "drops"], "likes": 8, "viewed": 223, "published": 3, "date": "1688160915", "time_retrieved": "2024-07-30T17:46:33.706864", "image_code": "// V-Drop (rotate remix II) - https://www.shadertoy.com/view/tdGXWm\n#define PI 3.14159\n#define\tTAU 6.28318\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\tuv *= 8.0;\n\tfloat dd1 = length(uv);\n\tdd1 = smoothstep(0.0,.5,dd1);\n\tuv.xy /= dot(uv,uv)*1.25;\n\t\n\tfloat dd = length(uv*.25);\n    uv *= rot(dd+fract(iTime*0.0025)*TAU);\n    vec3 col = vec3(0.9,.5,.425)*0.6;\t     \t// Drop Colour\n    uv.x = uv.x*64.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    float t =  iTime*0.3;\n    uv.y *= 0.15;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    yv *= d2*d2;\n    col = col*yv;\n    \n    float v1 = 1.25;\n    //v1 = 0.25; // ULTRA TRAILS\n    col = pow(col,vec3(v1,v1,v1));\n    \t\n\tcol *= dd1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsScWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 127, 127, 185], [186, 186, 243, 243, 1166]]}
{"id": "ddBcDK", "name": "test truchet-jf", "author": "jorge2017a2", "description": "test truchet", "tags": ["testtruchet"], "likes": 13, "viewed": 190, "published": 3, "date": "1688160283", "time_retrieved": "2024-07-30T17:46:34.558588", "image_code": "//---image\n//por jorge2017a2-\n//-test truchet-jf--30-jun-2023\n\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n// Rotate around a circular path\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,67.0));\n   float d2= sdBox(p-vec3(0.0,10.0,0.0), vec3(6.0,20.0,2.0) );\n   float d3= sdBox(p-vec3(28.0,10.0,15.0), vec3(8.0,20.0,2.0) );\n    res =opU2(res, vec2(d2,68.0));\n    res =opU2(res, vec2(d3,69.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{ vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{   vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\n//iq cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{    return a + b*cos( 6.28318*(c*t+d) );}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n     vec3 V = normalize(ro - p);\n    vec3 N = normal;\n    vec3 L = normalize (lightPos-p);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.5)*specular*specular;\n    return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/WdsGR7\nvec3 getColor(float v)\n{  float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\nfloat Noise21(vec2 p)\n{   p = fract (p * vec2 (234.34, 435.345)); p += dot(p,p +34.23);  \n    return fract(p.x * p.y);\n}\n\n//referencia Shane\nvec3 truc1(vec2 uv)\n{vec3 col = vec3(0);\n    vec2 gv = fract(uv) - 0.5;\n    vec2 idBox = floor(uv);\n    float n = Noise21(idBox); \n    float width = .05;\n    float lw=0.15;\n    if (n<.5){gv.x *=  -1.; }\n    float d;\n    float mask =0.0;\n    float d1,d2;\n    float lW=0.15;\n     \n    if(n>.35){\n        // Cross tile.\n        d1 = abs(gv.y) - lW;\n        d2 = abs(gv.x) - lW;    \n    }\n    else { \n        // Dual arc tile.\n        d1 = length(gv - .5) - .5;\n        d2 = length(gv + .5) - .5;\n        d1 = abs(d1) - lW;\n        d2 = abs(d2) - lW;\n    }    \n    d=min(d1,d2);\n    mask+= smoothstep(.01,-.01,abs(d)- width);\n    col += mask*vec3(1.0,3.0,4.0)/4.0;\n    return col;\n}\n\nvec3  truc2( vec2 uv )\n{ vec3 col = vec3(0);\n    vec2 gv = fract(uv) - 0.5;\n    vec2 idBox = floor(uv);\n    float n = Noise21(idBox); \n    float width = .05;\n    float lw=0.15;\n   if (n<.5){gv.x *=  -1.;}\n\t\n    float d=length(gv-vec2(0.5))-0.5;\n    float mask = smoothstep(.01,-.01,abs(d)- width);\n    float d1,d2;\n     // Dual arc tile.\n        d1 = length(gv - .5) - .5;\n        d2 = length(gv + .5) - .5;\n        d1 = abs(d1) - lw;\n        d2 = abs(d2) - lw;\n    d=min(d1,d2);\n    mask+= smoothstep(.01,-.01,abs(d)- width);\n    col += mask*vec3(0.1,1.0,0.2);\n    return col;\n}\n\nvec3 truc3(vec2 uv)\n{   vec3 col = vec3(0);\n    vec2 gv = fract(uv) - 0.5;\n    vec2 idBox = floor(uv);\n    float n = Noise21(idBox); \n    float width = .05;\n    if (n<.5) {gv.x *=  -1.;}\n\t\n    float d=length(gv-vec2(0.5))-0.5;\n    float mask = smoothstep(.01,-.01,d);\n    \n    d=length(gv-vec2(-0.5))-0.5;\n    mask+= smoothstep(.01,-.01,d);\n    col += mask*vec3(1.0,0.0,0.0);\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==41)\n     {  vec3 colp = palette( sin(21.29*0.25), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n          return colp; }\n    if (id_color==67)\n     {return  truc1(p.xz*0.05); }\n    if (id_color==68)\n     {return  truc2(p.xy*0.15); }\n    if (id_color==69)\n     {return  truc3(p.xy*0.15); } \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n        result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n//https://www.shadertoy.com/view/7dKfRt\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat3 cameraToWorld(vec3 ro,vec3 lookAt){\n    vec3 a = normalize(lookAt - ro);\n    vec3 b = cross(vec3(0.,1.,0),a);\n    vec3 c = cross(a,b);\n    return mat3(b,c,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n  \n   vec3 ro = vec3(10.0+5. * cos(iTime*2.0),7.,-20.0+5. * sin(iTime*2.0));\n   ro= getMouse(ro);  \n   //vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    vec3  rd = cameraToWorld(ro,vec3(0.,5.,0.)) * vec3(uv,1.);\n    if(2.0*sin(iTime)>0.0)\n    rd= rotate_x(rd, radians(10.0));\n    else\n    rd= rotate_z(rd, radians(-20.0));\n     \n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 520, 520, 604], [605, 605, 642, 642, 737], [739, 739, 783, 783, 810], [811, 811, 851, 851, 878], [879, 879, 924, 924, 952], [954, 954, 988, 988, 1084], [1085, 1085, 1119, 1119, 1210], [1211, 1211, 1245, 1245, 1336], [1337, 1337, 1371, 1371, 1462], [1464, 1497, 1525, 1525, 1595], [1597, 1597, 1622, 1622, 1988], [1990, 1990, 2014, 2014, 2176], [2178, 2178, 2226, 2226, 2505], [2507, 2578, 2614, 2614, 2817], [2818, 2889, 2913, 2913, 3162], [3164, 3164, 3208, 3208, 3529], [3531, 3531, 3568, 3568, 3825], [3827, 3827, 3850, 3850, 4005], [4007, 4048, 4120, 4120, 4161], [4164, 4164, 4254, 4254, 5218], [5221, 5221, 5253, 5253, 5450], [5452, 5492, 5516, 5516, 5648], [5650, 5650, 5673, 5673, 5770], [5772, 5791, 5812, 5812, 6469], [6471, 6471, 6495, 6495, 7050], [7052, 7052, 7073, 7073, 7445], [7447, 7447, 7517, 7517, 7969], [7971, 7971, 7998, 7998, 8087], [8089, 8089, 8147, 8147, 8195], [8197, 8197, 8220, 8220, 8332], [8334, 8334, 8365, 8365, 8984], [8986, 9026, 9073, 9073, 9285], [9287, 9287, 9327, 9327, 9452], [9454, 9454, 9511, 9511, 10272]]}
{"id": "csjyDy", "name": "(Better) cel-shaded donut", "author": "Sumsar86", "description": "A (better) cel shading shader applied to a rotating donut rendered using ray marching.", "tags": ["raymarching", "celshading", "donut", "doughnut"], "likes": 6, "viewed": 210, "published": 3, "date": "1688126749", "time_retrieved": "2024-07-30T17:46:35.453196", "image_code": "#define ENABLE_CEL_SHADING 1\n#define ENABLE_COLOR 1\n#define ENABLE_OUTLINE 1\n\nconst float N = 6.0;\nconst float INVERSE_N = 1.0 / N;\n\n\nvec3 torusColor = vec3(0.80, 0.45, 0.38);\nvec3 outlineColor = vec3(0.0);\nvec3 backgroundColor = vec3(0.8, 0.8, 0.8);\n\nvec3 lightPos = vec3(2.0, -5.0, 3.0);\nvec3 lightColor = vec3(1.0);\nfloat ambientIntensity = 0.2;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 normal = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float lightIntensity = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    \n    if (lightIntensity == -1.0)\n    {\n        fragColor = vec4(backgroundColor, 0.0);\n    }\n    else\n    {\n        float difference = mod(lightIntensity, INVERSE_N);\n#if ENABLE_CEL_SHADING\n        lightIntensity = lightIntensity - difference + INVERSE_N;\n#endif\n\n        vec3 color = vec3(0.0);\n#if ENABLE_COLOR\n        color = vec3(torusColor * lightColor * lightIntensity);\n#else\n        color = vec3(lightIntensity);\n#endif\n\n        float outlineIntensity = dot(texelFetch(iChannel1, ivec2(fragCoord), 0).rgb, vec3(1.0));\n#if ENABLE_OUTLINE\n        if (outlineIntensity > 0.0)\n            color = outlineColor;\n#endif\n\n        fragColor = vec4(color, 0.0);\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FLAT_COLORS 0\n\nconst vec3 BACKGROUND_NORMAL = vec3(0.0);\n\nstruct Torus\n{\n    float r;\n    float s;\n};\n\nstruct Light\n{\n    vec3 pos;\n    float ambientIntensity;\n};\n\nTorus t1 = Torus(0.5, 0.25);\nLight l1 = Light(vec3(2.0, -5.0, 3.0), 0.2);\n\n\nmat4 translate(vec3 v) {\n    return mat4(\n        1, 0, 0, -v.x, \n        0, 1, 0, -v.y, \n        0, 0, 1, -v.z, \n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        1, 0, 0, 0,\n        0, c, -s, 0,\n        0, s, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        c, 0, s, 0, \n        0, 1, 0, 0, \n        -s, 0, c, 0, \n        0, 0, 0, 1\n    );\n}\n\nfloat torusSDF(in vec3 p)\n{\n    float h = length(p.xz);\n    return length(vec2(h-t1.r,p.y))-t1.s;\n}\n\nvec3 calculateNormal(in vec3 pos)\n{\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = torusSDF(pos + smallStep.xyy) - torusSDF(pos - smallStep.xyy);\n    float gradientY = torusSDF(pos + smallStep.yxy) - torusSDF(pos - smallStep.yxy);\n    float gradientZ = torusSDF(pos + smallStep.yyx) - torusSDF(pos - smallStep.yyx);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nvec4 rayMarch(in vec3 rayOrigin, in vec3 rayDir) // returns normal map + light intensity\n{\n    float totalDistTraveled = 0.0;\n    const int NUMBER_OF_STEPS = 256;\n    const float MINIMUM_HIT_DIST = 0.001;\n    const float MAXIMUM_TRACE_DIST = 5.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {        \n        if (totalDistTraveled >= MAXIMUM_TRACE_DIST)\n            break;\n            \n        vec4 currentPos = vec4(rayOrigin + totalDistTraveled * rayDir, 1.0);\n        currentPos *= translate(vec3(0.0, 0.0, 0.0)) * rotateY(iTime) * rotateX(1.0);\n\n        float smallestDist = torusSDF(currentPos.xyz);\n\n        if (smallestDist <= MINIMUM_HIT_DIST)\n        {\n            vec3 normal = calculateNormal(currentPos.xyz);\n            \n            l1.pos = vec3(vec4(l1.pos, 0.0) * rotateY(iTime));\n            vec3 lightDir = normalize(currentPos.xyz - l1.pos);\n            float diffuseIntensity = max(l1.ambientIntensity, dot(normal, lightDir));\n            \n            return vec4(normal, diffuseIntensity);\n        }\n            \n        totalDistTraveled += smallestDist;\n    }\n    \n    return vec4(BACKGROUND_NORMAL, -1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // convert from (0 to 1) to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    // rescale\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    vec3 rOrigin = vec3(0.0, 0.0, -1.2);\n    vec3 rDir = vec3(uv, 1.0);\n    vec4 normalMap = rayMarch(rOrigin, rDir);\n    \n    // Output to buffer A\n    fragColor = normalMap;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define ENABLE_CEL_SHADING 1\n\nconst float N = 6.0;\nconst float INVERSE_N = 1.0 / N;\n\nconst float sobelX[9] = float[](\n    1.0, 0.0, -1.0, \n    2.0, 0.0, -2.0, \n    1.0, 0.0, -1.0\n);\n\nconst float sobelY[9] = float[](\n    1.0, 2.0, 1.0, \n    0.0, 0.0, 0.0, \n    -1.0, -2.0, -1.0\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float horizontal = 0.0, vertical = 0.0;\n    \n    for (float y = 0.0; y <= 2.0; y++)\n    {\n        for (float x = 0.0; x <= 2.0; x++)\n        {\n            ivec2 newFragCoord = ivec2(fragCoord + vec2(x - 1.0, y - 1.0));\n            float lightIntensity = texelFetch(iChannel0, newFragCoord, 0).a;\n            \n            float difference = mod(lightIntensity, INVERSE_N);\n            float greyScale = lightIntensity;\n#if ENABLE_CEL_SHADING\n            greyScale = lightIntensity - difference + INVERSE_N;\n#endif\n            \n            int index = int(x + 3.0 * y);\n            horizontal += greyScale * sobelX[index];\n            vertical += greyScale * sobelY[index];\n        }\n    }\n    \n    float edge = sqrt(dot(horizontal, horizontal) + dot(vertical, vertical));\n    fragColor = vec4(vec3(edge), 0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float STRONG_THRESHOLD = 0.7;\nconst float WEAK_THRESHOLD = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = floor(fragCoord.x), y = floor(fragCoord.y);\n    float prevIndex = x + iResolution.x * y - 1.0;\n    ivec2 prevFragCoord = ivec2(mod(prevIndex, iResolution.x), floor(prevIndex / iResolution.x));\n    \n    float nextIndex = x + iResolution.x * y + 1.0;\n    ivec2 nextFragCoord = ivec2(mod(nextIndex, iResolution.x), floor(nextIndex / iResolution.x));\n    \n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float colorIntensity = dot(color, vec3(1.0));\n    float prevColorIntensity = dot(texelFetch(iChannel0, prevFragCoord, 0).rgb, vec3(1.0));\n    float nextColorIntensity = dot(texelFetch(iChannel0, nextFragCoord, 0).rgb, vec3(1.0));\n\n    fragColor = vec4(0.0);\n    if (nextFragCoord.y == int(fragCoord.y) && floor(fragCoord.y) != iResolution.y - 1.0)\n    {\n        if (colorIntensity >= WEAK_THRESHOLD && colorIntensity >= prevColorIntensity && colorIntensity >= nextColorIntensity)\n        {\n            fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 0.1);\n            if (colorIntensity >= STRONG_THRESHOLD)\n            {\n                fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n            }\n        }\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    float sum = 0.0;\n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            if (x != 0.0 && y != 0.0)\n            {\n                ivec2 newFragCoord = ivec2(fragCoord + vec2(x, y));\n                vec4 neighbour = texelFetch(iChannel0, newFragCoord, 0).rgba;\n                sum += neighbour.a;\n            }\n        }\n    }\n    \n    fragColor = vec4(color.rgb, 0.0);\n    if (sum >= 1.0)\n        fragColor = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 408, 408, 1220]]}
{"id": "ddjcWG", "name": "Hell Texture [209 Chars]", "author": "SnoopethDuckDuck", "description": "any golf suggestions welcome :)\n\npartly inspired by Xor's shader: https://www.shadertoy.com/view/7lyBRR", "tags": ["texture", "tweet", "onetweet", "golf", "furry", "250chars"], "likes": 27, "viewed": 399, "published": 3, "date": "1688126380", "time_retrieved": "2024-07-30T17:46:36.217152", "image_code": "// -8 thanks to coyote  [213]\n// -4 thanks to Fabrice [209] :O\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    float t = .05*iTime, i;\n    u = u/iResolution.y + t;\n    O *= 0.;\n    for( O.yz++; \n         i++ < 9.;\n         O = cos(  .4* cos( u.x - t ) \n                 + 1.04 * O\n                 + 1. / ( 1. + length( fract(  u = u *.8* mat2(-2,1,1,2)  \n                                                   + .4*O.x* cos( t - vec2(0,1) )\n                                            )   \n                                       -.5 )))\n       ) t += 5.*O.x;\n}\n\n// original\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{ \n    float t = .05*iTime;\n    u = u/iResolution.y + t;        \n    O = vec4(0, 1, 1, 0); // change O.x for more motion. could do O * t\n\n    // interesting values to change:\n    // .4*cos(...)         noisy\n    // .4*O.x*cos(...)     aligned\n    // 1.*length(fract(... dotty\n    // 1.04*O+...          saturate/inflate\n    // replace cos(u.x-...) with u.y, or length(u), a*u.x+b*u.y etc. \n    for (int i = 0; i++ < 9;) \n    O = cos(.4*cos(u.x-(t+=5.*O.x))+1.04*O+1.\n          /(1.+length(fract(\n            u=u*.8*mat2(-2,1,1,2)+.4*O.x*cos(t-vec2(0,1)))   \n            -.5)));\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 101, 101, 553]]}
{"id": "dsSczz", "name": "Inverse Kinematic", "author": "l1ghtrider", "description": "Inverse Kinematic with fabrik, gradientdescent (jacobian) and forward implementations", "tags": ["2d", "ik", "physics", "fabrik", "gradientdescent", "jacobian"], "likes": 6, "viewed": 235, "published": 3, "date": "1688126012", "time_retrieved": "2024-07-30T17:46:37.031974", "image_code": "#define SHOW_BUFFERA 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resolution; float aspect; vec2 uv; vec2 target;\n    GetCommonInfo(iResolution, fragCoord, iMouse, resolution, aspect, uv, target);\n    vec2 rootPos = ROOT_POS;\n\n#if SHOW_BUFFERA == 1\n    vec2 cacheUV = fragCoord / resolution;\n    cacheUV = vec2(float(JOINT_NUM) + 0.5f, 0) / resolution;\n    fragColor = texture(iChannel0, cacheUV);\n    return;\n#endif\n\nbool converged = false;\n\n#if USING_BUFFERA == 1\n    Joint joints[JOINT_NUM];\n    vec2 end;\n    Fetch(iChannel0, joints, end);\n    converged = length(end - target) <= ITERATION_THRESHOLD;\n#else\n    //initialize joints' states\n    Joint joints[JOINT_NUM];\n    InitJoints(joints);\n\n    mat3 matrixAcc;\n    vec2 end;\n    for (int it = 0; it < min(int(iTime / 0.5f), ITERATION_COUNT); it++)\n    {\n        Iterate(joints, converged, end, target);\n        if (converged) break;\n    }\n#endif\n\n    bool black = false;\n    bool white = false;\n    mat3 matrixCol = mat3(1.0f);\n    \n    float drawRadius = JOINT_RADIUS * 1.5f;\n    float len = length(uv.xy - rootPos);\n    black = black || len < drawRadius;\n    white = white || len < JOINT_RADIUS;\n    \n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        Joint joi = joints[i];\n        vec2 localPosition = i == 0 ? rootPos : vec2(joints[i].length, 0.0f);\n        matrixCol = matrixCol * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        vec2 pos = (matrixCol * vec3(joi.length, 0.0f, 1.0f)).xy;\n        float len = length(uv.xy - pos);\n        black = black || len < drawRadius;\n        black = black || box2dmat(vec3(uv.xy, 1.0f), inverse(matrixCol), drawRadius, joints[i].length);\n        white = white || len < JOINT_RADIUS;\n    }\n    \n    fragColor = vec4(0.7, 0.1, uv.y + 0.3, 0.0);\n    if (black) fragColor = vec4(0.0f);\n    if (white) fragColor = converged ? vec4(0.0f, 1.0f, 1.0f, 1.0f) : vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    fragColor += 1.0 - smoothstep(length(uv - target), 0.0, 0.01);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resolution; float aspect; vec2 uv; vec2 target;\n    GetCommonInfo(iResolution, fragCoord, iMouse, resolution, aspect, uv, target);\n    vec2 rootPos = ROOT_POS;\n    \n    ivec2 coord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, coord, 0); \n    \n    Joint joints[JOINT_NUM];\n    vec2 end;\n    Fetch(iChannel0, joints, end);\n    \n    for (int i = 0; i < ITERATION_PER_FRAME; i++)\n    {\n        if (length(end - target) > ITERATION_THRESHOLD)\n        {\n            bool converged;\n            Iterate(joints, converged, end, target);\n\n            if (coord.y == 0)\n            {\n                if (coord.x < JOINT_NUM)\n                {\n                    Joint joi = joints[coord.x];\n                    fragColor = vec4(vec2(0.0f), JOINT_LENGTH, joi.angle) / vec4(FLT_SCALE);\n                }\n                if (coord.x == JOINT_NUM)\n                {\n                    fragColor = vec4(end.xy, JOINT_LENGTH, 0.0f) / vec4(FLT_SCALE);\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//IK_MODE 0 Jacobian\n//IK_MODE 1 FABRIK\n//IK_MODE 2 Forward\n#define IK_MODE 1\n#define USING_BUFFERA 1\n\n#if IK_MODE == 0\n#define ITERATION_PER_FRAME 10\n#define ITERATION_THRESHOLD 0.02f\n#elif IK_MODE == 1\n#define ITERATION_PER_FRAME 1\n#define ITERATION_THRESHOLD 0.001f\n#else\n#define ITERATION_PER_FRAME 10\n#define ITERATION_THRESHOLD 0.04f\n#endif\n\n#define JACOBIAN_SCALE 1.0f / 50.0f\n#define JOINT_NUM 5\n#define ROOT_X -0.35f\n#define ROOT_POS vec2(ROOT_X, 0.0f)\n#define JOINT_TOTAL_LENGTH 0.7f\n#define JOINT_LENGTH (JOINT_TOTAL_LENGTH / float(JOINT_NUM))\n#define JOINT_RADIUS 0.02f\n#define ITERATION_COUNT 100\n\n#define ITERATION_SCALE 0.2f\n#define PI 3.1415936f\n#define FLT_SCALE 1.0f\n\nstruct Joint\n{\n    float length;\n    float angle;\n    float radius;\n};\n\nvec2 rot2d(vec2 v,float d)\n{\n    float s = sin(d),c = cos(d);\n    mat2 rot = mat2(c,s,-s,c);\n    return rot * v;\n}\n\nmat3 rot2dmat(float angle)\n{\n    float s = sin(angle),c = cos(angle);\n    mat3 rot = mat3(c, s, 0, -s, c, 0, 0, 0, 1.0f);\n    return rot;\n}\n\nmat3 translate2dmat(vec2 pos)\n{\n    mat3 ret = mat3(1.0f);\n    ret[2][0] = pos.x;\n    ret[2][1] = pos.y;\n    return ret;\n}\n\nbool box2dmat(vec3 pos, mat3 w2l, float w, float h)\n{\n     pos = w2l * pos;\n     return pos.x > 0. && pos.x < h && pos.y > -w && pos.y < w;\n}\n\nbool box2d(vec2 uv, vec2 pos, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rot2d(uv, -angle) + pivot;\n    return (uv.x > 0.0f) && (uv.x < h) && (uv.y > -w) && (uv.y < w);\n}\n\nfloat CalculateGradient(vec2 pos, Joint root, mat3 matrixAcc, mat3 matrixRem, vec2 target)\n{\n    const float angleOff = 0.001f;\n    float dis = length((matrixAcc * translate2dmat(pos) * rot2dmat(root.angle) * matrixRem\n        * vec3(root.length, 0.0f, 1.0f)).xy  - target);\n    float disNew = length((matrixAcc * translate2dmat(pos) * rot2dmat(root.angle + angleOff) * matrixRem\n        * vec3(root.length, 0.0f, 1.0f)).xy  - target);\n    float slope = (disNew - dis) / angleOff;\n    return slope;\n}\n\nvoid GetCommonInfo(in vec3 iResolution, in vec2 fragCoord, in vec4 iMouse\n    , out vec2 resolution, out float aspect, out vec2 uv, out vec2 target)\n{\n    resolution = iResolution.xy;\n    aspect = iResolution.x / iResolution.y;\n    uv = fragCoord / resolution - vec2(0.5f);\n    uv.y /= aspect;\n    target = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y) - vec2(0.5f); \n    target.y /= aspect;\n}\n\nvoid InitJoints(inout Joint joints[JOINT_NUM])\n{\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        joints[i].length = JOINT_LENGTH;\n        if (i == 2) joints[i].angle = 0.5f;\n        else joints[i].angle = 0.0f;\n        joints[i].radius = JOINT_RADIUS;\n    }\n}\n\nvoid Fetch(sampler2D iChannel0, inout Joint joints[JOINT_NUM], out vec2 end)\n{\n    ivec2 coord;\n    vec4 drawed;\n    \n    coord = ivec2(JOINT_NUM, 0);\n    drawed = texelFetch(iChannel0, ivec2(coord), 0);\n    drawed *= FLT_SCALE;\n    if (drawed != vec4(0.0f))\n    {\n        end = drawed.xy;\n        for (int i = 0; i < JOINT_NUM; i++)\n        {\n            coord = ivec2(i, 0);\n            drawed = texelFetch(iChannel0, ivec2(coord), 0);\n            drawed *= FLT_SCALE;\n            if (drawed != vec4(0.0f))\n            {\n                joints[i].length = drawed.z;\n                joints[i].angle = drawed.w;\n            }\n            else\n            {\n                joints[i].length = JOINT_LENGTH;\n                joints[i].angle = 0.0f;\n            }\n        }\n    }\n    else\n    {\n        end = vec2(1000.0f);\n        InitJoints(joints);\n    }\n}\n\nvoid Jacobian(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n    vec3 jacobian[JOINT_NUM];\n    const vec3 unitZ = vec3(0.0f, 0.0f, 1.0f);\n    mat3 matrixAcc = mat3(1.0f);\n    vec2 lastPos,pos;\n    lastPos = ROOT_POS;\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        float lenEff = float(i) / float(JOINT_NUM - 1) * 0.1f + 0.9f;\n        lenEff = i == 0 ? 0.9f : 1.0f; \n        lenEff = 0.0f;\n        pos = (matrixAcc * vec3(joints[i].length * lenEff, 0.0f, 1.0f)).xy;\n        vec3 diffI = vec3(target - pos, 0.0f);\n        jacobian[i].xy = normalize(cross(unitZ, diffI).xy);\n        jacobian[i].z = min((length(diffI.xy) - ITERATION_THRESHOLD) * 0.005f, 0.001f);\n        //joints[i].angle += dot(jacobian[i].xy, lastPos - target) * 1.0f;\n        lastPos = pos;\n    }\n    end = (matrixAcc * vec3(joints[JOINT_NUM - 1].length, 0.0f, 1.0f)).xy;\n\n    matrixAcc = mat3(1.0f);\n    vec2 diff = normalize(target - end);\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        float effect = 0.5f + float(i) / float(JOINT_NUM);\n        float joc = dot(jacobian[i].xy, diff.xy) * JACOBIAN_SCALE;  \n        joints[i].angle += joc;\n        //joints[i].angle -= dot(jacobian[i].xy, vec2(jacobian[i].z)) * 1.0f;\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n    }\n    end = (matrixAcc * vec3(joints[JOINT_NUM - 1].length, 0.0f, 1.0f)).xy;\n    converged = converged || length(end  - target) <= ITERATION_THRESHOLD; \n}\n\nvoid FABRIK(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n    mat3 matrixAcc = mat3(1.0f);\n    vec2 worldPoses[JOINT_NUM + 1]; worldPoses[0] = ROOT_POS;\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        worldPoses[i + 1] = (matrixAcc * vec3(joints[i].length, 0.0f, 1.0f)).xy;\n    }\n\n    for (int it = 0; it < 1; it++)\n    {\n        vec2 a,b;\n\n        worldPoses[JOINT_NUM] = target;\n        for (int i = JOINT_NUM - 1; i >= 0; i--)\n        {\n            Joint joi = joints[i];\n            a = worldPoses[i + 1] - worldPoses[i]; a = normalize(a);\n            worldPoses[i] = worldPoses[i + 1] - a * joi.length;;\n            b = i == 0 ? vec2(1.0f, 0.0f) : worldPoses[i] - worldPoses[i - 1]; b = normalize(b);\n            joints[i].angle = sign(cross(vec3(b.xy, 0.0f),vec3(a.xy, 0.0f)).z) *acos(clamp(dot(a,b), -1.0f, 1.0f));\n        }\n\n        worldPoses[0] = ROOT_POS;\n        for (int i = 0; i < JOINT_NUM; i++)\n        {\n            Joint joi = joints[i];\n            a = worldPoses[i + 1] - worldPoses[i]; a = normalize(a);\n            worldPoses[i + 1] = worldPoses[i] + a * joi.length;;\n            b = i == 0 ? vec2(1.0f, 0.0f) : worldPoses[i] - worldPoses[i - 1]; b = normalize(b);\n            joints[i].angle = sign(cross(vec3(b.xy, 0.0f),vec3(a.xy, 0.0f)).z) * acos(clamp(dot(a,b), -1.0f, 1.0f));\n        }\n\n        end = worldPoses[JOINT_NUM];\n        if (length(worldPoses[JOINT_NUM] - target) <= ITERATION_THRESHOLD)\n        {\n            converged = true;\n            break;\n        }\n    }\n}\n\nvoid Forward(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n    mat3 matrixAcc = mat3(1.0f);\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        mat3 matrixRem = mat3(1.0f);\n        for (int j = i + 1; j < JOINT_NUM; j++)\n        {\n            matrixRem = matrixRem * translate2dmat(vec2(joints[j].length, 0.0f)) * rot2dmat(joints[j].angle);\n        }\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        float offAngle = CalculateGradient(localPosition, joints[i], matrixAcc, matrixRem, target) * ITERATION_SCALE;\n        joints[i].angle -= offAngle;\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        end = (matrixAcc * matrixRem * vec3(joints[JOINT_NUM - 1].length, 0.0f, 1.0f)).xy;\n        float dis = length(end  - target);\n        if (dis < ITERATION_THRESHOLD) \n        {\n            converged = true;\n            break;\n        }\n    }\n}\n\nvoid Iterate(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n#if IK_MODE == 0\n    Jacobian(joints, converged, end, target);\n#elif IK_MODE == 1\n    FABRIK(joints, converged, end, target);\n#else\n    Forward(joints, converged, end, target);\n#endif\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 79, 79, 1994]]}
{"id": "cs2cDy", "name": "Crystal Canyon", "author": "dr2", "description": "Another Truchet trip through the hexaprisms", "tags": ["hexagon", "truchet", "flight"], "likes": 20, "viewed": 314, "published": 3, "date": "1688122614", "time_retrieved": "2024-07-30T17:46:38.190875", "image_code": "// \"Crystal Canyon\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Bits from \"Canal Ruins 2\", \"Suborbital Flight\", etc)\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Ssign (float x);\nvec2 Ssign (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n\nmat3 flyerMat;\nvec4 cPath[PLEN];\nvec3 qHit, sunDir, cHit, qnHit, flyerPos;\nvec2 cIdB, cMidB;\nfloat tCur, dstFar, tEnd[PLEN + 1], hgSizeB, vgSize, tLen, cDir, cType, szFac;\nfloat flRad, flLen;\nint nFrame, idObj;\nconst int idFus = 1, idWng = 2, idEng = 3;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nbool HexCellOcc ()\n{\n  vec2 q;\n  float h;\n  cIdB = PixToHex (cHit.xz / hgSizeB);\n  BConf ();\n  q = (cHit.xz - cMidB) / hgSizeB;\n  h = length (vec2 (hgSizeB * abs (TruchSDist (q).x), cHit.y) *\n      vec2 (0.8 - 0.5 * sin (0.05 * pi * cHit.z), 0.15)) - 7.1;\n  h = min (h, length (vec2 (hgSizeB * HexEdgeDist (q), cHit.y) *\n      vec2 (0.8 - 0.5 * sin (0.05 * pi * cHit.z), 0.15)) - 4.1);\n  h = min (h, 8. + 2. * dot (sin (0.06 * pi * cHit - sin (0.01 * pi * cHit)),\n       vec3 (1.)) - cHit.y);\n  return (h > 0.);\n}\n\nvec2 PixToHexS (vec2 p)\n{\n  vec2 c, r, dr;\n  p.y *= 2./sqrt3;\n  c = p.yx;\n  r = floor (c);\n  r += 2. * fract (0.5 * vec2 (r.x, r.y + step (0.5, fract (0.25 * r.x + 0.25))));\n  dr = c - r;\n  r += step (2., dot (abs (dr), vec2 (sqrt3, 1.))) * Ssign (dr) * vec2 (2., 1.);\n  r.x *= sqrt3/2.;\n  return r;\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{  // (based on \"\"Canal Ruins 2\")\n  vec3 hv[3], ht, htt, w;\n  vec2 ve;\n  float dHit, ty, sy;\n  if (rd.y == 0.) rd.y = 0.0001;\n  cHit = vec3 (PixToHexS (ro.xz).yx, vgSize * floor (ro.y / vgSize + 0.5)).xzy;\n  hv[0].xy = vec2 (1., 0.);\n  hv[1].xy = vec2 (0.5, sqrt3/2.);\n  hv[2].xy = vec2 (-0.5, sqrt3/2.);\n  for (int k = 0; k < 3; k ++) {\n    hv[k].xy *= Ssign (dot (hv[k].xy, rd.xz));\n    hv[k].z = 1. / dot (hv[k].xy, rd.xz);\n  }\n  sy = Ssign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    w = ro - cHit;\n    ht.z = dstFar;\n    for (int k = 0; k < 3; k ++) {\n      htt = vec3 (hv[k].xy, hv[k].z * (1. - dot (hv[k].xy, w.xz)));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * sy * vgSize - w.y) / rd.y;\n    if (ht.z < ty) cHit.xz += 2. * ht.xy;\n    else cHit.y += sy * vgSize;\n    if (HexCellOcc ()) {\n      if (ht.z < ty) {\n        dHit = ht.z;\n        qnHit.xy = ht.xy;\n      } else {\n        dHit = ty;\n        qnHit.z = sy;\n      }\n      qnHit = - qnHit.xzy;\n      break;\n    }\n  }\n  return dHit;\n}\n\nfloat HexCellEdge (vec3 p)\n{\n  vec2 dh;\n  float d;\n  dh = p.xz - cHit.xz;\n  if (qnHit.y == 0.) {\n    d = min (abs (length (dh - dot (dh, qnHit.xz) * qnHit.xz) - 1./sqrt3),\n       abs (fract (p.y / vgSize) - 0.5) * vgSize);\n  } else {\n    dh = abs (dh);\n    d = max (dot (vec2 (0.5, sqrt3/2.), dh), dh.x) - 1.;\n  }\n  return d;\n}\n\nvec3 HexPrisCol (vec3 p, float dEdge)\n{\n  vec3 col;\n  vec2 cIdS, c;\n  float b;\n  col = vec3 (1.);\n  col *= 1. - 0.1 * smoothstep (0.01, 0.03, abs (dEdge));\n  if (abs (qnHit.y) < 0.9 && mod (floor (p.y / vgSize + 0.5), 2.) == 0.) col *= 0.9;\n  cIdS = PixToHex (cHit.xz);\n  c = vec2 (1., 0.96);\n  b = mod (dot (mod (2. * cIdS + cIdS.yx, 3.), vec2 (1., 2.)), 3.);\n  col *= (b == 0.) ? c.xyy : ((b == 1.) ? c.yxy : c.xxy);\n  if (qnHit.y > 0.9) col *= 0.7;\n  return col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, w, s, dy;\n  dMin = dstFar / szFac;\n  p = flyerMat * (p - flyerPos) / szFac;\n  q = p;\n  w = 1.2;\n  dy = 0.;\n  if (q.z < -1.5) {\n    s = (q.z + 1.5) * (q.z + 1.5);\n    w *= 1. - 0.025 * s;\n  } else if (q.z > 2.) {\n    s = (q.z - 2.) * (q.z - 2.);\n    w *= 1. - 0.025 * s;\n    dy = -0.01 * s;\n  }\n  d = max (PrCapsDf (q - vec3 (0., dy, 0.), w, 7.5), - q.z - 6.);\n  DMINQ (idFus);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (1.7, -4.2);\n  d = max (max (- q.z - 1.6, dot (vec2 (q.y, dot (q.xz, sin (0.15 * pi + vec2 (0., 0.5 * pi)))),\n     sin (0.1 * pi + vec2 (0., 0.5 * pi))) - 1.6), q.y - 0.6);\n  d = max (d, - min (abs (PrBox2Df (q.xz - vec2 (2.6, -1.5), vec2 (1., 0.2))),\n     abs (PrBox2Df (q.yz - vec2 (-0.2, -1.5), vec2 (0.5, 0.2)))));\n  d = SmoothMax (d, abs (PrRoundBox2Df (q.xy, vec2 (4., 1.), 0.7)) - 0.04, 0.05);\n  DMINQ (idWng);\n  q = p;\n  q.z += 6.05;\n  d = PrCylDf (q, 0.4, 0.15);\n  q.z += 0.5;\n  d = min (d, PrAnConCylDf (q, sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 0.45, 0.03, 0.35));\n  DMINQ (idEng);\n  return 0.5 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  vec3 q;\n  float s;\n  col4 = vec4 (0., 1., 0.3, 0.3);\n  if (idObj == idFus) {\n    q = qHit;\n    q.z -= 1.;\n    s = 0.;\n    if (abs (q.z) < 3.6) {\n      q *= 0.6;\n      q.z = fract (q.z) - 0.5;\n      s = max (step (length (q.yz + vec2 (-0.2, 0.)), 0.22), step (0., q.y) *\n         step (length (q.xz), 0.22));\n    }\n    s = max (s, step (SmoothMax (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.55, qHit.z) - vec2 (0., 5.6),\n       vec2 (0.3, 0.6), 0.1), - qHit.y + 0.2, 0.1), 0.));\n    if (s > 0.) col4 = vec4 (0., 0., 0., -2.);\n    if (qHit.z < -5.9) col4 *= 0.5 + 0.5 * smoothstep (0.4, 0.45,\n       mod (16. * (atan (qHit.y, qHit.x) / (2. * pi) + 0.5), 1.));\n    if (qHit.y < 0.) {\n      col4 *= 0.7 + 0.3 * smoothstep (0., 0.02,\n         min (abs (PrBox2Df (vec2 (abs (qHit.x), qHit.z) - vec2 (0.35, -0.5), vec2 (0.35, 1.5))),\n         abs (PrBox2Df (vec2 (abs (qHit.x), qHit.z) - vec2 (0.15, 4.5), vec2 (0.15, 0.4)))) - 0.01);\n    }\n    col4.rgb = mix (col4.rgb, vec3 (0.3, 0.8, 0.8), smoothstep (0., 0.02, qHit.z - 7.5));\n  } else if (idObj == idWng) {\n    col4.rgb = mix (vec3 (0.3, 0.8, 0.8), col4.rgb, smoothstep (0., 0.02,\n       abs (length (qHit.xz - vec2 (2.5, -0.2)) - 0.5) - 0.1));\n  } else if (idObj == idEng) {\n    col4 = (PrConCylDf (qHit, sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 0.45, 0.35) > 0.) ?\n       vec4 (0.7, 0.3, 0.3, 0.) * (0.8 + 0.2 * sin (16. * pi * qHit.z)) : vec4 (1., 0., 0., -1.);\n  }\n  return col4;\n}\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat FlmDens (vec3 p)\n{ // (from \"Flaming Asteroids\")\n  float c;\n  c = max (0., 1.3 * BumpFbm3 (0.2 * vec3 (p.xy / flRad, 0.5 * p.z + 16. * tCur)) - 0.2 +\n     0.4 * smoothstep (-0.5 * flRad, 0.1 * flRad, p.z));\n  return c * (1. - smoothstep (-0.3 * flRad, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - 2. * flLen, 0.))) - flRad * (1. + 0.8 * p.z / (2. * flLen)))) *\n     smoothstep (0., flRad, p.z + 2. * flLen);\n}\n\nvec4 FlmCol (vec3 ro, vec3 rd, vec2 dCyl2, float dstObj)\n{\n  vec4 col4;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 50.;\n  ds = min (2. * flRad, dCyl2.y - dCyl2.x) / sMax;\n  s = dCyl2.x;\n  ro.z -= flLen;\n  q = ro + s * rd;\n  r = length (q.xy) / flRad;\n  q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n  fn = FlmDens (q);\n  col4 = vec4 (0.);\n  for (float j = float (VAR_ZERO); j < sMax; j ++) {\n    f = fn;\n    s += ds;\n    q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n    r = length (q.xy) / flRad;\n    q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n    fn = FlmDens (q);\n    c = mix (mix (vec3 (1., 0.3, 0.1), vec3 (1., 1., 0.2), clamp ((0.3 / ds) * (f - fn), 0., 1.)),\n       vec3 (0.9, 0.8, 0.3), smoothstep (-0.5 * flRad, 0.2 * flRad, q.z)) *\n       (1. - smoothstep (-0.1, 0.1, s - dstObj));\n    col4 = col4 + (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n    if (s > dstObj || col4.a > 1.) break;\n  }\n  return clamp (col4, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, c;\n  vec3 col, bgCol, vn, roo, rdo;\n  vec2 dCyl2;\n  float dstObj, dstBlk, dEdge, sh;\n  if (rd.y == 0.) rd.y = 0.001;\n  bgCol = SkyCol (rd);\n  roo = ro;\n  rdo = rd;\n  dstBlk = HexVolRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      ro += dstBlk * rd;\n      dEdge = HexCellEdge (ro);\n      col4 = vec4 (HexPrisCol (ro, dEdge), 0.);\n      vn = qnHit;\n      vn = VaryNf (2. * ro, vn, ((abs (vn.y) < 0.95) ? 2. * (1. -\n         0.95 * smoothstep (60., 80., dstBlk)) : 0.5) * smoothstep (0.01, 0.03, abs (dEdge)));\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = ObjCol ();\n    }\n    sh = min (0.6 + 0.4 * smoothstep (12., 16., HexVolRay (ro + 0.01 * vn, sunDir)),\n       ObjSShadow (ro + 0.01 * vn, sunDir));\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.2 * max (dot (sunDir * vec3 (-1., 1., -1.), vn), 0.) +\n         0.8 * sh * max (dot (sunDir, vn), 0.)) + col4.a * step (0.95, sh) *\n         pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n    } else if (col4.a == -2.) {\n      rd = reflect (rd, vn);\n      col = (rd.y > 0.) ? SkyCol (rd) : vec3 (0.2);\n    }\n    col *= min (1., exp (0.6 + 0.03 * ro.y));\n  } else col = SkyCol (rd);\n  flRad = 0.35;\n  flLen = 5.;\n  ro = flyerMat * (roo - flyerPos);\n  rd = flyerMat * rdo;\n  ro.z += flLen + 7.4 * szFac;\n  dCyl2 = CapsHit (ro, rd, flRad, flLen);\n  if (dCyl2.x < min (min (dstBlk, dstObj), dstFar)) {\n    c = FlmCol (ro, rd, dCyl2, min (dstBlk, dstObj));\n    col = mix (col, 3. * c.rgb, clamp (8. * c.a * c.a, 0., 1.));\n  }\n  col = mix (col, bgCol, smoothstep (0.8, 0.95, min (dstBlk, dstObj) / dstFar));\n  return clamp (col, 0., 1.);\n}\n\nfloat FlyerHt (float t)\n{\n  return 4. * sin (0.15 * pi * t) + 2. * sin (0.35 * pi * t) - 10.;\n}\n\nvoid FlyerPM (float s, out vec3 flPos, out mat3 flMat)\n{\n  vec3 p, pf, pb, vel, acc, va, ori, ca, sa;\n  float ds, vm;\n  ds = 0.5;\n  p.xz = EvalPPos (s);\n  p.y = 0.;\n  flPos = p;\n  flPos.y = FlyerHt (s);\n  pf.xz = EvalPPos (s + ds);\n  pf.y = 0.;\n  pb.xz = EvalPPos (s - ds);\n  pb.y = 0.;\n  vel = (pf - pb) / (2. * ds);\n  acc = (pf + pb - 2. * p) / (ds * ds);\n  vm = length (vel);\n  va = cross (acc, vel) / vm;\n  ori = vec3 (- sin (vel.y) / vm, atan (vel.z, vel.x) - 0.5 * pi, 0.08 * length (va) * sign (va.y));\n  ca = cos (ori);\n  sa = sin (ori);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid VuPM (float s, out vec3 pos, out float az, out float el)\n{\n  vec3 pf, pb, vd;\n  float ds;\n  ds = 0.5;\n  pos.xz = EvalPPos (s);\n  pos.y = FlyerHt (s) + 8.;\n  pf.xz = EvalPPos (s + ds);\n  pf.y = 0.;\n  pb.xz = EvalPPos (s - ds);\n  pb.y = 0.;\n  vd = normalize (pf - pb);\n  az = atan (vd.z, - vd.x) - 0.5 * pi;\n  el = sin (vd.y);\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, trVel, t, azT, elT;\n  int vuId, vuIdO, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 3600.) + 30. * floor (dateCur.w / 3600.) + 10.;\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n    if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  }\n  vuIdO = vuId;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuIdO == regId) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  hgSizeB = 48.;\n  vgSize = 1.;\n  SetPath ();\n  szFac = 0.5;\n  trVel = 0.8;\n  t = tCur * trVel;\n  FlyerPM (t, flyerPos, flyerMat);\n  if (length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01, fract (tCur / 60.)))\n     vuId = 1 - vuId;\n  VuPM (t + 1.5 * (((vuId == 0) ? -1. : 1.)), ro, azT, elT);\n  if (vuId == 0) {\n    az += azT;\n    el += elT;\n  } else if (vuId == 1) {\n    az += pi + azT;\n    el = el - elT;\n  }\n  el -= 0.07 * pi;\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  dstFar = 200.;\n  zmFac = 1.8;\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 2. * pi * sin (0.001 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h)\n{\n  return max (abs (dot (vec2 (length (p.xy) - r, p.z), cs)) - w, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nvec2 Ssign (vec2 p)\n{\n  return vec2 (Ssign (p.x), Ssign (p.y));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 1.;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2cDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1439, 1439, 1460, 1460, 1483], [1485, 1485, 1511, 1511, 2499], [2501, 2501, 2518, 2518, 3363], [3365, 3365, 3390, 3390, 4044], [4046, 4046, 4061, 4061, 4770], [4772, 4772, 4792, 4792, 5285], [5287, 5287, 5312, 5312, 5588], [5590, 5590, 5626, 5658, 6680], [6682, 6682, 6710, 6710, 7009], [7011, 7011, 7050, 7050, 7478], [7480, 7480, 7502, 7502, 8573], [8575, 8575, 8608, 8608, 8791], [8793, 8793, 8814, 8814, 9071], [9073, 9073, 9110, 9110, 9365], [9367, 9367, 9390, 9390, 9553], [9555, 9555, 9571, 9571, 11013], [11015, 11015, 11072, 11072, 11947], [11949, 11949, 11973, 12003, 12368], [12370, 12370, 12428, 12428, 13375], [13377, 13377, 13412, 13412, 15197], [15199, 15199, 15224, 15224, 15294], [15296, 15296, 15352, 15352, 16034], [16036, 16036, 16099, 16099, 16367], [16387, 16387, 16443, 16443, 19206], [19208, 19208, 19241, 19241, 19330], [19332, 19332, 19379, 19379, 19426], [19428, 19428, 19470, 19470, 19521], [19523, 19523, 19566, 19566, 19630], [19632, 19632, 19686, 19686, 19759], [19761, 19761, 19826, 19826, 19909], [19911, 19911, 19935, 19935, 20165], [20167, 20167, 20191, 20191, 20247], [20249, 20249, 20277, 20277, 20357], [20359, 20359, 20389, 20389, 20502], [20504, 20504, 20535, 20535, 20599], [20601, 20601, 20637, 20637, 20843], [20845, 20845, 20868, 20868, 20906], [20908, 20908, 20929, 20929, 20973], [20975, 20975, 20997, 20997, 21024], [21026, 21026, 21048, 21048, 21075], [21077, 21077, 21122, 21122, 21214], [21216, 21216, 21261, 21261, 21299], [21301, 21301, 21358, 21358, 21441], [21443, 21443, 21469, 21469, 21531], [21533, 21533, 21558, 21558, 21620], [21622, 21622, 21647, 21647, 21910], [21944, 21944, 21968, 21968, 22028], [22030, 22030, 22054, 22054, 22119], [22121, 22121, 22145, 22145, 22257], [22259, 22259, 22283, 22283, 22426], [22428, 22428, 22453, 22453, 22637], [22639, 22639, 22664, 22664, 22889], [22891, 22891, 22912, 22912, 23067], [23069, 23069, 23090, 23090, 23245], [23247, 23247, 23276, 23276, 23488], [23490, 23490, 23529, 23529, 23781]]}
{"id": "Dd2cDy", "name": "Fork blog_profi electrogly 131", "author": "electroglyph", "description": "Cool!\nModified from shader tutorial video URL: https://youtu.be/f4s1h2YETNY", "tags": ["fractal"], "likes": 5, "viewed": 201, "published": 3, "date": "1688122137", "time_retrieved": "2024-07-30T17:46:39.207158", "image_code": "/* \n     Modified from shader tutorial video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\n//[[0.439 0.034 0.411] [0.742 0.658 0.198] [1.271 1.503 0.636] [1.615 2.178 1.561]]\nvec3 palette( float t ) {\n    vec3 a = vec3(.439, .034, .411);\n    vec3 b = vec3(.742, .658, .198);\n    vec3 c = vec3(1.271, 1.503, .636);\n    vec3 d = vec3(1.615, 2.178, 1.561);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.5; i < 4.5; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = sdRoundedX(uv, abs(sin(iTime*0.2+i)), i*10.);\n\n        vec3 col = palette(sin(pow(length(uv0), 1.)) + iTime*0.4 + i*1.);\n\n        d = sin(d*2. + i);\n        d = abs(d);\n\n        d = pow(.01 / pow(d, .5), .4);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2cDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 211, 236, 236, 433], [435, 486, 541, 541, 604], [607, 607, 664, 664, 1179]]}
{"id": "cs2cWy", "name": "VdropRotate", "author": "Del", "description": "remix of https://www.shadertoy.com/view/tdGXWm", "tags": ["2d", "drops"], "likes": 18, "viewed": 302, "published": 3, "date": "1688118333", "time_retrieved": "2024-07-30T17:46:40.059878", "image_code": "// V-Drop (rotate remix) - https://www.shadertoy.com/view/tdGXWm\n#define PI 3.14159\n#define\tTAU 6.28318\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= rot(length(uv*.2)+fract(iTime*0.025)*TAU);\n    vec3 col = vec3(.55,0.95,.425);\t     \t// Drop Colour\n    uv.x = uv.x*64.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    float t =  iTime*0.4;\n    uv.y *= 0.15;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    yv *= d2*d2;\n    col = col*yv;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2cWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 124, 124, 182], [183, 183, 240, 240, 932]]}
{"id": "Ds2yWy", "name": "Fork Psychedeli electrogly 508", "author": "electroglyph", "description": "Super colorful. Dutch color scheme goes boom!", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 1, "viewed": 178, "published": 3, "date": "1688116514", "time_retrieved": "2024-07-30T17:46:40.898635", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (uv.xy-0.5);\n\tvec2 cir = ((pos.xy*pos.xy+sin(uv.x*18.0+iTime)/25.0*sin(uv.y*7.0+iTime*1.5)/1.0)+uv.x*sin(iTime)/16.0+uv.y*sin(iTime*1.2)/16.0);\n\tfloat circles = (sqrt(abs(cir.x+cir.y*0.5)*25.0)*5.0);\n\tfragColor = vec4(sin(circles*1.25+2.0),abs(sin(circles*1.0-1.0)-sin(circles)),abs(sin(circles)*1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2yWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 420]]}
{"id": "Dd2cWG", "name": "gradient circle test", "author": "tianluo97", "description": "gradient circle test", "tags": ["gradientcircletest"], "likes": 1, "viewed": 179, "published": 3, "date": "1688112318", "time_retrieved": "2024-07-30T17:46:41.761329", "image_code": "const vec2 target_resolution = vec2(720, 720);\nvec4 radicalGradient2(vec2 uv, vec2 pos, vec2 size, vec4 cl1, float p1, vec4 cl2, float p2){\n    vec2 graduv = uv;\n    graduv -= pos;\n    graduv /= size;\n    float d = distance(graduv, vec2(0.0));  \n    vec4 color = mix(cl1, cl2, smoothstep(p1, p2, d));\n    return color;\n}\n\nvec2 rotate2d(vec2 v, float rot)\n    {\n        float mid = 0.5;\n        return vec2(\n        cos(rot) * (v.x - mid) + sin(rot) * (v.y - mid) + mid,\n        cos(rot) * (v.y - mid) - sin(rot) * (v.x - mid) + mid\n        );\n}\n    \n vec4 radicalGradient3(vec2 uv, vec2 pos, vec2 size, vec4 cl1, float p1, vec4 cl2, float p2, vec4 cl3, float p3){\n    vec2 graduv = uv;\n    graduv -= pos;\n    graduv /= size;\n    float d = distance(graduv, vec2(0.0));  \n    vec4 color = mix(cl1, cl2, smoothstep(p1, p2, d));\n    color = mix(color, cl3, smoothstep(p2, p3, d));\n    return color;\n  }\n\nfloat circleBlur(in vec2 _st, in float _radius, in float _blur){\n          vec2 dist = _st-vec2(0.5);\n          return 1.-smoothstep(_radius-(_radius*_blur), _radius, dot(dist, dist)*4.0);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    //uv.y -= 0.5/r - 0.5;    \n    \n    vec4 grad = radicalGradient3(\n        uv, \n        vec2(.4, .7) , \n        //vec2(-5.2867, -2.0867), \n        vec2(.7, .7) , \n        vec4(vec3(0.980,0.984,1.000),1.0), \n        0., \n        vec4(vec3(0.220,0.843,1.000),1.0), \n        0.45,\n        vec4(vec3(0.000,0.667,1.000),1.0), \n        0.8\n    );\n    \n    //uv *= 1.5;\n    vec2 circleUv = uv; \n    float circle = circleBlur(circleUv, 1., 1.3);\n    \n    //uv -= noise(vec2(iTime * 1.9));\n    \n    // Output to screen\n    fragColor = vec4(vec3(uv, noise(vec2(iTime * .9))), 1.0) * circle;\n    fragColor = vec4(vec3(grad.rgb) * circle\n    , 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2cWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 139, 139, 320], [322, 322, 360, 360, 544], [551, 551, 663, 663, 898], [900, 900, 964, 964, 1090], [1092, 1092, 1119, 1119, 1236], [1238, 1325, 1351, 1351, 1868], [1870, 1870, 1927, 1964, 3037]]}
{"id": "ddByDy", "name": "Waves interference", "author": "thesage1014", "description": "A little test to play with sin(x)/x", "tags": ["waves"], "likes": 1, "viewed": 145, "published": 3, "date": "1688108342", "time_retrieved": "2024-07-30T17:46:42.689846", "image_code": "\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\n#define XSCALE 100.\n#define YSCALE 1.\n#define PULSES 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    float x = uv.x * 1.;\n    float time = sin(iTime*.45)*.5;//mod(iTime*.25,2.);\n    float time2 = sin(iTime*.35)*.8;//mod(iTime*.25,2.);\n    float modtime = 2.-mod(iTime*.45,2.);\n    float modtime2 = 2.-mod(iTime*.35,2.);\n    \n    //float time2 =mod(iTime*.125,2.);\n    x = uv.x - time + .2;\n    float wave = uv.y*YSCALE + sin(x*XSCALE)/(x*XSCALE)*0.4*modtime;\n    x = uv.x + time - .2; \n    float wave2 = uv.y*YSCALE + sin(x*XSCALE)/(x*XSCALE)*0.4*modtime;\n    x = uv.x - time2 + .2;\n    float wave3 = uv.y*YSCALE + sin(x*XSCALE)/(x*XSCALE)*0.4*modtime2;\n    x = uv.x + time2 - .2; \n    float wave4 = uv.y*YSCALE + sin(x*XSCALE)/(x*XSCALE)*0.4*modtime2;\n    \n    float line = smoothstep(1.126,0.01,abs(wave + wave2 + wave3 + wave4));\n    vec3 col = ( hue2rgb(line+.5)*line + line*.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddByDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 194, 194, 303], [360, 360, 417, 467, 1355]]}
{"id": "DsBcWh", "name": "Unidentified Floating Object", "author": "granito", "description": "Fork of https://www.shadertoy.com/view/MdXSWn by evilryu\n& Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n\nPlayed around with the visuals, added handheld camera animation + DoF", "tags": ["julia", "zoom", "dof", "mandlebrot", "vhs", "handheld", "shaky"], "likes": 11, "viewed": 325, "published": 3, "date": "1688096441", "time_retrieved": "2024-07-30T17:46:43.754998", "image_code": "//Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n\n\n#define VHSRES vec2(540.0,320.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  #ifdef UseVHSEffect \n    vec2 uv = fragCoord.xy / iResolution.xy / iResolution.xy * VHSRES;\n    fragColor = texture( iChannel0, uv );\n  #else\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture( iChannel1, uv );\n  #endif\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Options\n    // AA: increase to have AA but not sure its working properly\n        #define AA 0\n    // VHS Effect Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n        #define UseVHSEffect \n\n//-----------\n// Noises\n\n#define HASHSCALE 0.1031\n#define saturate(i) clamp(i,0.,1.)\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence, float rdm) \n{\n    float total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n    for(int i = 0; i < octaves; ++i) \n    {\n        total += perlinNoise1D((pos * frequency) + hash(rdm)) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total / maxValue;\n}\n\nvec3 fbmv3(float pos, int octaves, float persistence, float rdm) \n{\n    return  vec3(   fbm(pos, octaves, persistence, hash(rdm)) , fbm(pos, octaves, persistence, hash(rdm+321.23)) , fbm(pos, octaves, persistence, hash(rdm+797.313))   );\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//-----------\n// Animation\n\n#define starttime 4.\n#define ep 9.\n\nfloat mandelbulbevolution (float t)\n{\n    float ts = max(t - starttime,0.);\n    return pow(saturate(fract(ts/ep) * ep),4.) + floor(ts/ep);\n}\n\nfloat shockwave (float t)\n{\n    float ts = max(t - starttime,0.);\n    float localt = ts-1.02;\n    float amount = 1. - saturate(fract(localt/ep) * ep);\n    float bounce = sin(ts+15.*amount*amount*amount) * smoothstep(0.,1.,amount);\n    return bounce;\n}\n\nfloat mandelbulbrotation (float t)\n{\n    float ts = max(t - starttime,0.);\n    float amount = smoothstep(0.,1.,abs((1. - saturate(fract(ts/ep) * ep)) * 2. - 1.));\n    amount *= sin(abs(amount) * 7.);\n    return amount*0.01;\n}\n\n\n//-----------\n// Camera\n\n\n#define Pi 3.14159265359\n\n#define DoFClamping 1.0\n#define DoFSamples 16\n\n#define Aperture 0.05\n\nfloat ZoomAnim(float time)\n{\n    float fadein = smoothstep(0.,1.,(max(time,0.)*0.5)) * 0.5 + 0.5;\n    \n    return fadein * pow(fbm(time*.1, 5, .45, 71.59)*0.5+0.5,2.);\n}\n\nfloat FocalDistance (float time) \n{\n    return 0.85 + fbm(time*0.3, 3, .3, 66.33) * 0.2;\n}\n\n//-----------\n// Tonemapping\n\nlowp vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n", "buffer_a_code": "// Fork of https://www.shadertoy.com/view/MdXSWn Created by evilryu\n// \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z/r) + mandelbulbevolution(iTime)+iTime*0.05;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, mandelbulbrotation(iTime));\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<48; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n    pixel_size = 1.0/(iResolution.x * 4.0);\n    \n    vec3 bg = exp(uv.y-2.0)*vec3(0.4, 0.6, 1.0);\n\n            \n\t// camera\n    float zoomanimfactor = ZoomAnim(iTime);\n    float zoom =  1. + zoomanimfactor * 20.;\n    vec3 camposanim =  ( vec3(.05) * fbmv3(iTime*1., 5, .3, 321.77) + vec3(1.) * fbmv3(iTime*0.1, 3, .2, 95.31) );\n    \n    vec3 camtargetanim = ( vec3(.05) * fbmv3(iTime*1., 5, .3, 321.23) + vec3(6.) * fbmv3(iTime*0.3, 3, .2, 767.9) ) ;\n    \n \tvec3 ta = camtargetanim * zoomanimfactor * 0.1; \n\tvec3 ro = vec3(0., 0.9 , 3. ) + camposanim * 0.1 + shockwave(iTime) * vec3(0.,.02,0.);\n \tvec3 cf = normalize(ta-ro); \n    \n    float depth = 0.;\n    vec3 col;    \n    \n    for (int i=0; i<(AA+1); ++i) { \n    \n        // AA \n        vec2 v = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(v - iTime + float(i))))/float(0xffffffffU);\n        vec2 uvoffset = hash2(seed)-0.5;\n        \n        vec2 localuv = uv + (uvoffset / iResolution.xy * 1.2); \n    \n        vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n        vec3 cu = normalize(cross(cs,cf)); \n        vec3 rd = normalize(localuv.x*cs + localuv.y*cu + zoom*cf);  // transform from view to world\n        col = texture(iChannel0, rd).rgb; \n        vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n        vec3 sun = vec3(1., 0.8, 0.6); \n        vec3 skycolor = vec3(0.5, .7, 1.0); \n\n        float t=0.0;\n        vec3 p=ro; \n\n        vec3 res = intersect(ro, rd);\n        \n         if(res.x > 0.0){\n               p = ro + res.x * rd;\n               vec3 n=nor(p); \n               float shadow = softshadow(p, sundir, 20.0 );\n               float dif = max(0.0, dot(n, sundir)); \n               float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n               vec3 lin = sun * dif * shadow; \n               vec3 ambient = texture(iChannel0, n, 5.).rgb * 0.8;               \n               lin += ambient * 0.5;\n               res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n               vec3 tc0 = 0.5 + vec3(0.2,0.5,0.7) * sin(2.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0) + mandelbulbevolution(iTime+0.2) * 2.);\n               col = lin * ((dot(vec3(.3,.6,.1),tc0) * 0.4 + tc0 * 0.4) + 0.2);\n               col += spe * sun * shadow * 0.25; \n               depth = length(p);\n        } \n\n    }\n    if (depth < 0.) {\n        col /= float(AA);\n    }\n\n    // post\n \tfragColor = vec4(max(col.xyz, vec3(0.)), depth); \n }", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//first DoF pass\n\n#define dir normalize(vec2(1.0, 1.0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float ApertureFinal = Aperture*ZoomAnim(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d, de;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        vec2 de = (fragCoord + d*iResolution.y*ApertureFinal)/iResolution.xy;\n        p = texture(iChannel0, de);\n        dr = min(abs(p.a-FocalDistance(iTime))/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*ApertureFinal + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define dir normalize(vec2(1.0, -1.0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float ApertureFinal = Aperture*ZoomAnim(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*ApertureFinal)/iResolution.xy);\n        dr = min(abs(p.a-FocalDistance(iTime))/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*ApertureFinal + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n\n       \n    fragColor = vec4(ACESFilm(col.rgb), 1. );\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define VHSRES vec2(540.0,320.0)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n#define validuv(v) (abs(v.x-0.5)<0.5&&abs(v.y-0.5)<0.5)\n\nfloat v2random( vec2 uv ) {\n  return texture( iChannel1, mod( uv, vec2( 1.0 ) ) ).x;\n}\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\nvec3 rgb2yiq( vec3 rgb ) {\n  return mat3( 0.299, 0.596, 0.211, 0.587, -0.274, -0.523, 0.114, -0.322, 0.312 ) * rgb;\n}\n\nvec3 yiq2rgb( vec3 yiq ) {\n  return mat3( 1.000, 1.000, 1.000, 0.956, -0.272, -1.106, 0.621, -0.647, 1.703 ) * yiq;\n}\n\n#define SAMPLES 10\n\nvec3 vhsTex2D( vec2 uv, float rot ) {\n  if ( validuv( uv ) ) {\n    vec3 yiq = vec3( 0.0 );\n    for ( int i = 0; i < SAMPLES; i ++ ) {\n      yiq += (\n        rgb2yiq( texture( iChannel0, uv - vec2( float( i ), 0.0 ) / VHSRES ).xyz ) *\n        vec2( float( i ), float( SAMPLES - 1 - i ) ).yxx / float( SAMPLES - 1 )\n      ) / float( SAMPLES ) * 2.0;\n    }\n    if ( rot != 0.0 ) { yiq.yz = rotate2D( rot ) * yiq.yz; }\n    return yiq2rgb( yiq );\n  }\n  return vec3( 0.1, 0.1, 0.1 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec3 col = vec3( 0.0, 0.0, 0.0 );\n\n  #ifdef UseVHSEffect \n\n      vec2 uv = fragCoord.xy / VHSRES;\n      float time = iTime;\n\n      float tapeerror = shockwave(time+0.4) * 0.2 + 0.2;\n\n      vec2 uvn = uv;\n\n      // tape wave\n      uvn.x += ( v2random( vec2( uvn.y / 10.0, time / 10.0 ) / 1.0 ) - 0.5 ) / VHSRES.x * 1.0;\n      uvn.x += ( v2random( vec2( uvn.y, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 1.0;\n\n      // tape crease\n      float tcPhase = smoothstep( 0.9, 0.96, sin( uvn.y * 8.0 - ( time + 0.14 * v2random( time * vec2( 0.67, 0.59 ) ) ) * PI * 1.2 ) );\n      float tcNoise = smoothstep( 0.3, 1.0, v2random( vec2( uvn.y * 4.77, time ) ) );\n      float tc = tcPhase * tcNoise;\n      uvn.x = uvn.x - tc / VHSRES.x * 8.0;\n\n      // switching noise\n      float snPhase = smoothstep( 6.0 / VHSRES.y, 0.0, uvn.y );\n      uvn.y += snPhase * 0.3;\n      uvn.x += snPhase * ( ( v2random( vec2( uv.y * 100.0, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 24.0 );\n\n      // fetch\n      col = vhsTex2D( uvn, tcPhase * 0.2 + snPhase * 2.0 );\n      col = max(mix( col, vec3( dot(col, vec3(.3,.6,.1)) ), vec3(-2.) ), vec3(0.));\n      \n      // crease noise\n      float cn = tcNoise * ( 0.3 + 0.7 * tcPhase );\n      if ( 0.29 < cn ) {\n        vec2 uvt = ( uvn + V.yx * v2random( vec2( uvn.y, time ) ) ) * vec2( 0.1, 1.0 );\n        float n0 = v2random( uvt );\n        float n1 = v2random( uvt + V.yx / VHSRES.x );\n        if ( n1 < n0 ) {\n          col = mix( col, 2.0 * V.yyy, pow( n0, 10.0 ) );\n        }\n      }\n\n      // ac beat\n      col *= 1.0 + 0.1 * smoothstep( 0.4, 0.6, v2random( vec2( 0.0, 0.1 * ( uv.y + time * 0.2 ) ) / 10.0 ) );\n\n      // color noise\n      col *= 0.9 + 0.1 * texture( iChannel1, mod( uvn * vec2( 1.0, 1.0 ) + time * vec2( 5.97, 4.45 ), vec2( 1.0 ) ) ).xyz;\n      col = saturate( col );\n\n      // yiq\n      col = rgb2yiq( col );\n      col = vec3( 0.1, -0.1, 0.0 ) + vec3( 0.9, 1.1, 1.5 ) * col;\n      col = yiq2rgb( col );\n\n  #endif\n  \n  fragColor = vec4( col, 1.0 );\n}", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 152, 152, 394]]}
{"id": "ddScWG", "name": "camera tracking default ", "author": "tianluo97", "description": "camera tracking default ", "tags": ["cameratrackingdefault"], "likes": 0, "viewed": 155, "published": 3, "date": "1688096178", "time_retrieved": "2024-07-30T17:46:44.634646", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n  vec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n const int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n  vec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n  br1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n  br2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n  br3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float divisionLine;\n    float d = cubicPulse(divisionLine,0.16,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //\n    //maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    // \n    float PI = 3.1415926;\n    float time = iTime * 0.; \n    float scale = 1.;\n    \n    vec4 vcolor0 = vec4(0.000,0.216,0.722,1.0);\n    vec4 vcolor1 = vec4(0.000,0.267,1.000,1.0);\n    vec4 vcolor2 = vec4(0.000,0.212,0.800,1.0);\n    \n    float step0 = 0.2 * scale;\n    float step1 = 0.4 * scale;\n    float step2 = 0.6 * scale;\n\n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor;\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor0,dist2);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //darkColorMask\n    float darkMaskd = cubicPulse(divisionLine,0.24,uv.x);\n    vec3 darkMaskColor = vec3(darkMaskd);\n    float darkMaskpct = plot(uv,darkMaskd);\n    \n    vec3 darkColorMask = darkMaskColor+darkMaskpct*vec3(0.0,1.0,0.0);\n    darkColor = mix(darkColor,vec4(0.361,0.639,1.000,1.),darkColorMask.r);\n    \n    //\n    float qscale = 0.25;\n    float qtime = iTime * 0.1;\n    \n    float qstep0 = 0.05 * qscale;\n    float qstep1 = 0.25 * qscale;\n    float qstep2 = 0.50 * qscale;\n    float qstep3 = 0.75 * qscale;\n    \n    vec4 qcolor0 = vec4(0.678,0.776,1.000,1.0);\n    vec4 qcolor1 = vec4(0.620,0.733,1.000,1.0);\n    vec4 qcolor2 = vec4(1.000,0.647,0.561,1.0);\n    vec4 qcolor3 = vec4(1.000,0.949,0.761,1.0);\n    vec4 qcolor4 = vec4(1.000,1.000,1.000,1.0);\n    \n    float brightness4 = 0.15;\n    float contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x- 0.15 - qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    //lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    //\n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    //\n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    //\n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    //lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    //lightColor = vec4(1.0);\n    \n    //\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //ending mask mask\n    float endMask = smoothstep(0.62,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4374, 8750]]}
{"id": "DsSyDG", "name": "Fork dream cave electrogly 767", "author": "electroglyph", "description": "Dream cavern derived from julia fractal.", "tags": ["fractal", "julia", "cavern", "hills"], "likes": 1, "viewed": 161, "published": 3, "date": "1688078784", "time_retrieved": "2024-07-30T17:46:45.624001", "image_code": "const float depthCull=.1;\nconst float zoom=3.5;\nconst float bailout=10.;\nconst vec2 offset=vec2(.3,.45);\nconst int iterations=9;\n\n//\"dream cavern\", by George Toledo. 2015.\n\nvec3 hsv(const in float h, const in float s, const in float v) {\n\treturn mix(vec3(1.0),clamp((abs(fract(h+vec3(3.,2.,1.)/3.0)*6.-3.)-1.),0.,1.0),s)*v;\n}\n\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details, located in ZIP file here:\n// http://webstaff.itn.liu.se/~stegu/GLSL-cellular/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nvec2 cmult(vec2 a, vec2 b)\n{\n\tvec2 p;\n\tp[0]=a[0]*b[0]-a[1]*b[1];\n\tp[1]=a[0]*b[1]+a[1]*b[0];\n\treturn p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime;\n    \n    vec2 offset=vec2(offset.x+sin(time*.1)*.05,offset.y+cos(time*.1)*.05);\n\tvec2 position = gl_FragCoord.xy/iResolution.xy - offset;\n\t\n\tposition = position * (zoom-.7);\n\n\tvec2 perturb=vec2(-.7+(sin(time*.11)*.1)+(sin(time*.2)*.4),0.45+cos(time*.03)*.05)+(sin(time*.12)*.3);\n\tvec2 c, c0, d;\n\tfloat v;\n\t\n\tc = vec2(position);\n\tc0 = perturb;\n\tc +=(cellular( c*4.))*.025;\n\tvec2 f = position.xy;\n\tfor(int i=0; i<iterations; i++) {\n\t\td = cmult(c, c);\n\t\tc = d + c0;\n\t\tv = abs((c.x*c.x) + sin(.1*time+c.y*c.y)) / sqrt(.1*time+c.x*c.x );\n\t\t\t\n\t\t\t\n\n\t\tif (v > bailout) break;\n\t}\n\tvec2 c1=c+cellular( .1*time+c*3.);\n\tvec2 c2=cellular(-.1*vec2(sin(.4*time + c.y*.2),sin(.02*time + c.x*.5)));\n\tvec2 c3=cellular( c*.01);\n\n\t\n\tfloat rand = mod(fract(sin(dot(2.5*gl_FragCoord.xy/iResolution.xy, vec2(12.9898,100.233))) * 43758.5453), .4);\n\t\n\tfloat col=(pow(v,-.23)*pow(sin(c2.x),.99));\n\tfloat col2=(pow(sin(c1.y)+1.75,.99));\n\t\n    if(v>10.){\n\n\tfragColor = vec4(hsv(.8+sin(c3.r+col)*.3,.5-c3.r,.1+col*.75),1.);\n\t}\n\n\telse \n    \n    fragColor=vec4(hsv(.8+sin(col2)*.3,.5-col+sin(time*.4)*.3,col2*.3),1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 670, 692, 692, 737], [739, 845, 868, 868, 2399], [2401, 2401, 2429, 2429, 2505], [2508, 2508, 2565, 2565, 3673]]}
{"id": "ms2cRt", "name": "Random Rain", "author": "mgmbass", "description": "Playing with random algorithms. ", "tags": ["random"], "likes": 3, "viewed": 225, "published": 3, "date": "1688064308", "time_retrieved": "2024-07-30T17:46:46.450790", "image_code": "float random (vec2 st, float randX, float randY) {\n    return fract(sin(dot(st.xy,\n                         vec2(randX, randY)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float mousePosX = iMouse.x / iResolution.x;\n    \n    uv *= 4.;\n    \n    uv.y += iTime * random(uv, uv.x, 0.0);\n    \n    vec2 iPos = floor(uv);\n    \n    vec3 color = vec3(step(random( iPos , 12.9898, 78.233), mousePosX));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2cRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 155], [157, 157, 214, 264, 594]]}
{"id": "cd2yRd", "name": "HeartyBoi", "author": "KishCom", "description": "Playing around while following https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["heart"], "likes": 2, "viewed": 160, "published": 3, "date": "1688055142", "time_retrieved": "2024-07-30T17:46:48.329767", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat sdHeart( in vec2 p ) {\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\n\nvec3 palette (float t) {\n    // These values come from a gradient generated at: http://dev.thi.ng/gradients\n    vec3 a = vec3(0.748, 0.378, 0.738);\n    vec3 b = vec3(0.916, 0.609, 0.456);\n    vec3 c = vec3(0.508, 0.508, 1.488);\n    vec3 d = vec3(-0.292, -0.062, 0.168);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float offset = 1.25;\n    float offset2y = 0.05;\n    float offset2x = 0.5;\n    \n    uv.x = (uv.x - offset2x) * offset;\n    uv.y = (uv.y - offset2y) * offset;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    uv0.y += offset2x;\n    //uv = fract(uv * offset);\n    //uv.x -= offset2x;\n    uv.y -= offset2y;\n    \n    //vec3 color = palette(iTime);\n    \n    //float d = sdHeart(uv);\n    float d = sdHeart(uv);\n    \n    vec3 color = palette(length(uv0) + iTime); // Try moving this line above d and just use iTime)\n    \n    //float d = length(uv);\n    //d -= 0.5;\n    \n    d = sin(d + iTime * 2.5)/2.5;\n    d = abs(d);\n\n    //for (float i = 0.0; i < 3.0; i++){\n    //    if (i == 0.0){\n    //        d = smoothstep(0.0, 0.10, d);\n    //   }\n    //    if (i == 1.0){\n    //        d = step(0.1, d);\n    //    }\n    //    if (i == 2.0){\n    //        //d = pow(0.01 / d, .75);\n    //        d = 0.05 / d;\n    //   }\n    //}\n    //d = step(0.1, d);\n    d = smoothstep(0.0, 0.10, d);\n    //d = 0.05 / d;\n    //d = pow(0.01 / d, .75);\n    color *= d;\n    \n    fragColor = vec4(color, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2yRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 73, 73, 293], [297, 297, 321, 404, 607], [609, 609, 666, 666, 1808]]}
{"id": "Dd2yRt", "name": "[RMO] - prism", "author": "silica163", "description": "prism sdf", "tags": ["raymarch", "prism"], "likes": 1, "viewed": 214, "published": 3, "date": "1688048153", "time_retrieved": "2024-07-30T17:46:49.245319", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,1)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    pr[0].p = vec3(0.);\n    pr[0].s = vec3(.2,1,6);\n    \n    //l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[0].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    N = sNormal(r.p);\n    \n    //c = N*.5+.5;\n    //c = r.p;\n    c += render(r); \n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  256\n#define MAX_REF   2\n\n#define rotX(a) mat3(      1, 0,       0, 0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n#define rotZ(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nconst int LIGHTS = 1;\nconst int PRISM = 1;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nstruct Prism {\n    vec3 p;\n    vec3 s;\n    vec3 c;\n},pr[PRISM];\n\nfloat polygon(vec2 uv,vec2 p,float r,float n){\n    uv = uv - p;\n    n = floor(n);\n    float pa = PI-atan(uv.x,uv.y);      // position angle\n    float sa = 2.*PI/n;                 // side angle\n    float id = (pa - mod(pa,sa)) / sa ;\n    float ra = id * (sa) + sa/2.;       // rotate angle\n    float ir = cos(sa/2.)*r;            // inner radius\n    float sl = sin(sa/2.)*r;            // half side length\n    \n    uv = rot2D(ra)*uv;\n    uv += vec2(-ir,0);\n    \n    if(uv.x < 0.)return uv.x;\n    \n    return length(vec2(uv.x,uv.y - clamp(uv.y,-sl,sl)));\n}\n\nfloat prismSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Prism ps = pr[id];\n    vec3 cp = p - ps.p;\n    \n    d = vec2(abs(cp.y)-ps.s.x,polygon(cp.xz,vec2(0),ps.s.y,ps.s.z)-.05) * vec2(.5,1);\n    \n    return min(max(d.y,d.x),0.) + length(max(d,0.));\n}\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n    d = prismSDF(p,0)-.05;\n    \n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += diffuse(r.p,l[i].L);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(.1);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2yRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 992]]}
{"id": "msV3Rc", "name": "BC - Gears", "author": "BackwardsCap", "description": "Infinite rotating gears", "tags": ["gears", "modulo", "repeating"], "likes": 6, "viewed": 203, "published": 3, "date": "1688047352", "time_retrieved": "2024-07-30T17:46:50.410204", "image_code": "#define tilt (cos(p.x)/4.0 + (cos(p.y)/4.0)+2.) \n#define size (tilt*15.5 + cos(iTime/8. - 3.14)*10.)/20.\n#define SS(U) smoothstep((size*3.)/iResolution.y, 0., U)\nfloat circle (vec2 p, float r){return length(p)-r;}\n\n\nmat2 rot(float d)\n{\n    float s = sin(d),\n          c = cos(d);\n    return mat2(c, -s, s, c);\n}\n\n\nvec2 lightDir = vec2(0.5,0.5);\n\nvec2 getCell(vec2 uv)\n{\n    float m = 1.42;\n    return mod(uv+m/2.,m)-m/2.;\n}\nfloat gear(vec2 p, float r, float m, float tm)\n{\n    float time = iTime * tm;\n    \n    float shine = dot(normalize(p), normalize(-lightDir));\n    float t = floor(time) + 1.0-pow(1.0-fract(time),3.);\n    \n    \n    t*=0.5 * m;\n    p *= rot(t);\n    float a = atan(p.y, p.x);\n    float gearBump =  cos(a*10.)*0.1;\n    gearBump = clamp(gearBump, -0.05, 0.05);\n    float outer = circle(p, r + gearBump);\n    float inner = circle(p, r-0.25);\n    \n    float s = clamp(SS(outer) - SS(inner), 0., 1.);\n    float sdf = (abs(outer) * 1.0-SS(inner)) * SS(outer);\n    float sdfi = 1.0-sdf;\n    \n    sdfi = smoothstep(1.,.9, sdfi);\n    \n    float s2 = smoothstep(0.3,0.,sdfi);\n    \n    float fo = s*(sdfi);\n    \n    shine*=1.0-fo;\n    shine*= s*.5;\n    shine*=(1.0-sdfi);\n    return clamp(s + shine*s2,0.,1.)*1.;\n}\n\nfloat getGears(vec2 uv, float tm)\n{\n    float g1 = gear(uv, 0.5, 1., tm);\n    float g2 = gear(uv + 0.71, 0.5, -1., tm);\n    g2 = max(g2,gear(uv - 0.71, 0.5, -1., tm));\n    g2 = max(g2,gear(uv - vec2(0.71, -0.71), 0.5, -1., tm));\n    g2 = max(g2,gear(uv - vec2(-0.71, 0.71), 0.5, -1., tm));\n    \n    return max(g1,g2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    p*=size;\n    vec2 puv = p;\n    p = getCell(p);\n    \n    float g = getGears(p,1.0)/6.;\n    float iter = 6.;\n    for(float i=2.; i<2.+iter; i++)\n    {\n    \n        float m = mod(i,2.0) == 1.0 ? 1.0 : -1.0;\n    \n        float time = i/4.*m;\n        g = max(g, getGears(getCell(puv*i),time)/i);\n        \n    }\n    vec3 col = vec3(g);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msV3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 193, 193, 213], [216, 216, 235, 235, 311], [346, 346, 369, 369, 423], [424, 424, 472, 472, 1223], [1225, 1225, 1260, 1260, 1544], [1547, 1547, 1604, 1604, 2045]]}
{"id": "mdBcz3", "name": "3D Wave Simulation", "author": "beans_please", "description": "Check out my Interactive 2D Wave Simulation:\nhttps://www.shadertoy.com/view/mdScW1\n\nCheck out my Python wave simulation project:\nhttps://github.com/bean-mhm/wave-simulation-py", "tags": ["wave", "simulation", "physics", "waveequation", "wavesim"], "likes": 21, "viewed": 428, "published": 3, "date": "1688036284", "time_retrieved": "2024-07-30T17:46:51.723692", "image_code": "// iChannel0 = Buffer A\n// iChannel1 = Buffer B\n\nfloat wave_fetch_curr(ivec3 icoord)\n{\n    if (!icoord_in_bounds(icoord, wave_res))\n        return 0.0;\n    return texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0).x;\n}\n\nvec3 get_col(vec2 frag_coord, vec3 tint)\n{\n    // UV\n    vec2 uv = frag_coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    // Setup camera\n\n    float r = 1.25 * max(wave_dims.x, wave_dims.y);\n    float theta = TWO_PI * iTime * 0.08 - (PI / 2.0);\n    vec3 cam_pos = vec3(r * cos(theta), r * sin(theta), wave_dims.z * 0.2);\n    float cam_fov = 80.0;\n    float cam_zoom = 90.0 / cam_fov;\n\n    vec3 cam_forward = normalize(vec3(0.0, 0.0, wave_dims.z * -0.04) - cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n\n    // Ray\n    Ray ray;\n    ray.orig = cam_pos;\n    ray.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    \n    // Box that contains the wave field\n    vec3 box_min = -wave_dims / 2.0;\n    vec3 box_max = wave_dims / 2.0;\n    \n    // Check intersection with the box\n    Hit hit;\n    ray_aabb(box_min, box_max, ray, hit);\n    \n    // Shade\n    vec3 col = vec3(0.0);\n    if (hit.hit)\n    {\n        col += vec3(0.01);\n        \n        // Intersection length along the ray\n        float len = max(0.0, hit.tmax - hit.tmin);\n        \n        // Step size for traversing the volume\n        const float volume_traverse_step = max(max(wave_dims.x, wave_dims.y), wave_dims.z) / 40.0;\n        \n        // Number of volume samples\n        int num_volume_samples = int(max(4.0, len / volume_traverse_step));\n        \n        // Constants multiplier\n        float mul = pow(2.0, 25.0) / float(num_volume_samples);\n        \n        // Samples\n        for (int i = 0; i < num_volume_samples; i++)\n        {\n            // Point along the ray inside the volume\n            float t = mix(hit.tmin, hit.tmax, float(i) / float(num_volume_samples));\n            vec3 p = ray.orig + t * ray.dir;\n            \n            // Trilinear interpolation\n            vec3 coord = vec3(wave_res) * (p - box_min) / wave_dims;\n            ivec3 p0 = ivec3(floor(coord));\n            ivec3 p1 = p0 + 1;\n            float x0y0z0 = wave_fetch_curr(p0);\n            float x1y0z0 = wave_fetch_curr(ivec3(p1.x, p0.y, p0.z));\n            float x0y1z0 = wave_fetch_curr(ivec3(p0.x, p1.y, p0.z));\n            float x1y1z0 = wave_fetch_curr(ivec3(p1.x, p1.y, p0.z));\n            float x0y0z1 = wave_fetch_curr(ivec3(p0.x, p0.y, p1.z));\n            float x1y0z1 = wave_fetch_curr(ivec3(p1.x, p0.y, p1.z));\n            float x0y1z1 = wave_fetch_curr(ivec3(p0.x, p1.y, p1.z));\n            float x1y1z1 = wave_fetch_curr(p1);\n            float v = interpolate3D(\n                coord - vec3(p0),\n                x0y0z0,\n                x1y0z0,\n                x0y1z0,\n                x1y1z0,\n                x0y0z1,\n                x1y0z1,\n                x0y1z1,\n                x1y1z1\n            );\n            \n            // Update the color\n            col += pow(abs(v), 3.0) * mul * tint;\n        }\n    }\n    \n    // Glow\n    col += tint * 0.15 * pow(max(0.0, dot(ray.dir, normalize(-cam_pos))), 9.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    eprng_init(frag_coord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // RGB sweep\n    vec3 tint = rgb_sweep(iTime * 0.05 + 0.53);\n\n    // Jitter sampling\n    const int num_samples = 4;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        col += get_col(frag_coord + vec2(random() - 0.5, random() - 0.5), tint);\n    }\n    col /= float(num_samples);\n    \n    // Color grading\n    col = pow(col, vec3(1.2));\n    col += 0.015 * pow(tint, vec3(6.0));\n    \n    // Noise\n    col += map_range_clamp(random(), 0.0, 1.0, -0.01, 0.005);\n    \n    // flim\n    col = flim_transform(col, 0.0, iChannel1);\n    \n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float tmin;\n    float tmax;\n};\n\n// Grid Resolution\nconst ivec3 wave_res = ivec3(50, 50, 50);\n\n// Minimum distance in the grid\nconst float wave_step = 0.01;\nconst float wave_step2 = wave_step * wave_step;\n\n// Grid dimensions\nconst vec3 wave_dims = wave_step * vec3(wave_res - 1);\n\n// Propagation speed in 2D\nconst float wave_speed = 10.0;\nconst float wave_speed2 = wave_speed * wave_speed;\n\n// Minimum wavelength\n// At least 8 steps needed for a perfectly smooth spherical wave.\nconst float wave_min_wavelength = wave_step * sqrt(3.0) * 8.0;\n\n// Maximum frequency\nconst float wave_max_frequency = wave_speed / wave_min_wavelength;\n\n// Maximum timestep\nconst float wave_max_dt = wave_step / (wave_speed * sqrt(3.0));\n\n// Timestep\nconst float wave_dt = 0.3 * wave_max_dt;\n\n// Stiffness\n// Must be greater than or equal to 1 to function properly.\nconst float wave_stiffness = 10.0;\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat fit_to_screen(vec2 image_res, vec2 screen_res)\n{\n    return min(screen_res.x / image_res.x, screen_res.y / image_res.y);\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n\n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n\n    return c;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y)\n        && (icoord.z >= 0) && (icoord.z < res.z);\n}\n\nivec3 idx_to_icoord3d(int idx, ivec3 res)\n{\n    return ivec3(\n        idx % res.x,\n        (idx % (res.x * res.y)) / res.x,\n        idx / (res.x * res.y)\n    );\n}\n\nint icoord3d_to_idx(ivec3 icoord, ivec3 res)\n{\n    return\n        icoord.x\n        + icoord.y * res.x\n        + icoord.z * res.x * res.y;\n}\n\nivec2 idx_to_icoord2d(int idx, ivec2 res)\n{\n    return ivec2(idx % res.x, idx / res.x);\n}\n\nint icoord2d_to_idx(ivec2 icoord, ivec2 res)\n{\n    return icoord.x + icoord.y * res.x;\n}\n\nivec3 icoord2d_to_3d(ivec2 icoord2d, ivec2 res2d, ivec3 res3d)\n{\n    return idx_to_icoord3d(icoord2d_to_idx(icoord2d, res2d), res3d);\n}\n\nivec2 icoord3d_to_2d(ivec3 icoord3d, ivec3 res3d, ivec2 res2d)\n{\n    return idx_to_icoord2d(icoord3d_to_idx(icoord3d, res3d), res2d);\n}\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, const Ray r, out Hit hit) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    hit.tmin = t0;\n    hit.tmax = t1;\n    hit.hit = t1 > max(t0, 0.0);\n}\n\nvec4 sample_bilinear(vec2 coord, sampler2D src, ivec2 src_res)\n{\n    ivec2 bottomLeftPos = ivec2(int(floor(coord.x - 0.5)), int(floor(coord.y - 0.5)));\n\n    ivec2 topRightPos = ivec2(bottomLeftPos.x + 1, bottomLeftPos.y + 1);\n\n    ivec2 bottomRightPos = ivec2(topRightPos.x, bottomLeftPos.y);\n\n    ivec2 topLeftPos = ivec2(bottomLeftPos.x, topRightPos.y);\n\n    float alongX = coord.x - (float(bottomLeftPos.x) + 0.5);\n    float alongY = coord.y - (float(bottomLeftPos.y) + 0.5);\n\n    float bottomLeftWeight = (1.0 - alongX) * (1.0 - alongY);\n    float bottomRightWeight = (alongX) * (1.0 - alongY);\n    float topLeftWeight = (1.0 - alongX) * (alongY);\n    float topRightWeight = (alongX) * (alongY);\n\n    vec4 result = vec4(0.0);\n\n    if (icoord_in_bounds(bottomLeftPos, src_res))\n        result += bottomLeftWeight * texelFetch(src, bottomLeftPos, 0);\n\n    if (icoord_in_bounds(topRightPos, src_res))\n        result += topRightWeight * texelFetch(src, topRightPos, 0);\n\n    if (icoord_in_bounds(bottomRightPos, src_res))\n        result += bottomRightWeight * texelFetch(src, bottomRightPos, 0);\n\n    if (icoord_in_bounds(topLeftPos, src_res))\n        result += topLeftWeight * texelFetch(src, topLeftPos, 0);\n\n    return result;\n}\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_INTERPOLATE_2D(T) T \\\ninterpolate2D(vec2 p, T x0y0, T x1y0, T x0y1, T x1y1) \\\n{ \\\n    T s = lerp(x0y0, x1y0, p.x); \\\n    T t = lerp(x0y1, x1y1, p.x); \\\n    return lerp(s, t, p.y); \\\n}\n\n#define FUNC_INTERPOLATE_3D(T) \\\nT interpolate3D( \\\n    vec3 p, \\\n    T x0y0z0, \\\n    T x1y0z0, \\\n    T x0y1z0, \\\n    T x1y1z0, \\\n    T x0y0z1, \\\n    T x1y0z1, \\\n    T x0y1z1, \\\n    T x1y1z1) \\\n{ \\\n    T s = interpolate2D(p.xy, x0y0z0, x1y0z0, x0y1z0, x1y1z0); \\\n    T t = interpolate2D(p.xy, x0y0z1, x1y0z1, x0y1z1, x1y1z1); \\\n    return lerp(s, t, p.z); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_INTERPOLATE_2D(float)\nFUNC_INTERPOLATE_2D(vec2)\nFUNC_INTERPOLATE_2D(vec3)\nFUNC_INTERPOLATE_2D(vec4)\n\nFUNC_INTERPOLATE_3D(float)\nFUNC_INTERPOLATE_3D(vec2)\nFUNC_INTERPOLATE_3D(vec3)\nFUNC_INTERPOLATE_3D(vec4)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n", "buffer_a_code": "// iChannel0 = Buffer A (self-feeding)\n// iChannel1 = Buffer C\n\nfloat wave_initial_val(ivec3 icoord)\n{\n    return 0.0;\n}\n\nfloat wave_update_val(ivec3 icoord, float curr, float sim_time)\n{\n    // Initial pulse at the center\n    if (icoord == wave_res / 2)\n    {\n        float amp = map_range_clamp(sim_time, 0.0, 0.006, 1.0, 0.0);\n        float freq = 0.95 * wave_max_frequency;\n        if (amp > 0.001)\n        {\n            return amp * sin(TWO_PI * sim_time * freq);\n        }\n    }\n\n    return curr;\n}\n\nfloat wave_fetch_curr(ivec3 icoord)\n{\n    //if (!icoord_in_bounds(icoord, wave_res))\n    //    return 0.0;\n    \n    // Disabled bounds checking because below we\n    // do manual bounds checking ONLY on the axis\n    // needed, reducing the overall number of\n    // checks.\n    \n    return texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0).x;\n}\n\n// X = current value\n// Y = previous value\n// Z = iteration\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec3 icoord = icoord2d_to_3d(ivec2(frag_coord), ivec2(iResolution.xy), wave_res);\n\n    // Skip if we're outside the grid\n    if (!icoord_in_bounds(icoord, wave_res))\n        return;\n\n    vec4 data = texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0);\n    float curr = data.x;\n    float prev = data.y;\n    int iter = int(data.z);\n\n    // First frame (initial values)\n    bool reset =\n        iter == 0\n        || iFrame < 1\n        || iTime == 0.0\n        || ivec2(iResolution.xy) != ivec2(texelFetch(iChannel1, ivec2(0), 0).xy);\n    if (reset)\n    {\n        float v = wave_initial_val(icoord);\n        frag_col = vec4(v, v, 1.0, 0.0);\n        return;\n    }\n\n    float next_in_x = 0.0;\n    float prev_in_x = 0.0;\n    float next_in_y = 0.0;\n    float prev_in_y = 0.0;\n    float next_in_z = 0.0;\n    float prev_in_z = 0.0;\n    if ((icoord.x + 1) < wave_res.x)\n    {\n        next_in_x = wave_fetch_curr(icoord + ivec3(1, 0, 0));\n    }\n    if ((icoord.x - 1) >= 0)\n    {\n        prev_in_x = wave_fetch_curr(icoord + ivec3(-1, 0, 0));\n    }\n    if ((icoord.y + 1) < wave_res.y)\n    {\n        next_in_y = wave_fetch_curr(icoord + ivec3(0, 1, 0));\n    }\n    if ((icoord.y - 1) >= 0)\n    {\n        prev_in_y = wave_fetch_curr(icoord + ivec3(0, -1, 0));\n    }\n    if ((icoord.z + 1) < wave_res.z)\n    {\n        next_in_z = wave_fetch_curr(icoord + ivec3(0, 0, 1));\n    }\n    if ((icoord.z - 1) >= 0)\n    {\n        prev_in_z = wave_fetch_curr(icoord + ivec3(0, 0, -1));\n    }\n\n    float grad_x = next_in_x - curr - curr + prev_in_x;\n    float grad_y = next_in_y - curr - curr + prev_in_y;\n    float grad_z = next_in_z - curr - curr + prev_in_z;\n\n    float acc = (grad_x + grad_y + grad_z) * wave_speed2 / wave_step2;\n    float vel = (curr - prev) / wave_dt;\n    vel += (acc * wave_dt);\n    vel *= pow(wave_stiffness, -wave_dt);\n\n    prev = curr;\n    curr += (vel * wave_dt);\n\n    float sim_time = wave_dt * float(iter);\n    curr = wave_update_val(icoord, curr, sim_time);\n\n    frag_col = vec4(curr, prev, float(iter + 1), 0.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(iResolution.xy, 1.0, 1.0);\n}\n", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdBcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 249], [251, 251, 293, 303, 3335], [3337, 3337, 3392, 3415, 4082]]}
{"id": "Dd2yzc", "name": "Year of Truchets #045", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! ", "tags": ["3d", "raymarching", "cube", "truchet"], "likes": 17, "viewed": 263, "published": 3, "date": "1688029251", "time_retrieved": "2024-07-30T17:46:52.611319", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #045\n    06/29/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    50.\nfloat tspeed=0.,speed,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nvec3 hp,hitpoint;\nvec2 gid, sid;\nmat2 grot,srot;\n\nconst float sz = 2.5;\nconst float hf = sz/2.;\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq sdf's\nfloat box( vec3 p, vec3 b ){ vec3 q = abs(p) - b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);}\nfloat box( vec2 p, vec2 b ){vec2 d = abs(p)-b;return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p.z -= T;\n    vec3 q = p;\n    \n    vec2 id = floor((p.xz+hf)/sz);\n    p.xz = mod(p.xz+hf,sz)-hf;\n    \n    float h = hash21(vec2(id.x,0));\n    float f = hash21(id);\n\n    float s = .5+.5*sin((h+id.y*2.5)*.5+T);\n    s += .5+.5*cos((h+id.x*2.5)*.5+T);\n    \n    p.y -= 1.75+s;\n    grot = rot(f*PI-speed);\n    p.zy *= grot;\n    \n    float d = box(p,vec3(.5));\n    if(d<res.x) {\n        res = vec2(d,2);\n        hp = p+id.x+id.y;\n        sid = id;\n    }\n    \n    float fl = q.y;\n    if(fl<res.x) {\n        res = vec2(fl,1);\n        hp = q;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t *= MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p) {\n    float d = 0., m = 0.;\n    for(int i=0;i<128;i++){\n        vec2 t = map(p);\n        d += i<64? t.x*.4:t.x*.8;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(t.x<d*MIN_DIST||d>55.) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 getFace(vec3 h, vec2 uv){\n    \n    float px = 10./R.x; \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float rnd = hash21(id.xy);\n    float sn = hash21(id.yx)*11.;\n    sn = mod(sn,11.);\n    \n    float t1 = lsp(sn,sn+.5,tmod);\n    float t2 = lsp(sn+2.,sn+2.5,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    q.xy *= rot((t1+t2)*1.5707);\n\n    if(rnd>.5) q*=rot(1.5707);\n    rnd=fract(rnd*32.232);\n    \n    vec2 q2 = length(q-.5)<length(q+.5)?q-.5 : q+.5;\n    \n    float tk = .1275;\n    float d1 = abs(length(q2)-.5)-tk;\n    float d3 = length(q)-.5;\n    if(rnd>.85) d1 = min(length(q.x)-tk,length(q.y)-tk);\n    d1=max(d1,d3);\n\n    float tt = .5+.5*sin(fract(T*.05)*PI);\n    tt=smoothstep(.7,.8,tt);\n    vec3 cr = mix(vec3(0,.4,.9),vec3(.03),tt);\n    h = mix(h,cr,smoothstep(px,-px,d3));\n    h = mix(h,mix(vec3(0),vec3(1,0,0),t1-t2),smoothstep(px,-px,d1));\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    tspeed = T*.3;\n    speed = T*.5;\n    tmod = mod(tspeed,14.);\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,11);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse //\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : (M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    mat2 rx = rot(-.68-x), ry = rot(-1.18-T*.06-y);\n    \n    ro.zy *= rx;rd.zy *= rx;\n    ro.xz *= ry;rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    vec2 ray = marcher(ro,rd,p);\n    float d = ray.x, m = ray.y;\n    \n    gid = sid;\n    hitpoint = hp;\n    srot = grot;\n    \n    if(d<MAX_DIST) {\n  \n        vec3 n = normal(p,d);\n        vec3 tn = n;\n        vec3 lpos = vec3(-15,15,-15);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t=.01;t<16.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h * .75;\n            if( shdw<MIN_DIST || t>6. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),0.),24.);\n        vec3 h = vec3(1.);\n        int face;\n        \n        if(m==2.) {\n            vec3 cuv;\n            h = vec3(.01);\n            tn.zy *= srot;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n    \n            if(face==0) cuv = hitpoint.yzx;\n            if(face==1) cuv = hitpoint.xzy;\n            if(face==2) cuv = hitpoint.xyz;\n            if(face==3) cuv = hitpoint.xyz;\n            if(face==4) cuv = hitpoint.xzy;\n            if(face==5) cuv = hitpoint.yzx;\n\n            //h = getFace(h, ((cuv.xy+float(face))-.5)*3.);\n            h = getFace(h, (cuv.xy+float(face))*2.);\n        }\n        \n        if(m==1.) {\n            h = vec3(.01);\n            vec2 uv = hitpoint.xz*.5;\n            h=  getFace(h,uv);\n        }\n        \n        C = h * diff;\n\n    }\n\n    C = mix(C,vec3(.005), 1.-exp(-.0006*d*d*d));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2yzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[531, 531, 552, 552, 607], [608, 608, 626, 626, 671], [673, 673, 710, 710, 744], [745, 745, 764, 764, 791], [793, 805, 833, 833, 912], [913, 913, 941, 941, 1008], [1010, 1010, 1028, 1028, 1623], [1625, 1625, 1655, 1655, 1850], [1852, 1852, 1898, 1898, 2128], [2130, 2130, 2160, 2160, 3031], [3033, 3033, 3074, 3074, 5407]]}
{"id": "DsByzd", "name": "testShaderSKLBZ", "author": "sklbz", "description": "just a shader", "tags": ["shader"], "likes": 2, "viewed": 156, "published": 3, "date": "1688024723", "time_retrieved": "2024-07-30T17:46:53.597682", "image_code": "vec3 palette(float t) {\nvec3 a = vec3(0.600, 0.500, 0.500), b = vec3(0.910, 0.600, 0.600), c = vec3(1.058, 1.000, 1.000), \n        d = vec3(0.190, 0.413, 0.557);\n        return a+b*cos(5.283185*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y, uv0 = uv;\n    \n    vec3 finalColor = vec3(0.25);\n    \n    for(float i = 0.0; i < 3.0; i++) {\n    \n        uv = fract(uv * 1.5) - .5;\n    \n        float d = length(uv) + tan(length(uv)) /* * cos(cos(length(uv)) * sin(length(uv0)))*/ * exp(-length(uv0));\n    \n        vec3 col = palette(length(uv0) / 2. + sqrt(exp(length(uv0) + iTime * 0.0058)) /2.  + iTime * .55);\n    \n    \n        \n        d = abs(d);\n    \n        d = sin(d * 8. + iTime + iDate.z) / 8.;\n    \n    \n        d = 0.02 / d;\n\n        finalColor += col * d;\n    }\n\n    float t = clamp(0.1, sin(iTime) + 1.5, 10.);\n\n    float tt = sin((uv0.x + floor(uv0.x-uv0.y))/2. - 5.) - 5.;\n\n    \n\n    fragColor = vec4(finalColor * t, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsByzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 205], [207, 207, 264, 264, 1022]]}
{"id": "ms2cz3", "name": "Stick Figure Cloaking", "author": "oneshade", "description": "The rays gets bent around a sphere to hide the stick figure until he jumps.", "tags": ["space", "warp", "hide", "cloaking"], "likes": 9, "viewed": 234, "published": 3, "date": "1688004241", "time_retrieved": "2024-07-30T17:46:54.371613", "image_code": "#define EPS 0.001\n\nvec2 Rotate(in vec2 p, in vec2 o, in float r) {\n    float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdSegment(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 o, in vec3 b) {\n    p = abs(p - o) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, max(p.y, p.z)));\n}\n\nfloat sdStickFigure(in vec3 p) {\n    // Sizes\n    float t = 0.1; // Thickness\n    float hs = 0.4; // Head size\n\n    // Limb rotations\n    float lsr = cos(iTime * 2.5) + 0.5; // Left shoulder rotation\n    float rsr = -0.25 - lsr; // Right shoulder rotation\n\n    float lar = cos(iTime * 2.5) + 2.0; // Left forearm rotation (a for forearm)\n    float rar = 4.0 - cos(iTime * 2.5 + 0.5); // Right forearm rotation\n\n    float ltr = 0.0; // Left thigh rotation\n    float rtr = 0.0; // Right thigh rotation\n\n    float lcr = 0.0; // Left shin (calf) rotation\n    float rcr = 0.0; // Right shin (calf) rotation\n\n    // Joint positions\n    vec2 np = vec2(0.0, 0.75) + sin(iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.1, 0.05); // Neck\n    vec2 bp = vec2(-0.15, -0.65) + sin(-iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.25, 0.1); // Hip\n    vec2 hp = bp + normalize(np - bp) * (length(np - bp) + hs); // Head\n\n    vec2 lep = vec2(-0.4, 0.0); // Left elbow\n    vec2 rep = vec2(0.4, 0.0); // Right elbow\n\n    vec2 lhp = vec2(-0.75, 0.7); // Left hand\n    vec2 rhp = vec2(0.75, 0.7); // Right hand\n\n    vec2 lfp = vec2(-0.25, -2.0) + sin(-iTime * 3.0 + vec2(1.57, 0.0)) * vec2(1.25, 0.4); // Left foot\n    vec2 rfp = vec2(0.5, -1.75) + sin(-iTime * 3.0 + 2.0 + vec2(1.57, 0.0)) * vec2(1.0, 0.4); // Right foot\n\n    vec2 lkp = (bp + lfp) * 0.5; lkp += normalize(lkp - bp).yx * vec2(-0.25, 0.25); // Left knee\n    vec2 rkp = (bp + rfp) * 0.5; rkp += normalize(rkp - bp).yx * vec2(-0.25, 0.25); // Right knee\n\n    // Arm rotations\n    lep = Rotate(lep, np, lsr); // Left shoulder rotation\n    rep = Rotate(rep, np, rsr); // Right shoulder rotation\n\n    lhp = Rotate(lhp, np, lsr); // Left forearm rotation (with elbow)\n    rhp = Rotate(rhp, np, rsr); // Right forearm rotation (with elbow)\n\n    lhp = Rotate(lhp, lep, lar); // Left forearm rotation (independent)\n    rhp = Rotate(rhp, rep, rar); // Right forearm rotation (independent)\n\n    // Leg rotations\n    lkp = Rotate(lkp, bp, ltr); // Left thigh rotation\n    rkp = Rotate(rkp, bp, rtr); // Right thigh rotation\n\n    lfp = Rotate(lfp, bp, ltr); // Left shin rotation (with thigh)\n    rfp = Rotate(rfp, bp, rtr); // Right shin rotation (with thigh)\n\n    lfp = Rotate(lfp, lkp, lcr); // Left shin rotation (independent)\n    rfp = Rotate(rfp, rkp, rcr); // Right shin rotation (independent)\n\n    return min(min(sdSegment(p, vec3( np, -t), vec3(lep, -t)),\n               min(sdSegment(p, vec3(lep, -t), vec3(lhp, -t)),\n               min(sdSegment(p, vec3( np,  t), vec3(rep,  t)),\n               min(sdSegment(p, vec3(rep,  t), vec3(rhp,  t)),\n               min(sdSegment(p, vec3( np,  0), vec3( bp,  0)),\n               min(sdSegment(p, vec3( bp, -t), vec3(lkp, -t)),\n               min(sdSegment(p, vec3(lkp, -t), vec3(lfp, -t)),\n               min(sdSegment(p, vec3( bp,  t), vec3(rkp,  t)),\n                   sdSegment(p, vec3(rkp,  t), vec3(rfp,  t)))))))))) - t,\n\n               sdSphere(p, vec3(hp, 0), hs));\n}\n\nvoid add(inout float dist, inout int nearest, in float obj, in int id) {\n    if (obj < dist) {\n        dist = obj;\n        nearest = id;\n    }\n}\n\nfloat mapUncloaked(in vec3 p, in vec3 pos, out int id) {\n    float sec = fract(max(0.0, mod(iTime, 2.0) - 1.0));\n    vec3 sp = p - pos - vec3(0.0, 24.0 * sec * (1.0 - sec), 0.0);\n    vec2 dir = normalize(vec2(2.0 * cos(2.0 * iTime), -sin(iTime)));\n    sp.xz *= mat2(dir, -dir.y, dir.x);\n    float d = sdStickFigure(sp);\n    id = 0;\n    add(d, id, p.y, 1);\n    add(d, id, sdSphere(p, vec3(5.0, 4.0, 3.0), 1.0), 2);\n    add(d, id, p.z + 7.0, 3);\n    add(d, id, sdBox(p, vec3(-8.0, 2.3, 0.0), vec3(1.0, 2.0, 0.5)) - 0.3, 4);\n    return d;\n}\n\nvec3 getNormalUncloaked(in vec3 p, in vec3 pos, in float d0) {\n    int id;\n    return normalize(vec3(\n        mapUncloaked(p + vec3(EPS, 0, 0), pos, id),\n        mapUncloaked(p + vec3(0, EPS, 0), pos, id),\n        mapUncloaked(p + vec3(0, 0, EPS), pos, id)\n    ) - d0);\n}\n\nfloat mapCloaked(in vec3 p, in vec3 pos, out int id) {\n    p += normalize(p - pos) * 2.5;\n    return mapUncloaked(p, pos, id) * 0.3;\n}\n\nvec3 getNormalCloaked(in vec3 p, in vec3 pos, in float d0) {\n    int id;\n    return normalize(vec3(\n        mapCloaked(p + vec3(EPS, 0, 0), pos, id),\n        mapCloaked(p + vec3(0, EPS, 0), pos, id),\n        mapCloaked(p + vec3(0, 0, EPS), pos, id)\n    ) - d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0, -0.25));\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 2.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec3 pos = vec3(3.0 * sin(2.0 * iTime), 2.25, 3.0 * cos(iTime));\n\n    float t = 0.0, d;\n    vec3 p;\n    int id;\n    bool hit;\n    for (int i = 0; i < 200; i++) {\n        p = ro + rd * t;\n        d = mapCloaked(p, pos, id);\n        if (abs(d) < EPS) {\n            hit = true;\n            break;\n        }\n\n        if (t > 25.0) break;\n        t += d;\n    }\n\n    fragColor = vec4(0);\n    if (hit) {\n        vec3 nor = getNormalCloaked(p, pos, d);\n        float shade = max(0.0, dot(nor, -rd));\n        vec3 color = vec3(0.8, 0.5, 0.0);\n        if (id == 1) color = vec3(0.0, 1.0, 0.0);\n        if (id == 2) color = vec3(0.0, 0.0, 1.0);\n        if (id == 3) color = vec3(1.0, 0.4, 0.25);\n        if (id == 4) color = vec3(1.0, 0.25, 1.0);\n        fragColor.rgb = color * shade;\n        vec2 st = p.yz;\n        vec3 an = abs(nor);\n        if (an.y > max(an.x, an.z)) st = p.xz;\n        if (an.z > max(an.x, an.y)) st = p.xy;\n        fragColor = mix(fragColor, texture(iChannel0, st * 0.5), 0.5);\n    }\n\n    t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        d = mapUncloaked(p, pos, id);\n        if (abs(d) < EPS) {\n            if (id == 0) fragColor.b += 0.4;\n            break;\n        }\n\n        if (t > 25.0) break;\n        t += d;\n    }\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2cz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 66, 66, 146], [148, 148, 198, 198, 323], [325, 325, 375, 375, 407], [409, 409, 455, 455, 549], [551, 551, 583, 596, 3498], [3500, 3500, 3572, 3572, 3644], [3646, 3646, 3702, 3702, 4183], [4185, 4185, 4247, 4247, 4456], [4458, 4458, 4512, 4512, 4592], [4594, 4594, 4654, 4654, 4857], [4859, 4859, 4914, 4914, 6698]]}
{"id": "DdSyR3", "name": "Trippy Spiral Tunnel", "author": "martysh12", "description": "Hello, ShaderToy!", "tags": ["tunnel", "spiral", "trippy"], "likes": 9, "viewed": 218, "published": 3, "date": "1687988827", "time_retrieved": "2024-07-30T17:46:55.145544", "image_code": "float grid(vec2 p) {\n    return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nfloat tunnel(vec2 uv, float dist)\n{\n    vec2 tun = vec2(dist / ((sin(iTime * 3.) + 1.) / 6. + 1.), atan(uv.y, uv.x));\n    tun.x += iTime / 4. + sin(iTime * 3.) * 0.1;\n    tun.y += iTime / 12. + tun.x / 2.;\n    float checker = grid(tun * 7.);\n    \n    return checker;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    \n    uv.x -= sin(iTime) / 12.;\n    uv.y -= cos(iTime) / 24.;\n    \n    uv.x /= iResolution.y / iResolution.x;\n    \n    float dsq = 1. / (pow(pow(uv.x * uv.x, 4.0) + pow(uv.y * uv.y, 4.0), 1.0 / 8.0)) * .2;\n    float dci = 1. / length(uv) * .2;\n    float dist = mix(dci, dsq, sin(iTime) * 0.5 + 0.5);\n    \n    vec3 finalColor = vec3(tunnel(uv, dist));\n    \n    finalColor += min(1. - dist / 4., 0.0);\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 67], [69, 69, 104, 104, 337], [339, 339, 396, 446, 950]]}
{"id": "dsByR3", "name": "Some other nonsense", "author": "sklbz", "description": "just taking some random shaders and changing random thing by adding things such as pi in the computation.", "tags": ["intro", "silexars", "1k", "demojs"], "likes": 10, "viewed": 371, "published": 3, "date": "1687962099", "time_retrieved": "2024-07-30T17:46:55.916482", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(float i = 0.; i < 3.; i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5021333;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*((sin(z)+1.)*abs(sin(l*9.-z-z)) + tan(exp(1.61803398875 * 3.141592653589)) + cos(exp(6.62607015)));\n        uv += i + t * 0.5;\n        int j = int(i);\n\t\tc[j]=.01/length(mod(uv,1.)-.5) + (sin(exp(i + t)) + 1.) * 0.01;\n\t}\n\tfragColor=vec4((c/l),t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsByR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 224, 224, 631]]}
{"id": "msSyR3", "name": "some nonsense", "author": "sklbz", "description": "shader", "tags": ["fractals"], "likes": 0, "viewed": 171, "published": 3, "date": "1687961760", "time_retrieved": "2024-07-30T17:46:56.852978", "image_code": "vec3 palette(float t) {\nvec3 a = vec3(0.600, 0.500, 0.500), b = vec3(0.910, 0.600, 0.600), c = vec3(1.058, 1.000, 1.000), \n        d = vec3(0.190, 0.413, 0.557);\n        return a+b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float goldenNumber = 1.61803398875, pi = 3.141592653589, plank = 6.62607015;\n\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y * 2.2, p=fragCoord.xy/ iResolution.xy, uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    float l, z = iTime;\n    \n    for(float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        \n        plank /= 1.65 + i / 10.;\n        \n        p-=.5;\n\t\tp.x*=iResolution.x/iResolution.y;\n\t\t//z+=.07;\n        \n        l=length(p);\n        uv += p/l*(sin(z)+1.)*abs(sin(l*9.-z-z)) * 0.035 + iDate.xy * 0.0000005;\n        \n        float d = length(uv) * exp(-length(uv0)) * goldenNumber * pi * (1. + fract(plank));\n    \n        vec3 col = palette(length(uv0) + (i + iTime*0.5)*.4);\n    \n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n    \n        d = pow(0.015 / d, 1.4);\n    \n        \n    \n        finalColor += col * d * goldenNumber / 1.6 + iDate.xyz * 0.000005;\n    }\n\n    \n\n    fragColor = vec4( finalColor , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 204], [206, 206, 263, 263, 1250]]}
{"id": "DsSyzc", "name": "Fork Initiation sklbz 497", "author": "sklbz", "description": "my third shader (isn't it majestic ?).", "tags": ["fractals"], "likes": 0, "viewed": 146, "published": 3, "date": "1687960840", "time_retrieved": "2024-07-30T17:46:57.855298", "image_code": "vec3 palette(float t) {\nvec3 a = vec3(0.600, 0.500, 0.500), b = vec3(0.910, 0.600, 0.600), c = vec3(1.058, 1.000, 1.000), \n        d = vec3(0.190, 0.413, 0.557);\n        return a+b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float goldenNumber = 1.61803398875, pi = 3.141592653589, plank = 6.62607015;\n\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y * 2.2;\n    \n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        \n        plank /= 1.65 + i / 10.;\n        \n        float d = length(uv) * exp(-length(uv0)) * goldenNumber * pi * (1. + fract(plank));\n    \n        vec3 col = palette(length(uv0) + (i + iTime*0.5)*.4);\n    \n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n    \n        d = pow(0.015 / d, 1.4);\n    \n        finalColor += col * d * goldenNumber / 1.6;\n    }\n\n    fragColor = vec4( finalColor , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 204], [206, 206, 263, 263, 977]]}
{"id": "cdjyWD", "name": "Hadar", "author": "Dragonpeak", "description": "Code is a total mess, inspired by the last few episodes of https://www.twitch.tv/highrollersdnd", "tags": ["space", "planet", "volumetric", "glow", "stars", "nebula", "flare"], "likes": 17, "viewed": 514, "published": 3, "date": "1687952119", "time_retrieved": "2024-07-30T17:46:59.061074", "image_code": "vec3 toneMap(vec3 x) \n{\n    //implementation from https://www.shadertoy.com/view/WdjSW3\n    const vec3 L_white = vec3(4.0);\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nfloat flare(vec2 p, vec2 flarePos)\n{// simple lens flare \n    vec2 op = p;\n    p-=flarePos;\n    float t = atan(p.y, p.x);\n\n    float col = 0.;\n    col += pow(1./length(p)*.02, 3.)-noise2D(vec2(t*16.,0.))*.08;\n    col += (1./length(p*vec2(.05,1.))*.05);\n    col += (1./length(p*vec2(1.,.1))*.02);\n    \n    col = max(pow(col, 4.),0.)*.1;\n    int ghosts = 4;\n    for(int i = -ghosts; i < ghosts; i++)\n    {\n        if(i==1)continue;\n        col += clamp(pow(1./distance(op*float(i), flarePos)*.1, 8.), 0., 1.);\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    vec2 screenPos = (fragCoord.xy/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n\n    vec4 col = textureLod(iChannel0, uv,0.);\n    col.y = textureLod(iChannel0, ((uv*2.-1.)*.995)*.5+.5,0.).y;\n    col.z = textureLod(iChannel0, ((uv*2.-1.)*.99)*.5+.5,0.).z;\n    const vec2 FLARE_POS = vec2(-.35,.14);\n    vec3 flareG = clamp(texture(iChannel0, FLARE_POS*.5+.5).xyz-.05, 0.001, 1.)*.1*vec3(1.,.1,.1);\n    \n    flareG = toneMap(flare(screenPos, FLARE_POS)*mix(flareG, flareG.xxx, .001));//scale flare colour by the point on the image it is over\n    col.xyz = toneMap(col.xyz*vec3(1.000,0.761,0.682));\n    col.xyz += clamp(flareG, vec3(0), vec3(1))*.9;\n    vec3 bloom = vec3(0);\n    for(int i = -BLUR_SAMPLES; i <= BLUR_SAMPLES; i++ )\n    {//y part of blur for bloom\n        bloom.xyz+=textureLod(iChannel1, (fragCoord+vec2(0,i*3))/iResolution.xy, 2.).xyz*gaussian(float(i)/float(BLUR_SAMPLES), 1., 0., .1);\n    }\n    bloom/=float(BLUR_SAMPLES*2);\n    col.xyz += toneMap(mix(bloom, bloom.xxx, .07))*.05;\n    col*=1.-length(uv*2.-1.)*.75;\n\n\n    fragColor = vec4(pow(col.xyz, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3 PLANET_POS = vec3(-.05,.25,.0);\nconst float PLANET_R = .08;\nconst vec3 PLANET2_POS = vec3(.26,.4,-.32);\nconst float PLANET2_R = .13;\nconst float FAR = 1.;\nconst vec3 CAMERA_POS = vec3(.2,.5, -0.2);\nconst vec3 CAMERA_DIR = vec3(.1,-1,.2); \nconst float FOCAL_LEN = .7;\nconst float RENDER_SCALE = .6;\nconst int BLUR_SAMPLES = 12;\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n//https://iquilezles.org/articles/distfunctions/\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\nfloat gaussian(float x, float a, float b, float c)\n{\n    return a*exp(-(pow(x-b,2.)/pow(2.*c,2.)));\n}\nRay constructViewRay(vec2 screen_pos, vec3 pos, vec3 look_dir, vec3 up, float len)\n{\n    Ray r = Ray(pos, vec3(0));\n    \n    vec3 side = cross(up, look_dir);\n    vec3 cam_up = cross(look_dir,side);\n    \n    r.dir = normalize(side*screen_pos.x+cam_up*screen_pos.y+look_dir*len);\n    \n    return r;\n}\nvec2 raySphere( Ray r, float ra)\n{\n    // edited from https://iquilezles.org/articles/intersectors\n    \n     float b = dot( r.origin, r.dir );\n     float c = dot( r.origin, r.origin ) - ra*ra;\n     float h = b*b - c;\n     if( h<0.0 ) return vec2(FAR);\n     h = sqrt( h );\n     return vec2( -b-h, -b+h );\n\n}\nvec3 screenShake(float t)\n{\n    return vec3(sin(t*27.12)*.001,sin(t*27.12+.863)*.001,-cos(t*27.12+.163)*.001)*.04*sin(t);\n}\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nuvec3 pcg3d(uvec3 v) \n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec2 rand2D(vec2 v)\n{\n    return vec2(pcg2d(uvec2(v)))/float(0xffffffffu);\n}\nvec3 rand3D(vec3 v)\n{\n    return vec3(pcg3d(uvec3(v)))/float(0xffffffffu);\n}\n\nfloat voro3D(vec3 pos, out vec3 point)\n{\n    vec3 cell = floor(pos);\n    float dist = 99.;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 pic = rand3D(abs(cell+vec3(x,y,z)))+cell+vec3(x,y,z);\n                float cd = dot(pos-pic, pos-pic);\n                point = (cd < dist) ? pic : point;\n                dist = min(dist, cd);\n            }\n        }\n    }\n    return (dist);\n}\nfloat voro2D(vec2 pos, out vec2 point)\n{\n    vec2 cell = floor(pos);\n    float dist = 99.;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n\n            vec2 pic = rand2D(abs(cell+vec2(x,y)))+cell+vec2(x,y);\n            float cd = dot(pos-pic, pos-pic);\n            point = (cd < dist) ? pic : point;\n            dist = min(dist, cd);\n            \n        }\n    }\n    return (dist);\n}\nfloat noise2D(vec2 p)\n{\n    vec2 ap = abs(p);\n    vec2 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = rand2D(ap).x;\n    float b = rand2D(ap+vec2(1,0)).x;\n    float c = rand2D(ap+vec2(0,1)).x;\n    float d = rand2D(ap+vec2(1)).x;\n\n    float v = mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y);\n    \n    return v;\n}\nvec3 noise3D(vec3 p)\n{\n    vec3 ap = abs(p);\n    vec3 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    vec3 a = rand3D(ap);\n    vec3 b = rand3D(ap+vec3(1,0,0));\n    vec3 c = rand3D(ap+vec3(0,1,0));\n    vec3 d = rand3D(ap+vec3(1,1,0));\n    \n    vec3 e = rand3D(ap+vec3(0,0,1));\n    vec3 f = rand3D(ap+vec3(1,0,1));\n    vec3 g = rand3D(ap+vec3(0,1,1));\n    vec3 h = rand3D(ap+vec3(1,1,1));\n\n    vec3 v = mix(mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y), mix(mix(e,f, fr.x),mix(g,h,fr.x), fr.y), fr.z);\n    \n    return v;\n}", "buffer_b_code": "\nconst float STEP_SIZE = .005;\nconst float LIGHT_FAR = .5;\nconst float LIGHT_STEP_SIZE = .15;\n//draw the nebula using mostly normal volumetric raymarching\nfloat nebulaeDens(vec3 pos)\n{//the density is based of a domain warped fbm voronoi noise, with the warping using standard value noise and varied over time\n    vec3 p;\n    float d = 0.;\n    float sc = 9.;\n    float am = 1.;\n    float lp = 1.-length(pos);\n    if(lp<0.)return 0.;\n    float t = .8*(max(sin(iTime*.02),0.)*(sin(iTime*.1)*3.+cos(iTime*1.)*.2)+iTime*.3)+211.;\n    pos += (noise3D(pos*4.-t*.01)*2.-1.)*.4;\n    for(int i = 0; i < 6; i++)\n    {\n        d+=pow(voro3D(pos*sc+float(i)*351.25+vec3(t)*sc*.01, p), 3.)*am;\n        if(d<.01)break;\n        am*=.9;\n        sc*=1.4;\n    }\n    d*=clamp(sdCapsule(pos, CAMERA_POS, CAMERA_POS*.3, .4), -1.,0.)+1.;\n    return max(pow(d*clamp(lp, 0., 1.), 4.)*2000.,0.);\n}\nfloat marchLight(Ray r)\n{//standard light marching\n    float d = .001;\n    float trans = 1.;\n    while(d < LIGHT_FAR)\n    {\n        d += LIGHT_STEP_SIZE;\n        vec3 pos = r.origin+r.dir*d;\n        float dens = nebulaeDens(pos)*LIGHT_STEP_SIZE;\n        trans*=exp(-dens);\n        if(trans<.5)\n        {\n            trans = 0.;break;\n        }\n    }\n    return trans;\n}\nvec4 march(Ray r)\n{//march the density, the middle of the nebulae also pushes and pulls on the light ray, with the strength varying over time. if we get to close to the \"event horizon\" then we colour it black and exit\n    float d = .001;\n    float trans = 1.;\n    vec3 col = vec3(0);\n    float far = min(FAR, raySphere(Ray(r.origin-PLANET_POS, r.dir), PLANET_R).x);//use planet 1 as our max dist if we hit it\n    while(d < far)\n    {\n        d += STEP_SIZE;\n        vec3 pos = r.origin+r.dir*d;\n        float dens = nebulaeDens(pos)*STEP_SIZE;\n        float lp = length(pos);\n        r.dir = normalize(r.dir+normalize(pos)*max(1./lp,0.)*(sin(iTime*.2)*.1*STEP_SIZE));\n        trans*=exp(-dens);\n        if(lp < .02)\n        {\n            trans = 0.;\n            col = vec3(0);\n            break;\n        }\n        if(dens > .01)\n        {\n            Ray lr = Ray(pos, normalize(-pos));\n            float pdist = raySphere(Ray(lr.origin-PLANET_POS, lr.dir), PLANET_R).x;\n            float light = (pdist<FAR) ? 0. : marchLight(lr)/(4.*(lp*lp));\n            col += (3.*vec3(1.,.01,.01)*max(0., light) + vec3(0,0,.1))*trans*dens;\n        }\n        if(trans<.1)\n        {\n            trans = 0.;break;\n        }\n    }\n    return vec4(max(col, vec3(0)),trans);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragCoord/=RENDER_SCALE;\n    if(fragCoord.x > iResolution.x || fragCoord.y > iResolution.y)return;\n    vec2 screenPos = ((fragCoord.xy)/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n\n\n    Ray viewRay = constructViewRay(screenPos, CAMERA_POS+screenShake(iTime), normalize(CAMERA_DIR), vec3(0,0,1), FOCAL_LEN);\n    vec2 planet2 = raySphere(Ray(viewRay.origin-PLANET2_POS, viewRay.dir), PLANET2_R);// planet 2 acts as a cutout, so we don't need to render as much\n    if(planet2.x < FAR)return;\n    viewRay.origin+=viewRay.dir*(texture(iChannel0, screenPos+iTime*10.3127).x*2.-1.)*STEP_SIZE*.5;\n    vec4 col = vec4(march(viewRay)/2.);\n    vec4 last = texture(iChannel1, uv).rgba;\n    fragColor = vec4(col*.4+last*.6);\n}", "buffer_b_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// stars, planets and the ships\n\nvec3 stars(vec2 pos)\n{\n    vec2 p;\n    float stars = voro2D(pos*3200.,p);\n    return vec3(smoothstep(.98,.997,1.-stars));\n}\n\nvec3 shadePlanet(Ray r, vec2 planet)// planet is just a noisy sphere with a bit of manipulation based on the thickness at that point\n{\n      \n    vec3 nrm = r.origin-PLANET_POS+r.dir*planet.x;\n    nrm = normalize(nrm+(noise3D(nrm*600.).xxx*2.-1.)*0.02);\n    float light = dot(nrm, -normalize(r.origin+r.dir*planet.x));\n    light+=1.-((planet.y-planet.x)/PLANET_R);\n    vec3 lCol = vec3(1.000,0.067,0.067)*max(light,0.)*80. + vec3(.01); \n    return lCol;\n}\nvec3 shadePlanet2(Ray r, vec2 planet)\n{\n    //mostly as above just different noise and rotated\n    vec3 nrm = r.origin-PLANET_POS+r.dir*planet.x;\n    float rot = .8;\n    float cr = cos(rot);\n    float sr = sin(rot);\n    nrm = mat3(vec3(cr,0,sr),vec3(0,1,0), vec3(-sr,0,cr))*nrm;\n    vec3 noise = (noise3D(nrm*vec3(20.,20.,500.)+iTime*.01).xxx*2.-1.)+(noise3D(nrm*vec3(100.,100.,2000.)+iTime*.1).xxx*2.-1.)*0.5+(noise3D(nrm*vec3(500.,500.,3000.)+iTime*.1).xxx*2.-1.)*0.25;\n    nrm = normalize(nrm-noise*.2);\n    float light = dot(nrm, -normalize(r.origin+r.dir*planet.x+vec3(-.3,-1.8,2.8)));\n    light+=1.-((planet.y-planet.x)/PLANET_R);\n    vec3 lCol = vec3(0.784,0.098,0.098)*pow(max(light,0.),4.)*100. + vec3(.02); \n    return lCol*mix(vec3(0.149,0.529,0.714), vec3(0.345,0.290,0.216), noise.x);\n}\n\n\nfloat distShip(vec3 pos, float to)\n{\n    //the ships are sdf lines with some domain warping based on sin and distance to shape them and make them move\n    const vec3 A =vec3(0.4,-.3,-.1)+CAMERA_POS;\n    const vec3 B =vec3(0.3,-1,-.02)+CAMERA_POS;\n    float dist = distance(A,pos)-distance(B,pos);\n    pos.x += sin(dist+iTime+to)*.01;\n    pos.z += sin(dist+312.15+iTime+to)*.01;\n    pos.x += sin(dist*12.+iTime*8.+to)*.03*(1.-clamp(dist+.7,0.,1.));\n    \n    float d = sdCapsule(pos, A, B, .04*((dist+.2))*(1.-clamp(dist*2.,0.,1.)));\n    return d;\n}\nfloat distShipScene(vec3 pos)\n{\n    float d = distShip(pos,0.);\n    d = min(d,distShip(pos+vec3(.1,-.3*sin(iTime),.2),.123));\n    d = min(d,distShip(pos+vec3(-.2,.1*cos(iTime),.2),.81));\n    \n    return d;\n}\n\nvec3 marchShip(Ray r)\n{//standard sdf march\n    float dep = .01;\n    float i = 0.;\n    while (dep < FAR)\n    {\n        float dist = distShipScene(r.origin+r.dir*dep);\n        if(dist<.002)break;\n        dep+=dist*.2;\n        i+=.1;\n    }\n    return vec3(0.239,0.639,0.812)*pow(i*.1+float(dep<FAR), 6.)*3.;\n}\nvec3 drawNearStars(vec2 pos, float nebW)\n{//draw several layers of stars at differnt scales and have them be effected more of less by nebulas dens, so it looks like they are partly behind it. \n    vec3 star =vec3(0);\n    pos.x*=.1;\n    for(int i = 0; i < 3; i++)\n    {\n        vec2 p;\n        nebW-=.1;\n        star+=smoothstep(.995, 1., pow(1.-voro2D(pos*5.*float(i*2+1),p), 12.))*clamp(nebW+.1,0.,1.);\n    }\n    return vec3(0.871,0.757,0.494)*star*20.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n\n\n    Ray viewRay = constructViewRay(screenPos, CAMERA_POS+screenShake(iTime), normalize(CAMERA_DIR), vec3(0,0,1), FOCAL_LEN);\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    vec3 bg = stars(uv);\n    vec2 planet = raySphere(Ray(viewRay.origin-PLANET_POS, viewRay.dir), PLANET_R);\n    vec2 planet2 = raySphere(Ray(viewRay.origin-PLANET2_POS, viewRay.dir), PLANET2_R);\n    \n    bg = (planet.x<FAR) ? shadePlanet(viewRay, planet) : bg;\n    bg = (planet2.x<FAR) ? shadePlanet2(viewRay, planet2) : bg;\n    \n    vec3 ship = marchShip(viewRay);\n\n    vec4 nebulae = texture(iChannel0, uv*RENDER_SCALE);\n    \n    vec3 col = mix(nebulae.xyz, bg, nebulae.a);\n    col += drawNearStars(screenPos, nebulae.w)*float(planet2.x >= FAR);\n    col += vec3(ship);\n    \n    fragColor = vec4(col.xyz,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//x part of gaussian blur for bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for(int i = -BLUR_SAMPLES; i <= BLUR_SAMPLES; i++ )\n    {\n        fragColor.xyz+=min(pow(textureLod(iChannel0, (fragCoord+vec2(i*3,0))/iResolution.xy, 2.).xyz, vec3(3.)),vec3(100000))*gaussian(float(i)/float(BLUR_SAMPLES), 1., 0., .2);\n    }\n    fragColor/=float(BLUR_SAMPLES*2);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 87, 187], [188, 188, 224, 245, 719], [720, 720, 777, 777, 1929]]}
{"id": "msjcRV", "name": "little state experiment", "author": "oatmealine", "description": "i wanna turn this into something more sometime later. move grid w/ keyboard\n\nbottom pixel row is state itself", "tags": ["2d", "state"], "likes": 1, "viewed": 234, "published": 3, "date": "1687942366", "time_retrieved": "2024-07-30T17:46:59.988594", "image_code": "vec2 tileToPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = fragCoord.xy / iResolution.xy;\n  \n  vec2 uv = p;\n\n  uv -= 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= 1.1;\n  uv += 0.5;\n  \n  vec3 col = vec3(0.15, 0.15, 0.3);\n  \n  if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {\n    float x = floor(uv.x * float(getWidth()));\n    float y = floor(uv.y * float(getHeight()));\n    \n    for (int i = 1; i <= getTileCount(); i++) {\n      vec4 tile = texture(iChannel0, tileToPos(i));\n      if (eq(tile.x, x) && eq(tile.y, y)) {\n        col = vec3(tile.b);\n      }\n    }\n  \n    //col = vec3((x / 10.0 + y / 10.0) / 2.0);\n  }\n\n  fragColor = vec4(col, 1.0) + texture(iChannel0, p / iResolution.x * float(getTileCount() + 1)) / float(max(getWidth(), getHeight()));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 tileToPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\nint posToTile(vec2 xy) {\n  xy *= iChannelResolution[0].xy;\n  xy = floor(xy);\n  return int(xy.x + xy.y * iChannelResolution[0].x);\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  int tile = posToTile(uv);\n\n  // (x, y, id, moved [dir % 4 + amp * 4 || -1])\n  vec4 state = texture(iChannel0, uv);\n  // (isLoaded, ?, ?, ?)\n  vec4 boardState = texture(iChannel0, tileToPos(0));\n  \n  bool isLoaded = boardState.x == 1.0;\n  \n  if (tile == 0) {\n    // loaded = true\n    state.x = 1.0;\n\n    fragColor = state;\n  } else if (tile > 0 && tile <= getTileCount()) {\n    if (!isLoaded) {\n      state = vec4(float((tile - 1) % getWidth()), float((tile - 1) / getHeight()), hash12(fragCoord.xy), -1.0);\n    }\n    \n    bool moveLeft  = texelFetch(iChannel1, ivec2(KEY_LEFT,  1), 0).x > .5;\n    bool moveRight = texelFetch(iChannel1, ivec2(KEY_RIGHT, 1), 0).x > .5;\n    bool moveUp    = texelFetch(iChannel1, ivec2(KEY_UP,    1), 0).x > .5;\n    bool moveDown  = texelFetch(iChannel1, ivec2(KEY_DOWN,  1), 0).x > .5;\n    \n    if (moveLeft) {\n      state.x -= 1.;\n      state.x = mod(state.x, float(getWidth()));\n    }\n    if (moveRight) {\n      state.x += 1.;\n      state.x = mod(state.x, float(getWidth()));\n    }\n    if (moveUp) {\n      state.y += 1.;\n      state.y = mod(state.y, float(getHeight()));\n    }\n    if (moveDown) {\n      state.y -= 1.;\n      state.y = mod(state.y, float(getHeight()));\n    }\n    \n    fragColor = state;\n  } else {\n    discard;\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool eq(float a, float b) {\n  return abs(a - b) < 0.00001;\n}\n\nint getWidth() {\n  return 12;\n}\nint getHeight() {\n  return 12;\n}\n\nint getTileCount() {\n  return getWidth() * getHeight();\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 220], [222, 222, 277, 277, 1005]]}
{"id": "mdXyD7", "name": "Year of Truchets #044", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \nStair into the center of the vortex! ", "tags": ["2d", "warp", "truchet"], "likes": 15, "viewed": 241, "published": 3, "date": "1687916337", "time_retrieved": "2024-07-30T17:47:01.026819", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #044\n    06/27/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.141592653\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    mat2 r45 = rot(.785398);\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n \n    // upscale\n    float scale = .6365;\n\n    // warp and turn\n    uv *= rot(-T*.3);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*scale;\n    uv.x -= T*.7;\n    \n    vec2 vv = uv;\n\n    // background patterns\n    vec3  C = fract(6.*(vv.x+T*.6))<.5 ? vec3(.1,0,0):vec3(0,0,.075);\n\n    float px = fwidth(uv.x); \n    \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float hs = hash21(id.xy);\n\n    if(hs>.5) q = vec2(-q.y,q); \n    hs = fract(hs*575.913);\n    \n    float wd = .015, mv = .095;\n    vec2 q2 = q;\n\n    vec2 pq = length(q.xy-vec2(-.5,.5))<length(q.xy+vec2(-.5,.5))? q.xy-vec2(-.5,.5) : q.yx+vec2(-.5,.5);\n  \n    pq *= r45;\n    q2 *= r45;\n \n    // main pattern\n    float d = length(pq.x);\n    d=abs(d)-mv;\n    \n    // alt pattern\n    if(hs>.85) d = min(length(q2.x),length(q2.y))-mv;\n    \n    // posts\n    float b = length(abs(q)-.5)-(mv*1.75);\n    d = min(b,d);\n    d = max(d,-(b+.075));\n    float md = d;\n    \n    d=abs(d)-wd;\n    \n    // grid lines\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.01;\n    d2 = max(d2,-(b+.075));\n    vec3 clr = vec3(.4);\n\n    // color mixdown\n    if(M.z>0.) C = mix(C,vec3(.3),smoothstep(px,-px,d2));\n\n    C = mix(C,C*.35,smoothstep(.075+px,-px,d-.015));\n    C = mix(C,clr,smoothstep(px,-px,d));\n    C = mix(C,vec3(.0025),smoothstep(px,-px,md));\n\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXyD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[318, 318, 337, 337, 380], [381, 381, 403, 403, 461], [463, 463, 504, 504, 1936]]}
{"id": "Dd2cRK", "name": "Tapestry 7b", "author": "iterati", "description": "Slower and offset", "tags": ["ifs"], "likes": 4, "viewed": 165, "published": 3, "date": "1687915070", "time_retrieved": "2024-07-30T17:47:01.942371", "image_code": "vec4 getHex(vec2 p)\n{\n    vec2 s = vec2(1, ROOT_3);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nfloat sinT( float l )\n{\n    return (sin(((iTime * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( float l )\n{\n    return abs((mod(iTime / l, 1.) - 0.5) * 2.0);\n}\n\nfloat sawT( float l, float p )\n{\n    return abs((mod((iTime / l) + p, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( float l, float a, float b)\n{\n    return abs(cos((iTime / l) * a * 2. * PI) * cos((iTime / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 uv_ur = uv0;\n    uv_ur.x -= (iResolution.x / iResolution.y) * 0.5;\n    uv_ur.y -= 0.5;\n    \n    vec2 uv_ll = uv0;\n    uv_ll.x += (iResolution.x / iResolution.y) * 0.5;\n    uv_ll.y += 0.5;\n\n    // move origin to upper left\n    uv0.x += (iResolution.x / iResolution.y) * 0.5;\n    uv0.y -= 0.5;\n\n    // get hex grid\n    vec2 h0 = getHex(uv0 * 0.5).xy;\n    vec2 h = h0;\n\n    vec3 col = vec3(0.); \n    vec3 finalColor = vec3(0.0);\n\n    float d = 0.;\n\n    // grid scaling\n    float x = mix(0.7, 1., sawT(36.));               // 3,3,2,2\n    float y = mix(-0.2, 0.2, sawT(30.));             // 5,3,2\n    float z = mix(-0.25, 0.25, sawT(21.));           // 7,3\n\n    // shape props\n    int sides = 6;\n    float r = mix(1.1, 0.25, sawT(33.));             // 11,3\n\n    // color variation\n    float c = iTime / 65.;                           // 13,5\n    float l = mix(1., -1., sawT(29.));               // 29\n    float k = mix(-1., 1., ampT(17., 2., 3.));       // 17\n    float o = mix(1., -1., ampT(19., 2., 3.));       // 19\n\n    const float iterations = 5.;\n    for (float i = 0.0; i < iterations; i++) {\n        // scale grid\n        float xx = x + (y * (i / iterations)) + (exp(length(uv0 * z)) * 0.25);\n        h = getHex(xx * h * ROOT_3 * ROT).xy;\n\n        // phased shape change by layer\n        float mp = mix(0., 1., sawT(23.));           // 23\n        float m = mix(1., float(sides) - 1., sawT(21., mp * i / iterations)); // 7,3 \n\n        // get sdf value\n        d = sdStar(h, r / ROOT_3, sides, m);\n\n        // cutoff value (line width)\n        float stepv = 0.0025 * (i + 1.) * xx;\n        d = 1. - step(stepv, abs(d));\n        \n        // get color\n        col = palette(c + (l * (i / iterations)) + (k * length(uv_ur * 0.1)) + (o * length(uv_ll * 0.1)));\n        col *= d;\n        \n        // add to pixel accumulator\n        if (finalColor == vec3(0.)) {\n            finalColor += col;\n        }\n        //if (col != vec3(0.)) {\n        //    finalColor = col;\n        //}\n    }\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n#define ROOT_3 1.7320508\nconst mat2 ROT = mat2(cos(PI / 6.), sin(PI / 6.), -sin(PI / 6.), cos(PI / 6.));\n\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2cRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 273], [275, 275, 298, 298, 368], [370, 370, 393, 393, 445], [447, 447, 479, 479, 537], [539, 539, 579, 579, 674], [676, 676, 733, 733, 2828]]}
{"id": "msSyRG", "name": "goobabs", "author": "oatmealine", "description": "fun and games!!!!", "tags": ["2d", "metaball", "glaggle"], "likes": 16, "viewed": 226, "published": 3, "date": "1687902533", "time_retrieved": "2024-07-30T17:47:02.756195", "image_code": "#define RADIUS 0.11\n#define PI 3.14159\n\n// polynomial smooth min\nvec2 smin(float a, float b, float k) {\n    float h =  max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 sineLayer(float i, float seed, float time) {\n    vec2 mag = hash22(vec2(i, seed)) * 0.5;\n    vec2 speed = hash22(vec2(i, seed + 1.0));\n    vec2 offset = hash22(vec2(i, seed + 2.0));\n\n    return vec2(\n      sin(iTime * speed.x + offset.x * PI),\n      cos(iTime * speed.y + offset.y * PI)\n    ) * mag;\n}\n\nvec2 goobabPos(vec2 uv) {\n    float m = 9999.9;\n    float angle = 0.0;\n    \n    for (float i = 0.0; i < 10.0; i++) {\n        float var = 0.1;\n        vec2 pos = hash22(vec2(i, 0.0)) * var + (0.5 - var * 0.5);\n        \n        vec2 p = pos + sineLayer(i, 1.0, iTime) + sineLayer(i, 1.5, iTime) * 0.75 + sineLayer(i, 1.75, iTime) * 0.5 + sineLayer(i, 1.25, iTime) * 0.5;\n        \n        float dist = length(p - uv);\n        vec2 norm = normalize(p - uv);\n        float dotp = dot(norm, normalize(vec2(-1.0, -1.0)));\n        float ang = acos(dotp) / PI;\n        vec2 minres = smin(m, dist, 0.09);\n        m = minres.x;\n        angle = mix(angle, ang, minres.y);\n    }\n    \n    return vec2(m, angle);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float pix = 80.0;\n\n    uv.x -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = floor(uv * pix) / pix;\n    uv.x += 0.5;\n    \n    vec2 uvP = uv;\n    \n    uv += vec2(sin(iTime + uv.y * 3.0), sin(iTime + uv.x * 2.0)) * 0.02;\n    \n    vec2 goo = goobabPos((uv - 0.5) * 1.1 + 0.5);\n    float dist = goo.x;\n    float angle = goo.y;\n    \n    float width = 1. / pix * 0.5;\n    \n    float outline = abs(dist - RADIUS) <= width ? 1.0 : 0.0;\n    float shine = max(1.0 - length(vec2(0.0, 0.5) - vec2(angle, dist / RADIUS)), 0.0) > 0.8 ? 1.0 : 0.0;\n    float shade = angle < 0.4 ? 1.0 : 0.0;\n    float ray = 0.0;\n    \n    for (float i = 0.0; i < 15.0; i++) {\n        vec2 poses = hash22(vec2(i, 0.0));\n        vec2 speedOffset = hash22(vec2(i, 1.0));\n        vec2 scaleBri = hash22(vec2(i, 2.0));\n        \n        float a = fract((iTime) / (10.0 + speedOffset.x * 10.0) + speedOffset.y);\n        float mn = min(poses.x, poses.y);\n        float mx = max(poses.x, poses.y);\n        float x = mix(mn - 0.5, mx + 0.5, a) + sin(uv.y * 10.0 + iTime * 0.2 + scaleBri.y * 50.0) * 0.01;\n        float bri = (abs(uv.x - (x - (1.0 - uv.y) * 0.6)) < 0.05 ? 1.0 : 0.0) * (1.0 - (1.0 - uv.y) * (1.2 + scaleBri.x * 1.5));\n        ray += max(0.0, bri) * (1.0 - abs(2.0 * a - 1.0)) * (0.5 + scaleBri.y * 0.5);\n    }\n    \n    vec3 col = mix(vec3(0.1, 0.1, 0.2), outline * vec3(1.0, 1.0, 1.0) + (\n        vec3(0.2, 0.6, 0.2) +\n        shine * vec3(1.0) +\n        shade * vec3(0.3, 0.8, 0.3)\n    ) * (dist < RADIUS ? 1.0 : 0.0), dist <= (RADIUS + width) ? 1.0 : 0.0)\n      + ray * vec3(0.4, 0.6, 1.0);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 65, 103, 103, 248], [250, 250, 271, 271, 404], [406, 406, 455, 455, 712], [714, 714, 739, 739, 1413], [1415, 1415, 1470, 1470, 3133]]}
{"id": "csscD4", "name": "Voxel Terrain Minmax Traversal", "author": "gelami", "description": "Rendering voxel terrain using minmax mipmaps/quadtree displacement mapping\n\nMouse drag to look around", "tags": ["3d", "raytracing", "terrain", "voxel", "quadtree", "traversal", "minmax"], "likes": 106, "viewed": 2989, "published": 3, "date": "1687898592", "time_retrieved": "2024-07-30T17:47:03.783449", "image_code": "\n// Voxel Terrain Minmax Traversal - gelami\n// https://www.shadertoy.com/view/csscD4\n\n/* \n * Rendering voxel terrain using minmax mipmaps/quadtree displacement mapping\n * \n * Mouse drag to look around\n * \n * The heightmap and its mipmaps is each stored in a cubemap face,\n * which has a constant resolution of 1024x1024, unlike in my previous minmax shader\n * \n * Grass is rendered as a special intersection on the top block \n * \n * Clouds are only 2D, with a fake shadow to give it some shape and depth\n * \n * There is still more room to add to this, for example you could store\n * up to 4 heightmaps in 4 faces, and store its mipmaps in the remaining 2,\n * allowing you to make a 2048x2048 sized terrain, or use it to add more layers\n * \n * Like in this shader from kastorp:\n * Heightmap with Layers - kastorp\n * https://www.shadertoy.com/view/7l23Rc\n * \n * My previous minmax traversal shader:\n * Fast Minmax Terrain Traversal - gelami\n * https://www.shadertoy.com/view/msj3Dh\n * \n * I changed my fake AO to use voxel AO instead, from:\n * Voxel Ambient Occlusion - fb39ca4\n * https://www.shadertoy.com/view/ldl3DS\n * \n * Catmull-rom spline camera path based on: \n * Fractal Flythrough - Shane\n * https://www.shadertoy.com/view/4s3SRN\n * \n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-06-15 09:26:29\n\nfloat map(vec3 p)\n{\n    const float sc = SCALE;\n    float s = 1.0 / (float(getLodSize(MIN_LOD)) * sc);\n    \n    #if 1\n    float h = luminance(sRGBToLinear(textureLod(iChannel2, p.xz * sc, 1.0).rgb)) * MAX_HEIGHT;\n    \n    return p.y - h;\n    #else\n    vec4 data = SampleCubemapLod(iChannel0, fract(p.xz * sc), vec2(1024), 0);\n    \n    float h = (data.r - (data.a + data.g) * s) * MAX_HEIGHT;\n    \n    return p.y - h;\n    #endif\n}\n\nvec3 grad(vec3 p)\n{\n    vec2 e = vec2(0, 1.0 / 1024.0);\n    \n    return vec3(map(p - e.yxx) - map(p + e.yxx),\n                e.y,\n                map(p - e.xxy) - map(p + e.xxy)\n            ) / (e.y * 2.0);\n}\n\nfloat getVoxel(vec3 id) {\n    const float sc = SCALE;\n    \n    float s = 1.0 / (float(getLodSize(MIN_LOD)) * sc);\n    \n    vec3 p = (floor(id) + 0.5) * s;\n\tvec4 data = SampleCubemapLodNearest(iChannel0, fract(p.xz * sc), vec2(1024), 0);\n    \n    float h = data.r * MAX_HEIGHT;\n    \n    return float(p.y < h - (data.a == 1.0 ? s : 0.0));\n}\n\n// Voxel AO from:\n// Voxel Ambient Occlusion - fb39ca4\n// https://www.shadertoy.com/view/ldl3DS\nfloat vertexAo(vec2 side, float corner) {\n\t//if (side.x == 1.0 && side.y == 1.0) return 1.0;\n\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\n}\n\nvec4 voxelAo(vec3 pos, vec3 d1, vec3 d2) {\n\tvec4 side = vec4(getVoxel(pos + d1), getVoxel(pos + d2), getVoxel(pos - d1), getVoxel(pos - d2));\n\tvec4 corner = vec4(getVoxel(pos + d1 + d2), getVoxel(pos - d1 + d2), getVoxel(pos - d1 - d2), getVoxel(pos + d1 - d2));\n\tvec4 ao;\n\tao.x = vertexAo(side.xy, corner.x);\n\tao.y = vertexAo(side.yz, corner.y);\n\tao.z = vertexAo(side.zw, corner.z);\n\tao.w = vertexAo(side.wx, corner.w);\n\treturn 1.0 - ao;\n}\n\nvec2 asign(vec2 p)\n{\n    return vec2(\n        p.x >= 0.0 ? 1.0 : -1.0,\n        p.y >= 0.0 ? 1.0 : -1.0);\n}\n\nvec3 asign(vec3 p)\n{\n    return vec3(\n        p.x >= 0.0 ? 1.0 : -1.0,\n        p.y >= 0.0 ? 1.0 : -1.0,\n        p.z >= 0.0 ? 1.0 : -1.0);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 id;\n    int i;\n    int type;\n};\n\nbool intersectObject(vec3 ro, vec3 rd, vec2 id, float t, float h, float s, out HitInfo hit)\n{\n    vec3 sp = vec3(id.x, h - s * 0.5, id.y);\n    \n    float tP2 = -(ro.y - (h - s)) / rd.y;\n\n    #if 0\n    vec2 sph = sphereIntersection(ro - sp, rd, s * 0.5);\n\n    if (sph.x < MAX_DIST)\n    {\n        hit.t = sph.x;\n        hit.n = normalize(ro + rd * sph.x - sp);\n        hit.id = id;\n        hit.i = i;\n        hit.type = 1;\n        return true;\n    }\n    #else\n\n    float ang = hash12(id*12.0) * TAU;\n\n    vec3 gn0 = vec3(cos(ang), 0, sin(ang));\n    vec3 gn1 = vec3(-gn0.z, 0, gn0.x);\n    //const vec3 gn0 = vec3(sqrt(0.5), 0, sqrt(0.5));\n    //const vec3 gn1 = vec3(-sqrt(0.5), 0, sqrt(0.5));\n    \n    float pa = dot(rd, gn0);\n    float pb = -dot(ro - sp, gn0) / pa;\n\n    vec3 pp = ro + rd * pb;\n\n    vec2 puv = vec2(dot(pp - sp, gn1), pp.y - sp.y);\n\n    pb = pb > 0.0 && abs(puv.x) < s * 0.5 && abs(puv.y) < s * 0.5 ? pb : MAX_DIST;\n\n    float pa2 = dot(rd, gn1);\n    float pb2 = -dot(ro - sp, gn1) / pa2;\n\n    vec3 pp2 = ro + rd * pb2;\n\n    vec2 puv2 = vec2(dot(pp2 - sp, gn0), pp2.y - sp.y);\n\n    pb2 = pb2 > 0.0 && abs(puv2.x) < s * 0.5 && abs(puv2.y) < s * 0.5 ? pb2 : MAX_DIST;\n\n    vec3 pn = gn0;\n    if (pb2 < pb)\n    {\n        pb = pb2;\n        puv = puv2;\n        pn = gn1;\n        pa = pa2;\n    }\n\n    if (pb < MAX_DIST)\n    {\n        hit.t = pb;\n        hit.n = -pn * sign(pa);\n        hit.id = id;\n        //hit.i = i;\n        hit.type = 1;\n        return true;\n    }\n\n    #endif\n    else if (rd.y < 0.0 && tP2 > 0.0 && tP2 < t)\n    {\n        hit.t = tP2;\n        hit.n = vec3(0, 1, 0);\n        hit.id = id;\n        //hit.i = i;\n        return true;\n    }\n\n    return false;\n}\n\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, float tmin, float tmax)\n{\n    if ((rd.y > 0.0 && ro.y > MAX_HEIGHT) ||\n        (rd.y < 0.0 && ro.y < 0.0) || iFrame < MAX_LOD)\n        return false;\n    \n    hit.t = MAX_DIST;\n    hit.type = 0;\n    \n    ro = ro + rd * tmin;\n    vec3 pos = ro;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = asign(ird);\n    vec3 ard = abs(ird);\n    vec3 iro = pos * ird;\n    \n    const int minlod = MIN_LOD;\n    const float sc = SCALE;\n    \n    int lod = MAX_LOD;\n    float s = 1.0 / (float(getLodSize(lod)) * sc);\n    vec2 id = (floor(pos.xz / s) + 0.5) * s;\n    vec2 pid = id;\n    \n    float t = 0.0;\n    vec2 nrd = vec2(0);\n    int i = min(0, iFrame);\n    for (; i < STEPS; i++)\n    {\n        vec4 data = SampleCubemapLodNearest(iChannel0, fract(id * sc), vec2(1024), lod);\n        \n        float h = data.r * MAX_HEIGHT;\n        \n        vec2 p = id;\n        vec2 n = iro.xz - p * ird.xz;\n        vec2 k = ard.xz * s * 0.5;\n        \n        vec2 t0 = -n - k;\n        vec2 t1 = -n + k;\n        \n        float tF = min(t1.x, t1.y);\n        \n        if (pos.y < h)\n        {\n            if (lod == minlod)\n            {\n                if (lod == 0 && data.a == 1.0 && h - pos.y < s * MAX_HEIGHT)\n                {\n                    if (intersectObject(ro, rd, id, tF, h, s, hit))\n                    {\n                        hit.i = i;\n                        return true;\n                    }\n                    \n                } else\n                {\n                    hit.t = t;\n                    hit.n = vec3(-nrd, 0).xzy;\n                    hit.id = id;\n                    hit.i = i;\n                    return true;\n                }\n            } else\n            {\n                s *= 0.5;\n                lod--;\n                id += asign(pos.xz - id) * s * 0.5;\n                continue;\n            }\n        }\n        \n        float tP = -(ro.y - h) * ird.y;\n        \n        pos = ro + rd * tF;\n        \n        if (pos.y < h)\n        {\n            if (lod == minlod)\n            {\n                if (lod == 0 && data.a == 1.0)\n                {\n                    if (intersectObject(ro, rd, id, tF, h, s, hit))\n                    {\n                        hit.i = i;\n                        return true;\n                    }\n                } else\n                {\n                    hit.t = tP;\n                    hit.n = vec3(0, 1, 0);\n                    hit.id = id;\n                    hit.i = i;\n                    return true;\n                }\n            } else\n            {\n                pos = ro + rd * (-(ro.y - h) * ird.y - EPS);\n                s *= 0.5;\n                lod--;\n                id += asign(pos.xz - id) * s * 0.5;\n                continue;\n            }\n        }\n        \n        if (tF + tmin > tmax ||\n           (rd.y > 0.0 && pos.y > MAX_HEIGHT) ||\n           (rd.y < 0.0 && pos.y < 0.0))\n            return false;\n        \n        t = tF;\n        nrd = t1.x <= t1.y ? vec2(srd.x, 0) : vec2(0, srd.z);\n        pid = id;\n        id += nrd * s;\n        \n        vec2 iid = id / s;\n        vec2 ipid = pid / s;\n        if (floor(iid*0.5) != floor(ipid*0.5) && lod < MAX_LOD)\n        {\n            s *= 2.0;\n            id = (floor(iid*0.5) + 0.5) * s;\n            pid = id;\n            lod++;\n        }\n    }\n    \n    return false;\n}\n\nvec3 shade()\n{\n    vec3 col = vec3(0);\n\n    return col;\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel3,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nconst mat2 rot = mat2(0.866, 0.5, -0.5, 0.866) * 2.0;\n\nfloat getClouds(vec2 p, const float a, const float b)\n{\n    #if 0\n    float d = texture(iChannel3, p).r*0.5; p *= rot;\n    d += texture(iChannel3, p).r*0.25*0.9; p *= rot;\n    d += texture(iChannel3, p).r*0.125*0.7; p *= rot;\n    d += texture(iChannel3, p).r*0.0625*0.5; p *= rot;\n    #else\n    vec3 q = vec3(p * 256.0, iTime*0.05);\n    float d = noise(q)*0.5; q.xy *= rot;\n    d += noise(q)*0.25*0.9; q.xy *= rot;\n    d += noise(q)*0.125*0.7; q.xy *= rot;\n    d += noise(q)*0.0625*0.5; q.xy *= rot;\n    #endif\n    d = smoothstep(a, b, d);\n    \n    return d;\n}\n\n\n#define CAM_PATH_LENGTH 30\n\nconst vec3[CAM_PATH_LENGTH] CAM_PATH = vec3[](\n    vec3(0.08/SCALE, 0.28, 0.52/SCALE),\n    vec3(0.105/SCALE, 0.15, 0.58/SCALE),\n    vec3(0.1/SCALE, 0.2, 0.64/SCALE),\n    vec3(0.1/SCALE, 0.25, 0.7/SCALE),\n    vec3(0.16/SCALE, 0.15, 0.73/SCALE),\n    vec3(0.21/SCALE, 0.1, 0.71/SCALE),\n    vec3(0.25/SCALE, 0.15, 0.67/SCALE),\n    vec3(0.31/SCALE, 0.2, 0.64/SCALE),\n    vec3(0.35/SCALE, 0.28, 0.61/SCALE),\n    vec3(0.39/SCALE, 0.3, 0.58/SCALE),\n    vec3(0.40/SCALE, 0.25, 0.54/SCALE),\n    vec3(0.42/SCALE, 0.28, 0.5/SCALE),\n    vec3(0.46/SCALE, 0.26, 0.47/SCALE),\n    vec3(0.5/SCALE, 0.2, 0.45/SCALE),\n    vec3(0.54/SCALE, 0.15, 0.43/SCALE),\n    vec3(0.59/SCALE, 0.25, 0.39/SCALE),\n    vec3(0.605/SCALE, 0.32, 0.34/SCALE),\n    vec3(0.58/SCALE, 0.30, 0.31/SCALE),\n    vec3(0.53/SCALE, 0.38, 0.29/SCALE),\n    vec3(0.49/SCALE, 0.42, 0.3/SCALE),\n    vec3(0.44/SCALE, 0.45, 0.31/SCALE),\n    vec3(0.39/SCALE, 0.48, 0.28/SCALE),\n    vec3(0.35/SCALE, 0.52, 0.25/SCALE),\n    vec3(0.29/SCALE, 0.58, 0.23/SCALE),\n    vec3(0.21/SCALE, 0.5, 0.28/SCALE),\n    vec3(0.18/SCALE, 0.3, 0.30/SCALE),\n    vec3(0.14/SCALE, 0.2, 0.32/SCALE),\n    vec3(0.11/SCALE, 0.12, 0.36/SCALE),\n    vec3(0.08/SCALE, 0.22, 0.4/SCALE),\n    vec3(0.07/SCALE, 0.28, 0.46/SCALE)\n);\n\nvec3 CatmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n    return p1 + 0.5 * t * (-p0 + p2 + t * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3 + t * (-p0 + 3.0 * p1- 3.0 * p2 + p3)));\n}\n\nvec3 getCamPath(float t)\n{\n    t = mod(t, float(CAM_PATH_LENGTH));\n    \n    int i = int(floor(t));\n    float f = fract(t);\n        \n    int i0 = (i - 1 + CAM_PATH_LENGTH) % CAM_PATH_LENGTH;\n    int i2 = (i + 1) % CAM_PATH_LENGTH;\n    int i3 = (i + 2) % CAM_PATH_LENGTH;\n    \n    return CatmullRomSpline(CAM_PATH[i0], CAM_PATH[i], CAM_PATH[i2], CAM_PATH[i3], f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    \n    #if SSAA > 0\n    for (int x = 0; x <= SSAA; x++)\n    {\n        for (int y = 0; y <= SSAA; y++)\n        {\n    vec2 o = (vec2(x, y) + 0.5) / float(SSAA+1);\n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    #else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    #endif\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax, ay;\n    \n    #ifdef TURNTABLE_CAM\n    vec3 ro = vec3(0, 0, 0.6);\n    vec3 lo = vec3(1.6, 0.1, 2.3);\n    \n    #ifdef STATIC_CAM\n    ax = -0.15 * TAU + PI;\n    ay = -0.46 * TAU + PI;\n    #else\n    if (iMouse.z > 0.0)\n    {\n        ax = -m.x * TAU + PI;\n        ay = -m.y * PI + PI * 0.5;\n    } else\n    {\n        ax = -PI * .7 + iTime * .15;\n        ay = PI * 0.15;\n    }\n    #endif\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    #else\n    float ct = iTime * 0.4;\n    vec3 ro = getCamPath(ct);\n    vec3 lo = getCamPath(ct + 0.2);\n    if (iMouse.z > 0.0)\n    {\n        lo = vec3(0, 0, 1);\n        ax = -m.x * TAU + PI;\n        ay = -m.y * PI + PI * 0.5;\n        \n        lo.yz *= rot2D(-ay);\n        lo.xz *= rot2D(ax);\n        lo += ro; \n    }\n    #endif\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    const float invTanFov = 1.25;\n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n    \n    vec3 col = vec3(0);\n    \n    float pt = 0.0;\n    if (rd.y < 0.0 && ro.y > MAX_HEIGHT)\n    {\n        pt = -(ro.y - MAX_HEIGHT) / rd.y - EPS;\n    }\n    \n    HitInfo hit;\n    bool isHit = trace(ro, rd, hit, pt, MAX_DIST);\n    \n    float t = hit.t + pt;\n    \n    vec3 pos = ro + rd * t;\n    \n    const float sc = SCALE;\n    float s = 1.0 / (float(getLodSize(MIN_LOD)) * sc);\n    \n    vec3 p = (pos - hit.n * EPS) / s;\n    vec3 vid = floor(p);\n    \n    vec3 id = vec3(hit.id, 0).xzy;\n    id.y = floor((pos.y + rd.y * EPS) / MAX_HEIGHT * 1024.0 * SCALE) / (1024.0 * SCALE);\n    \n    vec3 alb = vec3(texture(iChannel0, cubeUVToPos(fract(hit.id * SCALE), 0)).rgb);\n    \n    float k = texture(iChannel1, id.xz * 0.02).r;\n    k = smoothstep(0.05, 0.2, k * k);\n    \n    alb = mix(vec3(0.95,0.4,0.25)*0.4, vec3(0.95, 0.4, 0.3), 1.0 - k);\n    //alb *= hash12(hit.id*3232.0)*0.2+0.8;\n    \n    vec3 gn = normalize(grad(id));\n    \n    float ky = id.y + (textureLod(iChannel3, id.xz * 0.0006, 0.0).r - 0.5) * 0.002;\n    float k1 = smoothstep(0.0,0.5,hash11(ky * 4.3+1.0));\n    float k2 = smoothstep(0.2,0.15,hash11(ky * 8.0+1.0));\n    alb *= k1 * vec3(0.7, 0.6, 0.5) + 0.35;\n    \n    alb = mix(alb, vec3(1, 0.7, 0.6), k2 * 0.8);\n    \n    vec3 tcol = (0.4+0.6*texture(iChannel1, id.xz * 0.4).rgb) * vec3(0.9, 0.55, 0.2);\n    float tk = smoothstep(0.6, 0.9, gn.y);\n    alb = mix(alb, alb * vec3(1, 0.6, 0.3), tk);\n    tk *= smoothstep(0.2, 0.0, id.y);\n    tk *= smoothstep(0.1, 0.2, texture(iChannel1, -id.xz * 0.02).r);\n    alb = mix(alb, tcol, tk);\n    \n    alb *= 1.0-texture(iChannel1, -id.xz * 0.3).rgb * 0.8;\n    \n    col = alb;\n    \n    vec4 data = SampleCubemapLodNearest(iChannel0, fract(hit.id * sc), vec2(1024), 0);\n    \n    if (data.a > 1.0 && (vid.y + 1.0) * s > (data.r - data.a * s) * MAX_HEIGHT)\n    {\n        col = (col*0.6+0.4)*vec3(0.4, 0.5, 0.15) + col * 0.1;\n        col *= hash13(vid) * 0.3 + 0.7;\n    }\n    \n    vec3 ldir = normalize(vec3(1, 1.2, 0.8));\n    vec3 lcol = vec3(1, 0.8, 0.6) * 2.5;\n    vec3 skyCol = vec3(0.6, 0.85, 1) + smoothstep(0.2, 0.0, abs(rd.y)) * vec3(0.35,0.4,0.5);\n    vec3 skyCol2 = vec3(0.35,0.62,0.9);\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + hit.n * 1e-6, ldir, hitL, 0.0, MAX_DIST);\n    \n    float sha = float(!isHitL);\n    \n    if (hitL.type == 1)\n        sha = sha * 0.8 + 0.2;\n    \n    float dif = max(dot(hit.n, ldir), 0.0) * sha;\n    float hao = smoothstep(0.0, MAX_HEIGHT * 0.3, pos.y);\n    \n    if (hit.type == 1)\n    {\n        col = mix(col, (col*0.6+0.4)*vec3(0.8, 0.9, 0.2), 0.3);\n        //dif += 0.2 * max(-dot(hit.n, ldir), 0.0) * sha;\n        dif = (max(dot(hit.n, ldir), 0.0) + 0.6*max(-dot(hit.n, ldir), 0.0)) * (sha * 0.4+0.6);\n    }\n    \n    col *= lcol * (dif * 0.7 + 0.3);\n    \n    float ao = 1.0;\n    if (hit.type == 0)\n    {\n        vec3 mask = abs(hit.n);\n        vec2 vuv = mod(vec2(dot(mask * p.yzx, vec3(1.0)), dot(mask * p.zxy, vec3(1.0))), vec2(1.0));\n\n        vec4 vao = voxelAo(vid + hit.n, mask.zxy, mask.yzx);\n        ao = mix(mix(vao.z, vao.w, vuv.x), mix(vao.y, vao.x, vuv.x), vuv.y);\n\n        col *= dot(abs(hit.n), vec3(0.9, 1, 0.95));\n    \n        col *= ao * 0.6 + 0.4;\n    }\n    \n    col += skyCol * 0.1;\n    \n    if (hit.type == 1)\n    {\n        //col += alb * lcol * (dot(hit.n, ldir)*0.5+0.5) * 0.2;\n    }\n    \n    col *= hao * 0.4 + 0.6;\n    \n    float cost = dot(rd, ldir);\n    //float fog = 1.0 - exp(-t*t * 0.001);\n    float fog = 1.0 - exp(-t * 0.04);\n    float hg = mix(henyeyGreenstein(cost, 0.65), henyeyGreenstein(cost, -0.3), 0.45);\n    \n    vec3 fogCol = skyCol * hg;\n    col = mix(col, fogCol, fog);\n    \n    vec3 ref = reflect(rd, hit.n);\n    \n    HitInfo hitR;\n    bool isHitR = trace(pos + hit.n * EPS, ref, hitR, 0.0, MAX_DIST);\n    \n    #ifdef SHOW_NORMALS\n    col = hit.n;\n    #endif\n    \n    if (!isHit)\n    {\n        col = mix(skyCol, skyCol2, smoothstep(0.0, 0.4, rd.y));\n        \n        #define SUN_ANGLE_DEGREES 0.52\n        const float sunAngle = SUN_ANGLE_DEGREES * PI / 180.0;\n        const float sunCost = cos(sunAngle);\n\n        float cost = max(dot(rd, ldir), 0.0);\n        float dist = cost - sunCost;\n\n        float bloom = max(1.0 / (0.02 - min(dist, 0.0)*400.0), 0.0) * 0.08;\n\n        vec3 sun = 20.0 * lcol * (smoothstep(0.0, 0.0001, dist) + bloom);\n        \n        col += sun;\n        \n        vec2 clsph = sphereIntersection(vec3(0, 0.46, 0), rd, 0.5);\n        \n        vec3 clpos = rd * clsph.y;\n        vec2 cluv = (clpos.xz + iTime * 0.0015) * 0.3;\n        cluv += (texture(iChannel3, cluv * 10.0 + iTime * 0.003).rg - 0.5) * 0.0004;\n        float cld = getClouds(cluv, 0.35, 0.6);\n        float clsh = getClouds(cluv + (ldir.xz - rd.xz) * 0.0008, 0.35, 0.65);\n        \n        vec3 ccol = (max(cld - clsh, 0.0) * lcol * 0.6 + skyCol * 0.5 + 0.35) * hg ;\n        \n        col = mix(col, ccol, (1.0 - exp(-cld)) * smoothstep(0.0, 0.02, rd.y));\n        \n        vec3 fp = (rd - ldir) * cmat;\n        vec3 cldir = ldir * cmat;\n        vec2 cuv = cldir.xy / cldir.z * invTanFov;\n        vec2 fuv = pv - cuv;\n        float fd = length(fuv * vec2(30, 1));\n        fd = min(fd, length(rot2D(PI/3.0) * fuv * vec2(30, 1)));\n        fd = min(fd, length(rot2D(-PI/3.0) * fuv * vec2(30, 1)));\n        \n        vec3 flare = 0.2 * lcol * smoothstep(1.0, 0.0, fd);//max(1.0 / max(fd, 0.00), 0.0) * 0.05;\n        \n        col += flare;\n    }\n    \n    #ifdef SHOW_STEPS\n    col = turbo(float(hit.i) / float(STEPS));\n    \n    if (fragCoord.y < 10.0)\n        col = turbo(uv.x);\n    #endif\n    \n    //vec2 luv = fragCoord / iResolution.y;\n    //int lod = (iFrame/20)%(1+MAX_LOD);\n    //col = luv.x > 1.0 ? vec3(0) : vec3(SampleCubemapLodNearest(iChannel0, luv, vec2(1024), lod).r);\n    \n    //col = texture(iChannel0, cubeUVToPos(fragCoord / iResolution.y, 1)).rgb;\n    \n    col = max(col, vec3(0));\n    \n    #if SSAA > 0\n        tot += col;\n        }\n    }\n    tot /= float((SSAA+1)*(SSAA+1));\n    #else\n    tot = col;\n    #endif\n    \n    //tot = tot / (1.0 + tot);\n    //tot = ReinhardExtLuma(tot, 5.0);\n    tot = ACESFilm(tot * 0.35);\n    \n    fragColor = vec4(linearTosRGB(tot), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SSAA 0\n\n//#define TURNTABLE_CAM\n//#define STATIC_CAM\n//#define SHOW_STEPS\n//#define SHOW_NORMALS\n\n//#define SCALE 0.125\n#define SCALE 0.1\n//#define SCALE 0.0625\n\n#define MIN_LOD 0\n#define MAX_LOD 8\n\n#define MAX_HEIGHT 1.0\n\n#define STEPS 256\n#define MAX_DIST 200.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n\nfloat henyeyGreenstein(float cosTheta, float g)\n{\n    //const float k = 1.0 / (4.0 * PI);\n    float g2 = g * g;\n    \n    return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * cosTheta, 3.0 / 2.0);\n}\n\n// Ray-sphere intersesction\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereIntersection(vec3 ro, vec3 rd, float ra )\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    if (b > 0.0 && c > 0.0)\n        return vec2(MAX_DIST);\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Cubemap helper functions\n// https://en.wikipedia.org/wiki/Cube_mapping#Memory_addressing\n\n// Cubemap ID as per OpenGL indices\nint cubeID(vec3 normal)\n{\n    return int(dot(max(-normal, vec3(0)), vec3(1)) + dot(abs(normal), vec3(0, 2, 4)));\n}\n\nvec2 cubeNearest(vec2 uv, float res)\n{\n    return (floor(uv * res) + 0.5) / res;\n}\n\n// OpenGL face orientation from\n// https://www.khronos.org/opengl/wiki/Cubemap_Texture\nvec2 cubePosToUV(vec3 pos, vec3 normal)\n{\n    pos = pos + 0.5;\n\n    vec3 mask = abs(normal);\n    vec2 uv = mask.x > 0. ? vec2(-pos.z * normal.x, -pos.y) :\n              mask.y > 0. ? vec2( pos.x,  pos.z * normal.y) :\n                            vec2( pos.x * normal.z, -pos.y);\n    \n    uv = fract(uv);\n   \n    return uv;\n}\n\nvec2 cubePosToUV(vec3 pos, int id)\n{   \n    pos = pos + 0.5;\n\n    vec2 uv;\n    switch(id)\n    {\n        case 0:\n            uv = vec2(-pos.z, -pos.y); break;\n        case 1:\n            uv = vec2( pos.z, -pos.y); break;\n        case 2:\n            uv = vec2( pos.x,  pos.z); break;\n        case 3:\n            uv = vec2( pos.x, -pos.z); break;\n        case 4:\n            uv = vec2( pos.x, -pos.y); break;\n        case 5:\n            uv = vec2(-pos.x, -pos.y); break;\n    }\n    \n    uv = fract(uv);\n\n    return uv;\n}\n\n// Based on Shane's cubemap texture function\n// Geometric Cellular Surfaces - Shane\n// https://www.shadertoy.com/view/Wt33zH\n\n// Modified to match OpenGL face orientation\n// https://www.khronos.org/opengl/wiki/Cubemap_Texture\nvec3 cubeUVToPos(vec2 uv, int id)\n{\n    uv = fract(uv) - .5;\n    \n    \n    switch(id)\n    {\n        case 0:\n            return vec3(0.5, -uv.yx);\n        case 1:\n            return vec3(-0.5, -uv.y, uv.x);\n        case 2:\n            return vec3(uv.x, 0.5, uv.y);\n        case 3:\n            return vec3(uv.x, -0.5, -uv.y);\n        case 4:\n            return vec3(uv.x, -uv.y, 0.5);\n        case 5:\n            return vec3(-uv, -0.5);\n    }\n    \n    return vec3(0);\n}\n\nvec3 cubeIntersect(vec3 rayDir, out vec3 normal)\n{\n    vec3 sideDist = abs(0.5 / rayDir);\n    \n    float t = min(sideDist.x, min(sideDist.y, sideDist.z));\n    vec3 mask = step(sideDist, sideDist.yzx) * step(sideDist, sideDist.zxy);\n    \n    normal = mask * sign(rayDir);\n    \n    return rayDir * t;\n}\n\nconst int[] LOD_TEX_START = int[](0, 512, 768, 896, 960, 992, 1008, 1016, 1020, 1022);\nconst int[] LOD_TEX_END = int[](512, 768, 896, 960, 992, 1008, 1016, 1020, 1022, 1023);\n\nint getLodSize(int lod)\n{\n    return 1024>>lod;\n}\n\nvec4 SampleCubemapLod(samplerCube tex, vec2 uv, vec2 res, int lod)\n{\n    if (lod <= 0)\n    {\n        return texture(tex, cubeUVToPos(uv, 0));\n    }\n    \n    vec2 size = vec2(getLodSize(lod));\n    vec2 offset = vec2(LOD_TEX_START[lod-1], 0);\n    \n    return texture(tex, cubeUVToPos((uv * size + offset) / res, 1));\n}\n\nvec4 SampleCubemapLodNearest(samplerCube tex, vec2 uv, vec2 res, int lod)\n{\n    if (lod <= 0)\n    {\n        uv = (floor(uv * res) + 0.5) / res;\n        return texture(tex, cubeUVToPos(uv, 0));\n    }\n    \n    vec2 size = vec2(getLodSize(lod));\n    vec2 offset = vec2(LOD_TEX_START[lod-1], 0);\n    \n    uv = floor(uv * size) + 0.5;\n    return texture(tex, cubeUVToPos((uv + offset) / res, 1));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// matplotlib colormaps + turbo - mattz\n// https://www.shadertoy.com/view/3lBXR3\nvec3 turbo(float t) {\n\n    const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n    const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n    const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n    const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n    const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n    const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n    const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n", "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    // Doesn't do anything on my maching T_T\n    #if 0\n    if (iFrame > MAX_LOD)\n    {\n        fragColor = texture(iChannel0, rayDir);\n        return;\n    }\n    #endif\n    \n    vec3 n;\n    vec3 pos = cubeIntersect(rayDir, n);\n    int id = cubeID(n);\n    \n    if (id == 0)\n    {\n        fragColor = vec4(0);\n        \n        vec2 fl = floor(fragCoord / 4.0);\n        \n        vec3 tex = sRGBToLinear(texture(iChannel1, uv).rgb);\n        \n        float h = luminance(tex);\n        float ha = h;\n        h = floor(h * 1024.0 * SCALE);\n        \n        if (hash12(fragCoord) < 0.08 * smoothstep(0.25, 0.0, ha))\n        {\n            fragColor.a = 1.0;\n            h++;\n        } else if (hash12(-fragCoord.yx) < 0.0035 * smoothstep(0.1, 0.0, ha))\n        {\n            fragColor.a = floor(hash12(fragCoord.yx) * 4.0) + 2.0;\n            h += fragColor.a;\n        }\n        \n        h /= (1024.0 * SCALE);\n        \n        fragColor.r = saturate(h);\n        \n    } else if (id == 1)\n    {\n        fragColor = vec4(0);\n        \n        vec4 prev = textureLod(iChannel0, cubeUVToPos(uv, 0), 1.0);\n        vec2 hres = floor(iResolution.xy / 2.0);\n        \n        int lod = 0;\n        for(; lod <= MAX_LOD; lod++)\n        {\n            if (fragCoord.x < float(LOD_TEX_END[lod]))\n                break;\n        }\n        lod += 1;\n        \n        vec2 res = vec2(getLodSize(lod));\n        float xpos = float(LOD_TEX_START[lod-1]);\n        \n        if (lod > MAX_LOD || fragCoord.y >= res.y)\n        {\n            fragColor = vec4(0);\n            return;\n        }\n\n        vec2 p = (fragCoord - vec2(xpos, 0)) / iResolution.xy;\n        vec2 uv = (fragCoord - vec2(xpos, 0)) / vec2(res);\n        \n        vec2 res2 = vec2(getLodSize(lod-1));\n        vec2 px2 = 1.0 / res2;\n        vec2 uv2 = ((uv * res2) + 0.5) / res2;\n        \n        vec4 tex00 = SampleCubemapLodNearest(iChannel0, uv2, iResolution.xy, lod-1);\n        vec4 tex10 = SampleCubemapLodNearest(iChannel0, uv2 - vec2(px2.x, 0), iResolution.xy, lod-1);\n        vec4 tex01 = SampleCubemapLodNearest(iChannel0, uv2 - vec2(0, px2.y), iResolution.xy, lod-1);\n        vec4 tex11 = SampleCubemapLodNearest(iChannel0, uv2 - px2, iResolution.xy, lod-1);\n        \n        fragColor.r = max(max(tex00.x, tex10.x), max(tex01.x, tex11.x));\n        \n    } else\n    {\n        fragColor = vec4(0);\n    }\n}", "cube_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csscD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1787, 1787, 1806, 1806, 1996], [2338, 2434, 2475, 2526, 2592], [2594, 2594, 2636, 2636, 3034], [3036, 3036, 3056, 3056, 3142], [3144, 3144, 3164, 3164, 3283], [8395, 8395, 8409, 8409, 8452], [8454, 8454, 8475, 8475, 8691], [8748, 8748, 8803, 8803, 9308], [10576, 10576, 10644, 10644, 10766], [10768, 10768, 10794, 10794, 11131]]}
{"id": "ddBczW", "name": "Test julia set", "author": "Elyades", "description": "Julia set test", "tags": ["juliaset"], "likes": 2, "viewed": 138, "published": 3, "date": "1687897670", "time_retrieved": "2024-07-30T17:47:04.803720", "image_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\n\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan2(uv.y,uv.x)));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 power2d(vec2 uv, vec2 z)\n{\n    \n    return( exp2d(times(vec2(log(length(uv)),atan2(uv.y,uv.x)),z) ) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return(vec2(0.5*( exp2d(times(uv,vec2(0.0,1.0))) + exp2d(times(-uv,vec2(0.0,1.0))))));\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    return(times(0.5*( exp2d(times(uv,vec2(0.0,1.0))) - exp2d(times(-uv,vec2(0.0,1.0)))),vec2(0.0,1.0)));\n}\n\nvec2 function(vec2 uv,vec2 c)\n{    \n    vec2 result = tan(atan2(uv.y,uv.x))+c;\n    return result;\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette5(float iteration)\n{\n    float value = 0.8;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.0,0.0);\n    \n    return (a + b*cos(TWOPI*(c*iteration + d)));\n}\n\nvec2 functionPolar(vec2 uv)\n{\n    float n = 3.0;\n    vec2 c = vec2(0.1,-0.8);\n    vec2 result;\n    result.x = pow(uv.x,n);\n    result.y = n*uv.y;\n    return result;\n}\n\nvec2 cartesianToPolar(vec2 uv)\n{\n    float r = length(uv);\n    float theta = atan(uv.y,uv.x);\n    return vec2(r,theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //Offset\n    uv = uv - 0.5;\n    uv.x += 0.0;\n    \n    //Scale\n    uv *= 10.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //Choosing the Zoom\n    vec2 zoomPoint = vec2(-0.0,0.0);\n    \n    //Zoom\n    float zoomAmount = min(1.0,1.0/pow(max(iTime-3.0,1.0),3.0));\n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    // Algorithm to color the pixel\n    float tol = pow(10.0,-6.0);\n    \n    \n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    //vec2 c = 3.0*(iMouse.xy/iResolution.xy - 0.5);\n    vec2 c = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = uv;\n        uv = function(uv,c);\n        currentModulus = length(uv);\n        DistanceToPrevious = length(uv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 3.0){break;}\n    }\n    \n    \n    \n    if(currentModulus < 3.0)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    else\n    {\n            iterationAmount *= 5;\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette5(indexFast);\n            \n            int periodMedium = 20;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette5(indexMedium);\n            \n            int periodSlow = 50;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette5(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 194, 226, 312], [314, 314, 335, 335, 387], [391, 391, 412, 412, 466], [468, 468, 498, 498, 651], [653, 653, 684, 684, 750], [752, 752, 776, 776, 875], [877, 877, 908, 908, 986], [988, 988, 1009, 1009, 1102], [1105, 1105, 1126, 1126, 1234], [1236, 1236, 1267, 1267, 1335], [1337, 1337, 1363, 1385, 1571], [1573, 1573, 1605, 1605, 1804], [1806, 1806, 1835, 1835, 1972], [1974, 1974, 2006, 2006, 2095], [2097, 2097, 2154, 2205, 4287]]}
{"id": "DdScRV", "name": "Across the Spider-Verse", "author": "z0rg", "description": "I saw spiderman this week end :)", "tags": ["2d", "tunnel", "warp", "spiderman", "spiderverse"], "likes": 47, "viewed": 1018, "published": 3, "date": "1687885121", "time_retrieved": "2024-07-30T17:47:05.691348", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define N 96\n// Thanks IQ :)\n// Polygon - exact   (https://www.shadertoy.com/view/wdBXRW)\nfloat sdPolygon( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\nvec3 flare(vec2 uv)\n{\n    return vec3(0.424,0.596,0.996)*(1.-sat(lenny(uv*vec2(1.,4.))))*2.;\n}\nvec3 chromaflare(vec2 uv)\n{\n    vec2 off = vec2(0.05);\n    \n    vec3 col = vec3(0.);\n    col.x += flare(uv+off).x;\n    col.y += flare(uv).y;\n    col.z += flare(uv-off).z;\n    return col;\n}\nvec3 rdr(vec2 uv)\n{\n    vec2 ouv = uv;\n    vec3 col = vec3(0.);\n    float basean = atan(uv.y, uv.x);\n    float cnt = 6.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n        float sides = PI*2./cnt;\n        float an = basean+i*2.+iTime*.05*mix(1.,1.5,i/cnt);\n        float sectors = mod(an+sides*.5,sides)-sides*.5;\n        vec2 newuv = vec2(sin(sectors), cos(sectors))*length(uv);\n    \n        vec2 curuv = newuv+sin(i+iTime*.2)*.05;\n        float sz = mix(0.05,0.4, pow(i/cnt,2.)+sin(i+iTime)*.04);\n        float shape = abs(curuv.y-sz)-mix(0.01, 0.03, i/cnt);\n        vec3 rgb = texture(iChannel0, curuv*7.).xyz*mix(0.2, 1.,pow(i/cnt, .5));\n        vec3 outrgb = rgb *(1.-sat(shape*500.));\n        outrgb += rgb *(1.-sat(shape*20.))*.35;\n        outrgb = mix(outrgb*vec3(1.,.3,.3)*.5, outrgb, pow(i/cnt,2.));\n        col += outrgb;\n        \n        float shape2 = abs(curuv.y-sz-.1)-mix(0.01, 0.03, i/cnt)*.1;\n        col += vec3(1.000,0.000,0.349)*(1.-sat(shape2*100.))*sat(sin(curuv.x*100.)*.5+.5);\n    }\n    \n    col += chromaflare(uv)*.8;\n    col += pow(texture(iChannel1, vec2(basean, +iTime*.03+1./length(uv)*.02)).x, 5.)\n    *vec3(1.000,0.533,0.220)*sat(length(uv)*2.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    uv *= r2d(sin(iTime*.2)*.2);\n    uv *= mix(1.2,1., sin(iTime)*.5+.5);\n    uv += vec2(sin(iTime*.33), cos(iTime*.14))*.05;\n    vec3 col = rdr(uv);\n    col += sat(sin(uv.y*800.)*.5+.5)*vec3(0.,0.,1.)\n    *texture(iChannel1, uv*.1).x;\n\n// This was generated with a homemade unity solution\nvec2 points[96];\npoints[0] = vec2(0.07991514, 0.6348686);\npoints[1] = vec2(0.09641513, 0.6812686);\npoints[2] = vec2(0.1307151, 0.6464686);\npoints[3] = vec2(0.1583152, 0.5911686);\npoints[4] = vec2(0.1826151, 0.5790686);\npoints[5] = vec2(0.3704152, 0.7149686);\npoints[6] = vec2(0.4047152, 0.6834686);\npoints[7] = vec2(0.4323151, 0.6630686);\npoints[8] = vec2(0.4787152, 0.6155686);\npoints[9] = vec2(0.4980151, 0.6072686);\npoints[10] = vec2(0.5272151, 0.6442686);\npoints[11] = vec2(0.5205151, 0.6559686);\npoints[12] = vec2(0.5032151, 0.6677686);\npoints[13] = vec2(0.4838151, 0.6904686);\npoints[14] = vec2(0.4563152, 0.7153686);\npoints[15] = vec2(0.4331152, 0.7304686);\npoints[16] = vec2(0.4336151, 0.7369686);\npoints[17] = vec2(0.4428152, 0.7374686);\npoints[18] = vec2(0.4341151, 0.7477686);\npoints[19] = vec2(0.4422151, 0.7499686);\npoints[20] = vec2(0.4568152, 0.7289686);\npoints[21] = vec2(0.5232152, 0.6819686);\npoints[22] = vec2(0.5581151, 0.6800686);\npoints[23] = vec2(0.6139151, 0.6791686);\npoints[24] = vec2(0.6362152, 0.6824686);\npoints[25] = vec2(0.6400151, 0.7090686);\npoints[26] = vec2(0.6488152, 0.7315686);\npoints[27] = vec2(0.6641151, 0.7491686);\npoints[28] = vec2(0.6927152, 0.7535686);\npoints[29] = vec2(0.7133151, 0.7368686);\npoints[30] = vec2(0.7185152, 0.7181686);\npoints[31] = vec2(0.7108151, 0.7005686);\npoints[32] = vec2(0.7003151, 0.6865686);\npoints[33] = vec2(0.6956152, 0.6818686);\npoints[34] = vec2(0.7272152, 0.6703686);\npoints[35] = vec2(0.7440152, 0.6698686);\npoints[36] = vec2(0.7586151, 0.6709686);\npoints[37] = vec2(0.7721151, 0.6867686);\npoints[38] = vec2(0.8005152, 0.7258686);\npoints[39] = vec2(0.8090152, 0.7407686);\npoints[40] = vec2(0.8056152, 0.7637686);\npoints[41] = vec2(0.8037151, 0.7737686);\npoints[42] = vec2(0.7913151, 0.7873686);\npoints[43] = vec2(0.8020152, 0.7975686);\npoints[44] = vec2(0.8092152, 0.7928686);\npoints[45] = vec2(0.8239151, 0.7834686);\npoints[46] = vec2(0.8337151, 0.7851686);\npoints[47] = vec2(0.8539152, 0.8061686);\npoints[48] = vec2(0.8656151, 0.8275687);\npoints[49] = vec2(0.8872151, 0.8470686);\npoints[50] = vec2(0.9019151, 0.8530686);\npoints[51] = vec2(0.9071151, 0.8455686);\npoints[52] = vec2(0.9032152, 0.8399686);\npoints[53] = vec2(0.8850151, 0.8208686);\npoints[54] = vec2(0.8781152, 0.7945686);\npoints[55] = vec2(0.8781152, 0.7945686);\npoints[56] = vec2(0.9031152, 0.8075686);\npoints[57] = vec2(0.9369152, 0.8220686);\npoints[58] = vec2(0.9477152, 0.8270686);\npoints[59] = vec2(0.9574151, 0.8159686);\npoints[60] = vec2(0.9347152, 0.8032686);\npoints[61] = vec2(0.9051151, 0.7872686);\npoints[62] = vec2(0.9123151, 0.7730686);\npoints[63] = vec2(0.9657152, 0.7579686);\npoints[64] = vec2(0.9621152, 0.7407686);\npoints[65] = vec2(0.9004152, 0.7545686);\npoints[66] = vec2(0.9154152, 0.7294686);\npoints[67] = vec2(0.9296151, 0.7120686);\npoints[68] = vec2(0.9118152, 0.7103686);\npoints[69] = vec2(0.8928151, 0.7309686);\npoints[70] = vec2(0.8560151, 0.7143686);\npoints[71] = vec2(0.8241152, 0.6755686);\npoints[72] = vec2(0.7808151, 0.6225686);\npoints[73] = vec2(0.7658151, 0.6148686);\npoints[74] = vec2(0.7096151, 0.6286686);\npoints[75] = vec2(0.6771151, 0.6168686);\npoints[76] = vec2(0.6319152, 0.5926686);\npoints[77] = vec2(0.5773152, 0.5832686);\npoints[78] = vec2(0.5221152, 0.5104686);\npoints[79] = vec2(0.4818152, 0.4475686);\npoints[80] = vec2(0.4365152, 0.3935686);\npoints[81] = vec2(0.3971151, 0.3436686);\npoints[82] = vec2(0.3534151, 0.3056686);\npoints[83] = vec2(0.3452151, 0.2660686);\npoints[84] = vec2(0.3241152, 0.2577686);\npoints[85] = vec2(0.3195151, 0.2767686);\npoints[86] = vec2(0.3452151, 0.3132686);\npoints[87] = vec2(0.3786151, 0.3605686);\npoints[88] = vec2(0.4115151, 0.4078686);\npoints[89] = vec2(0.4125152, 0.4381686);\npoints[90] = vec2(0.4658151, 0.5361686);\npoints[91] = vec2(0.3673151, 0.6462686);\npoints[92] = vec2(0.2527151, 0.5852686);\npoints[93] = vec2(0.1579151, 0.5152686);\npoints[94] = vec2(0.1217152, 0.5070686);\npoints[95] = vec2(0.1044151, 0.5581686);\n\n    float spider = sdPolygon(points, (uv+.4)*1.5);\n    vec3 rgbspider = mix(vec3(0.), \n    sat(sin(uv.y*1200.)*.3+.7)*vec3(1.000,0.580,0.333), sat((length(uv)-.2)*15.));\n    float eyes = length((uv-vec2(0.07,.08))*r2d(.5)*vec2(.8,.6))-.01;\n    eyes = min(eyes, length((uv-vec2(0.04,.09))*r2d(.5)*vec2(.8,.6))-.01);\n    rgbspider = mix(rgbspider, vec3(1.,0.,0.)*length((uv-vec2(0.04,.09))*30.), 1.-sat((abs(eyes)-0.005)*500.));\n    rgbspider = mix(rgbspider, vec3(1.), 1.-sat(eyes*500.));\n    col = mix(col, rgbspider, (1.-sat(spider*500.))*.75);\n    col += vec3(1.000,0.580,0.333)*(1.-sat((abs(spider-0.01)-0.001)*200.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33830, "src": "https://soundcloud.com/500bricksging/calling?si=59f517c076bd4bc7a03adb8202d80320&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdrCirc(vec2 uv, float t)\n{\n    vec3 col = vec3(0.275,0.145,0.027)*1.5;\n    vec2 ouv = uv;\n    float rep = .03;\n    float id = floor((uv.y+rep*.5)/rep);\n    uv.y = mod(uv.y+rep*.5,rep)-rep*.5;\n    uv.x += id;\n    float cl = .1;\n    float h = clamp(asin(sin(uv.x*5.)), -cl, cl)/cl;\n    float line = abs(uv.y-h*0.01)-.001;\n    vec3 rgb = mix(vec3(1.000,0.533,0.220), vec3(0.902,0.667,0.396), sat(sin(id)));\n    rgb *= 1.-sat((abs(ouv.x+(fract(id*.1)-.5)+mod(t*.75+.5*id,4.)-2.)-.2)*4.);\n    col += .8*rgb*(1.-sat(line*80.));\n    return col;\n}\nvec3 rdrCircuit(vec2 uv)\n{\n    vec3 col = rdrCirc(uv, iTime);\n    col += rdrCirc(uv+vec2(0.,.2), iTime*.7);\n    col += .5*rdrCirc(2.*uv+vec2(0.,.1), iTime*.5);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    vec3 col = rdrCircuit(uv);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI acos(-1.)\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdScRV.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[927, 927, 948, 948, 1021], [1022, 1022, 1049, 1049, 1210], [1211, 1211, 1230, 1230, 2406], [2408, 2408, 2465, 2465, 7424]]}
{"id": "DsSyzV", "name": "GARBA", "author": "dripydacoder", "description": "idk its literally my first shader", "tags": ["gujaratifolkgarbavibe"], "likes": 2, "viewed": 190, "published": 3, "date": "1687883736", "time_retrieved": "2024-07-30T17:47:06.508164", "image_code": "vec3 pallete(float t){\n    vec3 a = vec3(0.500,0.500,0.358);\n    vec3 b = vec3(0.375,0.375,0.588);\n    vec3 c = vec3(1.000,1.000,-0.882);\n    vec3 d = vec3(0.000,-2.712,-1.242);\n    \n    return a + b*cos( 5.28318*(c*t+d) );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    vec2 uv0=uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i=0.0;i<2.0;i++){\n    \n    uv=fract(uv*2.0)-.5;\n    \n    float d = length(uv);\n    \n    vec3 col = pallete(length(uv0)+iTime);\n\n    d = cos(d * 5.5 + iTime*1.3) / 7.;\n    d = abs(d);\n    d = 0.02/ d;\n    \n    finalColor+=col * d;\n    }\n    fragColor = vec4(finalColor,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 226], [229, 229, 286, 286, 701]]}
{"id": "ddjyRG", "name": "2d canvas", "author": "silica163", "description": "2d experiment canvas", "tags": ["2d", "experiment"], "likes": 1, "viewed": 202, "published": 3, "date": "1687875027", "time_retrieved": "2024-07-30T17:47:07.309022", "image_code": "#define PI 3.14159265\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nfloat polygon(vec2 uv,vec2 p,float r,float n){\n    uv -= p;\n    n = floor(n);\n    \n    float pa = PI-atan(uv.x,uv.y);      // position angle\n    float sa = PI/n;                 // side angle\n    float id = (pa - mod(pa,2.*sa)) / (2.*sa) ;// side id [0,1,2,3,...]\n    float ra = id * (2.*sa) + sa;       // rotate angle\n    float ir = cos(sa)*r;            // inner radius\n    float sl = sin(sa)*r;            // half side length\n    \n    uv = rot2D(ra)*uv;\n    uv += vec2(-ir,0);\n    \n    if(uv.x < 0.)return uv.x;\n    \n    return length(vec2(uv.x,uv.y - clamp(uv.y,-sl,sl)));\n}\n\nfloat pattern0(vec2 uv){\n    float c = 0.;\n    vec2 p = uv*1.;\n    vec2 q = vec2(0);\n    mat2 r = rot2D(PI/7.);\n    \n    for(float i = 0.;i<4.;i++){\n        p = r * p;\n        p *= 1.4;\n        p += q;\n        c += sin(p.x*PI + iTime)*cos(p.y*PI+iTime);\n        q = vec2(c,cos(p.y*PI+iTime)+c) + cos(p*PI);\n    }\n    return c;\n}\n\nfloat w(float x,float a,float s,float offset){\n// https://www.desmos.com/calculator/ut86yzbnj6\n    float S = pow(a,s);\n    return sin(x*S+offset)/S;\n}\n\nfloat pattern1(vec2 uv){\n    float c = 0.;\n    float repeat = 8.;\n    float s = 1.6;// scale factor\n    float t = iTime*.3;\n    vec2 p = uv*5.;\n    \n    \n    for(float i = 0.;i < repeat;i++){\n        c += w(p.x+w(p.y+w(p.x,s,i,t*i),s,i,t-i),s,i,t*i*2.);\n        p = rot2D(PI/5.)*p;\n        p-=cos(c);\n        //p.x = p.x + c;\n        //p.y = p.y + c;\n        //p += uv.yx*rot2D(PI/(i+.01));\n    }\n    //c = w(uv.x,s,3.,iTime)+.5;\n    c = c*.2+.5;\n    \n    return c;\n}\n\nfloat pattern2(vec2 uv){\n    float c = 0.;\n    float repeat = 8.;\n    float s = 1.6;// scale factor\n    float t = iTime*.3;\n    vec2 p = uv*2.;\n    vec2 q = vec2(0);\n    \n    \n    for(float i = 0.;i < repeat;i++){\n        q.x = w(p.x,s,i,t+q.y);\n        q.y = w(p.y,s,i,t+q.x);\n        c += w(q.x+w(q.y+w(q.x,s,i,t*i),s,i,t-i),s,i,t*i*2.);\n        \n        p = rot2D(PI/7.)*p;\n        p -= cos(q);\n        q.x += p.x;\n        q.y += p.y;\n        //p += uv.yx*rot2D(PI/(i+.01));\n    }\n    //c = w(uv.x,s,3.,iTime)+.5;\n    c = .5+c*.2;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    //uv *= 2.;\n\n    vec3 c = vec3(0);\n    //c+= smoothstep(10./iResolution.y,.0,polygon(uv,vec2(0),.5,3.));\n    //c = mod(c,.2)*5.;\n    //c += pattern0(uv);\n    \n    c += mix(vec3(.4,.1,1),vec3(.4,1,.4),pattern2(uv));\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 121, 121, 654], [656, 656, 680, 680, 984], [986, 986, 1032, 1080, 1136], [1138, 1138, 1162, 1162, 1605], [1607, 1607, 1631, 1631, 2161], [2163, 2163, 2220, 2220, 2534]]}
{"id": "DdBcRK", "name": "Accumulated Grandma Inversion", "author": "SnoopethDuckDuck", "description": "----> vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv <----\n----> CLICK BUFFER A, CHANNEL1 TO PLAY <----\n----> ^^^^^^^^^^^^^^^^^^^^^^^  <----", "tags": ["sound", "audio", "inversion", "visual", "grandma", "salvatore"], "likes": 7, "viewed": 267, "published": 3, "date": "1687874869", "time_retrieved": "2024-07-30T17:47:08.179694", "image_code": "// ALWAYS uses MAX_STEPS so has to be a low value\n#define MAX_STEPS 120\n#define SURF_DIST .001\n\nfloat getTime() { return texture(iChannel3, vec2(0)).a; }\n\nvec3 ori = vec3(0);\nvoid setOri() {\n    vec2 m = iMouse.xy / res;\n    ori = vec3(4.*cos(.91*iTime), \n               10. * cos(.31 * iTime), \n               5. * sin(.81 * iTime));\n    ori = vec3(4, 10., 12.);\n    \n    float th = 0.5 * tanh(0.002 * iTime);\n    ori.yz *= rot(0.45*iTime);// + th*thc(20., iTime) * pi + 1.);\n    ori.xz *= rot(0.4*iTime);// + th*ths(20., iTime) * pi);\n    \n    //ori.yz *= rot(-m.y*pi+1.);\n    //ori.xz *= rot(-m.x*2.*pi);\n}\n\nvec2 map(vec3 p) {\n    // Time is accumulate volume! (sum vol*vol)\n    float t = 0.025 * getTime();\n    \n    // Rescale with volume\n    float vol = texture(iChannel3, vec2(0)).b;    \n    p*=0.006-0.0035*vol;\n    \n    // Inversion\n    p /= dot(p,p);\n    \n    // Squash and rotate around changing axis\n    // using val*p.y - t distorts like a torus\n    float o = 2. * pi / 3.;\n    p /= 1. + 0.5 * cos(2.*(t+vec3(o,0,-o)));\n    p = erot(p.yzx, normalize(cos(4.*t+vec3(o,0,-o))), 0.*(1.-tanh(2.*t))*length(p) - 2.*t);\n    \n    // Rotate\n    p.xz *= rot(-pi/1.5+0.5*t);\n    p.yx *= rot(2.63*t);\n\n    // Volume textures\n    float mx = .5-.5*thc(12., 3.*t);\n    vec3 txPos =  (0.1*(1.-tanh(2.*t)) + mix(0.002, 0.003, mx)) * p;\n    float tx = texture(iChannel0, txPos).x;\n    float tx2 = texture(iChannel1, txPos).x;\n    tx *= 1.35*tx2;\n   \n    // Distance accumulated this step\n    float dori = dot(p-ori, p-ori);\n    float d = 2000. / dori * smoothstep(0.8, 0., tx);\n\n    // If close to origin, accumulate more distance\n    // to avoid getting stuck (blocking screen)\n    if (dori < 35. * 35.)\n        d += 0.8; // was 0.25\n \n    return vec2(d, tx);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\t\n    float d = 0.;\n    float acc = 0.; // Accumulated distance\n    float mat = 0.; // Material (color)\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        \n        // Randomise distance to avoid overstepping and banding\n        float h = hash(hash(p.x,p.z), p.y);\n        m.x *= 1. + 0.3 * h;\n\n        mat += 1.2 * m.y;\n        acc += 1.4 * m.x;\n        d += max(2.*SURF_DIST, sqrt(m.x) - 0.35 + 0.04 * h);\n    }   \n    return vec3(d, mat, acc);\n}\n\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{    \n    vec2 uv = (px - 0.5 * res) / res.y;\n\n    float t = 0.5*getTime();\n\n    setOri();\n    vec3 rd = dir(uv, ori, vec3(0, cos(0.4*t), 0), \n                  0.45 * tanh(0.02 * t)+ 0.6* tanh(10.5*t));\n    vec3 m = march(ori, rd);    \n    vec3 p = ori + rd * m.x;  \n    \n    // Does something (?)\n    vec3 col = vec3(1.-1./cosh(0.01*m.z));\n\n    // Mix green color with volume\n    float vol = texture(iChannel3, vec2(0)).g;\n    vec3 pl = pal(0.0045*m.y + 0.5*smoothstep(9., 11.,t)*floor(0.*10.*(uv.x+uv.y)+.05*t)\n                  + 0.02 -0.*vol*vol - 0.12*length(uv), \n                  0.8 * vec3(0,3,1)/3.);\n    float str = exp(-30.*vol*vol-0.00003*m.y*m.y); //was 0.00006\n    col = mix(col, pl, exp(-str*vol*m.y*m.y));\n    \n    // Make background whiter (probably better ways of doing this)\n    col = mix(mix(vec3(1),col,0.1), col, exp(-0.00002*m.z*m.z));\n    \n    // Border\n    float x = abs(abs(uv.x) - 0.5*res.x/res.y + 0.01);\n    float y = abs(abs(uv.y) - 0.5 + 0.01);\n    float sBorder = smoothstep(-1./res.y,1./res.y, 0.01-min(x,y));   \n    float fr = fract(10. * (uv * rot(-pi/4.)).x - 0.4* t) - 0.5;\n    float s2 = step(abs(fr), 0.2);\n    sBorder = mix(sBorder, 0.03, s2);\n    col = mix(col, vec3(0), 0.3 * sBorder);\n    \n    // Border dots\n    float d = mlength(abs(uv) - 0.5*vec2(res.x/res.y, 1) + 0.05);\n    float sDots = smoothstep(-1./res.y, 1./res.y, 0.04 * vol - d);\n    col = mix(col, vec3(1), 0.5 * sDots);\n\n    // Purple and black vignettes\n    col = mix(col, vec3(1,0,1), 0.14*length(uv));\n    col *= 1. - 0.25*dot(uv,uv);\n    \n    // Clicky test thing\n    vec2 ms = (iMouse.xy - 0.5 * res) / res.y;\n    if (iMouse.z > 0.) {\n        col = 1. - col;\n        //col = mix(1.-col, col, smoothstep(-0.02,0.02,uv.x-ms.x));\n        //uv *= rot(iTime);\n        //col = mix(1.-col, col, smoothstep(-0.02,0.02, uv.x-0.6*res.x/res.y*sin(2.*iTime)));\n        // col = mix(1.-col, col, smoothstep(-0.02,0.02, abs(uv.y-0.)-0.2+0.1*cos(uv.x*4.+iTime)-0.5-0.5*thc(9.,4.*pi*vol*vol)));\n    }\n    \n    // Gamma\n    col = pow(col, vec3(1./2.2));\n    \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n#define res iResolution.xy\n#define tanh2(a) ((exp2(a)-1.)/(exp2(a)+1.))\n#define thc(a,b) tanh2(a*cos(b))/tanh2(a)\n#define ths(a,b) tanh2(a*sin(b))/tanh2(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// from BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat mlength(vec2 a) { return max(abs(a.x), abs(a.y)); }", "buffer_a_code": "float getVol(float samples) {\n    float v = 0.;\n    for (float i = 0.; i < samples; i++) \n        v += texture(iChannel1, vec2((i + 0.5)/samples, 0.05)).x;\n    return v / samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    //float sc = 32.;\n    //uv.x = floor(sc * uv.x + 0.5)/sc;\n    \n    vec4 ch0 = texture(iChannel0, uv);\n    float ch1 = 0.;\n    \n    // Number of samples in either direction\n    float n = 5.;\n    \n    // Sample spacing (value chosen because it looks good)\n    float s = 0.003;  //0.003 with n=5.\n    \n    // Average of samples, ch1\n    for (float i = -n; i <= n; i++) \n        ch1 = max(ch1, texture(iChannel1, vec2(uv.x + s * i, 0.25)).x);\n\n    // Alpha scales with uv.x, since bassy tones are more prevalent\n    float vol = getVol(40.);\n    float r = mix(ch0.r, ch1, 0.9); // individual frequencies (bad)\n    float g = mix(ch0.g, vol, 0.5); // lerp volume\n    float b = mix(ch0.b, vol, 0.2); // soft lerp volume\n    float a = ch0.a + g*g;          // accumulate volume to use as time\n    \n    // idea:\n    // acceleration += volume\n    // speed += acceleration\n    // speed *= friction\n    // time = speed    \n    \n    vec3 col = vec3(r, g, b);\n\n    fragColor = vec4(col, a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33827, "src": "https://soundcloud.com/salvatoreganacci/step-grandma?si=9484ed33a276447fa67a7bf2cddd8610&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 113, 113, 153], [175, 175, 190, 190, 609], [611, 611, 629, 677, 1756], [1758, 1758, 1788, 1788, 2285], [2288, 2288, 2332, 2332, 2523], [2525, 2525, 2567, 2567, 4645]]}
{"id": "DsScRK", "name": "polygon ring", "author": "silica163", "description": "polygon rings", "tags": ["raymarch", "ring", "polygon"], "likes": 6, "viewed": 185, "published": 3, "date": "1687873245", "time_retrieved": "2024-07-30T17:47:09.065326", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,1)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    //l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[0].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    N = sNormal(r.p);\n    \n    //c = N*.5+.5;\n    //c = r.p;\n    c += render(r); \n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  256\n#define MAX_REF   2\n\n#define rotX(a) mat3(      1, 0,       0, 0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n#define rotZ(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nconst int LIGHTS = 1;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat polygon(vec2 uv,vec2 p,float r,float n){\n    uv = uv - p;\n    n = floor(n);\n    float pa = PI-atan(uv.x,uv.y);      // position angle\n    float sa = 2.*PI/n;                 // side angle\n    float id = (pa - mod(pa,sa)) / sa ;\n    float ra = id * (sa) + sa/2.;       // rotate angle\n    float ir = cos(sa/2.)*r;            // inner radius\n    float sl = sin(sa/2.)*r;            // half side length\n    \n    uv = rot2D(ra)*uv;\n    uv += vec2(-ir,0);\n    \n    if(uv.x < 0.)return uv.x;\n    \n    return length(vec2(uv.x,uv.y - clamp(uv.y,-sl,sl)));\n}\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n    float poly1 = polygon(p.xz,vec2(-.5,0),.7,3.)-.3;\n    float poly2 = polygon(vec2(poly1,p.y),vec2(0,0),.1,5.)-.01;\n\t\n    d = poly2;\n    \n    poly1 = polygon(p.xy,vec2(.5,0),.7,5.)-.3;\n    poly2 = polygon(rot2D(2.*PI/3.)*vec2(poly1,p.z),vec2(0),.1,6.)-.01;\n\t\n    d = min(poly2,d);\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += diffuse(r.p,l[i].L);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(.1);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsScRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 935]]}
{"id": "ds2cRy", "name": "Colors Wheel", "author": "AmenShadertoy", "description": "play around with the #define values to change the result", "tags": ["colorwheelcolorswheelspheregradientblurgreenredyellowcirclerotatable"], "likes": 1, "viewed": 280, "published": 3, "date": "1687869897", "time_retrieved": "2024-07-30T17:47:10.069641", "image_code": "#define SphereSize 0.5;\n#define Saturation 0.8;\n#define BlurEdge 0.05;\n#define TurnColors false;\n#define RotationSpeed 0.;\n\nconst float PI = 3.14;\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv /= SphereSize;\n    \n    float rotationSpeed = RotationSpeed;\n    \n    uv *= rotationMatrix(rotationSpeed * iTime);\n\n    float saturation = Saturation;\n    \n    float blurEdge = BlurEdge;\n   \n    float l = length(uv);\n   \n    float colorStep = smoothstep(0.8 + blurEdge, (0.8 + blurEdge) - blurEdge, l);\n   \n    bool turnColors = TurnColors;\n      \n    float i = (turnColors ? 1. : -1.);\n    \n    float step1atCenter = colorStep * smoothstep(1., 0., l) * saturation;\n   \n    float red = ((uv.x * i) + (uv.y * i)) * step1atCenter;\n    float green = ((uv.x * -i) + (uv.y * -i)) * step1atCenter;\n   \n   \n\n    // Time varying pixel colors\n    vec3 col = vec3((colorStep * red) + step1atCenter, (colorStep * green) + step1atCenter, colorStep * 0.);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2cRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 182, 182, 276], [279, 279, 335, 385, 1301]]}
{"id": "dd2yR1", "name": "Fork perlin_noi aalsw42 086", "author": "aalsw42", "description": "perlin noise genrator", "tags": ["noisetexture"], "likes": 0, "viewed": 152, "published": 3, "date": "1687864917", "time_retrieved": "2024-07-30T17:47:10.987188", "image_code": "#define SCALE 2.\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D8\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // \n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float c = noise_perlin(vec3(SCALE * uv, iTime * 0.45))+0.5;\n\n    // Define the heatmap colors\n    vec3 color1 = vec3(0.117647, 0.196078, 0.301961);  // #1e324d\n    vec3 color2 = vec3(0.607843, 0.588235, 0.909804);  // #9b96e8\n    vec3 color3 = vec3(0.462745, 0.627451, 0.721569);  // #76a0b8\n    vec3 color4 = vec3(0.384314, 0.380392, 0.372549);  // #62615f\n\n    // Perform color interpolation based on the heatmap value\n    vec3 color;\n    if (c < 0.25)\n        color = mix(color1, color2, c * 4.0);\n    else if (c < 0.5)\n        color = mix(color2, color3, (c - 0.25) * 4.0);\n    else if (c < 0.75)\n        color = mix(color3, color4, (c - 0.5) * 4.0);\n    else\n        color = color4;\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2yR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 48, 48, 261], [263, 263, 292, 292, 1161], [1164, 1164, 1219, 1219, 1994]]}
{"id": "dd2yRG", "name": "Atlantis 3", "author": "dr2", "description": "Update includes using path based on hexagonal Truchet tiles (mouseable)", "tags": ["hexagon", "underwater", "truchet", "cave", "dolphin"], "likes": 20, "viewed": 348, "published": 3, "date": "1687858625", "time_retrieved": "2024-07-30T17:47:12.059321", "image_code": "// \"Atlantis 3\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat HexEdgeDist (vec2 p, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Ssign (float x);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n\n#define N_FISH 5\n\nstruct Fish {\n  vec3 pos;\n  vec2 angCsH, angCsV;\n  float angI;\n};\nFish fish[N_FISH];\n\nvec4 cPath[PLEN];\nvec3 qHit, sunDir, cHit, qnHit;\nvec2 cIdB, cMidB;\nfloat tCur, dstFar, tEnd[PLEN + 1], hgSizeB, vgSize, tLen, cDir, cType;\nint nFrame, idObj;\nbool isSh;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, CosSin (- pi / 3.)) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, CosSin (pi / 3.));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, CosSin (tt * a))) * hgSizeB;\n}\n\nfloat PathHt (vec2 p)\n{\n  return 2.5 * dot (sin (2. * pi * p * vec2 (0.015, 0.016)), vec2 (1.));\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nbool HexCellOcc ()\n{\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac, d, dc, hy;\n  cIdB = PixToHex (cHit.xz / hgSizeB);\n  BConf ();\n  hy = cHit.y - PathHt (cHit.xz);\n  w = (cHit.xz - cMidB) / hgSizeB;\n  cm3 = TruchSDist (w);\n  dt = hgSizeB * abs (cm3.x);\n  rc = abs (cm3.y);\n  ac = 18. * abs (cm3.z);\n  d = length (vec2 (dt + 0.5 * dot (sin (2. * pi * vec3 (dt, 2. * rc * ac, 0.1 * cHit.y)),\n     vec3 (1.)), 0.7 * hy)) - 10.1;\n  d = min (d, length (vec2 (hgSizeB * HexEdgeDist (w), hy)) - 8.1);\n  dc = min (4.1 - dt, 1.5 - abs (hy + 12.));\n  idObj = (d > dc) ? 1 : 2;\n  d = max (d, dc);\n  d = SmoothMin (d, 13. + 8.5 * dot (sin (0.03 * pi * cHit), vec3 (1.)) - cHit.y, 2.);\n  return (d > 0.);\n}\n\nvec2 PixToHexS (vec2 p)\n{\n  vec2 c, r, dr;\n  p.y *= 2./sqrt3;\n  c = p.yx;\n  r = floor (c);\n  r += 2. * fract (0.5 * vec2 (r.x, r.y + step (0.5, fract (0.25 * r.x + 0.25))));\n  dr = c - r;\n  r += step (2., dot (abs (dr), vec2 (sqrt3, 1.))) * sign (dr) * vec2 (2., 1.);\n  r.x *= sqrt3/2.;\n  return r;\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{  // (based on \"\"Canal Ruins 2\")\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, sy;\n  if (rd.y == 0.) rd.y = 0.0001;\n  cHit = vec3 (PixToHexS (ro.xz).yx, vgSize * floor (ro.y / vgSize + 0.5)).xzy;\n  hv[0] = vec2 (1., 0.);\n  hv[1] = vec2 (0.5, 0.5 * sqrt3);\n  hv[2] = vec2 (-0.5, 0.5 * sqrt3);\n  for (int k = 0; k < 3; k ++) hv[k] *= sign (dot (hv[k], rd.xz));\n  sy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    w = ro - cHit;\n    ht.z = dstFar;\n    for (int k = 0; k < 3; k ++) {\n      htt = vec3 (hv[k].xy, (1. - dot (hv[k], w.xz)) / dot (hv[k], rd.xz));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * sy * vgSize - w.y) / rd.y;\n    if (ht.z < ty) cHit.xz += 2. * ht.xy;\n    else cHit.y += sy * vgSize;\n    if (HexCellOcc ()) {\n      if (ht.z < ty) {\n        dHit = ht.z;\n        qnHit.xy = ht.xy;\n      } else {\n        dHit = ty;\n        qnHit.z = sy;\n      }\n      qnHit = - qnHit.xzy;\n      break;\n    }\n  }\n  return dHit;\n}\n\nfloat HexCellEdge (vec3 p)\n{\n  vec2 dh;\n  float d;\n  dh = p.xz - cHit.xz;\n  if (qnHit.y == 0.) {\n    d = min (abs (length (dh - dot (dh, qnHit.xz) * qnHit.xz) - 1./sqrt3),\n       abs (fract (p.y / vgSize) - 0.5) * vgSize);\n  } else {\n    dh = abs (dh);\n    d = max (dot (vec2 (0.5, sqrt3/2.), dh), dh.x) - 1.;\n  }\n  return d;\n}\n\nvec3 HexPrisCol (vec3 p, float dEdge)\n{\n  vec3 col;\n  vec2 cIdS, c;\n  float b;\n  col = (idObj == 1) ? vec3 (0.8, 0.9, 0.9) : vec3 (0.6, 0.7, 0.7);\n  col *= 1. - 0.15 * smoothstep (0.01, 0.03, abs (dEdge));\n  if (abs (qnHit.y) < 0.9 && mod (floor (p.y / vgSize + 0.5), 2.) == 0.) col *= 0.9;\n  cIdS = PixToHex (cHit.xz);\n  c = vec2 (1., 0.95);\n  b = mod (dot (mod (2. * cIdS + cIdS.yx, 3.), vec2 (1., 2.)), 3.);\n  if (idObj == 1) col *= (b == 0.) ? c.xyy : ((b == 1.) ? c.yxy : c.yyx);\n  if (qnHit.y == 1.) col *= 0.7;\n  return col;\n}\n\nfloat FishDf (vec3 p, int k)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye, d;\n  p.xz = Rot2Cs (p.xz, fish[k].angCsH);\n  p.yz = Rot2Cs (p.yz, fish[k].angCsV);\n  if (! isSh) d = PrCapsDf (p, 1.6, 3.);\n  if (isSh || d < 0.1) {\n    p.x = abs (p.x);\n    p.z -= 2.;\n    p.yz = Rot2Cs (p.yz, CosSin (0.2 * fish[k].angI));\n    q = p;\n    q.z -= -0.6;\n    dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n    q = p;\n    q.z -= -1.2;\n    q.yz = Rot2Cs (q.yz, CosSin (fish[k].angI));\n    q.z -= -1.6;\n    dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n    q.z -= -2.2;\n    q.yz = Rot2Cs (q.yz, CosSin (2. * fish[k].angI));\n    q.xz -= vec2 (0.5, -0.5);\n    q.xz = Rot2D (q.xz, 0.4);\n    dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n    q = p;\n    q.yz -= vec2 (-0.3, 1.7);\n    q.yz = Rot2D (q.yz, 0.1);\n    q.y = abs (q.y) - 0.04;\n    dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n    q = p;\n    q.yz -= vec2 (0.7, -1.);\n    q.yz = Rot2D (q.yz, 0.6);\n    dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n    q = p;\n    q.xy = Rot2D (q.xy, 0.8);\n    q.xz -= vec2 (0.7, -0.1);\n    q.xz = Rot2D (q.xz, 0.6);\n    dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n    q = p;\n    q -= vec3 (0.4, -0.1, 1.1);\n    dEye = PrEllipsDf (q, vec3 (0.11, 0.15, 0.15));\n    idObj = 11;\n    dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n    dMin = SmoothMin (SmoothMin (dMin, dFinT, 0.1), dMouth, 0.15);\n    dMin = SmoothMin (SmoothMin (dMin, dFinD, 0.02), dFinP, 0.02);\n    if (dEye < dMin) idObj = 12;\n    dMin = SmoothMin (dMin, dEye, 0.01);\n    qHit = q;\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qHitA;\n  float dMin, d, fishSz;\n  int idObjA;\n  fishSz = 1.2;\n  dMin = dstFar / fishSz;\n  for (int k = VAR_ZERO; k < N_FISH; k ++) {\n    q = (p - fish[k].pos) / fishSz;\n    d = FishDf (q, k);\n    if (d < dMin) {\n      idObjA = idObj;\n      qHitA = qHit;\n      dMin = d;\n    }\n  }\n  idObj = idObjA;\n  qHit = qHitA;\n  return dMin * fishSz;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isSh = true;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = (clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.)) *\n     (1. - smoothstep (0.4, 0.6, rd.y));\n  return 0.7 * vec3 (0.2, 0.7, 1.) * (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) *\n     (1. + 0.1 * gd);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float k = 1.; k <= 7.; k ++) {\n    tt = t * (1. + 1. / k);\n    a1 = tt - qq;\n    a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  p = 10. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (p.x * 2. + t * 0.77 + sin (p.y * 0.73 - t)) +\n     sin (p.y * 0.81 - t * 0.89 + sin (p.x * 0.33 + t * 0.34)) +\n     (sin (p.x * 1.43 - t) + sin (p.y * 0.63 + t)) * 0.5;\n  h *= smoothstep (0.5, 1., rd.y) * 0.04;\n  return h;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnn, bgCol;\n  float dstObj, dstBlk, dEdge, sh;\n  int idObjH;\n  isSh = false;\n  dstBlk = HexVolRay (ro, rd);\n  idObjH = idObj;\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  if (min (dstObj, dstBlk) < dstFar) {\n    if (dstObj < dstBlk) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vnn = vn;\n      col4 = vec4 (0.5, 0.8, 0.4, 0.2);\n      if (idObj == 11) col4 = vec4 (0.8, 0.8, 1., 0.1) *\n         (1. - 0.3 * smoothstep (-0.4, -0.2, vn.y));\n      else if (idObj == 12) col4 = vec4 (0.6, 1., 0.6, -1.) *\n         step (0.05, length (qHit.yz - vec2 (-0.02, 0.05)));\n    } else {\n      ro += dstBlk * rd;\n      idObj = idObjH;\n      dEdge = HexCellEdge (ro);\n      col4 = vec4 (HexPrisCol (ro, dEdge), 0.);\n      vn = qnHit;\n      if (vn.y > 0.99) col4 *= 0.8;\n      vnn = vn;\n      vn = VaryNf (8. * ro, vn, 0.5 * (1. - 0.95 * smoothstep (40., 60., dstBlk)) *\n         smoothstep (0.01, 0.03, abs (dEdge)));\n    }\n    if (col4.a >= 0.) {\n      sh = 0.6 + 0.4 * smoothstep (12., 16., HexVolRay (ro + 0.01 * vn, sunDir));\n      sh = min (sh, ObjSShadow (ro + 0.01 * vn, sunDir));\n      col = col4.rgb * (0.2 + 0.1 * max (dot (sunDir * vec3 (-1., 1., -1.), vn), 0.) +\n         0.8 * sh * max (dot (sunDir, vn), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      col += 0.2 * TurbLt (0.2 * ro, abs (vnn), 0.3 * tCur) * smoothstep (-0.3, -0.1, vnn.y);\n      col = mix (col, bgCol, smoothstep (0., 0.95, min (dstObj, dstBlk) / dstFar));\n    } else col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n  } else col = bgCol + WatShd (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid FishPM (float t, out vec3 pos, out float az, out float el)\n{\n  vec3 p, pf, pb, vd;\n  pf.xz = EvalPPos (t + 0.1);\n  pf.y = PathHt (pf.xz);\n  pb.xz = EvalPPos (t - 0.1);\n  pb.y = PathHt (pb.xz);\n  pos = 0.5 * (pf + pb);\n  vd = normalize (pf - pb);\n  az = atan (vd.z, - vd.x) - 0.5 * pi;\n  el = sin (vd.y);\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, vObs, tGap, t, angH, angV;\n  int vuId, vuIdO, regId;\n  bool sWin, opFish;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 18000.) + 30. * floor (dateCur.w / 3600.) + 20.;\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n    if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  }\n  vuIdO = vuId;\n  if (uv.x / asp > 1. - 2. * SmoothBump (0.25, 0.75, 0.01, fract (tCur / 60.))) vuId = 1 - vuId;\n  hgSizeB = 48.;\n  vgSize = 1.;\n  SetPath ();\n  dstFar = 150.;\n  vObs = 0.4;\n  opFish = (vuId == 0);\n  tGap = (opFish) ? 0.6 * hgSizeB / float (N_FISH) : 2.;\n  for (int k = VAR_ZERO; k < N_FISH; k ++) {\n    t = opFish ? tGap * (floor (vObs * tCur / tGap + 0.5) - fract (tCur / tGap) -\n       0.5 * float (N_FISH)) : vObs * tCur;\n    FishPM (t + tGap * float (k), fish[k].pos, angH, angV);\n    if (opFish) {\n      angH += pi;\n      angV *= -1.;\n      fish[k].pos.y -= 4.;\n    } else {\n      fish[k].pos.y -= 2.;\n    }\n    fish[k].angCsH = CosSin (angH);\n    fish[k].angCsV = CosSin (angV);\n    fish[k].angI = 0.1 * sin (pi * tCur + ((opFish) ? 0. :\n       2. * pi * float (k) / float (N_FISH)));\n  }\n  FishPM (vObs * tCur + ((opFish) ? 0. : -0.8), ro, az, el);\n  if (mPtr.z > 0. && vuIdO == regId) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  zmFac = 1.8;\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1.5, 1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.002 * pi * tCur);\n  uv += 2. * sin (2. * pi * (5. * uv + 0.5 * sin (0.4 * pi * tCur))) / canvas.y;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.3, 0.5, 0.3);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (vec3 (p.xy, sign (p.z) * (max (0., abs (p.z) - h)))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat HexEdgeDist (vec2 p, float h)\n{\n  p = abs (p);\n  p -= vec2 (0.5, - sqrt3/2.) * min (p.x - sqrt3 * p.y, 0.);\n  p.x -= h * sqrt3/2.;\n  return Ssign (p.x) * max (abs (p.x), abs (p.y) - 0.5 * h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2yRG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1168, 1168, 1189, 1189, 1212], [1214, 1214, 1240, 1240, 2228], [2230, 2230, 2251, 2251, 2859], [2861, 2861, 2878, 2878, 3723], [3725, 3725, 3750, 3750, 4385], [4387, 4387, 4410, 4410, 4485], [4487, 4487, 4502, 4502, 5211], [5213, 5213, 5233, 5233, 5901], [5903, 5903, 5928, 5928, 6203], [6205, 6205, 6241, 6273, 7240], [7242, 7242, 7270, 7270, 7569], [7571, 7571, 7610, 7610, 8104], [8106, 8106, 8136, 8136, 9696], [9698, 9698, 9720, 9720, 10070], [10072, 10072, 10105, 10105, 10288], [10290, 10290, 10311, 10311, 10568], [10570, 10570, 10607, 10607, 10867], [10869, 10869, 10891, 10891, 11314], [11316, 11316, 11356, 11356, 11818], [11820, 11820, 11844, 11844, 12147], [12149, 12149, 12184, 12184, 13844], [13846, 13846, 13911, 13911, 14156], [14176, 14176, 14232, 14232, 17456], [17458, 17458, 17501, 17501, 17578], [17580, 17580, 17615, 17615, 17677], [17679, 17679, 17703, 17703, 17933], [17935, 17935, 17959, 17959, 18015], [18017, 18017, 18045, 18045, 18125], [18127, 18127, 18164, 18164, 18326], [18328, 18328, 18358, 18358, 18471], [18473, 18473, 18504, 18504, 18568], [18570, 18570, 18606, 18606, 18812], [18814, 18814, 18837, 18837, 18875], [18877, 18877, 18899, 18899, 18926], [18928, 18928, 18950, 18950, 18977], [18979, 18979, 19024, 19024, 19116], [19118, 19118, 19175, 19175, 19258], [19292, 19292, 19316, 19316, 19376], [19378, 19378, 19402, 19402, 19514], [19516, 19516, 19541, 19541, 19725], [19727, 19727, 19756, 19756, 19968], [19970, 19970, 20009, 20009, 20261]]}
{"id": "Ds2czG", "name": "Vesica Segment - distance 3D", "author": "iq", "description": "The SDF to an arbitrarily oriented vesica segment, with only 3 square roots (2 if shape is constant).", "tags": ["3d", "sdf", "distance", "vesica"], "likes": 28, "viewed": 1754, "published": 3, "date": "1687843993", "time_retrieved": "2024-07-30T17:47:12.821284", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a vesica segment with 3 square roots, and to\n// a vertival vesica segment with 2 square roots.\n//\n// 2D version here: https://www.shadertoy.com/view/cs2yzG\n//\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and \n//     https://iquilezles.org/articles/distfunctions\n\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    // orient and project to 2D\n    vec3  c = (a+b)*0.5;\n    float h = length(b-a);\n    vec3  v = (b-a)/h;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\n// specialization for a vertical vesica segment at the origin\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat map( in vec3 pos )\n{\n    vec3 a = vec3(-0.3,-0.4, 0.0);\n    vec3 b = vec3( 0.3, 0.3, 0.0);\n\n    // animate\n    b = a + (b-a)*(1.0 + 0.2*sin(2.0*iTime) );\n    float l = length(b-a);\n    \n    // keep volume constant (say it's a muscle)\n    float w = sqrt(0.2/l);\n    \n    return sdVesicaSegment(pos, a, b, w*0.85 ) - w*0.15;\n\n    // test vertical vesica segment\n    // return sdVerticalVesicaSegment( pos-a, l, w*0.85 ) - w*0.15;\n\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.1*sin(iTime);\n\tvec3 ro = vec3( 1.0*sin(an), 0.4, 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n        \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2czG.jpg", "access": "api", "license": "mit", "functions": [[1388, 1388, 1458, 1490, 1894], [1896, 1958, 2026, 2049, 2355], [2357, 2357, 2383, 2383, 2793], [2795, 2841, 2873, 2873, 3112]]}
{"id": "cs2yzG", "name": "Vesica Segment - distance 2D", "author": "iq", "description": "Distance to an arbitrarily oriented Vesica (https://www.shadertoy.com/view/XtVfRW)", "tags": ["2d", "distancefield", "sdf", "distance", "segment", "vesica"], "likes": 22, "viewed": 1042, "published": 3, "date": "1687842920", "time_retrieved": "2024-07-30T17:47:13.582249", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a vesica given by two points and a (semi)width, using\n// two square roots per evaluation.\n\n// See also https://www.shadertoy.com/view/XtVfRW for an axis aligned vesica\n\n// List of some other 2D distances:\n//     https://www.shadertoy.com/playlist/MXdSRf\n// and\n//     iquilezles.org/articles/distfunctions2d\n\n\nfloat sdVesicaSegment( in vec2 p, in vec2 a, in vec2 b, float w )\n{\n    // shape constants\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    \n    // center, orient and mirror\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    \n    // feature selection (vertex or body)\n    vec3 h = (r*q.x < d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    // distance\n    return length(q-h.xy) - h.z;\n}\n\n\n// iquilezles.org/articles/distfunctions2d\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    // animation\n    vec2  v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2  v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.40*(0.5+0.495*cos(iTime*1.1+2.0));\n    float ra = 0.15*(0.5+0.495*cos(iTime*1.3+1.0));\n    float al = smoothstep( -0.5, 0.5,sin(iTime+0.1) );\n    ra *= 1.0-al;\n    \n    // distance\n    float d = sdVesicaSegment( p, v1, v2, th ) - ra;\n    \n    // color\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-10.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(100.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // mouse\n    if( iMouse.z>0.001 )\n    {\n    d = sdVesicaSegment( m, v1, v2, th ) - ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // geometry\n    {\n    vec2 c = (v1+v2)/2.0;\n    vec2 u = normalize( vec2(v2.y-v1.y,v1.x-v2.x) );\n    vec2 v3 = c + u*(th+ra);\n    vec2 v4 = c - u*(th+ra);\n    d = min(min(min(length(p-v1),\n                    length(p-v2)),\n                min(length(p-v3),\n                    length(p-v4))) - 0.015,\n                min(udSegment(p,v1,v2),\n                    udSegment(p,v3,v4)) - 0.004 );\n                  \n    col = mix(col, vec3(1.0,1.0,0.0), al*(1.0-smoothstep(0.0, 0.005, d)));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2yzG.jpg", "access": "api", "license": "mit", "functions": [[1411, 1411, 1478, 1501, 1870], [1873, 1916, 1968, 1968, 2092], [2094, 2094, 2151, 2170, 3725]]}
{"id": "Ds2cRG", "name": "Disk Jockey", "author": "johnCavatelli", "description": "inspired by sand gardens with patterns in them!", "tags": ["noise", "circle"], "likes": 4, "viewed": 123, "published": 3, "date": "1687841202", "time_retrieved": "2024-07-30T17:47:14.412031", "image_code": "float random (in vec2 st) {// 2D Random\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat circle(in vec2 _st, in float _radius, in float _pow){\n    float dist = length( abs(_st)-.5 );\n    if(dist > _radius){return 0.;}\n    float c0 = fract(dist*_pow);\n    float c1 = step(0.5,c0);\n    float offset = sin((iTime * 1.5) + (_pow * _radius));\n    float c2 = noise((_st*90. + offset + (_radius * _pow)));\n    float c3 = 0.5 * c1 + 0.2 * c2 + c0 * 0.6;\n    float c4 = step(0.95, c3);\n    return c4;\n}\n\nvec3 renderWavyCircle(in vec2 _uv, in float _rad,in float _waveMult, in vec2 _translate, inout vec3 _prevCircleColor){\n    vec2 st = _uv + _translate; \n    float r = _rad;\n    if(length( abs(st)-.5) < r && st.x > 0. && st.x < 1.){_prevCircleColor = vec3(0);}\n    vec3 col = vec3(circle(st,r,_waveMult));\n    if(st.x < 0. || st.x > 1.){col = vec3(0.);}\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    uv.x = uv.x / aspect;\n    vec2 ogUV = uv;\n    \n    vec3 c0 = vec3(0);\n    vec3 c0a = renderWavyCircle(ogUV,0.6,10.,vec2(-1.2,0),c0);\n    vec3 c1 = renderWavyCircle(ogUV,0.5,13.,vec2(-0.5,0),c0a) + c0a;\n    vec3 c2 = renderWavyCircle(ogUV,0.5,17.,vec2(0,0.5),c1) + c1;\n    vec3 c3 = renderWavyCircle(ogUV,0.5,27.,vec2(-0.99,0.5),c2) + c2;\n    vec3 c4 = renderWavyCircle(ogUV,0.3,17.,vec2(-1.,-0.2),c3) + c3;\n    vec3 c5 = renderWavyCircle(ogUV,0.5,37.,vec2(0.2,-1.3),c4) + c4;\n    vec3 c6 = renderWavyCircle(ogUV,0.3,27.,vec2(0.4,0.3),c5) + c5;\n    vec3 c7 = renderWavyCircle(ogUV,0.3,17.,vec2(-0.5,-0.5),c6) + c6;\n    vec3 c8 = renderWavyCircle(ogUV,0.2,90.,vec2(-1.3,0.),c7) + c7;    \n    \n    fragColor = vec4( c8,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2cRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 39, 156], [158, 245, 271, 271, 788], [790, 790, 849, 849, 1200], [1202, 1202, 1320, 1320, 1571], [1573, 1573, 1630, 1630, 2447]]}
{"id": "DsByzG", "name": "Tapestry 8", "author": "iterati", "description": "Pinwheels", "tags": ["ifs"], "likes": 8, "viewed": 184, "published": 3, "date": "1687811102", "time_retrieved": "2024-07-30T17:47:15.243807", "image_code": "float sheen( in float d, in float x )\n{\n    return 1. - step(x, abs(d));\n}\n\nvec4 getHex(vec2 p)\n{\n    vec2 s = vec2(1, ROOT_3);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    //uv0.x += iResolution.x / iResolution.y;\n    //uv0.y -= 1.;\n    vec2 uv = uv0;\n    vec3 finalColor = vec3(0.0);\n    float d = 0.;\n    int sides = 6;\n    vec3 col = vec3(0.); \n    vec4 h0 = getHex(0.5 * uv);\n    vec4 h = h0;\n\n    float r = sinT(iTime, 21.) * 1. + 0.5;\n    float s = sinT(iTime, 45.) * 0.5;\n    float color = sinT(iTime, 60.);\n\n    float x = sinT(iTime, 36.) * 0.2 + 1.;\n    const float iterations = 5.;\n    for (float i = 0.0; i < iterations; i++) {\n        float n = sawT(iTime + (i * PI * 15. / iterations), 15.) * (float(sides) - 1.) + 1.;\n        float xx = x + ((sinT(iTime, 15.) - 0.5) * 0.2 * ((i + 1.) / iterations));// * exp(length(uv0 * s)));\n        float xy = sinT(iTime, 16.) * 0.2 + 0.9;\n        float xd = (int(h.z + h.w) % 2 == 0) ? 1. : -1.;\n        float xr = (ampT(iTime, 60., 3., 2.) * 2. - 1.) * xd * PI / 3.;\n        h.xy = rotate(h.xy, xr * i);\n        h = getHex(xy * xx * ROOT_3 * h.xy * ROT);\n        d = sdStar(h.xy, r / ROOT_3, sides, n);\n        d = sheen(d, 0.0025 * (i + 1.) * xx * xy);\n        float cc = (1. - sawT(iTime, 29.)) * 5. * (i / iterations);\n        col = palette(mod(cc + color + (length(uv0 * 0.1) * (1. - sinT(iTime, 7.))), 1.));\n        col *= d;\n        if (col.r > 1.) {\n            col.g += 0.25 * (col.r - 1.);\n            col.b += 0.25 * (col.r - 1.);\n            col.r -= 1.;\n        }\n        if (col.g > 1.) {\n            col.r += 0.25 * (col.g - 1.);\n            col.b += 0.25 * (col.g - 1.);\n            col.g -= 1.;\n        }\n        if (col.b > 1.) {\n            col.r += 0.5 * (col.b - 1.);\n            col.g += 0.5 * (col.b - 1.);\n            col.b -= 1.;\n        }\n        finalColor += col;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n#define ROOT_3 1.7320508\nconst mat2 ROT = mat2(cos(PI / 6.), sin(PI / 6.), -sin(PI / 6.), cos(PI / 6.));\n\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( in float t, float l, float a, float b)\n{\n    return abs(cos((t / l) * a * 2. * PI) * cos((t / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsByzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 74], [76, 76, 97, 97, 349]]}
{"id": "dsjyDw", "name": "Automata I Showcase 4x3", "author": "misol101", "description": "Variation on Game of Life algorithm, showcasing 12 rule sets. Fullscreen recommended!\n\nspace=regenerate, 7-9=speed.  Mouse x zooms, arrow keys pan when zoomed.\n\nCode taken from my shader https://www.shadertoy.com/view/cdSyDD", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 13, "viewed": 250, "published": 3, "date": "1687801874", "time_retrieved": "2024-07-30T17:47:16.628105", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ppos = texelFetch(iChannel1, ivec2(10,0), 0 ).xy;\n    \n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul) + ppos;\n\n    vec3 val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n    fragColor = vec4( val.x*0.9, val.x*0.95, val.x, 1.0 );\n    //fragColor = vec4( 0.8-val, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\n\nbool ReadKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=30.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 3) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    \n    float xsq = 4., ysq = 3.;\n    float wsq = iResolution.x / xsq;\n    float hsq = iResolution.y / ysq;\n    float thick = 3.;\n\n    float i;\n    for (i=0.; i<xsq; i++) {\n        if (fragCoord.x > wsq*i-thick && fragCoord.x < wsq*i+thick ) {\n            fragColor = vec4(0.01);\n            return;\n        }\n    }\n    for (i=0.; i<ysq; i++) {\n        if (fragCoord.y > hsq*i-thick && fragCoord.y < hsq*i+thick ) {\n            fragColor = vec4(0.01);\n            return;\n        }\n    }\n\n    int cix = int(fragCoord.x / wsq) + int(fragCoord.y / hsq)*int(xsq) + int(ix*10.);\n    setRules(cix % 33);\n\n\n    ivec2 px = ivec2( fragCoord );\n    float curr = cellval(px);\n\n    if( iFrame==0 || ReadKey(KEY_SPACE) || ReadKey(KEY_Z) || ReadKey(KEY_X) || int(xres) != int(iResolution.x)\n     || ReadKey(KEY_1) || ReadKey(KEY_2) || ReadKey(KEY_3) || ReadKey(KEY_4) || ReadKey(KEY_5) ) {\n        fragColor = vec4(restart(fragCoord, method),0.,0.,0.);\n        return;\n    }\n\t\n    if (iFrame % (speed+1) > 0) {\n        fragColor = vec4(curr, 0.,0.,0.);\n        return;\n    }\n  \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int ev = int(curr*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n\tfragColor = vec4( float(f)/10., 0.0, 0.0, 0.0 );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float density=50.;\nint stayrules[9];\nint bornrules[9];\nfloat liveval = 0.1;\nint newmethod = 0;\n\nvoid setRules(int index) {\n    int v1, v2;\n\n    if (index == 0) {v1 = 128, v2=98; density=90.;}    // Rectangles\n    if (index == 1) {v1 = 147, v2=225; density=100.;}  // Growing \"pipes\"\n    if (index == 2) {v1 = 136, v2=225; density=100.;}  // Weed \n    if (index == 3) {v1 = 149, v2=196; density=100.;}  // Critters\n    if (index == 4) {v1 = 170, v2=145; density=100.;}  // Dots and \"bursts\"\n    if (index == 5) {v1 = 208, v2=33; density=80.;}    // \"Worms\"\n    if (index == 6) {v1 = 140, v2=225; density=100.;}  // Critters and diagonal lines \n    if (index == 7) {v1 = 130, v2=52; density=90.;}    // Slowly building \"dotted lines\"\n    if (index == 8) {v1 = 138, v2=225; density=90.;}   // Chaos,dark\n    if (index == 9) {v1 = 80, v2=97; density=100.;}    // Black and white flashy\n    if (index == 10) {v1 = 145, v2=225; density=90.;}  // Rounded short lines\n    if (index == 11) {v1 = 116, v2=48; density=90.;}   // Going spiky black\n    if (index == 12) {v1 = 141, v2=72; density=98.;}   // Rectangles go fuzzy\n    if (index == 13) {v1 = 206, v2=161; density=90.;}  // Crosses and noise\n    if (index == 14) {v1 = 203, v2=196; density=70.;}  // Dying critters\n    if (index == 15) {v1 = 128, v2=60; density=90.;}   // Mosquito \n    if (index == 16) {v1 = 167, v2=73; density=100.;}  // Mini moving dots\n    if (index == 17) {v1 = 134, v2=98; density=90.;}   // Rectangles II\n    if (index == 18) {v1 = 164, v2=225; density=100.;} // Straight,weird \"lines\"\n    if (index == 19) {v1 = 229, v2=33; density=70.;}   // White vs black\n    if (index == 20) {v1 = 128, v2=57; density=90.;}   // Mosquito II\n    if (index == 21) {v1 = 203, v2=162; density=98.;}  // \"Diamonds\"\n    if (index == 22) {v1 = 140, v2=225; density=90.;}  // Chaos, less dark\n    if (index == 23) {v1 = 200, v2=97; density=100.;}  // \"Worms + cross\"\n    if (index == 24) {v1 = 153, v2=225; density=100.;} // Slow, straight lines\n    if (index == 25) {v1 = 153, v2=225; density=90.;}  // Squiggly, dense lines\n    if (index == 26) {v1 = 172, v2=97; density=90.;}   // Plant war\n    if (index == 27) {v1 = 85, v2=176; density=90.;}   // Going spiky black II + flashy\n    if (index == 28) {v1 = 64, v2=88; density=98.;}    // Flashy diamonds\n    if (index == 29) {v1 = 122, v2=8; density=96.;}    // Stable bg\n    if (index == 30) {v1 = 146, v2=72; density=100.;}  // Diagonal dying lines\n    if (index == 31) {v1 = 206, v2=160; density=97.;}  // Stable cracks\n    if (index == 32) {v1 = 207, v2=129; density=100.;} // Stable cracks II\n\n\n\tint i, stayVal = 128, bornVal = 128;\n\tfor (i = 0; i < 8; i++) {\n\t\tstayrules[8 - i] = ((v1 & stayVal) > 0? 1 : 0);\n\t\tstayVal = stayVal >> 1;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tbornrules[8 - i] = ((v2 & bornVal) > 0? 1 : 0);\n\t\tbornVal = bornVal >> 1;\n\t}\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_C     = 67;\nconst int KEY_V     = 86;\n\n\nbool ReadKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) {\n        fragColor = vec4(0.,0.,0.,1.0);\n        return;\n    }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( ReadKey(KEY_Z)||ReadKey(KEY_X)||ReadKey(KEY_C)||ReadKey(KEY_V) ) {\n            if (ky == 0.) {\n                if (ReadKey(KEY_X) || ReadKey(KEY_V)) {\n                    kx+=0.1;\n                    if (kx > 3.25) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=3.25;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( ReadKey(KEY_1)) method = 0.5;\n        if( ReadKey(KEY_2)) method = 1.5;\n        if( ReadKey(KEY_3)) method = 2.5;\n        if( ReadKey(KEY_4)) method = 3.5;\n        if( ReadKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( ReadKey(KEY_7)) speed = 0.;\n        if( ReadKey(KEY_8)) speed = 2.;\n        if( ReadKey(KEY_9)) speed = 8.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        vec2 ppos = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xy;\n        float mmul = iMouse.x / iResolution.x;\n        vec2 mid = iResolution.xy / 2.;\n\n        float psp=8.;\n        if( ReadKey(KEY_RIGHT)) ppos.x += psp;\n        if( ReadKey(KEY_LEFT)) ppos.x -= psp;\n        if( ReadKey(KEY_DOWN)) ppos.y -= psp;\n        if( ReadKey(KEY_UP)) ppos.y += psp;\n        ppos.x = clamp(ppos.x, -mid.x*mmul, mid.x*mmul);\n        ppos.y = clamp(ppos.y, -mid.y*mmul, mid.y*mmul);\n\n        fragColor = vec4(ppos,0.,1.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 444]]}
{"id": "dd2cDw", "name": "Automata II Showcase 5x4", "author": "misol101", "description": "Game of Life algorithm, showcasing 20 rule sets. Fullscreen recommended!\n\nspace=regenerate, 7-9=speed.  Mouse x zooms, arrow keys pan when zoomed.\n\nCode taken from my shader https://www.shadertoy.com/view/ms2cWW", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 17, "viewed": 347, "published": 3, "date": "1687798320", "time_retrieved": "2024-07-30T17:47:17.470852", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ppos = texelFetch(iChannel1, ivec2(10,0), 0 ).xy;\n    \n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul) + ppos;\n\n    vec3 val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n    fragColor = vec4( val.x*1.45, val.x*1.45, val.x*1.8, 1.0 );\n    //fragColor = vec4( 0.8-val, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\n\nbool ReadKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=30.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 3) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n\n    float xsq = 5., ysq = 4.;\n    float wsq = iResolution.x / xsq;\n    float hsq = iResolution.y / ysq;\n    float thick = 3.;\n\n    float i;\n    for (i=0.; i<xsq; i++) {\n        if (fragCoord.x > wsq*i-thick && fragCoord.x < wsq*i+thick ) {\n            fragColor = vec4(0.01);\n            return;\n        }\n    }\n    for (i=0.; i<ysq; i++) {\n        if (fragCoord.y > hsq*i-thick && fragCoord.y < hsq*i+thick ) {\n            fragColor = vec4(0.01);\n            return;\n        }\n    }\n\n    int cix = int(fragCoord.x / wsq) + int(fragCoord.y / hsq)*int(xsq) + int(ix*10.);\n    setRules(cix % 30);\n\n    ivec2 px = ivec2( fragCoord );\n    float curr = cellval(px);\n\n    if( iFrame==0 || ReadKey(KEY_SPACE) || ReadKey(KEY_Z) || ReadKey(KEY_X) || int(xres) != int(iResolution.x)\n     || ReadKey(KEY_1) || ReadKey(KEY_2) || ReadKey(KEY_3) || ReadKey(KEY_4) || ReadKey(KEY_5) ) {\n        fragColor = vec4(restart(fragCoord, method),0.,0.,0.);\n        return;\n    }\n\t\n    if (iFrame % (speed+1) > 0) {\n        fragColor = vec4(curr, 0.,0.,0.);\n        return;\n    }\n  \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int ev = int(curr*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = 0;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n\tfragColor = vec4( float(f)/10., 0.0, 0.0, 0.0 );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float density=50.;\nint stayrules[9];\nint bornrules[9];\nfloat liveval = 0.1;\n\nvoid setRules(int index) {\n    int v1, v2;\n\n    if (index == 0) {v1 = 122, v2=65; density=60.;}    // Chaos + stable\n    if (index == 1) {v1 = 70, v2=4; density=10.;}      // \"Self-activating\" GOL\n    if (index == 2) {v1 = 248, v2=65; density=10.;}    // Random to stable takeover\n    if (index == 3) {v1 = 120, v2=68; density=98.;}    // Slow growing \"maps\"\n    if (index == 4) {v1 = 248, v2=66; density=10.;}    // Growing jigsaw\n    if (index == 5) {v1 = 222, v2=32; density=100.;}   // Stone\n    if (index == 6) {v1 = 240, v2=40; density=78.;}    // Ink blobs \n    if (index == 7) {v1 = 122, v2=225; density=60.;}   // Worms in static\n    if (index == 8) {v1 = 121, v2=16; density=54.;}    // Squiggly no chaos\n    if (index == 9) {v1 = 175, v2=8; density=20.;}     // Stable bg\n    if (index == 10) {v1 = 227, v2=255; density=18.;}  // Hornet's nest\n    if (index == 11) {v1 = 122, v2=240; density=60.;}  // Stable worms\n    if (index == 12) {v1 = 122, v2=65; density=60.;}   // Chaos + stable\n    if (index == 13) {v1 = 122, v2=65; density=70.;}   // Chaos + stable II\n    if (index == 14) {v1 = 96, v2=57; density=100.;}   // Grow to stable flashing\n    if (index == 15) {v1 = 51, v2=4; density=10.;}     // Non-growing chaos\n    if (index == 16) {v1 = 243, v2=24; density=55.;}   // Stable BW\n    if (index == 17) {v1 = 243, v2=88; density=45.;}   // Stable BW II\n    if (index == 18) {v1 = 113, v2=89; density=50.;}   // Ant war with spots\n    if (index == 19) {v1 = 185, v2=9; density=50.;}    // Ant war\n    if (index == 20) {v1 = 6, v2=4; density=30.;}      // Original Game Of Life\n    if (index == 21) {v1 = 120, v2=4; density=85.;}    // Black vs white landscape \n    if (index == 22) {v1 = 249, v2=216; density=31.;}  // Stable \"stones\"\n    if (index == 23) {v1 = 242, v2=18; density=60.;}   // Slow growing blobs in chaos\n    if (index == 24) {v1 = 5, v2=12; density=78.;}     // Chaotic life III\n    if (index == 25) {v1 = 219, v2=216; density=50.;}  // Black eating ant war\n    if (index == 26) {v1 = 230, v2=196; density=5.;}   // Chaotic life \n    if (index == 27) {v1 = 38, v2=20; density=5.;}     // Chaotic life II\n    if (index == 28) {v1 = 0, v2=61; density=100.;}    // Triangles\n    if (index == 29) {v1 = 222, v2=32; density=100.;}  // Stone\n\n\tint i, stayVal = 128, bornVal = 128;\n\tfor (i = 0; i < 8; i++) {\n\t\tstayrules[8 - i] = ((v1 & stayVal) > 0? 1 : 0);\n\t\tstayVal = stayVal >> 1;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tbornrules[8 - i] = ((v2 & bornVal) > 0? 1 : 0);\n\t\tbornVal = bornVal >> 1;\n\t}\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_C     = 67;\nconst int KEY_V     = 86;\n\nbool ReadKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( ReadKey(KEY_Z)||ReadKey(KEY_X)||ReadKey(KEY_C)||ReadKey(KEY_V) ) {\n            if (ky == 0.) {\n                if (ReadKey(KEY_X) || ReadKey(KEY_V)) {\n                    kx+=0.1;\n                    if (kx > 2.95) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=2.95;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( ReadKey(KEY_1)) method = 0.5;\n        if( ReadKey(KEY_2)) method = 1.5;\n        if( ReadKey(KEY_3)) method = 2.5;\n        if( ReadKey(KEY_4)) method = 3.5;\n        if( ReadKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( ReadKey(KEY_7)) speed = 0.;\n        if( ReadKey(KEY_8)) speed = 2.;\n        if( ReadKey(KEY_9)) speed = 10.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        vec2 ppos = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xy;\n        float mmul = iMouse.x / iResolution.x;\n        vec2 mid = iResolution.xy / 2.;\n\n        float psp=8.;\n        if( ReadKey(KEY_RIGHT)) ppos.x += psp;\n        if( ReadKey(KEY_LEFT)) ppos.x -= psp;\n        if( ReadKey(KEY_DOWN)) ppos.y -= psp;\n        if( ReadKey(KEY_UP)) ppos.y += psp;\n        ppos.x = clamp(ppos.x, -mid.x*mmul, mid.x*mmul);\n        ppos.y = clamp(ppos.y, -mid.y*mmul, mid.y*mmul);\n\n        fragColor = vec4(ppos,0.,1.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2cDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 449]]}
{"id": "md3Gzj", "name": "Rippled", "author": "UsamagorQ", "description": "A ripple in space Idk", "tags": ["strange"], "likes": 2, "viewed": 58, "published": 3, "date": "1687795943", "time_retrieved": "2024-07-30T17:47:18.233812", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(float i = 0.0; i<=50.; i+=0.02)\n    {\nvec2 ew = vec2(fragCoord.xy*vec2(sin((iTime/100.)/15.)*sin(6.), sin(5.)));\nvec3 ew2 = vec3(ew.x*fragCoord.y + sin(ew.y*fragCoord.x)+4.);\n    vec2 uv = vec2 (fragCoord.yx/(iResolution.xy+fragCoord.yy*5.4525425));\n    vec3 col = 0.8465433 + .3*cos(iTime+uv.xyx+ew2);\n    vec3 tr = vec3(fragCoord.x*fragCoord.y/4., uv.x*\n    (7.52*uv.y), col*vec3(5000.*cos(5.43),asin(i/24.764), sin(24.5342)/4.54\n    *(fragCoord/vec2(54., 9.))));\n    fragColor = vec4(col+tr,524.0);\n    }\n}\n// I know you could probably do this in a much easier way\n//It's jus that shadertyou still seems a little confusing to me\n//And I still haven't taken the time to learn it yet.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3Gzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 575]]}
{"id": "ms2cWW", "name": "Automata Lab II (No grow chaos)", "author": "misol101", "description": "Game of Life algorithm, with many rule sets.\n\nCONTROLS:  down=next, up=previous, space=regenerate, right=next(no clear), left=previous(no clear).  1-5=clear method, 7-9=speed, h=toggle text. Mouse x zooms", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 4, "viewed": 212, "published": 3, "date": "1687786325", "time_retrieved": "2024-07-30T17:47:19.177290", "image_code": "float text(vec2 uv, float ix)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(ix*10.,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, ix);    \n\n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul);\n\n    vec3 val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n    fragColor = vec4( val.x*1.45, val.x*1.45, val.x*1.8, 1.0 );\n    //fragColor = vec4( 0.8-val, 1.0 );\n\n    fragColor += text_pixel;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=30.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 3) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    \n    setRules(int(ix*10.));\n    \n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor =  vec4(restart(fragCoord, method), 0.,0.,0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = vec4( cellval(px), 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int ev = int(cellval(px)*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = 0;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        ff = restart(fragCoord, method);\n    }\n\t\n\tfragColor = vec4( ff, 0.0, 0.0, 0.0 );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 29.;\nfloat density=50.;\nint stayrules[9];\nint bornrules[9];\nfloat liveval = 0.1;\n\nvoid setRules(int index) {\n    int v1, v2;\n\n    if (index == 0) {v1 = 51, v2=4; density=10.;}      // Non-growing chaos\n    if (index == 1) {v1 = 70, v2=4; density=10.;}      // \"Self-activating\" GOL\n    if (index == 2) {v1 = 6, v2=4; density=30.;}       // Original Game Of Life\n    if (index == 3) {v1 = 120, v2=68; density=98.;}    // Slow growing \"maps\"\n    if (index == 4) {v1 = 230, v2=196; density=5.;}    // Chaotic life \n    if (index == 5) {v1 = 38, v2=20; density=5.;}      // Chaotic life II\n    if (index == 6) {v1 = 240, v2=40; density=74.;}    // Ink blobs \n    if (index == 7) {v1 = 122, v2=225; density=60.;}   // Worms in static\n    if (index == 8) {v1 = 120, v2=4; density=85.;}     // Black vs white landscape \n    if (index == 9) {v1 = 175, v2=8; density=20.;}     // Stable bg\n    if (index == 10) {v1 = 241, v2=92; density=7.;}    // Oddly growing rects\n    if (index == 11) {v1 = 122, v2=240; density=60.;}  // Stable worms\n    if (index == 12) {v1 = 122, v2=65; density=60.;}   // Chaos + stable\n    if (index == 13) {v1 = 122, v2=65; density=70.;}   // Chaos + stable II\n    if (index == 14) {v1 = 96, v2=57; density=100.;}   // Grow to stable flashing\n    if (index == 15) {v1 = 249, v2=228; density=8.;}   // Growing blobs\n    if (index == 16) {v1 = 243, v2=24; density=55.;}   // Stable BW\n    if (index == 17) {v1 = 243, v2=88; density=45.;}   // Stable BW II\n    if (index == 18) {v1 = 249, v2=216; density=31.;}  // Stable \"stones\"\n    if (index == 19) {v1 = 121, v2=16; density=54.;}   // Squiggly no chaos\n    if (index == 20) {v1 = 185, v2=9; density=50.;}    // Ant war\n    if (index == 21) {v1 = 113, v2=89; density=50.;}   // Ant war with spots\n    if (index == 22) {v1 = 227, v2=255; density=18.;}  // Hornet's nest\n    if (index == 23) {v1 = 242, v2=18; density=60.;}   // Slow growing blobs in chaos\n    if (index == 24) {v1 = 5, v2=12; density=78.;}     // Chaotic life III\n    if (index == 25) {v1 = 219, v2=216; density=50.;}  // Black eating ant war\n    if (index == 26) {v1 = 248, v2=65; density=10.;}   // Random to stable takeover\n    if (index == 27) {v1 = 248, v2=66; density=10.;}   // Growing jigsaw\n    if (index == 28) {v1 = 0, v2=61; density=100.;}    // Triangles\n    if (index == 29) {v1 = 222, v2=32; density=100.;}  // Stone\n\n\tint i, stayVal = 128, bornVal = 128;\n\tfor (i = 0; i < 8; i++) {\n\t\tstayrules[8 - i] = ((v1 & stayVal) > 0? 1 : 0);\n\t\tstayVal = stayVal >> 1;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tbornrules[8 - i] = ((v2 & bornVal) > 0? 1 : 0);\n\t\tbornVal = bornVal >> 1;\n\t}\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_H     = 72;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=0.1;\n                    if (kx > 2.95) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=2.95;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 3.;\n        if( readKey(KEY_9)) speed = 12.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2cWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 232], [234, 234, 291, 291, 895]]}
{"id": "cdSyDD", "name": "Automata Lab I (imploding rects)", "author": "misol101", "description": "Variation on Game of Life (New cell state=neigbours, dying cell=state-1), with many rule sets.\n\nCONTROLS:  down/up=next/previous, space=regenerate, right/left=next/previous(no clear).  1-5=clear method, 7-9=speed, h=toggle text. \nMouse x zooms", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 14, "viewed": 202, "published": 3, "date": "1687786313", "time_retrieved": "2024-07-30T17:47:20.417972", "image_code": "float text(vec2 uv, float ix)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(ix*10.,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, ix);    \n\n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul);\n\n    vec3 val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n    fragColor = vec4( val.x*0.9, val.x*0.95, val.x, 1.0 );\n    //fragColor = vec4( 0.8-val, 1.0 );\n    \n    fragColor += text_pixel;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=30.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 3) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n\n    setRules(int(ix*10.));\n    \n    ivec2 px = ivec2( fragCoord );\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = vec4( cellval(px), 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int ev = int(cellval(px)*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        ff = restart(fragCoord, method);\n    }\n\t\n\tfragColor = vec4( ff, 0.0, 0.0, 0.0 );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 32.;\nfloat density=50.;\nint stayrules[9];\nint bornrules[9];\nfloat liveval = 0.1;\nint newmethod = 0;\n\nvoid setRules(int index) {\n    int v1, v2;\n\n    if (index == 0) {v1 = 128, v2=98; density=90.;}    // Rectangles\n    if (index == 1) {v1 = 147, v2=225; density=100.;}  // Growing \"pipes\"\n    if (index == 2) {v1 = 136, v2=225; density=100.;}  // Weed \n    if (index == 3) {v1 = 149, v2=196; density=100.;}  // Critters\n    if (index == 4) {v1 = 128, v2=60; density=90.;}    // Mosquito \n    if (index == 5) {v1 = 208, v2=33; density=80.;}    // \"Worms\"\n    if (index == 6) {v1 = 140, v2=225; density=100.;}  // Critters and diagonal lines \n    if (index == 7) {v1 = 130, v2=52; density=90.;}    // Slowly building \"dotted lines\"\n    if (index == 8) {v1 = 203, v2=162; density=98.;}   // \"Diamonds\"\n    if (index == 9) {v1 = 80, v2=97; density=100.;}    // Black and white flashy\n    if (index == 10) {v1 = 200, v2=97; density=100.;}  // \"Worms + cross\"\n    if (index == 11) {v1 = 167, v2=73; density=100.;}  // Mini moving dots\n    if (index == 12) {v1 = 141, v2=72; density=98.;}   // Rectangles go fuzzy\n    if (index == 13) {v1 = 206, v2=161; density=90.;}  // Crosses and noise\n    if (index == 14) {v1 = 203, v2=196; density=70.;}  // Dying critters\n    if (index == 15) {v1 = 170, v2=145; density=100.;} // Dots and \"bursts\"\n    if (index == 16) {v1 = 116, v2=48; density=90.;}   // Going spiky black\n    if (index == 17) {v1 = 134, v2=98; density=90.;}   // Rectangles II\n    if (index == 18) {v1 = 164, v2=225; density=100.;} // Straight,weird \"lines\"\n    if (index == 19) {v1 = 229, v2=33; density=70.;}   // White vs black\n    if (index == 20) {v1 = 128, v2=57; density=90.;}   // Mosquito II\n    if (index == 21) {v1 = 138, v2=225; density=90.;}  // Chaos,dark\n    if (index == 22) {v1 = 140, v2=225; density=90.;}  // Chaos, less dark\n    if (index == 23) {v1 = 145, v2=225; density=90.;}  // Rounded short lines\n    if (index == 24) {v1 = 153, v2=225; density=100.;} // Slow, straight lines\n    if (index == 25) {v1 = 153, v2=225; density=90.;}  // Squiggly, dense lines\n    if (index == 26) {v1 = 172, v2=97; density=90.;}   // Plant war\n    if (index == 27) {v1 = 85, v2=176; density=90.;}   // Going spiky black II + flashy\n    if (index == 28) {v1 = 64, v2=88; density=98.;}    // Flashy diamonds\n    if (index == 29) {v1 = 122, v2=8; density=96.;}    // Stable bg\n    if (index == 30) {v1 = 146, v2=72; density=100.;}  // Diagonal dying lines\n    if (index == 31) {v1 = 206, v2=160; density=97.;}  // Stable cracks\n    if (index == 32) {v1 = 207, v2=129; density=100.;} // Stable cracks II\n\n\n\tint i, stayVal = 128, bornVal = 128;\n\tfor (i = 0; i < 8; i++) {\n\t\tstayrules[8 - i] = ((v1 & stayVal) > 0? 1 : 0);\n\t\tstayVal = stayVal >> 1;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tbornrules[8 - i] = ((v2 & bornVal) > 0? 1 : 0);\n\t\tbornVal = bornVal >> 1;\n\t}\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_H     = 72;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 3.;\n        if( readKey(KEY_9)) speed = 12.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 232], [234, 234, 291, 291, 894]]}
{"id": "mdByWD", "name": "Tapestry 7", "author": "iterati", "description": "Hexes\nTry sides = 12 or 3", "tags": ["ifs"], "likes": 3, "viewed": 156, "published": 3, "date": "1687785902", "time_retrieved": "2024-07-30T17:47:21.601807", "image_code": "float sheen( in float d, in float x )\n{\n    return 1. - step(x, abs(d));\n}\n\nvec4 getHex(vec2 p)\n{\n    vec2 s = vec2(1, ROOT_3);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (fragCoord * 2.0 - iResolution.xy) / (iResolution.y * 0.5);\n    vec2 uv = uv0;\n    vec3 finalColor = vec3(0.0);\n    float d = 0.;\n    int sides = 6;\n    vec3 col = vec3(0.); \n    vec2 h0 = getHex(0.5 * uv).xy;\n    vec2 h = h0;\n\n    float r = sinT(iTime, 21.) * .8 + 0.2;\n    float n = sawT(iTime, 15.) * (float(sides) - 1.) + 1.;\n    float s = sinT(iTime, 45.) * 0.4 + 0.2;\n    float color = sinT(iTime, 60.);\n\n    float x = sinT(iTime, 36.) * 0.2 + 0.8;\n    const float iterations = 5.;\n    for (float i = 0.0; i < iterations; i++) {\n        float xx = x + ((sinT(iTime, 15.) - 0.5) * 0.5 * ((i + 1.) / iterations) * exp(length(uv0 * s)));\n        h = getHex(xx * ROOT_3 * h * ROT).xy;\n        d = sdStar(h, r / ROOT_3, sides, n);\n        d = sheen(d, 0.0025 * (i + 1.) * ROOT_3 / xx);\n        float cc = (1. - sawT(iTime, 29.)) * 5. * (i / iterations);\n        col = palette(mod(cc + color + (length(uv0 * 0.1) * (1. - sinT(iTime, 7.))), 1.));\n        col *= d;\n        if (col.r > 1.) {\n            col.g += 0.5 * (col.r - 1.);\n            col.b += 0.5 * (col.r - 1.);\n            col.r -= 1.;\n        }\n        if (col.g > 1.) {\n            col.r += 0.5 * (col.g - 1.);\n            col.b += 0.5 * (col.g - 1.);\n            col.g -= 1.;\n        }\n        if (col.b > 1.) {\n            col.r += 0.5 * (col.b - 1.);\n            col.g += 0.5 * (col.b - 1.);\n            col.b -= 1.;\n        }\n        finalColor += col;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n#define ROOT_3 1.7320508\nconst mat2 ROT = mat2(cos(PI / 6.), sin(PI / 6.), -sin(PI / 6.), cos(PI / 6.));\n\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( in float t, float l, float a, float b)\n{\n    return abs(cos((t / l) * a * 2. * PI) * cos((t / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdByWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 74], [76, 76, 97, 97, 349]]}
{"id": "cs2cWD", "name": "The Force Awakens", "author": "dean_the_coder", "description": "Some firsts for me:\n  - Chromatic aberration\n  - Depth of field.\n  - Lens effects.\nDisable AA in Buffer A for performance.\n  - ...and a Stormtrooper helmet. :)", "tags": ["3d", "raymarching", "starwars", "movie", "cineshader"], "likes": 48, "viewed": 1887, "published": 3, "date": "1687775856", "time_retrieved": "2024-07-30T17:47:22.780655", "image_code": "// 'The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/cs2cWD (YouTube: https://youtu.be/sFD_L59Asgg)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Some firsts for me:\n//  - Chromatic aberration\n//  - Depth of field.\n//  - Lens effects.\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - SDF fine details only modelled when ray is near a surface.\n//   - Using bump maps over SDF displacement where possible.\n//     (Displacing an SDF is much more expensive at the code is\n//     ever time the ray moves, whereas a bump is only applied once\n//     when the ray has hit a surface.)\n//   - Relax accuracy as the ray moves further away from the camera.\n//   - AA only applied on pixels where the neighbouring\n//     pixel is a significantly different color.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define CHROMATIC 0.003\n\n// Thnx Dave_Hoskins\nvec2 h22(vec2 p)\n{\n\tvec3 v = fract(p.xyx * vec3(.1031, .1030, .0973));\n    v += dot(v, v.yzx + 333.33);\n    return fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n    p += 353.627;\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat film(vec2 uv) {\n    // Film grain.\n    float c = (h21(uv * iResolution.xy) - 0.5) / 32.;\n\n    // Lens dust.\n    uv *= 4.;\n    float sm = 0.1;\n    for (int i = 0; i < 3; i++, uv++) {\n        vec2 p = fract(uv) - 0.5, id = floor(uv);\n        float s = h21(id) * sm;\n        p += h22(id) * (1.0 - sm) * 0.5;\n        c = max(c, smoothstep(s, s * 0.5, length(p)) * 0.025);\n        sm *= 0.5;\n        uv *= 2.282;\n    }\n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Chromatic aberration.\n    vec2 ca = (uv - 0.5) * CHROMATIC;\n\n    fragColor = vec4(\n                    texture(iChannel0, uv + ca).r,\n                    texture(iChannel0, uv).g,\n                    texture(iChannel0, uv - ca).ba);\n                    \n    if (fragColor.w > 0.0)\n        fragColor.rgb += film(uv * vec2(1, iResolution.y / iResolution.x));\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// 'The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/cs2cWD (YouTube: https://youtu.be/sFD_L59Asgg)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Disable if your GPU is melting.\n#define AA\t\n\n#define LIGHT_RGB\tvec3(2.4, 1.92, 1.68)\n#define R\tiResolution\n#define Z0\tmin(-t, 0.)\n#define I0\tmin(int(iTime), 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S\tsmoothstep\n#define S01(a)\tS(0., 1., a)\n\nfloat t,\n      fade = 1.;\nvec3 lp;\nstruct Hit {\n\tfloat d, id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, float id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat mul2(vec2 v) { return v.x * v.y; }\n\n///////////////////////////////////////////////////////////////////////////////\n// Hash/noise functions (Thnx Dave_Hoskins, Shane)\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat n31(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( h31(i), \n                        h31(i+vec3(1,0,0)),f.x),\n                   mix( h31(i+vec3(0,1,0)), \n                        h31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( h31(i+vec3(0,0,1)), \n                        h31(i+vec3(1,0,1)),f.x),\n                   mix( h31(i+vec3(0,1,1)), \n                        h31(i+1.0),f.x),f.y),f.z);\n}\n\nfloat n21(vec2 v) { return n31(vec3(v, 1)); }\n\n// roughness: (0.0, 1.0], default: 0.5\n// Returns unsigned noise [0.0, 1.0]\nfloat fbm2(vec2 p, int octaves, float roughness) {\n\tfloat sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n21(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\n// roughness: (0.0, 1.0], default: 0.5\n// Returns unsigned noise [0.0, 1.0]\nfloat fbm(vec3 p, int octaves) {\n\tfloat roughness = .5,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nvec3 randomPos(float seed) {\n\tvec4 s = vec4(seed, 0, 1, 2);\n\treturn vec3(h21(s.xy), h21(s.xz), h21(s.xw)) * 1e2 + 1e2;\n}\n\n// Returns unsigned noise [0.0, 1.0]\nfloat fbmDistorted(vec3 p, float distortion) {\n\tp += (vec3(n31(p + randomPos(0.)), n31(p + randomPos(1.)), n31(p + randomPos(2.))) * 2. - 1.) * distortion;\n\treturn fbm(p, 2);\n}\n\n// 2D voronoi noise.\nfloat voronoi(vec2 p) {\n\tvec2 o,\n\t     f = floor(p);\n\tp -= f;\n\tvec3 d = vec3(2);\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\to = vec2(x, y);\n\t\t\to += h22(f + o) - p;\n\t\t\td.z = dot(o, o);\n\t\t\td.y = max(d.x, min(d.y, d.z));\n\t\t\td.x = min(d.x, d.z);\n\t\t}\n\t}\n\n\treturn d.y - d.x;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Math\n// Smooth abs()\nfloat sabs(float f, float s) { return sqrt(f * f + s); }\n\n// Smooth min()\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// 1D infinite repeat.\nfloat rep(float p) { return p - .06 * floor(p / .06 + .5); }\n\n// 1D limited repeat.\nfloat repLim(float p) { return p - .07 * clamp(floor(p / .07 + .5), -4., 4.); }\n\n///////////////////////////////////////////////////////////////////////////////\n// SDFs\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p) {\n\tvec2 q = abs(p) - vec2(0, .9);\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y += clamp(-p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p) {\n\treturn length(vec2(length(p.xz) - .07, p.y)) - .005;\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Environment/textures/materials.\n\n// Plain sky color.\nvec3 skyCol(float y) { return pow(vec3(max(1. - y * .5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1); }\n\n// Sky with clouds.\nvec3 sky(vec3 rd) {\n\tvec3 p,\n\t     col = skyCol(rd.y);\n\tfloat den,\n\t      d = 5. / rd.y;\n\tif (d < 0.) return col;\n\tp = rd * d + vec3(1, .2, 1) * t * .2;\n\tp.xz *= .2;\n\tden = 1.;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.06 * fbm(p, 4));\n\n\treturn mix(col, LIGHT_RGB, S(.9, 1., den) * (1. - sat(d / 42.)));\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) / 1.73205;\n}\n\nvec3 matSand(vec3 p, inout vec3 n, inout float shine) {\n\t// Bump.\n\tfloat s = fbmDistorted(p * 2.3, 1.);\n\tn.xz += s * .3 - .15;\n\tn = normalize(n);\n\n\t// Sand color (light/stones.)\n\tshine = fbmDistorted(p * 30.3, .5) * .3;\n\tvec3 c = mix(vec3(.11, .03, .002), vec3(.75, .5, .25), S(0., .08, shine));\n\n\t// Add grains.\n\treturn mix(c, vec3(.5, .3, .2), S(.5, 1.5, voronoi(p.xz * 40.)) * (1. - sat(p.z / 2.)));\n}\n\n// Returns scratchiness. See scratches().\nfloat texScratches(vec3 p) {\n\tfloat sh = S(.85, 1., n31(p * vec3(80, 12, 1)));\n\tp.xy = p.yx * mat2(.76031, .64956, -.64956, .76031);\n\treturn max(sh, S(.85, 1., n31(p * vec3(80, 10, 1))));\n}\n\n// Return scratchiness, and apply bump to normal.\nfloat scratches(vec3 p, inout vec3 n) {\n\tconst vec3 dt = vec3(.001, 0, 0);\n\tfloat s = texScratches(p);\n\tn = normalize(n + vec3(texScratches(p + dt.xyy), texScratches(p + dt.yxy), texScratches(p + dt.yyx)) - s);\n\treturn s;\n}\n\nfloat dunes(vec3 p) {\n\tp.y += 2.;\n\tp.z -= 20.;\n\tfloat d = length(sin(p.xz * vec2(.07, .136)) * 3.5);\n\td *= S(12., -8., p.x);\n\td *= step(p.z, -15.);\n\n\t// Sand bumps.\n\tif (d < 3.) {\n\t\t// Close enough - Add detail.\n\t\tfloat s = n21(vec2(p.z + p.x, length(p.xz * 3. + vec2(500, 200))));\n\t\ts = abs(s - .5) + .2;\n\t\td -= s * .15 * S(-18., -20., p.z);\n\t}\n\n\treturn p.y - d;\n}\n\nfloat darkSand(vec3 p) {\n\tp.y += 12.97;\n\tp.z -= 2.;\n\tfloat d = length(p) - 12.05;\n\tif (d < .5) d -= abs(fbm2(p.xz * .5, 6, .55) - .5); // Close enough - Add detail.\n\treturn d;\n}\n\nfloat mountains(vec3 p) {\n\tfloat d = length(p.yz - vec2(-2, 25.3));\n\tif (d < 3.) d -= fbm2(p.xz, 3, .5) * 2.; // Close enough - Add detail.\n\treturn d * .5;\n}\n\nHit helmet(vec3 p) {\n\t// Main head.\n\tp += vec3(.7, .4, -.4);\n\tp.xy *= mat2(.90475, .42594, -.42594, .90475);\n\tp.xz *= mat2(.79608, .60519, -.60519, .79608);\n    \n\tfloat d, ox, f, isVisor,\n\t      helmet = cap(p, 1.3, 1.8 * S(-3., -1.4, p.y));\n\tif (helmet > 2.) return Hit(helmet, 3., p); // Too far away - Bail early.\n\t\n    // ...minus a bit off the chin...\n\td = smin(helmet, length(p.yz) - 2.07, -.1);\n\n\t// Top crest.\n\tox = p.x;\n\tp.x = abs(p.x);\n\td -= .07 * S(.255, .2, p.x) * S(-.1, 0., p.z + 1.);\n\n\t// Brow rim.\n\tf = S(.12, .08, abs(p.y - .2));\n\tf *= S(-.7, -.8, p.z);\n\td -= .03 * f;\n\tfloat isBlack = f * (step(abs(p.y - .2), .03) + step(abs(p.y - .14), .01));\n\n\t// Ear things.\n\tvec3 q = p;\n\tq.y += .35;\n\tq.z += .65;\n\tf = length(q.yz) - .4;\n\tf = smin(f, max(-p.z - .55, p.y - .7), .4);\n\tq.y -= 1.1;\n\tf = smin(f, box(q, vec3(3, .1, .1)) - .1, .2);\n\td = smin(d, smin(f, helmet - .025, -.03), .02);\n\tq.y += 1.1;\n\tq.z += .2;\n\tf = length(q.yz);\n\td = smin(d, smin(helmet - .06 + .01 * S(.15, .1, f), f - .15, -.05), .03);\n\tq.x -= 1.654;\n\tq.xz *= mat2(.88699, -.46178, .46178, .88699);\n\tHit h = Hit(tor(q.yxz), 7., p);\n\n\t// Cheek patches.\n\tq = p + vec3(-1.18, .7, 1.27);\n\tq.xz *= mat2(.73712, -.67576, .67576, .73712);\n\tq.yz *= mat2(.76484, -.64422, .64422, .76484);\n\tq.y -= 1. - cos(q.z);\n\tf = box(q, vec3(.05 - .003 * S01(sin(q.z * 1e2)), .08, .2)) - .05;\n\tU(h, f, 4., p);\n\n\t// Visor glass.\n\tf = sabs(pow(p.x, 1.2) * 1.1, .22) - 1.;\n\tf = S(.5, .45, abs(f * f * 1.2 + p.y * p.y * .8 + .1));\n\tf *= S(0.08, 0.06, p.y);\n\td += f * .08;\n\tisBlack += step(.01, f);\n\tisVisor = step(1., f);\n\n\t// Nose bump.\n\td -= .4 * (.4 - p.y) * pow(abs(cos(p.x * .6)), 10.) * step(p.y, .2);\n\n\t// Nose band.\n\tf = S(.1, .08, abs((p.y + 1.32) - mix(cos(p.x * 5.) + .86, p.x * p.x - .5, step(.6, p.x)) * .25));\n\tisBlack += step(.5, f);\n\td += f * .02;\n\n\t// Lower node band.\n\tf = S(.02, 0., abs(2.2 + p.y - cos(p.x * 2.2)));\n\td += f * .01;\n\n\t// Jaws.\n\tq = p;\n\tq.x = sabs(ox, .05);\n\tq += vec3(-1.28, 1.5, .9);\n\tq.yz *= mat2(.43568, .9001, -.9001, .43568);\n\tq.xy *= mat2(.76484, -.64422, .64422, .76484);\n\td = smin(d, cap(q, 1.2, .5), .2);\n\n\t// Jaw slots.\n\tq += vec3(-.33, .45, .35);\n\tq.xz *= mat2(.69671, .71736, -.71736, .69671);\n\tq.x = abs(q.x) - .09;\n\tq.y = repLim(q.y);\n\td = max(d, -box(q, vec3(.08, .03, .07)));\n\n\t// Chin vent hole.\n\tq = p;\n\tq.x = ox;\n\tq.xz *= mat2(.95141, .30791, -.30791, .95141);\n\tq.yz *= mat2(.97865, .20552, -.20552, .97865);\n\tq += vec3(.08, 2.16, 1.83);\n\td = smin(d, -cyl(q, vec2(.15, .1)), -.05);\n\tU(h, d * .9, 3. + sat(isBlack) + isVisor, vec3(ox, p.yz));\n\n\t// Chin vent inside.\n\tq.z -= .14;\n\td = cyl(q, vec2(.15, .1));\n\tf = cyl(q, vec2(.1, .2));\n\td = max(d, -f);\n\tq.y = rep(q.y);\n\tq.z += .07;\n\td = min(d, max(f, length(q.yz) - .01));\n\tU(h, d, 7., q);\n\treturn h;\n}\n\nHit sdf(vec3 p) {\n\tHit h = helmet(p);\n\tU(h, dunes(p), 1., p);\n\tU(h, mountains(p), 6., p);\n\tU(h, darkSand(p), 2., p);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float d) {\n\tfloat h = d * .05;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat s = 1.,\n\t      l = .1;\n\tfor (float i = Z0; i < 30. && l < 4.; i++) {\n\t\tfloat d = sdf(l * ld + p).d;\n\t\ts = min(s, mix(50., 7., .5) * d / l);\n\t\tl += max(.05, d);\n\t\tif (s < .1) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(mul2(.5 + .5 * ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h, float fogAdjust) {\n\tif (h.id == 0.) return sky(rd);\n\tfloat _ao, sha,\n\t      shine = 1.;\n\tvec3 c, l, skyTop, col,\n\t     ld = normalize(lp - p);\n\n\t// Calculate ambient occlusion and shadows.\n\t_ao = ao(p, n);\n\tsha = shadow(p, ld, n);\n\tif (h.id <= 2.) {\n\t\tc = matSand(p, n, shine);\n\t\tif (h.id == 2.) {\n\t\t\tc = pow(c, vec3(1.36, 1.18, 1.18)) * .9;\n\t\t\tshine *= .5;\n\t\t}\n\t}\n\telse if (h.id == 3.) {\n\t\tc = vec3(.85);\n\t\tshine = .5;\n\n\t\t// Scratches.\n\t\tfloat _ns,\n\t\t      s = scratches(p, n);\n\t\tshine += s * 4.;\n\t\tc = mix(c, vec3(.1), s);\n\n\t\t// Sand (More in corners).\n\t\ts = sat(S(.6, .8, n31(h.p * 2.)) + S(1., .8, _ao));\n\t\ts *= n31(h.p * 5.);\n\t\tc = mix(c, vec3(.5, .331, .168), s);\n\t\tshine *= 1. - s;\n\n\t\t// Blood.\n\t\tvec2 uv = h.p.xy;\n\t\tuv.y -= (cos(uv.x * 3.) - 1.) * .4;\n\t\tuv *= mat2(.92106, .38942, -.38942, .92106);\n\t\tuv.x = abs(abs(uv.x - .5) - .15) - .14;\n\t\t_ns = n21(h.p.xy * 10.);\n\t\tc = mix(c, vec3(.15 - .12 * _ns, .001, .01), S(.03, 0., box2d(uv) - .04 - .02 * (h.p.y - 1.5 * _ns)));\n\t}\n\telse if (h.id == 5.) {\n\t\tc = vec3(.01);\n\t\tshine = .8;\n\t}\n\telse if (h.id == 4.) {\n\t\tc = vec3(.02);\n\t\tshine = .2;\n\t}\n\telse if (h.id == 6.) c = vec3(.25, .2, .18);\n\telse {\n\t\tc = vec3(.2);\n\t\tshine = 5.;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\tl.x *= fakeEnv(ld * 4.); // Light mask.\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl *= sat(_ao * vec3(1.2, 1, 1)); // Ambient occlusion.\n\tl *= vec3(1, .5, .2); // Light contributions (key, reverse, sky).\n    \n\t// Apply tinted shadows.\n\tl.x *= .1 + .9 * sha;\n\tskyTop = pow(vec3(max(.5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1);\n\tc += skyTop * (1. - sha) * .5;\n\n\t// Specular (Blinn-Phong)\n\tshine *= sha; // No specular in the shadows.\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), 10.) * shine;\n\n\t// Light falloff.\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\n\t// Fresnel.\n\t// Combine the lights (key, reverse, sky).\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * skyTop) * c, skyTop, S(.6, 1., 1. + dot(rd, n)) * .25);\n\n\t// Distance Fog.\n\treturn mix(pow(vec3(max(1., 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1), col, 1. - sat(1. - exp(dot3(p - ro) / -fogAdjust * mix(1e-4, .01, .02))));\n}\n\nfloat addFade() { return min(1., abs(t)); }\n\nvec4 march(vec3 ro, vec3 rd) {\n\tt = iTime;\n\tfade = addFade();\n\tlp = vec3(6, 19, 1);\n\n\t// March the scene.\n\tvec3 n,\n\t     p = ro,\n\t     col = vec3(0);\n\tfloat i, dof, refl,\n\t      d = 1.;\n\tHit h;\n\tfor (i = Z0; i < 96.; i++) {\n\t\tif (d > 42.) {\n\t\t\th.id = 0.;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tdof = sat(d / 42.);\n\n\t// Brighten scene when facing the sun.\n\tcol += .2 * dof * LIGHT_RGB * S(.5, 1., pow(sat(dot(rd, normalize(lp))), 3.));\n\tcol += lights(p, ro, rd, n = N(p, d), h, 1.);\n\trefl = h.id == 5. ? .03 : 0.;\n\tif (refl > 0.) {\n\t\t// We hit a reflective surface, so march reflections.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < 32.; i++) {\n\t\t\tif (d > 15.) {\n\t\t\t\th.id = 0.;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += refl * (1. - col) * lights(p, ro, rd, n = N(p, d), h, .2);\n\t}\n\n\treturn vec4(pow(max(vec3(0), col), vec3(.4545)), dof);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col,\n\t     ro = vec3(0, .001, -4.8);\n\tro.xz *= mat2(.92978, -.36811, .36811, .92978);\n\n\t// View bob\n\tro += vec3(.5, .1, .1) * sin(iTime * vec3(.4, .3, .1));\n\tvec4 rgbz = march(ro, rayDir(ro, uv));\n\tcol = rgbz.rgb;\n#ifdef AA\n\tif (fwidth(col.r) > .1) {\n\t\tfor (float dx = -.5; dx <= .5; dx++) {\n\t\t\tfor (float dy = -.5; dy <= .5; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, uv + vec2(dx, dy) / R.xy)).rgb;\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n\n#endif\n\n\t// Vignette.\n\tcol *= 1. - .3 * dot(uv, uv);\n\tfragColor = vec4(col * fade, sat(rgbz.w));\n}", "buffer_a_inputs": [], "buffer_b_code": "// 'The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/cs2cWD (YouTube: https://youtu.be/sFD_L59Asgg)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUR 10.0\n#define LENS 0.005\n\nvec2 fisheye(vec2 uv) {\n    uv -= 0.5;\n    uv *= pow(dot(uv, uv), LENS);\n    return uv + 0.5;\n}\n\nfloat h31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 333.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Lens distortion.\n    uv = fisheye(uv);\n\n    // Apply basic depth of field blur.\n    vec4 col = texture(iChannel0, uv);\n    float blur = smoothstep(0.2, 0.3, col.w) * BLUR;\n    \n    if (blur > 0.0) {\n        float samples = 40.0;\n        for (float i = 0.0; i < samples; i++) {\n            float a = 3.1415 * 2.0 / samples * i;\n            //todo - rotate by constant each iteration\n            // todo - ...or use sin on vec2 to pick 2d -1...1\n            vec2 tuv = uv + vec2(blur * h31(vec3(uv, i)), 0) * mat2(cos(a), sin(a), -sin(a), cos(a)) / iResolution.xy;\n            col += texture(iChannel0, tuv);\n        }\n        \n        col /= samples + 1.0;\n    }\n    \n    fragColor = col;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2cWD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1253, 1274, 1292, 1292, 1419], [1421, 1421, 1440, 1440, 1598], [1600, 1600, 1621, 1640, 2036], [2038, 2038, 2090, 2090, 2503]]}
{"id": "ds2cWW", "name": "Chladni ispired pattern", "author": "GianC", "description": "Chladni ispired pattern", "tags": ["chladnitrippyvisual"], "likes": 1, "viewed": 196, "published": 3, "date": "1687772687", "time_retrieved": "2024-07-30T17:47:25.252048", "image_code": "#define PI 3.14159265359\nfloat modFloat(float a, float b) {\n  return a - b * floor(a / b);\n}\nvec4 invertColor(vec4 color) {\n    return vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, color.a);\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.26,0.516,0.357);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n      vec2 uv0 = uv;\n\n    uv=fract(uv)-0.5;\n    float t=iTime/1.0;\n    for (float i = 0.0; i < 3.0; i++) {\n    float n= PI*(4.0+15.0*sin(t/20.0)*cos(t/10.0))*i;\n    float m=PI*(2.0+12.0*sin(t/10.0)*cos(t/10.0))*i;\n    float v= cos(n*uv0.x)* cos(m*uv0.y) - cos(m*uv0.x) *cos(n*uv0.y);\n    float th=step(0.1,v);\n    \n    // Time varying pixel color\n    vec3 col = palette(v);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n        invertColor(fragColor);\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2cWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 59, 59, 92], [93, 93, 123, 123, 196], [197, 197, 222, 222, 405], [407, 407, 464, 515, 1040]]}
{"id": "csByDm", "name": "Rainbow Planet", "author": "ufffd", "description": "", "tags": ["alien", "rainbow", "mirror", "pride"], "likes": 9, "viewed": 325, "published": 3, "date": "1687753809", "time_retrieved": "2024-07-30T17:47:26.637344", "image_code": "// used for video render or beastly gpu\n// #define HI_QUALITY\n// uncomment this if your pc is strugglin\n//#define LO_QUALITY\n// common vals\n#define PI 3.1415927\n#define EPSILON 0.0001\n// implement quality options\n#ifdef HI_QUALITY\n    #define STEP_MAX 600.\n    #define DIST_MAX 35.\n    #define STEP_FAC 0.4\n#elif defined(LO_QUALITY)\n    #define STEP_MAX 100.\n    #define DIST_MAX 20.\n    #define STEP_FAC 1.\n#else\n    #define STEP_MAX 160.\n    #define DIST_MAX 35.\n    #define STEP_FAC 0.7\n#endif\n// RAY_MAX > 1 is pretty busted currently\n#define RAY_MAX 1.\n#define SPECULAR_POWER 100.\n#define SPECULAR_INTENSITY .5\n\n// \n#define PRIDE\n\n// define textures\n// note: most of these are unused\nstruct Tex {\n    vec3  c; // color\n    float m; // mirror\n    float r; // rough\n};\n// tex setup. takes object and global position as inputs\nTex T1(in vec3 p, in vec3 gp) {\n    // green, nonreflective\n    Tex T;\n    T.c = vec3(0.,1.,0.);\n    T.m = 0.;\n    return T;\n}\nTex T2(in vec3 p, in vec3 gp) {\n    // black and white stripes\n    // the black part is reflective\n    Tex T;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x + sin(p.z*-.5)));\n    stripes = SS(0.,0.01,stripes);\n    T.c = vec3(stripes);\n    T.m = 1.-stripes;\n    return T;\n}\nTex T3(in vec3 p, in vec3 gp) {\n    // show position\n    Tex T;\n    T.c = normalize(p);\n    T.m = 0.;\n    return T;\n}\nTex T4(in vec3 p, in vec3 gp) {\n    // black mirror\n    Tex T;\n    T.c = vec3(.001);\n    T.m = .8;\n    return T;\n}\nTex T5(in vec3 p, in vec3 gp) {\n    // white mattte\n    Tex T;\n    T.c = vec3(1.);\n    T.m = .0;\n    return T;\n}\nTex T6(in vec3 p, in vec3 gp) {\n    // voronoi\n    Tex T;\n    T.c = voronoi(gp*.5 - iTime).rrr * voronoi(gp*3. - iTime) * voronoi(gp*8. - iTime);\n    T.c = mix(T.c, vec3(0.,1.8,1.),gp.y/3.);\n    T.c = clamp(vec3(0.),vec3(1.),T.c);\n    T.c = hueShift(T.c, T.c.g*8.);\n    T.c.g -= 0.5;\n    T.c = hueShift(T.c, noise(gp*2. + iTime*0.1)*3.);\n    T.m = 0.;\n    return T;\n}\nTex T7(in vec3 p, in vec3 gp) {\n    // horiz stripes\n    Tex T;\n    T.c = vec3(smoothstep(0.,0.01,sin(p.y*40.)));\n    T.m = 0.;\n    return T;\n}\nvec3 rainbowSmooth(float x, float k){\n    // return vec3(1.);\n    vec3 r1 = vec3(1.,0.,0.)*1.;\n    vec3 r2 = vec3(1.,.5,0.)*1.;\n    vec3 r3 = vec3(1.,1.,0.)*1.;\n    vec3 r4 = vec3(0.,.5,0.)*1.;\n    vec3 r5 = vec3(0.,0.,1.)*1.;\n    vec3 r6 = vec3(.5,0.,.5)*1.;\n    x = fract(x+0.5/6.);\n\t\n\tfloat level = x * 6.0;\n    // float mixamt = fract(level); // full linear mix\n    float mixamt = smoothstep(0.5-k,0.5+k,fract(level)); // smoothstep\n    vec3 col = vec3(0.);\n    if (level<1.) col = mix(r1,r2,mixamt);\n    else if (level<2.) col = mix(r2,r3,mixamt);\n    else if (level<3.) col = mix(r3,r4,mixamt);\n    else if (level<4.) col = mix(r4,r5,mixamt);\n    else if (level<5.) col = mix(r5,r6,mixamt);\n    else if (level<6.) col = mix(r6,r1,mixamt);\n    return col;\n}\nTex T8(in vec3 p, in vec3 gp) {\n    // rainbow stripes with mirrors\n    Tex T;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x + sin(p.z*-.5)));\n    vec3 rb = rainbowSmooth(0.2+1.06*(p.x+sin(p.z*-.5)), 0.2);\n    stripes = SS(0.,0.1,stripes);\n    stripes = stripes*0.8 + 0.2; // glowy rainbow on the mirrors - disable for cleaner color palette (ie for printing)\n    rb *= stripes;\n    \n    T.c = rb;\n    T.m = 1.-stripes;\n    return T;\n}\nTex T9(in vec3 p, in vec3 gp) {\n    // horiz rainbow stripes\n    Tex T;\n    T.c = rainbowSmooth(-p.y*3.,0.025);\n    T.m = 0.;\n    return T;\n}\n// structs for abstracting march process\nstruct MapData {\n    vec4  c; // color\n    float d; // distance\n    float m; // mirror\n    bool  h; // hit\n};\nstruct MarchData {\n    vec4  c; // color\n    vec3  p; // intersection point\n    float d; // distance\n    float s; // steps\n    bool  h; // hit\n    // bounces\n    // attenuation\n    // steps in this bounce\n};\nvoid drawTex(in vec3 p, in vec3 gp, inout MapData m, int tx) {\n    Tex T;\n    if (tx==1) T = T1(p,gp);\n    if (tx==2) T = T2(p,gp);\n    if (tx==3) T = T3(p,gp);\n    if (tx==4) T = T4(p,gp);\n    if (tx==5) T = T5(p,gp);\n    if (tx==6) T = T6(p,gp);\n    if (tx==7) T = T7(p,gp);\n    if (tx==8) T = T8(p,gp);\n    if (tx==9) T = T9(p,gp);\n    float color_mix = 1.; // this should be set based on material & incidence angle\n    m.c = vec4(T.c,color_mix);\n    m.m = T.m;\n}\n// 3d scene\nvoid addObject(in float sdf, in int tx, in vec3 p, in vec3 gp, inout MapData m) {\n    m.h = m.h || sdf < EPSILON; // register hit\n    if (sdf < m.d) { // this is the closest object so far\n        m.d = sdf;\n        if (m.h) drawTex(p,gp,m,tx);\n    }\n}\nMapData map(in vec3 p) {\n    // returns distance to nearest surface from a given point in 3d space\n    MapData m;\n    m.d = 9999.; // start high, use min(d,x) to add geometry to scene\n    m.m = 0.; // no reflective surfaces yet\n    m.h = false; // no surfaces at all yet really\n    m.c = vec4(0.); // sure is dark in here...\n    \n    // base gyroid\n    float gy1 = sdGyroid(p, pow(p.y,.125) - p.y*.2 - 2.);\n    int gyroid_mat = 7; // 6\n    #ifdef PRIDE\n        gyroid_mat = 9;\n    #endif\n    // if (cell_rand > 0.5) gyroid_mat = 5;\n    addObject(gy1, gyroid_mat, sin(p*0.5), p, m);\n    \n    \n    // ground/floor plane\n    float ground = p.y;\n    \n    vec3 gy1_1p = p;\n    // gy1_1p.y = floor(gy1_1p.y*10.)/10.;\n    float gy1_1 = sdGyroid(gy1_1p, -1.4 * p.y);\n    // ground = smin(ground, gy1_1, 0.2);\n    ground = fOpUnionStairs(ground, gy1+p.y-.5, .5, 10.);\n    // addObject(gy1_1, gy1_1mat, p, p, m);\n    int ground_mat = 2;\n    #ifdef PRIDE\n        ground_mat = 8;\n    #endif\n    addObject(ground, ground_mat, p, p, m);\n    // orbs\n    // float orbs = sdOrb(p, 1.4);\n    // int orbs_mat = 3;\n    // if (cell_rand > 0.5) gyroid_mat = 5;\n    // addObject(orbs, orbs_mat, p, p, m);\n    \n    vec3 orbonoi = voronoi(p/2.);\n    float orbs = orbonoi.x - .3*pow(hash11(orbonoi.z),3.);\n    int orbs_mat = 2;\n    #ifdef PRIDE\n        orbs_mat = 8;\n    #endif\n    addObject(orbs, orbs_mat, p, p, m);\n        \n    return m;\n}\nvec3 getNorm(vec3 p, float spread) { \n    float d = map(p).d; // Distance\n    vec2 e = vec2(.02*spread,0); // Epsilon\n    vec3 n = d - vec3(\n        map(p-e.xyy).d,  \n        map(p-e.yxy).d,\n        map(p-e.yyx).d);   \n    return normalize(n);\n}\nvec3 getNorm(vec3 p) {\n    return getNorm(p, 0.005); // default spread\n}\n\n\n// raymarch\nMarchData raymarch(in vec3 ro, in vec3 rd) {\n    MarchData d;\n    d.h = false;\n    d.d = 0.;\n    d.c = vec4(0.);\n    float atten = 1.;\n    int bounces = 0;\n    for (d.s=0.;d.s<STEP_MAX&&d.d<DIST_MAX;d.s++) {\n        vec3 p = ro + rd*d.d;\n        MapData m = map(p);\n        if (m.h) { // hit\n            d.h = true; // record hit\n            d.p = p; // hit location\n            d.c.rgb += m.c.rgb*m.c.a*atten; // l.o.l adds hit color to return color\n            if (m.m<0.01) break; // if not a mirror, we're done\n            // else, we hit a mirror. reflect and keep steppin\n            bounces++;\n            if (bounces>2) break;\n            atten *= m.m; // - step(.5,p.y);\n            vec3 n = getNorm(p);\n            rd = reflect(rd, n);\n            d.d = 0.;\n            // d.c = vec4(n,1.); break; // debug\n            ro = p + rd*EPSILON; // step away from surface\n        } else\n            d.d += m.d*STEP_FAC; // * .5; // halfstep riddim\n    }\n    return d;\n}\nfloat nnoise2(in vec3 x) { // -1 to 1\n    float nn = noise(x)*2.-1.;\n    return nn*nn; // curved\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // setup\n    vec2 R = iResolution.xy;\n    vec2 uvc = (fragCoord-R/2.)/R.y;\n    vec3 col = vec3(0.);\n    float t = iTime;\n    // t = 44.06;\n    float carloop = mod(t*2.-2.2,101.);\n    vec3 carpos = vec3(sin(t*0.3)+2.,.5,t*0.5);\n    carpos.y -= smoothstep(32.,40.,carloop) - smoothstep(70.,80.,carloop);\n    vec3 sideview = vec3(iMouse.xy/R,-1.);\n    // vec3 ro = iMouse.z>0.?sideview:carpos;\n    vec3 ro = carpos;\n    float fov = 0.6;\n    vec3 rd = normalize(vec3(uvc,fov));\n    \n    if (iMouse.z>0.) {\n        vec2 muv = (iMouse.xy - R/2.) / R.y;\n        rd.yz = rotate(rd.yz,muv.y);\n        rd.xz = rotate(rd.xz,muv.x);\n    } else {\n        // rd.yz = rotate(rd.yz,-0.5);\n        float lookdown = smoothstep(29.,33.,carloop) - smoothstep(36.,41.,carloop);\n        lookdown += smoothstep(70.,73.,carloop) - smoothstep(71.,81.,carloop);\n        rd.yz = rotate(rd.yz,-lookdown);\n        float twist = smoothstep(35.,45.,carloop) + smoothstep(75.,85.,carloop);\n        rd.xy = rotate(rd.xy, twist*PI);\n        \n        rd.yz = rotate(rd.yz,nnoise2(vec3(t*0.1+20.)));\n        rd.xz = rotate(rd.xz,nnoise2(vec3(t*0.1+80.)));\n        // cam jitter - i'm preferring smooth look\n        // rd.yz = rotate(rd.yz,nnoise(vec3(iTime*2.))*0.01);\n        // rd.xz = rotate(rd.xz,nnoise(vec3(iTime*2.1+100.))*0.01);\n        if (ro.y<0.) {\n            rd.y *= -1.;\n            ro.y *= -1.;\n        }\n    }\n    \n    // raymarch\n    for (float M=0.;M<RAY_MAX;M++) { // multiple rays per pixel\n        ro += hash31(M)/100000000.; // randomize\n        MarchData d = raymarch(ro,rd);\n        vec3 raycol = d.c.rgb;\n        // col = vec3(1./d.d, d.s/STEP_MAX, float(d.h)); // debug march data\n        // col = vec3(d.d);\n        // lighting - should all of this happen within raymarch for each intersection? probably\n        vec3 n = d.h?getNorm(d.p):vec3(0,0,1);\n        n += hash33(d.p*100.)*.005; // scatter - ought to be based on material roughness\n        vec3 bounceAngle = reflect(rd,n); \n\n        float amb = d.h?0.001:0.; // add ambient light for all hit pixels\n\n        vec3 light1pos = vec3(d.p+1.);\n        vec3 light1dir = normalize(light1pos-d.p);\n        vec3 light2pos = vec3(d.p-vec3(.5,.9,1.));\n        vec3 light2dir = normalize(light2pos-d.p);\n        \n        float diff1 = max(0.0, dot(n, light1dir)) * 1.;\n        float spec1 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light1result = diff1 + spec1;\n        \n        float diff2 = max(0.0, dot(n, light2dir)) * 1.;\n        float spec2 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light2result = diff2 + spec2;\n\n        raycol *= vec3(amb + light1result + light2result); // apply lighting\n        // raycol = vec3(amb + light1result + light2result); //d.c.rgb;\n        col += raycol;\n        // col = vec3(1./d.d);\n    }\n    col /= RAY_MAX;\n    // post fx\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define SS(a,b,c) smoothstep(a-b,a+b,c)\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// sdfs\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdOrb(vec3 p, float b) {\n  return length(p) - b;\n}\nfloat sdGyroid(vec3 p, float b) {\n    float g = dot(sin(p),cos(p.yzx));\n    return g - b;\n}\n// sdf ops\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\n// hash - rand - noise\n//--------------------\n// 1 out, 1 in\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n//\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n//\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n\n\n// iq box intersect\nfloat boxIntersect( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return tF;\n}\n\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csByDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[776, 833, 864, 892, 959], [960, 960, 991, 1058, 1246], [1247, 1247, 1278, 1299, 1364], [1365, 1365, 1396, 1416, 1479], [1480, 1480, 1511, 1531, 1592], [1593, 1593, 1624, 1639, 1960], [1961, 1961, 1992, 2013, 2104], [2105, 2105, 2142, 2166, 2867], [2868, 2868, 2899, 2935, 3317], [3318, 3318, 3349, 3378, 3459], [3819, 3819, 3881, 3881, 4285], [4286, 4298, 4379, 4379, 4549], [4550, 4550, 4574, 4648, 5966], [5967, 5967, 6003, 6003, 6212], [6213, 6213, 6235, 6235, 6285], [6288, 6300, 6344, 6344, 7273], [7274, 7274, 7300, 7311, 7372], [7373, 7373, 7430, 7443, 10598]]}
{"id": "ddjyWD", "name": "Zillij inspired mosaic", "author": "etdeagle", "description": "Using a xor of triangles technique discussed in https://www.shadertoy.com/view/mdsyWf", "tags": ["xor", "mosaic", "geometric", "zillij"], "likes": 5, "viewed": 132, "published": 3, "date": "1687735394", "time_retrieved": "2024-07-30T17:47:27.462139", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nvec3 xorCols(vec3 col0, vec3 col1) {\n    vec3 col = vec3(int(col0.x * 255.0) ^ int(col1.x * 255.0),\n    int(col0.y * 255.0) ^ int(col1.y * 255.0),\n    int(col0.z * 255.0) ^ int(col1.z * 255.0));\n    return col / 255.0;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec3 rgb_to_hsl(vec3 rgb) {\n    vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n    float fmin = min(min(rgb.r, rgb.g), rgb.b);    //Min. value of RGB\n    float fmax = max(max(rgb.r, rgb.g), rgb.b);    //Max. value of RGB\n    float delta = fmax - fmin;             //Delta RGB value\n\n    hsl.z = (fmax + fmin) / 2.0; // Luminance\n\n    if (delta == 0.0)\t\t//This is a gray, no chroma...\n    {\n        hsl.x = 0.0;\t// Hue\n        hsl.y = 0.0;\t// Saturation\n    }\n    else                                    //Chromatic data...\n    {\n        if (hsl.z < 0.5)\n            hsl.y = delta / (fmax + fmin); // Saturation\n        else\n            hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n        float deltaR = (((fmax - rgb.r) / 6.0) + (delta / 2.0)) / delta;\n        float deltaG = (((fmax - rgb.g) / 6.0) + (delta / 2.0)) / delta;\n        float deltaB = (((fmax - rgb.b) / 6.0) + (delta / 2.0)) / delta;\n\n        if (rgb.r == fmax)\n            hsl.x = deltaB - deltaG; // Hue\n        else if (rgb.g == fmax)\n            hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n        else if (rgb.b == fmax)\n            hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n        if (hsl.x < 0.0)\n            hsl.x += 1.0; // Hue\n        else if (hsl.x > 1.0)\n            hsl.x -= 1.0; // Hue\n    }\n\n    return hsl;\n}\n\n\nvec3 drawTriangle(in vec2 suv, in vec2 rot, in float side) {\n\n    // Create triangle vertices in local coordinates\n    float height = sqrt(side * side - (side * side / 4.0));\n    vec2 p1 = vec2(-side / 2.0, 0);\n    vec2 p2 = vec2(0, height);\n    vec2 p3 = vec2(side / 2.0, 0);\n\n    // Rotate and translate vertices\n    /*p1 = vec2(dot(p1, rot), dot(p1, vec2(-rot.y, rot.x)));\n    p2 = vec2(dot(p2, rot), dot(p2, vec2(-rot.y, rot.x)));\n    p3 = vec2(dot(p3, rot), dot(p3, vec2(-rot.y, rot.x)));*/\n\n\n    p1 = vec2(p1.x * rot.x - p1.y * rot.y, p1.x * rot.y + p1.y * rot.x);\n    p2 = vec2(p2.x * rot.x - p2.y * rot.y, p2.x * rot.y + p2.y * rot.x);\n    p3 = vec2(p3.x * rot.x - p3.y * rot.y, p3.x * rot.y + p3.y * rot.x);\n\n    // Compute barycentric coordinates\n    /*vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1;*/\n    \n     vec2 barycenter = (p1 + p2 + p3) / 3.0;\n    \n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1 + barycenter;\n    \n    \n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float dot13 = dot(v1, v3);\n    float dot22 = dot(v2, v2);\n    float dot23 = dot(v2, v3);\n    float invDenom = 1.0 / (dot11 * dot22 - dot12 * dot12);\n    float u = (dot22 * dot13 - dot12 * dot23) * invDenom;\n    float v = (dot11 * dot23 - dot12 * dot13) * invDenom;\n    vec2 uv = vec2(u, v);\n\n    vec3 col = vec3(0);\n    if ((uv.x >= 0.0) && (uv.y >= 0.0) && (uv.x + uv.y < 1.0)) {\n        // col = vec3(uv.x, uv.y, 1.0 - uv.x  - uv.y * uv.y);\n\n        float t1 = uv.x;// * 2.0  + uv.y;\n        float t2 = uv.y;// * 2.1 + uv.x;\n\n        float x = (1.0 + pow(sin(t1 * sin(t1 * 8.0) + pow(sin(t1 * t1), 1.) * 5.0), 2.0)) / 2.0;\n        float y = (1.0 + cos(cos(t2) * 18.0)) / 2.0;\n        float z = 1.0 - x * x - y * x;\n        //col = rgb_to_hsl(vec3(x + y * x + z * x / 3.0 + z / 2.0, 0.7, x * y + y * z));\n        //col = rgb_to_hsl(vec3(uv.x, uv.y, 1.0 - uv.x - uv.y));\n        //col = vec3(uv.x, uv.y, 1.0 - uv.x - uv.y);\n        col = vec3(1.0);\n    }\n    return col;\n}\n\n\n\nvec3 xorTriangles(in vec2 suv0, in vec2 rot0, in float side0, in vec3 col0,\n                  in vec2 suv1, in vec2 rot1, in float side1, in vec3 col1) {\n\n    vec3 cola = drawTriangle(suv0, rot0, side0);\n    vec3 colb = drawTriangle(suv1, rot1, side1);\n    \n    if (cola.x == 0.0) {\n        cola = col0;\n    }\n    \n    if (colb.x == 0.0) {\n        colb = col1;\n    }\n    \n    vec3 col = xorCols(cola, colb);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Create a circle\n    float r = length(uv);\n    if(r < 6.0) {\n        float a = atan(uv.y, uv.x);\n        vec2 suv = vec2(cos(a), sin(a)) * r;\n        vec2 rot = vec2(cos(2.0 * PI / 6.0), sin(2.0 * PI / 6.0));\n        float side = 1.2;\n        vec2 rot3 = vec2(1.0, 0);\n        vec2 rot4 = vec2(-1.0, 0);\n\n\n        float t0 = 1.0;\n        float t1 = 1.4;\n        float t2 = 1.5;\n        float t3 = 1.8;\n\n        vec3 turquoise = vec3(71., 224., 204.) / 255.0;\n        vec3 ochre = vec3(239., 192., 102.) / 255.0;\n        vec3 blue = vec3(24., 88., 178.) / 255.0;\n        vec3 green = vec3(10, 81, 51) / 255.0;\n        // make a list with all the colors\n\n        vec3 colors[6];\n        // some nice colors to swap arounc\n        colors[0] = vec3(0.14461228,0.15513487,0.27088341);\n        colors[1] = vec3(0.87665264,0.56123238,0.49973392);\n        colors[2] = vec3(0.06986726,0.44971911,0.75165264);\n        colors[3] = vec3(1.00000000,0.85636869,0.50259627);\n        colors[4] = vec3(0.97761418,0.93624878,0.73902827);\n        colors[5] = vec3(0.16251525,0.29011418,0.25204154);\n\n        // pick six random colors col00, col01, col10, col11, col20, col21 from truquoise, ochre, blue, green\n        vec3 col00 = vec3(0.14461228,0.15513487,0.27088341);\n        vec3 col01 = vec3(0.14461228,0.15513487,0.27088341);\n\n\n\n        vec3 colx = vec3(0.00000000,0.00000000,0.00000000);\n        int rings =5;\n        int ngon = 4;\n        side = 0.9;\n        for(int i = 0; i < rings; i++) {\n            t0 = 0.4+float(i) / 3.0;\n\n            for(int j = 0; j < ngon ; j++) {\n                vec2 localRot = vec2(cos(float(j) * 2.0 * PI / float(ngon)), sin(float(j) * 2.0 * PI / float(ngon)));\n                colx = xorCols(colx, xorTriangles(suv, rot3, side * t0, col00,\n                                                  suv, localRot, side * t0, col01));\n            }\n        }\n        col = colx;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 89, 89, 273], [276, 276, 296, 296, 366], [369, 369, 396, 396, 1707], [1710, 1710, 1770, 1824, 3727], [3731, 3731, 3884, 3884, 4156], [4158, 4158, 4215, 4215, 6317]]}
{"id": "cd2cDD", "name": "Star Nest golfed version", "author": "superhit", "description": "code was taken from comment to https://www.shadertoy.com/view/XlfGRj\n--------------\n2023-09-24 updated according to FabriceNeyret2's comment ;) (524 chars)", "tags": ["math", "star", "space"], "likes": 11, "viewed": 285, "published": 3, "date": "1687727305", "time_retrieved": "2024-07-30T17:47:28.236069", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tfloat t = iTime*.01+.25, s=.1, f=1. ,a,l;\n\tvec3  R = iResolution,p,\n\t      D = vec3( ( u+u - R.xy ) / R.x*.2 , .5 ),\n          M = 2.*iMouse.xyz/R,\n          o = vec3(1,.5,.5) + vec3(t+t, t, -2);\n    O *= 0.;\n\tmat2 r1 = rot(.5+M.x),\n\t     r2 = rot(.8+M.y);\n\tD.xz *= r1; o.xz *= r1;\n\tD.xy *= r2; o.xy *= r2;\n\t\n\tfor (int i,r; r++<20; f*=.73, s+=.1 ) {\n\t\tp = abs( mod( o + s*D ,1.7) -.85 );\n\t\ta=t=0.;\n\t\tfor ( i=0; i++<17; t=l )\n\t\t\tl = length( p= abs(p)/dot(p,p) - .53 ),\n\t\t\ta += abs(l-t);\n\n\t\ta *= a*a;\n\t\tr>7 ? f *= min(1., .7 + a*a/1e3 ) : f; \n\t\tO.rgb += f + s*vec3(1,s,s*s*s)*a*.0015*f; \n\t}\n\t\n\tO = .0085*O + .0015*length(O);\t\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2cDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 716]]}
{"id": "DsjcWD", "name": "CheckerboardNeon", "author": "Rayfbie", "description": "Based on the youtube video by Kishimisu", "tags": ["checkerboard", "rainbow", "neon"], "likes": 6, "viewed": 199, "published": 3, "date": "1687722926", "time_retrieved": "2024-07-30T17:47:29.007008", "image_code": "vec3 pallete(float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c*t+d));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n        \n    float zoom = (0.8 + 0.2 * sin(iTime));\n    //uv *= zoom;\n        \n    float d = length(uv);\n    vec3 col = pallete(d);\n    \n    d = sin(d * 8.0 + iTime)/8.0;\n    d = abs(d);\n    d = 0.02 / d;\n    \n    \n    col *= d;\n\n    vec2 pos = floor(fragCoord / 10.0);\n    float pattern = mod(pos.x + mod(pos.y, 2.0), 2.0);\n    fragColor = zoom * (zoom * pattern * vec4(1.0, 1.0, 1.0, 1.0) + vec4(col, 1.0));\n    //fragColor = pattern * vec4(1.0, 1.0, 1.0, 1.0);\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(pos, 1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 213], [215, 215, 272, 272, 961]]}
{"id": "dssyzH", "name": "Year of Truchets #043", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \nsmoothstep on my sine wave", "tags": ["raymarching", "reflection", "truchet"], "likes": 26, "viewed": 242, "published": 3, "date": "1687708963", "time_retrieved": "2024-07-30T17:47:29.862720", "image_code": "/**\n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #043\n    06/25/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.1415926\n#define PI2         6.2831853\n\n#define MIN_DIST    1e-3\n#define MAX_DIST 55.\n\n// constants\nconst float size = 1.5;\nconst float hlf = size*.5;\nconst float grid = 1.;\n\nvec3 hit,hitPoint;\nmat2 r45;\nfloat speed;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq sdf & extrude\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n    pos-=vec3(1,.1,-speed);\n\n    vec2 uv = pos.xz;\n    vec2 id = vec2(floor((uv.x+hlf)/size)-grid,floor((uv.y+hlf)/size));\n    vec2 q = vec2(uv.x-size*clamp(round(uv.x/size),-grid,grid),mod(uv.y+hlf,size)-hlf);\n    \n    vec3 pp = vec3(q.x,pos.y,q.y);\n    vec3 pr = vec3(pos.xy,q.y);\n    \n    float rnd = hash21(id);\n    if (rnd>.5) q.x = -q.x; \n    rnd = fract(rnd*32.78);\n    \n    float mv = .06+.05*sin(pos.z*.4), mx = mv*1.5;\n    const vec3 b2 = vec3(1.,.15,hlf);\n\n    vec2 spc = vec2(-hlf,.0);\n    vec2 p2 = vec2(length(q+spc),length(q-spc));\n    vec2 pq = p2.x<p2.y? q+spc : q-spc;\n\n    pq *= r45;\n\n    float d = length(pq.x);\n    if(rnd>.675) d = min(length(q.x),length(q.y));\n\n    d = abs(d)-mv;\n\n    float sw = .35+.25*sin(pos.z*.45-T*.75);\n    sw = smoothstep(.2,.5,sw);\n    \n    float pl = length(vec2(abs(q.x)-hlf,q.y))-(mx);\n          pl = min(length(vec2(q.x,abs(q.y)-hlf))-(mx),pl);\n\n    float d3 = opx(d,pos.y-sw,sw);\n    float ct = box(pp,vec3(hlf,5,hlf));\n    d3=max(max(d3,ct),-(pl));\n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit = pos-vec3(0,sw,0);\n    }\n    \n    sw += .02;\n    float pole = opx(pl,pos.y-sw, sw);\n    if(pole<res.x) {\n        res = vec2(pole,3.);\n        hit = pos;\n    }\n\n    float gnd = box(pp+vec3(0,b2.y+.05,0),b2);\n    if(gnd<res.x) {\n        res = vec2(gnd,1.);\n        hit = pp;\n    }\n    \n    float wll = box(pr-vec3(8.3,15,0),vec3(.1,17,b2.x));\n    if(wll<res.x) {\n        res = vec2(wll,6.);\n        hit = pos;\n    }\n    \n    float flr = pos.y+.275;\n    if(flr<res.x) {\n        res = vec2(flr,6.);\n        hit = pos;\n    }\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<128;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<64?ray.x*.35:ray.x*.9;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 FC = vec3(0.114,0.169,0.227);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv, float loop) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n    hitPoint = hit;  \n\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST)\n    {\n             p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-6.,12.,12.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.25);\n\n        if(m==1.) {\n            float pz = (p.z+speed);\n            vec3 k = hsv2rgb(vec3(pz*.02,.95,.35));\n            vec2 ft = fract((vec2(p.x,pz)*4.+vec2(T*.2,0))*r45)-.5;\n            float fmod = mod(floor(ft.x),3.);\n            h = mix(k,vec3(.075),fmod==0.?1.:0.);\n            ref = fmod==0.?vec3(0.):k;\n        }\n        if(m==2.) { \n            h = hsv2rgb(vec3(hitPoint.z*.02,1.,.3)); \n            ref = h; \n        }\n        if(m==3.) { h = vec3(.15); ref = h; }\n        if(m==5.) { \n            h = hsv2rgb(vec3(-hitPoint.z*.02,.75,.3)); \n            ref = h; \n        }\n        if(m==6.) { \n            vec3 f = fract((hitPoint+vec3(0,.275,0))*.5)-.5;\n            h = vec3(.65);\n            if(f.x*f.y*f.z>.0)h=vec3(.55);\n            ref = h*.5; \n        }\n        \n        C = (diff*h);\n        if(loop==0.) C = mix(FC,C,exp(-.000015*d*d*d*d));\n         \n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } \n\n    return vec4(C,d);\n}\n\nmat2 rx,ry;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    r45 = rot(.78539816);\n    speed = T*1.05; \n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,.75,7);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z <0. ? .0 : (M.y/R.y * .4-.2)*PI;\n    float y = M.xy==vec2(0) || M.z <0. ? .0 : (M.x/R.x * .6-.3)*PI;\n\n    float ff = .35+.25*cos(T*.035), fx = .6*sin(T*.065);\n\n    rx = rot(-(.25+ff)-x), ry = rot(-1.85-fx-y);\n    \n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref = vec3(0), fil = vec3(.95);\n    float d =0., a = 0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<3.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv, i);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC,C,exp(-.000015*a*a*a*a));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssyzH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[507, 507, 525, 525, 569], [570, 570, 594, 594, 652], [654, 674, 702, 702, 787], [788, 788, 837, 837, 933], [935, 935, 954, 954, 2582], [2584, 2653, 2683, 2683, 2907], [2909, 2909, 2941, 2941, 3168], [3170, 3184, 3211, 3211, 3323], [3360, 3360, 3455, 3455, 5147], [5161, 5161, 5202, 5202, 6102]]}
{"id": "mdByWW", "name": "Discrete Land", "author": "beans_please", "description": "Playing with integer coordinates", "tags": ["math", "discrete", "maths", "integer", "integers"], "likes": 5, "viewed": 159, "published": 3, "date": "1687704350", "time_retrieved": "2024-07-30T17:47:30.853072", "image_code": "vec3 eval(vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float scale = map_range(cos(TWO_PI * iTime * 0.05), -1.0, 1.0, 150.0, 35.0);\n    vec2 discrete = floor(uv * scale);\n    \n    int method = int(iTime / 1.2) % 5;\n    \n    bool b = false;\n    vec3 col;\n\n    switch (method) {\n    case 0:\n        b = fract(discrete.x * discrete.x / discrete.y) == 0.0;\n        col = vec3(0.01, 0.6, 0.7);\n        break;\n    case 1:\n        b = fract(sqrt(discrete.x * discrete.y)) < 0.01;\n        col = vec3(0.7, 0.55, 0.3);\n        break;\n    case 2:\n        b = fract(sqrt(abs(discrete.x * discrete.y))) > 0.95;\n        col = vec3(0.2, 0.6, 0.9);\n        break;\n    case 3:\n        b = cos(discrete.x * discrete.y / 6.0) > 0.95;\n        col = vec3(0.45, 0.6, 0.25);\n        break;\n    case 4:\n        b = fract(log(abs(discrete.x * discrete.y)) * sin(discrete.x)) < 0.05;\n        col = vec3(0.8, 0.35, 0.6);\n        break;\n    }\n    \n    return b ? col : 0.04 * pow(col, vec3(4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Jitter sampling\n    const int numSamples = 32;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < numSamples; i++)\n    {\n        col += eval(fragCoord + vec2(random() - 0.5, random() - 0.5));\n    }\n    col /= float(numSamples);\n    \n    // Noise\n    eprng_init((floor(fragCoord.xy / 2.0) * 2.0) / max(iResolution.x, iResolution.y), floor(iTime * 15.0) / 15.0);\n    float noiseAmount = pow(sin(PI * rgb_max(col)), 2.0);\n    noiseAmount = map_range(noiseAmount, 0.0, 1.0, 0.01, 1.0);\n    col += noiseAmount * map_range(random(), 0.0, 1.0, -0.05, 0.1);\n    \n    // Vignette\n    float dist = length((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    col = pow(col, vec3(map_range_clamp(dist, 0.7, 6.0, 1.0, 4.0)));\n    col *= pow(2.0, map_range_clamp(dist, 0.75, 4.0, 0.0, -5.0));\n    \n    // OETF\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdByWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 1073], [1075, 1075, 1130, 1153, 2102]]}
{"id": "csSyDD", "name": "[RMO] - octahedron", "author": "silica163", "description": "octahedron sdf", "tags": ["raymarch", "octahedron"], "likes": 4, "viewed": 128, "published": 3, "date": "1687701615", "time_retrieved": "2024-07-30T17:47:31.780592", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    oc[0].p = vec4(0,0,0,1);\n    \n    l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[1].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    c += render(r); \n    \n    //c = N*.5+.5;\n    //c = r.p;\n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  50.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\n#define rotX(a) mat3(      1, 0,       0, 0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n\nconst int LIGHTS = 2;\nconst int OCTS  = 1;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nstruct Octahedron {\n    vec4 p;\n    vec3 c;\n},oc[OCTS];\n\nfloat octahedronSDF(vec3 p,int id){\n    Octahedron o = oc[id];\n    float d;\n    \n    p = abs(p-o.p.xyz);\n    float face = p.x+p.y+p.z - o.p.w;\n        \n    vec3 q = p;\n    \n    if(p.x*3.< face)q = p.xyz;\n    else if(p.y*3. < face)q = p.yzx;\n    else if(p.z*3. < face)q = p.zxy;\n    else return face* (1./sqrt(3.));\n    \n    float k = clamp(0.5*(q.z-q.y+o.p.w),0.0,o.p.w);\n    float edge = length(vec3(q.x,q.y-o.p.w+k,q.z-k));\n    \n    d = edge;\n    return d;\n}\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n    d = octahedronSDF(p,0);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += diffuse(r.p,l[i].L);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(.1);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 945]]}
{"id": "DdSyDW", "name": "Chinese Ink-wash Painting II", "author": "Delincoter", "description": "Inspired by \"Thousand miles of rivers and mountains\" and Guilin scenery.", "tags": ["3d", "mountain", "chinese", "paining"], "likes": 33, "viewed": 642, "published": 3, "date": "1687695843", "time_retrieved": "2024-07-30T17:47:32.691158", "image_code": "//noise funtion abstract from https://www.shadertoy.com/view/ldc3RB\n//RayMarch funtion abstract from https://www.shadertoy.com/view/WtGXDD\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    //return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor(p + (p.x + p.y) * K1);\n    \n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - (o - K2);\n    vec2 c = a - (1.0 - 2.0 * K2);\n    \n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n     \n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\nfloat noise_itself(vec2 p)\n{\n    float f = 0.;\n    p *= 8.;\n    f += 1.0000 * noise(p); p = 6.0 * p;\n    f += 0.1000 * noise(p); p = 4.0 * p;\n    f += 0.0100 * noise(p); p = 3.0 * p;\n    //f += 0.001 * noise(p); \n    return f;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    float d = p.y+4.;\n    p.z -= iTime;\n    float h = max(0., noise_itself(p.xz*0.01+13.7)); \n    h = pow(h, 1.6)*8.;\n    d -= h;\n    \n    return d*0.3;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = vec2(-.05, -0.5);\n    if(iMouse.z > 0.) m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.y = max(ro.y, -1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n    \n    float sun = S(0.998,1.,dot(normalize(rd), normalize(vec3(0.,0.5,-1.))));\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        \n        vec3 lightDir = normalize(vec3(0.0, .5,-.5));\n\n        float fre = max(0.,dot(n, normalize(ro-p)));\n        fre = pow(fre,.125);\n        fre = S(0.8,0.85,fre);\n        fre = mix(fre, 1., S(-0.0, -4., p.y));\n        \n        float heigh = S(-4., 0., p.y);\n        col = mix(vec3(0.6588,0.5176,0.2824), vec3(0.3059, 0.4627, 0.633), heigh)*fre;\n        \n        heigh = S(-4.1, -3.9, p.y);\n        col = mix(vec3(0.6,0.55,0.2)*S(0.,15., d), col, heigh);\n        \n        sun = .0;\n    }\n    \n    col = mix(col, vec3(0.6588,0.5176,0.2824)*1.5, S(0.,100., d));\n    \n    col = mix(col, vec3(1.,0.4,0.), sun);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 307, 307, 505], [507, 507, 528, 528, 1073], [1075, 1075, 1103, 1103, 1303], [1305, 1305, 1324, 1324, 1386], [1388, 1388, 1411, 1411, 1566], [1568, 1568, 1602, 1602, 1813], [1815, 1815, 1839, 1839, 1993], [1995, 1995, 2045, 2045, 2230], [2232, 2232, 2289, 2289, 3478]]}
{"id": "ds2yWh", "name": "First visualiser", "author": "globaldusk", "description": "Music visualiser", "tags": ["visualizer"], "likes": 10, "viewed": 480, "published": 3, "date": "1687689151", "time_retrieved": "2024-07-30T17:47:33.486032", "image_code": "vec3 palette( float t ){\n\n    \n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sample_at(float f)\n{\n    return texture(iChannel0, vec2(f / 10.0, 0.25)).x;\n}\n\nfloat sm(float f)\n{\n    float delta = .1;\n    return 0.2 * (sample_at(f - 2. * delta) + sample_at(f - delta) + sample_at(f) + sample_at(f + delta) + sample_at(f + 2. * delta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.y; //Centering and coord scaling\n    \n    vec2 uv0 = uv;//Temp storage\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);// backcolour\n    \n    for (float i = 0.0; i <2.0; i++){\n\n        uv = fract(uv *sm(1.5)) - 0.5;//amount of fractals\n\n        float d = length(uv) * sm(exp(-length(uv0))); //circle placement\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);//changing colour scheme\n\n        d = sin(d*8. +iTime)/8.;//circle movement direction and speed\n        d = abs(d); //ring brightness\n\n        d = pow(0.01/ d, 1.2); //colour glow\n          \n\n        finalColor += col * d;// Applying the colour to the algorithm\n    }\n\n    fragColor =  vec4(finalColor, 1.0);//setting the output\n    \n}", "image_inputs": [{"id": 33801, "src": "https://soundcloud.com/thibault-saillan/pump-it-the-black-eyed-peas-speed-version?si=aea4389d465743009951d54216451309&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2yWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 220], [222, 222, 248, 248, 305], [307, 307, 326, 326, 485], [487, 487, 544, 544, 1312]]}
{"id": "cs2cWz", "name": "truss structures: Zeppelin", "author": "FabriceNeyret2", "description": "mouse controls camera\ninspiration:\nhttps://twitter.com/mariuswatz/status/1670382116310319104/photo/1\nhttps://www.deutsches-museum.de/assets/_processed_/d/6/csm_LRD_Zeppelin_Hindenburg_Archiv_BN_43561_72ceb33fc4.jpg", "tags": ["short", "reproduction", "truss"], "likes": 42, "viewed": 491, "published": 3, "date": "1687681469", "time_retrieved": "2024-07-30T17:47:34.256971", "image_code": "// variant of https://shadertoy.com/view/cs2yWz\n//        and https://shadertoy.com/view/dssyDs\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                      // rotation\n#define ring(P,l) 4.* vec3( length(P.xz)-l, P.y, l*atan(P.x,P.z) )  // ring coordinates\n\n#define T(q) (                                       /* truss structure   */ \\\n        q.xy = length(q.xy) * cos( mod(atan(q.y,q.x)+1.05,2.1)-1.05 + vec2(0,11) ), \\\n        q.z = mod(q.z,2.) - 1.,                      /* z-repeat          */ \\\n        q.x -= .5,                                   /* faces = 0yz plane */ \\\n        min( length(vec2(q.x,abs(q.y)-.87)) -.1,                             \\\n             max(length(vec2(q.x,.87*abs(q.z)+.5*q.y-.5))-.1, abs(q.y)-.9) ) \\\n     )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,l;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -2.*R.y) - R),                    // ray direction\n          p = vec3(0,0,15), P,q,                                    // marching point along ray \n          C = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.                   // camera control\n                            : 3.* cos(.3*iTime + vec3(0,11,0));     // demo mode\n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )                  // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                          // rotations\n        q.xz *= rot(-C.x),\n        P = q,                                                      // --- longitudal beams\n        P.xy = length(P.xy) * cos( mod(atan(P.y,P.x)+.314,.628)-.314 + vec2(0,11) ), // 10-folds rot symmetry\n        P.x += 5.,\n        P = ring(P,10.),                                            // ring coordinates\n        t = T(P),                                                   // large structure\n        P = q,                                                      // --- latitudal beams\n        l = sqrt( 1e2 - P.z*P.z ) - 5.,                             // ring radius\n        P.z = mod(P.z,3.) - 1.5,                                    // z-repeat\n        P = ring(P.xzy, l ),                                        // ring coordinates\n        t = min(t, T(P)),\n        p += .1*t*D;                                                // step forward = dist to obj  \n    \n   O *= O*O*O*2.;                                                   // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2cWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[755, 755, 791, 791, 2349]]}
{"id": "ddjcWh", "name": "Sunday morning random results", "author": "mrange", "description": "CC0: Sunday morning random results\nTinkering around on sunday morning\n", "tags": ["kaleidoscope"], "likes": 87, "viewed": 1003, "published": 3, "date": "1687679270", "time_retrieved": "2024-07-30T17:47:35.023920", "image_code": "// CC0: Sunday morning random results\n//  Tinkering around on sunday morning\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int max_iter = 5;\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat shape(vec2 p) {\n  const float amp = 10.0;\n  p += amp*sin(vec2(1.0, sqrt(0.5))*0.026*TIME*TAU/amp);\n  vec2 cp = p;\n  vec2 np = round(p);\n  cp -= np;\n\n  float h0 = hash(np+123.4); \n  if (h0 > 0.5) {\n    cp = vec2(-cp.y, cp.x);\n  }\n\n  vec2 cp0 = cp;\n  cp0 -= -0.5;\n  float d0 = (length(cp0)-0.5);\n  vec2 cp1 = cp;\n  cp1 -= 0.5;\n  float d1 = (length(cp1)-0.5);\n  \n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125;\n  return d;\n}\n\nvec2 df(vec2 p, out int ii, out bool inside) {\n  float sz = 0.9;\n  float ds = shape(p);\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  float aa = 0.25*sz;\n\n  float d0 = box(pp, vec2(r-aa))-aa; \n  float d1 = length(pp);\n  return vec2(d0, d1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 4.0/RESOLUTION.y;\n  vec2 op = p;\n  mat2 rot =ROT(0.0125*TIME); \n  p *= rot;\n  smoothKaleidoscope(p, 0.025, 34.0);\n  p *= ROT(0.25*length(op));\n  p *= transpose(rot);\n\n  int i;\n  bool inside;\n  vec2 d2 = df(p, i, inside);\n  float ii = float(i)/float(max_iter);\n  vec3 col = vec3(0.0);\n  vec3  rgb = 0.5*(1.0+cos(0.5*TIME-0.5*PI*length(p)+vec3(0.0, 1.0, 2.0)+ PI*ii+(inside?(2.0*(dot(p,pp)+1.0)):0.0)));\n  rgb += 0.0025/max(d2.y, 0.005);\n  col = mix(col, rgb, smoothstep(0.0, -aa, d2.x));\n  col -= vec3(0.25)*(length(op)+0.0);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 367, 403, 403, 497], [499, 559, 580, 580, 650], [652, 746, 773, 773, 849], [851, 951, 990, 990, 1075], [1077, 1165, 1195, 1195, 1223], [1225, 1313, 1335, 1335, 1379], [1381, 1469, 1490, 1490, 1535], [1537, 1623, 1668, 1668, 1822], [1824, 1824, 1885, 1885, 2098], [2100, 2100, 2121, 2121, 2533], [2535, 2535, 2581, 2581, 3054], [3056, 3056, 3113, 3113, 3858]]}
{"id": "md2yWh", "name": "experimenting with colormaps", "author": "beans_please", "description": "will use this in another shader of mine", "tags": ["test", "colormap"], "likes": 4, "viewed": 143, "published": 3, "date": "1687678448", "time_retrieved": "2024-07-30T17:47:36.069126", "image_code": "float map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n    \n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = colormap(uv.x * 2.0 - 1.0);\n    \n    col = pow(col, vec3(1.0 / 2.2));\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2yWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 92, 92, 186], [188, 188, 286, 286, 429], [431, 431, 455, 455, 1041], [1043, 1043, 1100, 1100, 1264]]}
{"id": "mdScW1", "name": "Interactive 2D Wave Simulation", "author": "beans_please", "description": "*Drag your mouse, make a spiral or something.\n\nThis is a port of my Python wave simulation project:\nhttps://github.com/bean-mhm/wave-simulation-py\n", "tags": ["wave", "simulation", "physics", "waveequation", "wavesim"], "likes": 6, "viewed": 285, "published": 3, "date": "1687653267", "time_retrieved": "2024-07-30T17:47:36.924838", "image_code": "// iChannel0 = Buffer A\n\nvec3 get_col(vec2 uv)\n{\n    // UV\n    bool inside_buf;\n    vec2 buf_uv;\n    get_buf_uv(uv, iResolution.xy, buf_uv, inside_buf);\n    if (!inside_buf)\n    {\n        return colormap(0.0) * 0.5;\n    }\n\n    // Bilinear interpolation\n    vec2 buf_coord = buf_uv * vec2(wave_grid_res);\n    float v = sample_bilinear(buf_coord, iChannel0, wave_grid_res).x;\n\n    // Color map\n    v *= 1.5;\n    vec3 col = colormap(v);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n\n    vec3 col = get_col(uv);\n    col = pow(col, vec3(1.0 / 2.2));\n\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// iChannel0 = Buffer A (self-feeding)\n\nfloat wave_initial_val(ivec2 icoord)\n{\n    return 0.0;\n}\n\nfloat wave_update_val(ivec2 icoord, float curr, float sim_time)\n{\n    // Initial pulse at the center\n    if (icoord == wave_grid_res / 2)\n    {\n        float amp = map_range_clamp(sim_time, 0.0, 0.02, 0.5, 0.0);\n        float freq = 0.5 * wave_max_frequency;\n        if (amp > 0.001)\n        {\n            return amp * sin(TWO_PI * sim_time * freq);\n        }\n    }\n\n    bool inside_buf;\n    vec2 mouse_uv;\n    get_buf_uv(iMouse.xy / iResolution.xy, iResolution.xy, mouse_uv, inside_buf);\n    vec2 mouse_coord = mouse_uv * vec2(wave_grid_res);\n\n    float mouse_prox = distance(vec2(icoord) + 0.5, mouse_coord);\n    mouse_prox /= max(float(wave_grid_res.x), float(wave_grid_res.y));\n\n    // Create disturbance with mouse\n    if (iMouse.z > 0.0)\n    {\n        curr = mix(curr, curr + iTimeDelta * wave_dt * 1000.0, map_range_clamp(mouse_prox, 0.03, 0.0, 0.0, 1.0));\n    }\n\n    return curr;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n\n    // Skip pixels outside the grid\n    if (icoord.x >= wave_grid_res.x || icoord.y >= wave_grid_res.y)\n        return;\n\n    // X = current value\n    // Y = previous value\n    // Z = iteration\n    vec4 data = texelFetch(iChannel0, icoord, 0);\n    float curr = data.x;\n    float prev = data.y;\n    int iter = int(data.z);\n\n    // First frame (initial values)\n    if (iter == 0 || iFrame < 1 || iTime == 0.0)\n    {\n        float v = wave_initial_val(icoord);\n        fragColor = vec4(v, v, 1.0, 0.0);\n        return;\n    }\n\n    float next_in_x = 0.0;\n    float prev_in_x = 0.0;\n    float next_in_y = 0.0;\n    float prev_in_y = 0.0;\n    if ((icoord.x + 1) < wave_grid_res.x)\n    {\n        next_in_x = texelFetch(iChannel0, icoord + ivec2(1, 0), 0).x;\n    }\n    if ((icoord.x - 1) >= 0)\n    {\n        prev_in_x = texelFetch(iChannel0, icoord + ivec2(-1, 0), 0).x;\n    }\n    if ((icoord.y + 1) < wave_grid_res.y)\n    {\n        next_in_y = texelFetch(iChannel0, icoord + ivec2(0, 1), 0).x;\n    }\n    if ((icoord.y - 1) >= 0)\n    {\n        prev_in_y = texelFetch(iChannel0, icoord + ivec2(0, -1), 0).x;\n    }\n\n    float grad_x = next_in_x - curr - curr + prev_in_x;\n    float grad_y = next_in_y - curr - curr + prev_in_y;\n\n    float acc = (grad_x + grad_y) * wave_speed2 / wave_step2;\n    float vel = (curr - prev) / wave_dt;\n    vel += (acc * wave_dt);\n    vel *= pow(wave_stiffness, -wave_dt);\n\n    prev = curr;\n    curr += (vel * wave_dt);\n\n    float sim_time = wave_dt * float(iter);\n    curr = wave_update_val(icoord, curr, sim_time);\n\n    fragColor = vec4(curr, prev, float(iter + 1), 0.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\n// Grid Resolution\nconst ivec2 wave_grid_res = ivec2(256, 256);\n\n// Minimum distance in the grid\nconst float wave_step = 0.01;\nconst float wave_step2 = wave_step * wave_step;\n\n// Grid dimensions\nconst vec2 wave_dims = wave_step * vec2(wave_grid_res - 1);\n\n// Propagation speed in 2D\nconst float wave_speed = 10.0;\nconst float wave_speed2 = wave_speed * wave_speed;\n\n// Minimum wavelength\n// At least 8 steps needed for a perfectly smooth spherical wave.\nconst float wave_min_wavelength = wave_step * sqrt(2.0) * 8.0;\n\n// Maximum frequency\nconst float wave_max_frequency = wave_speed / wave_min_wavelength;\n\n// Maximum timestep\nconst float wave_max_dt = wave_step / (wave_speed * sqrt(2.0));\n\n// Timestep\nconst float wave_dt = 0.95 * wave_max_dt;\n\n// Stiffness\n// Must be greater than or equal to 1 to function properly.\nconst float wave_stiffness = 15.0;\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat fit_to_screen(vec2 image_res, vec2 screen_res)\n{\n    return min(screen_res.x / image_res.x, screen_res.y / image_res.y);\n}\n\nvoid get_buf_uv(vec2 uv, vec2 res, out vec2 buf_uv, out bool inside_buf)\n{\n    buf_uv = uv * 2.0 - 1.0;\n    buf_uv.x *= res.x / res.y;\n    buf_uv.x *= float(wave_grid_res.y) / float(wave_grid_res.x);\n    buf_uv /= fit_to_screen(vec2(wave_grid_res) / float(wave_grid_res.y), res.xy / res.y);\n    buf_uv = (buf_uv + 1.0) / 2.0;\n    inside_buf = max(abs(buf_uv.x - 0.5), abs(buf_uv.y - 0.5)) <= 0.5;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return (icoord.x >= 0) && (icoord.x < res.x) && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\nvec4 sample_bilinear(vec2 coord, sampler2D src, ivec2 src_res)\n{\n    ivec2 bottomLeftPos = ivec2(int(floor(coord.x - 0.5)), int(floor(coord.y - 0.5)));\n\n    ivec2 topRightPos = ivec2(bottomLeftPos.x + 1, bottomLeftPos.y + 1);\n\n    ivec2 bottomRightPos = ivec2(topRightPos.x, bottomLeftPos.y);\n\n    ivec2 topLeftPos = ivec2(bottomLeftPos.x, topRightPos.y);\n\n    float alongX = coord.x - (float(bottomLeftPos.x) + 0.5);\n    float alongY = coord.y - (float(bottomLeftPos.y) + 0.5);\n\n    float bottomLeftWeight = (1.0 - alongX) * (1.0 - alongY);\n    float bottomRightWeight = (alongX) * (1.0 - alongY);\n    float topLeftWeight = (1.0 - alongX) * (alongY);\n    float topRightWeight = (alongX) * (alongY);\n\n    vec4 result = vec4(0.0);\n\n    if (icoord_in_bounds(bottomLeftPos, src_res))\n        result += bottomLeftWeight * texelFetch(src, bottomLeftPos, 0);\n\n    if (icoord_in_bounds(topRightPos, src_res))\n        result += topRightWeight * texelFetch(src, topRightPos, 0);\n\n    if (icoord_in_bounds(bottomRightPos, src_res))\n        result += bottomRightWeight * texelFetch(src, bottomRightPos, 0);\n\n    if (icoord_in_bounds(topLeftPos, src_res))\n        result += topLeftWeight * texelFetch(src, topLeftPos, 0);\n\n    return result;\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n\n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n\n    return c;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdScW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 48, 58, 452], [454, 454, 504, 504, 642]]}
{"id": "csBcWh", "name": "raymarched pathtracing", "author": "01000001", "description": "Bit weird but it works. Small experiment, it's not great. Using flim by beans_please", "tags": ["fractal", "pathtracing", "rendering"], "likes": 6, "viewed": 78, "published": 3, "date": "1687622696", "time_retrieved": "2024-07-30T17:47:37.882278", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy;\n    O = texture(iChannel1, uv);\n    O /= O.a;\n    O = vec4(flim O.xyz, -2.), 1.0); //*/\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\n\nvec3 normaliza(vec3 v)\n{\n    return v * fisqrt(v.x*v.x+v.y*v.y+v.z*v.z);\n}\n\n/////  USING QUAKE III FAST INVERSE SQUARE ROOT!  It works exceptionally well. fisqrt() is in common tab.\n\n\nvec3 randSphere( uvec3 x )\n{\n    vec3 a;\n    for (int i = 0; i<100; i++)\n    {\n        a = hash(x)*2.-1.;\n        if (length(a) < 1.){ return normaliza(a); }\n    }\n    return normaliza(a);\n}\n\nfloat maxDist = 1e3;\nfloat minDist = 1e-3;\nint maxIters = 512;\nint maxBounces = 4;\n\nvec3 lightDir = vec3(1, -0.4, 1);\nfloat shadowBrightness = 0.1;\nfloat lightStrength = 5.;\nfloat lightSize = 0.1;\n\nfloat roughness = 1.;\nfloat focusDistance = 6.;\nfloat focusLength = 1.8;\nfloat dof = 0.05f;\n\nvec3 camPos = vec3(3, -4, 1);\nvec3 camDir = vec3(-0.4,1,-0.1);\n#define eps 1e-3\n\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat mandel( in vec3 p)\n{\n    if (length(p) > 1.3) return length(p)-1.1;\n\n    vec3 w = p;\n    float m = dot(w,w);\n    vec4 resColor;\n    \n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat DF(vec3 p)\n{\n    float minDist = 500.0;\n    minDist = min(minDist, length(p - vec3(0, 4, 0))-1.);\n    minDist = min(minDist, length(p - vec3(4, 3, -0.5))-0.5);\n    minDist = min(minDist, length(p - vec3(3, 6, -0.3))-0.7);\n    minDist = min(minDist, length(vec3(p.x, mod(p.y, 2.)+1., p.z) - vec3(-3, 2, -0.3))-0.7);\n    minDist = min(minDist, mandel(p-vec3(2, 3, 0)));\n    \n    minDist = min(minDist, box(p-vec3(-1, 10, 3.5), vec3(3, 3, 0.5)));\n    minDist = min(minDist, box(p-vec3(2, 10, 1), vec3(0.5, 3, 3)));\n    minDist = min(minDist, box(p-vec3(-1, 12, 1), vec3(3, 0.5, 3)));\n    \n\n    minDist = min(minDist, p.z+1.0);\n    minDist = min(minDist, p.x+4.0);\n    \n    return minDist;\n}\n\nvec3 norm(vec3 p, float e)\n{\n    return vec3(\n    \n        DF(p+vec3(e, 0., 0.))-DF(p+vec3(-e, 0., 0.)),\n        DF(p+vec3(0., e, 0.))-DF(p+vec3(0., -e, 0.)),\n        DF(p+vec3(0., 0., e))-DF(p+vec3(0., 0., -e))\n    \n    )/(2.*e);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = (U-iResolution.xy/2.)/iResolution.y*2.;\n    uvec3 a = uvec3(U, iFrame);\n    \n    \n    vec3 calcLightDir = normaliza(lightDir + randSphere(a.yxz)*lightSize);\n    \n\n    vec3 o = vec3(0);//randSphere(uvec3(iTime, U.xy))*dof;\n    vec3 dirV = vec3(uv.x, focusLength, uv.y) + randSphere(a)/iResolution.y;\n    dirV *= focusDistance/focusLength;\n    dirV = normaliza(dirV-o);\n  \n    o += camPos;\n    \n    vec3 r = normaliza(cross(camDir, vec3(0, 0, 1)));\n    vec3 u = cross(r, normaliza(camDir));\n    dirV = normaliza(camDir * dirV.y + r * dirV.x + u * dirV.z);\n  \n    float d;\n    vec3 p;\n    vec3 l;\n    \n    \n    float depth = 0.;\n    vec3 normal = vec3(0);\n    float totalDepth = 0.;\n    bool hit = false;\n    \n    vec3 mult = vec3(1);\n    vec3 tot = vec3(0);\n    float f = 1.;\n    \n    for (int s = 0; s < maxBounces; s++)\n    {\n        hit = false;\n        depth = 0.;\n        for (int i = 0; i < maxIters; i++)\n        {\n            p = o + dirV * depth;\n            d = DF(p);\n            depth += d;\n            if (d < minDist){\n                hit = true;\n                break; \n            }\n            if (d > maxDist) break;\n        }\n        if (d > maxDist) break;\n                \n        normal = norm(p, minDist);\n        totalDepth += depth;\n        \n        depth = 0.;\n        bool li = true;\n        for (int i = 0; i < maxIters; i++)\n        {\n            l = p + normal*eps + calcLightDir * depth;\n            d = DF(l);\n            depth += d;\n            if (d < minDist){\n                li = false;\n                break; \n            }\n            if (d > maxDist) break;\n        }\n        \n        dirV = reflect(dirV, normal);\n        dirV = mix(dirV, normaliza(normal + randSphere(a + uvec3(p))), roughness);\n        \n        f = 1.-pow(max(0.,dot(normal, dirV)),1./5.);\n        mult *= mix(\n            (p.z <= -1.+eps?vec3(0, 0.2, 1.0):p.x < -4.+eps?vec3(1, 0.2, 0):vec3(1)),\n            vec3(f),\n            f\n        );\n\n        mult *= (max(0., lightStrength*dot(normal, normaliza(lightDir))) * (li?1.:0.))*(1.-shadowBrightness) + shadowBrightness;\n        \n        tot += mult;\n        \n    }\n    \n    vec3 col = vec3(tot);\n    \n    //col += vec3(float(steps)/float(maxIters));\n    \n    \n\n\n    // Output to screen\n    O = texture(iChannel0, U/iResolution.xy) + vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float fisqrt(float x)\n{\n    uint i;\n    float a = x,y;\n    a*=.5;\n    i=floatBitsToUint(x);\n    i=uint(0x5f3759df) - ( i >> 1);\n    y=uintBitsToFloat(i);\n    y=y*(1.5-(a*y*y));\n    return y;\n}\n// see https://www.shadertoy.com/view/DlSyRD\n\n\n#define flim flim_transform(iChannel0, \n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nfloat lerp(float a, float b, float t){return a + t * (b - a);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n", "buffer_b_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "dd2yDz", "name": "flim - Filmic Color Transform", "author": "beans_please", "description": "Experimental Port of flim (Film Emulation Transform)\n\nOriginal Repo:\nhttps://github.com/bean-mhm/flim\n", "tags": ["color", "display", "gamma", "filmic", "filmemulation", "viewtransform"], "likes": 12, "viewed": 493, "published": 3, "date": "1687622059", "time_retrieved": "2024-07-30T17:47:38.930475", "image_code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = frag_coord.xy / iResolution.xy;\n\n    // RGB sweep test\n    vec3 col = flim_rgb_exposure_sweep_test(uv);\n\n    // alternate between flim and native sRGB\n    if (mod(iTime, 3.) > 1.5)\n    {\n        col = pow(col, vec3(1. / 2.2));\n    }\n    else\n    {\n        float exposure = 0.;\n        col = flim_transform(col, exposure, true);\n    }\n\n    // output\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2yDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 450]]}
{"id": "DsByWh", "name": "AI-gen-Claude", "author": "Sergeindamix", "description": "https://www.anthropic.com/claude-in-slack", "tags": ["stair", "broca", "escada", "twistdrill", "tatuzo"], "likes": 1, "viewed": 128, "published": 3, "date": "1687621384", "time_retrieved": "2024-07-30T17:47:39.792171", "image_code": "\n#define shake cos(iTime*.1 * escada(y, .1))\n\n#define zoom .2 * sin(iTime * .3) \n\nfloat escada(float x, float w){\n    return floor(x / w) * w;\n}\n\nvec3 bg(vec2 p){\n\n    float y = length(p) * 2. + zoom;\n    float x = atan(p.x, p.y);\n\n    float a = sin(x * 2. + iTime * .5);\n    float b = cos(y * 2. + iTime * .7);\n\n    float c = sin(x * 4. - iTime * .3);\n    float d = cos(y * 4. - iTime * .1);\n\n    vec3 col = vec3(a * c, b * d, (c + d) * .5);    \n\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - .5 * iResolution.xy);\n\n    float mask = sin(uv.x * 6. + uv.y * 6. + iTime * .2) * .5 + .5; \n    uv *= mask;     \n\n    fragColor = vec4(bg(uv), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsByWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 113, 113, 144], [146, 146, 162, 162, 465], [468, 468, 523, 523, 700]]}
{"id": "Dd2cWz", "name": "hexagons and stars", "author": "4eckme", "description": "Try to get stars on the field...", "tags": ["rgb", "stars", "pattern", "infinity", "octagons"], "likes": 3, "viewed": 176, "published": 3, "date": "1687597429", "time_retrieved": "2024-07-30T17:47:40.566102", "image_code": "// CLICK MOUSE AND MOVE\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage( out vec4 c, in vec2 xy )\n{\n    c=vec4(0,0,0,1);\n    vec2 O=xy.xy;\n    vec2 M=iMouse.xy;\n    if(M.x+M.y<1.0)M=iResolution.xy/2.0;\n    float sin60=sin(radians(60.0));\n    float cos60=cos(radians(60.0));\n    \n    //fix coords\n    xy.x=mod(xy.x,(256.0-64.0)/sin60);\n    vec2 o=abs(xy);    \n    xy.y+=32.0;\n    xy.x-=128.0*sin60;\n    float x=abs(xy.x);\n    float y=abs(xy.y);\n    xy=abs(xy);    \n    xy.x-=32.0/sin60;\n    xy.y=32.0-mod(xy.y,64.0);\n    if(mod(o.x,512.0*sin60)>=256.0*sin60){xy.x=32.0*5.0/8.0-xy.x;};\n    if(mod(y,128.0)>=64.0)xy.x-=32.0/sin60;\n    xy*=rot(ceil(M.x/8.0));//rotated by mouse\n    vec2 XY=vec2(xy.y*cos60-xy.x*sin60,xy.y*cos60+xy.x*sin60);//oblique lines\n    \n    //yellow bordes backlight (by mouse)\n    if(length(ceil(vec2(M.x,(M.y)))-O)<=224.0)c=vec4(1,1,0,1);\n    //red bordes backlight (by mouse)\n    if(length(ceil(vec2(M.x/111.0-64.0/111.0,(M.y)/64.0-30.0/64.0))*vec2(111.0,64.0)-O)<=111.0)c=vec4(1,0,0,1);\n    \n    //draw all octagons\n    if(abs(xy.y)+abs(XY.x)+abs(XY.y)<=56.0){c=vec4(0.4,0.8,1,1);}\n    if(abs(xy.y)+abs(XY.x)+abs(XY.y)>=64.0){c=vec4(0,0,0,1);}\n    if(abs(xy.y)+abs(XY.x)+abs(XY.y)<=50.0){\n        c=vec4(1.8,1.8,1.8,1);\n        c*=11.0/sqrt(abs(xy.x*xy.x)+abs(xy.y*xy.y));//shadows\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2cWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 116, 116, 1330]]}
{"id": "cs2yWz", "name": "truss: multiscalstructured beams", "author": "FabriceNeyret2", "description": "mouse controls camera\nhttps://en.wikipedia.org/wiki/Truss\nmultiscale variant of https://shadertoy.com/view/dssyDs", "tags": ["short", "truss"], "likes": 27, "viewed": 389, "published": 3, "date": "1687596404", "time_retrieved": "2024-07-30T17:47:41.486641", "image_code": "// multiscale variant of https://shadertoy.com/view/dssyDs\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                    // rotation\n#define T(q) (                                                               \\\n        q.xy = length(q.xy) * cos( mod(atan(q.y,q.x)+1.05,2.1)-1.05 + vec2(0,11) ), \\\n        q.z = mod(q.z,2.) - 1.,                      /* z-repeat          */ \\\n        q.x -= .5,                                   /* faces = 0yz plane */ \\\n        min( length(vec2(q.x,abs(q.y)-.87)) -.1,                             \\\n             max(length(vec2(q.x,.87*abs(q.z)+.5*q.y-.5))-.1, abs(q.y)-.9) ) \\\n     )\n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,l;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -R.y) - R),                       // ray direction\n          p = vec3(0,0,5), P,q,                                     // marching point along ray \n          C = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.                   // camera control\n                            : 3.* cos(.3*iTime + vec3(0,11,0));     // demo mode\n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )                  // march scene\n        P = p, \n        P.yz *= rot(-C.y),                                          // rotations\n        P.xz *= rot(-C.x),\n        T(P),                                                       // large structure\n     // t = T(P)*3.,                                                // debug: visualize it\n        q = 6.* vec3( P.x, abs(P.y)-.87, P.z),                      // long tubes\n        t = length(T(q)) -.1 , \n        q = 6.* vec3( P.x, .87*abs(P.z)+.5*P.y-.5, .5*P.z-.87*P.y*sign(P.z) ),\n        t = min(t, max( length(T(q)) -.1 , abs(q.y)-.9) ),          // short tubes\n        p += .07*t*D;                                                // step forward = dist to obj  \n    \n   O *= O*O*O*2.;                                                   // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2yWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[630, 630, 666, 666, 1915]]}
{"id": "msScWR", "name": "Cool Fractal [278 Chars]", "author": "SnoopethDuckDuck", "description": "its a cool fractal", "tags": ["fractal", "inversion", "golfed"], "likes": 9, "viewed": 199, "published": 3, "date": "1687563495", "time_retrieved": "2024-07-30T17:47:42.488961", "image_code": "void mainImage( out vec4 O, in vec2 u )\n{\n    vec2 r = iResolution.xy;\n    u = (u - .5 * r) / r.y;\n    \n    float t = .1 * iTime,\n          i = .3;\n    \n    for (i; i < 2.7; i += .3) {\n        t /= i;\n        u = 4. * u * mat2(u.x+u.y, u.x-u.y, u.y-u.x, u.x+u.y)\n          + .3 * sin(1.9 * t) + 2. * vec2(cos(t), sin(t));\n        u /= dot(u, u);\n    }\n    O = texture(iChannel0, u/2e2) \n      + .15 / cosh(3.*abs(fract(4.*u.x)-.5));\n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msScWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 434]]}
{"id": "msByWR", "name": "Cluster Bomb", "author": "AsePlayer", "description": "Chain reaction by Ase", "tags": ["test"], "likes": 2, "viewed": 203, "published": 3, "date": "1687562207", "time_retrieved": "2024-07-30T17:47:43.454380", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv; // Store initial uv\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 1.35) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = 0.01 / d;\n\n        finalColor += col * d;\n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msByWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 219], [221, 221, 276, 326, 849]]}
{"id": "dd2yzw", "name": "Rusting Computer Chip", "author": "tomachi", "description": "This has a life algorithm but is tainted by also allowing it to migrate to \"greener\" pixel pastures.", "tags": ["colors", "automata", "screensaver", "colours", "gameoflife", "fading", "gol"], "likes": 2, "viewed": 187, "published": 3, "date": "1687552603", "time_retrieved": "2024-07-30T17:47:44.428775", "image_code": "/* IMAGE */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*\nchannels:\nBuffer A - Cells states\nBuffer B - background trails\nBuffer C - density mask ( used to fill blanks mid-game)\n*/\nvec4 sand(in vec2 uv )\n{\n    vec4 part = texture(iChannel3,uv);\n\tfloat c = step(0.1,part.z);\n\tvec3 col=vec3(1.,.9,.8)*c*(1.-abs(uv.x-.5));\n    vec4 fragColor = vec4(col,1.);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float rain = 0.;\n    if (therain(uv).x > 0.) { rain = 0.45; }\n //   float rain = therain(uv).x   *10.1;//therain(uv).x*1.59;\n    float bug =   amoeba(uv).x*120.9;\n    float bugpiss = amoeba(uv).y*0.0001*uv.y;\n    float herbi = habitat(uv).x*.005;\n    float red =   rain +     herbi*0.5 + bug*5. + bugpiss*1.;\n    float green = rain +     herbi*2.5 + bug*0.91 + bugpiss*1.;\n    float blue =  rain*1.3 + herbi*0.19 + bug*0.0013 + bugpiss*0.01;\n\n  \n    fragColor = vec4(red, green, blue, 1.);// + sand(uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* AMOEBA/LIFE */\n#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n#define R iResolution.xy\n\n#define webcam(pos) texture(iChannel3, pos)\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*float checkPixel(float col, float value) // mapping function\n{\n    if (value >= 0.90001) {\n        return col + value;\n    } else {\n        return 0.;\n    }\n}*/\nbool isHerbivore(vec2 uv) {\n    if (habitat(uv).x > 20.91 && amoeba(uv).y<0.21) { return true; } else { return false; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    float brightest = 0.;\n    float veges = tex1(uv);\n    float bugpiss = amoeba(uv).y;\n    float col = tex0(uv);\n    float D = tex3(uv);\n    vec4 colour = vec4(webcam(uv).r*1.1, 0.1, webcam(uv).r, 0.);\n    vec4 herbivore = amoeba(uv);\n    if(iFrame < 2 &&  length(uv.xy - fragCoord.xy) > 8.12) // fill blank space with cells\n    {\n        if (rand(uv)  > 0.85 + uv.y*0.5 ) {\n            fragColor = vec4(rand(uv)) * uv.y*0.5;\n            return;\n        }\n    }\n    // DEATH OF PISS OR LACK OF VEGES\n    if (veges > 0.) {\n       if (herbivore.y >0.1) {\n           bugpiss *= 0.9975;\n           fragColor = vec4(0., bugpiss, 0.,0.);\n           return;\n        }\n    } else {\n        col -= 0.0001; // starve\n    }  \n\n\n\n    int n = 0; // game of life logics\n    float amoeba = 0.; // amoeba logic\n    float onepix = p.x;\n    float twopix = onepix * 2.;\n\n    vec2 lup   = vec2(uv.x-p.x, uv.y-p.y);\n    vec2 ldown = vec2(uv.x-p.x, uv.y+p.y);\n    vec2 rup   = vec2(uv.x+p.x, uv.y-p.y);\n    vec2 rdown = vec2(uv.x+p.x, uv.y+p.y);\n\n    vec2 left = vec2(uv.x+p.x, uv.y);\n    vec2 right= vec2(uv.x-p.x, uv.y);\n    vec2 up   = vec2(uv.x, uv.y-p.y);\n    vec2 down = vec2(uv.x, uv.y+p.y);\n\n    // count neighbours\n    n += int(tex(lup));\n    n += int(tex(ldown));\n    n += int(tex(rup));\n    n += int(tex(rdown));\n\n    n += int(tex(left));\n    n += int(tex(right));\n    n += int(tex(up));\n    n += int(tex(down));\n    \n    if (habitat(uv).x > 0.1) colour.y = 0.; // if the forest grows, it consumes the excrement\n\n    if(col > 0.1 && colour.y == 0.||n == 3){\n  //  if(col > 0.1 ){\n       if( n == 3) col += 1.; // rebirth\n    }\n    else if(col > 0. && !(n == 3 || n == 4)) {\n       col = 0.; // overcrowd death\n       colour.y += 0.1;// add to the cemetry\n     } \n    // if (abs(col)>10.65)  { col = 0.; } \n       \n    // if the cell at 180 degrees around from herbi is not better move here\n    // if to the left, theh check 2 pixels to the left\n\n    if (isHerbivore(lup)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x - twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(ldown)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y + twopix))) {\n          col += tex1(vec2(uv.x - twopix, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rup)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rdown)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n\n    if (isHerbivore(left)) { // left\n      if(veges > tex1(vec2(uv.x - twopix, uv.y))) {\n         col += tex1(vec2(uv.x - twopix, uv.y));\n      } else { col = 0.01; }\n    }\n    if (isHerbivore(right)) { // right\n      if(veges > tex1(vec2(uv.x + twopix, uv.y))) {\n          col += tex1(vec2(uv.x + twopix, uv.y));\n      } else { col = 0.01; }\n    }\n    if (isHerbivore(up)) { // up\n      if(veges > tex1(vec2(uv.x, uv.y - twopix))) {\n          col += tex1(vec2(uv.x, uv.y - twopix));\n      } else { col = 0.001; }\n    }\n    if (isHerbivore(down)) { // down\n      if(veges > tex1(vec2(uv.x, uv.y + twopix))) {\n          col += tex1(vec2(uv.x, uv.y + twopix));\n      } else { col = 0.0061; }\n    }\n             \n  \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.) ) {\n        float r = rand(uv);\n        if (r < 0.1) {\n         \tfragColor = vec4(rand(uv),0.,0,1.);\n        } else {\n//          \tfragColor = vec4(1.,1.,0,1.);\n          \tfragColor = vec4(0.);\n        }\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n        return;\n    }\n   // col = clamp(col, -1., 1.);\n  \n    fragColor = vec4(vec3(abs(col)), 1.0);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n/* HABITAT */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos)\n#define tex3(pos) texture(iChannel3, pos).z\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float A = tex0(uv);\n    vec4  B = tex1(uv);\n    float D = tex3(uv);\n\n    vec4 veges = vec4(0.);\n    vec4 colour = habitat(uv);// + vec4(0., amoeba(uv).r*1.1, 0., 0.);\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    int counter = 0; // for life alg\n\n\n\n  //  B-=A*0.8;\n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 256.)) {\n\n        \n          //  fragColor += 1.95+ dot(iDate,vec4(A)) ; ///,0.1,uv);\n               \tfragColor = vec4(uv.y,0.,0.,0.);\n\n       return;\n    }\n    \n    if(iFrame < 2 && length(vec2(0.5,0.5) - uv.xy) < 0.1251) // fill blank space with cells\n    {\n        if (rand(uv) > 0.99) {\n            fragColor = vec4(rand(uv));\n            return;\n        }\n        \n       \n    }\n\nvec4 amount = vec4(0.75+uv.y*0.2-uv.x*0.2);\n//vec4 amount = vec4(0.11+uv.y*0.2-uv.x*0.2);\n//vec4 amount = vec4(0.4 + uv.x);\n//vec4 amount = vec4(0.6 + uv.x);\n\n\nif ( habitat(vec2(uv.x-p.x, uv.y-p.y)).x > 0.) {veges += amount;counter++;} // left d\nif ( habitat(vec2(uv.x+p.x, uv.y-p.y)).x > 0.) {veges += amount;counter++;} // right up\nif ( habitat(vec2(uv.x-p.x, uv.y+p.y)).x > 0.) {veges += amount;counter++;} // right up\nif ( habitat(vec2(uv.x+p.x, uv.y+p.y)).x > 0.) {veges += amount;counter++;} // right down\n\nif ( habitat(vec2(uv.x-p.x, uv.y)).x > 0.) {veges += amount;counter++;} // left d\nif ( habitat(vec2(uv.x+p.x, uv.y)).x > 0.) {veges += amount;counter++;} // right up\nif ( habitat(vec2(uv.x, uv.y+p.y)).x > 0.) {veges += amount;counter++;} // right up\nif ( habitat(vec2(uv.x, uv.y+p.y)).x > 0.) {veges += amount;counter++;} // right down\n\n\n\n// amoeba.x is the herbivore\n// amoeba.y is it's urinations = good for tree growth\nif ( amoeba(vec2(uv.x-p.x, uv.y-p.y)).y > 0.) {veges += amount;counter++;} // left d\nif ( amoeba(vec2(uv.x+p.x, uv.y-p.y)).y > 0.) {veges += amount;counter++;} // right up\nif ( amoeba(vec2(uv.x-p.x, uv.y+p.y)).y > 0.) {veges += amount;counter++;} // right up\nif ( amoeba(vec2(uv.x+p.x, uv.y+p.y)).y > 0.) {veges += amount;counter++;} // right down\n\nif ( amoeba(vec2(uv.x-p.x, uv.y)).y > 0.) {veges += amount;counter++;} // left d\nif ( amoeba(vec2(uv.x+p.x, uv.y)).y > 0.) {veges += amount;counter++;} // right up\nif ( amoeba(vec2(uv.x, uv.y+p.y)).y > 0.) {veges += amount;counter++;} // right up\nif ( amoeba(vec2(uv.x, uv.y+p.y)).y > 0.) {veges += amount;counter++;} // right down\n\nif ( amoeba(vec2(uv.x-p.x, uv.y-p.y)).x > 0.) {veges -= amount;counter--;} // left d\nif ( amoeba(vec2(uv.x+p.x, uv.y-p.y)).x > 0.) {veges -= amount;counter--;} // right up\nif ( amoeba(vec2(uv.x-p.x, uv.y+p.y)).x > 0.) {veges -= amount;counter--;} // right up\nif ( amoeba(vec2(uv.x+p.x, uv.y+p.y)).x > 0.) {veges -= amount;counter--;} // right down\n\nif ( amoeba(vec2(uv.x-p.x, uv.y)).x > 0.) {veges -= amount;counter--;} // left d\nif ( amoeba(vec2(uv.x+p.x, uv.y)).x > 0.) {veges -= amount;counter--;} // right up\nif ( amoeba(vec2(uv.x, uv.y+p.y)).x > 0.) {veges -= amount;counter--;} // right up\nif ( amoeba(vec2(uv.x, uv.y+p.y)).x > 0.) {veges -= amount;counter--;} // right down\n    \n    float e = veges.x;\n    if (counter < 0) { e = 0.; } \n    colour += abs(veges)*0.00005951951 * D; \n    // GROWT FUNC:\n    if (e > 0.1 && e < 20.40) { colour += vec4(0.1251-uv.y*0.009, 0., 0., 0.); } else {colour+=vec4(-0.001);}\n\n    // DEATH BY EATING BY AMOEBA:\n    if (veges.x > 80. || amoeba(uv).x > 0.5 && amoeba(uv).y<0.951) colour = vec4(0.);\n    \n    // crowding:\n    if (abs(counter) > 8) { colour += vec4(-0.21, uv.y*0.1, 0., 0.);}\n\n    fragColor = colour;\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\nfloat rand(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nuint seed2 = uint(0);\nfloat r(uint s)  // random float\n{\n    return float(Hash(s)) / 4294967295.0;\n}\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r(uint(p.x*100.));\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\nfloat roughNoise1(vec2 uv, int depth, float roughness, uint s)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(s), 5.754*r(s)); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness, uint s)\n{\n    uv += vec2(27.238*r(s), 16.162*r(s+uint(1)));\n\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(s+uint(2)), 5.754*r(s+uint(3))); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}", "buffer_c_code": "#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <3 ) {\n        fragColor = vec4(0.75) -  vec4(fragCoord,fragCoord.x,fragCoord.y);\n        return;\n     }\n\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/* THE RAIN */\n#define A 4\n\n#define rainSpeed 4. // float of A\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nfloat hash(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check if there is an arriving particle at this pixel in next frame\nfloat arrivingParticle(vec2 coord, out vec4 partData) {\n\t// scan area from -D to D\n\tvec2 uv = coord / iResolution.xy;\n    float veges = habitat(uv).x;\n    float returnval = 0.;\n\t// scan area from -D to D\n    for (int i=-A; i<A; i++) {\n        for (int j=-A; j<A; j++) {\n            // position to check\n            vec2 arrCoord = coord + vec2(i,j);\n            vec4 data = texture(iChannel3, arrCoord/iResolution.xy);\n            vec4 plant = texture(iChannel1, arrCoord/iResolution.xy);\n            vec4 herbi = texture(iChannel0, arrCoord/iResolution.xy);\n            \n            // no particles here\n            if (dot(data,data)<1.9991) continue;\n            // get next position of particle\n            vec2 nextCoord = data.xy + data.zw;\n\n            // distance between next position and current pixel\n            vec2 offset = abs(coord - nextCoord);\n            // if the distance is within half a pixel pick this particle\n            // (other arriving particles are dismissed)\n            if (offset.x<.5 && offset.y<.5) {\n                partData += data;\n                return 1.;\n            }\n            if (plant.x > 0.5 || herbi.x > 0.5) {  partData = vec4(0.); }\n\n        }\n    }\n    // no particles arriving here\n\treturn 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n \t// random particles at the top, xy is position, zw velocity\n    if (fragCoord.y > iResolution.y - float(A) || fragCoord.x > iResolution.x - float(A)) {\n        fragColor = vec4(fragCoord.xy, hash(vec2(uv.x , iTime)) * rainSpeed, hash(vec2(uv.y , iTime)) * -rainSpeed); \n        return;\n    }\n    if (hash(uv) > 0.99) {\n        fragColor = vec4(1., 1.0, 1.0, 1.0);\n        //hash(vec2(uv.x , iTime)) * rainSpeed, hash(vec2(uv.y , iTime)) * -rainSpeed);} \n    }\n    \n    // get the data of a particle arriving at this pixel \n    vec4 partData;\n    float p = arrivingParticle(fragCoord, partData);\n\n    // no particles, empty pixel\n    if (p < 1.) {\n    \tfragColor = vec4(p);\n        return;\n    }\n    \n    // update position with current velocity altered by channels r & b in the video\n    float vel = max(0.,1.-length(texture(iChannel1,fragCoord/iResolution.xy).rb));\n    partData.xy += partData.zw*vel;\n\n    //set particle data\n    fragColor = partData;\n}", "buffer_d_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2yzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 494, 518, 518, 691], [692, 692, 749, 749, 1302]]}
{"id": "ddjyRw", "name": "Bouncing ball (192 chars)", "author": "Nguyen2007", "description": "Try some procedural animation", "tags": ["2d"], "likes": 10, "viewed": 250, "published": 3, "date": "1687548620", "time_retrieved": "2024-07-30T17:47:45.551772", "image_code": "// -13 chars thanks to FabriceNeyret2\n\nvoid mainImage(out vec4 O, vec2 p)\n{\n    float t = fract(iTime + texture(iChannel0, p *= 18. / iResolution.y).x / 30.),\n          r = 1. - t,\n          b = 65. * t * r + .4,\n          s = tanh(b) + .4 * sin(22. * t) * r;\n    \n    O = vec4(length(vec2((p.x - 16.) * s * s, p.y - b)) < s);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 75, 75, 328]]}
{"id": "mdjcRw", "name": "Cosmos-Komodo", "author": "hellhand", "description": "Did you see the komodo?", "tags": ["stars", "cosmos", "black", "panda", "komodo"], "likes": 4, "viewed": 337, "published": 3, "date": "1687536612", "time_retrieved": "2024-07-30T17:47:46.730620", "image_code": "#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord.xy - 0.502*iResolution.xy) / iResolution.y; \n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv) - 0.1;\n    vec2 st = exp(vec2(cos(a)/PI, r) * 2.0*log(r)) - 0.2*iTime;\n    \n    vec4 col = texture(iChannel0, st);\n    col *= 0.01*r - log(r);\n\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 423]]}
{"id": "ddjcRw", "name": "Cosmos-Dolphin", "author": "hellhand", "description": "Did you see the dolphin?", "tags": ["stars", "cosmos", "dolphin", "black", "panda"], "likes": 3, "viewed": 196, "published": 3, "date": "1687536350", "time_retrieved": "2024-07-30T17:47:47.873564", "image_code": "#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord.xy - 0.502*iResolution.xy) / iResolution.y; \n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv) - 0.2;\n    vec2 st = exp(vec2(abs(a)*r/PI, r) * sin(log(r))) - 0.2*iTime;\n    \n    vec4 col = texture(iChannel0, st);\n    col *= 0.01*r - log(r);\n\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 426]]}
{"id": "ms2yRw", "name": "Cosmos-Lion", "author": "hellhand", "description": "Did you see the lion?", "tags": ["stars", "cosmos", "black", "lion", "panda"], "likes": 4, "viewed": 192, "published": 3, "date": "1687536115", "time_retrieved": "2024-07-30T17:47:48.946695", "image_code": "#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord.xy - 0.502*iResolution.xy) / iResolution.y; \n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    vec2 st = vec2(a*sin(a)/PI, r) * log(r) - 0.2*iTime;\n    \n    vec4 col = texture(iChannel0, st);\n    col *= 0.01*r - log(r);\n\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2yRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 410]]}
{"id": "Dd2czm", "name": "Cosmos-Panda", "author": "hellhand", "description": "Did you see the panda?", "tags": ["stars", "cosmos", "black", "panda"], "likes": 0, "viewed": 134, "published": 3, "date": "1687535753", "time_retrieved": "2024-07-30T17:47:50.233255", "image_code": "#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord.xy - 0.502*iResolution.xy) / iResolution.y; \n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv) - 0.3;\n    vec2 st = vec2(a*sin(a)/PI, r) * sin(log(r)) - 0.2*iTime;\n    \n    vec4 col = texture(iChannel0, st);\n    col *= 0.01*r - log(r);\n\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2czm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 421]]}
{"id": "cd2czm", "name": "Cosmos-Zebra", "author": "hellhand", "description": "Did you see the zebra?", "tags": ["stars", "cosmos", "zebra", "black"], "likes": 0, "viewed": 141, "published": 3, "date": "1687535301", "time_retrieved": "2024-07-30T17:47:51.235575", "image_code": "#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord.xy - 0.502*iResolution.xy) / iResolution.y; \n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv) - 0.3;\n    vec2 st = vec2(a/PI*2.0, 0.1/r) + log(sin(-5.0*r - 10.0)) - 0.2*iTime;\n    \n    vec4 col = texture(iChannel0, st);\n    col *= 0.01*r - log(r);\n\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2czm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 434]]}
{"id": "cdjyzw", "name": "scrinkily binkily", "author": "UsamagorQ", "description": "balls", "tags": ["defaultshader"], "likes": 2, "viewed": 63, "published": 3, "date": "1687526956", "time_retrieved": "2024-07-30T17:47:52.395474", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n\n    // Time varying pixel color\n    vec3 col = 0.75 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col/=(fragCoord.x*fragCoord.x,fragCoord.y*fragCoord.y,cos(sqrt(uv.x*uv.y)));\n    // Output to screen  \n    vec3 balls = texture(iChannel0, uv).rgb;\n    fragColor = vec4(sqrt((sqrt(balls.x*balls.z)*log(col))),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float a = 0.05163*abs((sqrt(iTime/exp(cos(iTime*5.)))/(iTime/(iTime*sqrt(iTime/5.)))));\n   float bc = sqrt(acos(iTime))*log(fragCoord.x);\n    fragColor = vec4(a,bc,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 457]]}
{"id": "mdByRm", "name": "Canal Ruins 2", "author": "dr2", "description": " Update includes using path based on hexagonal Truchet tiles (mouseable).", "tags": ["hexagon", "truchet", "path", "boat"], "likes": 27, "viewed": 307, "published": 3, "date": "1687513552", "time_retrieved": "2024-07-30T17:47:53.760824", "image_code": "// \"Canal Ruins 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 9 in \"Truchet Path\" series; others listed in \"Truchet Path Journey\" (mdXyRB).\n*/\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat HexEdgeDist (vec2 p, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n#define N_BOAT 3\n\nmat3 boatMat[N_BOAT];\nvec4 cPath[PLEN];\nvec3 boatPos[N_BOAT], qHit, sunDir, cHit, qnHit;\nvec2 cIdB, cMidB;\nfloat tCur, dstFar, tEnd[PLEN + 1], boatAng[N_BOAT], hgSizeB, vgSize, tLen, cDir, cType, watHt;\nint nFrame, idObj, idObjGrp;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = sign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nbool HexCellOcc ()\n{\n  vec2 q;\n  float h, s;\n  bool hCut;\n  cIdB = PixToHex (cHit.xz / hgSizeB);\n  BConf ();\n  hCut = false;\n  q = (cHit.xz - cMidB) / hgSizeB;\n  if (hCut) s = hgSizeB * abs (TruchSDist (q).x) - 4.1;\n  else s = length (vec2 (hgSizeB * abs (TruchSDist (q).x), cHit.y) *\n      vec2 (0.8 - 0.5 * sin (0.05 * pi * cHit.z), 0.3)) - 4.1;\n  s = min (s, hgSizeB * HexEdgeDist (q) - 3.1);\n  if (s > 6.) {\n    h = - cHit.y;\n  } else {\n    if (hCut) h = min (s, 1. - cHit.y);\n    else h = SmoothMin (s, 15. + 6. * dot (sin (0.06 * pi * cHit - sin (0.01 * pi * cHit.yzx)),\n       vec3 (1.)) - cHit.y, 4.);\n  }\n  return (h > 0.);\n}\n\nvec2 PixToHexS (vec2 p)\n{\n  vec2 c, r, dr;\n  p.y *= 2./sqrt3;\n  c = p.yx;\n  r = floor (c);\n  r += 2. * fract (0.5 * vec2 (r.x, r.y + step (0.5, fract (0.25 * r.x + 0.25))));\n  dr = c - r;\n  r += step (2., dot (abs (dr), vec2 (sqrt3, 1.))) * sign (dr) * vec2 (2., 1.);\n  r.x *= sqrt3/2.;\n  return r;\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{  // (based on \"Atlantis 2\")\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, sy;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  cHit = vec3 (PixToHexS (ro.xz).yx, vgSize * floor (ro.y / vgSize + 0.5)).xzy;\n  hv[0] = vec2 (1., 0.);\n  hv[1] = vec2 (0.5, 0.5 * sqrt3);\n  hv[2] = vec2 (-0.5, 0.5 * sqrt3);\n  for (int k = 0; k < 3; k ++) hv[k] *= sign (dot (hv[k], rd.xz));\n  sy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    w = ro - cHit;\n    ht.z = dstFar;\n    for (int k = 0; k < 3; k ++) {\n      htt = vec3 (hv[k].xy, (1. - dot (hv[k], w.xz)) / dot (hv[k], rd.xz));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * sy * vgSize - w.y) / rd.y;\n    if (ht.z < ty) cHit.xz += 2. * ht.xy;\n    else cHit.y += sy * vgSize;\n    if (HexCellOcc ()) {\n      if (ht.z < ty) {\n        dHit = ht.z;\n        qnHit.xy = ht.xy;\n      } else {\n        dHit = ty;\n        qnHit.z = sy;\n      }\n      qnHit = - qnHit.xzy;\n      break;\n    }\n  }\n  return dHit;\n}\n\nfloat HexCellEdge (vec3 p)\n{\n  vec2 dh;\n  float d;\n  dh = p.xz - cHit.xz;\n  if (qnHit.y == 0.) {\n    d = min (abs (length (dh - dot (dh, qnHit.xz) * qnHit.xz) - 1./sqrt3),\n       abs (fract (p.y / vgSize) - 0.5) * vgSize);\n  } else {\n    dh = abs (dh);\n    d = max (dot (vec2 (0.5, sqrt3/2.), dh), dh.x) - 1.;\n  }\n  return d;\n}\n\nvec3 HexPrisCol (vec3 p, float dEdge)\n{\n  vec3 col;\n  vec2 cIdS, c;\n  float b;\n  col = vec3 (1.);\n  col *= 1. - 0.1 * smoothstep (0.01, 0.03, abs (dEdge));\n  if (abs (qnHit.y) < 0.9 && mod (floor (p.y / vgSize + 0.5), 2.) == 0.) col *= 0.9;\n  if (qnHit.y == 1. && p.y < 0.4) {\n    col *= vec3 (0.3, 0.5, 0.3);\n  } else {\n    cIdS = PixToHex (cHit.xz);\n    c = vec2 (1., 0.96);\n    b = mod (dot (mod (2. * cIdS + cIdS.yx, 3.), vec2 (1., 2.)), 3.);\n    col *= (b == 0.) ? c.xyy : ((b == 1.) ? c.yxy : c.yyx);\n    if (qnHit.y == 1.) col *= 0.8;\n  }\n  col *= 1. - 0.4 * smoothstep (10., 15., hgSizeB * abs (TruchSDist ((p.xz - cMidB) / hgSizeB).x));\n  col = mix (vec3 (0., 0.3, 0.), col, 0.6 + 0.4 * smoothstep (0., 0.15, p.y - watHt));\n  return col;\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 0.9;\n  d = PrCylDf (p, 1.2, 3.5);\n  if (d < 0.1) {\n    q = p;\n    d = max (max (PrRoundCylDf (q, -0.8, 2., 1.5), - max (PrRoundCylDf (q - vec3 (0., 0.1, 0.),\n       -0.85, 2., 1.5), abs (q.y) - 0.1)), abs (q.y + 0.1) - 0.1);\n    q.y -= -0.2;\n    d = max (SmoothMin (d, max (PrRoundCylDf (q, -1., 2., 1.3 ), q.y), 0.1), q.z - 2.);\n    DMINQ (idObjGrp + 1);\n    q = p;\n    q.yz -= vec2 (-0.5, -0.2);\n    d = max (PrRoundCylDf (q, -0.1, 1.1, 1.2), max (0.4 - q.y, q.z - 1.2));\n    DMINQ (idObjGrp + 2);\n    q = p;\n    q.yz -= vec2 (0.8, 0.5);\n    d = PrCylDf (q.xzy, 0.04, 0.3);\n    DMINQ (idObjGrp + 3);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, -0.9, 2.);\n    d = PrRoundBoxDf (q, vec3 (0.02, 0.2, 0.1), 0.03);\n    DMINQ (idObjGrp + 4);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, bScl;\n  bScl = 0.9;\n  dMin = dstFar / bScl;\n  for (int k = VAR_ZERO; k < N_BOAT; k ++) {\n    idObjGrp = (k + 1) * 256;\n    dMin = BoatDf (boatMat[k] * (p - boatPos[k]) / bScl, dMin);\n  }\n  return bScl * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec4 BoatCol ()\n{\n  vec4 col4, c4;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  c4 = vec4 (1., 0.1, 0.1, 0.2);\n  c4.rgb = (ig == 1) ? c4.rgb : ((ig == 2) ? c4.grb : c4.rrg);\n  if (id == 1) col4 = (abs (qHit.y - 0.1) < 0.01) ? vec4 (0.7, 0.4, 0.2, 0.1) * (1. -\n     0.2 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.))) :\n     ((qHit.y > -0.3) ? c4 : vec4 (0.6, 0.6, 0.8, 0.1));\n  else if (id == 2) col4 = (abs (abs (qHit.x) - 0.4) < 0.36 && qHit.y > 0.45 &&\n     length (vec2 (abs (qHit.x) - 0.1, qHit.y - 0.2)) < 0.7 || abs (abs (qHit.z + 0.2) -\n     0.6) < 0.5 && abs (qHit.y - 0.65) < 0.2) ? vec4 (0.2, 0.2, 0.6, -2.) : c4;\n  else if (id == 3) col4 = (qHit.y > 0.25) ? vec4 (c4.rgb, -1.) : vec4 (0.6, 0.6, 0.8, 0.1);\n  else if (id == 4) col4 = vec4 (0.5, 0.6, 0.5, 0.1);\n  return col4;\n}\n\nfloat WakeFac (vec3 p)\n{\n  vec3 twa;\n  vec2 tw;\n  float twLen, twLenMin, wkFac;\n  twLenMin = 1e6;\n  for (int k = 0; k < N_BOAT; k ++) {\n    tw = p.xz - (boatPos[k].xz - Rot2D (vec2 (0., 2.), boatAng[k]));\n    twLen = length (tw);\n    if (twLen < twLenMin) {\n      twLenMin = twLen;\n      twa = vec3 (tw, boatAng[k]);\n    }\n  }\n  twa.xy = Rot2D (twa.xy, - twa.z);\n  wkFac = clamp (1. - 1.5 * abs (twa.x), 0., 1.) * clamp (1. - 2. * twa.y, 0., 0.2) *\n     smoothstep (-4.5, -1.5, twa.y) * (1. - smoothstep (-0.3, 0.2, twa.y));\n  return wkFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, row;\n  float dstObj, dstWat, dstBlk, dEdge, sh, reflFac, wkFac;\n  reflFac = 1.;\n  if (rd.y == 0.) rd.y = 0.001;\n  bgCol = SkyCol (rd);\n  dstWat = - (ro.y - watHt) / rd.y;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstBlk = HexVolRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    if (k == 0 && rd.y * (min (dstBlk, dstObj) - dstWat) < 0.) {\n      ro += dstWat * rd;\n      row = ro;\n      wkFac = WakeFac (row);\n      vn = vec3 (0., 1., 0.);\n      if (wkFac > 0.) vn = VaryNf (64. * ro, vn, 8. * wkFac);\n      else vn = VaryNf (2. * ro, vn, 0.2);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      reflFac = 0.8;\n    } else break;\n  }\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      ro += dstBlk * rd;\n      dEdge = HexCellEdge (ro);\n      col4 = vec4 (HexPrisCol (ro, dEdge), 0.);\n      vn = qnHit;\n      vn = VaryNf (4. * ro, vn, ((abs (vn.y) < 0.95) ? 3. * (1. -\n         0.95 * smoothstep (40., 60., dstBlk)) : 0.5) * smoothstep (0.01, 0.03, abs (dEdge)));\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = BoatCol ();\n    }\n    sh = min (0.6 + 0.4 * smoothstep (12., 16., HexVolRay (ro + 0.01 * vn, sunDir)),\n       ObjSShadow (ro + 0.01 * vn, sunDir));\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.2 * max (dot (sunDir * vec3 (-1., 1., -1.), vn), 0.) +\n         0.8 * sh * max (dot (sunDir, vn), 0.)) + col4.a * step (0.95, sh) *\n         pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n    } else {\n      col = (sh > 0.7) ? 0.6 * SkyCol (reflect (rd, vn)) : col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n    }\n   } else col = SkyCol (rd);\n  col *= reflFac;\n  if (reflFac < 1. && wkFac > 0.) col = mix (col, vec3 (0.9),\n     8. * wkFac * clamp (0.1 + 0.5 * Fbm3 (8. * row), 0., 1.));\n  if (reflFac == 1.) dstWat = 0.;\n  col = mix (col, bgCol, smoothstep (0.8, 0.95, (dstWat + min (dstBlk, dstObj)) / dstFar));\n  return clamp (col, 0., 1.);\n}\n\nvoid BoatPM (float t, out vec3 bPos, out mat3 bMat, out float btAng)\n{\n  vec2 pc[3], cs, vd;\n  float bAz;\n  for (int j = VAR_ZERO; j < 3; j ++)\n     pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * 0.2 : 0.));\n  bPos.xz = pc[0];\n  bPos.y = watHt + 0.1 * (Fbm1 (4. * t) - 0.4);\n  vd = pc[2] - pc[1];\n  bMat[2] = vec3 (Rot2D (vec2 (1., 0.), 0.4 * (Fbm1 (t) - 0.5)), 0.);\n  bMat[0] = normalize (vec3 (0., 0.1, 1.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  bAz = atan (vd.y, - vd.x);\n  btAng = 0.5 * pi - bAz;\n  cs = sin (bAz + vec2 (0.5 * pi, 0.));\n  bMat *= mat3 (cs.x, 0., cs.y, 0., 1., 0., - cs.y, 0., cs.x);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col, pAv;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, trVel, bGap, nc, t;\n  int vuId, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 18000.) + 30. * floor (dateCur.w / 3600.);\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n    mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n    if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  hgSizeB = 48.;\n  vgSize = 0.75;\n  SetPath ();\n  watHt = -1.;\n  bGap = 0.65;\n  trVel = 0.4;\n  t = (tCur + 10.) * trVel;\n  for (int k = VAR_ZERO; k < N_BOAT; k ++) {\n    BoatPM (t + float (k) * bGap, boatPos[k], boatMat[k], boatAng[k]);\n    pAv += boatPos[k];\n  }\n  nc = float (N_BOAT);\n  pAv /= nc;\n  if (vuId == 0 || vuId == 1) {\n    if (uv.y > 1. - 2. * SmoothBump (0.25, 0.75, 0.01, fract (0.025 * tCur))) vuId = 1 - vuId;\n    if (vuId == 1) t += (nc + 0.1 + 0.4 * (1. + sin (0.05 * pi * tCur))) * bGap;\n    else t -= (1. + 0.4 * (1. + sin (0.05 * pi * tCur))) * bGap;\n    ro.xz = EvalPPos (t);\n    ro.y = 1.5;\n    vd = normalize (pAv - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y);\n    el += 0.05 * pi;\n    el = clamp (el, -0.45 * pi, 0.45 * pi);\n    dstFar = 200.;\n    zmFac = 2.2;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 60., ((2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.x -= 1.5 * hgSizeB;\n    vd = normalize (pAv - ro);\n    az = 0.3 * az + atan (vd.z, - vd.x) - 0.5 * pi;\n    el = 0.3 * el + asin (vd.y);\n    el = clamp (el, -0.45 * pi, -0.15 * pi);\n    dstFar = 300.;\n    zmFac = 2.5;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 2. * pi * sin (0.0005 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat HexEdgeDist (vec2 p, float h)\n{\n  p = abs (p);\n  p -= vec2 (0.5, - sqrt3/2.) * min (p.x - sqrt3 * p.y, 0.);\n  p.x -= h * sqrt3/2.;\n  return sign (p.x) * max (abs (p.x), abs (p.y) - 0.5 * h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdByRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1338, 1338, 1359, 1359, 1382], [1384, 1384, 1410, 1410, 2394], [2396, 2396, 2417, 2417, 3063], [3065, 3065, 3082, 3082, 3927], [3929, 3929, 3954, 3954, 4606], [4608, 4608, 4623, 4623, 5332], [5334, 5334, 5354, 5354, 5968], [5970, 5970, 5995, 5995, 6270], [6272, 6272, 6308, 6336, 7369], [7371, 7371, 7399, 7399, 7698], [7700, 7700, 7739, 7739, 8448], [8450, 8450, 8485, 8485, 9309], [9311, 9311, 9333, 9333, 9568], [9570, 9570, 9603, 9603, 9786], [9788, 9788, 9809, 9809, 10066], [10068, 10068, 10105, 10105, 10360], [10362, 10362, 10385, 10385, 10548], [10550, 10550, 10567, 10567, 11362], [11364, 11364, 11388, 11388, 11906], [11908, 11908, 11943, 11943, 13971], [13973, 13973, 14043, 14043, 14592], [14612, 14612, 14668, 14668, 18092], [18094, 18094, 18140, 18140, 18187], [18189, 18189, 18231, 18231, 18282], [18284, 18284, 18341, 18341, 18417], [18419, 18419, 18443, 18443, 18673], [18675, 18675, 18699, 18699, 18755], [18757, 18757, 18785, 18785, 18865], [18867, 18867, 18904, 18904, 19065], [19067, 19067, 19097, 19097, 19210], [19212, 19212, 19243, 19243, 19307], [19309, 19309, 19345, 19345, 19551], [19553, 19553, 19575, 19575, 19602], [19604, 19604, 19626, 19626, 19653], [19655, 19655, 19700, 19700, 19792], [19794, 19794, 19839, 19839, 19877], [19879, 19879, 19936, 19936, 20019], [20053, 20053, 20077, 20077, 20137], [20139, 20139, 20163, 20163, 20275], [20277, 20277, 20301, 20301, 20444], [20446, 20446, 20470, 20470, 20523], [20525, 20525, 20550, 20550, 20696], [20698, 20698, 20723, 20723, 20907], [20909, 20909, 20934, 20934, 21159], [21161, 21161, 21183, 21183, 21337], [21339, 21339, 21360, 21360, 21515], [21517, 21517, 21538, 21538, 21693], [21695, 21695, 21724, 21724, 21936], [21938, 21938, 21977, 21977, 22229]]}
{"id": "msByRw", "name": "Counting Up In Binary", "author": "tomachi", "description": "The shader is counting in binary.", "tags": ["binary"], "likes": 2, "viewed": 120, "published": 3, "date": "1687509000", "time_retrieved": "2024-07-30T17:47:54.713277", "image_code": "#define tex0(pos) texture(iChannel0, pos)\n#define tex1(pos) texture(iChannel1, pos)\n#define tex2(pos) texture(iChannel2, pos)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = tex0(uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define tex0(pos) texture(iChannel0, pos)\n#define tex1(pos) texture(iChannel1, pos)\n#define tex2(pos) texture(iChannel2, pos)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    float samp = tex0(vec2(uv.x - p.x, uv.y - p.y)).x;\n    float col = tex0(uv).x;\n    if (fragCoord.x <= 1. && fragCoord.y <= 1. || samp >=1.) {\n        col += -1.;\n        col = abs( col);\n    }\n    \n    fragColor = vec4(col);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msByRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 183, 233, 326]]}
{"id": "DsjcRD", "name": "Gauges", "author": "QuantumSuper", "description": "An auti-VJ including a variety of gauges each working on their own. Went for the look of a messy dashboard, convoluted but informative at the same time.\n\n- Use with music in iChannel0 -", "tags": ["2d", "music", "gauge"], "likes": 13, "viewed": 301, "published": 3, "date": "1687473469", "time_retrieved": "2024-07-30T17:47:55.832285", "image_code": "// Gauges 0.8.230622 by QuantumSuper\n// auto-vj including a variety of gauges each working on their own\n// \n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 2.133333*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\tfor (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvec3 getCol(float id){ //color definitions, for triplets\n    vec3 setCol = vec3(0);\n    id = mod(id,15.);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    else if (id<13.) setCol = vec3( 28,142, 77); //matrix green\n    else if (id<14.) setCol = vec3( 66,120, 91); //matrix green 2\n    else if (id<15.) setCol = vec3(173,  0, 27); //matrix red\n    return setCol/256.;\n}\n\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\nvec2 aaStep( vec2 fun){return vec2( aaStep(fun.x), aaStep(fun.y));} //overload\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat sdCircle( vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b;\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b){//source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\nvec3 getCircScale( vec2 p, float a, float s){ //in( position, amplitude, scale scale); out( circle, scale, indicator)\n    float rho = atan(p.x,p.y)/PI/2.+.5; //polar angle flipped & shifted, 0..1\n    return vec3(aaStep( sdCircle( p, .5)), //circle\n        (aaStep( abs(sdCircle( p, .46))-.01) //ring\n        + aaStep( fract((rho-1./8.)*s*10.*4./3.)-.03) * aaStep( abs(sdCircle( p, .39))-.06) //large scale, 10%\n        + aaStep( fract((rho-1./8.)*s*10.*4./3.+.5)-.01) * aaStep( abs(sdCircle( p, .41))-.04) //mid scale, 5%\n        + aaStep( fract((rho-1./8.)*s*100.*4./3.)-.03) * aaStep( abs(sdCircle( p, .43))-.02)) //small scale 1%\n        * aaStep( fract(rho-1.01/8.)-3./4.), //bottom cutout\n        aaStep( sdSegment( p*rotM(-(a-1./6.)*3./2.*PI), vec2(0), vec2(-.4,0)) - .01/length(p/.1))); //indicator\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // General initialization\n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1..1, square aspect ratio\n\tfloat rho = atan(uv.x,uv.y)/PI/2.+.5; //polar angle flipped & shifted, 0..1\n    float colId = 3. * floor(mod(aTime/16.,5.)); //color set id \n    vec3 col = getCol(colId+2.) * fft.x * .05; //background \n    vec4 tmp; //temporary values\n \n \n    // Gauge, left\n    tmp.xyz = getCircScale( uv*1.6+vec2(.79,.18), fft.x, 1.);\n    col *= 1.-tmp.x; //delete col\n    col += tmp.x*(1.-tmp.y)*(1.-tmp.z) * getCol(colId+2.) * (1.-.5*fft.x) * .5 + tmp.y*(1.-tmp.z) * getCol(colId+1.) * (.2+.8*fft.x) * .8 + tmp.z*getCol(colId);\n\n\n     // Double gauge, top mid\n    tmp.xyz = clamp((getCircScale( (uv*vec2(1,-1)+vec2(.125, .5))*rotM( PI/4.), 1.-fft.z*.27, 1./.27)  * vec3(1.-aaStep(uv.xx),1.) //right half of double scale \n        + getCircScale( (uv*vec2(1,-1)-vec2(.125,-.5))*rotM(-PI/4.), fft.y*.27, 1./2.7) * vec3(aaStep(uv.xx),1.))//left half of double scale\n        * aaStep(uv.y-.58),.0,1.); //cut of unused part \n    col *= 1.-tmp.x; //delete col\n    col += tmp.x*(1.-tmp.y)*(1.-tmp.z) * getCol(colId+1.) * (1.-.2*(fft.y+fft.z)) * .5 //circle\n        + tmp.y*(1.-tmp.z) * getCol(colId+0.) * (.6+.2*(fft.y+fft.z)) * .8 //scale\n        + tmp.z * getCol(colId+2.); //indicator\n    \n    \n    // Led lights\n    col *= 1.-aaStep(sdCircle( uv-vec2(.31,.07), .07)); //delete col\n    tmp.x = sdCircle( uv-vec2(.31,.07), .07*ffts.w);\n    col += (aaStep( sdCircle( uv-vec2(.31,.07), .07*ffts.w)) + .002/max(.002,tmp.x)) * getCol(colId+2.) * (.2+.8*fft.x); //extending circle near center\n    \n    for (float n=0.;n<4.;n++){ //lower left set of integrated four\n        tmp.x = sdCircle( uv+vec2(.449+.1*floor(n/2.),.22+.1*mod(ceil(n/2.),2.)), .03); //circles\n        col *= 1.-aaStep(tmp.x); //delete col\n        col += .002/max(.002,tmp.x) * getCol(colId+n) * (.2+.8*step( .91, texelFetch( iChannel0, ivec2(n,0), 0 ).x)); //light, bass channels\n    }\n    \n    \n    // Spectrum bars I, indicators, bottom right\n    tmp = vec4( //spectrum indicators (ugly but quick code)\n         aaStep(sdSegment( uv, -vec2(-.375-(.6* 6./512.),.4-.05), -vec2(.22,.13)-vec2(-.75-.002,.18-.002))-.002) //speech lower\n        +aaStep(sdSegment( uv, -vec2(-.375-(.6*24./512.),.4-.05), vec2(.22,-.13)-vec2(-.75+.002,.18-.002))-.002), //speech higher\n         aaStep(sdSegment( uv, -vec2(-.375+(.6*24./512.),.4-.05), vec2(.3,-.05)-vec2(-.18+.002,.1-.002))-.002) //presence lower\n        +aaStep(sdSegment( uv, -vec2(-.375+(.6*95./512.),.4-.05), -vec2(.3,.05)-vec2(-.18-.002,.1-.002))-.002), //presence higher\n         aaStep(sdSegment( uv, -vec2(-.375-(.6*95./512.)-.002,.4+.05-.002), -vec2(.45,-.02)-vec2(-.52-.002,.5-.002))-.002) //brilliance lower\n        +aaStep(sdSegment( uv, -vec2(-.375-(.6         )+.002,.4+.05-.002), vec2(.45,.02)-vec2(-.52+.002,.5-.002))-.002), //brilliance higher\n        0);\n    col *= 1.-clamp(dot(tmp,vec4(1)),.0,1.);\n    for (int n=0;n<3;n++) col += tmp[n] * getCol(colId+float(n)) * .2;\n    \n    \n    // Waveform\n    tmp = vec4( uv+vec2(-.16,.25), vec2(.32,.06)); \n    float wave = texelFetch( iChannel0, ivec2((tmp.x+tmp.z)*512./(2.*tmp.z)*.98+1.,1), 0).x; //get waveform from texture, trim edges\n    if (wave == 0.){ //catch if no waveform found\n        for (int n=0;n<9;n++) //synthesize crude approximation\n            wave += texelFetch( iChannel0, ivec2(n,0), 0 ).x * sin((tmp.x+tmp.z)*PI/tmp.z * float(n*n*n) + aTime*2.*PI);\n        wave = wave/18. + .5; //scale & shift\n    }\n    tmp.z = aaStep(sdBox( tmp.xy, tmp.zw)); //empty box\n    col *= 1.-tmp.z; //delete col\n    col += aaStep(abs(wave-.5-tmp.y/(2.*tmp.w))-.1) * tmp.z * getCol(colId+0.) * (.2+.8*ffts.w); //waveform in black box\n    \n    wave = .0;\n    tmp = vec4( uv+vec2(.499,.47), vec2(.23,.04));\n    for (int n=0;n<int(6.*fract(aTime));n++) //synthesize crude approximation\n        wave += texelFetch( iChannel0, ivec2(n,0), 0 ).x * sin((tmp.x+tmp.z)*PI/tmp.z * float(n));\n    wave = wave/(6.*fract(aTime)) + .5; //scale & shift\n    wave = aaStep(abs(wave-.5-tmp.y/(2.*tmp.w))-.01) * aaStep(abs(tmp.x)-tmp.z+.001);\n    col *= 1. - wave - aaStep( sdCircle( abs(tmp.xy)-vec2(tmp.z,.0), .01)); //delete col\n    col += wave * getCol(colId+2.); //bottom left waveform\n    \n    \n    // Spectrum bars II, bars itself, bottom right \n    tmp = vec4( uv+vec2(-.375,.4), vec2(.6,.05)); //spectrum bar mid\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\n    col *= 1.-tmp.y; //delete col\n    col += tmp.y * texelFetch( iChannel0, ivec2(1024.*abs(tmp.x/(2.*tmp.z)),0),0).x  * getCol(colId+2.); //sound texture, full, mirrored\n    \n    tmp = vec4( uv+vec2(-.75,.18), vec2(.22,.13)); //spectrum bar top right\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\n    col *= 1.-tmp.y; //delete col\n    tmp.x = texelFetch( iChannel0, ivec2(6.+18.*(tmp.x+tmp.z)/(2.*tmp.z),0),0).x; //sound texture, speech\n    col += tmp.x*tmp.x*tmp.x*tmp.x * tmp.y * getCol(colId+0.);   \n    \n    tmp = vec4( uv+vec2(-.18,.1), vec2(.3,.05)); //spectrum bar top left\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\n    col *= 1.-tmp.y; //delete col\n    tmp.x = texelFetch( iChannel0, ivec2(24.+71.*(tmp.x+tmp.z)/(2.*tmp.z),0),0).x; //sound texture, presence\n    col += tmp.x*tmp.x*tmp.x * tmp.y * getCol(colId+1.);     \n    \n    tmp = vec4( uv+vec2(-.52,.5), vec2(.45,.02)); //spectrum bar bottom\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw)); \n    col *= 1.-tmp.y; //delete col\n    col += texelFetch( iChannel0, ivec2(95.+417.*(tmp.x+tmp.z)/(2.*tmp.z),0),0).x * tmp.y * getCol(colId+2.); //sound texture, brilliance\n\n    \n    // Spectrum screen, top right\n    tmp = vec4( uv-vec2(.7,.26), vec2(.27));\n    tmp.z = aaStep(sdBox( tmp.xy, tmp.zw)); //empty box\n    col *= 1.-tmp.z; //delete col\n    tmp.xy /= 2.*tmp.w;\n    col += (texelFetch( iChannel0, ivec2(int(512.*2.*abs(tmp.x)),0),0).x - 2.*abs(tmp.y)) * tmp.z * getCol(colId+1.); //mirrored sound texture spectrum\n    \n    \n    // Fill bars, top left\n    tmp = vec4( -.94, .32, -.38, .012);\n    for (float n=0.;n<4.;n++){\n        col *= 1. - aaStep( sdSegment( uv, tmp.xy, tmp.zy) - tmp.w); //delete col\n        col += aaStep( sdSegment( uv, tmp.xy, tmp.zy) - tmp.w) * aaStep(fract((uv.x-tmp.x)/abs(-tmp.x+tmp.z)*4.) - .03) * getCol(colId+n) * ffts.w; //add scale\n        col += aaStep( sdSegment( uv, tmp.xy, vec2( tmp.x+fft[int(n)]*abs(tmp.z-tmp.x), tmp.y)) - tmp.w) * getCol(colId+n) * .5; //light bar\n        tmp.y += 4.5*tmp.w; //shift to the top\n        tmp.z -= .02/(n+n+1.); //shorten\n    }\n    \n    \n    // Shifter, bottom left\n    tmp = vec4( -.94, -.5, .0, 0);\n    for (float n=0.;n<3.;n++){\n        tmp.w = sdSegment( uv, tmp.xy, tmp.xz+vec2(.0,.16-n*.085))-.001;\n        col *= 1. - aaStep(tmp.w); //delete col\n        col += .002/max(.002,tmp.w) * getCol(colId+n+0.) * ffts[int(n)] //glow lines\n        * (1.-aaStep(fract((uv.y-tmp.y)/abs(-tmp.y+tmp.z)*2.04) - .01) * aaStep(abs(uv.x-tmp.x)-.004) * step(tmp.y-tmp.x,abs(uv.y)-tmp.y)); //indicators\n        tmp.w = aaStep( sdCircle( uv-tmp.xy-vec2(0.,ffts[int(n)]*(tmp.z-tmp.y)), .015));\n        col *= 1. - tmp.w; //delete col\n        col += tmp.w * getCol(colId+n+1.) * .5; //knob\n        tmp.x += .04;\n    }\n    \n    \n    // Triangle\n    tmp = vec4( (vec2(uv.x,-uv.y)+vec2(.81,.19))*7., 0, 0);\n    tmp.z = aaStep( sdEquilateralTriangle( tmp.xy));\n    col *= 1. - tmp.z; //delete col\n    col += tmp.z * mat3(getCol(colId+0.),getCol(colId+1.),getCol(colId+2.))*(.5+.5*vec3(tmp.xy,-tmp.x)) * .33; //triangle\n    col += .01/max(.01, sdCircle( tmp.xy-vec2( (ffts.z-ffts.y)*(1.-ffts.x*1.9), (2.*ffts.x-ffts.z-ffts.y)*.56), .08*fft.y)) //dot\n        * mat3(getCol(colId+0.),getCol(colId+1.),getCol(colId+2.)) * vec3(ffts.x>ffts.y && ffts.x>ffts.z,ffts.y>ffts.z && ffts.y>ffts.x,ffts.z>ffts.x && ffts.z>ffts.y); //coloring\n    \n    \n    // Finalizations\n    col *= .8+.3*hash21(uv*aTime); //noise\n    col -= length(uv) * .03; //vignette\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 33793, "src": "https://soundcloud.com/sleepnet/could-this-be-sleepnet-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 269, 360, 1480], [1482, 1482, 1504, 1538, 2571], [2573, 2573, 2598, 2598, 2640], [2641, 2663, 2686, 2686, 2730], [2743, 2743, 2762, 2762, 2815], [2838, 2838, 2859, 2929, 3022], [3024, 3024, 3057, 3057, 3083], [3085, 3085, 3114, 3173, 3253], [3255, 3255, 3296, 3354, 3472], [3474, 3474, 3510, 3569, 3773], [3775, 3775, 3820, 3892, 4582], [4584, 4584, 4639, 4670, 12670]]}
{"id": "mdSczD", "name": "Braids pattern", "author": "AndrewB330", "description": "2d braids pattern :)", "tags": ["2d", "pattern"], "likes": 13, "viewed": 168, "published": 3, "date": "1687472040", "time_retrieved": "2024-07-30T17:47:56.635138", "image_code": "#define s(p) max( d(p) - .4, .5 - d(p + f) )              //\n#define d(p) length( p - vec2( h(p), sin(h(p))) )          //\n#define h(p) ( p + cos(p) * ( (p).y - sin(p) )/2. ).x\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    p *= mat2(29, -29, 29, 29)/iResolution.x;\n    vec2 f = vec2(2.1, 0);\n    p.x += iTime * sign( sin(p.y * .79) );\n    p.y = mod(p.y, 4.) - 2.;\n    o = o*0. - min(min(s(p), s(p + f)), s(p + f + f)) /.1;\n}\n\n/*\n// Original 395\nfloat d(vec2 p)\n{\n    // distance to sin curve, one step Newton method\n    float x = p.x + (p.x + cos(p.x)*(p.y - sin(p.x)) - p.x) * 0.5;\n    return length(p - vec2(x, sin(x)));\n}\nfloat s(vec2 p)\n{\n    // sbtract(sin curve sdf, other thicker sin curve sdf)\n    return max(d(p) - 0.45, -d(p + vec2(2.1, 0)) + 0.5);\n}\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    vec2 R = iResolution.xy, p = (u - R * .5)/R.x * mat2(29, -29, 29, 29);\n    p.x += iTime * (1. - 2. * mod(floor(p.y * 0.25), 2.0));\n    p.y = mod(p.y, 4.) - 2.;\n    o = smoothstep(.0, .1, -min(min(s(p), s(p + vec2(2.1, 0))), s(p + vec2(4.2, 0)))) * vec4(1);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 214, 214, 420]]}
{"id": "Ds2yRW", "name": "Fork Psychedeli psql 351", "author": "psql", "description": "warmer color variant", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 5, "viewed": 135, "published": 3, "date": "1687469373", "time_retrieved": "2024-07-30T17:47:57.517779", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (uv.xy-0.5);\n\tvec2 cir = ((pos.xy*pos.xy+sin(uv.x*18.0+iTime)/25.0*sin(uv.y*7.0+iTime*1.5)/1.0)+uv.x*sin(iTime)/16.0+uv.y*sin(iTime*1.2)/16.0);\n\tfloat circles = (sqrt(abs(cir.x+cir.y*0.5)*25.0)*5.0);\n    \n    float r = sin(circles*1.25+2.0)*0.5 + 0.5; // purple and white component\n    float g = abs(sin(circles*1.0-1.0)-sin(circles)); // yellow component\n    float b = abs(sin(circles)*1.0)*0.5; // purple component\n\n    fragColor = vec4(r,g,b,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2yRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 564]]}
{"id": "ddBcRW", "name": "Colorful Blindness", "author": "ArtiFintell", "description": "Fork of \"Shader Art Coding Introduction\" by kishimisu. I just turned the Background black.", "tags": ["visual"], "likes": 2, "viewed": 166, "published": 3, "date": "1687458378", "time_retrieved": "2024-07-30T17:47:58.288717", "image_code": "// Fork of \"Shader Art Coding Introduction\" by kishimisu. https://shadertoy.com/view/mtyGWy\n// 2023-06-22 18:22:16\n\n/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 2.0);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 510, 535, 535, 719], [721, 721, 778, 778, 1264]]}
{"id": "DsSyzD", "name": "My first FLIUIDE", "author": "Deceleris", "description": "Simple perlin noise test", "tags": ["perlin"], "likes": 6, "viewed": 244, "published": 3, "date": "1687453107", "time_retrieved": "2024-07-30T17:47:59.057661", "image_code": "// Perlin noise from : https://www.shadertoy.com/view/DsK3W1\n\n// =================================\nvec2 n22 (vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 get_gradient(vec2 pos)\n{\n    float twoPi = 6.283185;\n    float angle = n22(pos).x * twoPi;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin_noise(vec2 uv, float cells_count)\n{\n    vec2 pos_in_grid = uv * cells_count;\n    vec2 cell_pos_in_grid =  floor(pos_in_grid);\n    vec2 local_pos_in_cell = (pos_in_grid - cell_pos_in_grid);\n    vec2 blend = local_pos_in_cell * local_pos_in_cell * (3.0f - 2.0f * local_pos_in_cell);\n    \n    vec2 left_top = cell_pos_in_grid + vec2(0, 1);\n    vec2 right_top = cell_pos_in_grid + vec2(1, 1);\n    vec2 left_bottom = cell_pos_in_grid + vec2(0, 0);\n    vec2 right_bottom = cell_pos_in_grid + vec2(1, 0);\n    \n    float left_top_dot = dot(pos_in_grid - left_top, get_gradient(left_top));\n    float right_top_dot = dot(pos_in_grid - right_top,  get_gradient(right_top));\n    float left_bottom_dot = dot(pos_in_grid - left_bottom, get_gradient(left_bottom));\n    float right_bottom_dot = dot(pos_in_grid - right_bottom, get_gradient(right_bottom));\n    \n    float noise_value = mix(\n                            mix(left_bottom_dot, right_bottom_dot, blend.x), \n                            mix(left_top_dot, right_top_dot, blend.x), \n                            blend.y);\n   \n    \n    return (0.5 + 0.5 * (noise_value / 0.7));\n}\n// =================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 aspected = vec2(fragCoord.x / (iResolution.y / iResolution.x), fragCoord.y);\n    aspected += perlin_noise(aspected + iTime * 30., 0.01f) * 500.;\n    vec2 uv = fract (aspected/iResolution.xy * 5.);\n    vec2 tile = abs ((uv - .5) * 2.);   \n    vec3 col = vec3(1.0, 2.0, 3.0);    \n    float m = max (tile.x, tile.y);\n    m = 0.02 / m;\n    col *= m * 3.;\n    col *= col;    \n    fragColor = vec4 (col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 99, 118, 118, 252], [254, 254, 283, 283, 392], [394, 394, 442, 442, 1525], [1564, 1564, 1621, 1621, 2037]]}
{"id": "mdlcRX", "name": "Year of Truchets #042", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \nthanks @stl for the inversion trick!", "tags": ["2d", "warp", "truchet", "inversion"], "likes": 29, "viewed": 283, "published": 3, "date": "1687449142", "time_retrieved": "2024-07-30T17:47:59.917363", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #042\n    06/22/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nfloat tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    \n    tspeed = T*.3;\n    tmod = mod(tspeed,12.5);\n\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n\n    // @stb polar thing.. \n    uv.x -= .25;\n    uv /= uv.x*uv.x + uv.y*uv.y;\n    uv.x += 2.;\n    \n    // inversion\n    float scale = 1.2726;\n    uv *= rot(-T*.035);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*scale;\n    uv.x -= T*.2;\n \n    float px = fwidth(uv.x); \n    \n    // std truchet stuff\n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float rnd = hash21(id.xy);\n    float ck =mod(id.x+id.y,2.)*2.-1.;\n\n    float sn = length(id*.25)+hash21(id.yx)*11.;\n    sn = mod(sn,10.);\n    \n    float t1 = lsp(sn,sn+.5,tmod);\n    float t2 = lsp(sn+2.,sn+2.5,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    q.xy*=rot((t1+t2)*1.5707);\n    \n    // main pattern\n    if(rnd>.5) q.y = -q.y;\n    rnd=fract(rnd*32.232);\n    \n    vec2 u2 = vec2(length(q-.5),length(q+.5));\n    vec2 q2 = u2.x<u2.y ? q-.5 : q+.5;\n    \n    float tk = .1275;\n    float d1 = abs(length(q2)-.5)-tk;\n    float d3 = length(q)-.485;\n    \n    if(rnd>.85) d1 = min(length(q.x)-tk,length(q.y)-tk);\n    \n    float d4=max(d1,d3);\n    d1=abs(d1)-.035;\n    d1=max(d1,d3);\n   \n    rnd=fract(rnd*32.232);\n\n    // color mixdown\n    vec3 C = hsv2rgb(vec3((uv.x*.025),.9,.1));\n    vec3 klr = hsv2rgb(vec3((rnd*.15)+(uv.x*.025),1.,.5));//vec3(.282,.114,.039)\n    vec3 clr = mix(vec3(.02,.341,.02),klr,rnd);//\n    C = mix(C,C*.75,smoothstep(.03+px,-px,d3-.035));\n    C = mix(C,clr,smoothstep(px,-px,d3));\n    C = mix(C,vec3(.5),smoothstep(px,-px,d1));\n    C = mix(C,klr*.425,smoothstep(px,-px,d4));\n    C = mix(C,vec3(.5),smoothstep(px,-px,abs(d3)-.015));\n\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlcRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[406, 406, 425, 425, 468], [469, 469, 491, 491, 549], [550, 550, 577, 577, 640], [641, 641, 678, 678, 712], [713, 713, 732, 732, 759], [761, 778, 805, 805, 921], [923, 923, 964, 964, 2671]]}
{"id": "mdfcW7", "name": "BC: Wispy Line", "author": "BackwardsCap", "description": "~~~~", "tags": ["line"], "likes": 9, "viewed": 203, "published": 3, "date": "1687443462", "time_retrieved": "2024-07-30T17:48:01.071277", "image_code": "float getColor(float y, float time, float diff, float speed, float seed, float mult)\n{\n    return y + sin((time + diff) * speed + seed) * mult;\n}\n\nvec3 getSplitColor(vec2 uv, float m, float seed)\n{\n    float speed = 1.2;\n    float xMult = 20. + seed * 10.;\n    float diff = 0.02;\n    float time = iTime + uv.x * xMult * m + cos(uv.x+iTime/5.)*10.;\n    time *= 0.5;\n    float r = getColor(uv.y, time, -diff, speed, seed, m);\n    float g = getColor(uv.y, time, 0., speed, seed, m);;\n    float b = getColor(uv.y, time, diff, speed, seed, m);;\n    return smoothstep(20./iResolution.y, 0., abs(vec3(r, g, b)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y/1.2;    \n    vec3 col = vec3(0);\n    float decay = cos(uv.x)/(3.14*2.)*1.5;\n\n    float iter = 50.;\n    for(float i=0.;i<iter;i++)\n    {\n        col += getSplitColor(uv, decay, (i*1.5)/iter);\n    }\n\n    fragColor = vec4(col/(iter/4.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 145], [147, 147, 197, 197, 607], [609, 609, 666, 666, 966]]}
{"id": "msjyzh", "name": "test_shader_tee", "author": "13917368953", "description": "test", "tags": ["test"], "likes": 1, "viewed": 125, "published": 3, "date": "1687438267", "time_retrieved": "2024-07-30T17:48:01.870142", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normorlize\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\n    //Get the distance\n    float d = length(uv);\n    \n    d=sin(d * iTime)/0.5;\n    d=abs(d);\n    d=smoothstep(0.0,0.1,d);\n    \n    fragColor = vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 74, 302]]}
{"id": "7sfyDB", "name": "Simple line with normal and trim", "author": "G4ROOT", "description": "Draw a line and trim each end. draw other stuff base on the line normal", "tags": ["line", "geometry", "dot"], "likes": 1, "viewed": 161, "published": 3, "date": "1687426723", "time_retrieved": "2024-07-30T17:48:02.975187", "image_code": "#define POINT_SIZE 0.007\n#define LINE_WIDTH 0.0025 // wanna get rectangle? :)\n\n\n#define CHK_POINT(uv, point) (distance(uv, point) < POINT_SIZE)\n\nfloat normal_dist(vec2 linepos, vec2 linevec, vec2 pos)\n{\n    // invert middle - to swap direction\n    return (linevec.x * (pos.y - linepos.y) - linevec.y * (pos.x - linepos.x))\n        / length(linevec); // scale\n}\n\n\nbool inLine(vec2 linepos, vec2 linevec, vec2 pos, bool trim)\n{\n    bool r = abs(normal_dist(linepos, linevec, pos)) < LINE_WIDTH;\n\n    // trim line ending\n    if (trim && r) {\n        float l = dot(linevec, linevec);\n        r = l > dot(linepos - pos, linevec) // above vector end\n         && l < dot(linepos - pos + linevec, linevec); // below line start\n    }\n\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float PI = 3.14159265;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = fragCoord.xy / iResolution.yy;\n\n    //set background color to black\n    vec3 color = vec3(0.);\n\n    vec2 point1 = vec2(sin(iTime)*0.2+0.5, cos(iTime)*0.2+0.5);\n    vec2 point2 = vec2(sin(iTime+PI)*0.2+0.5, cos(iTime+PI)*0.2+0.5);\n    float lineDist;\n\n    if (CHK_POINT(pos, point1)) { // line start dot\n      color = vec3(1., 0., 0.);\n    } else if (CHK_POINT(pos, point2)) { // line end dot\n      color = vec3(0., 0., 1.);\n    } else if (inLine(point1, point1 - point2, pos, true)) { // in the line?\n      color = vec3(0., 1., 0.);\n    } else if ((lineDist = normal_dist(point1, point1 - point2, pos)) > 0.) { // on wich side of the line?\n       // render fancy stuff on the right side of the line\n       color = lineDist * 6. * vec3(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 202, 243, 360], [363, 363, 425, 425, 741], [743, 743, 799, 799, 1705]]}
{"id": "cdjyzh", "name": "Cissoid - distance ", "author": "iq", "description": "Distance to a cissoid curve", "tags": ["2d", "sdf", "distance", "cissoid"], "likes": 24, "viewed": 688, "published": 3, "date": "1687425765", "time_retrieved": "2024-07-30T17:48:03.792005", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a Cissoid curve\n// (https://en.wikipedia.org/wiki/Cissoid_of_Diocles),\n// solved through a quartic, minimizing the distance\n// squared D = (x-cx(t))+(y-cy(t)) like in\n// https://www.shadertoy.com/view/DdsyDX\n// but all constants simplified and impossible root\n// paths skipped. As with most quartic solvers, it's\n// pretty unstable for large values of a, so not really\n// useful currently.\n\nfloat sdCissoid( in vec2 p, in float a )\n{\n    p.y = abs(p.y);\n    \n    float x = p.x/a;\n    float y = p.y/a;\n    float y2 = y*y;\n\n    float t;\n    \n    #if 1\n    // optional handling degenerate case x>0 && y==0\n    if( x>0.0 && y==0.0 )\n    {\n        t = sqrt(sqrt(1.0+x)-1.0);\n    }\n    else\n    #endif\n    {\n        float r = y2*(x-7.0)/64.0 - x/3.0 - 1.0/27.0;\n        float s = y2/16.0 + x/3.0 - 1.0/9.0;\n        float h = r*r + s*s*s;\n        if( h<0.0 )\n        {\n            return length(p);\n        }\n\n        h = sqrt(h);\n        vec2  k = vec2(h-r, -h-r);\n        vec2  u = vec2(           pow(    k.x , 1.0/3.0),   // k.x>0 guaranteed\n                        sign(k.y)*pow(abs(k.y), 1.0/3.0) );\n        float m = u.x + u.y;\n\n        #if 1\n        // optional newtown-raphson (adapted from NinjaKoala's in https://www.shadertoy.com/view/DdsyDX)\n        for( int i=0; i<2; i++ )\n        {\n            float m2 = m*m;\n            m = (2.0/3.0)*(m2*m - r)/(m2 + s);\n        }\n        #endif\n        \n        float w = sqrt(y2/16.0 + 2.0*m - 4.0/3.0);\n        float v = sqrt(y2/8.0  - 2.0*m - 8.0/3.0 + 2.0*y*(y2/64.0+1.0)/w);\n\n        t = (w + v)/2.0 + y/8.0;\n    }\n    \n    float z = 2.0*a*t*t/(1.0+t*t);\n    vec2  q = vec2(z, z*t);\n    \n    float ss = sign( 2.0*y2 - x*(x*x+y2) );\n    return ss*min(length(p),length(p-q));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float ka = 0.5 + 0.4*cos(iTime*0.31+2.0);\n    \n    // distance\n    float d = sdCissoid(p,ka);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdCissoid(m,ka);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjyzh.jpg", "access": "api", "license": "mit", "functions": [[2827, 2827, 2884, 2920, 3650]]}
{"id": "DslcWB", "name": "Early skipping sdCapsule", "author": "pizzahollandaise", "description": "Trying to make sdCapsule faster using early skipping, in the grey area the calculation of the capsule distance is skipped. The bounding volume is an aligned cylinder with radius of the first point a, I assume that the radius at a is bigger.", "tags": ["2d", "distancefield", "sdf", "distance", "aabb", "bounding"], "likes": 1, "viewed": 196, "published": 3, "date": "1687417991", "time_retrieved": "2024-07-30T17:48:04.680627", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Based on:\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n#define INF 1.0 / 0.0\n\nfloat distLine(vec3 p, vec3 dir) {\n    return length(cross(p, dir))/length(dir)-0.1;\n}\n\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p-s.xyz)-s.w;\n}\n\nbool bounded = false;\n// Rounded capsule https://iquilezles.org/articles/distfunctions/\nfloat dot2(in vec3 v) { return dot(v,v); }\nfloat sdBranchFast(vec3 p, vec4 a, vec4 b, float minDist) {\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b.xyz - a.xyz;\n    float l2 = dot(ba, ba);\n    float bound = length(cross(p-a.xyz, ba))/sqrt(l2) -a.w;\n    if (bound > minDist) {\n        bounded = true;\n        return minDist; // Early skip\n    } // Bounding cylinder\n    float rr = a.w - b.w;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n        \n    // sampling dependant computations\n    vec3 pa = p - a.xyz;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2>k ) return min(sqrt(x2 + z2)         *il2 - b.w, minDist);\n    if( sign(y)*a2*y2<k ) return min(sqrt(x2 + y2)         *il2 - a.w, minDist);\n                          return min((sqrt(x2*a2*il2)+y*rr)*il2 - a.w, minDist);\n}\n\nfloat map(vec2 p2) {\n    vec3 p = vec3(p2.x, p2.y, 0.0);\n    float other = sdSphere(p, vec4(0.5, 0.0, 0.0, 0.3));\n    //return distLine(p, vec3(1.0, 1.0, 0.0));\n    return sdBranchFast(p, vec4(-0.3, -0.3, 0.0, 0.4), vec4(0.5, 0.5, 0.0, 0.1), other);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = map(p);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 ) {\n        d = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    if (bounded) col *= 0.5;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslcWB.jpg", "access": "api", "license": "mit", "functions": [[1241, 1241, 1275, 1275, 1327], [1329, 1329, 1361, 1361, 1395], [1419, 1485, 1508, 1508, 1527], [1528, 1528, 1587, 1651, 2473], [2475, 2475, 2495, 2495, 2726], [2729, 2729, 2786, 2786, 3441]]}
{"id": "Ds2yzh", "name": "Test: Mandelbrot/Julia (Mitsync)", "author": "Mitsync", "description": "Very simple Mandelbrot shader. See code comments for details and instructions.", "tags": ["fractal", "test", "julia", "mandelbrot", "zoom", "set"], "likes": 1, "viewed": 166, "published": 3, "date": "1687417682", "time_retrieved": "2024-07-30T17:48:05.524371", "image_code": "// Mitsync 2023\n\n/*\n    HOW TO USE:\n    Mandelbrot mode:\n        Draws the canonical Mandelbrot set:\n        Brightness of point c is related to the amount of iterations it takes for that point diverge to infinity\n            when iterated according to the Mandelbrot formula $z_{n+1} = {z_n}^2 + c$ with $z_0 = 0$.\n        Mouse drags the shape around, centered on an interesting point for your viewing pleasure.\n        Set the time bar to 0->300 seconds to use it as zoom slider, or use alt+[left/right] to zoom in fullscreen.\n    Julia mode (uncomment `#define JULIA`):\n        Draws the Julia set of the clicked point:\n        The same formula as Mandelbrot except z and c are 'reversed', so every point has a fractal associated with it.\n        Mouse changes initial point z, so changes the fractal.\n        Time still acts as zoom, and in the same way as in Mandelbrot mode.\n    Note that in both modes you can't zoom in very far because of the limitations of floating point numbers.\n    TODO: fix that\n*/\n\n// Iterations is an int because this saves like 5ms over floats\n#define ITERATIONS 2048\n// MSAA level\n#define AA 5\nconst vec2[] aa_pnts = vec2[](vec2(0.25, 0.25), vec2(0.75, 0.75), vec2(0.25, 0.75), vec2(0.75, 0.25), vec2(0.5, 0.5));\n// Uncomment below to draw Julia sets instead of the canonical Mandelbrot\n//#define JULIA\n\n// Interesting point, from animation on Wikipedia\nconst vec2 zoom_center = vec2(-0.743643887037158704752191506114774, 0.131825904205311970493132056385139);\n//const vec2 zoom_center = vec2(0.0, 0.0);\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t) {\n    vec3 a = vec3(0.300, 0.014, 0.025);\n    vec3 b = vec3(0.714, 0.835, 0.573);\n    vec3 c = vec3(1.198, 1.295, 0.206);\n    vec3 d = vec3(3.173, 4.916, 1.800);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// The canonical Mandelbrot has c as input with z initially being 0\nfloat iterate( in vec2 c, in vec2 z ) {\n    for (int i = 0; i < ITERATIONS; i++) {\n        // z_{n+1} = {z_n}^2 + c\n        z = vec2((z.x*z.x) - (z.y*z.y), 2.*z.x*z.y) + c;\n        // Can't really check for infinity, but luckily in Mandelbrot infinity = 2\n        // Note the weird comparison, saving milliseconds left and right\n        if (any(greaterThan(abs(z), vec2(2., 2.)))) return float(i);\n    }\n    return float(ITERATIONS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates ((0,0) is center, y goes from -1 to 1, aspect ratio preserved)\n    vec2 uv = ((2.0 * fragCoord)-iResolution.xy) / iResolution.y;\n    vec2 mouse_uv = ((2.0 * iMouse.xy)-iResolution.xy) / iResolution.y;\n    \n    //vec2 c = (vec2(cos(0.001*iTime+0.1), sin(0.001*iTime+0.1)) / 4.) - vec2(1.0, 0.0);\n    \n    vec3 col = vec3(0.0);\n\n    // Calculate fractal, with multi-sampling AA\n    for (int aa_pass = 0; aa_pass < AA; aa_pass++) {\n        // Multisampling AA does what it says on the tin, so we gotta come up with different points to sample\n        vec2 aa_uv = uv + (aa_pnts[aa_pass] * 2./iResolution.xy);\n        #ifndef JULIA\n        // Canonical Mandelbrot\n        float it = iterate((aa_uv-mouse_uv)/(exp(iTime/25.))+zoom_center, vec2(0.0));\n        #else\n        // Julia set of point at cursor\n        float it = iterate(mouse_uv, (aa_uv)/(exp(iTime/25.)));\n        #endif\n        col += vec3(palette(0.1*log2(it))) / float(AA);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2yzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1539, 1584, 1610, 1610, 1813], [1815, 1883, 1922, 1922, 2318], [2320, 2320, 2377, 2476, 3392]]}
{"id": "cd2yRh", "name": "twisty waves", "author": "scry", "description": "https://twitter.com/Scrygl/status/1671749573629612034", "tags": ["2d"], "likes": 3, "viewed": 148, "published": 3, "date": "1687413209", "time_retrieved": "2024-07-30T17:48:08.654004", "image_code": "////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n#define R iResolution.xy\n#define ar R.x/R.y\nvec3 cs = vec3(1.,2.,3.);\nmat2 r2d(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat sdBox(vec2 p, vec2 s) {\n    vec2 q = abs(p)-s;\n    return length(max(q,0.))+min(0.,max(q.x,q.y));\n}\nvec3 rgb2hsv(vec3 c){vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);float e = 1.0e-10;return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);}vec3 hsv2rgb(vec3 c){vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);}float bitm(vec2 uv,int c) {float h = 5.;float w = 3.;int p = int(pow(2.,w));float line1 = 9591.;uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);float c1 = 0.;float cc = uv.x + uv.y*w;c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);c1 *= step(0.,uv.x)*step(0.,uv.y);c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));return (c1);}vec3 slogo(vec2 uv, float ar_, float size) {size = 240./size;uv.x = 1.-uv.x;vec2 px = vec2(1./3.,1./5.);float ls = 4.1;uv *= 240./5.25/size;ls += 2.;float ul = length(uv);ul = length(vec2(uv.x*0.5,uv.y)-0.5);uv -= 0.4;uv.x *= ar*1.75;uv.y *= 1.04;int s = 29671;int c = 29263;int r = 31469;int y = 23186;uv.x= 5.-uv.x;float b = bitm(uv,s);uv.x -= 1./3.*4.;b += bitm(uv,c);uv.x -= 1./3.*4.;b += bitm(uv,r);uv.x -= 1./3.*4.;b += bitm(uv,y);float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));b = clamp(b,0.,1.);vec3 l = hsv2rgb(vec3(b+iTime/40.,0.1,rr-b*1.9))*rr;l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);return vec3(l);}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    uv *= 4.;\n    vec3 col = vec3(0.);\n    float b = sdBox(uv,vec2(0.));\n    vec2 s = vec2(0.2,0.7);\n    float t = time;\n    float rtime = time/4.;\n    float sv = 16.;\n    for (int i=0;i<8;i++) {\n        uv += sin(uv.x*14.)*float(i+1)*0.02;\n        uv *= r2d(deg*45.+sin(rtime*sv)/sv+rtime);\n        t = -t;\n    }\n    uv += vec2(sin(time),cos(time))*0.9;\n    \n    for (int i=0;i<25;i++) {\n        float ii = float(i);\n        float b_ = sdBox(uv+s,vec2(s));\n        uv *= r2d(deg*90.);\n        //b = min(b,b_);\n        b = min(b_,b);\n        //s *= 0.3;\n        //s *= r2d(time*2.);\n        col += smoothstep(0.1,0.,abs(b_-0.3))*(sin(cs+float(i)*0.9+time)*0.3+0.7)*0.2;\n        col += smoothstep(0.5,0.,(b_-0.25))*(sin(cs+float(i)*2.5+time)*0.3+0.7)*0.2;\n        ii += 0.2;\n        vec2 ua = vec2(sin(ii*ii*0.5),cos(ii*ii*0.5));\n        ua = floor(ua*2.)/3.;\n        ua += vec2(sin(time+ii),cos(time-ii))*0.6;\n        uv += ua*2.2;\n        //b = sdBox(uv,vec2(0.1))-0.1*float(i+1);\n    }\n    col *= 1.8;\n    col -= 0.8;\n    col = clamp(col,-0.5,1.);\n    col += slogo(tv,1.,300./2.)*(sin(vec3(cs*0.6+tv.x*20.))*0.4+0.6)*0.5;\n    //col += sin(cs+uv.x+time+sin(uv.y*40.+sin(uv.x*40.)*4.)*0.8)*0.1;\n    //col += smoothstep(0.01,0.,abs(b));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2yRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 302, 302, 345], [346, 346, 375, 375, 451], [452, 452, 473, 473, 772], [772, 772, 793, 793, 946], [946, 946, 973, 973, 1274], [1274, 1274, 1318, 1318, 1936], [1940, 1940, 1995, 1995, 3358]]}
{"id": "dsBcR1", "name": "Rotating neon lights", "author": "AndrewB330", "description": "Just some lights :D", "tags": ["lights"], "likes": 6, "viewed": 249, "published": 3, "date": "1687409655", "time_retrieved": "2024-07-30T17:48:09.511710", "image_code": "#define rot(a) mat2(cos(a+vec4(0,-1.57,1.57,0)))\n\nvoid mainImage(out vec4 o, vec2 c)\n{\n    vec2 R = iResolution.xy, a, D, P = (c - R * .5) / R.x * 9.;\n    o *= 0.;\n    \n    for (float w; w++ < 50.; P *= rot(.126)) \n    {\n        // Color, hsv2rgb\n        vec4 C = .2+ .8* clamp(abs(fract(w/50.+vec4(3,2,1,0)/3.)*6.-3.)-1., 0., 1.);\n        // Offset and rotate coordinates\n        D = (P + vec2(1.2,0)) * rot( iTime*2. + sin(iTime) );\n        // Analytical integral solution for 0-width segment light\n        a = atan((D.x + vec2(1,-1)) / D.y);\n        o += C / dot(C, vec4(3, 5, 1, 0)) * (a.x - a.y) / D.y;\n    }\n    // Some color normalization\n    o = 1.-exp(-o * .08);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 86, 86, 673]]}
{"id": "DdScR1", "name": "Fork Hexagone leosalvati 663", "author": "leosalvatierra", "description": "What you get when you screw with hexagons for too long. Scrub time with the mouse. Watch fullscreen!", "tags": ["psychedelic", "hexagon", "trippy", "dmt"], "likes": 2, "viewed": 184, "published": 3, "date": "1687387685", "time_retrieved": "2024-07-30T17:48:10.597807", "image_code": "#define R3 1.732051\n\nvec4 HexCoords(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = ab;\n    vec2 id = gv-ab;\n    \n    st = ab;\n    return vec4(st, id);\n}\n\nfloat GetSize(vec2 id, float seed) {\n    float d = length(id);\n    float t = iTime*.5;\n    float a = sin(d*seed+t)+sin(d*seed*seed*10.+t*2.);\n    return a/2. +.5;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hexagon(vec2 uv, float r, vec2 offs) {\n    \n    uv *= Rot(mix(0., 3.1415, r));\n    \n    r /= 1./sqrt(2.);\n    uv = vec2(-uv.y, uv.x);\n    uv.x *= R3;\n    uv = abs(uv);\n    \n    vec2 n = normalize(vec2(1,1));\n    float d = dot(uv, n)-r;\n    d = max(d, uv.y-r*.707);\n    \n    d = smoothstep(.06, .02, abs(d));\n    \n    d += smoothstep(.1, .09, abs(r-.5))*sin(iTime);\n    return d;\n}\n\nfloat Xor(float a, float b) {\n\treturn a+b;\n}\n\nfloat ShapePattern(vec2 uv) {\n    float r = 0.0;\n    for(int i = 0; i < 8; i++) {\n        vec2 pos = vec2(\n            fract(sin(float(i) * 123.456 + iTime) * 234.567),\n            fract(cos(float(i) * 234.567 + iTime) * 345.678)\n        );\n        r += length(uv - pos) < 0.1 ? 1.0 : 0.0;\n    }\n    return r;\n}\n\nfloat Layer(vec2 uv, float s) {\n    vec4 hu = HexCoords(uv*2.);\n\n    float d = Hexagon(hu.xy, GetSize(hu.zw, s), vec2(0));\n    vec2 offs = vec2(1,0);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    offs = vec2(.5,.8725);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    offs = vec2(-.5,.8725);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    \n    d = Xor(d, ShapePattern(uv));\n    \n    return d;\n}\n\nfloat N(float p) {\n    return fract(sin(p*123.34)*345.456);\n}\n\nvec3 Col(float p, float offs) {\n    float n = N(p)*1234.34;\n    \n    return sin(n*vec3(12.23,45.23,56.2)+offs*3.)*.5+.5;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 lookat, float zoom) {\n    vec3 f = normalize(lookat-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = p+f*zoom,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy-.5;\n    float duv= dot(UV, UV);\n    vec2 m = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.2+m.x*10.+5.;\n    \n    float y = sin(t*.5);\n    vec3 ro = vec3(0, 20.*y, -5);\n    vec3 lookat = vec3(0,0,-10);\n    vec3 rd = GetRayDir(uv, ro, lookat, 1.);\n    \n    vec3 col = vec3(0);\n    \n    vec3 p = ro+rd*(ro.y/rd.y);\n    float dp = length(p.xz);\n    \n    if((ro.y/rd.y)>0.)\n    \tcol *= 0.;\n    else {\n        uv = p.xz*.1;\n\n        uv *= mix(1., 5., sin(t*.5)*.5+.5);\n\n        uv *= Rot(t);\n        m *= Rot(t);\n\n        uv.x *= R3;\n        \n\n        for(float i=0.; i<1.; i+=1./3.) {\n            float id = floor(i+t);\n            float t = fract(i+t);\n            float z = mix(5., .1, t);\n            float fade = smoothstep(0., .3, t)*smoothstep(1., .7, t);\n\n            col += fade*t*Layer(uv*z, N(i+id))*Col(id,duv);\n        }\n    }\n    col *= 2.;\n    \n    if(ro.y<0.) col = 1.-col;\n    \n    col *= smoothstep(18., 5., dp);\n    col *= 1.-duv*2.;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 17402, "src": "https://soundcloud.com/buku/front-to-back", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdScR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 46, 46, 303], [305, 305, 341, 341, 469], [471, 471, 490, 490, 566], [568, 568, 612, 612, 954], [956, 956, 985, 985, 1000], [1002, 1002, 1031, 1031, 1313], [1315, 1315, 1346, 1346, 1984], [1986, 1986, 2004, 2004, 2047], [2049, 2049, 2080, 2080, 2171], [2173, 2173, 2231, 2231, 2435], [2437, 2437, 2494, 2494, 3582]]}
{"id": "csByR1", "name": "Ruidos en el planeta", "author": "leosalvatierra", "description": "noises", "tags": ["noise", "ruidos"], "likes": 2, "viewed": 136, "published": 3, "date": "1687386911", "time_retrieved": "2024-07-30T17:48:11.469477", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.1415926535897932384626433832795;\n    \n    vec2 c = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Ajusta el valor de beat desde tu software de msica\n    // Cuando un beat ocurre, incrementa este valor\n    float beat = 0.0; \n\n    // Parmetros basados en el tiempo para la animacin\n    vec2 k = vec2(0.4*cos(iTime/2.0 + beat), 0.4*sin(iTime/2.0 + beat));\n\n    // Valores iniciales\n    vec2 z = c;\n    float m = dot(z,z);\n\n    // Conjunto de Mandelbrot\n    for(int i = 0; i < 256; i++)\n    {\n        if(m < 1024.0)\n        {\n            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c + k;\n            m = dot(z,z);\n        }\n        else break;\n    }\n\n    // Color psicodlico\n    vec3 color = 0.5 + 0.5*cos( 3.0 + iTime + vec3(0.0, 0.6, 1.0) * m * 0.1 + beat * 2.0 );\n\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csByR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 916]]}
{"id": "DsSczh", "name": "Random Rectangle Noise", "author": "Markant", "description": "Random Rectangle Noise", "tags": ["noise"], "likes": 5, "viewed": 228, "published": 3, "date": "1687385281", "time_retrieved": "2024-07-30T17:48:12.307236", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rectSize = iResolution.xy / 10.0;\n    vec2 rectCoord = floor(fragCoord / rectSize);\n    \n    float randomValue = fract(sin(dot(rectCoord, vec2(11.5621, 78.943))) * (iTime/10000.) * 4358.5453);\n    \n    fragColor = randomValue < 0.3 ? vec4(1.) : vec4(0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 321]]}
{"id": "DdSyzh", "name": "Ball bearing", "author": "AndrewB330", "description": "Ball bearing. PBR code in common was taken from https://www.shadertoy.com/view/ld3SRr. Replaced 2d roughness texture with 3d to make it stick to the surface.", "tags": ["sdf", "metal", "pbr", "bearing"], "likes": 13, "viewed": 205, "published": 3, "date": "1687383470", "time_retrieved": "2024-07-30T17:48:13.599780", "image_code": "const float M_PI = 3.1415926535;\nconst vec3 L = normalize(vec3(1.0, 1.0, 1.0));\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 rot(vec2 v, float a)\n{\n    return vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a));\n}\n\nconst mat3 m1 = mat3(0.61, 0.12, 0.78, 0.04, 0.98, -0.18, -0.79, 0.14, 0.59);\nconst mat3 m2 = mat3(0.44, 0.87, 0.2, -0.74, 0.23, 0.63, 0.50, -0.43, 0.75);\n   \nfloat texture_metal(vec3 p)\n{\n    float r = 0.0;\n    p *= 2.0;\n    float rr = noise(p * 4.0) + noise(p * 8.0) * 0.5 + noise(p * 16.0) * 0.25;\n    r += pow(saturate(rr * 0.7 - 0.2), 4.0);\n    vec3 scale = vec3(15, 3, 3);\n    for (int i = 0; i < 5; i++)\n    {\n        scale *= 1.5;\n        p += 0.2;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.7);\n        p *= m2;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.5);\n        p *= m1;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.6);\n        p *= m2;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.8);\n    }\n    return saturate(r);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdShell(vec3 p, float d, float r, float r1)\n{\n    vec2 pp = vec2(length(p.xy) - r, p.z);\n    return max(min(sdBox(pp + vec2(r1, 0), vec2(r1 * 0.3, d)),\n                   sdBox(pp - vec2(r1, 0), vec2(r1 * 0.3, d))),\n                   -(length(pp) - r1));\n}\n\nconst float r = 1.0, r1 = 0.2;\nconst float w0 = 0.8;\nconst float w2 = 0.3;\nconst float wc = ((w2 * (r + r1) + w0 * (r - r1)) * 0.5) / r;\nconst float wcc = ((w2 * (r + r1) - w0 * (r - r1) ) * 0.5) / r1;\n\nvec2 calc_w(vec2 w)\n{\n    w *= vec2(r - r1, r + r1);\n    return vec2(w.y + w.x, w.y - w.x) * 0.5 / vec2(r, r1);\n}\n\nvec3 camera(vec3 p)\n{\n    p.xz = rot(p.xz, sin(iTime) * 0.8);\n    p.yz = rot(p.yz, 0.6);\n    return p;\n}\n\nvec2 get_w()\n{\n    float a = 0.22;\n    return vec2((1.5 * iTime + 2. * cos(a * iTime) / a + 0.25 * cos(2. * a * iTime) / a) * 2.0, cos(iTime) * 0.5);\n}\n\n#define setup() vec2 w = get_w();vec2 wc = calc_w(w);p = camera(p);\n\nfloat map_scene(vec3 p)\n{\n    setup();\n    \n    float sdf = sdShell(p, 0.2, r, r1);\n    p.xy = rot(p.xy, wc.x);\n    for (int i = 0; i < 12; i++)\n    {\n        p.xy = rot(p.xy, 2. * M_PI / 12.0);\n        sdf = min(sdf, sdSphere(p + vec3(1, 0, 0), r1 * 0.95));\n    }\n    \n    return sdf;\n}\n\nfloat map_roughness(vec3 p)\n{\n    setup();\n    \n    float sdf = sdShell(p, 0.2, r, r1);\n    float res = texture_metal(vec3(rot(p.xy, (length(p.xy) < r ? w.x : w.y)), p.z));\n    \n    p.xy = rot(p.xy, wc.x);\n    for (int i = 0; i < 12; i++)\n    {\n        p.xy = rot(p.xy, 2. * M_PI / 12.0);\n        vec3 pp = p + vec3(1, 0, 0);\n        pp.xy = rot(pp.xy, wc.y);\n        float sd = sdSphere(pp, r1 * 0.95);\n        res = mix(res, texture_metal(pp), step(sd, sdf));\n    }\n    \n    return res;\n}\n\nvec2 trace(vec3 origin, vec3 dir)\n{\n    float t = 0.;\n    for (int i = 0; i < 48 && origin.z > -6.0; i++)\n    {\n        float h = map_scene(origin);\n        origin += dir * h;\n        t += h;\n        if (h < 0.01)\n        {\n            return vec2(map_roughness(origin), t);\n        }\n    }\n\n    return vec2(-1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize(e.xyy*map_scene(pos + e.xyy) +\n\t\t\t\t\t e.yyx*map_scene(pos + e.yyx) +\n\t\t\t\t\t e.yxy*map_scene(pos + e.yxy) +\n\t\t\t\t\t e.xxx*map_scene(pos + e.xxx));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = normalize(vec3(fragCoord - .5* iResolution.xy, -iResolution.y ));\n    vec3 origin = vec3(0, -0.3, 2.1);\n    fragColor = texture(iChannel2, dir);\n    \n    \n    vec2 res = trace(origin, dir);\n    if (res.y > 0.)\n    {\n        vec3 p = origin + res.y * dir;\n        vec3 v = normalize(p - origin);\n        vec3 n = calcNormal(p);\n        fragColor.rgb = pow(MAT_apply(p, res.y, dir, n, res.x, \n                                      MATERIALID_SPHERE, iChannel2, iChannel3) * 2.0 * vec3(1, 0.9, 0.7),vec3(1./2.2));\n    }\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define saturate(x) clamp(x,0.0,1.0)\n\n// PBR Code from https://www.shadertoy.com/view/ld3SRr\nconst int MATERIALID_SKY    = 2;\nconst int MATERIALID_SPHERE = 3;\nconst vec3  F_ALU_N  = vec3(1.600,0.912,0.695); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_ALU_K  = vec3(8.010,6.500,5.800); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nfloat ROUGHNESS_AMOUNT       = 0.85;//Valid range : [0-1] 0=shiny, 1=rough map\nfloat SKY_COLOR              = 0.0; //[0.0=Red, 1.0=Blue)\nfloat ABL_LIGHT_CONTRIBUTION = 0.0; //[0-1] Additional ABL Light Contribution\n\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, const vec3 ior_n, const vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution Term\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t\n    //Fresnel Term\n\tvec3 F;\n    if(metallic)\n    {\n        float cos_theta = 1.0-NdotV;\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t    /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n    }\n    else //Dielectric (Note: R/G/B do not really differ for dielectric materials)\n    {\n        float F0 = pow((1.0 - ior_n.x) / (1.0 + ior_n.x),2.0);\n  \t\tF = vec3(F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    }\n    \n    //Geometric term (Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation p.3/59)\n    //k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; \n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    float softTr = 0.1; // Valid range : [0.001-0.25]. Transition softness factor, close from dot(L,N) ~= 0\n    float angleLim = 0.;//2.75; // Valid range : [0-0.75]. Compensates for IBL integration suface size.\n    //sinT = 1.;\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr));\n    else\n        return D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);\n    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);\n    return mix(cRedSky,cBlueSky,SKY_COLOR);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01, samplerCube iChannel2, samplerCube iChannel3)\n{\n    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel2, sampleDir ).rgb,vec3(2.2)));\n    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel3, sampleDir ).rgb,vec3(1)));\n    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));\n    return linearGammaColor;\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 PBR_axisRotationMatrix( vec3 u, float ct, float st ) //u=axis, co=cos(t), st=sin(t)\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 PBR_importanceSampling(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    const float PI = 3.14159;\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n    float phi = 2.0*PI*e2;\n    //Improve this? https://blog.selfshadow.com/2011/10/17/perp-vectors/\n    vec3 notColinear   = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n    vec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n\tmat3 m1 = PBR_axisRotationMatrix(normalize(othogonalAxis), cos(range), sin(range));\n\tmat3 m2 = PBR_axisRotationMatrix(normalize(sampleDir),     cos(phi),   sin(phi));\n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k, samplerCube iChannel2, samplerCube iChannel3)\n{\n    const float MIPMAP_SWITCH  = 0.29; //sampling angle delta (rad) equivalent to the lowest LOD.\n    const ivec2 SAMPLE_COUNT = ivec2(05,15); //(5 random, 15 fixed) samples\n    const vec2 weight = vec2(1./float(SAMPLE_COUNT.x),1./float(SAMPLE_COUNT.y));\n    float angularRange = 0.;    \n    vec3 vCenter = reflect(-V,N);\n    \n    //Randomized Samples : more realistic, but jittery\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[0]; ++i)\n    {\n        //Random noise from DaveHoskin's hash without sine : https://www.shadertoy.com/view/4djSRW\n        vec3 p3 = fract(vec3(fIdx*10.0+vCenter.xyx*100.0) * vec3(.1031,.11369,.13787)); \n    \tp3 += dot(p3.zxy, p3.yzx+19.19);\n    \tvec2 jitter = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x*randomness_range, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH, iChannel2, iChannel3);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[0];\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    //Fixed Samples : More stable, but can create sampling pattern artifacts (revealing the sampling pattern)\n    fIdx = 0.0;\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[1]; ++i)\n    {\n        vec2 jitter = vec2( clamp(weight[1]*fIdx,0.0,0.50), fract(weight[1]*fIdx*1.25)+3.14*fIdx); //Fixed sampling pattern.\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH, iChannel2, iChannel3);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[1];\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    return (totalRandom*weight[1]+totalFixed*weight[0])/(weight[0]+weight[1]);\n}\n\n//The main material function.\nvec3 MAT_apply(vec3 pos, float rayLen, vec3 rayDir, vec3 N, float roughness, int matID, samplerCube iChannel2, samplerCube iChannel3)\n{\n    vec3 V = normalize(-rayDir);\n    vec3 L = normalize(vec3(1,1,0));\n    vec3 col = PBR_visitSamples(V,N,roughness, true, F_ALU_N, F_ALU_K, iChannel2, iChannel3);\n    vec3 L0  = PBR_Equation(V,L,N,roughness+0.01, F_ALU_N, F_ALU_K, true, false);\n    col     += PBR_HDRremap(vec3(1))*L0*ABL_LIGHT_CONTRIBUTION;\n    \n    //Anti-aliasing trick (normal-based)\n    vec3 backgroundColor = pow(texture( iChannel2, rayDir ).xyz,vec3(2.2));\n    float aaAmount = 0.095;\n    float smoothFactor = 1.0-clamp(-dot(N,rayDir)/(aaAmount), 0.0, 1.0);\n    col = (dot(N,-rayDir)<aaAmount)? mix(col, backgroundColor, smoothFactor) : col;\n    \n    return matID==MATERIALID_SKY?backgroundColor:col;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 107, 107, 314], [316, 316, 343, 343, 420], [581, 581, 610, 610, 1181], [1183, 1183, 1216, 1216, 1244], [1246, 1246, 1275, 1275, 1357], [1359, 1359, 1410, 1410, 1622], [1827, 1827, 1848, 1848, 1940], [1942, 1942, 1963, 1963, 2046], [2048, 2048, 2062, 2062, 2199], [2270, 2270, 2295, 2295, 2557], [2559, 2559, 2588, 2588, 3049], [3051, 3051, 3086, 3086, 3367], [3369, 3415, 3447, 3447, 3657], [3659, 3659, 3716, 3716, 4250]]}
{"id": "md2yRz", "name": "basic audio visualisation", "author": "mitchpk", "description": "It looks like the windows 11 wallpaper", "tags": ["visualization", "audio"], "likes": 6, "viewed": 296, "published": 3, "date": "1687376795", "time_retrieved": "2024-07-30T17:48:14.369722", "image_code": "float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.500, 0.500, 0.500);\n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    uv0 += vec2(sin(iTime * 0.6) * 0.5, cos(iTime * 0.5) * 0.5);\n    uv += vec2(cos(iTime * 0.3) * 0.1, sin(iTime * 0.2) * 0.1);\n    uv *= (sin(iTime * 0.1) + 1.0) / 20.0 + 0.1;\n    \n    float sum = 0.0;\n    int count = 0;\n    for(float i = 0.001; i < 0.02; i += 1.0/1024.0) {\n        sum += texture(iChannel0, vec2(i, 0.25)).x;\n        count++;\n    }\n    float average = sum/float(count);\n    float hit = max(average - 0.8, 0.0);\n    \n    float d = length(uv);\n    d -= average * 0.04;\n    \n    vec3 col = palette(length(uv0) * 0.2 - iTime * 0.1);\n    col += rand(uv0) * 4.0 * hit;\n    \n    d = sin(d * 8.0 + iTime + cos(iTime * d)) / 8.0;\n    d = abs(d);\n    \n    d = (0.02 + hit * 0.02) / d;\n    \n    col *= d;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33789, "src": "https://soundcloud.com/fatherplaystation/lightbreak", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2yRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 70], [71, 71, 91, 91, 159], [160, 160, 180, 180, 213], [215, 215, 238, 238, 447], [449, 449, 506, 560, 1423]]}
{"id": "msjyRz", "name": "Mister&Prada", "author": "misterprada", "description": "(^_^)/\n\nOriginal shader - https://www.shadertoy.com/view/DlX3zS", "tags": ["text"], "likes": 12, "viewed": 424, "published": 3, "date": "1687376724", "time_retrieved": "2024-07-30T17:48:15.455818", "image_code": "#define _ ;p.y+=sin((p.x-=3.)+iTime)*.2;q.x=abs((q=v=p).x);O+=.04*(cos(p.x*.7+iTime+t)+1.2)/\n#define l(p,a) length(p-a+a*clamp(dot(a-p,a)/dot(a,a),0.,1.))\n#define h(f)   _ min(l((p=q), f), J);p=v+t.zx\n#define J      l(abs(p-t.yx), t.xz)\n\n\n#define TJ     l(abs(p+t.yx), t.xz)\n\n#define Eh(f)  _ min(l((p=q), f), EJ);p=v+t.zx\n#define EJ       l(abs(p+t.yx * 2.5), t.xz)\n#define EJ2      l(abs(p.y-t.xz), vec2(0.0, 0.0))\n#define EJ3      l(33333.1, vec2(0.0, 0.0))\n\n#define RJ      l(abs(p+t.yx * vec2(8.6)), t.xz)\n#define RJ2     l(abs(p+t.yx * vec2(9.6)), t.xz)\n\n#define S _ (abs(p.x + sin(p.y*1.5))+pow(abs(p.y)*.3, 8.))\n#define M   h(t.yz)\n#define I _ J ;p.x +=3.2 POINT\n#define T _ min(TJ, min(20., l(vec2(p.y-1.3, p.x + 2.0), t.yz)))\n\n\n#define E _ min(EJ, min(20., l(vec2(p.y-2.0, p.x + 2.5), t.wz))) _ min(EJ2, min(20., l(vec2(p.y, p.x + 5.4), t.wz))) _ min(EJ3, min(20., l(vec2(p.y+2.0, p.x + 8.4), t.wz))); p.x -= 1.0\n\n#define R _ min(RJ2, min(20., l(vec2(-p.x-7.7, abs(p.y - 0.9) + 0.8), t.zz))) _ min(EJ3, min(20., l(vec2(-p.x-11.1, p.y + 1.6 + 0.1), sqrt(t.zz) )))\n\n\n#define P _ min(RJ, min(20., l(vec2(sqrt(-p.x-6.7), abs(p.y - 0.9) + 0.8), t.zz)))\n\n#define R3 _ min(RJ2, min(20., l(vec2(-p.x-7.7, abs(p.y - 0.9) + 0.8), t.zz)))\n#define R4 _ min(EJ3, min(20., l(vec2(-p.x-11.1, p.y + 1.6 + 0.1), sqrt(t.zz) )))\n\n#define Al(p,a) length(p-a+a*clamp(dot(a-p,a)/dot(a,a), 0.0, 1.0))\n#define AJ      Al(abs(p+t.yx * vec2(8.6)), t.xz)\n#define A1 _ min(EJ3, min(20., l(vec2(p.x+14.1, p.y + 2.0), sinh(t.yz + 0.1) )))\n\n#define AJ2      Al(abs(p+t.yx * vec2(8.6)), t.xz)\n#define A2 _ min(EJ3, min(20., l(vec2(-p.x-14.5, p.y + 2.0), sinh(t.yz + 0.1) )))\n\n#define AJ3      l(33333.1, vec2(0.0, 0.0))\n#define A3 _ min(AJ3, min(20., l(vec2(p.y, p.x + 19.8), t.wz)))\n\n#define DJ  l(abs(p+t.yx * vec2(19.6)), t.xz)\n#define D _ min(DJ, min(20., l(vec2(-p.x-17.7, abs(p.y - 0.1)), t.zz))) ;p.x += 7.0\n\n\n#define Al4(p,a) length(p-a+a*clamp(dot(a-p,a)/dot(a,a), 0.0, 1.0))\n#define AJ4      Al(abs(p+t.yx * vec2(8.6)), t.xz)\n#define A4 _ min(EJ3, min(20., l(vec2(p.x + 20.1, p.y + 2.0), sinh(t.yz + 0.1) )))\n\n#define AJ5      Al(abs(p+t.yx * vec2(8.6)), t.xz)\n#define A5 _ min(EJ3, min(20., l(vec2(-p.x-20.5, p.y + 2.0), sinh(t.yz + 0.1) )))\n\n#define AJ6      l(33333.1, vec2(0.0, 0.0))\n#define A6 _ min(AJ3, min(20., l(vec2(p.y, p.x + 25.8), t.wz)))\n\n#define A ;p.x -= 6.5 _ min(EJ3, min(20., l(vec2(p.x + 20.1, p.y + 2.0), sinh(t.yz + 0.1) ))) _ min(EJ3, min(20., l(vec2(-p.x-20.5, p.y + 2.0), sinh(t.yz + 0.1) ))) _ min(AJ3, min(20., l(vec2(p.y, p.x + 25.8), t.wz))) ;p.x += 6.0\n\n#define POINT _ min(AJ3, min(20., l(vec2(p.y - 3.7, p.x - 1.2), t.ww)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2 i = iResolution.xy, p = (F+F-i)/i.y*10., q, v; \n    vec4 t = vec4(0,1,2,0); p.x += 16.5; O *= 0.;\n    \n                                                /*  */    \n                                                \n                                            M I S T E R  P R A D A   \n                                            \n                                                /*  */          \n;                                      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "dsjcRR", "name": "PBR with Ray Marching (WIP)", "author": "beans_please", "description": "* Drag -> Look around\n* WASD -> Move\n* Shift -> Sprint\n* Alt -> Stealth?\n* R -> Reset\n", "tags": ["raymarching", "camera", "pathtracing"], "likes": 6, "viewed": 386, "published": 3, "date": "1687371539", "time_retrieved": "2024-07-30T17:48:16.586794", "image_code": "// Image\n// iChannel0 = Buffer A\n\n// Controls\n// * Drag -> Look around\n// * WASD -> Move\n// * Shift -> Sprint\n// * Alt -> Stealth?\n// * R -> Reset\n\nvec3 viewTransform(vec3 inp)\n{\n\t// Clip negatives\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, 1.5);\n\n    // Offset\n    inp += vec3(0.0, 0.0, 0.006);\n\n    // Uniform Reinhard (good enough for now)\n    float lum = dot(inp, lumWeights);\n    inp /= lum + 1.0;\n    inp = mix(inp, vec3(1.0), smoothstep(0.0, 1.0, map_range_clamp(log2(lum), -1.0, 10.0, 0.0, 1.0)));\n\n    // OETF (Gamma)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\nvec3 getAccumulated(in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return data.rgb * SAMPLE_COUNT_MUL / data.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = getAccumulated(fragCoord);\n    col = viewTransform(col);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common\n\n#define PI 3.14159265359\n#define DEG_TO_RAD 0.01745329251994\n\n#define SAMPLE_COUNT_MUL 0.01\n\nconst vec3 lumWeights = vec3(0.2126, 0.7152, 0.0722);\nconst vec3 defPlayerPos = vec3(-1.5, -3.7, 0.4);\nconst vec3 defCamOrient = vec3(97.0, 0.0, -25.0);\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 mixColPerceptual(vec3 a, vec3 b, float t)\n{\n    //return mix(a, b, t);\n    return pow(mix(sqrt(a), sqrt(b), t), vec3(2.0));\n}\n\nvec3 rotateEuler(vec3 v, vec3 angle)\n{\n    angle *= DEG_TO_RAD;\n\n    // X\n    v.x = v.x * cos(angle.x) - v.y * sin(angle.x);\n    v.y = v.x * sin(angle.x) + v.y * cos(angle.x);\n\n    // Y\n    v.x = v.x * cos(angle.y) + v.z * sin(angle.y);\n    v.z = -v.x * sin(angle.y) + v.z * cos(angle.y);\n\n    // Z\n    v.y = v.y * cos(angle.z) - v.z * sin(angle.z);\n    v.z = v.y * sin(angle.z) + v.z * cos(angle.z);\n\n    return v;\n}\n\n// Ignores Y (roll)\nvec3 orientationToDirection(vec3 orient)\n{\n    orient.x -= 90.0;\n    orient.x *= DEG_TO_RAD;\n    orient.z *= -DEG_TO_RAD;\n\n    return vec3(vec2(sin(orient.z), cos(orient.z)) * cos(orient.x), sin(orient.x));\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Source: https://github.com/MaxBittker/glsl-voronoi-noise\n// ***********************************************\n\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv)\n{\n    uv *= myt;\n    uv *= mys;\n    return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash2(vec3 p)\n{\n    return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)), dot(p, vec3(113.0, 1.0, 57.0)))) *\n        43758.5453);\n}\n\nvec3 voronoi3d(const in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float id = 0.0;\n    vec2 res = vec2(100.0);\n    for (int k = -1; k <= 1; k++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            for (int i = -1; i <= 1; i++)\n            {\n                vec3 b = vec3(float(i), float(j), float(k));\n                vec3 r = vec3(b) - f + hash2(p + b);\n                float d = dot(r, r);\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3(sqrt(res), abs(id));\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Keyboard Utils\n// ***********************************************\n\n// Key code constants\n// https://asawicki.info/nosense/doc/devices/keyboard/key_codes.html\n\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_R = 82;\nconst int KEY_Q = 81;\nconst int KEY_Z = 90;\n\nbool keyIsDown(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool keyGotPressed(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool keyToggleState(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat keyIsDownF(int key, sampler2D keyboardChannel)\n{\n    return keyIsDown(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\nfloat keyGotPressedF(int key, sampler2D keyboardChannel)\n{\n    return keyGotPressed(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\nfloat keyToggleStateF(int key, sampler2D keyboardChannel)\n{\n    return keyToggleState(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Data Buffer Utils\n// ***********************************************\n\nvec4 fetchVec4(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0);\n}\n\nvec3 fetchVec3(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).xyz;\n}\n\nvec2 fetchVec2(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).xy;\n}\n\nfloat fetchScalar(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).x;\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\nvec3 randomUnitVector()\n{\n    const int numAttempts = 100;\n\n    float l = 0.0;\n    for (int i = 1; i <= numAttempts; i++)\n    {\n        // random() returns a float in the [0, 1] range\n        vec3 p = vec3(random(), random(), random());\n        p = p * 2.0 - 1.0;\n\n        // Normalize and return if length <= 1\n        if ((l = length(p)) <= 1.0)\n            return p / l;\n    }\n\n    // If all failed\n    return normalize(vec3(random(), random(), random()));\n}\n\nvec3 randomPointInUnitSphere()\n{\n    return random() * randomUnitVector();\n}\n\nfloat mengerSpongeDF(int n, vec3 pos)\n{\n    if (length(pos) > 2.2)\n        return length(pos) - 1.8;\n\n    //by recursively digging a box\n    float x = pos.x, y = pos.y, z = pos.z;\n    x = x * 0.5 + 0.5;\n    y = y * 0.5 + 0.5;\n    z = z * 0.5 + 0.5; //center it by changing position and scale\n\n    float xx = abs(x - 0.5) - 0.5, yy = abs(y - 0.5) - 0.5, zz = abs(z - 0.5) - 0.5;\n    float d1 = max(xx, max(yy, zz)); //distance to the box\n    float d = d1; //current computed distance\n    float p = 1.0;\n    for (int i = 1; i <= n; ++i)\n    {\n        float xa = mod(3.0 * x * p, 3.0);\n        float ya = mod(3.0 * y * p, 3.0);\n        float za = mod(3.0 * z * p, 3.0);\n        p *= 3.0;\n\n        //we can also translate/rotate (xa,ya,za) without affecting the DE estimate\n\n        float xx = 0.5 - abs(xa - 1.5), yy = 0.5 - abs(ya - 1.5), zz = 0.5 - abs(za - 1.5);\n        d1 = min(max(xx, zz), min(max(xx, yy), max(yy, zz))) / p; //distance inside the 3 axis-aligned square tubes\n\n        d = max(d, d1); //intersection\n    }\n    //return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function\n    return d;\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat mandelbulb(in vec3 p, out vec4 resColor)\n{\n    if (length(p) > 1.5)\n        return length(p) - 1.2;\n\n    vec3 w = p;\n    float m = dot(w, w);\n\n    vec4 trap = vec4(abs(w), m);\n    float dz = 1.0;\n\n    for (int i = 0; i < 4; i++)\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m * m;\n        float m4 = m2 * m2;\n        dz = 8.0 * sqrt(m4 * m2 * m) * dz + 1.0;\n\n        float x = w.x;\n        float x2 = x * x;\n        float x4 = x2 * x2;\n        float y = w.y;\n        float y2 = y * y;\n        float y4 = y2 * y2;\n        float z = w.z;\n        float z2 = z * z;\n        float z4 = z2 * z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt(k3 * k3 * k3 * k3 * k3 * k3 * k3);\n        float k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x + 64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2;\n        w.y = p.y + -16.0 * y2 * k3 * k4 * k4 + k1 * k1;\n        w.z = p.z + -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4) * k1 * k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n\n        // dz = 8*z^7*dz\n        dz = 8.0 * pow(m, 3.5) * dz + 1.0;\n\n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n#endif        \n\n        trap = min(trap, vec4(abs(w), m));\n\n        m = dot(w, w);\n        if (m > 256.0)\n            break;\n    }\n\n    resColor = vec4(m, trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25 * log(m) * sqrt(m) / dz;\n}\n\nfloat boxSD(vec3 p, vec3 center, vec3 scale)\n{\n    float x = max(p.x - center.x - scale.x / 2., center.x - p.x - scale.x / 2.);\n    float y = max(p.y - center.y - scale.y / 2., center.y - p.y - scale.y / 2.);\n\n    float z = max(p.z - center.z - scale.z / 2., center.z - p.z - scale.z / 2.);\n    float d = x;\n    d = max(d, y);\n    d = max(d, z);\n    return d;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat anotherFractalSD(vec3 p, float scale, int iters)\n{\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < iters) {\n\t\t c = a1; dist = length(p-a1);\n\t        d = length(p-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(p-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(p-a4); if (d < dist) { c = a4; dist=d; }\n\t\tp = scale*p-c*(scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(p) * pow(scale, float(-n));\n}\n", "buffer_a_code": "// Buffer A\n// iChannel0 = Buffer A\n// iChannel1 = Buffer B\n\nprecision highp float;\n\n#define OBJID_BOX 0\n#define OBJID_FLOOR 1\n#define OBJID_WALL 2\n#define OBJID_FRACTAL 3\n#define OBJID_FRACTAL2 4\n\n// SD object info\nstruct SdInfo\n{\n    int objID;\n    vec4 data;\n};\n\nstruct HitInfo\n{\n    // Always present\n    vec3 rayDir;     // Ray direction (normalized)\n    bool hit;        // Have we hit something?\n    vec3 pos;        // Last position on the ray\n    float dist;      // Total distance traveled\n    SdInfo sdInfo;   // Last SD object info\n\n    // Only present if hit == true\n    vec3 normal;\n};\n\nconst float rayOffset = .02;\nconst float hitThreshold = .0006;\nconst float maxTotalDist = 100.;\nconst float eps = .0005;\n\nconst vec3 sunDir = normalize(vec3(0, 1, -.8));\n\nvec2 pixelToDeviceCoords(vec2 coords)\n{\n    vec2 uv = coords / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv = (uv * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    return uv;\n}\n\nvec2 getMouseUV()\n{\n    if (ivec2(iMouse) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nfloat sceneSD(vec3 p, out SdInfo info)\n{\n    // Store individual distances\n    const int numObjs = 5;\n    float dists[5];\n\n    // Mouse UV\n    vec2 mouseUV = getMouseUV();\n\n    // Box\n    vec3 boxPos = vec3(-2.55, 6.0, -.2);\n    vec3 boxBounds = vec3(0.8, 2.5, 0.8);\n    dists[0] = boxSD(p, boxPos, boxBounds);\n\n    // Floor\n    vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    float planeHeight = -.601;// - voronoi3d(vec3(p.xy * 0.3, 1.0)).x;\n    dists[1] = dot(p, planeNormal) - planeHeight;\n\n    // Wall\n    vec3 planeNormal2 = normalize(vec3(1.0, 0.0, 0.0));\n    float planeHeight2 = 0.0;\n    dists[2] = dot(p - vec3(-3.0, 0.0, 0.0), planeNormal2) - planeHeight2;\n\n    // Fractal\n    vec4 mandelbulbData = vec4(1.0);\n    dists[3] = mandelbulb((p - vec3(1.9, -2.8, 0.5)) / 1.0, mandelbulbData); \n    \n    // Another fractal\n    dists[4] = mengerSpongeDF(5, 1.1 * p - vec3(1.0, 1.0, 0.6));\n\n    // Find minimum distance\n\n    float minDist = dists[0];\n    info.objID = 0;\n\n    if (numObjs < 2)\n        return minDist;\n\n    for (int i = 1; i < numObjs; i++)\n    {\n        if (dists[i] < minDist)\n        {\n            minDist = dists[i];\n            info.objID = i;\n\n            if (i == OBJID_FRACTAL)\n            {\n                info.data = mandelbulbData;\n            }\n        }\n    }\n\n    return minDist;\n}\n\nvoid rayMarch(vec3 orig, vec3 dir, out HitInfo hitInfo)\n{\n    dir = normalize(dir);\n    orig += rayOffset * dir;\n\n    float totalDist = 0.0;\n    SdInfo sdInfo;\n\n    float sd = sceneSD(orig, sdInfo);\n\n    while (sd > hitThreshold && totalDist < maxTotalDist)\n    {\n        orig += sd * dir;\n        totalDist += sd;\n\n        sd = sceneSD(orig, sdInfo);\n    }\n\n    hitInfo.hit = false;\n    hitInfo.rayDir = dir;\n    hitInfo.pos = orig;\n    hitInfo.dist = totalDist;\n    hitInfo.sdInfo = sdInfo;\n\n    if (sd > hitThreshold)\n        return;\n\n    hitInfo.hit = true;\n    hitInfo.normal = normalize(vec3(sceneSD(orig + vec3(eps, 0.0, 0.0), sdInfo) - sceneSD(orig - vec3(eps, 0.0, 0.0), sdInfo), sceneSD(orig + vec3(0.0, eps, 0.0), sdInfo) - sceneSD(orig - vec3(0.0, eps, 0.0), sdInfo), sceneSD(orig + vec3(0.0, 0.0, eps), sdInfo) - sceneSD(orig - vec3(0.0, 0.0, eps), sdInfo)));\n}\n\n// https://www.shadertoy.com/view/tlXBRl\nfloat calculateObstruction(vec3 pos, vec3 lightPos, float lightRadius)\n{\n    SdInfo sdInfo;\n\n    vec3 toLight = normalize(lightPos - pos);\n    float distToLight = length(lightPos - pos);\n    float d, t = lightRadius * 0.1;\n    float obstruction = 0.;\n    for (int j = 0; j < 32; j++)\n    {\n        d = sceneSD(pos + t * toLight, sdInfo);\n        obstruction = max(0.5 - d * distToLight / (2. * lightRadius * t), obstruction);\n        if (obstruction >= 1.)\n            break;\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lightRadius * t / distToLight);\n        if (t >= distToLight)\n            break;\n    }\n\n    return clamp(obstruction, 0., 1.);\n}\n\nvoid shadeRay(HitInfo hit, out vec3 incomingLight, out vec3 rayColor)\n{\n    // Sky\n    if (!hit.hit)\n    {\n        // Deep orange\n        const vec3 skyColor1 = vec3(0.60, 0.13, 0.07);\n        const float skyLine1 = -0.01;\n\n        // Orange\n        const vec3 skyColor2 = vec3(1.00, 0.40, 0.16);\n        const float skyLine2 = 0.03;\n\n        // Gray\n        const vec3 skyColor3 = vec3(0.64, 0.59, 0.55);\n        const float skyLine3 = 0.075;\n\n        // Cyan\n        const vec3 skyColor4 = vec3(0.04, 0.25, 0.63);\n        const float skyLine4 = 0.14;\n\n        // Blue\n        const vec3 skyColor5 = vec3(0.006, 0.027, 0.263);\n        const float skyLine5 = 0.25;\n\n        // Dark Blue\n        const vec3 skyColor6 = vec3(0.0002, 0.002, 0.055);\n        const float skyLine6 = 0.53;\n\n        float z = hit.rayDir.z;\n        z += map_range_clamp(voronoi3d(vec3(vec2(hit.rayDir.xy * 2.2), 0.0)).x, 0.0, 1.0, -0.02, 0.0);\n\n        // Color gradient\n\n        float fac = map_range_clamp(z, skyLine1, skyLine2, 0.0, 1.0);\n        vec3 col = mixColPerceptual(skyColor1, skyColor2, fac);\n\n        fac = map_range_clamp(z, skyLine2, skyLine3, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor3, fac);\n\n        fac = map_range_clamp(z, skyLine3, skyLine4, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor4, fac);\n\n        fac = map_range_clamp(z, skyLine4, skyLine5, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor5, fac);\n\n        fac = map_range_clamp(z, skyLine5, skyLine6, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor6, fac);\n\n        // Stars\n        fac = voronoi3d(hit.rayDir.xyz * 33.0).x;\n        if (fac < 0.035)\n        {\n            float intensity = random() * 4.0 + 0.5;\n            intensity *= max(0.0, (hit.rayDir.z - 0.1) * 1.9);\n            col += vec3(intensity);\n        }\n\n\n\n        incomingLight += rayColor * col;\n\n        return;\n    }\n\n    // Diffuse\n    if (hit.sdInfo.objID == OBJID_FLOOR)\n    {\n        rayColor *= vec3(0.08, 0.3, 0.005);\n    }\n    if (hit.sdInfo.objID == OBJID_BOX)\n    {\n        // Emission\n        //incomingLight += rayColor * vec3(1000.0, 50.0, 5.0);\n\n        rayColor *= vec3(0.5, 0.03, 0.01);\n    }\n    if (hit.sdInfo.objID == OBJID_WALL)\n    {\n        rayColor *= vec3(0.55, 0.55, 0.5);\n    }\n    if (hit.sdInfo.objID == OBJID_FRACTAL)\n    {\n        // Fractal color\n        vec3 c = pow(hit.sdInfo.data.ywz, vec3(0.5));\n\n        // Saturation\n        c = mix(vec3(dot(c, lumWeights)), c, 1.3);\n\n        // Clamp\n        c = clamp(c, 0.0, 1.0);\n\n        // Edge glow\n        // If ray dir and hit normal are 90 deg apart\n        // (dot is closer to 0) then we add light.\n        incomingLight += rayColor * pow(1.0 - abs(dot(hit.normal, hit.rayDir)), 1.5) * 0.05 * c;\n\n        // Diffuse color\n        rayColor *= c;\n    }\n    if (hit.sdInfo.objID == OBJID_FRACTAL2)\n    {\n        rayColor *= vec3(0.85, 0.05, 0.005);\n    }\n\n    // Conservation of energy? (IDK)\n    //rayColor /= PI;\n}\n\n// inspired by https://iquilezles.org/articles/fog/\nvec3 pretty_fog(\n    vec3 col,\n    float hit_dist,\n    vec3 ray_dir, // must be normalized\n    vec3 sun_dir, // must be normalized\n    float fog_start_dist, // normally 0\n    vec3 absorption_col, // RGB values below 1, or white to disable\n    float scatter_density, // usually near 0 like .04\n    vec3 scatter_col_sky, // normally a cold color\n    vec3 scatter_col_sun, // normally a warm color\n    float sun_sharpness // default=8\n)\n{\n    // subtract starting distance, return if depth is too low\n    hit_dist -= fog_start_dist;\n    if (hit_dist < .00001)\n    {\n        return col;\n    }\n    \n    // absorption\n    col *= pow(absorption_col, vec3(hit_dist));\n\n    // scatter color depends on view dir and sun dir\n    float sun_fac = pow(\n        max(dot(ray_dir, sun_dir), 0.),\n        sun_sharpness\n    );\n    vec3 scatter_col = mix(\n        scatter_col_sky,\n        scatter_col_sun,\n        sun_fac\n    );\n    \n    // scattering\n    col = mix(\n        col,\n        scatter_col,\n        1. - exp(-hit_dist * scatter_density)\n    );\n    \n    return col;\n}\n\nvoid shadeRayFog(HitInfo firstHit, inout vec3 col)\n{\n    if (!firstHit.hit)\n        return;\n\n    // Fog if we've hit an object\n    col = pretty_fog(\n        col,\n        firstHit.dist,\n        firstHit.rayDir,\n        sunDir,\n        1.,\n        vec3(.99, 1, .995),\n        .04,\n        vec3(.02, .03, .12),\n        vec3(.2, .15, .14),\n        8.\n    );\n}\n\nvec3 tracePath(vec3 rayOrig, vec3 rayDir, out HitInfo firstHit)\n{\n    HitInfo hit;\n    vec3 incomingLight = vec3(0.0);\n    vec3 rayColor = vec3(1.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        // Ray march\n        rayMarch(rayOrig, rayDir, hit);\n\n        if (i == 0)\n            firstHit = hit;\n\n        // Update the colors\n        shadeRay(hit, incomingLight, rayColor);\n\n        // Stop if we hit the sky\n        if (!hit.hit)\n            break;\n\n        // Should we stop bouncing?\n        if (random() > (1.0 / (2.0 * PI)))\n            break;\n\n        // Update the ray\n        rayOrig = hit.pos;\n        rayDir = hit.normal + randomUnitVector();\n        if (dot(rayDir, hit.normal) <= 0.0)\n        {\n            rayDir = -rayDir;\n        }\n\n        //vec3 reflectNormal = reflect(hit.rayDir, hit.normal);\n    }\n\n    // Cast ray towards point light\n    if (hit.hit)\n    {\n        vec3 pointLightPos = vec3(-2.6, 2.5, 3.6);\n        float pointLightStrength = 150.0;\n        vec3 pointLightCol = vec3(1.0, 0.9, 0.6);\n        float pointLightRadius = 0.3;\n\n        vec3 toLight = pointLightPos + (pointLightRadius * randomUnitVector()) - hit.pos;\n\n        float distToLight = length(toLight);\n\n        HitInfo hit2;\n        rayMarch(hit.pos, toLight, hit2);\n\n        if ((!hit2.hit) || (hit2.dist > distToLight))\n        {\n            incomingLight += rayColor * pointLightCol * pointLightStrength * max(dot(hit.normal, normalize(toLight)), 0.0) / (distToLight * distToLight);\n        }\n    }\n\n    return incomingLight;\n}\n\nvec3 render(vec2 uv)\n{\n    // Read data\n    vec3 camOrient = fetchVec3(iChannel1, ivec2(1, 0));\n    vec3 playerPos = fetchVec3(iChannel1, ivec2(2, 0));\n\n    // Setup camera\n\n    vec3 camPos = playerPos;\n    float camFOV = 80.0;\n    float camZoom = 90.0 / camFOV;\n\n    vec3 camForward = orientationToDirection(camOrient);\n    vec3 camRight = normalize(cross(camForward, vec3(0, 0, 1)));\n    vec3 camUp = cross(camRight, camForward);\n\n    // Ray\n    vec3 rayOrig = camPos;\n    vec3 rayDir = normalize(camForward + camRight * (uv.x / camZoom) + camUp * (uv.y / camZoom));\n\n    // Lighting\n    HitInfo firstHit;\n    vec3 col = tracePath(rayOrig, rayDir, firstHit);\n\n    // Fog\n    shadeRayFog(firstHit, col);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // UV from -1 to +1\n    vec2 uv = pixelToDeviceCoords(fragCoord.xy);\n\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Previous frame data\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Jitter sample count (increases over time)\n    int numJitterSamples;\n    if (prev.w < (90.0 * SAMPLE_COUNT_MUL))\n        numJitterSamples = 1;\n    else\n        numJitterSamples = 5;\n\n    // Render\n    vec3 col = vec3(0.0);\n    vec2 msPixelOffset = pixelToDeviceCoords(vec2(1.0, 1.0)) - pixelToDeviceCoords(vec2(0.0, 0.0));\n    for (int i = 1; i <= numJitterSamples; i++)\n    {\n        float offsetX = random() - 0.5;\n        float offsetY = random() - 0.5;\n\n        col += render(uv + msPixelOffset * vec2(offsetX, offsetY));\n    }\n    col /= float(numJitterSamples);\n\n    // Should we reset accumulation?\n    vec4 mouseAndRes = fetchVec4(iChannel1, ivec2(0));\n    vec4 camOrient = fetchVec4(iChannel1, ivec2(1, 0));\n    vec4 playerPos = fetchVec4(iChannel1, ivec2(2, 0));\n    bool reset = (iFrame == 0) || (iTime == 0.0) || (iMouse.xy != mouseAndRes.xy) || (iResolution.xy != mouseAndRes.zw) || (playerPos.w == 1.0) || (camOrient.w == 1.0);\n\n    // Accumulate\n    if (reset)\n    {\n        fragColor = vec4(col, SAMPLE_COUNT_MUL);\n    }\n    else\n    {\n        fragColor.rgb = prev.rgb + col;\n        fragColor.w = prev.w + SAMPLE_COUNT_MUL;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B\n// iChannel0 = Buffer B\n// iChannel1 = Keyboard\n\nvec2 getMouseUV()\n{\n    if (ivec2(iMouse) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvec2 getMouseUV(vec2 pos, vec2 res)\n{\n    if (ivec2(pos) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = pos.xy / res.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Mouse position and resolution\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        fragColor = vec4(iMouse.xy, iResolution.xy);\n    }\n\n    bool reset = (iFrame < 4) || (iTime == 0.0) || keyGotPressed(KEY_R, iChannel1);\n\n    // Mouse drag info\n    if (ivec2(fragCoord) == ivec2(3, 0))\n    {\n        vec3 mouseDrag = fetchVec3(iChannel0, ivec2(3, 0));\n\n        // Update if needed\n        if (iMouse.z > 0.0)\n        {\n            mouseDrag = vec3(getMouseUV(), 1.0);\n        }\n        else\n        {\n            mouseDrag.z = 0.0;\n        }\n\n        // Write\n        fragColor = vec4(mouseDrag, 0);\n    }\n\n    // Camera orientation\n    if (ivec2(fragCoord) == ivec2(1, 0))\n    {\n        // Read\n        vec4 camOrient = fetchVec4(iChannel0, ivec2(1, 0));\n\n        // W == 1 means accumulation should be reset\n        if (camOrient.w == 1.0)\n            camOrient.w = 0.0;\n\n        // Reset if needed\n        if ((camOrient.xyz == vec3(0.0)) || (length(camOrient.xyz) < 0.1) || reset)\n        {\n            camOrient = vec4(defCamOrient, 1.0);\n        }\n\n        // Delta mouse UV\n        vec3 mouseDrag = fetchVec3(iChannel0, ivec2(3, 0));\n        vec2 deltaMouseUV = getMouseUV() - mouseDrag.xy;\n\n        // Update if needed\n        if (iMouse.z > 0.0 && mouseDrag.z > 0.0 && length(deltaMouseUV) > 0.00001)\n        {\n            camOrient.x += deltaMouseUV.y * 84.5;\n            camOrient.z += deltaMouseUV.x * -120.0;\n            camOrient.w = 1.0;\n        }\n\n        // Write\n        fragColor = camOrient;\n    }\n\n    // Player position\n    if (ivec2(fragCoord) == ivec2(2, 0))\n    {\n        // Read\n        vec4 playerPos = fetchVec4(iChannel0, ivec2(2, 0));\n\n        // W == 1 means accumulation should be reset\n        if (playerPos.w == 1.0)\n            playerPos.w = 0.0;\n\n        // Reset if needed\n        if (playerPos.xyz == vec3(0.0) || reset)\n            playerPos = vec4(defPlayerPos, 1.0);\n\n        // Get camera directions for movement\n        vec3 camOrient = fetchVec3(iChannel0, ivec2(1, 0));\n        vec3 camForward = orientationToDirection(camOrient);\n        vec3 camRight = normalize(cross(camForward, vec3(0, 0, 1)));\n\n        // Get velocity based on the keyboard input\n        vec3 velocity = vec3(0.0);\n        velocity += camForward * keyIsDownF(KEY_W, iChannel1);\n        velocity += -camForward * keyIsDownF(KEY_S, iChannel1);\n        velocity += -camRight * keyIsDownF(KEY_A, iChannel1);\n        velocity += camRight * keyIsDownF(KEY_D, iChannel1);\n        velocity.z = 0.0;\n\n        // Up/down movement\n        velocity.z += 0.5 * keyIsDownF(KEY_Q, iChannel1);\n        velocity.z -= 0.5 * keyIsDownF(KEY_Z, iChannel1);\n\n        // Speed multiplier\n        float speed = 1.5;\n        if (keyIsDown(KEY_SHIFT, iChannel1))\n            speed = 4.0;\n        if (keyIsDown(KEY_ALT, iChannel1))\n            speed = 0.4;\n        velocity *= speed;\n\n        // Move if needed\n        if (velocity != vec3(0.0))\n        {\n            playerPos.xyz += velocity * iTimeDelta;\n            playerPos.w = 1.0;\n        }\n\n        // Write\n        fragColor = playerPos;\n    }\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 178, 197, 605], [607, 607, 647, 647, 758], [760, 760, 815, 815, 922]]}
{"id": "csfcWS", "name": "Tapestry 6", "author": "iterati", "description": "Colored layers are fun", "tags": ["ifs"], "likes": 6, "viewed": 169, "published": 3, "date": "1687370974", "time_retrieved": "2024-07-30T17:48:17.354740", "image_code": "float sheen( in float d, in float x )\n{\n    return 1. - smoothstep(0.0, x, abs(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 col = vec3(0.);\n    float d = 0.;\n    \n    float r = sawT(iTime, 7.) * 0.5 + 0.25;\n    float color = sinT(iTime, 60.);\n\n    float x = ampT(iTime, 36., 4., 3.) * 0.2 + 1.2;\n    uv.x += (sinT(iTime, 45.) - 0.5) * 0.5 * x;\n    uv.y += (sinT(iTime + (45. * PI), 45.) - 0.5) * 0.5 * x;\n\n    const float iterations = 8.;\n    for (float i = 0.0; i < iterations; i++) {\n        float rot = (i + 1.) * PI * 0.25;\n        float xx = (ampT(iTime, 63., 4., 3.) - 0.5) * 0.5 * ((iterations - i) / iterations);\n        uv = fract(rotate(uv, rot) * (x + xx)) - 0.5;\n        float vu = floor(uv.x) + floor(uv.y);\n        d = sdStar(uv, r, 4, 4.);\n        d = sheen(d, (0.0025 * (i + 1.) * (x + xx)));\n        float cc = (1. - sawT(iTime, 29.)) * 3.;\n        col = palette(mod(color + (i * cc * (1. / iterations)), 1.0));\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, in float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( in float t, float l, float a, float b)\n{\n    return abs(cos((t / l) * a * 2. * PI) * cos((t / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 85], [87, 87, 144, 144, 1160]]}
{"id": "DsjyRR", "name": "InitiationShader", "author": "sklbz", "description": "my second shader (much better than the first).", "tags": ["fractals"], "likes": 0, "viewed": 128, "published": 3, "date": "1687358050", "time_retrieved": "2024-07-30T17:48:18.146623", "image_code": "vec3 palette(float t) {\nvec3 a = vec3(0.600, 0.500, 0.500), b = vec3(0.910, 0.600, 0.600), c = vec3(1.058, 1.000, 1.000), \n        d = vec3(0.190, 0.413, 0.557);\n        return a+b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y * 1.5;\n    \n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i< 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        \n        float d = length(uv) * exp(-length(uv0));\n    \n        vec3 col = palette(length(uv0) + (i + iTime*0.5)*.4);\n    \n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n    \n        d = pow(0.015 / d, 1.4);\n    \n        finalColor += col * d;\n    }\n\n    fragColor = vec4( finalColor , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 204], [206, 206, 263, 263, 789]]}
{"id": "mdScRz", "name": "[RMO] - torus", "author": "silica163", "description": "torus sdf", "tags": ["raymarch", "torus"], "likes": 1, "viewed": 160, "published": 3, "date": "1687356536", "time_retrieved": "2024-07-30T17:48:18.913572", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    tor[0].r = vec2(1,.5);\n    \n    l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[1].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    c += render(r);\n    \n    //c = N*.5+.5;\n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  10.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\n#define rotX(a) mat3(      1, 0,       0, 0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n\nconst int LIGHTS = 2;\nconst int TORUS = 1;\n\nstruct Torus {\n    vec3 p;\n    vec2 r;\n    vec3 c;\n},tor[TORUS];\n\nfloat torusSDF(vec3 p,int id){\n    float d = 0.;\n    Torus t = tor[id];\n    \n    vec3 sp;\n    sp.xz = normalize(p.xz-t.p.xz)*t.r.x;\n    d = length(p-t.p-sp)-t.r.y;\n    \n    return d;\n}\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat dist(vec3 p){\n\tfloat d = 10000.;\n    \n\td = torusSDF(p,0);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += diffuse(r.p,l[i].L);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(.1);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdScRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 926]]}
{"id": "dsSczR", "name": "Iterative Cissoid distance", "author": "NinjaKoala", "description": "Inspired by NR4s variant https://www.shadertoy.com/view/DdsyDX i gave it a try using an iterative scheme.\nThe technique is similar to https://www.shadertoy.com/view/ctBSWR and like there, it works ok but needed some fiddling to remove artifacts.", "tags": ["2d", "sdf", "lagrange", "cissoid"], "likes": 4, "viewed": 176, "published": 3, "date": "1687353473", "time_retrieved": "2024-07-30T17:48:19.726399", "image_code": "const int num_iterations=20;\n\nfloat cissoid(vec2 uv, float a, out vec2 grad){\n\tgrad = vec2(3.*uv.x*uv.x+uv.y*uv.y,(2.*uv.x-4.*a)*uv.y);\n\n\treturn dot(uv,uv)*uv.x-2.*a*uv.y*uv.y;\n}\n\nfloat lagrange_curve(vec2 uv, vec2 p2, float a, out vec2 grad){\n\tgrad = vec2(2.*(2.*a + uv.x + p2.x)*uv.y - 6.*uv.x*p2.y,(4.*a + uv.x)*uv.x - 2.*(2.*a - uv.x)*p2.x + (3.*uv.y - 2.*p2.y)*uv.y);\n\treturn (dot(uv,uv) + 2.*uv.x*p2.x + 4.*(uv.x - p2.x)*a)*uv.y - (3.*uv.x*uv.x + uv.y*uv.y)*p2.y;\n}\n\nvec2 iteration(vec2 p, vec2 p2, float a){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val2 = lagrange_curve(p,p2,a,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\tp_val1 = cissoid(p,a,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\treturn p;\n}\n\nfloat cissoid_dis(vec2 uv, float a){\n\tvec2 p0 = vec2(2.*a,uv.y+5.*a*sign(uv.y));\n\n\tfloat cusp_dis = length(uv);\n\n\tif(a > .15 && uv.x > 0. && cusp_dis < .05){\n\t\tp0.x = 0.;\n\t}\n\n\tfor(int i=0;i<num_iterations;i++){\n\t\tp0 = iteration(p0,uv,a);\n\t}\n\n\treturn min(cusp_dis,distance(p0,uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tfloat fac = .5+.5*sin(iTime*.2+1.);\n\n\tfloat dis = cissoid_dis(uv,fac);\n\n\t//iq's sd color scheme\n\tvec3 col = (dis>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-12.0*abs(dis));\n\tcol *= 0.7 + 0.2*cos(480.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,3.0*border,abs(dis)) );\n\n\tvec2 grad;\n\tfloat val = lagrange_curve(uv,mouse,fac,grad);\n\n\tfloat mdis = cissoid_dis(mouse,fac);\n\n\tcol = mix(vec3(1,0,0), col, smoothstep(0.,border,abs(distance(mouse,uv)-mdis)));\n\t//col = mix(vec3(0), col, smoothstep(0.,border,abs(val)/length(grad)));\n\n\tfragColor=vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 77, 77, 178], [180, 180, 243, 243, 471], [473, 473, 514, 514, 741], [743, 743, 779, 779, 1025], [1027, 1027, 1081, 1081, 1880]]}
{"id": "DdSczz", "name": "[RMO] - cylinder", "author": "silica163", "description": "cylinder sdf", "tags": ["raymarch", "cylinder"], "likes": 1, "viewed": 137, "published": 3, "date": "1687346034", "time_retrieved": "2024-07-30T17:48:20.545210", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    cyl[0].p = vec3(0);\n    cyl[0].s = vec2(2,.5);\n    \n    l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[1].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    c += render(r);\n    \n    //c = r.p;\n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  10.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\n#define rotX(a) mat3(1,0,0,0,sin(a),cos(a),0,-cos(a),sin(a))\n#define rotY(a)mat3(sin(a), 0,-cos(a), 0, 1,  0,cos(a), 0, sin(a))\n\nconst int LIGHTS = 2;\nconst int CYLS = 1;\n\nstruct Cyl {\n    vec3 p;\n    vec2 s;\n    vec3 c;\n},cyl[CYLS];\n\nfloat cylinderSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Cyl c = cyl[id];\n    vec3 cp = p - c.p;\n    \n    d = vec2(abs(cp.y),length(cp.xz)) - c.s * vec2(.5,1);\n    \n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n\td = cylinderSDF(p,0);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += max(dot(l[i].L,N),0.);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(0);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 946]]}
{"id": "mslcWX", "name": "[RMO] - capsule", "author": "silica163", "description": "capsule sdf", "tags": ["raymarch", "line", "capsule"], "likes": 2, "viewed": 188, "published": 3, "date": "1687345185", "time_retrieved": "2024-07-30T17:48:21.333104", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/2.,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    line[0].a = vec3(.5);\n    line[0].b = vec3(-.5);\n    line[0].r = .5;\n    l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[1].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    c += render(r);\n    \n    //c = N*.5+.5;\n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\nconst int LIGHTS = 2;\nconst int LINES = 1;\n\nstruct Line {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    float r;\n},line[LINES];\n\nfloat lineSDF(vec3 p,int id){\n    float d = 0.;\n    Line li = line[id];\n    vec3 p1 = p - li.a;\n    vec3 p2 = li.b - li.a;\n    \n    d = length(p1 - clamp(dot(p1,p2)/dot(p2,p2),0.,1.)*p2) - li.r;\n    return d;\n}\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n\td = lineSDF(p,0);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nmat3 rotX(float a){\n    float sa = sin(a),\n        ca = cos(a);\n    return mat3(\n         1,  0, 0,\n         0, sa,ca,\n         0,-ca,sa\n    );\n}\n\nmat3 rotY(float a){\n    float sa = sin(a),\n        ca = cos(a);\n    return mat3(\n        sa, 0,-ca,\n         0, 1,  0,\n        ca, 0, sa\n    );\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += max(dot(l[i].L,N),0.);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(0);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 966]]}
{"id": "cdfyR2", "name": "Year of Truchets #041", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n\nvery linux / openGL screensaver looking", "tags": ["raymarching", "truchet", "trippy", "circuit"], "likes": 21, "viewed": 253, "published": 3, "date": "1687341971", "time_retrieved": "2024-07-30T17:48:22.119002", "image_code": "/**\n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #041\n    06/21/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MIN_DIST    1e-3\n#define MAX_DIST    55.\n\n// constants\nconst float size = 1.35;\nconst float hlf = size*.5;\nconst float xlf = hlf*.5;\n\nvec3 hit,hitPoint;\nvec2 gid,sid;\nmat2 r90,r45;\nfloat speed,glowa,glowb;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq sdfs & extrude\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat box(vec2 p, vec2 a) {\n    vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\nfloat cap( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat opx(in float sdf, in float pz, in float h) {\n    vec2 w = vec2( sdf, abs(pz) - h );return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos, float sg){\n    vec2 res = vec2(1e5,0);\n\n    pos-=vec3(0,0,speed);\n\n    float sw = .2+.2*sin(pos.z*.63);\n    sw -= .3+.2*cos(pos.x*.73);\n    pos.y-=sw;\n    \n    vec2 uv = pos.xz;\n    vec2 id = floor((uv+hlf)/size);\n    vec2 q = mod(uv+hlf,size)-hlf;\n    \n    vec3 pp = vec3(q.x,pos.y,q.y);\n\n    float rnd = hash21(id);\n    float rdm = fract(rnd*42.79);\n    \n    if (rnd>.5) {q.x = -q.x; pp.xz*=r90;}\n    rnd = fract(rnd*32.781);\n    \n    float mv = .02, mx = mv*3.5;\n    const vec3 b2 = vec3(1.,.15,hlf);\n\n    vec2 spc = vec2(-hlf,.0);\n    vec2 p2 = vec2(length(q+spc),length(q-spc));\n    vec2 pq = p2.x<p2.y? q+spc : q-spc;\n\n    pq *= r45;\n\n    float d = length(pq.x);\n    if(rnd>.85) d = min(length(q.x),length(q.y));\n\n    d = abs(d)-mv;\n\n    float pl = length(vec2(abs(q.x)-hlf,q.y))-(mx);\n          pl = min(length(vec2(q.x,abs(q.y)-hlf))-(mx),pl);\n\n    float d3 = opx(d,pos.y,.05);\n    float ct = box(pp,vec3(hlf,5,hlf));\n    d3=max(max(d3,ct),-(pl));\n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit = pos-vec3(0,sw,0);\n    }\n\n    float pole = opx(abs(pl)-.01,pos.y, .055);\n    if(pole<res.x) {\n        res = vec2(pole,3.);\n        hit = pos;\n    }\n    \n    float bx=1e5,rx=1e5,cx=1e5,lx=1e5;\n    if(rnd<.675 && rdm>.75){\n        pp.xz*=r45;\n        bx = box(pp,vec3(xlf,.05,xlf*.5))-.01;\n    }else if(rnd<.675 && rdm>.5){\n        pp.xz*=r45;\n        pp = vec3(abs(abs(pp.x)-(.125*size))-(.0625*size),pp.yz);\n        rx = cap(pp.yzx,.74*xlf,.01*size)-.03;\n    }else if(rnd<.675 && rdm<.2){\n        pp.y-=.2;\n        cx = cap(pp,.2,.15)-.01;\n    }else if(rnd<.675) {\n        lx = cap(pp,.1,.001)-.05;\n        bx=min(bx,cap(pp+vec3(0,.05,0),.03,.075));\n    }\n    rdm = fract(rnd*42.79);\n    if(bx<res.x) {\n        res = vec2(bx,4.);\n        hit = pp;\n    }\n    if(rx<res.x) {\n        res = vec2(rx,7.);\n        hit = pp;\n    }\n    if(cx<res.x) {\n        res = vec2(cx,8.);\n        hit = pp;\n    }  \n    if(lx<res.x) {\n        res = vec2(lx,9.);\n        hit = pp;\n    } \n    float flr =pos.y+.05;\n    if(flr<res.x) {\n        res = vec2(flr,1.);\n        hit = pos;\n    }\n           \n    if(sg==1.&&lx<bx) { \n        if(rdm>.5) {glowa += .0005/(.0001+lx*lx);}else{glowb += .0005/(.0001+lx*lx);}\n    }\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e,0. ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e,0. ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e,0. ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e,0. ).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd,float cnt) {\n    float d = 0., m = 0.;\n    for(int i=0;i<128;i++){\n        vec2 ray = map(ro + rd * d,cnt>0.?0.:1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<64?ray.x*.4:ray.x*.8;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv, float cnt) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd,cnt);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n    hitPoint = hit;  \n    sid = gid;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST)\n    {\n             p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-6.,12.,12.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.5);\n\n        if(m==1.) {\n            float px = 2./R.x; \n            vec2 dp = p.xz;\n            dp.y-=speed;\n            vec3 k = vec3(0.012,0.149,0.047);\n            vec2 id = floor(dp.xy*6.), q = fract(dp.xy*6.)-.5;\n            float hs = hash21(id.xy);\n\n            if(hs>.5)  q.xy *= rot(1.5707);\n            hs = fract(hs*575.913);\n\n            float mv = .1;\n\n            vec2 spc = vec2(-.5,.0);\n            vec2 p2 = vec2(length(q+spc),length(q-spc));\n            vec2 pq = p2.x<p2.y? q+spc : q-spc;\n\n            pq *= r45;\n\n            float td = length(pq.x);\n            td=abs(td)-mv;\n\n            if(hs>.85) td = min(length(q.x)-mv,length(q.y)-mv);\n            float b = length(vec2(abs(q.x)-.5,q.y))-(mv*1.75);\n            b = min(length(vec2(q.x,abs(q.y)-.5))-(mv*1.75),b);\n            td = min(b,td);\n            h = mix(k,k*.75,smoothstep(px,-px,td));\n            ref = vec3(td);\n        }\n        if(m==2.) { \n            h = hsv2rgb(vec3(hitPoint.z*.02,1.,.3)); \n            ref = h; \n        }\n        if(m==3.) { h = vec3(.1); ref = h; }\n        if(m==4.) { h = vec3(.05); ref = vec3(.35); }\n        if(m==5.) { \n            h = hsv2rgb(vec3(-hitPoint.z*.02,.75,.3)); \n            ref = h; \n        }\n        if(m==6.) { \n            vec2 f = fract(hitPoint.xz*.5)-.5;\n            h = vec3(.01);\n            if(f.x*f.y>.0)h=vec3(.1);\n            ref = h; \n        }\n        if(m==7.) { \n            h = vec3(0.255,0.161,0.086); \n            float ft = fract((hitPoint.z+.4)*8.)-.5;\n            float fmod = mod(floor(ft),3.);\n            if(hitPoint.z>-.15) h = mix(h,hsv2rgb(vec3((p.z-speed)*.5,.8,.1)),fmod==0.?1.:0.);\n            \n            ref = h*.5; \n        }\n        if(m==8.) { \n            vec2 hp = hitPoint.xz;\n            float d = length(hp)-.1;\n            float b = box(hp-vec2(.5,0),vec2(.5,.05));\n            float px = 4./R.x;\n            h = vec3(.012,.227,.427); \n            h = mix(h,vec3(0.349,0.506,0.651),smoothstep(px,-px,b));\n            h = mix(h,vec3(.1),smoothstep(px,-px,d));\n            ref = h*.5; \n        }\n        \n        C = (diff*h);\n\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } \n\n    return vec4(C,d);\n}\n\nmat2 rx,ry;\nvec3 FC = vec3(0.114,0.227,0.137);\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    r45 = rot(.7853981634);\n    r90 = rot(1.5707);\n    speed = T*2.05;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,5.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z <0. ? .0 : (M.y/R.y * .24-.12)*PI;\n    float y = M.xy==vec2(0) || M.z <0. ? .0 : (M.x/R.x * 1.0-.50)*PI;\n\n    float ff = .45+.25*cos(T*.065), fx = .55*sin(T*.113);\n\n    rx = rot(-(.28+ff)-x), ry = rot(-fx-y);\n    \n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<2.; i++) {   \n        //glowa=0.;glowb=0.;\n        vec4 pass = render(ro, rd, ref, d, uv, i);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n     \n    }\n      \n    C = mix(C,vec3(0.941,0.459,0.459),clamp(glowa*.5,0.,1.));\n    C = mix(C,vec3(0.420,0.749,0.353),clamp(glowb*.5,0.,1.));\n    \n    C = mix(FC,C,exp(-.00025*a*a*a));\n  \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfyR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[552, 552, 570, 570, 614], [615, 615, 639, 639, 697], [699, 720, 748, 748, 832], [833, 833, 860, 860, 929], [930, 930, 969, 969, 1073], [1074, 1074, 1124, 1124, 1216], [1218, 1218, 1247, 1247, 3464], [3466, 3535, 3565, 3565, 3801], [3803, 3803, 3845, 3845, 4084], [4086, 4100, 4127, 4127, 4239], [4241, 4241, 4335, 4335, 7272], [7322, 7322, 7363, 7363, 8454]]}
{"id": "DsBczR", "name": "Flowing Wires [471 chars]", "author": "kishimisu", "description": "Inspired by @byte_mechanic's various Year of Truchet experiments.", "tags": ["3d", "raymarching", "ray", "light", "marching", "space", "repetition", "bloom", "truchet", "infinite", "neon", "short", "golf"], "likes": 91, "viewed": 4651, "published": 3, "date": "1687340533", "time_retrieved": "2024-07-30T17:48:22.957760", "image_code": "/* Flowing Wires by @kishimisu (2023) - https://www.shadertoy.com/view/DsBczR\n   \n   This is actually a 3D truchet pattern (with 1 tile and no variation)\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0))) \n\n#define s(p) ( q = p,                                    \\\n    d = length(vec2(length(q.xy += .5)-.5, q.z)) - .01,  \\\n    q.yx *= r(round((atan(q.y,q.x)-T) * 3.8) / 3.8 + T), \\\n    q.x -= .5,                                           \\\n    O += (sin(t+T)*.1+.1)*(1.+cos(t+T*.5+vec4(0,1,2,0))) \\\n         / (.5 + pow(length(q)*50., 1.3))            , d ) // return d\n   \nvoid mainImage(out vec4 O, vec2 F) {\n    vec3  p, q,    R = iResolution;\n    float i, t, d, T = iTime;\n\n    for (O *= i, F += F - R.xy; i++ < 28.;          // raymarch for 28 iterations\n        \n        p = t * normalize(vec3(F*r(t*.1), R.y)),    // ray position\n        p.zx *= r(T/4.), p.zy *= r(T/3.), p.x += T, // camera movement\n                   \n        t += min(min(s( p = fract(p) - .5 ),        // distance to torus + color (x3)\n                     s( vec3(-p.y, p.zx)  )),\n                     s( -p.zxy            ))\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBczR.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[751, 751, 787, 787, 1290]]}
{"id": "dssyDs", "name": "truss: structured beams", "author": "FabriceNeyret2", "description": "mouse controls camera\n\nhttps://en.wikipedia.org/wiki/Truss", "tags": ["short", "truss"], "likes": 28, "viewed": 235, "published": 3, "date": "1687332555", "time_retrieved": "2024-07-30T17:48:23.821450", "image_code": "\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                    // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -R.y) - R),                       // ray direction\n          p = vec3(0,0,5), q,                                       // marching point along ray \n          C = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.                   // camera control\n                            : 3.* cos(.3*iTime + vec3(0,11,0));     // demo mode\n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )                  // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                          // rotations\n        q.xz *= rot(-C.x),\n        q.xy = length(q.xy) * cos( mod(atan(q.y,q.x),2.1)-1. + vec2(0,11) ), // 3- rot symmetry\n        q.z = mod(q.z,2.) - 1.,                                     // z-repeat\n        q.x -= .5,                                                  // faces = 0yz plane\n        t = min( length(vec2(q.x,abs(q.y)-.87)) -.1,                // long tubes\n                 max(length(vec2(q.x,.87*abs(q.z)+.5*q.y-.5))-.1, abs(q.y)-.9) ), // short tubes\n        p += .3*t*D;                                                // step forward = dist to obj  \n    \n   O *= O*O*O*2.;                                                   // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 118, 118, 1354]]}
{"id": "cslcWs", "name": "RAZZLE 0.333", "author": "MacroMachines", "description": "DEEP FAKE <3", "tags": ["sdf", "glitch", "bw", "stripes", "reza"], "likes": 3, "viewed": 144, "published": 3, "date": "1687315959", "time_retrieved": "2024-07-30T17:48:24.593387", "image_code": "// Fork of \"RAZZLE 0.33\" by MacroMachines. https://shadertoy.com/view/cdscWl\n// 2023-06-21 02:46:52\n\n// Fork of \"Space Puppy Zebra\" by reza. https://shadertoy.com/view/MscGWN\n// 2023-06-21 00:28:12\n\n// This is me stealing many many many things from IQ, THANK YOU IQ, YOU ARE THE BEST!!!\n// Really this is just a glitchy bastardization of ray marching a space puppy sphere\n// Then I put some strips on it, because why not right?\n\n#define TWO_PI 6.2831853072\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\n\n\nfloat RIPPLES = 0.320;\nfloat MODAMT = 1.0;\nvec3 RIM = vec3( 0.10, -0.90, 0.950 );\nfloat kick = 0.0; \nfloat snare = 0.0;//pow(fract(iTime*0.5),6.) * 0.12*MODAMT;\n\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n\n{\n    float modValue = snoise( vec4( 0.350 * normalize( p ), 0.05252 * iTime + kick) );\n    vec3 d = abs(p) - b;\n    float dd = min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n    dd += modValue;\n    return dd;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\n\tfloat modValue = snoise( vec4( 1.0 * normalize( p ), 0.052 * iTime ) );\n    return length( p ) - ( s + 0.5 * modValue );\n\t// return length( p ) - s;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 MAPP = vec2( sdSphere( pos, 1.0 ), 2.0 );\n    MAPP = vec2( sdBox( pos, vec3(0.50) ), 1.50 );\n    return MAPP;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 2.0;\n\n\tfloat precis = 0.1;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<1; i++ )\n    {\n\t    vec2 res = map( ro + rd*t );\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n\t    \tm = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.5, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3( 0.0, 0.0, 0.0 );\n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n\t\tfloat m = res.y;\n    if( m > -1.90 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = abs( calcNormal( pos ) );\n        col = vec3( 2.950 );\n        float rim = dot( RIM, nor );;\n        float value = cos( rim * TWO_PI * 40.0*RIPPLES );\n//        col *= value > 0.7 ? 1.0 : 0.0;\n        col *= smoothstep(.5,.51, value );\t// thank you @iapafoto!\n    }\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\n\n\t// camera\n    kick = pow(cos(iTime*PI),2.) * 0.12*MODAMT;\n    snare = pow(fract(iTime*0.25),2.) * 1.02*MODAMT;\n\tvec3 ro = vec3( 0.0, 0.0, -2.25+snare );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    ro *= setCamera(ro, ta, 0.0);\n    \n    \n    // ray direction\n\tvec3 rd = normalize( vec3( p.xy, 2.0 ) );\n    // render\n    vec3 col = render( ro, rd );\n\tcol = pow( col, vec3( 20 ) );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1072, 1072, 1093, 1093, 1142], [1144, 1144, 1167, 1167, 1216], [1218, 1218, 1240, 1240, 1280], [1282, 1282, 1306, 1306, 1346], [1348, 1348, 1376, 1376, 1428], [1430, 1430, 1460, 1460, 1512], [1514, 1514, 1546, 1546, 1809], [1891, 1891, 1915, 1915, 4390], [4392, 4392, 4424, 4424, 4642], [4644, 4644, 4679, 4679, 4832], [4834, 4834, 4859, 4859, 4980], [4982, 4982, 5022, 5022, 5341], [5343, 5343, 5375, 5375, 5594], [5596, 5596, 5635, 5635, 6103], [6105, 6105, 6157, 6157, 6334], [6336, 6336, 6393, 6393, 6936]]}
{"id": "dsXcDl", "name": "Rotational Patterns", "author": "mgmbass", "description": "Exploring rotating patterns. ", "tags": ["patterns", "rotation", "fract"], "likes": 3, "viewed": 124, "published": 3, "date": "1687297006", "time_retrieved": "2024-07-30T17:48:25.499962", "image_code": "#define PI 3.14159265358979323846\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rotate space\n    uv = rotate2D(uv, PI *sin(iTime));\n    \n    // fract space \n    float frac = 4.0;\n    vec2 uvf = tile(uv, frac);\n    \n    // Rotate each fraction \n    uvf = rotate2D(uvf, PI *cos(iTime / 2.));\n\n    vec3 col = vec3(0.0);\n    vec3 color;\n    color = vec3(box(uvf, vec2(0.7), 0.01));\n    \n    //Color transitions. \n    color.rb = rotate2D(color.rb, PI * cos(iTime));\n    color.g = 1. / sin(iTime / 2.);\n    \n    // Output to screen\n    fragColor = vec4(color + col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 79, 79, 247], [249, 249, 301, 301, 494], [496, 496, 529, 529, 572], [574, 574, 612, 612, 752], [754, 754, 811, 861, 1400]]}
{"id": "cdfyDs", "name": "glass mug", "author": "elenzil", "description": "keys 1 .. 7 toggle stuff.\nonion-skinning it (key 7) doesn't look right, i need to re-do the ray-handling.", "tags": ["coffee", "refraction", "glass", "optics"], "likes": 28, "viewed": 384, "published": 3, "date": "1687291248", "time_retrieved": "2024-07-30T17:48:26.635926", "image_code": "//---------------------------------------------------------------------\n// keyboard stuff\n\nbool        kPipOn      =   false;      // heat map.       1\nbool        kPixelate   =   false;      // chunky pixels.  2\nbool        kShadows    =   true;       // shadows.        3\nbool        kFullRays   =   true;       // quality.        4\nbool        kMtl1       =   false;      // material        5\nbool        kCut        =   false;      // cutting plane   6\nbool        kHollow     =   false;      // hollow geometry 7\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn    =  KEY_TOGGLED(ZRO + 1, iChannel2);\n    kPixelate =  KEY_TOGGLED(ZRO + 2, iChannel2);\n    kShadows  = !KEY_TOGGLED(ZRO + 3, iChannel2);\n    kFullRays = !KEY_TOGGLED(ZRO + 4, iChannel2);\n    kMtl1     =  KEY_TOGGLED(ZRO + 5, iChannel2);\n    kCut      =  KEY_TOGGLED(ZRO + 6, iChannel2);\n    kHollow   =  KEY_TOGGLED(ZRO + 7, iChannel2);\n}\n\n//---------------------------------------------------------------------\n// materials\n\nconst uint mtl_0                 =  0u;\nconst uint mtl_floor             =  1u;\nconst uint mtl_green_glass       =  2u;\nconst uint mtl_other_glass       =  3u;\nconst uint mtl_cup_glass         =  3u;\nconst uint mtl_debug             =  5u;\nconst uint mtl_count             =  6u;\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    //    ior   trn   alb                  transmissance\n    mtl_t(1.0 , 0.0 , v1                 , v41),                         // sky\n    mtl_t(2.0 , 0.0 , v1                 , v41),                         // floor\n    mtl_t(1.5 , 1.0 , v0                 , vec4(0.1, 0.7, 0.2 ,  1.3)), // glass chartreuse\n    mtl_t(1.8 , 1.0 , v0                 , vec4(0.3, 0.9, 0.4 ,  2.0)),  // other glass\n    mtl_t(1.8 , 1.0 , v0                 , vec4(0.3, 0.9, 0.4 ,  2.0)),  // cup glass\n    mtl_t(2.0 , 0.0 , vec3(0.8, 0.6, 0.6), v41)                          // debug\n);\n\n\n//---------------------------------------------------------------------\n// viewport stuff\n\nconst float cPipScale   =   0.4;        // heatmap size\nconst float cPixelation =   8.0;\n      float gVPZoom     =   0.8;\n      float gVPEps      =   1e9;        // viewport epsilon\n      float gVPLW       =   1e9;        // viewport linewidth\n      float gT          =   0.0;\n      float gFOVFac     =   0.5;        // smaller = zoomier\n      float gCamDist    =  30.0;\n      float gMapCount   =   0.0;\n      vec3  gRGB;\n      \n// raymarch stuff\nconst uint  cMaxMarchSteps = 900u;      // crazy high for internal reflection\nconst uint  cHeatMapSteps  = 150u;      // march steps used in heatmap visualization\nconst float cWSEps         =   0.0001;\nconst float gUnderStepFac  =   0.98;\nconst float cSurfEps       =   cWSEps * 3.0;\nconst float cMinRayAmt     =   0.4 / 256.0;\nconst uint  cMaxRays       = 2010u;\n      uint  gRayCount;\nconst uint  cHeatMapRays   =   20u;\n      uint  gMaxRays       =   cMaxRays; // toggled at runtime\n      uint  gMtl           =   mtl_green_glass;\n      \n//---------------------------------------------------------------------\n// scene stuff\n\nfloat gCutPlaneOffset = 1e8; // set at runtime\n\nvoid configScene() {\n    gCutPlaneOffset = kCut  ? 0.0 : -1e8;\n    gMtl            = kMtl1 ? mtl_debug : mtl_green_glass;\n}\n\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nMST map(in vec3 p) {\n    gMapCount += 1.0;\n\n    MST   ret = MST(1e9, mtl_0);\n    \n    float d = ret.dist;\n    vec3  q;\n    vec4  w;\n    \n    // centimeters\n    const float outRad          = 11.0;\n    const float height          = 18.0;\n    const float mainThickness   =  0.8;\n    const float hover           =  0.001;\n    const float wallThick       =  0.1;\n    const float handleClearance =  2.0;\n    \n    const float handleRad        = 3.3;\n    const float handleHeight     = height / 2.0 + mainThickness - 3.5;\n    const float handleVertOffset = 1.0;\n    const float handleWidth      = 0.8;\n    const float handleDepth      = 5.0;\n    const float handleThickness  = 0.4;\n    \n    const float cylRad = outRad - mainThickness;\n    \n    // bottom is a cylinder\n    q = p;\n    q.y -= mainThickness + wallThick + hover;\n    d = min(d, sdCappedCylinder(q, mainThickness, cylRad));\n    \n    // walls are a space-expanded torus\n    q = p;\n    q.y -= mainThickness + wallThick + height / 2.0 + hover;\n    w = opElongate(q, vec3(0.0, height / 2.0, 0.0));\n    \n    d = min(d, w.w + sdTorus(w.xyz, vec2(cylRad, mainThickness)));\n    \n    d = kHollow ? abs(d) : d;\n    d -=wallThick;\n    \n    // handle\n    q = p;\n    q.y -= mainThickness + wallThick + height / 2.0 + hover + handleVertOffset;\n    q.z -= outRad;\n    w = opElongate(q, vec3(handleWidth, handleHeight - handleRad, handleDepth - handleRad));\n    float hd = w.w + sdTorus(w.yxz, vec2(handleRad, handleThickness));\n    opMinus(hd, p.z - outRad);\n    \n    d = smin(d, hd, 0.3);\n    \n    d = max(d, p.x + gCutPlaneOffset);\n\n    ret.dist = d;\n    ret.mtl = gMtl;\n\n\n    return ret;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene(in ray_t r, inout hit_t h, in uint maxSteps) {\n    // tack on a plane via analytic intersection.\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n\n    float t = 0.0;\n    \n    for (uint n = 0u; n < maxSteps && t < 1e3; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        MST ms = map(p);\n        float absDist = abs(ms.dist);\n        if (t < h.t && (absDist < cWSEps)) {\n            h.hit      = true;\n            h.t        = t;\n            h.pnt      = p;\n            h.nrm      = mapNormal(p);\n            h.mtl      = ms.mtl;\n            \n            if (h.mtl == gMtl) {\n                // bumps\n                const float bumpSize = 0.01;\n                h.nrm.y += sin(p.y * 7.12 + sin(p.y * 1.0) * 3.0 ) * (1.0 + 0.7 * sin(p.x * 2.0)) * bumpSize;\n                h.nrm    = normalize(h.nrm);\n            }\n            \n            return;\n        }\n\n\n        t += absDist * gUnderStepFac;\n    }\n}\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 15u\nQ_IMPLEMENTATION\n\nvec3 gSunDir = normalize(vec3(-1.0, 1.0, -1.0));\nvec3 toneSky(in ray_t r) {\n    return v1;\n    return r.rd * 0.5 + 0.5;\n}\n\nvec3 toneFloor(in vec2 p) {\n    if (abs(p.y) < 2.2) {\n        p.x += gT;\n    }\n    p = fract(p * 0.2 - 0.5);\n    float f = length(p * 2.0 - 1.0);\n    return 0.5 + 0.2 * smoothstep(0.9, 0.88, f) * v1;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n        default:\n            return materials[h.mtl].color;\n    }\n}\n\n\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    gRayCount = 0u;\n    gMaxRays = kFullRays ? cMaxRays : 8u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n        \n        \n        hit_t h = hit_t(false, 1e9, v0, vX, mtl_0);\n        h.mtl = mtl_0;\n        rayVsScene(r, h, cMaxMarchSteps);\n        \n        if (!h.hit) {\n            // no hit - escapes to the sky\n            gRGB += r.amt * toneSky(r);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n                        \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            vec3  reflAmt = v1 * schlick  (R0, dot(r.rd, -nrm));            \n            vec3  trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            vec3  diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n\n            if (r.side < 0.0) {\n                // just traveled through media, attenuate !\n                r.amt *= exp(-m.absorption.w * h.t * (1.0 - m.absorption.rgb));\n            }\n\n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n            \n            if (gRayCount >= gMaxRays) {\n                continue;\n            }\n            \n            // diffuse\n\n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n                        \n            if (dot(diffAmt, diffAmt) > cMinRayAmt * cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                \n                float sunDot      = dot(gSunDir, h.nrm);\n                if (sunDot > 0.0) {\n\n                    // cast a diffuse lighting ray.\n                    ray_t dlrRay;\n                    dlrRay.ro         = h.pnt + h.nrm * cSurfEps;\n                    dlrRay.rd         = gSunDir;\n                    dlrRay.amt        = diffAmt * sunDot * tone(r, h);\n                    dlrRay.side       = 1.0;\n                    dlrRay.ior        = 1.0;\n                    dlrRay.DLR        = true;\n                    \n                    if (dot(dlrRay.amt, dlrRay.amt) > cMinRayAmt * cMinRayAmt) {\n                        if (!kShadows) {\n                            // if no shadows, advance the ray to the sky\n                            dlrRay.ro += dlrRay.rd * 1e4;\n                        }\n                        QEnqueue(dlrRay);\n                    }\n                }\n            }\n\n\n            // transmission\n            \n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            \n            if (dot(trnsAmt, trnsAmt) > cMinRayAmt * cMinRayAmt) {\n                if (!r.DLR) {\n                    float eta = r.ior / m.ior;\n                    if (r.side < 0.0) {\n                     //   eta = 1.0 / eta;\n                    }\n                    vec3 trnRayDir = refract(r.rd, nrm, eta);\n                    if (dot(trnRayDir, trnRayDir) < 0.001) {\n                        // total internal reflection.\n                        reflAmt += trnsAmt;\n                    }\n                    else {\n                        // the treatment of \"side\" here is not accounting for\n                        // the possibility of both sides being inside.\n                        // but it looks good !\n                        ray_t trnRay;\n                        trnRay.ro   = h.pnt - nrm * cSurfEps;\n                        trnRay.rd   = trnRayDir;\n                        trnRay.side = -r.side;\n                        trnRay.amt  = trnsAmt;\n                        trnRay.DLR  = false;\n                        trnRay.ior  = m.ior;\n\n                        QEnqueue(trnRay);\n                    }\n                }\n                else {\n                    // is DLR ray: diffuse lighting ray not refracted, reflected, etc.\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = r.rd;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    trnRay.DLR  = true;\n                    trnRay.ior  = 1.0;\n\n                    QEnqueue(trnRay);\n                }\n            }\n\n            // reflection\n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            if (!r.DLR && dot(reflAmt, reflAmt) > cMinRayAmt * cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n                rflRay.DLR  = false;\n                rflRay.ior  = r.ior;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\n\nfloat viewportFromScreen(in float D) {\n    return D * 2.0 / MINRES / gVPZoom;\n}\n\nvec2 viewportFromScreen(in vec2 XY) {\n    return vec2(viewportFromScreen(XY.x - RES.x / 2.0),\n                viewportFromScreen(XY.y - RES.y / 2.0));\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    // modify XY for pixelation station\n    if (kPixelate) {\n        XY = XY - (fract(XY / cPixelation ) - 0.5) * cPixelation;\n    }\n\n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n    \n    vec2 xy = viewportFromScreen(XY);\n    gVPEps  = viewportFromScreen(2.0);\n    gVPLW   = viewportFromScreen(2.0);\n    gT      = iTime * pi * 2.0 / 7.0;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    vec2 mss;\n    if (length(iMouse.xy) < 20.0) {\n        mss.x = gT * 0.1 - ms.x * 6.0 - pi/2.0;\n        mss.y = sin(gT * 0.131 + 10.5) * 0.2 + 0.5;\n    }\n    else {\n        mss.x = -ms.x * pi * 2.3;\n        mss.y =  ms.y;\n    }\n    \n    vec2  camYMinMax = vec2(0.01, 2.0);\n    float theta      = mss.x;\n    float camY       = mix(camYMinMax[1], camYMinMax[0], smoothstep(0.0, 1.0, sqrt(mss.y)));\n    vec3  lookFrom   = vec3(sin(theta), camY, cos(theta)) * gCamDist;\n    vec3  lookTo     = vY * 10.0;\n    \n    vec3  camFw      = normalize(lookTo - lookFrom);\n    vec3  camRt      = normalize(cross(camFw, vY));\n    vec3  camUp      = cross(camRt, camFw);\n    \n    configScene();\n    \n    ray_t r;\n    r.ro    = lookFrom;\n    r.rd    = normalize(camFw + (camRt * xy.x + camUp * xy.y) * gFOVFac);\n    r.amt   = v1;\n    MST mst = map(r.ro);\n    r.side  = sign(mst.dist);\n    r.ior   = mst.dist < cWSEps ? materials[mst.mtl].ior : 1.0;\n    r.DLR   = false;\n    QEnqueue(r);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        gRGB = mix(cCool, cHot, pow(temp, 0.6));\n    }\n\n    RGBA = vec4(gRGB, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi  = 3.14159265359;\nconst vec3  v1  = vec3(1.0);\nconst vec3  v0  = vec3(0.0);\nconst vec3  vX  = vec3(1.0, 0.0, 0.0);\nconst vec3  vY  = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ  = vec3(0.0, 0.0, 1.0);\nconst vec4  v41 = vec4(1.0);\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n    bool  DLR;   // Diffuse Lighting Ray.\n    float ior;   // index of refraction at ro.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n    vec4  absorption;  // transmissive color, density.  eg (0.8, 0.7, 0.1, 30.0)\n};\n\n\n//--------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n//--------------------------------------------------------------------------------\n// famous indices\nconst float ior_air                =  1.0003;\nconst float ior_aerogel            =  1.03;\nconst float ior_ice                =  1.309;\nconst float ior_water              =  1.333;\nconst float ior_quartz             =  1.46;\nconst float ior_borosilicate_glass =  1.5168;\nconst float ior_diamond            =  2.42;\nconst float ior_shiny1             =  4.0;    // ad hoc\nconst float ior_mrr                =  1e2;    // ad hoc\n\n//--------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//--------------------------------------------------------------------------\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n//--------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------\n\nvoid opUnion(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist < cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opMinus(inout float cur, in float new) {\n    cur = -min(new, -cur);\n}\n\nvoid opMinus(inout mapSample_t cur, mapSample_t new) {\n    if (-new.dist > cur.dist) {\n        cur.dist = -new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opInter(inout float cur, in float new) {\n    cur = max(cur, new);\n}\n\nvoid opInter(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist > cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opUnion(inout float cur, float new) {\n    cur = min(cur, new);\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 519, 540, 540, 916], [3116, 3116, 3136, 3136, 3239], [3242, 3242, 3283, 3283, 3371], [3373, 3373, 3393, 3393, 5004], [5006, 5052, 5075, 5075, 5277], [5280, 5280, 5342, 5392, 6191], [6314, 6314, 6340, 6340, 6386], [6388, 6388, 6415, 6415, 6589], [6591, 6591, 6626, 6626, 6830], [6833, 6833, 6849, 6878, 11637], [11640, 11640, 11678, 11678, 11719], [11721, 11721, 11758, 11758, 11873], [11876, 11876, 11919, 11919, 13772]]}
{"id": "DdfcWs", "name": "Last night a DJ saved my life...", "author": "mrange", "description": "CC0: Last night a DJ saved my life...\nPublished this when lug00ber played: Last night a DJ saved my life...\nA slight rework of: https://www.shadertoy.com/view/ctBSRR", "tags": ["2d", "interference"], "likes": 8, "viewed": 203, "published": 3, "date": "1687290100", "time_retrieved": "2024-07-30T17:48:27.604336", "image_code": "// CC0: Last night a DJ saved my life...\n//  Published this when lug00ber played: Last night a DJ saved my life...\n//  A slight rework of: https://www.shadertoy.com/view/ctBSRR\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n\n\nfloat df(vec2 p) {\n  const float m = 0.25;\n  float l = length(p);\n  l = mod(l+(0.5*m), m)-(0.5*m);\n  return abs(l)-(m*0.25);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat lug00ber(vec2 p) {\n  vec2 p0 = p;\n  p0.y = abs(p0.y);\n  p0 -= vec2(-0.705, 0.41);\n  float d0 = length(p0)-0.16;\n  \n  float topy = 0.68;\n  vec2 bp = p-vec2(0.27, -0.8);\n  float d1 = segment(p, vec2(0.72, topy), vec2(0.27, -0.8))-0.06;\n  float d2 = segment(p, vec2(-0.13, topy), vec2(0.33, -0.8))-0.1;\n  float d3 = p.y-(topy-0.066);\n\n  float d4 = box(p-vec2(-0.1, topy), vec2(0.25, 0.03))-0.01;\n  float d5 = box(p-vec2(0.685, topy), vec2(0.19, 0.03))-0.01;\n  float d6 = min(d4, d5);\n  \n  vec2 ax7 = normalize(vec2(vec2(0.72, topy)-vec2(0.27, -0.8)));\n  vec2 nor7 = vec2(ax7.y, -ax7.x);\n  float d7 = dot(p, nor7)+dot(nor7, -vec2(vec2(0.72, topy)))+0.05;\n  \n  d2 = max(d2, d7);\n  float d = d1;\n  d = pmin(d,d2, 0.025);\n  d = max(d, d3);\n  d = pmin(d, d6, 0.1);\n  d = min(d,d0);\n  \n  return d; \n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(vec2 p, float freq) {\n  // Approximate distance to cos\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n\n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n\n  float a = 0.18*freq;\n\n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\n\n\nvec3 overlay(vec3 col, vec2 p) {\n  vec2 p0 = p;\n  float dl = lug00ber(p);\n\n  const float z1 = 0.25;\n  vec2 p1 = p;\n  p1.x += 0.1*TIME;\n  p1 /= z1;\n  float dc = dfcos(p1, 0.5)*z1;\n  dc = abs(dc)- mix(0.025, 0.00, smoothstep(0., 2.0, abs(p.x)));\n  float aa = 4.0/RESOLUTION.y;\n  \n  float d = dl;\n  d = pmax(d, -(dc-0.025), 0.025);\n  d = min(d, dc);\n  \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(1.0, 4.0, TIME);\n  col = mix(col, vec3(0.925), smoothstep(0.0, -aa, d));\n  \n  return col;\n}\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  float tm = TIME*0.25;\n  vec2 op = p;\n  // Random stuff to make the lights move somewhat interesting.\n  vec2 off = 0.25*sin(vec2(0.3, sqrt(0.15))*(tm*0.25));\n  p -= off;\n  p *= ROT(0.5*tm);\n  p += off;\n  vec2 p0 = p+sin(vec2(1.0, sqrt(0.5))*(tm+100.0));\n  vec2 p1 = p+sin(1.2*vec2(1.0, sqrt(0.5))*(tm+200.0));\n  float sm = 0.0666*length(p);\n  float d0 = df(p0);\n  float d1 = df(p1);\n  float d = d0;\n  d = pmax(d, d1, sm);\n  float dd = -d0;\n  dd = pmax(dd, -d1, sm);\n  d =  min(d, dd);\n  const float so = 8.0;\n  const float co = 0.5;\n  vec3 bcol0 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p0)+1.0-TIME))/(so*dot(p0, p0)+0.0001);\n  vec3 bcol1 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p1)+3.0+TIME))/(so*dot(p1, p1)+0.0001);\n  vec3 bcol = (bcol0+bcol1);\n  vec3 col = vec3(0.0);\n  col += 0.005*bcol/(max(dd+0.005, 0.0)+0.0001);\n  col = mix(col, bcol, smoothstep(aa, -aa, d));\n  col -= 0.25*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = overlay(col, op);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 327, 327, 435], [437, 537, 576, 576, 661], [663, 751, 790, 790, 819], [821, 939, 978, 978, 1097], [1099, 1217, 1244, 1244, 1320], [1323, 1323, 1347, 1347, 2120], [2122, 2209, 2231, 2231, 2265], [2267, 2354, 2387, 2420, 2742], [2746, 2746, 2778, 2778, 3237], [3297, 3297, 3327, 3327, 4418], [4420, 4420, 4475, 4475, 4650]]}
{"id": "cdXyDl", "name": "Weird Attractor Fractal", "author": "SnoopethDuckDuck", "description": "Built out of curiosity to accompany this: \nhttps://www.vertexshaderart.com/art/kpxXuKKj3zwRaQ23J\n\nVertex shader moves points to new positions\nFrag shader simulates same movement and accumulates distances for color but keeps pixels fixed in place", "tags": ["fractal", "attractor", "chaos"], "likes": 9, "viewed": 252, "published": 3, "date": "1687283801", "time_retrieved": "2024-07-30T17:48:28.459051", "image_code": "#define pi 3.14159\n#define res iResolution.xy\n#define Dir(a) vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n\n    float d = 0.;\n    const float n = 10.;\n    for (float i = 0.; i < n; i++) {\n        float a = atan(uv.y, uv.x);\n        vec2 dir = 0.1 * sin(2.*a + iTime) * Dir(8.*pi*uv.x) \n                 + 0.1 * cos(2.*a + iTime) * Dir(8.*pi*uv.y);\n        d += length(dir) / (i+1.);\n        uv += dir;\n    }\n    \n    vec3 col = vec3(exp(-12.*d*d));\n    \n    O = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 124, 124, 535]]}
{"id": "mdsyDf", "name": "Bloom.", "author": "TinyTexel", "description": "A bloom demo that allows to mix and match different mip mapping filters for down and up sampling.", "tags": ["filtering", "bloom", "glow", "glare"], "likes": 15, "viewed": 446, "published": 3, "date": "1687280849", "time_retrieved": "2024-07-30T17:48:29.906181", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm/status/1694024936040411509\n\n/*\n   A bloom demo that allows to mix and match different mip mapping filters for down and up sampling.\n   \n   Controls:\n   \n       Space - toggle off/on bloom + post-proc\n       Shift - toggle off/on post-proc\n       Tab   - toggle off/on ui\n       Ctrl  - toggle on/off quantization (useful for examining aliasing (crank up exposure))\n       <-/-> - decrease/increase exposure\n       1,2,3 - change test image\n       \n       Q - use BloomUpKernel4\n       W - use BloomUpKernel4B\n       E - use BloomUpKernel9\n       R - use BloomUpKernel9B\n       \n       A - use BloomDownKernel4\n       S - use BloomDownKernel9\n       D - use BloomDownKernel9B\n       E - use BloomDownKernel13\n       \n       -> filters can also be changed by clicking the arrows ui\n       \n       Common        : filtering + test image code\n       Buffer A/B/C/D: mip chain (down + up-sampling)\n       Image         : last up-sampling step + tonemapping + ui\n       \n \n    \n   Write-up structure:\n  #####################\n   \n       1. General approach\n\n       2. Relative sample alignment between mipmap levels\n\n       3. Buffer boundary handling\n\n       4. Filter kernels\n\n\n\n   1. General approach\n  #####################\n   \n   Typical state-of-the-art bloom implementations achieve their very wide blurs via mipmap filter chains.\n   The mip-mapping/blending approach implemented here looks like this (assuming only 4 mip levels):\n   \n  -> [mip0] -blend-> [result] ->\n      \n       |               \n    1/2x1/2           2x2\n       V               |\n       \n    [mip1A] -blend-> [mip1B]\n      \n       |               \n    1/2x1/2           2x2\n       V               |\n       \n    [mip2A] -blend-> [mip2B]   \n      \n       |               \n    1/2x1/2           2x2\n       V               |\n                       |\n    [mip3A] -----------+\n   \n   '1/2x1/2' and '2x2' denote down-sampling and up-sampling steps, respectively.\n   \n   Since Shadertoy offers only a quite limited number of passes, the implementation here ended up being a bit less straightforward.\n   However, it still emulates the process described above faithfully (i.e. it does not just repeatedly blur a full-res buffer and blend it with itself).\n   \n  (Basically, I had to pack all mip levels starting with mip1 into a single buffer and distribute the mipmapping process over multiple frames. \n   Mip0 is re-computed with a frame offset at the very end. This way the entire image (every mip level) consistently lags a set number of frames behind.\n   An unfortunate consequence of this is that swapping filter kernels or changing the test image takes a couple of frames. And therefore can't really\n   be done while the shader is paused.)\n\n\n   \n   2. Relative sample alignment between mipmap levels\n  ####################################################\n   \n   There are basically two options for the relative sample alignment between two consecutive mip levels ('XX' marks a texel center):\n   \n   \n   StyleA:\n   \n   mip0: ---XX------XX------XX---\n                                               \n   mip1: -----XX----------XX-----              vec2 texcoord_mip1 = (vec2(texel_uv_uint) + 0.5) / texel_count_mip1;\n   \n   \n   StyleB:\n   \n   mip0: ---XX------XX------XX---\n                                               \n   mip1: -------XX--------------XX-------      vec2 texcoord_mip1 = vec2(texel_uv_uint * 2u + 1u) / texel_count_mip0;\n   \n   \n   StyleA evenly distributes the samples of mip1 so that they cover the same space as those of mip0.\n   StyleB, on the other hand, places mip1 samples strictly half way between mip0 samples.\n   \n   The major advantage of StyleB is that it allows the use of discrete kernels with fixed weights for down- and up-sampling.\n   To handle filtering with StyleA correctly one would need to compute a discrete kernel for each target sample individually at runtime.\n   Well, at least if the number of samples at the upper mip level is odd: \n   in the case that there is an even number of samples at the upper mip level both styles produce equivalent results.\n   \n   There is probably little reason not to favor StyleB. \n   At least as long as one does not care about the sample placement sometimes not being symmetric about the center of the buffer. \n   \n   \n   \n   3. Buffer boundary handling\n  #############################\n   \n   The sample distribution of a typical mipmap chain looks like an upside-down pyramid. For mipmaps of tiled textures this works just fine.\n   But for a bloom implementation it means we unnecessarily lose information during down-sampling and have to \n   extrapolate at the buffer edges during up-sampling which produces rather unreliable results.\n   A more elegant way to handle the buffer boundary is to pad each mip level (starting with mip1) with additional boundary samples:\n   \n   BoundaryWidth = 0: (default)\n   \n   mip0:                         -XX--XX--XX--XX--XX--XX--XX--XX-\n                                 \n   mip1:                         ---XX------XX------XX------XX---\n                                 \n   mip2:                         -------XX--------------XX-------\n                                                    \n                                                    \n   BoundaryWidth = 1: (minimal padding)\n\n   mip0:                         -XX--XX--XX--XX--XX--XX--XX--XX-\n                   \n   mip1:                 ---XX------XX------XX------XX------XX------XX---\n           \n   mip2: -------XX--------------XX--------------XX--------------XX--------------XX-------\n                                      \n                                      \n   Setting BoundaryWidth to the radius of the widest filter kernel ensures that texels at the edges of mip0 produce glare patterns that \n   are no different to the ones produces by texels closer to the center of the buffer (ignoring differences due to aliasing).\n   \n   For down-sampling the demo emulates a black borders address mode.\n   \n   \n   \n   4. Filter kernels\n  ###################\n\n   All filter kernels implemented here use hardware bilinear sampling to fetch and blend 4 texture samples at once. \n   The number at the end of each kernel's name denotes the number of bilinear samples used (the number of effective samples is not necessarily 4x as many).\n   \n<  BloomDownKernel4  - 16 samples; has about the same amount of aliasing as BloomDownKernel5; smallest reasonable kernel\n   BloomDownKernel5  - 16 samples; taken from \"Bandwidth-Efficient Rendering\" (Siggraph 2015); BloomDownKernel4 works just as well\n  (BloomDownKernel8  - 24 samples; not really a good tradeoff to lose 12 effective samples for 1 less bilinear sample compared to BloomDownKernel9)\n<  BloomDownKernel9  - 36 samples; pretty much optimal with regard to aliasing\n<  BloomDownKernel9B - 36 samples; improved radial symmetry, but slightly more aliasing when compared to BloomDownKernel9\n<  BloomDownKernel13 - 36 samples; taken from \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014) but with better weights\n   \n>  BloomUpKernel4    - 16 samples; less aliasing than BloomUpKernel4B, but worse radial symmetry\n>  BloomUpKernel4B   - 12 samples; very good approximation of BloomUpKernel8; a bit more aliasing than BloomUpKernel4, but better radial symmetry\n   BloomUpKernel8    - 13 samples; taken from \"Bandwidth-Efficient Rendering\" (Siggraph 2015); BloomUpKernel4B works just as well\n>  BloomUpKernel9    - 36 samples; pretty much optimal with regard to aliasing, but worse radial symmetry than BloomUpKernel4B\n>  BloomUpKernel9B   - 16 samples; taken from \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n                                   more aliasing than BloomUpKernel9 + worse radial symmetry; less ALU though\n   \n   Filters highlighted by an '<' or '>' can be swapped in via the arrows ui (or the respective hot keys; see 'Controls').\n   \n   Useful filter combinations, from expensive to cheap:\n   \n   [1]: BloomDownKernel9 + BloomUpKernel9 : least amount of aliasing     | radial symmetry is okay\n   [2]: BloomDownKernel9 + BloomUpKernel4B: more aliasing than [1]       | good radial symmetry\n   [3]: BloomDownKernel4 + BloomUpKernel9 : more aliasing than [2]       | worse radial symmetry than [1] (but still acceptable)\n   [4]: BloomDownKernel4 + BloomUpKernel4B: a lot more aliasing than [3] | decent radial symmetry\n   \n   Alternatively, one could use different filters for different mip levels. For example, replacing BloomDownKernel9 with BloomDownKernel4 at\n   the first mip level (i.e. when down-sampling the full-res buffer) for [1] and [2] might result in significant performance savings.\n   \n   Using BloomDownKernel9B instead of BloomDownKernel9 improves the radial symmetry only marginally (in exchange for more aliasing).\n   Trying to improve the radial symmetry during up-sampling seems to be more effective. Down-sampling should probably focus more on antialiasing.\n   \n   The cheapest filter combination ([4]) stills works quite well at more moderate exposure levels.\n   \n   \n   A good way to test the filters is to use scene 2,3,4, or 5, crank up the exposure and toggle on the quantization.\n   Any inconsistencies in the iso lines of the glare pattern are usually due to aliasing. \n   Scene 4 is useful to catch bugs resulting from low-precision bilinear sampling (explained here: https://www.shadertoy.com/view/cslczj).\n   Scene 5 makes it easier to compare the differences in the shapes of the glare patterns\n   (pausing the shader does not really work for that since it takes a couple of frames to fully switch filters).\n   \n   \n   Related:\n    \n        visualization of the amplitude response of some of the down-sampling filters used here: \"Bloom Downsampling Filter\" \n        https://www.shadertoy.com/view/cslczj\n       \n        13 samples kernel design: \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n        http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n        \n        source of BloomDownKernel5 + BloomUpKernel8: \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\n        https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_notes.pdf\n        \n        9 samples kernel that tries to match the original 13 samples kernel: \"The Rendering of Inside, High Fidelity, Low Complexity\" (GDC 2016)\n        https://loopit.dk/rendering_inside.pdf#page=17\n        https://twitter.com/pixelmager/status/1691731512004071785\n*/\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\n\n//////////////////////////////////////////////////  Tonemapping  /////////////////////////////////////////////////////\n// ================================================================================================================ //\n\nfloat Pow2Toe(float x, float s, float end)\n{\n    if(x < end)\n    {\n        x *= 1.0 / end;\n        \n        return mix(x, x*x, s) * end; \n    }\n    else\n    {\n        float d = 1.0 + s;\n        \n        return x * d + (end - end * d);\n    }\n}\n\nfloat Reinhard(float x, float s, float start)\n{    \n    if(x <= start) return x;\n \n    float sx = 1.0 / (1.0 - start);\n    float ax = -start * sx;\n    \n    float sy = 1.0 - start;\n    float ay = start;\n    \n    x = x * sx + ax;\n    \n    x += x * x * s;\n    \n    float y = x / (x + 1.0);\n    \n    return y * sy + ay;\n}\n\n// x: [0, inf], s: (-1, 1]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0 * s * x + x*x)) / (1.0 + s);\n}\n\nfloat Bias(float x, float bias)\n{\n    float b = 1.0/bias;\n    \n    return x / ((2.0 - b) * x + b - 1.0);\n}\n\n// https://www.shadertoy.com/view/stsfzM\nvec3 Tonemap_sRGB(vec3 col, float toeStrength, vec2 linSeg, float shoulderStrength, float desatBias)\n{\n    if(col.r <= 0.0 || col.g <= 0.0 || col.b <= 0.0) return vec3(0.0);\n\n    vec3 wL = vec3(0.2126, 0.7152, 0.0722);\n    \n    float L0 = dot(col, wL);\n\n    float L0t = Reinhard(Pow2Toe(L0, toeStrength, linSeg.x), \n                                shoulderStrength, linSeg.y);\n\n    col *= L0t / L0;\n\n\n    float L1 = max(col.r, max(col.g, col.b));\n\n    float L1t = SoftClip(L1, 0.9);\n\n    col *= L1t / L1;\n\n\n    float L2 = dot(col, wL);\n\n    float sat = max(0.0, (L2 - L0t) / (L2 - 1.0));\n    \n    sat = Bias(sat, desatBias);\n    \n    col = mix(col, vec3(1.0), sat);\n\n    return col;\n}\n\n// ================================================================================================================ //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    Time = iTime;\n    Frame = iFrame;\n    \n    ReadState(iChannel1);\n    \n    vec2 uv = floor(uv0);\n    \n    vec3 col = vec3(0.0);\n\n    vec2 tc = uv0 / iResolution.xy;\n    \n    float image = EvalImage(uv0, DelayedTime);\n    \n    float v = mix(Upsample2x2(iChannel2, uv0, 1).a, image, 0.25);\n    v *= 2048.0;\n    v *= exp2(Exposure);\n    \n    col = vec3(v);\n    \n    if(ReadKeyToggle(KEY_SHIFT) == 0.0)\n    {\n        col *= mix(vec3(1.0, 0.05, 0.01), vec3(1.0), 0.04);\n        //col += vec3(0.0, 0.009, 0.015)*1.0;\n\n        col = Tonemap_sRGB(col, 0., vec2(0.18, 0.5), 0.0, 0.5);\n        //col.b = pow(col.b, 0.8); col.gb *= mix(col.gb, vec2(1.0), 0.75);\n    } \n    \n    outCol = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    \n    #if 1\n    if(ReadKeyToggle(KEY_CTRL) == 0.0)\n    {\n        float r2 = fract(dot(uv, vec2(0.7548776662, 0.56984029)));\n\n        outCol.rgb += (r2 - 0.5) * (1.0/256.0);\n    }\n    #endif\n\n    if(ReadKeyToggle(KEY_CTRL) != 0.0)\n    {\n        outCol.rgb = floor(outCol.rgb * 8.0) / 8.0;\n    }\n\n    if(ReadKeyToggle(KEY_SPACE) != 0.0)\n    {\n        outCol.rgb = vec3(pow(image, 1.0/2.2));\n    }\n    \n    if(ReadKeyToggle(KEY_TAB) == 0.0)\n    {\n        vec2 uvI;\n        vec2 ui = EvalUI(uv0, /*out:*/ uvI);\n        \n        outCol.rgb = mix(outCol.rgb, vec3(ui.y) * mix(vec3(0., 0.6, 1.0), vec3(1.0), 0.9), ui.x);\n    }\n    \n}\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    Time = iTime;\n    Frame = iFrame;\n    \n    ReadState(iChannel0);\n    \n    outCol = vec4(0.0);\n    \n    outCol.r = EvalImage(uv0, iTime);\n    outCol.g = Downsample2x2(iChannel0, uv0, 4).r;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 7).g;\n    outCol.a = Upsample2x2(iChannel0, uv0, 3).b;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    ReadState(iChannel2);\n    \n    outCol = vec4(0.0);\n\n    outCol.r = Downsample2x2(iChannel0, uv0, 1).r;\n    outCol.g = Downsample2x2(iChannel0, uv0, 5).g;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 6).b;\n    outCol.a = Upsample2x2(iChannel0, uv0, 3).a;    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    ReadState(iChannel2);\n    \n    outCol = vec4(0.0);\n\n    outCol.r = Downsample2x2(iChannel0, uv0, 2).r;\n    outCol.g = Downsample2x2(iChannel0, uv0, 6).g;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 5).b;\n    outCol.a = Upsample2x2(iChannel0, uv0, 2).a;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\nfloat ReadKey(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 1), 0).x;}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    ReadState(iChannel1);\n    \n    outCol = vec4(0.0);\n\n    outCol.r = Downsample2x2(iChannel0, uv0, 3).r;\n    outCol.g = Downsample2x2(iChannel0, uv0, 7).g;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 4).b;\n    \n    // global state\n    {\n        int x = int(floor(uv0.x));\n        int y = int(floor(uv0.y));\n        \n        float v = texelFetch(iChannel1, ivec2(x, 0), 0).a;\n        \n        if(y == 0)\n        {\n            if(x == 0)\n            {\n                if(ReadKey(KEY_N1) != 0.0) v = 0.0;\n                if(ReadKey(KEY_N2) != 0.0) v = 1.0;\n                if(ReadKey(KEY_N3) != 0.0) v = 2.0;\n                if(ReadKey(KEY_N4) != 0.0) v = 3.0;\n                if(ReadKey(KEY_N5) != 0.0) v = 4.0;\n                if(ReadKey(KEY_N6) != 0.0) v = 5.0;\n            }\n            else if(x == 1)\n            {\n                if(ReadKey(KEY_Q) != 0.0) v = 0.0;\n                if(ReadKey(KEY_W) != 0.0) v = 1.0;\n                if(ReadKey(KEY_E) != 0.0) v = 2.0;\n                if(ReadKey(KEY_R) != 0.0) v = 3.0;\n            }\n            else if(x == 2)\n            {\n                if(ReadKey(KEY_A) != 0.0) v = 0.0;\n                if(ReadKey(KEY_S) != 0.0) v = 1.0;\n                if(ReadKey(KEY_D) != 0.0) v = 2.0;\n                if(ReadKey(KEY_F) != 0.0) v = 3.0;\n            }\n            else if(x == 3)\n            {\n                if(ReadKey(KEY_LEFT ) != 0.0) v -= 1.0;\n                if(ReadKey(KEY_RIGHT) != 0.0) v += 1.0;\n            }\n            \n            if(x == 1 || x == 2)\n            {\n                vec2 uvI;\n                if(EvalUI(iMouse.zw, /*out:*/ uvI).y != 0.0)\n                {\n                    if((1.0 - uvI.y) + 1.0 == float(x))\n                    {\n                        v = uvI.x;\n                    }\n                }\n            }\n        }\n        \n        if(y == 1)\n        {\n            if(x == 0)\n            {\n                v = iTime;\n            }\n            else\n            {\n                v = texelFetch(iChannel1, ivec2(x - 1, 1), 0).a;\n            }\n        }\n        \n        outCol.a = v;\n    }\n}\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    - UTILS + GLOBAL STATE\n    \n    - DOWN-SAMPLING\n    \n    - UP-SAMPLING\n    \n    - RNG\n    \n    - IMAGE\n    \n    - ARROWS UI\n*/\n\n/////////////////////////////////////////////////////////////////////////////////// UTILS + GLOBAL STATE\n//===============================================================================//\n\n#define READ_TEXTURE_COND (ReadKeyToggle(KEY_TAB) != 0.0)\n#define NO_DOWNSAMPLING_COND (ReadKeyToggle(KEY_SPACE) != 0.0)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n#define KEY_G 71\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\nvec2 Resolution;\nfloat Time;\nint Frame;\n\nfloat SceneId;\nfloat UpId;\nfloat DownId;\nfloat Exposure;\nfloat DelayedTime;\n\nvoid ReadState(sampler2D Tex)\n{\n    SceneId  = texelFetch(Tex, ivec2(0, 0), 0).a;\n    UpId     = texelFetch(Tex, ivec2(1, 0), 0).a;\n    DownId   = texelFetch(Tex, ivec2(2, 0), 0).a;\n    Exposure = texelFetch(Tex, ivec2(3, 0), 0).a;\n    \n    DelayedTime = texelFetch(Tex, ivec2(3, 1), 0).a;\n}\n\nconst float BoundaryWidth = 2.0;\n\nbool IsUVinBounds(vec2 uv, vec4 rect)\n{\n    uv -= rect.xy;\n    \n    return uv.x >= 0.0 && uv.x < rect.z && \n           uv.y >= 0.0 && uv.y < rect.w;\n}\n\nvoid GetRects(float n, out vec4 rectA, out vec4 rectB)\n{\n    vec2 res = Resolution.xy;\n    \n    res = ceil(res * 0.5) + BoundaryWidth * 2.0;\n\n    rectA = vec4(0.0, 0.0, Resolution.xy);\n    rectB = vec4(0.0, 0.0, res);\n    \n    float x = 0.0;\n    float y = res.y;\n    \n    for(float i = 1.0; i < n; ++i)\n    {\n        rectA = rectB;\n\n        res = ceil(res * 0.5) + BoundaryWidth * 2.0;\n\n        rectB = vec4(x, y, res);\n        \n        x += res.x;\n    }\n}\n\nfloat EvalImage(vec2 uv, int frameOff);\n\n\n\nvec4 SrcRect;\nvec4 Read(sampler2D Tex, vec2 tc)\n{\n#if 1\n    // read from rect region (mip chain is packed in single buffer (except mip0))\n    vec2 uv = tc * Resolution;\n    \n    vec2 m = clamp01(SrcRect.zw*0.5+0.5 - abs(uv - SrcRect.xy - 0.5 * SrcRect.zw));\n    \n    tc = clamp(uv, SrcRect.xy + 0.5, SrcRect.xy + SrcRect.zw - 0.5) / Resolution;\n    \n#else\n\n    vec2 m = clamp01(Resolution*0.5+0.5 - abs(tc-0.5) * Resolution);\n    \n#endif    \n\n    vec4 col = textureLod(Tex, tc, 0.0);\n        \n    return col * (m.x*m.y);// emulate black border address mode\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// UTILS + GLOBAL STATE\n\n\n/////////////////////////////////////////////////////////////////////////////////// DOWN-SAMPLING\n//===============================================================================//\n\n// 4x4 samples downsampling kernel implemented via 4 bilinear samples\nvec4 BloomDownKernel4(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    // optimal stop band\n    // float la = 1.0/4.0 + 1.0/16.0 + 1.0/32.0;//0.34375 ~ 0.3533943809268811\n    \n    // pascal kernel; more pleasant aliasing (matches BloomDownKernel5 well)\n    float la = 1.0/4.0;\n    \n\tvec2 o = (0.5 + la) * RcpSrcTexRes;\n    \n\tvec4 c = vec4(0.0);\n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * o) * 0.25;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * o) * 0.25;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * o) * 0.25;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * o) * 0.25;\n    \n    return c;\n}\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\n// works about as well as BloomDownKernel4\nvec4 BloomDownKernel5(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    vec2 o = RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n\n\tc += Read(Tex, tc) * 0.5;\n\n\tc += Read(Tex, tc + vec2(-1.0, -1.0) * o) * 0.125;\n\tc += Read(Tex, tc + vec2( 1.0,  1.0) * o) * 0.125;\n\tc += Read(Tex, tc + vec2( 1.0, -1.0) * o) * 0.125;\n\tc += Read(Tex, tc + vec2(-1.0,  1.0) * o) * 0.125;\n    \n    return c;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples (meh)\nvec4 BloomDownKernel8(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    float a  = 0.13433339843769723; \n    float la = 1.0/2.0 + 1.0/4.0 + 1.0/8.0 + 1.0/32.0;// ~ 0.91081327364113440;\n    float lb = 1.0/4.0 + 1.0/8.0;// ~ 0.37269896061302266;\n\n\tvec2 oa = (1.5 + la) * RcpSrcTexRes;\n\tvec2 ob = (0.5 + lb) * RcpSrcTexRes;\n    \n\tvec4 ca = vec4(0.0);\n\tca += Read(Tex, tc + vec2(-1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0,-1.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0, 1.0) * oa);\n    \n    vec4 cb = vec4(0.0);\n\tcb += Read(Tex, tc + vec2(-1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2(-1.0, 1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0, 1.0) * ob);\n    \n    return cb * (0.25 - a * 0.25) + \n           ca * (       a * 0.25);\n}\n\n// 36 samples downsampling kernel implemented via 9 bilinear samples \n// pretty much optimal with regard to aliasing\nvec4 BloomDownKernel9(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    // optimal stop band but o is chosen so as to keep frequency response \n    // symmetric despite lower-precision hardware bilinear filtering\n    float a = 7.49862 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + (0.25+1.0/64.0);\n\n    vec2 off = o * RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n    \n    c += Read(Tex, tc) * (b * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * off) * (a * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * off) * (a * a);    \n\n\treturn c;\n}\n\n// non-separable variant; improved radial symmetry (but more aliasing)\nvec4 BloomDownKernel9B(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n#if 1\n    // radial symmetry\n    float w0 = 0.302001;\n\tfloat a  = 0.127963;\n\tfloat b  = 0.0465365;\n\tfloat oa = 1.5 + 0.25;// ~ 0.250795\n\tfloat ob = 1.5 + (0.125+1.0/16.0);       \n#else\n    // params by Mikkel Gjoel; half Nyquist = 0 (along x & y)\n    // (https://twitter.com/pixelmager/status/1691731512004071785)\n    float w0 = 4.0/16.0;\n\tfloat a  = 2.0/16.0;\n\tfloat b  = 1.0/16.0;\n\tfloat oa = 1.5 + 0.25;\n\tfloat ob = 1.5 + 0.2052; //(1.0 - 0.7948);\n#endif\n\n    vec2 oa2 = oa * RcpSrcTexRes;\n    vec2 ob2 = ob * RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n    \n    c += Read(Tex, tc) * w0;\n\n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * oa2) * a;\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * ob2) * b;\n\n\treturn c;\n}\n\n// \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\nvec4 BloomDownKernel13(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n\n#if 0\n    // radial symmetry\n    float w0 = 0.144622;\n    float wa = 0.105596;\n    float wb = 0.0822943;\n    float wc = 0.0259547;\n#elif 1\n    // optimal stop band\n    float w0 = 0.173633;\n    float wa = 0.0991668;\n    float wb = 0.0744867;\n    float wc = 0.0329382;\n#else\n    // original weights; half Nyquist = 0 \n    float w0 = 4.0/32.0;// 0.125\n    float wa = 4.0/32.0;// 0.125\n    float wb = 2.0/32.0;// 0.0625\n    float wc = 1.0/32.0;// 0.03125\n#endif\n\n    vec2 off = RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n\n\tc += Read(Tex, tc) * w0;\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * off) * wa;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * off) * wa;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * off) * wa;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * off) * wa;\n    \n\tc += Read(Tex, tc + vec2( 2.0, 0.0) * off) * wb;\n\tc += Read(Tex, tc + vec2(-2.0, 0.0) * off) * wb;\n\tc += Read(Tex, tc + vec2( 0.0, 2.0) * off) * wb;\n\tc += Read(Tex, tc + vec2( 0.0,-2.0) * off) * wb;\n    \n\tc += Read(Tex, tc + vec2( 2.0, 2.0) * off) * wc;\n\tc += Read(Tex, tc + vec2(-2.0, 2.0) * off) * wc;\n\tc += Read(Tex, tc + vec2( 2.0,-2.0) * off) * wc;\n\tc += Read(Tex, tc + vec2(-2.0,-2.0) * off) * wc;\n\n    return c;\n}\n\nvec4 Downsample2x2(sampler2D Tex, vec2 uv0, int n)\n{\n    vec4 col = textureLod(Tex, uv0 / Resolution.xy, 0.0);\n    \n    if(n == 1) col = vec4(0.0);\n    \n    vec4 rectA, rectB;\n    GetRects(float(n), rectA, rectB);\n    \n    if(IsUVinBounds(uv0, rectB))\n    {\n        SrcRect = rectA;\n    \n        vec2 uv = floor(uv0) - rectB.xy + rectA.xy * 0.5;\n        \n        if(DownId == 0.0) col = BloomDownKernel4 (Tex, uv);\n        if(DownId == 1.0) col = BloomDownKernel9 (Tex, uv);\n        if(DownId == 2.0) col = BloomDownKernel9B(Tex, uv);\n        if(DownId == 3.0) col = BloomDownKernel13(Tex, uv);\n    }\n    \n    return col;\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// DOWN-SAMPLING\n\n\n/////////////////////////////////////////////////////////////////////////////////// UP-SAMPLING\n//===============================================================================//\n\nvec4 BloomUpKernel4(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n\n    // optimal stop-band\n    float lw = 0.357386;\n    float la = 25.0/32.0;// 0.78125  ~ 0.779627; \n    float lb =  3.0/64.0;// 0.046875 ~ 0.0493871;\n     \n    vec2 l = vec2(-1.5 + la, 0.5 + lb);\n    \n    vec2 lx = uvF.x == 0.0 ? l.xy : -l.yx;\n    vec2 ly = uvF.y == 0.0 ? l.xy : -l.yx;\n    \n    lx *= RcpSrcTexRes.xx;\n    ly *= RcpSrcTexRes.yy;\n    \n    vec4 c00 = Read(Tex, tc + vec2(lx.x, ly.x));\n    vec4 c10 = Read(Tex, tc + vec2(lx.y, ly.x));\n    vec4 c01 = Read(Tex, tc + vec2(lx.x, ly.y));\n    vec4 c11 = Read(Tex, tc + vec2(lx.y, ly.y));\n    \n    vec2 w = abs(uvF * 2.0 - lw);\n    \n    vec4 cx0 = c00 * (1.0 - w.x) + (c10 * w.x);\n    vec4 cx1 = c01 * (1.0 - w.x) + (c11 * w.x);\n    \n    vec4 cxy = cx0 * (1.0 - w.y) + (cx1 * w.y);\n    \n    return cxy;\n}\n\n// very good approximation of BloomUpKernel8; good radial symmetry\n// but more aliasing than BloomUpKernel4\nvec4 BloomUpKernel4B(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n    \n   #if 1\n    vec2 l00 = vec2(11.0/32.0, 17.0/32.0);// 0.34375  ~ 0.347209 \n    vec2 l10 = vec2( 7.0/64.0, 11.0/32.0);// 0.109375 ~ 0.109840 \n    vec2 l01 = vec2(11.0/32.0,  7.0/64.0);// 0.34375  ~ 0.334045 \n    vec2 l11 = vec2(17.0/32.0, 11.0/32.0);// 0.53125  ~ 0.526425 \n   #else\n    vec2 l00 = vec2(0.347209, 0.526425);\n    vec2 l10 = vec2(0.109840, 0.334045);\n    vec2 l01 = vec2(0.334045, 0.109840);\n    vec2 l11 = vec2(0.526425, 0.347209);\n   #endif\n    \n    vec4 w = vec4(0.288971, 0.211029, 0.211029, 0.288971);\n    \n    bool flipX = uvF.x != 0.0;\n    bool flipY = uvF.y != 0.0;\n    \n    if(flipX)\n    {\n        vec2 tmp = l11; l11 = l10; l10 = tmp;\n        \n        l00.x = 1.0 - l00.x;\n        l10.x = 1.0 - l10.x;\n        l01.x = 1.0 - l01.x;\n        l11.x = 1.0 - l11.x;\n        \n        w = vec4(w.x, w.w, w.z, w.y);\n    }\n    \n    if(flipY)\n    {\n        vec2 tmp = l00; l00 = l01; l01 = tmp;\n        \n        l00.y = 1.0 - l00.y;\n        l10.y = 1.0 - l10.y;\n        l01.y = 1.0 - l01.y;\n        l11.y = 1.0 - l11.y;\n        \n        w = vec4(w.z, w.y, w.x, w.w);\n    }\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + (vec2(-0.5, -1.5) + l00) * RcpSrcTexRes) * w.x;\n    col += Read(Tex, tc + (vec2( 0.5, -0.5) + l10) * RcpSrcTexRes) * w.y;\n    col += Read(Tex, tc + (vec2(-0.5,  0.5) + l01) * RcpSrcTexRes) * w.z;\n    col += Read(Tex, tc + (vec2(-1.5, -0.5) + l11) * RcpSrcTexRes) * w.w;\n    \n    return col;\n}\n\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\n// good radial symmetry\nvec4 BloomUpKernel8(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.25;\n    uv += BoundaryWidth;\n    \n    vec2 tc = uv * RcpSrcTexRes.xy;\n    \n    float a = 1.0/12.0;\n    float b = 2.0/12.0;\n    \n    vec2 s = RcpSrcTexRes;    \n    vec4 col = vec4(0.0);\n    \n    col += a * Read(Tex, tc + vec2( 1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2(-1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0, 1.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0,-1.0) * s);\n    \n    col += b * Read(Tex, tc + vec2( 0.5, 0.5) * s);\n    col += b * Read(Tex, tc + vec2(-0.5, 0.5) * s);\n    col += b * Read(Tex, tc + vec2( 0.5,-0.5) * s);\n    col += b * Read(Tex, tc + vec2(-0.5,-0.5) * s);\n    \n    return col;\n}\n\n// low aliasing; radial symmetry worse than BloomUpKernel8/BloomUpKernel4B\nvec4 BloomUpKernel9(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n\n    // optimal stop-band\n    float la = 57.0/64.0;// 0.890625 ~ 0.897872\n    float lb =  7.0/16.0;// 0.4375   ~ 0.438573\n    float lc =  1.0/64.0;// 0.015625 ~ 0.0194411\n    \n    float wa = 0.206516;\n    float wb = 0.712722;\n    float wc = 0.0807621;\n\n    vec3 l = vec3(-2.5 + la, -0.5 + lb, 1.5 + lc);\n    \n    vec3 lx = uvF.x == 0.0 ? l.xyz : -l.zyx;\n    vec3 ly = uvF.y == 0.0 ? l.xyz : -l.zyx;\n    \n    vec3 wx = vec3(uvF.x == 0.0 ? wa : wc, wb, uvF.x == 0.0 ? wc : wa);\n    vec3 wy = vec3(uvF.y == 0.0 ? wa : wc, wb, uvF.y == 0.0 ? wc : wa);\n    \n    lx *= RcpSrcTexRes.xxx;\n    ly *= RcpSrcTexRes.yyy;\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + vec2(lx.x, ly.x)) * (wx.x * wy.x);\n    col += Read(Tex, tc + vec2(lx.y, ly.x)) * (wx.y * wy.x);\n    col += Read(Tex, tc + vec2(lx.z, ly.x)) * (wx.z * wy.x);\n    \n    col += Read(Tex, tc + vec2(lx.x, ly.y)) * (wx.x * wy.y);\n    col += Read(Tex, tc + vec2(lx.y, ly.y)) * (wx.y * wy.y);\n    col += Read(Tex, tc + vec2(lx.z, ly.y)) * (wx.z * wy.y);\n    \n    col += Read(Tex, tc + vec2(lx.x, ly.z)) * (wx.x * wy.z);\n    col += Read(Tex, tc + vec2(lx.y, ly.z)) * (wx.y * wy.z);\n    col += Read(Tex, tc + vec2(lx.z, ly.z)) * (wx.z * wy.z);\n    \n    return col;\n}\n\n// \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n//  more aliasing than BloomUpKernel9 + worse radial symmetry; less ALU though\nvec4 BloomUpKernel9B(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.25;\n    uv += BoundaryWidth;\n    \n    vec2 tc = uv * RcpSrcTexRes.xy;\n    \n    float a = 2.0/16.0;\n    float b = 1.0/16.0;\n    float c = 4.0/16.0;\n    \n    vec2 s = RcpSrcTexRes;\n    \n    vec4 col = vec4(0.0);\n    \n    col += a * Read(Tex, tc + vec2( 1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2(-1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0, 1.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0,-1.0) * s);\n    col += b * Read(Tex, tc + vec2( 1.0, 1.0) * s);\n    col += b * Read(Tex, tc + vec2(-1.0, 1.0) * s);\n    col += b * Read(Tex, tc + vec2( 1.0,-1.0) * s);\n    col += b * Read(Tex, tc + vec2(-1.0,-1.0) * s);\n    col += c * Read(Tex, tc + vec2( 0.0, 0.0) * s);\n    \n    return col;\n}\n\nvec4 Upsample2x2(sampler2D Tex, vec2 uv0, int n)\n{\n    vec4 col = textureLod(Tex, uv0 / Resolution.xy, 0.0);\n    \n    vec4 rectA, rectB;\n    GetRects(float(n), rectA, rectB);\n    \n    if(IsUVinBounds(uv0, rectA))\n    {\n        SrcRect = rectB;\n    \n        vec2 uv = floor(uv0) - rectA.xy + rectB.xy * 2.0;\n        \n        vec4 col2 = col;\n        \n        if(UpId == 0.0) col2 = BloomUpKernel4 (Tex, uv);\n        if(UpId == 1.0) col2 = BloomUpKernel4B(Tex, uv);\n        if(UpId == 2.0) col2 = BloomUpKernel9 (Tex, uv);\n        if(UpId == 3.0) col2 = BloomUpKernel9B(Tex, uv);\n        \n        //col = mix(col, col2, exp2(-float(n - 1) * 0.125*0.5));\n        col = n == 1 ? col2 : mix(col2, col, 0.1);\n    }\n    \n    return col;\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// UP-SAMPLING\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. ONeill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(inout uint state  ) { return pcg(state); }\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4  Hash01x4(inout uint state) { return Float01(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash01x3(inout uint state) { return Float01(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash01x2(inout uint state) { return Float01(uvec2(pcg(state), pcg(state))); }\nfloat Hash01  (inout uint state) { return Float01(      pcg(state)); }\n\nvec4  Hash11x4(inout uint state) { return Float11(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash11x3(inout uint state) { return Float11(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash11x2(inout uint state) { return Float11(uvec2(pcg(state), pcg(state))); }\nfloat Hash11  (inout uint state) { return Float11(      pcg(state)); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n\n\n/////////////////////////////////////////////////////////////////////////////////// IMAGE\n//===============================================================================//\n\n// https://www.shadertoy.com/view/cdjBzc\nfloat disk_mb_aa(vec2 tc, float r, float s, vec2 a, vec2 b)\n{\n    vec2 vec = b - a;\n    \n    tc -= a;\n    \n    float tt = dot(vec, vec);\n        \n    float rcptt = 1.0 / tt;\n    \n    vec2 dirX = vec * rcptt;\n    \n    vec2 dirY = vec2(-dirX.y, dirX.x);\n        \n    float x = dot(tc, dirX);\n    float y = dot(tc, dirY);\n    \n    float r0 = sqrt(max(0.0, r*r * rcptt - y*y));\n    \n    float u = r0 + 0.5;\n    \n    float v = clamp(u - abs(-x - r0 + u), 0.0, min(2.0 * r0, 1.0));\n    \n    if(tt == 0.0) v = dot(tc, tc) < r*r ? 1.0 : 0.0;\n    \n    // aa\n    {\n        vec2 p = vec * (tt == 0.0 ? 0.0 : clamp(x, 0.0, 1.0));\n\n        float l = length(tc - p);\n\n        float m = clamp((r - l) * s * 0.5, 0.0, 1.0);\n        //m = m > 0.5 ? 1.0 : 0.0;\n        v *= m*m*(3.0-2.0*m);\n    }\n    \n    return v;\n}\n\nfloat EvalImage0B(vec2 uv, float ang0, float speed, vec2 rr, uint seed, float time)\n{\n    uv = cmul(uv, cossin(ang0));\n    \n    float t = time * 60.0;\n    \n    uv.x -= t * speed;\n\n    float s = 128.0;\n    \n    uv /= s;\n    \n    uv += Hash11x2(vec2(1.0, 2.0), seed);\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    vec4 h = Hash11x4(uvI, seed);\n    vec4 h2 = Hash11x4(uvI, seed ^ 1426236u);\n    \n    vec2 uv2 = (uvF - 0.5);\n    \n    float rs = rr.y / s;\n    float u = 0.5 - rs;\n    \n    float ang = h.x * Pi;\n    vec2 dir = vec2(cos(ang), sin(ang));\n    float o = 1.0;// h.y;\n    \n    vec2 p = vec2(0.0);\n    \n    p += dir * vec2(0.0, (u)*(1.0-abs(o)));\n    \n    vec2 p2 = p;\n    \n    p.x += sin(t * 0.005 + Pi * h2.z) * (u);//TODO speed\n    p.y += sin(t * 0.01  + Pi * h.z) * (u * 0.5 * o);\n    p.y += sin(t * 0.001 + Pi * h.w) * (u * 0.5 * o);\n\n    float to = 1.5;\n    float t2 = t - to;\n    p2.x += sin(t2 * 0.005 + Pi * h2.z) * (u);//TODO speed\n    p2.y += sin(t2 * 0.01  + Pi * h.z) * (u * 0.5 * o);\n    p2.y += sin(t2 * 0.001 + Pi * h.w) * (u * 0.5 * o);\n\n    p2.x -= speed / s * to;\n    p2.x = max(-0.5+rs, p2.x);\n\n    float z = 0.0;\n    z += cos(t * 0.01  + Pi * h.z) * (0.5*o);\n    z += cos(t * 0.001 + Pi * h.w) * (0.5*o);\n    \n    float r = mix(rr.x, rr.y, pow(z*0.5+0.5,2.0));\n    \n    float v = disk_mb_aa(uv2, r/s, s, p, p2);\n    \n    return v * mix(0.125, 1.0, sin(t * 0.02 + Pi * h2.x)*0.5+0.5)/(r*r*r*r);\n}\n\nfloat EvalImage0A(vec2 uv, float time)\n{\n    float a = 0.05;\n    \n    float v = 0.0;\n    v += EvalImage0B(uv, (a +  0.01) * Pi, 4.7, vec2(1.5, 4.0), 325852u, time)*1.0;\n    v += EvalImage0B(uv, (a + -0.01) * Pi, 3.9, vec2(4.0, 8.0), 152678u, time)*0.15;\n    v += EvalImage0B(uv, (a + -0.03) * Pi, 3.1, vec2(8.0, 16.0), 3457267u, time)*0.125;\n    \n    return v;\n}\n\nfloat EvalImage0(vec2 uv, float time)\n{\n    float fo = float(time);\n    \n#if 0\n    float v = 0.0;\n    float count = 8.0;\n    float wa = 0.0;\n    for(float i = 0.0; i < count; ++i)\n    {\n        float w = 1.0 - i/(count);\n        //w *= w;\n        w = 1.0;\n        \n        v += EvalImage0A(uv, fo - i/(count)*1.5) * w;\n        wa += w;\n    }\n    return v / wa;\n#else\n    return EvalImage0A(uv, time);\n#endif\n}\n\nfloat EvalImage1(vec2 uv, float time, float r)\n{\n    vec2 uvr = Resolution * 0.5 + 0.;\n\n    float t = time * 1.0;\n\n    uvr += vec2(cos(t), sin(t)) * floor(Resolution.y*0.5+0.0) * vec2(1.0, 1.0) * r;\n\n    // aa\n    if(false)\n    {\n        float r = 2.5;\n        \n        float l = length(uv - uvr);\n\n        float m = clamp((r - l) * 1.0 * 0.125, 0.0, 1.0);\n        m = 1.0-m;\n        m*=m;\n        m*=m;\n        m = 1.0-m;\n        \n        return m*m*(3.0-2.0*m);\n    }\n    \n    uvr = floor(uvr) + 0.5;\n    \n    return uv.x == uvr.x && uv.y == uvr.y ? 1.0 : 0.0;\n\n    return 0.0;\n}\n\nfloat EvalImage1b(vec2 uv, float time)\n{\n    vec2 uvr = Resolution * 0.5 + 0.;\n\n    float t = time * 2.0;\n\n    float t0 = floor(fract(t) * 4.0);\n    \n    float x, y;\n    \n    if(t0 < 2.0)\n    {\n        x = t0;\n        y = 0.0;\n    }\n    else\n    {\n        x = 3.0 - t0;\n        y = 1.0;\n    }\n\n    uvr += vec2(x, y);\n\n    uvr = floor(uvr) + 0.5;\n    \n    return uv.x == uvr.x && uv.y == uvr.y ? 1.0 : 0.0;\n\n    return 0.0;\n}\n\nfloat EvalImage2(vec2 uv, float time)\n{\n    vec2 res = Resolution;\n    vec2 o = floor(Resolution * (sin(time * 0.5) * 0.5 + 0.5));\n    if(uv.x == o.x + 0.5                  && uv.y == 0.5        ) return 1.0;\n    if(uv.x == (Resolution.x - o.x) - 0.5 && uv.y == res.y - 0.5) return 1.0;\n    if(uv.y == (Resolution.y - o.y) - 0.5 && uv.x == 0.5        ) return 1.0;\n    if(uv.y == o.y + 0.5                  && uv.x == res.x - 0.5) return 1.0;\n    \n    return 0.0;\n}\n\nfloat EvalImage(vec2 uv, float time)\n{\n    if(SceneId == 0.0) return EvalImage0(uv, time);\n    if(SceneId == 1.0) return EvalImage1(uv, time, 1.);\n    if(SceneId == 2.0) return EvalImage1(uv, time, 0.25);\n    if(SceneId == 3.0) return EvalImage1b(uv, time);\n    if(SceneId == 4.0) return EvalImage1(uv, time, 0.0);\n    if(SceneId == 5.0) return EvalImage2(uv, time);\n    \n    return 0.0;\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// IMAGE\n\n\n/////////////////////////////////////////////////////////////////////////////////// ARROWS UI\n//===============================================================================//\n\nfloat tri0(vec2 tc, float r, float r2)\n{\n    float v = -tc.y;\n    \n    float ang = Pi * 0.1666;\n    vec2 dir = vec2(cos(ang), sin(ang));\n    \n    v = max(v, dot(tc, dir));\n    v = max(v, dot(tc, vec2(-dir.x, dir.y)));\n    \n    float m = clamp((r - v)  * 0.5, 0.0, 1.0);\n     m *= clamp(-(r2-1.5 - v)  * 0.5, 0.0, 1.0);\n\n    v = m*m*(3.0-2.0*m); \n    \n    return v;\n}\n\nfloat tri(vec2 tc, float r, float r2)\n{\n    return tri0(tc, r, r2) * tri0(vec2(tc.x, -tc.y), r * 1.4, r2);\n}\n\nvec2 EvalUI(vec2 uv0, out vec2 uvI)\n{\n    vec2 s = vec2(29.0, 36.0);\n\n    vec2 uv = uv0;\n    uv.x -= s.x * 0.15;\n    uv.y += s.y * 0.15;\n\n         uvI = floor(uv / s);\n    vec2 uvF = uv - uvI * s;\n\n    vec2 tc = uvF-s*0.5;\n    if(uvI.y == 0.0) tc.y = -tc.y;\n    tc.y += s.y * 0.2;\n\n    float k = 0.5;\n    if(uvI.y == 0.0)\n    {\n        if(uvI.x == DownId) k = 0.875;\n    }\n    else\n    {\n        if(uvI.x == UpId) k = 0.875;\n    }\n\n    float v = tri(tc, s.y*0.25, k != 0.875 ? s.y*0.15 : s.y*0.0);\n\n    if(uvI.y > 1.0 || uvI.x < 0.0 || uvI.x > 3.0) { v = 0.0; k = 0.0; }\n    //if(uvI.y == 1.0 && (uvI.x == 3.0)) { v = 0.0; k = 0.0; }// mask out unused up kernels\n\n    return vec2(v, k);\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// ARROWS UI\n\n\n\n/*\n\n// first attempt at approx BloomUpKernel8, 16 effective samples, but not nearly as good as BloomUpKernel4B\nvec4 BloomUpKernel4B0(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n    \n    vec2 l00 = vec2(0.7171050, 0.7171050);\n    vec2 l10 = vec2(0.0713251, 0.7944620);\n    vec2 l01 = vec2(0.7944620, 0.0713251);\n    vec2 l11 = vec2(0.0329773, 0.0329773);\n    \n    vec4 w = vec4(1.39257, 0.85375, 0.85375, 0.474184);\n    w /= w.x + w.y + w.z + w.w;\n    \n    bool flipX = uvF.x != 0.0;\n    bool flipY = uvF.y != 0.0;\n    \n    if(flipX)\n    {\n        vec2 tmp;\n        \n        tmp = l00; l00 = l10; l10 = tmp;\n        tmp = l01; l01 = l11; l11 = tmp;\n        \n        l00.x = 1.0 - l00.x;\n        l10.x = 1.0 - l10.x;\n        l01.x = 1.0 - l01.x;\n        l11.x = 1.0 - l11.x;\n        \n        w = vec4(w.y, w.x, w.w, w.z);\n    }\n    \n    if(flipY)\n    {\n        vec2 tmp;\n        \n        tmp = l00; l00 = l01; l01 = tmp;\n        tmp = l10; l10 = l11; l11 = tmp;\n        \n        l00.y = 1.0 - l00.y;\n        l10.y = 1.0 - l10.y;\n        l01.y = 1.0 - l01.y;\n        l11.y = 1.0 - l11.y;\n        \n        w = vec4(w.z, w.w, w.x, w.y);\n    }\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + (vec2(-1.5, -1.5) + l00) * RcpSrcTexRes) * w.x;\n    col += Read(Tex, tc + (vec2( 0.5, -1.5) + l10) * RcpSrcTexRes) * w.y;\n    col += Read(Tex, tc + (vec2(-1.5,  0.5) + l01) * RcpSrcTexRes) * w.z;\n    col += Read(Tex, tc + (vec2( 0.5,  0.5) + l11) * RcpSrcTexRes) * w.w;\n    \n    return col;\n}\n\n\n// very slight improvement of BloomUpKernel4B; not worth it\nvec4 BloomUpKernel5(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n    \n    vec2 l00 = vec2(0.348324, 0.467528);\n    vec2 l10 = vec2(0.164815, 0.265081);\n    vec2 l01 = vec2(0.264857, 0.164846);\n    vec2 l11 = vec2(0.468550, 0.348326);\n    \n    vec2 lc  = vec2(0.557242, 0.556469);\n    \n    vec4 w = vec4(1.34843, 0.713947, 0.714223, 1.35102);\n    float wc = 1.10538;\n    float wsum = w.x + w.y + w.z + w.w + wc;\n    \n    w  /= wsum;\n    wc /= wsum;\n    \n    \n    bool flipX = uvF.x != 0.0;\n    bool flipY = uvF.y != 0.0;\n    \n    if(flipX)\n    {\n        vec2 tmp;\n        \n        tmp = l11; l11 = l10; l10 = tmp;\n        \n        l00.x = 1.0 - l00.x;\n        l10.x = 1.0 - l10.x;\n        l01.x = 1.0 - l01.x;\n        l11.x = 1.0 - l11.x;\n        lc.x  = 1.0 - lc.x;\n        \n        w = vec4(w.x, w.w, w.z, w.y);\n    }\n    \n    if(flipY)\n    {\n        vec2 tmp;\n        \n        tmp = l00; l00 = l01; l01 = tmp;\n        \n        l00.y = 1.0 - l00.y;\n        l10.y = 1.0 - l10.y;\n        l01.y = 1.0 - l01.y;\n        l11.y = 1.0 - l11.y;\n        lc.y  = 1.0 - lc.y;\n        \n        w = vec4(w.z, w.y, w.x, w.w);\n    }\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + (vec2(-0.5, -1.5) + l00) * RcpSrcTexRes) * w.x;\n    col += Read(Tex, tc + (vec2( 0.5, -0.5) + l10) * RcpSrcTexRes) * w.y;\n    col += Read(Tex, tc + (vec2(-0.5,  0.5) + l01) * RcpSrcTexRes) * w.z;\n    col += Read(Tex, tc + (vec2(-1.5, -0.5) + l11) * RcpSrcTexRes) * w.w;\n    \n    col += Read(Tex, tc + (vec2(-0.5, -0.5) + lc ) * RcpSrcTexRes ) * wc;\n    \n    return col;\n}\n\n\n#if 0\nvec3 ReadImage(vec2 tc)\n{\n    vec2 uv = tc * Resolution;\n    \n    uv -= 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    uvI += 0.5;\n    \n    return mix(mix(EvalImage(uvI + vec2(0.0, 0.0)), EvalImage(uvI + vec2(1.0, 0.0)), uvF.x),\n               mix(EvalImage(uvI + vec2(0.0, 1.0)), EvalImage(uvI + vec2(1.0, 1.0)), uvF.x), uvF.y);\n}\n#endif\n\nvec4 BloomUpKernel4(sampler2D Tex, vec2 uv0)\n{\n    vec2 uv = floor(uv0) * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    // optimal stop-band\n    float la = 0.779627; \n    float lb = 0.0493871;\n    float ll = 0.357386;\n    \n    #if 0\n    // b-spline\n    la = 0.896947;\n    lb = 0.00819672;\n    ll = 0.317708;\n    #endif\n    \n    #if 0\n    // stop-band 2\n    la = 0.598347;\n    lb = 0.129794;\n    ll = 0.364298;\n    #endif\n    \n    #if 0\n    // radial symmetry\n    la = 0.91466;\n    lb = 0.00786767;\n    ll = 0.293837;\n    #endif\n        \n    vec2 ln = vec2(-1.5 + la, 0.5 + lb);\n    vec2 lu = vec2(-0.5 - lb, 1.5 - la);\n    \n    vec2 lx = uvF.x == 0.0 ? ln : lu;\n    vec2 ly = uvF.y == 0.0 ? ln : lu;\n    \n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n    \n    uvI *= RcpSrcTexRes.xy;\n    lx  *= RcpSrcTexRes.xx;\n    ly  *= RcpSrcTexRes.yy;\n    \n    vec4 c00 = Read(Tex, uvI + vec2(lx.x, ly.x));\n    vec4 c10 = Read(Tex, uvI + vec2(lx.y, ly.x));\n    vec4 c01 = Read(Tex, uvI + vec2(lx.x, ly.y));\n    vec4 c11 = Read(Tex, uvI + vec2(lx.y, ly.y));\n    \n    vec2 w = abs(uvF * 2.0 - ll);\n    \n    vec4 cx0 = c00 * (1.0 - w.x) + (c10 * w.x);\n    vec4 cx1 = c01 * (1.0 - w.x) + (c11 * w.x);\n    \n    vec4 cxy = cx0 * (1.0 - w.y) + (cx1 * w.y);\n    \n    return cxy;\n}\n\nvec4 BloomUpKernel9(sampler2D Tex, vec2 uv0)\n{\n    vec2 uv = floor(uv0) * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    // optimal stop-band\n    float la = 0.897872; \n    float lb = 0.438573;\n    float lc = 0.0194411;\n    \n    float wa = 0.206516;\n    float wb = 0.712722;\n    float wc = 0.0807621;\n\n#if 0\n    // radial symmetry\n    la = 63.0/64.0;//0.9821 \n    lb = 23.0/64.0;//0.35766\n    lc = 0.;\n    \n    wa = 0.0987087;\n    wb = 0.88551;\n    wc = 0.0158843;\n#endif\n\n    vec3 ln = vec3(-2.5 + la, -0.5 + lb, 1.5 + lc);\n    vec3 lu = vec3(-1.5 - lc,  0.5 - lb, 2.5 - la);\n    \n    vec3 lx = uvF.x == 0.0 ? ln : lu;\n    vec3 ly = uvF.y == 0.0 ? ln : lu;\n    \n    vec3 wx = vec3(uvF.x == 0.0 ? wa : wc, wb, uvF.x == 0.0 ? wc : wa);\n    vec3 wy = vec3(uvF.y == 0.0 ? wa : wc, wb, uvF.y == 0.0 ? wc : wa);\n    \n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n    \n    uvI *= RcpSrcTexRes.xy;\n    lx  *= RcpSrcTexRes.xxx;\n    ly  *= RcpSrcTexRes.yyy;\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, uvI + vec2(lx.x, ly.x)) * (wx.x * wy.x);\n    col += Read(Tex, uvI + vec2(lx.y, ly.x)) * (wx.y * wy.x);\n    col += Read(Tex, uvI + vec2(lx.z, ly.x)) * (wx.z * wy.x);\n    \n    col += Read(Tex, uvI + vec2(lx.x, ly.y)) * (wx.x * wy.y);\n    col += Read(Tex, uvI + vec2(lx.y, ly.y)) * (wx.y * wy.y);\n    col += Read(Tex, uvI + vec2(lx.z, ly.y)) * (wx.z * wy.y);\n    \n    col += Read(Tex, uvI + vec2(lx.x, ly.z)) * (wx.x * wy.z);\n    col += Read(Tex, uvI + vec2(lx.y, ly.z)) * (wx.y * wy.z);\n    col += Read(Tex, uvI + vec2(lx.z, ly.z)) * (wx.z * wy.z);\n    \n    return col;\n}\n\n\nvec4 BloomDownKernel9B(sampler2D Tex, vec2 uv0)\n{\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth;\n    \n    vec2 tc = uv * (1.0 / Resolution);\n    \n#if 0\n    // optimal stop-band\n    float w0 = 0.28397;\n\tfloat a = 0.124413;\n\tfloat b = 0.0545943;\n\tfloat oa = 1.5 + 0.262180;\n\tfloat ob = 1.5 + 0.262641;\n#elif 0\n    // radial symmetry\n    float w0 = 0.340645;\n\tfloat a = 0.134777;\n\tfloat b = 0.0300612;\n\tfloat oa = 1.5 + 0.226953;\n\tfloat ob = 1.5 + 0.;\n#elif 0\n    // radial symmetry\n    float w0 = 0.316221;\n\tfloat a = 0.130564;\n\tfloat b = 0.0403808;\n\tfloat oa = 1.5 + 0.241873;\n\tfloat ob = 1.5 + 0.125;\n#elif 1\n    // radial symmetry\n    float w0 = 0.309247;\n\tfloat a = 0.129306;\n\tfloat b = 0.0433824;\n\tfloat oa = 1.5 + 0.246235;\n\tfloat ob = 1.5 + (0.125+1.0/32.0);\n#elif 1\n    float w0 = 0.218567;\n\tfloat a = 0.128518;\n\tfloat b = 0.0668404;\n\tfloat oa = 1.5 + 0.34447;\n\tfloat ob = 1.5 + 0.314137;\n#endif\n\n    vec2 oa2 = oa * (1.0 / Resolution);\n    vec2 ob2 = ob * (1.0 / Resolution);\n\n\tvec4 c = vec4(0.0);\n    \n    c += Read(Tex, tc) * w0;\n\n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * oa2) * a;\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * ob2) * b;\n\n\treturn c;\n}\n\nfloat EvalImage(vec2 uv, int frameOff)\n{\n    vec2 uv2 = uv - 0.5;\n    \n    float o = 120.0;\n    \n    float v = 0.0;\n    v += uv2.x == 600.0 && uv2.y == o ? 1000.0 : 0.0;\n    v += uv2.x == 600.0 && uv2.y == Resolution.y - 1.0 - o ? 1000.0 : 0.0;\n    v += uv2.y == 330.0 && uv2.x == Resolution.x - 1.0 - o ? 1000.0 : 0.0;\n    v += uv2.y == 330.0 && uv2.x == o ? 1000.0 : 0.0;\n    \n    //return vec3(v*100.2);\n    \n    //return uv2.y == 66.0 || uv2.y == Resolution.y - 67.0 ? vec3(30.0) : vec3(0.0);\n    //return uv2.y == 16.0 || uv2.y == Resolution.y - 17.0 ? vec3(1.0) : vec3(0.0);\n    //return uv2.y == 0.0 || uv2.y == Resolution.y - 1.0 ? vec3(1.0) : vec3(0.0);\n    //return uv2.x == 0.0 || uv2.x == Resolution.x - 1.0 ? vec3(1.0) : vec3(0.0);\n\n    vec2 uvr = Resolution * 0.5;\n    \n    float t = float(Frame + frameOff) * 0.02;\n    \n    float a = mix(0.2, 0.3, sin(t) * 0.5 + 0.5) * Pi;\n    //a = mix(-0.03, 0.02, sin(t) * 0.5 + 0.5) * Pi;\n    a = t;\n    \n    uvr += vec2(cos(a), sin(a)) * floor(Resolution.y*0.5+0.0) * vec2(1.0, 1.0);\n    //uvr += vec2(cos(a), sin(a)) * (256.0+64.0) * vec2(1.0, 1.0);\n    //uvr += vec2(-1.0, 0.0) * (256.0+343.0) * vec2(1.0, 0.0);\n    \n    vec2 vec = uv - uvr;\n    float ll = dot(vec, vec);\n    //return vec3(exp2(-ll * 2.0)) * 100.0;//20000.0;\n    \n    //uvr = vec2(Resolution.x*0.5, Resolution.y-1.0);\n    //uvr = vec2(Resolution.x-1.0, Resolution.y*0.5);\n    \n    uvr = floor(uvr) + 0.5;\n    //uvr = vec2(512.0, 337.0 + round(sin(Time)*4.0)) + 0.5;\n    \n    //if(false)\n    {\n        float s = 0.02;\n        \n        float s2 = s * 0.01;\n        \n        uv += t * 64.0;\n        \n        float v = max(0.0, cos(uv.x * s) * cos(uv.y * s) - (1.0-s2)) / s2;\n        \n        return v*v;\n        //return cos(uv.x * s) * cos(uv.y * s) > 0.99 ? vec3(1.0) : vec3(0.0);\n    }\n   // return vec3(1.0);\n    \n    return uv.x == uvr.x && uv.y == uvr.y ? 1.0 : 0.0;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples\nvec4 BloomDownKernel8(sampler2D Tex, vec2 tc)\n{\n#if 1\n    float a  = 0.13433339843769723; \n    float la = 0.9108132736411344;\n    float lb = 0.37269896061302266;\n#else\n    float a  = 0.125143; \n    float la = 0.701224;\n    float lb = 0.330373; \n#endif\n\n\tvec2 oa = (1.5 + la) * (1.0 / Resolution);\n\tvec2 ob = (0.5 + lb) * (1.0 / Resolution);\n    \n\tvec4 ca = vec4(0.0);\n\tca += Read(Tex, tc + vec2(-1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0,-1.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0, 1.0) * oa);\n    \n    vec4 cb = vec4(0.0);\n\tcb += Read(Tex, tc + vec2(-1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2(-1.0, 1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0, 1.0) * ob);\n    \n    return cb * (0.25 - a * 0.25) + \n           ca * (       a * 0.25);\n}\n\n// 36 samples downsampling kernel implemented via 9 bilinear samples\nvec4 BloomDownKernel9(sampler2D Tex, vec2 tc)\n{\n#if 0\n    // pascal kernel (gauss approx)\n\tfloat a = 6.0 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.5 * (2.0 / 6.0);\n#elif 0\n    float a = 8.0 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.893356 * (2.0 / 6.0);\n#elif 1\n    float a = 7.46602 / 32.0;\n    //a = 7.44733 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.784887 * (2.0 / 6.0);    \n\t//o = 1.5 + 0.778 * (2.0 / 6.0);    \n#elif 1\n    float a = 7.37167 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.25;//0.75 * (1.0 / 6.0);    \n#endif\n\n    vec2 off = o * 1.0 / Resolution;\n\n\tvec4 c = vec4(0.0);\n    c += Read(Tex, tc + vec2(0.0)) * (b * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * off) * (a * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * off) * (a * a);    \n\n\treturn c;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples\nvec4 BloomDownKernel8B(sampler2D Tex, vec2 tc)\n{\n#if 1\n    // optimal stop band\n    float la = 0.553811;\n    float lb = 0.35856; \n#else\n    float la = 0.245966;\n    float lb = 0.333333;\n#endif\n    \n    vec2 s = 1.0/Resolution;\n\tvec2 o = vec2(1.5 + la, 0.5 + lb);\n   \n\tvec4 col = vec4(0.0);\n\tcol += Read(Tex, tc + (vec2( 1.0, 1.0) * o.xy * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0, 1.0) * o.xy * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2( 1.0,-1.0) * o.xy * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0,-1.0) * o.xy * s)) * 0.125;\n    col += Read(Tex, tc + (vec2( 1.0, 1.0) * o.yx * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0, 1.0) * o.yx * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2( 1.0,-1.0) * o.yx * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0,-1.0) * o.yx * s)) * 0.125;\n    \n    return col;\n}\n\n\nvec4 bspline(float x)\n{\n\tfloat x2 = x * x;\n\tfloat x3 = x2 * x;\n\tvec4 w;\n\tw.x = -x3 + 3.0 * x2 - 3.0 * x + 1.0;\n\tw.y = 3.0 * x3 - 6.0 * x2 + 4.0;\n\tw.z = -3.0 * x3 + 3.0 * x2 + 3.0 * x + 1.0;\n\tw.w = x3;\n\treturn w / 6.0;\n}\n\nvec4 SampleCubic(sampler2D Tex, vec2 uvI, vec2 uvF, vec2 rcpTexSize)\n{\n\tvec4 cubicX = bspline(uvF.x);\n\tvec4 cubicY = bspline(uvF.y);\n\n\tvec2 cX = uvI.xx + vec2(-0.5, 1.5);\n\tvec2 cY = uvI.yy + vec2(-0.5, 1.5);\n\n\tvec2 sX = cubicX.xz + cubicX.yw;\n\tvec2 sY = cubicY.xz + cubicY.yw;\n\n\tvec2 offsetX = cX + cubicX.yw / sX;\n\tvec2 offsetY = cY + cubicY.yw / sY;\n\n\tvec4 value0 = textureLod(Tex, vec2(offsetX.x, offsetY.x) * rcpTexSize, 0.0);\n\tvec4 value1 = textureLod(Tex, vec2(offsetX.y, offsetY.x) * rcpTexSize, 0.0);\n\tvec4 value2 = textureLod(Tex, vec2(offsetX.x, offsetY.y) * rcpTexSize, 0.0);\n\tvec4 value3 = textureLod(Tex, vec2(offsetX.y, offsetY.y) * rcpTexSize, 0.0);\n\n\tfloat lX = sX.x / (sX.x + sX.y);\n\tfloat lY = sY.x / (sY.x + sY.y);\n\n\treturn mix(mix(value3, value2, lX),\n\t\t       mix(value1, value0, lX), lY);\n}\n\nvec4 SampleCubic(sampler2D Tex, vec2 uv, vec2 rcpTexSize)\n{\n\tuv -= 0.5;\n\n\tvec2 uvI = floor(uv);\n\tvec2 uvF = uv - uvI;\n\t\n\tvec4 r = SampleCubic(Tex, uvI, uvF, rcpTexSize);\n    \n    return r;\n}\n\n\n    {\n        // 2x2 box filter\n        v = 0.0;\n        v += Read(uv, vec2(0.0, 0.0)) * 0.25;\n        v += Read(uv, vec2(1.0, 0.0)) * 0.25;\n        v += Read(uv, vec2(0.0, 1.0)) * 0.25;\n        v += Read(uv, vec2(1.0, 1.0)) * 0.25;\n    }\n    \n        float size = SIZE*InputScale;\n        if(uv.x < 0.0) uv.x += size;\n        if(uv.y < 0.0) uv.y += size;\n\n        if(uv.x >= size) uv.x -= size;\n        if(uv.y >= size) uv.y -= size;\n\n        v = Hash01(uv, 0u);\n        \n        v = v > 0.99 ? 8.0 : 0.0;\n        \n// [1/32, 5/32, 10/32, 10/32, 5/32, 1/32]^2\nvec4 Pascal6x6Ref(vec2 uv)\n{\n\tvec4 c = vec4(0.0);\n\tfor(float y = -1.25; y <= 1.25; y += 0.5)\n\tfor(float x = -1.25; x <= 1.25; x += 0.5)\n\t{\n\t\tvec2 o = vec2(x, y);\n\n\t\tfloat wx = abs(o.x) == 0.25 ? 10.0 / 32.0 :\n\t\t\t       abs(o.x) == 0.75 ?  5.0 / 32.0 : 1.0 / 32.0;\n        float wy = abs(o.y) == 0.25 ? 10.0 / 32.0 :\n\t\t\t       abs(o.y) == 0.75 ?  5.0 / 32.0 : 1.0 / 32.0;\n\n\t\tc += Read(uv + 0.5 + o * 2.0) * (wx * wy);\n\t}\n\n\treturn c;\n}\n\nfloat Read2(vec2 uv)\n{\n    //if(ReadKeyToggle(KEY_TAB) != 0.0) \n    return Read(uv);\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    return mix(mix(Read(uvI + vec2(0.0, 0.0)), Read(uvI + vec2(1.0, 0.0)), uvF.x),\n               mix(Read(uvI + vec2(0.0, 1.0)), Read(uvI + vec2(1.0, 1.0)), uvF.x), uvF.y);\n}\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\nvec4 Moo3x3(vec2 uv)\n{\n    uv += 0.5;\n    float o = 2.0;\n\n    float b = 4.0;\n\n\tvec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\n\tsum += b * Read2(uv);\n\n\tsum += Read2(uv + vec2(-1.0, -1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2( 1.0,  1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2( 1.0, -1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2(-1.0,  1.0) * 0.5 * o);\n    \n    return sum / (b + 4.0);\n}\n\n*/", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsyDf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[10679, 10679, 10713, 10713, 10767], [11008, 11008, 11052, 11052, 11250], [11252, 11252, 11299, 11299, 11569], [11571, 11598, 11632, 11632, 11700], [11702, 11702, 11735, 11735, 11808], [11810, 11851, 11953, 11953, 12535], [12778, 12778, 12826, 12826, 14204]]}
{"id": "mdsyWf", "name": "Simple sun rosace", "author": "etdeagle", "description": "Shows how to compute if a point is inside a triangle, apply rotation too.\nUse Xoring of triangles for cool effects thanks to the suggestion of FabriceNeyret2.\nThere is a layer of imbrication, you could play with the side of the triangle for various effect", "tags": ["trianglerosacerosetterotation"], "likes": 2, "viewed": 136, "published": 3, "date": "1687279447", "time_retrieved": "2024-07-30T17:48:30.802785", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nvec3 xorCols(vec3 col0, vec3 col1) {\n    vec3 col = vec3(int(col0.x * 255.0) ^ int(col1.x * 255.0),\n    int(col0.y * 255.0) ^ int(col1.y * 255.0),\n    int(col0.z * 255.0) ^ int(col1.z * 255.0));\n    return col / 255.0;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 drawTriangle(in vec2 suv, in vec2 rot, in float side) {\n\n    // Create triangle vertices in local coordinates\n    float height = sqrt(side * side - (side * side / 4.0));\n    vec2 p1 = vec2(-side / 2.0, 0);\n    vec2 p2 = vec2(0, height);\n    vec2 p3 = vec2(side / 2.0, 0);\n\n    // Rotate and translate vertices\n    /*p1 = vec2(dot(p1, rot), dot(p1, vec2(-rot.y, rot.x)));\n    p2 = vec2(dot(p2, rot), dot(p2, vec2(-rot.y, rot.x)));\n    p3 = vec2(dot(p3, rot), dot(p3, vec2(-rot.y, rot.x)));*/\n\n\n    p1 = vec2(p1.x * rot.x - p1.y * rot.y, p1.x * rot.y + p1.y * rot.x);\n    p2 = vec2(p2.x * rot.x - p2.y * rot.y, p2.x * rot.y + p2.y * rot.x);\n    p3 = vec2(p3.x * rot.x - p3.y * rot.y, p3.x * rot.y + p3.y * rot.x);\n\n    // Compute barycentric coordinates\n    /*vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1;*/\n    \n     vec2 barycenter = (p1 + p2 + p3) / 3.0;\n    \n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1 + barycenter;\n    \n    \n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float dot13 = dot(v1, v3);\n    float dot22 = dot(v2, v2);\n    float dot23 = dot(v2, v3);\n    float invDenom = 1.0 / (dot11 * dot22 - dot12 * dot12);\n    float u = (dot22 * dot13 - dot12 * dot23) * invDenom;\n    float v = (dot11 * dot23 - dot12 * dot13) * invDenom;\n    vec2 uv = vec2(u, v);\n\n    vec3 col = vec3(0);\n    if ((uv.x >= 0.0) && (uv.y >= 0.0) && (uv.x + uv.y < 1.0)) {\n        //col = vec3(1.0);// flat shading\n        col = vec3(uv.x * uv.x, uv.y * uv.y, 1.0 - uv.x * uv.x  - uv.y * uv.y); // colorful shading wiht artifacts\n        //col = vec3(uv.x, uv.y, 1.0 - uv.x  - uv.y * uv.y);\n    }\n    return col;\n}\n\n\nvec3 ring(float r, vec2 uv, float petals, float triangle_radius) {\n            \n        float a = atan(uv.y, uv.x);\n        a = mod(a, 2.0 * PI / petals); // 6-fold symmetry\n        \n        vec2 suv = vec2(cos(a), sin(a))*r;\n        \n        // Create rosette pattern\n        float da = 2.0 * PI / petals;\n        float ca = cos(da);\n        float sa = sin(da);\n        vec2 rot = vec2(ca, sa);\n\n        vec3 col = vec3(0);\n        for(int i = 0; i < int(petals); ++i) {\n            col = col + drawTriangle(suv, rot, triangle_radius);\n            suv = vec2(dot(suv, rot), dot(suv, vec2(-rot.y, rot.x)));\n        }\n    return col;\n}\n\nvec3 xorTriangles(in vec2 suv0, in vec2 rot0, in float side0, in vec3 col0,\n                  in vec2 suv1, in vec2 rot1, in float side1, in vec3 col1) {\n\n    vec3 cola = drawTriangle(suv0, rot0, side0);\n    vec3 colb = drawTriangle(suv1, rot1, side1);\n    \n    if (cola.x == 0.0) {\n        cola = col0;\n    }\n    \n    if (colb.x == 0.0) {\n        colb = col1;\n    }\n    \n    vec3 col = xorCols(cola, colb);\n    return col;\n\n}\n\n/*\nvec3 xorPolygons(in vec3 polygon0_center, in float polygon0_radius, in int polygon0_sides, in float polygon0_offset,\n                in vec3 polygon1_center, in float polygon1_radius, in int polygon1_sides, in float polygon1_offset,\n                in vec2 uv) {\n    // The color is xor of the polygons surfaces\n    vec3 col = vec3(0);\n\n    // Create polygon 0\n    float a = atan(uv.y - polygon0_center.y, uv.x - polygon0_center.x);\n    a = mod(a, 2.0*3.141598 / float(polygon0_sides)); // 6-fold symmetry\n    vec2 suv = vec2(cos(a), sin(a))*polygon0_radius;\n\n    // Create rosette pattern\n    float da = 2.0*3.141598 / float(polygon0_sides) + polygon0_offset;\n    float ca = cos(da);\n    float sa = sin(da);\n    vec2 rot = vec2(ca, sa);\n\n    // Draw polygon 0\n\n    for(int i = 0; i < polygon0_sides; ++i) {\n        vec2 uv = drawTriangle(suv, rot, 0.1);\n        float u = uv.x;\n        float v = uv.y;\n        if ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) {\n            col = vec3(1.0);\n        }\n        suv = vec2(dot(suv, rot), dot(suv, vec2(-rot.y, rot.x)));\n    }\n\n    // Create polygon 1\n    a = atan(uv.y - polygon1_center.y, uv.x - polygon1_center.x);\n    a = mod(a, 2.0*3.141598 / float(polygon1_sides)); // 6-fold symmetry\n    suv = vec2(cos(a), sin(a))*polygon1_radius;\n    \n    // Create rosette pattern\n    da = 2.0*PI / float(polygon1_sides) + polygon1_offset;\n    ca = cos(da);\n    sa = sin(da);\n    rot = vec2(ca, sa);\n\n    // Draw polygon 1\n    for(int i = 0; i < polygon1_sides; ++i) {\n        vec2 uv = drawTriangle(suv, rot, 0.1);\n        float u = uv.x;\n        float v = uv.y;\n        if ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) {\n            col = vec3(1.0);\n        }\n        suv = vec2(dot(suv, rot), dot(suv, vec2(-rot.y, rot.x)));\n    }\n\n    return col;\n}\n*/\n\nvec3 pick_random_color(vec3 colors[6], in int seed) {\n    //rand();\n    //int idx = int(rand(vec2(iTime, iTime * 2.43243212)) * 6.0);\n    //int idx = int(iTime * float(seed) / 30.0) % 6;\n    return colors[seed % 6];\n\n    //return colors[idx];\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Create a circle\n    float r = length(uv);\n    if(r < 6.0) {\n        //col = ring(r, uv, 6.0, 0.3);\n        //col += ring(r * 2.0, uv, 6.0, 0.3);\n        //col += ring(r * 4.0, uv, 6.0, 0.3);\n\n        \n        float a = atan(uv.y, uv.x);\n        //a = mod(a, 2.0 * PI / petals);\n        vec2 suv = vec2(cos(a), sin(a)) * r;\n        vec2 rot = vec2(cos(2.0 * PI / 6.0), sin(2.0 * PI / 6.0));\n        float side = 1.0;\n\n        vec2 suv2 = vec2(cos(a + PI), sin(a + PI)) * r;\n        vec2 rot2 = vec2(cos(2.0 * PI / 6.0 + PI), sin(2.0 * PI / 6.0 + PI));\n    \n    \n        vec2 rot3 = vec2(1.0, 0);\n        vec2 rot4 = vec2(-1.0, 0);\n        \n        /* Repeating inner pattern\n        vec3 col0 = xorTriangles(suv, rot3, side, suv, rot4, side);\n        vec3 col1 = xorTriangles(suv, rot3, side * 1.3 / 3.0, suv, rot4, side * 1.3 / 3.0);\n        vec3 col2 = xorTriangles(suv, rot3, side * 3.0 / 1.3, suv, rot4, side * 3.0 / 1.3);\n        col = col0 + col1 + col2;\n        */\n        \n        /*\n        float t0 = sin(iTime);\n        float t1 = cos(iTime);\n        float t2 = sin(cos(iTime));\n        \n        vec3 col0 = xorTriangles(suv, rot3, side * t0, suv, rot4, side * t0);\n        vec3 col1 = xorTriangles(suv, rot3, side * t1 / 3.0, suv, rot4, side * t1 / 3.0);\n        vec3 col2 = xorTriangles(suv, rot3, side * t2 / 2.0, suv, rot4, side * t2 / 2.0);\n        */\n        \n        float t0 = 1.0;\n        float t1 = 1.4;\n        float t2 = 1.5;\n        float t3 = 1.8;\n\n        vec3 turquoise = vec3(71., 224., 204.) / 255.0;\n        vec3 ochre = vec3(239., 192., 102.) / 255.0;\n        vec3 blue = vec3(24., 88., 178.) / 255.0;\n        vec3 green = vec3(10, 81, 51) / 255.0;\n        // make a list with all the colors\n\n        vec3 colors[6];\n        colors[0] = turquoise;\n        colors[1] = ochre;\n        colors[2] = blue;\n        colors[3] = green;\n        colors[4] = vec3(0.);\n        colors[5] = vec3(1.);\n\n        // pick six random colors col00, col01, col10, col11, col20, col21 from truquoise, ochre, blue, green\n        vec3 col00 = pick_random_color(colors, 0);\n        vec3 col01 = pick_random_color(colors, 0);\n        vec3 col10 = pick_random_color(colors, 1);\n        vec3 col11 = pick_random_color(colors, 1);\n        vec3 col20 = pick_random_color(colors, 2);\n        vec3 col21 = pick_random_color(colors, 2);\n        vec3 col30 = pick_random_color(colors, 4);\n        vec3 col31 = pick_random_color(colors, 4);\n        \n        vec3 col0 = xorTriangles(suv, rot3, side * t0, col00,\n                                 suv, rot4, side * t0, col01);\n        vec3 col1 = xorTriangles(suv, rot3, side * t1 / 3.0, col10,\n                                 suv, rot4, side * t1 / 3.0, col11);\n        vec3 col2 = xorTriangles(suv, rot3, side * t2 / 2.0, col20,\n                                 suv, rot4, side * t2 / 2.0, col);\n        vec3 col3 = xorTriangles(suv, rot3, side * t3 / 1.2, col30,\n                                 suv, rot4, side * t3 / 1.2, col31);\n        \n        \n        col = xorCols(xorCols(col0, xorCols(col1, col2)), col3);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 89, 89, 273], [276, 276, 296, 296, 366], [368, 368, 428, 482, 2035], [2038, 2038, 2104, 2104, 2672], [2674, 2674, 2827, 2827, 3100], [4897, 4897, 4950, 5083, 5141], [5144, 5144, 5201, 5201, 8477]]}
{"id": "cdsyWX", "name": "[RMO] - sphere", "author": "silica163", "description": "ray marching object - sphere", "tags": ["raymarch", "sphere"], "likes": 1, "viewed": 148, "published": 3, "date": "1687261454", "time_retrieved": "2024-07-30T17:48:31.738283", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/2.,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    sp[0].p = vec4(0,0,0,1);\n    l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[1].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    c += render(r);\n    \n    //c = r.p;\n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\nconst int LIGHTS = 2;\nconst int SPHERES = 1;\n\nstruct Sphere {\n    vec4 p;\n    vec3 c;\n},sp[SPHERES];\n\nfloat sphereSDF(vec3 p,int id){\n    return length(p-sp[id].p.xyz) - sp[id].p.w;\n}\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n\td = sphereSDF(p,0);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nmat3 rotX(float a){\n    float sa = sin(a),\n        ca = cos(a);\n    return mat3(\n         1,  0, 0,\n         0, sa,ca,\n         0,-ca,sa\n    );\n}\n\nmat3 rotY(float a){\n    float sa = sin(a),\n        ca = cos(a);\n    return mat3(\n        sa, 0,-ca,\n         0, 1,  0,\n        ca, 0, sa\n    );\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += max(dot(l[i].L,N),0.);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(0);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 918]]}
{"id": "dsfyDf", "name": "Refraction Shader - Moni", "author": "AvaterClasher", "description": "Refraction Shader", "tags": ["refraction"], "likes": 1, "viewed": 127, "published": 3, "date": "1687257212", "time_retrieved": "2024-07-30T17:48:32.636880", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n   \n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 1.45; // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 rdOut = refract(rdIn, nExit, IOR);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        \n        vec3 reflTex = texture(iChannel0, rdOut).rgb;\n        col = vec3(reflTex);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 124, 124, 186], [188, 188, 217, 217, 298], [301, 301, 324, 324, 378], [380, 380, 426, 426, 642], [644, 644, 668, 668, 858], [860, 860, 910, 910, 1101], [1103, 1103, 1160, 1160, 2368]]}
{"id": "dsfyWf", "name": "[RMO] - cube", "author": "silica163", "description": "render cube with raymarching.", "tags": ["raymarch", "cube"], "likes": 1, "viewed": 152, "published": 3, "date": "1687255633", "time_retrieved": "2024-07-30T17:48:33.484615", "image_code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/2.,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    cu[0].s = vec3(1);\n    l[0].p = vec3(2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    c += render(r);\n    \n    //c = r.p;\n    fColor = vec4(c,1.0);\n}\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\nconst int LIGHTS = 2;\nconst int CUBES = 1;\n\n// cube function\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n},cu[CUBES];\n\nfloat max3(vec3 n){\n    return max(max(n.x,n.y),n.z);\n}\n\nfloat cubeSDF(vec3 p,int id){\n    vec3 c = abs(p-cu[id].p)-cu[id].s;\n    return length(max(c,0.)) + min(0.,max3(c));\n}\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n\td = cubeSDF(p,0);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nmat3 rotX(float a){\n    float sa = sin(a),\n        ca = cos(a);\n    return mat3(\n         1,  0, 0,\n         0, sa,ca,\n         0,-ca,sa\n    );\n}\n\nmat3 rotY(float a){\n    float sa = sin(a),\n        ca = cos(a);\n    return mat3(\n        sa, 0,-ca,\n         0, 1,  0,\n        ca, 0, sa\n    );\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++)\n        lNormal(l[i],r);\n    \n    c += max(dot(l[0].L,N),0.)+.2;\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(0);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 856]]}
{"id": "ddfcWf", "name": "Generalized Dijkstra's Algorithm", "author": "copperbotte", "description": "Continuous Dijkstra's algorithm in Euclidean space.\n\nClick and drag to adjust the starting point.", "tags": ["sdf", "pathfinding", "continuous", "dijkstra"], "likes": 4, "viewed": 190, "published": 3, "date": "1687254767", "time_retrieved": "2024-07-30T17:48:34.438064", "image_code": "\n//for i, path in enumerate(paths):\n//\tprint(\"const int path%d_len = %d;\"%(i, len(path)))\n//\tprint(\"vec2 path%d[path%d_len] = vec2[](\"%(i, i))\n//\tfor j, p in enumerate(path):\n//\t\ts = \"\\tvec2(%f, %f),\"%p\n//\t\tif j+1 == len(path):\n//\t\t\ts = s[:-1]\n//\t\tprint(s)\n//\tprint(\");\")\n//\tprint()\n\n\nconst int path0_len = 5;\nvec2 path0[path0_len] = vec2[](\n\tvec2(0.000000, 0.000000),\n\tvec2(1.388889, 0.000000),\n\tvec2(1.388889, 1.000000),\n\tvec2(0.000000, 1.000000),\n\tvec2(0.000000, 0.000000)\n);\n\nconst int path1_len = 7;\nvec2 path1[path1_len] = vec2[](\n\tvec2(0.176389, 0.919444),\n\tvec2(0.298611, 0.916667),\n\tvec2(0.379167, 0.811111),\n\tvec2(0.309722, 0.702778),\n\tvec2(0.162500, 0.702778),\n\tvec2(0.093056, 0.805556),\n\tvec2(0.176389, 0.919444)\n);\n\nconst int path2_len = 4;\nvec2 path2[path2_len] = vec2[](\n\tvec2(0.272222, 0.376389),\n\tvec2(0.591667, 0.773611),\n\tvec2(0.697222, 0.256944),\n\tvec2(0.272222, 0.376389)\n);\n\nconst int path3_len = 5;\nvec2 path3[path3_len] = vec2[](\n\tvec2(0.805555, 0.351389),\n\tvec2(0.750000, 0.156945),\n\tvec2(0.972222, 0.093056),\n\tvec2(1.036111, 0.268056),\n\tvec2(0.805555, 0.351389)\n);\n\nconst int path4_len = 9;\nvec2 path4[path4_len] = vec2[](\n\tvec2(0.791667, 0.845833),\n\tvec2(0.777778, 0.659722),\n\tvec2(0.963889, 0.529167),\n\tvec2(0.719444, 0.540278),\n\tvec2(1.077778, 0.298611),\n\tvec2(1.213889, 0.626389),\n\tvec2(0.947222, 0.623611),\n\tvec2(0.972222, 0.837500),\n\tvec2(0.791667, 0.845833)\n);\n\nvec2 offs0[4] = vec2[](\n\tvec2(-0.811534, -0.584305),\n\tvec2(0.811534, -0.584305),\n\tvec2(0.811534, 0.584305),\n\tvec2(-0.811534, 0.584305)\n);\n\nvec2 offs1[6] = vec2[](\n\tvec2(-0.316228, 0.948683),\n\tvec2(0.375705, 0.926739),\n\tvec2(0.999829, 0.018515),\n\tvec2(0.583207, -0.812324),\n\tvec2(-0.603443, -0.797406),\n\tvec2(-0.997366, -0.072536)\n);\n\nvec2 offs2[3] = vec2[](\n\tvec2(-0.936903, -0.349591),\n\tvec2(0.227884, 0.973688),\n\tvec2(0.640514, -0.767946)\n);\n\nvec2 offs3[4] = vec2[](\n\tvec2(-0.533038, 0.846092),\n\tvec2(-0.905024, -0.425361),\n\tvec2(0.552462, -0.833538),\n\tvec2(0.954800, 0.297249)\n);\n\nvec2 offs4[8] = vec2[](\n\tvec2(-0.650792, 0.759256),\n\tvec2(-0.963518, -0.267644),\n\tvec2(-0.949902, 0.312548),\n\tvec2(-0.922194, 0.386727),\n\tvec2(0.363543, -0.931578),\n\tvec2(0.773006, 0.634398),\n\tvec2(0.802744, 0.596324),\n\tvec2(0.707107, 0.707107)\n);\n\n\nvec2 pt1 = vec2(0.17256944176474115, 0.1586805690634476);\nvec2 pt2 = vec2(1.0201200976064742, 0.6792735789518283);\n\n//https://stackoverflow.com/questions/16069959/glsl-how-to-ensure-largest-possible-float-value-without-overflow\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\nfloat sdf_circle(vec2 x, vec2 x0)\n{\n    return length(x - x0);\n}\n\n// Thanks iq!  This is capsule, with r=0.\n// https://iquilezles.org/articles/distfunctions/\nfloat sdf_segment(vec2 x, vec2 x0, vec2 x1)\n{\n    vec2 dx = x - x0;\n    vec2 dx1 = x1 - x0;\n    float dist = clamp(dot(dx, dx1)/dot(dx1, dx1), 0.0, 1.0); // Projection\n    return length(dx - dx1*dist);\n}\n\nfloat sdf(vec2 x)\n{\n    float dist = FLT_MAX;\n    \n\tfor(int i=0; i<path0_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path0[i], path0[i+1]));\n        \n\tfor(int i=0; i<path1_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path1[i], path1[i+1]));\n        \n\tfor(int i=0; i<path2_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path2[i], path2[i+1]));\n        \n\tfor(int i=0; i<path3_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path3[i], path3[i+1]));\n        \n\tfor(int i=0; i<path4_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path4[i], path4[i+1]));\n    \n    return dist;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//     This function finds if the points x0 and x1 are visible to each other \n// through the segment s0 to s1.\n// \n//     This works similarly to barycentric point-in-triangle, but checks if all \n// three conditions are true.\nbool seg_vis(vec2 x0, vec2 x1, vec2 s0, vec2 s1)\n{\n    x1 -= x0;\n    s0 -= x0;\n    s1 -= x0;\n    mat2x2 M = inverse(mat2x2(s0, s1));\n    x1 = M*x1;\n    \n    if(0.0 < x1.x && 0.0 < x1.y && 1.0 < dot(x1, vec2(1)))\n        return false;\n\n    return true;\n}\n\n// This function finds if the points x0 and x1 are visible to each other.\nbool visibility(vec2 x0, vec2 x1)\n{\n    bool vis = true;\n\n    for(int i=0; i<path0_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path0[i], path0[i+1]);\n    \n\tfor(int i=0; i<path1_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path1[i], path1[i+1]);\n        \n\tfor(int i=0; i<path2_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path2[i], path2[i+1]);\n        \n\tfor(int i=0; i<path3_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path3[i], path3[i+1]);\n        \n\tfor(int i=0; i<path4_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path4[i], path4[i+1]);\n\n    return vis;\n}\n\n// Get a position for the ith point, adjusted with epsilon if not x0.\nvec2 get_adjusted_pt(int i, vec2 x0, vec2 x1)\n{\n    if(i == 0) return x0;\n    i -= 1;\n    \n    if(i == 0) return x1;\n    i -= 1;\n    \n    float e = 1e-4; // epsilon\n    \n    if(i < path0_len-1) return path0[i] - offs0[i]*e;\n    i -= path0_len-1;\n    \n    if(i < path1_len-1) return path1[i] + offs1[i]*e;\n    i -= path1_len-1;\n    \n    if(i < path2_len-1) return path2[i] + offs2[i]*e;\n    i -= path2_len-1;\n    \n    if(i < path3_len-1) return path3[i] + offs3[i]*e;\n    i -= path3_len-1;\n    \n    return path4[i] + offs4[i]*e;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//     This function is the resulting generalized pathfinding distance field.  \n// Represents the distance from x0 to x1, or FLT_MAX if unreachable.\n\n\n\n// visibility matrix size, it was used in a previous version.\nconst int vismat_len = 2+4+6+3+4+8;\nint pathids[vismat_len]; // Linked list forming a tree\nfloat pathdist(vec2 x0, vec2 x1, out bool vis)\n{\n    // Maybe rewrite the algo right here.\n    // Starting at x0, we want to find the shortest distance to x1 minimizing work.\n    //vec2 x0 = pt;\n    //vec2 x1 = xy;\n\n    // intermediate path distance array\n    float pdist[vismat_len];\n    \n    // Generate a list of nodes that are currently visible, previously visible and visited.\n    bool c_vis[vismat_len];\n    bool p_vis[vismat_len];\n    bool visited[vismat_len];\n    for(int i=0; i<vismat_len; ++i)\n    {\n        c_vis[i] = p_vis[i] = visited[i] = false;\n        pdist[i] = FLT_MAX;\n        pathids[i] = 0; // Clears pathids\n    }\n    \n    pdist[0] = 0.0;\n    \n    // Loop through all nodes:\n    int current = 0;\n    int next;\n    \n    for(int n=0; n<vismat_len; ++n)\n    {\n        current = next;\n        visited[current] = true;\n\n        vec2 p0 = get_adjusted_pt(current, x0, x1);\n        for(int i=0; i<vismat_len; ++i)\n        {\n            if(visited[i]) continue; // Skip visited nodes. \n\n            // Find nodes that are visible to p0.\n            c_vis[i] = visibility(p0, get_adjusted_pt(i, x0, x1));\n            p_vis[i] = p_vis[i] || c_vis[i];\n\n            // Compute pdist if visible.\n            if(!c_vis[i]) continue;\n            \n            // Code for not using pathids.\n            //pdist[i] = min(pdist[i], pdist[current] + sdf_circle(p0, get_adjusted_pt(i, x0, x1)));\n            \n            // Code for using pathids.\n            \n            float ndist = pdist[current] + sdf_circle(p0, get_adjusted_pt(i, x0, x1));\n            if(ndist < pdist[i])\n            {\n                pdist[i] = ndist;\n                pathids[i] = current;\n                \n            }\n            \n        }    \n\n        //if(current == 1) break; // This might actually make it laggier?\n\n        // Find next unvisited, previously visible node.\n        next = -1;\n        for(int i=0; i<vismat_len; ++i)\n        {\n            if(visited[i] || !p_vis[i]) continue;\n            if(next == -1) next = i;\n            else if(pdist[i] < pdist[next]) next = i;\n        }\n    }\n    \n    vis = p_vis[1];\n    return pdist[1];\n    \n}\n\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    xy /= 1.5;\n    \n    xy += path0[2]/2.0;\n    \n    //float time = mod(iTime + 5.0, 10.0);\n    float time = iTime;// - 5.0;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(time + xy.xyx+vec3(0,2,4));\n    \n    // Default sdf appearance\n    float sdist = sdf(xy);\n    if(mod(sdist, 0.025)/0.025 > 0.5)\n        col /= 2.0;\n    \n    // Mouse input\n    vec2 pt = pt1;\n    if(0.5 < iMouse.z)\n    {\n        pt = iMouse.xy/iResolution.xy;\n        pt = pt*2.0 - 1.0;\n        pt.x *= iResolution.x/iResolution.y;\n        pt /= 1.5;\n        pt += path0[2]/2.0;\n    }\n\n    col /= 3.0;\n    \n    \n    vec3 colpath = col;\n    \n    bool vis = false;\n    float dist = pathdist(pt, xy, vis);\n    float diff = time - dist*4.0;\n    \n    // Resulting visual\n    if(vis)\n    {\n        //dist = pdist[1];\n        if(0.0 < diff)\n        {\n        \n        colpath = 0.5 + 0.5*cos(-diff + xy.xyx+vec3(0,2,4));\n        if(mod(dist, 0.025)/0.025 > 0.5)\n            colpath *= mix(1.0/3.0, 1.0, exp(-4.0*diff));\n            //colpath /= 3.0;\n            \n        }\n    }\n    \n    \n    \n    \n    bool vis2 = false;\n    float p2dist = pathdist(pt, pt2, vis2);\n    float diff2 = time - p2dist*4.0;\n    if(0.0 < diff2)\n    {\n        // super satisfying ripple effect\n        float crad = mix(0.05, 0.0, exp(-4.0*diff2));\n        if(sdf_circle(xy, pt2) < crad)\n        {\n            colpath += vec3(sqrt(exp(-4.0*(diff2))));\n\n        }\n\n    //}\n    \n        // Path from pt1 to pt2\n        if(vis)\n        {\n        int current = 1;\n        float dsum = 0.0;\n        for(int i=0; i<5; ++i)\n        {\n            int next = pathids[current];\n            vec2 p0 = get_adjusted_pt(current, pt, pt2);\n            vec2 p1 = get_adjusted_pt(next, pt, pt2);\n            \n            float dd = length(p1 - p0);\n            \n            //dsum += dd;\n            \n            float dd2 = diff2 - p2dist;\n            //float dd3 = diff2 - p2dist + dist;\n            float dd3 = dd2 + dist; // works, but uses dist.\n            //float dd3 = dd2 + dsum; // does not work\n            //dd3 = min(0.0, dd3);\n            // dd3 here is the distance from the destination back to the source.\n            \n            \n            // if dd3 < dsum + dd, dd3 can be used as a lerp!\n            // dsum < dd3 < dsum + dd\n            // ds1 < dd3 < ds2\n            // \n            \n            \n            \n            //float dd3 = dd2 - dsum - dd;\n            \n            \n            float dd4 = min(0.0, dd2);\n            \n            //if(0.0\n            \n            \n            //bool factor = 0.0 < (dist - dd2);\n            //bool factor = 0.0 < diff2 - p2dist + dist;\n            bool factor = 0.0 < dd3;\n            \n            \n            \n            if(sdf_segment(xy, p0, p1) < 0.005 && factor) colpath = mix(colpath, vec3(1.0), min(1.0, exp(-2.0*(time - p2dist*6.0))));\n            // This is oddly, really hard to get the segments working right.\n            \n            /*       \n            float ratio = clamp(dd2/dd, 0.0, 1.0);\n            p1 = mix(p0, p1, ratio);\n            if(sdf_segment(xy, p0, p1) < 0.005) col = vec3(1.0);\n            //*/\n\n            current = next;\n        }\n        }\n    }\n    \n    \n    //if(sdist*10.0 + time - p2dist*6.0 < 0.0)\n    //    col = colpath;\n    \n    //if(sdist*10.0 + time - p2dist*6.0 < 0.0)\n    //    col = colpath;\n    col = colpath;\n    \n    \n    /*\n    // Path from pt1 to pt2\n    dist = pathdist(pt, pt2, vis);\n    int current = 1;\n    for(int i=0; i<5; ++i)\n    {\n        int next = pathids[current];\n        vec2 p0 = get_adjusted_pt(current, pt, pt2);\n        vec2 p1 = get_adjusted_pt(next, pt, pt2);\n        if(sdf_segment(xy, p0, p1) < 0.01) col = vec3(1.0);\n        \n        current = next;\n    }\n    */\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2522, 2522, 2557, 2557, 2586], [2588, 2680, 2725, 2725, 2883], [2885, 2885, 2904, 2904, 3455], [3457, 3764, 3814, 3814, 4017], [4019, 4093, 4128, 4128, 4644], [4646, 4716, 4763, 4763, 5245], [5603, 5633, 5681, 5888, 7771], [7774, 7866, 7879, 7879, 7922], [7924, 7924, 7981, 8031, 11964]]}
{"id": "mddSWf", "name": "Sea of spheres", "author": "z0rg", "description": "bleep", "tags": ["raymarching", "wave", "sea", "spheres", "dots"], "likes": 57, "viewed": 853, "published": 3, "date": "1687245161", "time_retrieved": "2024-07-30T17:48:35.217979", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 rgb = texture(iChannel0, uv).xyz;\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = .5;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    vec2 rep = vec2(.6);\n    vec2 id = floor((p.xz+rep*.5)/rep);\n    p.xz = mod(p.xz+rep*.5,rep)-rep*.5;\n    p.y += sin(length(id)*.25-iTime)*2.;\n    acc = _min(acc, vec2(length(p)-.25, 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 150.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.4;\n        accCol += vec3(1.)*(1.-sat(res.x/.2))*.01;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float d = 60.;\n    vec3 ro = vec3(sin(iTime*.5)*20.,-d,-d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    float depth = 100.;\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = mix(\n        vec3(1.000,0.451,0.000), \n        vec3(0.094,0.376,0.949),\n        1.-pow(sat(-dot(normalize(vec3(1.)), n)*.75),1.));\n        col = mix(col, vec3(1.), pow(sat(-dot(rd, n)),5.));\n        col = mix(col, col*.5, sat(p.y*.5+.5));\n    }\n    col += accCol;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord)/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec2 off = .75*(vec2(rand(), rand())-.5);\n    vec3 col = rdr(uv+off*pow(abs(uv.y),3.));\n    col = sat(col*1.2);\n    col = pow(col, vec3(2.2));\n    \n\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .95);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddSWf.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 571]]}
{"id": "dslczf", "name": "Better Rain", "author": "ixmibrahim", "description": "Added wavy droplets and made it faster", "tags": ["glass", "heart", "rain", "drop", "sad", "window", "droplets", "drops", "raining", "rainonwindow"], "likes": 4, "viewed": 249, "published": 3, "date": "1687243369", "time_retrieved": "2024-07-30T17:48:36.161457", "image_code": "\n#define USE_POST_PROCESSING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 c = texture(iChannel0, uv).xy;\n    float focus = texture(iChannel0, uv).z;\n    float t = texture(iChannel0, uv).w;\n    \n    \n    float normalScale = 0.5;//when background is more sharpened, make this less and make the trails more\n    vec2 e = normalScale / iResolution.xy;\n    float cx = texture(iChannel0, uv + e).x;\n    float cy = texture(iChannel0, uv + e.yx).x;\n    vec2 n = vec2(cx-c.x, cy-c.x);\n        \n        \n    vec3 col = textureLod(iChannel3, uv+n, focus).rgb;\n    \n    \n    #ifdef USE_POST_PROCESSING\n    float colFade = sin(t*.2)*.5+.5;\n    col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    col *= 1.-dot(uv-=.5, uv);\t\t\t\t\t\t\t// vignette\n    #endif\n    \n    \n    \n    //vec3 col = texture(iChannel0, UV+n).rgb;\n    fragColor = vec4(vec3(0.5+n,0.5), 1.);\n    fragColor = vec4(vec3(c,0), 1.);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12788, "src": "https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}, {"id": 20576, "src": "https://soundcloud.com/daklakwarriors/sleeping-sound-rain-and-thunder-1-hours", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define M_PI 3.14159\n#define M_2PI 6.28318\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\nvec2 StaticDropCenter(vec2 id)\n{\n    //vec3 n = N13(id.x*106.45+id.y*3543.654);\n    //return vec3(n.x - 0.5, n.y - 0.5, n.z);\n    //return vec2(-0.3,0.0);\n    return N13(id.x*106.45+id.y*3543.654).xy - 0.5;\n}\n\nvec3 rand3(vec2 id)\n{\n    return N13(id.x*105.45+id.y*3543.654);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 DropLayer2(vec2 uv, float t, vec2 densityScale) {\n    vec2 UV = uv;//return vec2(uv.x, fract(uv.y+0.5)-0.5); // [-0.5, 0.5]\n    vec2 a = vec2(6., 1.) * densityScale;\n    vec2 grid = a*2.;\n    \n    vec2 id = floor(uv * grid); //return fract(uv*grid); // get id of each tile in grid\n    float gridFall = N(id.x)/3. + 0.5;//gridFall=0.;// 0.75\n    uv.y += t*gridFall/a.y; //return vec2(uv.x, fract(uv.y+0.5)-0.5); // make all drops fall a uniform amount - randomize?\n    id = floor(uv * grid); //return fract(uv*grid); // get id of falling grid\n    float extraDropSpeed = N(id.x);\n    uv.y += extraDropSpeed; // shift the grid by a (constant) random vertical amount\n    \n    id = floor(uv*grid); // update ID to match the location of the shifted grid, should be unique for each grid that shows up\n    vec2 st = fract(uv*grid)-vec2(.5, 0); //return fract(uv*grid)-vec2(.5, .5); // uvs for each tile, -.5<x<.5 and 0<y<1\n    //if (abs(st.x) > .485 || abs(st.y) > .985) return vec2(.9); // debuggin\n    vec3 n = N13(id.x*35.2+id.y*2376.1); // random [0,1]\n    float x = n.x-.5; // starting horizontal position [-0.5, 0.5]\n    float lambda = UV.y*20.; // wavelength of wiggle\n    float wiggle = sin(lambda+sin(lambda)); // shape of wiggle path [-1,1]\n    x += wiggle*(.5-abs(x))*(n.z-.5); // to drop position, add wiggle with random range [-0.25, 0.25], for a total max x value [-0.75, 0.75]\n    x *= .6; // keep away from tile edge [-0.45, 0.45] (as max range is [-0.5, 0.5]\n    float ti = fract(t*(gridFall+0.1)+n.z); // time offset so they don't all fall at the same time\n    float slowStart = 0.85;\n    float y = (Saw(slowStart, ti)-.5)*.9+.5; // falling position, slow start fast end, mapped to [0.05, 0.95] to avoid tile edge - can be randomized\n    vec2 p = vec2(x, y); // drop position\n    \n    //float d = length((st-p)*a.yx);// circular distance - a.xy returns a trail\n    float dropShape = (ti > slowStart) ? -sin(M_2PI * ti/ (1.-slowStart))*.5 - .5 : 0.;\n    float d = sdEgg((st-p)*a.yx, 0., dropShape);// drop-shape distance - a.xy returns a trail\n    float diameter = N(id.x+id.y)/7.+.2; // should be limited by starting position\n    float mainDrop = S(diameter/1.5, .0, d); // draws a drop with diameter\n    \n    float r2 = S(1., y, st.y);// blends from 0/top of tile to the vertical position of the drop, which clamp at 1\n    float r = sqrt(r2);\n    float cd = abs(st.x-x); // blends from 0/horizontal position of the drop to the tile edges, which clamp at 1\n    float thickness = diameter * 0.95;\n    //float trail = S(thickness*r, thickness/1.5*r2, cd); // draws a trail when cd is between the two curves, which create an arrow shape that is 0 at the top/0 and expand as r increases/gets lower\n    float trail = S(thickness*r, 0., cd); // draws a trail when cd is between the two curves, which create an arrow shape that is 0 at the top/0 and expand as r increases/gets lower\n    float trailFront = S(-.02, .02, st.y-y); // above the drop is 1 (where the trail is), below the drop is 0\n    trail *= r2*trailFront*0.5; // remove the trail below the drop, multiplying by r2 to get a blend from 0/top to 1/bottom of the trail\n    \n    y = UV.y; // [-0.5, 0.5]\n    float trail2 = S((thickness - 0.15)*r, 0., cd); // create a thinner trail that linearly expands in width, starting at 0 and clamping at 1\n    trail2 *= trailFront*n.z; // remove the trail below the drop and randomize its intensity\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2; // indicate the droplets' positions using the sin function (which starts big then gets small) and keep them within the smaller trail\n    float rndX = N(id.x)/1.5 + 0.5;\n    float rndY = N(st.y)/40. + 0.05; // high value adds slight shimmering effect\n    y = fract(y*11.*rndX)+(st.y-.5); // create a random grid where the droplets will show up\n    float dd = length(st-vec2(x, y)); // circular distance of droplet\n    droplets = S(trail2+rndY, 0.0, dd); // droplet positions, ideally with random widths\n    float m = mainDrop + droplets*r*trailFront; // add the droplets to the drop, blending them from 0/top to 1/bottom and removing the ones that are under the drop\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.; // debugging\n    //return vec2(m, trail2 > trail ? 0. : trail);\n    return vec2(m, trail);\n}\n\nfloat StaticDrop(vec2 uv, float t, vec2 offset)\n{\n    vec2 id = floor(uv) + offset;//if (floor(uv) == vec2(-3,-0) && offset == vec2(0,-1)) return 1.;\n    vec2 center = StaticDropCenter(id)*0.8;\n    vec3 rand = rand3(id);\n    uv = fract(uv) - 0.5; // within the tile, remap the origin so it's centered \n    //if (abs(uv.x) > .485 || abs(uv.y) > .485) return 0.02; // debugging\n    float d = length((uv - offset) - center);\n    \n    float radius = 0.5 + (rand.x/2. - 0.5);\n    float drop = S(radius, 0.0, d);\n    \n    t /= 1. + 1.5*(rand.x - 0.5); // the bigger the drop the longer it stays\n    float fade = Saw(0.15, fract(t + rand.y));// b is how fast the dot appears, 1-b is how fast the dot disappears, and it fades at a radom pace (multiply instead)\n    float intensity = fract(rand.z*27.);\n    \n    return drop * fade * intensity;\n    return drop;\n}\n\nfloat StaticDrops_old(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    float drops = StaticDrop(uv, t, vec2(0,0))\n                + StaticDrop(uv, t, vec2(1,0))\n                + StaticDrop(uv, t, vec2(-1,0))\n                + StaticDrop(uv, t, vec2(0,1))\n                + StaticDrop(uv, t, vec2(0,-1))\n                + StaticDrop(uv, t, vec2(1,1))\n                + StaticDrop(uv, t, vec2(-1,1))\n                + StaticDrop(uv, t, vec2(-1,-1))\n                + StaticDrop(uv, t, vec2(1,-1));\n    \n    return drops;\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    vec2 center = StaticDropCenter(id)*0.6;\n    vec3 rand = rand3(id);\n    //vec2 center = (n.xy-.5)*.7;center = (n.xy-.5)*1.0;\n    uv = fract(uv)-.5;\n    //if (abs(uv.x) > .495 || abs(uv.y) > .495) return 0.1;\n    \n    float d = length(uv-center.xy);//return d;\n    float radius = 0.3;\n    float drop = S(radius, 0.0, d);\n    //float drop = clamp(radius-d, 0.0, 1.0);\n    \n    float fade = Saw(0.10, fract(t + rand.y));// b is how fast the dot appears, 1-b is how fast the dot disappears, and it fades at a radom pace (multiply instead)\n    //float fade = saw(fract(t+n.z));\n    float intensity = fract(rand.x*27.);\n    \n    drop *= fade * intensity;\n    return drop;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = (StaticDrops(uv, t))*l0;\n    vec2 m1 = DropLayer2(uv, t, vec2(1.))*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t, vec2(1.))*l2;\n    \n    float c = s+m1.x+m2.x;//return m1;\n    //float c = max(s,max(m1.x,m2.x));\n    //float c = max(m1.x,m2.x);\n    //c = max(S(0.3, 1.0, s), max(S(0.3, 1.0, m1.x), S(0.3, 1.0, m2.x)));\n    c = S(0.3, 1.0, c);\n    \n    //return vec2(c, max(m1.y*l1, m2.y*l2));\n    return vec2(c, m1.y + m2.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;\n    \n    float t = T*.2;\n    \n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\n    //rainAmount = 1.;//\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;\n    \n    float staticDrops = S(-.5, 1., rainAmount)*2.;//staticDrops = 0.;\n    float layer1 = S(.25, .75, rainAmount);//layer1 = 1.;\n    float layer2 = S(.0, .5, rainAmount);//layer2 = 0.;\n    \n    \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    //focus = M.y;//\n    \n    fragColor = vec4(c, focus, t);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 1007]]}
{"id": "ddlyW2", "name": "fye grain", "author": "1fluor", "description": "Shader that combines pretty much everything ive learned about making grain look good\n\n- Using colored grain to give it more depth\n- Using overlay so that colors pop more\n- Mapping it on the midtones to keep clarity\n- Adding bright pixels to make it crispy", "tags": ["noise", "postprocessing", "film", "grain"], "likes": 2, "viewed": 243, "published": 3, "date": "1687221672", "time_retrieved": "2024-07-30T17:48:37.066039", "image_code": "vec3 hash32(vec2 p) {\n    return fract(vec3(\n        sin(dot(p, vec2(127.1, 311.7))),\n        sin(dot(p, vec2(269.5, 183.3))),\n        sin(dot(p, vec2(419.2, 371.9)))\n    ) * 43758.5453);\n}\n\nfloat getLuminance(vec3 color) {\n    return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\n\nvec3 grain(vec2 uv, vec3 col, float intensity, float threshold) {\n      vec3 noise = hash32(uv + vec2(fract(iTime)));\n\n      float crispNoise = step(getLuminance(noise), threshold);\n\n      noise = mix (vec3(0.5), noise, intensity);\n\n      vec3 screen = 1.0 - 2.0 * (1.0 - col) * (1.0 - noise);\n      vec3 mult = 2.0 * col * noise;\n\n      vec3 overlay = mix(screen, mult, step(col, vec3(0.5)));\n\n      vec3 mapMidtones = mix(col, overlay, 1.0 - distance(col, vec3(0.5)));\n\n      vec3 final = mapMidtones + vec3(crispNoise);\n\n      return final;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = grain(uv, col, 0.4, 0.01);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 189], [191, 191, 223, 223, 279], [282, 282, 347, 347, 827], [830, 830, 887, 887, 1042]]}
{"id": "cdsyW2", "name": "pixel fight", "author": "01000001", "description": "https://www.pixelsfighting.com/", "tags": ["cellular", "automaton"], "likes": 0, "viewed": 23, "published": 3, "date": "1687221658", "time_retrieved": "2024-07-30T17:48:37.988572", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float threshold = 6.2;\nconst float random = 6.;\n//try playing with this random.  while running, set to 8, then to 5 and see what happens\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame < 30){\n        float s = floor(mod(iDate.w,3600.));\n        fragColor = vec4(rand(vec2(234, 23049) + s), rand(vec2(2390, 239) * s), rand(vec2(239, 96) - s),1.0);\n        fragColor = uv.x>0.5?fragColor:1.-fragColor;\n    } else {\n        float me = texture(iChannel0, uv).a;\n        \n        vec2 offset[8];\n        offset[0] = vec2(0,  1);\n        offset[1] = vec2(1,  1);\n        offset[2] = vec2(1,  0);\n        offset[3] = vec2(1, -1);\n        offset[4] = vec2(0, -1);\n        offset[5] = vec2(-1,-1);\n        offset[6] = vec2(-1, 0);\n        offset[7] = vec2(-1, 1);\n        float val[8];\n        float sum = 0.;\n        \n\n        //threshold = 6.3 + cos(iTime)*0.2;    ///////////// COMMENT OUT THIS LINE FOR A MORE STANDARD https://pixelsfighting.com/ CLONE\n        \n        for (int i = 0; i<offset.length(); i++)\n        {\n            val[i] = texture(iChannel0, (fragCoord + offset[i])/iResolution.xy).a;\n            \n            sum += val[i];\n        }\n        \n        \n        fragColor = texture(iChannel0, uv);\n        if ((me > .5 && sum < 8.-threshold + rand(fragCoord + iTime + mod(iDate.w, 512.))*random)\n        ||  (me < .5 && sum >    threshold - rand(fragCoord + iTime + mod(iDate.w, 512.))*random)\n        ){\n            fragColor = 1.-fragColor;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]]}
{"id": "mdXcW2", "name": "Spirit Colony", "author": "johnCavatelli", "description": "I think it looks a little cool :)\nFor other newbies: I basically scale the uv grid, and scroll noise over a function that, and fill up the edges of the box based on value of noise texture as a percentage of how 'full' the box is.", "tags": ["uv", "box", "matrix"], "likes": 2, "viewed": 134, "published": 3, "date": "1687207142", "time_retrieved": "2024-07-30T17:48:38.848273", "image_code": "#define PI 3.14159265359\n#define GHOST_MODE\n\nfloat random (in vec2 st) {// 2D Random\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rot(float a){//counterCW rotation matrix\n    float ca= cos(a);\n    float sa= sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;//scale UV\n    vec2 ogUV = uv;//keep origional for noise\n    uv *= 8.;//multiply UV space\n    uv *= rot(iTime*0.01);//rotate it\n    uv = fract(uv);//many tiny boxes\n    uv = uv*2. - 1.;//make space map from -1 to 1 \n    \n    vec3 col;\n    #ifdef GHOST_MODE\n    col = vec3(smoothstep(uv.x,uv.x-0.05,-0.95));//?\n    #else\n    col = vec3(smoothstep(0.9,0.95, uv.x));//only keep edges\n    col += vec3(smoothstep(0.9,0.95, uv.y));\n    col += vec3(step(uv.x,-.95));\n    col += vec3(step(uv.y,-.95));\n    #endif\n    \n    \n    //use 2 layers of scrolling noise, giving what percent full each box should be\n    float perc = noise(-2.5*iTime + (ogUV*10.));\n    perc *= noise(2.*iTime + (ogUV*3.));\n    perc *= 1.8;\n    perc = (2.*PI * perc) - PI;//scale from -pi to pi\n    \n    //if the angle of the pixel to the origin is greater than the percent full, then color it black\n    if(atan(uv.y,uv.x) > perc){col = vec3(0.);}\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 72, 84, 201], [203, 290, 316, 316, 833], [835, 835, 853, 880, 957], [959, 959, 1016, 1016, 2027]]}
{"id": "mdfcD2", "name": "Quadratic bzier curve", "author": "Starfish", "description": "A visualization of a quadratic bzier curve with moving points.", "tags": ["bzier"], "likes": 2, "viewed": 158, "published": 3, "date": "1687206480", "time_retrieved": "2024-07-30T17:48:39.687030", "image_code": "//linear interpolatiion between two points\nvec2 lerp(vec2 p1, vec2 p2, float t){\n    return (1.-t) * p1 + t * p2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    float aspectRatio = iResolution.x/iResolution.y;    \n    uv.x *= aspectRatio;\n\n\n    //points to be used for bezier curve calculation, moving over time due to the added vectors\n    vec2 point1 =  vec2(0.2 *aspectRatio, 0.5) + vec2(0.2 * sin(0.3 * iTime + 32.), 0.4 * cos(0.7 * iTime + 79.));\n    vec2 point2 =  vec2(0.5 *aspectRatio, 0.5) + vec2(0.6 * cos(0.4 * iTime + 823.), 0.4 * sin(0.8 * iTime + 9234.)); \n    vec2 point3 =  vec2(0.8 *aspectRatio, 0.5) + vec2(0.2 * sin(0.1 * iTime + 2423.), 0.3 * cos(0.5 * iTime + 2134.));     \n\n    //points along the bezier curve are calculated and checked for distance to current uv coordinates,\n    //then a circular shape is being drawn for each pixel depending on the closest point in the curve.\n    //since a lot of points are being calculated the circles shape into a line.\n    float closestDistance = 10.;\n    for(float i=0.0; i<1.0;i+=0.001){\n\n        vec2 interpolation12 = lerp(point1, point2, i);\n        vec2 interpolation23 = lerp(point2, point3, i);\n\n        vec2 interpolation123 = lerp(interpolation12, interpolation23, i);\n\n        float currentDistance = distance(uv, interpolation123);\n        closestDistance = min(closestDistance, currentDistance);\n    }\n    \n    float lineWidth = 0.0015;\n    vec3 col = vec3(smoothstep(0.0,  2./iResolution.y, closestDistance - lineWidth));\n    \n    //adding some background color\n    col *= vec3(0.2, 0.4, 0.8);\n    \n    //coloring the 3 points used to calculate the curve\n    float pointRadius = 0.02;\n    vec3 pointColor = vec3(0.9, 0.7, 0.);\n    if(smoothstep(0.0, 2./iResolution.y, distance(uv, point1) - pointRadius) == 0.0){\n        col = vec3(1.-smoothstep(0.0, 2./iResolution.y, distance(uv, point1) - pointRadius)) * pointColor;\n    }\n\n    if(smoothstep(0.0, 2./iResolution.y, distance(uv, point2) - pointRadius) == 0.0){\n        col = vec3(1.-smoothstep(0.0, 2./iResolution.y, distance(uv, point2) - pointRadius)) * pointColor;\n    }\n        \n    if(smoothstep(0.0, 2./iResolution.y, distance(uv, point3) - pointRadius) == 0.0){\n        col = vec3(1.-smoothstep(0.0, 2./iResolution.y, distance(uv, point3) - pointRadius)) * pointColor;\n    }\n\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 80, 80, 115], [118, 118, 175, 225, 2458]]}
{"id": "msfyW2", "name": "Figure and ground fractal 2", "author": "FabriceNeyret2", "description": "inspiration:   https://twitter.com/tobyhoward/status/1653306249310531584\nmouse.xy for manual tuning", "tags": ["fractal", "julia", "mandelbrot"], "likes": 21, "viewed": 256, "published": 3, "date": "1687203340", "time_retrieved": "2024-07-30T17:48:40.526785", "image_code": "// variant of https://shadertoy.com/view/mdfcDj\n\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) ) \n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O *= 0.;\n // float t = mod(iTime/4.,2.); t = min(t,2.-t);\n    for ( int k=0; k < 9; k++ ) {                  // AA loop\n    \n        vec2  R = iResolution.xy, M = iMouse.xy,\n              d = vec2(k%3-1, k/3-1) / 3.,         // AA oversampling\n              z = -2.45* ( 2.*(u+d) - R )  / R.y,  // windowing\n              c = length(M)>9. ? vec2(2,1) * M/R   // manual controm\n                               : vec2(1,.5) * (1. + vec2(cos(iTime),sin(.7*iTime)));\n                            // : vec2(1,.5) + (t-.3)*vec2(-1,1); \n        float r = 4., N = 26.;          \n\n        for ( float i = 0. ; i < N && dot(z,z) < r; i++ )  // Julia loop\n            z = cmul ( c ,  z + cinv(z) );\n\n        O += vec4( z.y < 0. );                     // binary decomposition\n    }\n    O = sqrt(O/9.);                                // to sRGB\n    \n // O = vec4( sqrt(.5 - .5* z.y / fwidth(z.y)) );  // variant without the AA loop\n }\n \n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 1122]]}
{"id": "mdfcDj", "name": "Figure and ground fractal", "author": "FabriceNeyret2", "description": "reference:   https://twitter.com/tobyhoward/status/1653306249310531584\n\nnot exactly the same, but pretty close !", "tags": ["fractal", "julia", "mandelbrot", "reproduction"], "likes": 10, "viewed": 211, "published": 3, "date": "1687202330", "time_retrieved": "2024-07-30T17:48:41.365543", "image_code": "// from draft base https://shadertoy.com/view/dtySD1\n\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) ) \n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O *= 0.;\n    for ( int k=0; k < 9; k++ ) {                  // AA loop\n    \n        vec2  R = iResolution.xy,\n              d = vec2(k%3-1, k/3-1) / 3.,         // AA oversampling\n              z = -2.45* ( 2.*(u+d) - R )  / R.y,  // windowing\n              c = vec2(1.0546875,.4453125); \n        float r = 4., N = 26.;          \n\n        for ( float i = 0. ; i < N && dot(z,z) < r; i++ )  // Julia loop\n            z = cmul ( c ,  z + cinv(z) );\n\n        O += vec4( z.y < 0. );                     // binary decomposition\n    }\n    O = sqrt(O/9.);                                // to sRGB\n    \n // O = vec4( sqrt(.5 - .5* z.y / fwidth(z.y)) );  // variant without the AA loop\n}\n \n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 203, 203, 887]]}
{"id": "cdfcW2", "name": "cursors123", "author": "chenxianming", "description": "fork raymarching template\nhttps://cineshader.com/view/3sySRK\n2d ver\nhttps://www.shadertoy.com/view/mtKXWV", "tags": ["raymarching", "cineshader"], "likes": 1, "viewed": 1095, "published": 3, "date": "1687195899", "time_retrieved": "2024-07-30T17:48:42.360881", "image_code": "#define X 1.5\n#define Y 1.2\n#define perspective 1\n#define arc 1\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat calcSphere( vec3 pos ){\n\n    /*\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    m = (m - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0;\n    \n    if( iMouse.z < .01 ){\n        m = vec2( cos( iTime ) * 3., sin( iTime ) * 3. );\n    }\n    */\n    vec2 m = vec2( cos( iTime ) * 3., sin( iTime ) * 3. );\n    \n    \n    return length( pos - vec3( m, 0. ) ) - .15;\n\n}\n\n\nfloat calcTube(vec3 pos)\n{\n    vec2 m = pos.xy/iResolution.xy;\n    \n    m = vec2( cos( iTime ) * 3., sin( iTime ) * 3. );\n    \n    \n    /*\n    vec2 c = floor(( pos.xz +  vec2( X, Y ) * .5 ) / vec2( X, Y ));\n    pos.xy = mod(\n        pos.xy,\n        vec2( X, Y )\n    ) - vec2( X * .5, Y * .5 );\n    */\n    \n    \n    vec2 h = vec2( X, Y ) * .5;\n    vec2 c = floor(( pos.xy +  vec2( X, Y ) * .5 ) / vec2( X, Y ));\n    pos.xy = mod(pos.xy + vec2( X, Y ) * .5, vec2( X, Y ) ) - vec2( X, Y ) * .5;\n    \n    \n    pos.xy *= rotation( -atan( m.x - ( X ) * c.x, m.y - Y * c.y ) );\n    \n\n    float py = abs( arc == 0 ? pos.y : pow( pos.y, 2. ) - .5 );\n    py = py - .75; // or smoothstep 0~1 py ( .5 = taper )\n    py = abs( py );\n\n    float d = max(\n        length( pos.xz ) - .4 * ( py ),\n        abs( pos.y ) - .45\n    );\n    \n    return d;\n}\n\nfloat map( vec3 pos ){\n    float d = 5.;\n    \n    if( perspective == 1 ){\n        pos.xz *= rotation( cos( iTime ) * .35 );\n    }\n    \n    d = min( d, calcTube(pos) );\n    \n    d = opSmoothUnion( d, calcSphere( pos ), .2 );\n    \n    \n    return d;\n    \n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 117, 117, 216], [219, 219, 243, 243, 309], [311, 311, 340, 560, 680], [683, 683, 709, 709, 1516], [1518, 1518, 1540, 1540, 1772], [1774, 1774, 1804, 1804, 2086], [2089, 2089, 2146, 2146, 2865]]}
{"id": "DdfyRX", "name": "Year of Truchets #040", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)", "tags": ["raymarching", "refraction", "glass", "truchet", "trippy"], "likes": 19, "viewed": 237, "published": 3, "date": "1687188448", "time_retrieved": "2024-07-30T17:48:43.120849", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #040\n    06/19/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Glass effect is refract/reflect in one pass. Almost\n    like interlacing almost.. It's a weird effect but I\n    like the style, and still playing with it.. \n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.141592653\n#define PI2 6.283185307\n\n#define MAX_DIST   30.\n#define MIN_DIST   .001\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.29))) *4832.3734); }\n\n//@iq sdf's + extrude\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h ); return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat box(vec2 p,vec2 b){\n    vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// globals\nfloat gtk,stk,speed;\nvec3 hitPoint,hp,sid,gid;\nmat2 spin;\n\n// constants\nconst float scale = .5;\nconst float hf = .45;\nconst float rd = .015;\nconst float thick = .0375;\n\nvec2 map (in vec3 p) {\n \tvec2 res = vec2(1e5,0);\n    p.xz *= spin;\n    // movement\n    p.y -= speed;\n    \n    // sizing and mixdown\n    gtk = thick;\n    \n    // id grid\n    vec3 id = floor(p*scale), q = fract(p*scale)-.5;\n    gid=id;\n    float hs = hash21(id.xz+id.y);\n    float xhs = fract(35.37*hs);\n\n    if (hs>.75) { q.zy=-q.zy; } else if (hs>.5) { q.xy=-q.xy; }\n \n    vec3 q1,q2,q3;\n    float trh,trx,jre,clip=1e5;\n    \n    //draw\n    if(xhs>.75) {\n        q1 = q;\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(0,hf,hf);\n\n        trh = opx(box(q1.xz,vec2(.5,thick)),q1.y,thick)-rd;\n        trx = opx(abs(box(q2.yz,vec2(.15))-.3)-thick,q.x,thick)-rd;\n        jre = opx(abs(box(q3.yz,vec2(.15))-.3)-thick,q.x,thick)-rd;\n\n    } else {\n        q1 = q + vec3(hf,0,-hf);\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(hf,hf,0);\n        \n        trh = opx(abs(box(q1.xz,vec2(.15))-.3)-thick,q.y,thick)-rd;\n        trx = opx(abs(box(q2.yz,vec2(.15))-.3)-thick,q.x,thick)-rd;\n        jre = opx(abs(box(q3.xy,vec2(.15))-.3)-thick,q.z,thick)-rd;\n\n    }\n    \n    clip = box(vec3(abs(q.x)-.5,q.yz),vec3(thick+.01))-rd;\n    clip=min(clip,box(vec3(q.x,abs(q.y)-.5,q.z),vec3(thick+.01))-rd);\n    clip=min(clip,box(vec3(q.xy,abs(q.z)-.5),vec3(thick+.01))-rd);\n        \n    xhs = fract(35.37*hs); \n    if(trh<res.x) {res = vec2(trh,xhs>.6?2.:1.);hp=p;}\n    if(trx<res.x) {res = vec2(trx,xhs>.6?2.:1.);hp=p;}\n    if(jre<res.x) {res = vec2(jre,xhs>.6?2.:1.);hp=p;}\n\n    if(clip<res.x) {res = vec2(clip,3.);hp=p;}\n    \n \treturn res;\n}\n\nvec3 normal(vec3 p, float t, float mindist){\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n.xz*=spin;// match scene rotation\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n){\n    n = normal(p,d,1.01);\n    vec3 lpos = vec3(.5,15.5,.5);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),.01,.95);\n\n    vec3 h = vec3(0.043,0.078,0.063);\n    float hs = hash21(sid.xz+sid.y);\n    \n    if(m==1.) h=mix(hs>.5?vec3(.42,.21,.04):vec3(.17,.31,0.39),hs>.5?vec3(.19,.09,.01):vec3(.06,.09,.12),smoothstep(.15,.4,tex3D(iChannel0,hitPoint*.5,n).r*.75));\n    \n    if(m==3.) h=mix(vec3(.12,.12,.124),vec3(.067,.07,.071),smoothstep(.2,.15,tex3D(iChannel1,hitPoint*.8,n).r*.75));\n\n    return diff*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    speed =T*.15;\n    spin = rot(T*.03);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    // ray order+direction\n    vec3 ro = vec3(0,0,1.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse //\n    float x = M.xy==vec2(0) || M.z <1. ? 0. :  (M.y/R.y*.5-.25)*PI2;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*1.-.5)*PI2;\n\n    mat2 rx = rot(x), ry = rot(-y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = 1.,k = 1.,d = 0.,a = 0., iv = 1., b = 7.;\n    \n    for(int i=0;i<200;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n        float m = ray.y;\n        d = i<32? ray.x*.85:ray.x;\n        p += rd * d *k;\n        a += d*.425;\n        if (d*d < 1e-8) {\n            hitPoint = hp;\n            sid=gid;\n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            \n            if(m!=2.||b<0.)break;\n            b--;\n            p += rd*.025;\n            k = sign(map(p).x);\n\n            atten *= .5;\n            vec3 rf=refract(rd,n,iv>0.?.875:1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.0025;\n\n        } \n        \n        if(distance(p,rd)>MAX_DIST) {break;}\n    }\n    \n    C = mix(vec3(.059,.082,.078),C,exp(-.025*a*a*a));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfyRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[515, 515, 535, 535, 580], [581, 581, 605, 605, 663], [665, 687, 733, 733, 823], [824, 824, 849, 849, 923], [924, 924, 950, 950, 1030], [1212, 1212, 1234, 1234, 2745], [2747, 2747, 2791, 2791, 3004], [3006, 3006, 3053, 3053, 3296], [3298, 3298, 3368, 3368, 3891], [3893, 3893, 3934, 3934, 5302]]}
{"id": "csscWB", "name": "lined Terrain", "author": "gustav", "description": "2d terrain that uses lines for its visual", "tags": ["contour"], "likes": 5, "viewed": 255, "published": 3, "date": "1687171555", "time_retrieved": "2024-07-30T17:48:43.958610", "image_code": "const float PI = 3.14159, K1 = 0.366025404, K2 = 0.211324865;\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43.7585) * 2. - 1.;\n}\n\nfloat fbm4(vec2 p) {\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    float m = step(a.y, a.x);\n    vec2 o = vec2(m, 1. - m);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1. + 2. * K2;\n    vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.)), dot(b, hash(i + o)), dot(c, hash(i + 1.)));\n    return dot(n, vec3(70.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.), acc = vec3(0.);\n    float lh = -iResolution.y, off = .1 * iTime, h = 0., z = .1, zi = .05;\n    const int l = 10;\n    for (int i = 0; i < l; ++i) {\n        vec2 pOffset = vec2(p.x, z + off);\n        float n = .4 * fbm4(pOffset);\n        h = n - p.y;\n        if (h > lh) {\n            float d = abs(h);\n            col = vec3(smoothstep(1., 0., d * 192.));\n            col *= exp(-.1 * float(i));\n            lh = h;\n        }\n        acc += col;\n        z += zi;\n    }\n    col = sqrt(clamp(acc, 0., 2.));\n    vec3 b = col * col * col;\n    fragColor = vec4(b - vec3(0.0353, 0.2078, 0.6902), b);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csscWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 82, 82, 200], [202, 202, 222, 222, 617], [619, 619, 674, 674, 1408]]}
{"id": "msXcDB", "name": "Yin-Yang for extraterrestrials", "author": "FabriceNeyret2", "description": "reference:   https://twitter.com/tobyhoward/status/1654768432301109250   ", "tags": ["fractal", "julia", "mandelbrot", "reproduction"], "likes": 19, "viewed": 311, "published": 3, "date": "1687160014", "time_retrieved": "2024-07-30T17:48:46.169698", "image_code": "// from draft base https://shadertoy.com/view/dtySD1\n\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O *= 0.;\n    for ( int k=0; k < 9; k++ ) {                  // AA loop\n    \n        vec2  R = iResolution.xy,\n              d = vec2(k%3-1, k/3-1) / 3.,         // AA oversampling\n              z = 1.23* ( 2.*(u+d) - R )  / R.y,   // windowing\n              c = vec2( .346, .06 ); \n        float r = 1.326, N = 144.;\n\n        for ( float i = 0. ; i < N && dot(z,z) < r*r; i++ ) // Julia loop\n            z = cmul(z,z) + c;\n            \n        O += step( z.x , 0. );                     // binary decomposition\n    }\n    O = sqrt(O/9.);                                // to sRGB\n    \n // O = vec4( sqrt(.5 - .5* z.x / fwidth(z.x)) );  // variant without the AA loop\n }\n \n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 147, 147, 820]]}
{"id": "ddXyDB", "name": "Blackhole Impulse", "author": "shamitahmed", "description": "Blackhole effect with electrifying pulses", "tags": ["psychedelic"], "likes": 6, "viewed": 166, "published": 3, "date": "1687156974", "time_retrieved": "2024-07-30T17:48:47.293693", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (uv.xy-0.5);\n\tvec2 cir = ((pos.xy*pos.xy+sin(uv.x*18.0+iTime)/25.0*sin(uv.y*7.0+iTime*1.5)/1.0)+uv.x*sin(iTime)/16.0+uv.y*sin(iTime*1.2)/16.0);\n\tfloat circles = (sqrt(abs(cir.x+cir.y*0.5)*25.0)*5.0);\n\tfragColor = vec4(abs(tan(circles)*0.015),abs(tan(circles)*0.025),abs(tan(circles)*0.05),0.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 408]]}
{"id": "cdsyRl", "name": "Knots portal", "author": "AndrewB330", "description": "Continuation of my experiments with different curve transformations/mappings. Here I'm warping coordinates into circle, then warping coordinate system into 3-string \"braid\" and then applying 4-string \"braid\" sdf to the resulting coordinate + fractal loop.", "tags": ["raymarching", "fractal", "sdf", "curve", "knots", "braids"], "likes": 40, "viewed": 756, "published": 3, "date": "1687155893", "time_retrieved": "2024-07-30T17:48:48.333911", "image_code": "const float M_PI = 3.1415926535;\nconst vec3 LIGHT = normalize(vec3(0.0, 0.0, 1.0));\n\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101\n// https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x, 0., 1.),c.y);\n}\n\nvec3 point_on_curve(float t, int k, float phase, float stretch)\n{\n    float sn = sin(t + phase), \n          cs = cos(t + phase), \n          snk = sin(float(k) * (t + phase)) / float(k);\n    return vec3(cs, t * stretch, snk);\n}\n\nfloat dist_to_point_on_curve_dt(vec3 p, float t, int k, float phase, float stretch)\n{\n    float sn = sin(t + phase), cs = cos(t + phase), snk = sin(float(k) * (t + phase)), csk = cos(float(k) * (t + phase));\n    return 2.0 * (sn * (p.x - cs) - csk * (p.z - snk / float(k)) - stretch * (p.y - stretch * t));\n}\n\nfloat nearest_point_on_curve(vec3 p, int curve, float phase, float stretch)\n{\n    float t = p.y / stretch;\n    for (int i = 0; i < 2;i++)\n    {\n        float dt = dist_to_point_on_curve_dt(p, t, curve, phase, stretch);\n        t -= dt * 0.15;\n    }\n    return t;\n}\n\nfloat sd_curve(vec3 p, int k, float phase, float stretch, float radius)\n{\n    float t = nearest_point_on_curve(p, k, phase, stretch);\n    return (length(point_on_curve(t, k, phase, stretch) - p) - radius) * 0.7;\n}\n\nfloat sd_curve_multi(vec3 p, int k, int n, float phase, float stretch, float radius)\n{\n    float res = 1000.0;\n    for (float i = 0.0; i < float(n); i++)\n    {\n        res = min(res, sd_curve(p, k, M_PI * 2.0 * i / float(n) + phase, stretch, radius));\n    }\n    return res;\n}\n\nvec3 map_circle(vec3 p, float radius)\n{\n    return vec3(length(vec2(p.y, p.x)) - radius, atan(p.y, p.x) * radius, p.z);\n}\n\nfloat approximate_curve_length(float t, float phase, float stretch)\n{\n    // This tries to approximate curve length on the segment [0; t]\n    // But this formula is very inprecise.\n    return t * (pow(stretch * 2.2, 1.8) + 10.12)/10.0\n           - sin((t + phase) * 2.0) * 0.1 * ((0.95 - cos(2.0 * (t + phase))) * 0.83)\n           + sin(phase * 2.0) * 0.095;\n}\n\nvec3 map_curve(vec3 p, float phase, float stretch, float radius, float target_radius)\n{\n    float t = nearest_point_on_curve(p, 2, phase, stretch);\n    float l = approximate_curve_length(t, phase, stretch);\n    vec3 pp = point_on_curve(t, 2, phase, stretch);\n    \n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    float csk = cos(3.0 * (t + phase));\n    \n    vec3 ny = normalize(vec3(-sn, stretch, csk));\n    vec3 nz = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 nx = normalize(cross(ny, nz));\n    nz = normalize(cross(nx, ny));\n    \n    float scale = (1.0 + target_radius) / radius;\n    return vec3(dot(p - pp, nx), l, dot(p - pp, nz)) * scale;\n}\n\nvec4 op(vec4 a, vec4 b)\n{\n    return a.w < b.w ? a : b;\n}\n\nvec4 map(vec3 p)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 1000.0);\n    \n    \n    float scale = 1.0;\n    float t = iTime * 0.4;\n    \n    // Apply partial transform to the first portal ring for seamless transition\n    p.z -= 0.6 * fract(t);\n    p /= pow(1.7, fract(t));\n    scale *= pow(1.7, fract(t));\n    \n    for (int k = 0; k < 5; k++)\n    {\n        vec3 color = hsv2rgb(vec3((floor(t) + float(k)) * 0.1, 0.7, 0.8));\n        float side = 1.0 - 2.0 * float((k + int(floor(t))) % 2);\n        for (int i = 0; i < 3; i++)\n        {\n            vec3 pp = map_circle(p, 6.0);\n            \n            if (length(pp.xz) > 1.4)\n            {\n                res.w = min(res.w, scale * (length(pp.xz) - 1.1));\n                continue;\n            }\n            \n            pp = map_curve(pp, 2.0 * M_PI / 3.0 * float(i) + iTime * 0.5 * side, 2.0, 0.4, 0.4);\n            res = op(res, vec4(color, scale * sd_curve_multi(pp, 3, 4, 0.0 + iTime * 4.0 + sin(iTime + float(i) * M_PI * 0.5) * 4.0, 1.0, 0.3)));\n        }\n        \n        // Apply transform to the next portal ring\n        scale /= 1.7;\n        p *= 1.7;\n        p.z += 0.6;\n    }\n    \n    // Scale down sdf, because it is not really an sdf an we can miss surface.\n    res.w *= 0.35;\n    return res;\n}\n\nvec4 trace(vec3 origin, vec3 dir)\n{\n    float t = 0.;\n    for (int i = 0; i < 24; i++)\n    {\n        vec4 h = map(origin);\n        origin += dir * h.w;\n        t += h.w;\n        if (h.w < 0.01) return vec4(h.rgb, t);\n        if (origin.z < -6.0) break;\n    }\n\n    return vec4(-1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.02;\n    return normalize(e.xyy*map(pos + e.xyy).w +\n\t\t\t\t\t e.yyx*map(pos + e.yyx).w +\n\t\t\t\t\t e.yxy*map(pos + e.yxy).w +\n\t\t\t\t\t e.xxx*map(pos + e.xxx).w);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    vec3   R = iResolution,\n         dir = normalize(vec3( fragCoord - .5* R.xy , -R.y )),\n      origin = vec3(0, 0, 8);\n    \n    vec4 res = trace(origin, dir);\n    if (res.w > 0.)\n    {\n        vec3 n = calcNormal(origin + res.w * dir);\n        float l = clamp(dot(LIGHT, n), 0., 1.) * 0.6 + 0.4;\n        l *= clamp((dir.z * res.w + origin.z) + 0.7, 0.0, 1.0);\n        fragColor = vec4(res.rgb * l, 1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 205, 226, 226, 337], [339, 339, 404, 404, 565], [567, 567, 652, 652, 875], [877, 877, 954, 954, 1141], [1143, 1143, 1216, 1216, 1356], [1358, 1358, 1444, 1444, 1633], [1635, 1635, 1674, 1674, 1756], [1758, 1758, 1827, 1938, 2118], [2120, 2120, 2207, 2207, 2780], [2782, 2782, 2807, 2807, 2839], [2841, 2841, 2859, 2859, 4092], [4094, 4094, 4129, 4129, 4378], [4380, 4426, 4458, 4458, 4651], [4653, 4653, 4710, 4710, 5152]]}
{"id": "DdfczB", "name": "Retro video compression", "author": "maras", "description": "Left panel: uncompressed video\nMiddle panel: interlacing (every second (or more) row is replaced by black one)\nRight panel: every pixel in check pattern is replaced by black one.\n\nPower of compression is changing over time.", "tags": ["video", "retro", "compression"], "likes": 3, "viewed": 169, "published": 3, "date": "1687153960", "time_retrieved": "2024-07-30T17:48:49.296338", "image_code": "vec3 interlacing(vec2 uv, vec2 fragCoord, float compression_power) {\n    vec3 col = vec3(texture(iChannel0, uv));\n    if (mod(fragCoord.y, compression_power) > 0.5) {\n        col = vec3(0.0);\n    }\n    \n    return col;\n}\n\nvec3 checkers_pattern(vec2 uv, vec2 fragCoord, float compression_power) {\n    vec3 col = vec3(texture(iChannel0, uv));\n\n    if ((mod(fragCoord.y, compression_power) > 0.5 || mod(fragCoord.x, compression_power) > 0.5) &&\n        !(mod(fragCoord.y, compression_power) > compression_power - 1.5 && mod(fragCoord.x, compression_power) > compression_power - 1.5)) {\n        col = vec3(0.0);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    int compression_power = int(ceil(abs(sin(iTime / 4.0)) * 4.0)) + 1;\n    \n    if (uv.x < 0.329) col = vec3(texture(iChannel0, uv));\n    if (uv.x > 0.331 && uv.x < 0.659) col = interlacing(uv, fragCoord, float(compression_power));\n    if (uv.x > 0.661) col = checkers_pattern(uv, fragCoord, float(compression_power));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 220], [222, 222, 295, 295, 636], [638, 638, 695, 695, 1135]]}
{"id": "DsfyWB", "name": "Wavy Noise", "author": "johnCavatelli", "description": "Just messing around with some noise functions ", "tags": ["noisewave"], "likes": 3, "viewed": 109, "published": 3, "date": "1687136040", "time_retrieved": "2024-07-30T17:48:50.150055", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform vec2 u_resolution;\nuniform float u_time;\n//Thanks for the help @FabriceNeyret2 !\n\nfloat random (in vec2 st) {// 2D Random\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rot(float a){//counterCW rotation matrix\n    float ca= cos(a);\n    float sa= sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;    \n    vec2 pos = uv * 20.;// Scale the coordinate system \n\n    float n2 = noise(pos * rot(0.1*iTime));\n    float n = noise(pos - n2);\n    \n    // Use the noise function\n    //n = noise(pos);//1: basic\n    \n    //n2= noise(pos);//2: more trippy slanted\n    //n = noise(pos + n2 + n2);\n    \n    //pos *= sin(0.1 * iTime);//space tunnel\n    //n2 = noise(pos);\n    //n = noise(pos * n2);\n    \n    //n2 = noise(pos*abs(0.8*cos(0.2*iTime)));//TOTK type beat\n    //n = noise(pos*rot(n2));//rotateUV(pos,n2));\n    \n    n *= 1. + 0.3 * sin(iTime * 0.2);//make it BREATHE\n    vec2 colUV = uv * rot(-1.1*iTime);//rotate colors background\n    vec3 col = vec3(colUV, 0.5);\n    col *= smoothstep(0.5,0., abs((n-.525)/fwidth(n)));\n    //if(n>0.9){col=vec3(1.0,0.,0.);}//red infiltration\n    fragColor = vec4(col, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 162, 174, 291], [293, 380, 406, 406, 923], [925, 925, 943, 970, 1047], [1049, 1049, 1106, 1106, 1982]]}
{"id": "ddlcRs", "name": "Test: Magnifying glass (Mitsync)", "author": "Mitsync", "description": "Testing rendering a buffer and using that buffer in a distortion/chromatic aberration shader. This is not physically accurate but it looks nice. You can replace iChannel0 with whatever buffer, image, or video you want and it should work.", "tags": ["test", "distortion", "lens", "uv", "glass", "aberration", "buffer"], "likes": 5, "viewed": 221, "published": 3, "date": "1687121097", "time_retrieved": "2024-07-30T17:48:50.921992", "image_code": "// Mitsync 2023\n\n// This does distortions to the source iChannel0 (can be buffer, image, video) and outputs result\n\n// Distortion matrix, every column contains X and Y distortion strength, one column per color channel\nmat3x2 distortion = mat3x2(vec2(0.50), vec2(0.45), vec2(0.40));\nfloat glass_radius = 0.25;\nfloat magnification = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Glass follows mouse\n    vec2 glass_center = iMouse.xy / iResolution.xy;\n    \n    // Normalized pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 dist_uv = uv - glass_center;\n    \n    // Warp UV\n    vec2 uv_r = magnification*dist_uv / (1. - (distortion[0]*length(dist_uv)));\n    vec2 uv_g = magnification*dist_uv / (1. - (distortion[1]*length(dist_uv)));\n    vec2 uv_b = magnification*dist_uv / (1. - (distortion[2]*length(dist_uv)));\n    \n    // If we're looking through the glass\n    float d_to_glass = length((uv-glass_center)*vec2(iResolution.x/iResolution.y, 1.0));\n    if (d_to_glass < glass_radius)\n    {\n        // If we're looking through the glass\n        // Lookup colors from input seperately because of the distortion\n        fragColor.r = texture(iChannel0, uv_r+glass_center).r;\n        fragColor.g = texture(iChannel0, uv_g+glass_center).g;\n        fragColor.b = texture(iChannel0, uv_b+glass_center).b;\n        fragColor.a = 1.0;\n        //fragColor = vec4(0.0);\n    } else if (d_to_glass < glass_radius + 0.02) {\n        // If we're on the edge of the glass\n        // return black\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        // If we're NOT looking through the glass\n        // return base image (iChannel0)\n        fragColor = vec4(texture(iChannel0, uv));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Render an interesting image like shaders normally do but to buffer A instead of out\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates ((0,0) is center, y goes from -1 to 1, aspect ratio preserved)\n    vec2 uv = ((2.0 * fragCoord)-iResolution.xy) / iResolution.y;\n\n    // Reticle\n    //vec3 col = 1.0 < length(uv) ? vec3(0.0) : (0.975 < length(uv) || sign(uv.x) == sign(uv.y)) ? vec3(1.0) : vec3(0.25);\n    \n    // Checkerboard\n    vec3 col = vec3(mod(floor(4.1*uv.x)+floor(4.1*uv.y), 2.0));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 394, 421, 1727]]}
{"id": "DssyRf", "name": "Tapestry 5", "author": "iterati", "description": "Spatial Distortions", "tags": ["ifs"], "likes": 7, "viewed": 262, "published": 3, "date": "1687117788", "time_retrieved": "2024-07-30T17:48:51.828568", "image_code": "float morphStar( in vec2 p, in float r, in float f )\n{\n    float rtn = 0.;\n    float y = sinT(f, 1.);\n    //float y = mod(f, 1.);\n    int n = ((int(f) % 4) + 1) * 4;\n    \n    return (sdCircle(p, r) * (1. - y)) + (sdStar(p, r, n, float(n)) * y);\n}\n\nfloat sheen( in float d, in float x, in float g )\n{\n    return pow(x / abs(d), g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 col = vec3(0.);\n    float d = 0.;\n    \n    // shape morph, sides + radius\n    float f;\n    float g = iTime / 2.5;\n    float h;\n    float z = 0. * PI;\n    g = modf(g, h); // g = frac(0 -> 1), h = whole(0 -> inf)\n    int c = int(h) % 4;\n    int e = int(h / 4.) % 2;\n    float r = ampT(iTime, 30., 4., 3.) * 0.4 + 0.3;\n\n    if (c == 0) {\n      f = (h * 0.25) + (0.5 * g);\n      //r = sin(g * 0.5) * 0.2 + 0.5;\n      z = float(e) * 0.25 * PI;\n    } else if (c == 1) {\n      f = (h + 3.) * 0.25 + (0.5 * g) + 0.5;\n      //r = sin(g * 0.5 + 0.5) * 0.2 + 0.5;\n      z = float(e) * 0.25 * PI;\n    } else if (c == 2) {\n      f = (h + 2.) * 0.25;\n      z = (g * 0.125 * PI) + (float(e) * 0.25 * PI);\n    } else {\n      f = (h + 1.) * 0.25;\n      z = (g * 0.125 * PI) + (0.125 * PI) + (float(e) * 0.25 * PI);\n    }\n\n    //float r = sinT(iTime, 10.) * 0.3 + 0.2;\n    \n    //float x = 1.5;\n\n    //uv = rotate(uv, z);\n\n    d = morphStar(rotate(uv, -z), r, f) * exp(-length(uv0) * sinT(iTime, 5.) * 2.);\n    d = sheen(d, 0.0025, 1.5);\n    col = palette((length(uv0) + sin(iTime)) / 2.0);\n    finalColor += col * d;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        float zz = (int(i) % 2 == 0) ? z : -z;\n        float rot = ((i + 1.) * PI * 0.25) + -zz;\n        uv = rotate(uv, rot);\n        float x = sinT(iTime, 30.) * exp(length(uv) * (i + 1.)) + 0.5;\n        uv = fract(uv * x * (i + 1.)) - 0.5;\n        d = morphStar(uv, r, f);\n        d = sheen(d, (0.0025 * (4. - i)), 1.);\n        col = palette((length(uv0) + sin(iTime) + i + 1.) / 2.0);\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.6); //vec3(0.5);\n    vec3 b = vec3(0.4, 0.3, 0.35); //vec3(0.5);\n    vec3 c = vec3(2.0); //vec3(1.);\n    vec3 d = vec3(0.85, 0.55, 0.25); //vec3(0.0, 0.333, 0.667); //vec3(3.477, 6.066, 1.898);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, in float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( in float t, float l, float a, float b)\n{\n    return abs(cos((t / l) * a * 2. * PI) * cos((t / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 299, 299, 332]]}
{"id": "msXyzl", "name": "Radioactive Lichen 3", "author": "tomachi", "description": "Swap the video for your webcam!\nI seemed to have stumbled upon a method to creative a \"off the wall\" style chrome-key loop.\nThis has a life algorithm but is tainted by also allowing it to migrate to \"greener\" pixel pastures.", "tags": ["2d", "colors", "automata", "life", "cellular", "screensaver", "colours", "lichen", "amoeba"], "likes": 3, "viewed": 389, "published": 3, "date": "1687115207", "time_retrieved": "2024-07-30T17:48:52.805954", "image_code": "/* IMAGE */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define culling(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*\nchannels:\nBuffer A - Cells states\nBuffer B - background trails\nBuffer C - density mask ( used to fill blanks mid-game)\n*/\nvec4 sand(in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec4 part = texture(iChannel3,uv);\n\tfloat c = step(0.1,part.x);\n\tvec3 col=vec3(1.,.9,.8)*c*(1.-abs(uv.x-.5));\n    vec4 fragColor = vec4(col,1.);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float rain = therain(uv).x;\n    if (rain > 0.) { rain = 1.; } \n    float bug =   amoeba(uv).x*1.1;\n    float bugpiss = amoeba(uv).y*0.51;\n    float herbi = habitat(uv).x*0.78;\n    float overgrowth = habitat(uv).y *0.001;\n    float c = culling(uv).x*1.;\n    float red =   c+ bug + bugpiss *0.25 + overgrowth + herbi*0.012349 ;\n    float green = rain + herbi*1.5  + bug*0.1 + bugpiss*0.25;\n    float blue =  c+rain*1.3 + herbi*0.2349 + bug*0.13 + bugpiss*0.00625;\n  \n    fragColor = vec4(red, green, blue, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* AMOEBA/LIFE */\n#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n#define R iResolution.xy\n\n#define webcam(pos) texture(iChannel3, pos)\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define culling(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*float checkPixel(float col, float value) // mapping function\n{\n    if (value >= 0.90001) {\n        return col + value;\n    } else {\n        return 0.;\n    }\n}*/\nbool isHerbivore(vec2 uv) {\n    if (habitat(uv).x > 0.51 && amoeba(uv).y < 0.1) { return true; } else { return false; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    float brightest = 0.;\n    float veges = tex1(uv);\n    float col = tex0(uv);\n    float D = tex3(uv);\n    vec4 colour = amoeba(uv);\n    float bugpiss = colour.y;\n    \n\n    if(iFrame < 2 ) // fill blank space with cells\n    {\n        if (rand(uv)  > 0.27 + uv.y*0.5 ) {\n            fragColor += vec4(rand(uv)) * uv.y*0.5;\n            return;\n        }\n    }\n    if (culling(uv).x > 0.) { fragColor = vec4(0.); return; } \n\n\n\n    int n = 0; // game of life logics\n    float amoeba = 0.; // amoeba logic\n    float onepix = p.x;\n    float twopix = onepix * 2.;\n\n    vec2 lup   = vec2(uv.x-p.x, uv.y-p.y);\n    vec2 ldown = vec2(uv.x-p.x, uv.y+p.y);\n    vec2 rup   = vec2(uv.x+p.x, uv.y-p.y);\n    vec2 rdown = vec2(uv.x+p.x, uv.y+p.y);\n\n    vec2 left = vec2(uv.x+p.x, uv.y);\n    vec2 right= vec2(uv.x-p.x, uv.y);\n    vec2 up   = vec2(uv.x, uv.y-p.y);\n    vec2 down = vec2(uv.x, uv.y+p.y);\n\n    // count neighbours\n    n += int(tex(lup));\n    n += int(tex(ldown));\n    n += int(tex(rup));\n    n += int(tex(rdown));\n\n    n += int(tex(left));\n    n += int(tex(right));\n    n += int(tex(up));\n    n += int(tex(down));\n    if (veges > 0.1) { bugpiss = 0.; }\n    if (n > 5 || bugpiss < 1.1) { col = 0.; bugpiss+=0.01; }   \n\n    //if(col > 0.1 && colour.y == 0.){\n    if(col > 0.1 && bugpiss < 0.1){ \n       if( n == 3) col += 1.; // rebirth\n    }\n    else if(col > .0991 && !(n == 3 || n == 4)) {\n       col = 0.; // overcrowd death\n       colour.y += 1.;// add to the cemetry\n     } \n    // if the cell at 180 degrees around from herbi is not better move here\n    // if to the left, theh check 2 pixels to the left\n\n   if (isHerbivore(lup)) { // diagonal down\n      if(veges < tex1(vec2(uv.x - twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x - twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n   /*\n     if (isHerbivore(ldown)) { // diagonal down\n      if(veges < tex1(vec2(uv.x - twopix, uv.y + twopix))) {\n          col += tex1(vec2(uv.x - twopix, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rup)) { // diagonal up \n      if(veges < thttps://www.shadertoy.com/img/themes/dark/play.pngex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rdown)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n\n    if (isHerbivore(left)) { // left\n      if(veges > tex1(vec2(uv.x - twopix, uv.y))) {\n         col += tex1(vec2(uv.x - twopix, uv.y));\n      } else { col = 0.; }\n    }\n if (isHerbivore(right)) { // right\n      if(veges > tex1(vec2(uv.x + twopix, uv.y))) {\n          col += tex1(vec2(uv.x + twopix, uv.y));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(up)) { // up\n      if(veges > tex1(vec2(uv.x, uv.y - twopix))) {\n          col += tex1(vec2(uv.x, uv.y - twopix));\n      } else { col = 0.1; }\n    }\n    if (isHerbivore(down)) { // down\n      if(veges > tex1(vec2(uv.x, uv.y + twopix))) {\n          col += tex1(vec2(uv.x, uv.y + twopix));\n      } else { col = 0.1; }\n    }*/\n             \n  \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 64.) ) {\n        float r = rand(uv);\n        if (r > 0.1) {\n         \tfragColor = vec4(rand(uv),0.,0,0.);\n        } else {\n          \tfragColor = vec4(0.5,0.,0,0.);\n        }\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n        return;\n    }\n    if (abs(col)>2.)  { col = 0.; } \n\n    fragColor = vec4(col, bugpiss, 0., 0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n/* HABITAT */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos)\n#define tex3(pos) texture(iChannel3, pos).z\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define culling(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float A = tex0(uv);\n    float herbi = amoeba(uv).x;\n    float overgrowth = habitat(uv).y;\n    vec4  B = tex1(uv);\n    float rain = therain(uv).x;\n\n    vec4 veges = vec4(0.);\n    vec4 herbivore = vec4(0.);\n    vec4 colour = habitat(uv);// + vec4(0., amoeba(uv).r*1.1, 0., 0.);\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.)) {\n       fragColor += vec4(uv.y, 0., 0., 0.) ; ///,0.1,uv);\n       return;\n    }\n    \n    if(iFrame < 2 && length(vec2(0.5,0.5) - uv.xy) < 0.581) // fill blank space with cells\n    {\n        if (rand(uv) > 0.9) {\n            fragColor = vec4(rand(uv)*uv.y, 0., 0., 0.);\n           // fragColor = vec4(1.,0.,0.,0.);\n            return;\n        }\n        \n    }\n    if (culling(uv).x > 0. || culling(vec2(uv.x + p.x, uv.y + p.y)).x > 0.) { fragColor = vec4(0.); return; } \n\n    \n    // if i recall correct i was trying to make analog / floating point life\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    herbivore += amoeba(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    herbivore += amoeba(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    herbivore += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y)); // left \n    herbivore += amoeba(vec2(uv.x, uv.y-p.y)); // up\n    herbivore += amoeba(vec2(uv.x, uv.y+p.y)); // down\n    if (herbivore.x > 3.91) { colour = vec4(0.); }\n\n    veges += habitat(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += habitat(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += habitat(vec2(uv.x+p.x, uv.y)); // right\n    veges += habitat(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down\n    if (veges.x < 2.) { veges.x = 0.;  } // colour.y += 0.1;\n\n    float e = veges.x; // convenience\n    float h = herbivore.x; // convenience\n    float bugpiss = herbivore.y*0.5;\n\n   // colour += abs(e)*0.0951951 * rain; // absorb the rain?\n    // growth functino\n    e = clamp(e, 0., 10.);\n    if (e > 0.99 && e < 3.98609) { colour += vec4(bugpiss + e *0.05+uv.y*-0.051, 0., 0., 0.); }\n    if (e > 0.) { \n       colour.y += 0.051;\n    }\n   \n   // if (e > 150. || h > 120.91) colour = vec4(0.);\n    if ( h > 2.91) colour = vec4(0.);\n    colour = abs(colour);\n  \n\n  //if (overgrowth > 0.9) { fragColor = vec4(0.); return; }\n\n    fragColor = colour;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\nfloat rand(vec2 p)\n{ return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }\n\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{ return (v-a1)/(a2-a1)*(b2-b1)+b1; }\n\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nuint seed2 = uint(0);\n\nfloat r(uint s)  // random float\n{ return float(Hash(s)) / 4294967295.0; }\n\nfloat r2(vec2 p) {\n    if(p == vec2(0.)) return r(uint(p.x*100.));\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\n// uper left quadrant\nfloat pixelNoise(vec2 uv) {\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv) {\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\n\nfloat roughNoise1(vec2 uv, int depth, float roughness, uint s) {\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(s), 5.754*r(s)); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness, uint s) {\n    uv += vec2(27.238*r(s), 16.162*r(s+uint(1)));\n\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(s+uint(2)), 5.754*r(s+uint(3))); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}", "buffer_c_code": "/* CULLING PLANE */\n#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define culling(pos) texture(iChannel2, pos)\n#define webcam(pos) texture(iChannel3, pos)\n#define thresh 0.3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    vec4 cam = webcam(uv);\n    if (iFrame <3 ) {\n        fragColor = vec4(0.75) -  vec4(fragCoord,fragCoord.x,fragCoord.y);\n        return;\n     }\n    float bug = amoeba(uv).x;\n    float bugpiss = amoeba(uv).y;\n    float veges = habitat(uv).x;\n    float overgrown = habitat(uv).y;\n    float cull = culling(uv).x ;\n    if (cull > 0.1) { cull *= 0.5; } else { cull = 0.; } \n    if (cam.b > thresh*3. || bugpiss > thresh || overgrown > thresh && cull > 0.) {\n        cull +=32.8;\n    }\n    fragColor = vec4(cull*0.5);\n}", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/* THE RAIN */\n#define A 4\n\n#define rainSpeed 8. // float of A\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define culling(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nfloat hash(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check if there is an arriving particle at this pixel in next frame\nfloat arrivingParticle(vec2 coord, out vec4 partData) {\n\t// scan area from -D to D\n\tvec2 uv = coord / iResolution.xy;\n    float veges = habitat(uv).x;\n    float returnval = 0.;\n    partData = therain(uv);\n\t// scan area from -D to D\n    for (int i=-A; i<A; i++) {\n        for (int j=-A; j<A; j++) {\n            // position to check\n            vec2 arrCoord = coord + vec2(i,j);\n            vec4 data = texture(iChannel3, arrCoord/iResolution.xy);\n            vec4 amoeba = texture(iChannel1, arrCoord/iResolution.xy);\n            // no particles here\n            if (dot(data,data)<1.9991) continue;\n            if (habitat(arrCoord/iResolution.xy).x > 0.1) { // got eaten\n                partData.zw *= vec2(0.95);\n                return 1.;\n            }\n            // get next position of particle\n            vec2 nextCoord = data.xy + data.zw;\n\n            // distance between next position and current pixel\n            vec2 offset = abs(coord - nextCoord);\n            // if the distance is within half a pixel pick this particle\n            // (other arriving particles are dismissed)\n            if (offset.x<.5 && offset.y<.5) {\n                partData += vec4(0.,0., data.zw);\n             //   partData += data;\n                  returnval++;\n//                return 1.;\n            }\n        }\n    }\n    // no particles arriving here\n\treturn returnval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n \t// random particles at the top, xy is position, zw velocity\n    if (fragCoord.y > iResolution.y - float(A) || fragCoord.x > iResolution.x - float(A)) {\n        fragColor = vec4(fragCoord.xy, rainSpeed*0.5 - hash(vec2(uv.x , iTime)) * rainSpeed,rainSpeed*0.5 - hash(vec2(uv.y , iTime)) * rainSpeed); \n        return;\n    }\n   \n    // get the data of a particle arriving at this pixel \n    vec4 partData;\n    float p = arrivingParticle(fragCoord, partData);\n\n    // no particles, empty pixel\n    if (p < 1.) {\n    \tfragColor = vec4(p);\n        return;\n    }\n    \n    // update position with current velocity altered by channels r & b in the video\n    float vel = max(0.,1.-length(texture(iChannel1,fragCoord/iResolution.xy).rb));\n    partData.xy += partData.zw*vel;\n\n    //set particle data\n    fragColor = partData;\n}", "buffer_d_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 494, 525, 525, 736], [737, 737, 794, 794, 1352]]}
{"id": "csscRl", "name": "Cheap AABB", "author": "pizzahollandaise", "description": "Cheap but incorrect distance to an axis aligned bounding box, useful for accelerating ray marching. Effectively box without interio", "tags": ["2d", "distancefield", "sdf", "distance", "aabb"], "likes": 1, "viewed": 176, "published": 3, "date": "1687105874", "time_retrieved": "2024-07-30T17:48:53.659672", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Based on:\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    vec2 size = (maxCorner - minCorner) * 0.5;\n    vec2 center = minCorner + size;\n    vec2 d = max(abs(p - center) - size, 0.0);\n    return dot(d, d);\n}\n\nfloat map(vec2 p) {\n    float bb1 = sqAABB(p,vec2(-abs(sin(iTime)) * 0.5),vec2(abs(cos(iTime))) * 0.5);\n    float bb2 = sqAABB(p,vec2(cos(iTime), 0.0),vec2(cos(iTime)+0.3, 0.3));\n    return sqrt(min(bb1, bb2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = map(p);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = map(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csscRl.jpg", "access": "api", "license": "mit", "functions": [[1219, 1323, 1389, 1389, 1543], [1545, 1545, 1564, 1564, 1757], [1760, 1760, 1817, 1817, 2436]]}
{"id": "dssyzf", "name": "Quiver Plot", "author": "gehtsiegarnixan", "description": "I made my own naive implementation of a simple quiver plot to visualize vector fields. It should be pretty competetive with the other implementations since it does not use ifs and it appears to be more robust and harder to breake. Feel free to use it. ", "tags": ["flow", "arrow", "quiverplot", "vectorfield"], "likes": 4, "viewed": 250, "published": 3, "date": "1687098843", "time_retrieved": "2024-07-30T17:48:54.490451", "image_code": "// The MIT License\n// Copyright  2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nMy Own Quiver Plot Implementation\nA simple and performant quiver plot to visualize vector fields.\nFeel free to use it and enjoy the power of vector visualization! :D\n*/\n\n// Rotate coordinates in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n    float lineThickness = 0.03;    // Thickness of the arrow line\n    float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    float maxSize = 0.9;           // Maximum arrow length (1 should be the max)\n    float minSize = 0.2;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        //return step(arrowDist, 0.0); // no AA\n        float blur = (gridSize * 1.0)/(size * iResolution.y);\n        return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}\n\n// loads noise texture and turns it into flowmap\nvec2 flowTex(vec2 uv) {\n    //a random spot in the noise map, normally you use an actual flowmap\n    vec4 tex = texture(iChannel1, (uv + vec2(0.8,1.0))*0.05); \n    vec2 flowMap = tex.xy;\n    float mask = clamp(2.2-pow(length(uv),2.0), 0.0, 1.0);\n    return (flowMap-.5)*2. * mask; // constant bias scale for -1 to 1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Center screen coords \n    vec2 uv = (fragCoord.xy-(0.5*iResolution.xy))/iResolution.y; \n    \n    float myTime = iTime * 0.1; // slowed down time\n    vec2 flowUV = uv + vec2(cos(myTime),sin(myTime)); //rotating center\n    float spread = mix(4.0, 3.0, sin(0.25*iTime)); //changing donut size\n    \n    // Making flowmap\n    vec2 flowMap = flowTex(flowUV);\n    \n    // Making quiverplot\n    // number of subdivisions for the sampling of the flowmap\n    float gridSize = 15.0; \n    float arrows = 1.0 - quiverPlot(uv, flowMap, gridSize);\n    \n    // Shift flowmap into visible range\n    vec4 viewFlowMap = vec4(flowMap*0.5+0.5,0.5,1.0);\n\n    // Output to screen\n    fragColor = vec4(viewFlowMap * arrows);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssyzf.jpg", "access": "api", "license": "mit", "functions": [[1254, 1296, 1336, 1373, 1560], [1611, 1669, 1728, 1728, 3552], [3554, 3603, 3626, 3699, 3926], [3928, 3928, 3985, 4014, 4695]]}
{"id": "cdfczl", "name": "Tile Pattern", "author": "propagant", "description": "Simple deterministic tile pattern. Inspired by https://www.shadertoy.com/view/mdBSRt\n\nPlayaround with constants. Comment 'SWAY' definition for stable pattern!", "tags": ["pattern", "tiles", "tilefractal"], "likes": 2, "viewed": 169, "published": 3, "date": "1687091395", "time_retrieved": "2024-07-30T17:48:55.250418", "image_code": "const float TILING = 7.;\nconst float TILE_FRACT = 2.0;\nconst float TILE_VAR = 12.;\nconst float ROTATION_SPEED = .1;\nconst vec3 COLOR = vec3(0.4,0.2,0.7);\n\nconst float ZOOM_FACTOR = 1.0;\nconst float SWAY_SPEED = 0.25;\n#define SWAY\n\n#define Rot(a) mat2(sin(a),-cos(a),cos(a),sin(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy )/iResolution.y;\n\t\n\tuv*=Rot(iTime*ROTATION_SPEED);\n\t\n\tfloat a = 0.;\n\t#ifdef SWAY\n\t\ta = cos(uv.x+(iTime+10.)*SWAY_SPEED)*ZOOM_FACTOR;\n\t\tuv = mix(uv,ceil(uv)*1.e-5, a);\n\t#endif\n\t\n\tvec2 ouv = uv;\n\t\n\tuv = fract(uv*TILE_FRACT)/2.;\n\tfloat v = sin(iTime-length(floor(ouv*TILING))*TILE_VAR);\n\tfloat tile = step(uv.x,v)*step(uv.y,0.5);\n\t\n\tfragColor = vec4(vec3(tile*(1.-length(uv-.5)*2.))*COLOR*(1.-clamp(a,0.,1.)), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 340, 340, 807]]}
{"id": "mdlyzf", "name": "Graphic Design Experiment 8", "author": "yasuo", "description": "Graphic Design Experiment 8", "tags": ["graphicdesign", "cineshader"], "likes": 23, "viewed": 1335, "published": 3, "date": "1687080011", "time_retrieved": "2024-07-30T17:48:56.060253", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n\nfloat SimpleVesicaDistanceX(vec2 p, float r, float d) {\n    p.y = abs(p.y);\n    p.y+=d;\n    return length(p)-r;\n}\n\nfloat drawEye(vec2 p){\n    vec2 prevP = p;\n    float d = 0.;\n    \n    float thickness = 0.003;\n    \n    d = abs(length(p)-0.04)-thickness;\n    \n    p*=Rot(radians(iTime*10.));\n    p = DF(p,4.);\n    p-=0.09;\n    p*=Rot(deg45);\n    p.x*=2.0;\n    float d2 = Tri(p,vec2(0.03));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*-15.));    \n    p = DF(p,7.);\n    p-=0.13;\n    p*=Rot(deg45);\n    p.x*=2.0;\n    d2 = Tri(p,vec2(0.03));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*-10.));        \n    p = DF(p,8.);\n    p-=0.155;\n    p*=Rot(deg45);\n    p.x*=2.0;\n    d2 = Tri(p,vec2(0.03));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*-17.));            \n    p = DF(p,10.);\n    p-=0.18;\n    p*=Rot(deg45);\n    p.x*=2.0;\n    d2 = Tri(p,vec2(0.03));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*17.));            \n    p = DF(p,16.);\n    p-=0.2;\n    p*=Rot(deg45);\n    p.x*=2.0;\n    p.y*=-1.;\n    d2 = Tri(p,vec2(0.02));\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    float s = mod(iTime*0.5,2.3);\n    if(s<1.){\n        p.y*=1.+s;\n    } else if(s>=1. && s<2.){\n        p.y*=1.+2.-s;\n    }\n    d2 = abs(SimpleVesicaDistanceX(p,0.5,0.2))-thickness;\n    float d3 = SimpleVesicaDistanceX(p,0.5,0.2);\n    d = max(d3,d);    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat drawHalfMoon(vec2 p){\n    vec2 prevP = p;\n    float d = length(p)-0.05;\n    p.y*=1.2;\n    float d2 = length(p-vec2(-0.025,0.0))-0.05;\n    d = max(-d2,d);\n    return d;\n}\n\nfloat drawSmallEye(vec2 p){\n    p*=1.2;\n    vec2 prevP = p;\n    float thickness = 0.007;\n    float d = abs(length(p)-0.07)-thickness;\n    \n    p*=Rot(radians(30.));\n    p*=1.3;\n    float d2 = drawHalfMoon(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    float s = mod(-iTime*0.3,2.3);\n    if(s<1.){\n        p.y*=1.+s;\n    } else if(s>=1. && s<2.){\n        p.y*=1.+2.-s;\n    }\n    d2 = abs(SimpleVesicaDistanceX(p,0.15,0.05))-thickness;\n    float d3 = SimpleVesicaDistanceX(p,0.15,0.05);\n    d = max(d3,d);    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat arrowItem(vec2 p){\n    p*=vec2(2.3,2.);\n    vec2 prevP = p;\n    p.y-=0.1;\n    p.y*=0.6;\n    float d = Tri(p,vec2(0.06));\n    p.y+=0.04;\n    float d2 = Tri(p,vec2(0.06));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.y+=0.07;\n    p.y*= -1.0;\n    d2 = Tri(p,vec2(0.06));\n\n    p.y+=0.04;\n    d2 = max(-Tri(p,vec2(0.06)),d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat circleItem(vec2 p){\n    p*=1.3;\n    vec2 prevP = p;\n    p*=Rot(radians(-iTime*15.));\n    p = DF(p,6.);\n    p-=0.15;\n    p*=Rot(deg45);\n    float d = arrowItem(p);\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*15.));\n    p = DF(p,2.);\n    p-=0.05;\n    p*=Rot(radians(30.));\n    float d2 = Tri(p,vec2(0.02));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*12.));\n    p = DF(p,3.);\n    p-=0.095;\n    p*=Rot(deg45);\n    p.y*=-1.;\n    p*=1.2;\n    d2 = arrowItem(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat drawGraphics(vec2 p){\n    vec2 prevP = p;\n    float d = drawEye(p);\n    p.x = abs(p.x)-0.5;\n    float d2 = drawHalfMoon(p);\n    p = prevP;\n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.57;\n    p.y = abs(p.y)-0.27;\n    d2 = circleItem(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.25;\n    p.y = abs(p.y)-0.36;\n    p*=Rot(radians(-15.));\n    d2 = drawSmallEye(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.38;\n    p*=0.7;\n    d2 = arrowItem(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.65;\n    p*=Rot(radians(90.));\n    p*=0.7;\n    d2 = arrowItem(p);\n    d = min(d,d2);    \n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float d = drawGraphics(p.xy);\n    d = max(abs(p.z)-0.005,d);\n    return vec2(d*0.6,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,1.0)*skyDiff*occ;\n    diffCol += col*vec3(0.8)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.2));\n    return col;\n}\n\nvec3 ACESFilmic(vec3 x, float a, float b, float c, float d, float e){\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.05);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        //ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    col = ACESFilmic(col,3.,0.03,2.43,0.59,0.14);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 560, 615, 615, 673], [675, 675, 697, 697, 1994], [1996, 1996, 2023, 2023, 2171], [2173, 2173, 2200, 2200, 2720], [2722, 2722, 2746, 2746, 3094], [3096, 3096, 3121, 3121, 3619], [3621, 3621, 3648, 3648, 4273], [4275, 4275, 4297, 4297, 4410], [4412, 4412, 4470, 4470, 4737], [4739, 4739, 4763, 4763, 4964], [4966, 4966, 5008, 5008, 5203], [5205, 5246, 5295, 5295, 5589], [5591, 5591, 5648, 5648, 6261], [6263, 6263, 6322, 6322, 6385], [6387, 6387, 6456, 6456, 6496], [6498, 6498, 6555, 6555, 7326]]}
{"id": "ddlyzf", "name": "moving rainbow bar", "author": "silica163", "description": "moving rainbow bar", "tags": ["2d", "rgb", "rainbow"], "likes": 1, "viewed": 144, "published": 3, "date": "1687079335", "time_retrieved": "2024-07-30T17:48:56.973810", "image_code": "#define pi 3.14159265\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    uv *= pi;\n    \n    vec3 col = vec3(0);\n    \n    /*\n    col.r += (sin(uv.x-iTime*.7+pi*2.)+1.)/2.5;\n    col.g += (sin(uv.x-iTime*.5+(pi*2.)*(1./3.))+1.)/2.5;\n    col.b += (sin(uv.x-iTime*.3+(pi*2.)*(2./3.))+1.)/2.5;\n    */\n    \n    col += (1.+sin(uv.x-iTime*vec3(.7,.5,.3)+pi*2.*vec3(3,1,2)/3.))/2.5;\n    \n    col *= smoothstep(pi,.8,abs(uv.y));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 528]]}
{"id": "ddsczX", "name": "Grounded", "author": "directrix1", "description": "Learning shaders.", "tags": ["learning"], "likes": 2, "viewed": 158, "published": 3, "date": "1687074144", "time_retrieved": "2024-07-30T17:48:57.905320", "image_code": "// Written By: Directrix1\n// Grounded, Just Learning\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float z = uv.y;\n    float falloff = max(0.8 - z, 0.0);\n    float invfalloff = 1.0 - falloff;\n    z = z * z;\n    z = z * z;\n    vec3 col = vec3(falloff, falloff, falloff);\n    col *= texture(iChannel0, (uv - vec2(0.5, 0.0)) * z + vec2(0.0, iTime / -50.0)).rgb;\n    \n    float angle = iTime / 10.0;\n    float scale = sin(iTime / 5.0) + 1.5;\n    vec2 xbasis = vec2(cos(angle), -sin(angle)) * scale;\n    vec2 ybasis = vec2(sin(angle), cos(angle)) * scale;\n    uv -= 0.5;\n    vec2 uv2 = uv.x * xbasis + uv.y * ybasis;\n    uv = uv.x * ybasis + uv.y * xbasis;\n    \n    col += invfalloff * invfalloff * (texture(iChannel0, uv).rgb * texture(iChannel0, uv2).rgb);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 111, 161, 923]]}
{"id": "mslyRX", "name": "Fork reactive m ItsAlmostP 927", "author": "ItsAlmostPG", "description": "audio tunnel\n", "tags": ["tunnel", "audio"], "likes": 3, "viewed": 270, "published": 3, "date": "1687059935", "time_retrieved": "2024-07-30T17:48:58.864755", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bloom = texture(iChannel0,  uv);\n    vec4 base = texture(iChannel1,  uv); \n    \n    fragColor = sqrt(bloom) + base; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat time = 0.1;\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length( p.xz - c.xy ) - c.z;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\nvec2 map(vec3 p)\n{\n\n    vec3 q = p;\n\tp.z -= 0.1 * iTime + sin(iTime * 0.01)* 0.5;\n    vec3 c = vec3(0.53 / 4.0);\n    \n    p.z = mod(p.z,c.z)-0.5*c.z;\n         \n    vec4 noise = texture(iChannel1, floor(q.zz / 1.0));\n    \n    float freq =  atan(p.x, -p.y) / 3.1415 * 2.0 + fract(q.z) * 3.1415 * 2.0;\n    \n    float audio = texture(iChannel0, vec2((freq), 0.0)).r;\n    float audio2 = texture(iChannel0, vec2(fract(0.01*q.z), 0.0)).r;\n    \n  \tfloat r1 = 1.9 ;\n           \n    float r2 = r1 * (1.0 -  audio2);\n        \n    \n    float thickness = 0.02 * audio2;\n\n    \n    float inner = sdCappedCylinder(p.xzy , vec2(r2, 0.5));\n    float outer = sdCappedCylinder(p.xzy, vec2(r1, thickness));\n        \n    float result = opS(inner, outer);\n\n    float theta = iTime + q.z + audio2;\n    float r = 1.0;\n\tfloat ball = length(p + vec3(r * cos(theta), r * sin(theta), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);                  \n\n\tball = length(p + vec3(r * cos(-theta), r * sin(-theta), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n\tball = length(p + vec3(r * cos(theta + 3.1415), r * sin(theta + 3.1415), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n\tball = length(p + vec3(r * cos(-theta + 3.1415), r * sin(-theta + 3.1415), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n    return vec2(result, audio2);\n    \n}\n\n\n// See https://iquilezles.org/articles/palettes for more information\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = iTime  ;\n  //  ro.x -= sin(iTime /5.7);\n  //  ro.y -= cos(iTime /  2.3);\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx).x - map(p-e.yxx).x,\n\t\t\t\t\tmap(p+e.xyx).x - map(p-e.xyx).x,\n\t\t\t\t\tmap(p+e.xxy).x - map(p-e.xxy).x\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n#define MAX_D 20.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.5;\n\n    vec2 _p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 noise = texture(iChannel0, _p).rg;\n\n    vec3 ray = normalize(vec3(_p + noise * 0.01, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, iter = 0.0;\n    vec2 d; \n    vec3 p;\n    \n    for( int i = 0; i < 50; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d.x < 0.001 * pow(depth, 2.0)) {\n\t\t\thit = true;\n            break;\n        }\n        \n        if (depth > MAX_D)\n            break;\n                   \n\t\tdepth += d.x * 0.253; \n\t\titer++; \n    }\n    float ii = 1.0 - iter / 50.0;\n    vec3 col = vec3(ii); \n    if ( hit)\n    col *= pal(d.y, vec3(0.1,0.5,0.1),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n    \n    fragColor = vec4(sqrt(col),1.0);\n    \n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 total = vec4(0.0);\n\tvec2 delta = vec2(1.5, 0.0) / iResolution.x;\n    //const float weights[9] = float[9](0.091637,0.105358,0.1164,0.123573,0.126061,0.123573,0.1164,0.105358,0.091637);\n    const float weights[9] = float[9](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    \n    total += texture(iChannel0, uv - 5.0 * delta) * weights[0];\n    total += texture(iChannel0, uv - 3.0 * delta) * weights[1];\n    total += texture(iChannel0, uv - 2.0 * delta) * weights[2];\n    total += texture(iChannel0, uv - 1.0 * delta) * weights[3];\n    total += texture(iChannel0, uv - 0.0 * delta) * weights[4];\n    total += texture(iChannel0, uv + 1.0 * delta) * weights[5];\n    total += texture(iChannel0, uv + 2.0 * delta) * weights[6];\n    total += texture(iChannel0, uv + 3.0 * delta) * weights[7];\n    total += texture(iChannel0, uv + 5.0 * delta) * weights[8];\n    \n    fragColor = total/9.0;\n        \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 total = vec4(0.0);\n\tvec2 delta = vec2(0.0, 1.5) / iResolution.y;\n    //const float weights[9] = float[9](0.091637,0.105358,0.1164,0.123573,0.126061,0.123573,0.1164,0.105358,0.091637);\n    const float weights[9] = float[9](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    \n    total += texture(iChannel0, uv - 4.0 * delta) * weights[0];\n    total += texture(iChannel0, uv - 3.0 * delta) * weights[1];\n    total += texture(iChannel0, uv - 2.0 * delta) * weights[2];\n    total += texture(iChannel0, uv - 1.0 * delta) * weights[3];\n    total += texture(iChannel0, uv - 0.0 * delta) * weights[4];\n    total += texture(iChannel0, uv + 1.0 * delta) * weights[5];\n    total += texture(iChannel0, uv + 2.0 * delta) * weights[6];\n    total += texture(iChannel0, uv + 3.0 * delta) * weights[7];\n    total += texture(iChannel0, uv + 4.0 * delta) * weights[8];\n    \n    fragColor = total/9.0;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 230]]}
{"id": "cssczf", "name": "Fork HODL ItsAlmostP 459", "author": "ItsAlmostPG", "description": "See comments for details. Use mouse to scrub time.", "tags": ["crypto", "coin", "blockchain", "bitcoin", "btc", "nft", "currency"], "likes": 3, "viewed": 417, "published": 3, "date": "1687058492", "time_retrieved": "2024-07-30T17:48:59.929907", "image_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// I had started a bitcoin texture a couple of years ago but\n// never finished it. With the recent bullrun I got motivated\n// again to finish it. I tried to use symmetries as much as possible\n// but in the end, its still a shitload of manual tweaks because\n// the thing really isn't as symmetrical as it looks. Oww well.\n//\n// Music: Fly Me To The Moon (prod. ibrahim) - Going Spaceward\n// https://soundcloud.com/going-spaceward/fly-me-to-the-moon\n\n//#define SHOW_COIN_TEXTURE\n//#define SHOW_BACKGROUND\n#if HW_PERFORMANCE!=0\n#define USE_AA\n#endif\n \n#define MAX_STEPS 100\n#define MAX_DIST 5.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nvec3 Transform(vec3 p) {\n    vec4 pr = GetProgress(iTime, iMouse.xy/iResolution.xy);\n    \n    float a = 10.*pr.x-4.*pr.x*pr.x;\n    \n    p.xz *= Rot(pr.x*6.2832);\n    p.yz *= Rot(a*6.2832);\n    \n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    \n    p = Transform(p);\n    \n    float \n        dist = length(p.xy),\n        d = dist-.5,\n        side = -sign(p.z);\n    \n    d = max(d, abs(p.z)-.03);\n   \t\n    p.x /= iResolution.x/iResolution.y;\n    \n    vec2 uv = vec2(p.x*side, p.y)+.5;\n    d -= .003*texture(iChannel0, uv).r*S(.0, .01, abs(p.z));\n    \n    float a = atan(p.x, p.y)*200.;\n    d += S(.025, .015, abs(p.z))*(sin(a)+sin(3.*a)*.25+sin(5.*a)*.0625)*.003;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.,dS;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec4 GetNormal(in vec3 p) {\n    vec2 e = vec2(-1., 1.)*1e-3;   \n    float \n        t1 = GetDist(p + e.yxx), \n        t2 = GetDist(p + e.xxy),\n        t3 = GetDist(p + e.xyx), \n        t4 = GetDist(p + e.yyy),\n        c = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n        \n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n        \n    return normalize(i);\n}\n\nvec3 Bg(vec3 rd, float lod) {\n    \n    lod = mix(5., 10., lod);\n    \n    vec3 \n        xy = textureLod(iChannel1, rd.xy+.5, lod).rgb,\n        xz = textureLod(iChannel1, rd.xz+.5, lod).rgb,\n        yz = textureLod(iChannel1, rd.yz+.5, lod).rgb;\n    \n    rd = abs(rd);\n    \n    return rd.x*yz + rd.y*xz + rd.z*xy+pow(rd.z*rd.z, 3.);\n}\n\nvec4 Render(vec2 frag, vec2 res) {\n    vec2 \n        uv = (frag-.5*res.xy)/res.y,\n        m = iMouse.xy/res.xy;\n    \n    vec4 pr = GetProgress(iTime, m);\n    \n    float \n        t = pr.x,\n        alpha = 0.,\n        d;\n    \n    vec3 \n        ro = vec3(0, 0, -4)*mix(.2, 1., S(.5, 0., abs(t-.5))),\n        rd = GetRayDir(uv, ro, vec3(0), 1.),\n        col=vec3(0);\n  \n    vec2 i = RaySphere(ro, rd, vec3(0), .5);\n    \n    \n    if(i.x>-1.) {\n        d = RayMarch(ro, rd);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec4 n = GetNormal(p);\n            vec3 r = reflect(rd, n.xyz);\n\n            p = Transform(p);\n            \n            float \n                bump = WaveletNoise(p.xy*10.,3.,2.),\n                dif = dot(n.xyz, normalize(vec3(1,2,3)))*.5+.5,\n                dirt = 1.-max(0., -n.w);\n            \n            col = Bg(r, max(0., n.w))+dif*.03;\n            col *= vec3(255,150,40)/255.; \n            col *= pow(dirt, 10.);\n            col *= mix(1., bump, .2);\n            \n            vec3 spec = vec3( pow(abs(r.y),10.) );\n            spec *= mix(vec3(1), GetBgCol(iTime)*(1.-pr.z), step(r.y, 0.));\n            col += spec;\n            \n            alpha = 1.;\n        }\n    }\n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(0);\n    \n    #ifdef SHOW_COIN_TEXTURE\n    col = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    #else\n    #ifdef SHOW_BACKGROUND\n    col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    #else\n   \n    col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    \n    vec4 coin = Render(fragCoord, iResolution.xy);  \n    #ifdef USE_AA\n    coin += Render(fragCoord+vec2(.5,0), iResolution.xy);  \n    coin += Render(fragCoord+vec2(0,.5), iResolution.xy);  \n    coin += Render(fragCoord+vec2(.5,.5), iResolution.xy);  \n    coin /= 4.;\n    #endif\n    \n    col = mix(col, coin.rgb, coin.a);\n    #endif\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    // vignette\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    float d = dot(uv, uv);\t\t\n    col /= d*d+1.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Bitcoin texture. \n// I tried to make use of symmetries as much as possible\n// but in the end its just a lot of detail that needs to be hand coded.\n\n#define SS smoothstep\n#define sat(x) clamp(x, 0., 1.)\n\nfloat box(vec2 p, float x, float y, float z, float w, float b) {\n\tfloat \n        v = SS(x-b, x+b, p.x)*SS(z+b, z-b, p.x),\n        h = SS(y-b, y+b, p.y)*SS(w+b, w-b, p.y);\n    return v*h;\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.)) + min(max(p.x, p.y), 0.);\n}\n\nfloat cir(vec2 uv, float x, float y, float r, float w, float b) {\n\treturn SS(w+b, w-b, abs(r-length(uv-vec2(x, y))));\n}\n\nfloat r = .05;\nfloat _A(vec2 uv) {return box(uv, .1, .1, .9, .5, r)-box(uv, .2, .1, .8, .4, r)+(box(uv, .15, .5, .8, .9, r)-box(uv, .25, .5, .7, .8, r));}\nfloat _B(vec2 uv) {\n    uv.y = abs(uv.y-.5);\n    return max(min(box(uv, .1, -.1, .74, .4, r),1.-box(uv, .2, .05, .9, .3, r)), step(.675,uv.x)*cir(uv, .675, .175, .175, .05, r));\n}\nfloat _D(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .2, .8, .8, r);}\nfloat _F(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, 1., .8, r)+box(uv, .1, .1, .2, .5, r);}\nfloat _I(vec2 uv) {return box(uv, .1, .1, .2, .9, r);}\nfloat _L(vec2 uv) {return max(box(uv, .1, .1, .9, .2, r), box(uv, .1, .1, .2, .9, r));}\nfloat _O(vec2 uv) {return _D(uv);}\nfloat _J(vec2 uv) {return min(_O(uv), 1.-box(uv, .0, .3, .8, 1.1, r));}\nfloat _P(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, .8, .8, r)+box(uv, .1, .1, .2, .5, r);}\nfloat _C(vec2 uv) {return min(_O(uv), 1.-box(uv, .5, .4, 1., .6, r));}\nfloat _G(vec2 uv) {return max(min(_O(uv), 1.-box(uv, .5, .5, 1., .7, r)), box(uv, .6, .4, .9, .5, r));}\nfloat _E(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .2, 1., .8, r)+box(uv, .2, .45, .9, .55, r);}\nfloat _M(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .0, .8, .8, r)+box(uv, .45, .1, .55, .8, r);}\nfloat _N(vec2 uv) {\n    return max(box(vec2(abs(uv.x-.5),uv.y), .3, .1, .4, .9, r), \n               box(vec2(uv.x-(.9-uv.y)*.82, uv.y), .1, .1, .25, .9, r));\n}\nfloat _R(vec2 uv) {return _A(uv);}\nfloat _S(vec2 uv) {\n    float y = 1.-uv.x;\n    y = y*y*y*.15;\n    return max(min(max(box(uv, .1, .45, .9, .9, r)\n        -box(uv, .2, .55, .8, .8, r),\n        +box(uv, .8, .1, .9, .6, r)),\n        1.-box(uv, .5, .55, 1., .7, r)),\n               box(vec2(uv.x, uv.y-y), .1, .1, .9, .2, r));\n}\nfloat _T(vec2 uv) {return max(box(uv, .1, .8, .9, .9, r), box(uv, .45, .1, .55, .85, r));}\nfloat _Y(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, .8, 1., r)+box(uv, .45, .1, .55, .5, r);}\nfloat _Z(vec2 uv) {\n    float y = abs(uv.y-.5);\n    float x = uv.y>.5 ? uv.x : 1.-uv.x;\n    return sat(box(vec2(x, y), .1, .3, .9, .4, r)+ \n               box(vec2(uv.y-uv.x*.95+.15, uv.y), .1, .2, .25, .8, r)+\n             box(vec2(x,y), .1, .2, .2, .3, r));\n}\nfloat _dot(vec2 uv) { return SS(.3+r, .3-r, length(uv-vec2(.5)));}\nfloat _ONE(vec2 uv) {return max(max(box(uv, .2, .1, .3, .9, r), box(uv, .1, .1, .4, .2, r)),box(vec2(uv.x, uv.y-uv.x*.5), .1, .66, .26, .785, r));}\nfloat _NINE(vec2 uv) {return _P(vec2(1.-uv.x, uv.y));}\n\n#define _w if(within(uv, c+=s, .0, c+w, 1.)) e +=\n#define _d _w _dot(local(uv, c, .0, c+w, 1.));\n#define _s _w 0.;\n#define _1 _w _ONE(local(uv, c, .0, c+w, 1.));\n#define _9 _w _NINE(local(uv, c, .0, c+w, 1.));\n#define A _w _A(local(uv, c, .0, c+w, 1.));\n#define B _w _B(local(uv, c, .0, c+w, 1.));\n#define D _w _D(local(uv, c, .0, c+w, 1.));\n#define E _w _E(local(uv, c, .0, c+w, 1.));\n#define F _w _F(local(uv, c, .0, c+w, 1.));\n#define G _w _G(local(uv, c, .0, c+w, 1.));\n#define I _w _I(local(uv, c, .0, c+w, 1.)); c-=s*.75;\n#define J _w _J(local(uv, c, .0, c+w, 1.));\n#define L _w _L(local(uv, c, .0, c+w, 1.));\n#define R _w _R(local(uv, c, .0, c+w, 1.));\n#define S _w _S(local(uv, c, .0, c+w, 1.));\n#define T _w _T(local(uv, c, .0, c+w, 1.));\n#define C _w _C(local(uv, c, .0, c+w, 1.));\n#define M _w _M(local(uv, c, .0, c+w, 1.));\n#define N _w _N(local(uv, c, .0, c+w, 1.));\n#define O _w _O(local(uv, c, .0, c+w, 1.));\n#define P _w _P(local(uv, c, .0, c+w, 1.));\n#define Y _w _Y(local(uv, c, .0, c+w, 1.));\n#define Z _w _Z(local(uv, c, .0, c+w, 1.));\n\nfloat Text(vec2 uv) {\n    float \n        e = 0.,\n        c = 0.,\n        w = 1./76.,\n        s = w *.9;\n    \n    if( uv.x<.536) {\n        if(uv.x<.287) {\n            if(uv.x<.145) {\n                _1 T R O Y O Z _s _9 _9 _9 _s\n            } else {\n                c=.14;\n                F I N E _s C O P P E R _s _s\n            }\n        } else {\n            c=.287;\n            if(uv.x<.445) {\n                M J B _s M O N E T A R Y _s \n            } else {\n                c=.44;\n                M E T A L S _s _s\n            }\n        }\n    } else {\n        c = .532;\n\n        if(uv.x<.70) {\n            if(uv.x<.62) {\n                B I T C O I N _d \n            } else {\n                c = .61;\n                D I G I T A L _d\n            }\n        } else {\n            c=.687;\n\n            if(uv.x<.857) {\n                D E C E N T R A L I Z E D _d\n            } else {\n                c=.845;\n                P E E R _s T O _s P E E R\n            }\n        }\n    }\n    return e;\n}\n\nfloat DooHicky(vec2 p, float reps, float h, float w, float x1, float y1, float x2, float y2) {\n    float m = 0.;\n    vec2 lp = local(p, x1,y1,x2,y2);\n    if(lp.y>0. && lp.y<1.&&lp.x>0.&&lp.x<1.) {\n        lp.x-=.5;\n        lp.y = fract(lp.y*reps)-.5;\n        float d = sdBox(lp, vec2(h));\n        m = SS(.1,.0, d)*2.;\n        m = max(m, SS(.05, .0, abs(abs(lp.x)-.15)-w));\n    }\n    return m*.5;\n}\n\nfloat Bitcoin(vec2 uv) {\n    // https://www.shadertoy.com/view/WtGBW1\n    vec2 m = iMouse.xy/iResolution.xy;\n    //uv *= .4; uv -= (m-.5);\n    \n    float \n        e = 0., d, x, y, k, holes, rings, id;\n    r = .05;\n    \n    vec2 \n        st = vec2(atan(uv.x, uv.y)/6.283+.5, length(uv)),\n        lp, //used for local coordinates\n        p = uv;\n    \n    st.x = fract(st.x+.29);\n    if(st.y>.425 && st.y<.462) {\n     \te = Text(local(st, .0917, .425, 1., .462));\n    } else if (st.y>.472 && st.y<.5) {\n    \ty = 1.-(abs(.486-st.y)/.014);\n        e = sat(y*2.);\n    }\n    else \n    if(st.y>.4){ \n        x = fract(st.x*36.-.25);\n        y = remap01(.4, .423, st.y);\n        e = max(e, box(vec2(x, y), .15, .0, .85, 1., r));\n        e = max(e, SS(.2, .1, abs(y-.5))*.5);\n    } else { // center \n        d = sdBox(uv-vec2(-.063,-.198), vec2(.027, .1));  // bottom left\n        d = min(d, sdBox(uv-vec2(.032,-.178), vec2(.027, .12))); // bottom right\n        d = min(d, sdBox(uv-vec2(-.073,.171), vec2(.14, .028)));// top\n        d = min(d, sdBox(uv-vec2(-.04+uv.y*.2,-.18-uv.x*.03), vec2(.12, .031)));//bottom\n        d = min(d, sdBox(uv-vec2(-.07,.198), vec2(.027, .1))); // top left\n        d = min(d, sdBox(uv-vec2(.021,.198), vec2(.028, .1))); // top left\n        d = min(d, sdBox(uv, vec2(.135, .17))); // center fill\n        d = min(d, length((uv-vec2(.075, .101))*vec2(.82,1))-.098);// top arc\n        d = min(d, length((uv-vec2(.075, -.085))*vec2(.82,1))-.12);// bottom arc\n        \n        holes = length((uv-vec2(.02, .092))*vec2(.9,1))-.055;\n        holes = min(holes, sdBox(uv-vec2(-.012,.092), vec2(.034, .055)));   \n        holes = min(holes, length((uv-vec2(.04, -.084))*vec2(.8,1))-.06);\n        holes = min(holes, sdBox(uv-vec2(-.0,-.084), vec2(.045, .06)));\n        \n        d = max(d, -holes);\n \n        y = st.y*78.;\n        id = floor(y);\n        rings = fract(y)-.5;\n        \n        k = 18.\n            +step(abs(st.x-.3)-.2, 0.)\n            -step(abs(st.x-.6)-.05, 0.)*2.;\n        if(d*holes>0. && (id>k||abs(uv.x)<.05)) {\n            r = 0.;\n            // concentric circles\n            if(id>19.&&id<27. && mod(id,2.)==0.) { // resistors\n                float len = .55/(id+1.);\n                float s = remap01(20.,26., id);\n                float ph = mix(.65, .5, pow(s, .8))+.18;\n                x = fract(st.x*4.);\n                r=SS(.01, .0, abs(x-ph)-len);\n            }\n            rings = SS(.2, .0, abs(rings)-r*.2)*mix(.5, 1., r);\n            lp = uv-vec2(-.024,0);\n                \n            if(lp.y>.3&&lp.y<.35&&abs(lp.x)<.075) {\n                x = remap(.3, .35, .075, .015, uv.y);\n                k = step(0., abs(lp.x)-x);\n                rings *= k;\n                x = Min(abs(lp.x-.06), abs(lp.x-.044), abs(lp.x-.027));\n                y = Min(abs(lp.x+.033), abs(lp.x+.054), abs(lp.x+.018));\n                x = min(x, y);\n                rings += (1.-k)*SS(.003,.0, x)*.5;\n            } else if(lp.y<-.3 && lp.y>-.35) {\n                lp.x -=.008;\n                x = remap(-.3, -.35, .078, .015, uv.y);\n                k = step(0., abs(lp.x)-x);\n                rings *= k;\n                x = Min(abs(lp.x-.065), abs(lp.x-.045), abs(lp.x-.028));\n                y = Min(abs(lp.x+.032), abs(lp.x+.053), abs(lp.x+.018));\n                x = min(x, y);\n                rings += (1.-k)*SS(.003,.0, x)*.5;\n            }\n            e = max(e, rings);\n        }\n        \n        e = max(e, SS(.005, .0, abs(d)));\n        \n        // stuff in holes\n        if(holes<-.01) {\n            lp = local(uv, -.038,-.139+.006,-.022-.005,.141-.004);\n            if(lp.x>0.&& lp.x<1.&&lp.y>0.&&lp.y<1.) {\n                y = lp.y;\n                d = length(fract(lp*vec2(1,27))-.5);\n                d = SS(.3, .0, d)*step(.05, abs(abs(y-.573)-.335));\n                e = max(e, d);\n            }\n            e = max(e, DooHicky(uv, 1., .25, .01, -.032,-.137, -.008,-.114));\n            e = max(e, DooHicky(uv, 1., .25, .01, -.032,.069, -.005,.046));\n            \n            d = sdBox(uv-vec2(.045, .097), vec2(.008,.012));\n            d = min(d, sdBox(uv-vec2(-.028,.11), vec2(.001,.008))-.001);\n            \n            r = abs(sdBox(uv-vec2(-.015,.094), vec2(.03,.006))-.03)-.0005;\n            d = min(d, max(r, -uv.x-.02));\n            d = min(d, sdBox(vec2(abs(uv.x)-.012, uv.y-.113), vec2(.008,.012)));\n            \n            \n            lp = uv-vec2(.017,-.014);\n            lp.y = abs(lp.y)-.09;\n            d = min(d, sdBox(lp, vec2(.014,.004)));\n            d = max(d, -sdBox(lp, vec2(.005,.004)));\n            // lines\n            lp.x -= lp.y*.3-.01;\n            lp.y = abs(lp.y-.0016)-.007;\n            d = min(d, sdBox(lp, vec2(.028,.0)));\n            \n            x = abs(abs(uv.x-.03)-.026)-.013;\n            d = min(d, sdBox(vec2(x, uv.y+.068), vec2(.007,.011))-.003);\n           \n            r = sdBox((uv-vec2(-.015,-.083))*vec2(1,1.4), vec2(.04,.0))-.055;\n            r = max(r, uv.x-.056);\n            \n            r = abs(abs(r)-.011)-.0005;\n            d = min(d, max(r, -uv.x-.02));\n                  \n            e = max(e, SS(.003,-.002, d)); \n        }\n        \n        x = abs(abs(uv.y-.03)-.022)-.011;\n        d = sdBox(vec2(uv.x-.22, x), vec2(.013,.004))-.002; \n        d = min(d, sdBox(uv-vec2(.22, .095), vec2(.013,.015))-.002);\n        d = max(d, length(uv)-.24);\n        d = min(d, sdBox(uv-vec2(.22, .04), vec2(.001,.05))+.002);\n        e = max(e, SS(.004, .0, d));\n        \n        lp = uv-vec2(-.28,-.037);\n        \n        if(uv.x<0.) {\n            if(lp.y>.0) {\n                e *= SS(.00, .001, Line(lp,vec2(-.017,.0125),vec2(.08,.105))-.022);\n            \n                d = Line(lp,vec2(0,0),vec2(-.034,.027));\n                d = min(d, Line(lp,vec2(.026,0),vec2(-.021,.04)));\n                d = min(d, Line(lp,vec2(.026,0.025),vec2(-.008,.052)));\n                d = min(d, Line(lp,vec2(.04,0.037),vec2(.006,.065)));\n                d = min(d, Line(lp,vec2(.066,0.037),vec2(.021,.078)));\n                d = min(d, Line(lp,vec2(.068,0.062),vec2(.0365,.094)));\n                d = min(d, Line(lp,vec2(.082,0.075),vec2(.055,.112)));\n                d = min(d, Line(lp,vec2(.095,0.088),vec2(.075,.126)));\n                \n                lp.y = abs(lp.y-.135); \n                d = min(d, Line(lp,vec2(.11,.023),vec2(.14,.023)));\n                d = min(d, Line(lp,vec2(.11,.023),vec2(.097,.0)));\n            } else {\n                d = Line(lp,vec2(.015,-.013),vec2(-.026,-.033));\n                d = min(d, Line(lp,vec2(.03,-.025),vec2(-.009,-.047)));\n                d = min(d, Line(lp,vec2(.045,-.038),vec2(.01,-.063)));\n                d = min(d, Line(lp,vec2(.06,-.051),vec2(.031,-.08)));\n                d = min(d, Line(lp,vec2(.04,-.072),vec2(.045,-.08)));\n                d = min(d, Line(lp,vec2(.09,-.076),vec2(.07,-.09)));\n                d = min(d, Line(lp,vec2(.09,-.12),vec2(.07,-.09)));\n                      \n               e *= SS(.00, .001, Line(lp,vec2(.04,-.06),vec2(-.018,-.01))-.022);\n            }\n            e = max(e, SS(.003, .0, d)*.5);\n        } else {\n            if(uv.y>-.07) {\n                d = Line(uv,vec2(.38,.05),vec2(.3365,.106));\n                d = min(d, Line(uv,vec2(.36,.05),vec2(.326,.095)));\n                d = min(d, Line(uv,vec2(.362,.107),vec2(.349,.107)));\n                d = min(d, Line(uv,vec2(.347,.038),vec2(.3175,.08)));\n                d = min(d, Line(uv,vec2(.336,.026),vec2(.307,.067)));\n                d = min(d, Line(uv,vec2(.325,.014),vec2(.2965,.054)));\n                d = min(d, Line(uv,vec2(.314,.00),vec2(.286,.039)));\n                d = min(d, Line(uv,vec2(.303,-.012),vec2(.275,.024)));\n                d = min(d, Line(uv,vec2(.292,-.025),vec2(.263,.008)));\n                d = min(d, Line(uv,vec2(.28,-.037),vec2(.25,-.01)));\n                d = min(d, Line(uv,vec2(.27,-.05),vec2(.218,-.01)));\n                e *= SS(.00, .001, Line(uv,vec2(.352,.08),vec2(.255,-.05))-.028);\n            } else {\n                d = Line(uv,vec2(.237,-.115),vec2(.278,-.076));\n                d = min(d, Line(uv,vec2(.245,-.127),vec2(.288,-.088)));\n                d = min(d, Line(uv,vec2(.252,-.141),vec2(.297,-.101)));\n                d = min(d, Line(uv,vec2(.26,-.153),vec2(.306,-.114)));\n                d = min(d, Line(uv,vec2(.267,-.165),vec2(.315,-.125)));\n                e *= SS(.00, .001, Line(uv,vec2(.295,-.18),vec2(.323,-.14))-.01);\n                e *= SS(.00, .001, Line(uv,vec2(.259,-.093),vec2(.291,-.147))-.03);\n            }\n            \n            e = max(e, SS(.003, .0, d)*.5);   \n        }\n    }\n    \n     // straight lines\n    y = remap01(-.132, .082, p.y);\n    y += clamp(remap01(.45, .475, st.y),0.,1.)*.05;\n   \n    if(st.y<.475 && y>0. && y<1.) {\n        bool \n            rightSide = (p.x-.197-.19*y>.0 && p.x-.321+.16*y>.0),\n            leftSide = (p.x<-.14 && y>.05 && y<.88 && p.x+p.y*1.2>-.325 && p.x-p.y*1.1>-.24);\n    \n        if ( rightSide || leftSide) {\n            y *= 17.;\n            id = floor(y);\n            y = fract(y)-.5;\n            \n            r = 0.;\n            if(id==7.||id==9.||id==11.)\n                r = SS(.002, .0, abs(p.x-.4)-.015);\n                \n            e = SS(.2, .0, abs(y)-.2*r)*mix(.5, 1., r);\n            \n            // diagonal lines\n            d = sdBox(uv-vec2(.336,-.065), vec2(.03, .03));\n            r = SS(-.2, .2, sin((uv.x+uv.y)*250.));\n            r *= SS(.01, .0, d+.013);\n            d = SS(.003,-.002, d)*.7+r;\n            e = max(e, d); \n        }\n        \n        lp = (uv - vec2(.26,-.063))*.7;\n        d = max(sdBox(lp, vec2(.014,.004)), -sdBox(lp, vec2(.005,.004)));\n        e = max(e, SS(.003, .0, d));\n    }\n    \n    e = max(e, DooHicky(p, 5., .35, .01, -.212,.02, -.159,-.107));\n    e = max(e, DooHicky(p, 2., .35, .05, -.125,-.22, -.099,-.268));\n    e = max(e, DooHicky(p, 2., .3, .05, -.143,.12, -.17,.076));\n    e = max(e, DooHicky(p, 1., .3, .05, -.143,-.141, -.17,-.114));\n   \n    lp = vec2(p.x-step(p.y,0.)*.01, abs(p.y+.004));\n    e = max(e, DooHicky(lp, 1., .2, .02, .045,.245, .095,.205));\n    \n    lp = vec2(p.x-step(p.y,0.)*.01, abs(p.y));\n    e = max(e, DooHicky(lp, 2., .3, .02, -.045,.3, -.005,.35));\n    \n    return e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float e = 0.;\n    \n    vec2 oldRes = texture(iChannel0, vec2(.5)/iResolution.xy).rg;\n    \n    if(oldRes.x!=iResolution.x)\n        e = Bitcoin((fragCoord.xy-.5*iResolution.xy) / iResolution.y);   \n    else\n        e = texture(iChannel0, fragCoord.xy/iResolution.xy).r;\n    \n    if(fragCoord == vec2(1,1))\n        fragColor = vec4(iResolution.xy, 0,0);\n    else    \n        fragColor = vec4(e);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Background layer. See my tutorial about this here:\n// https://www.youtube.com/watch?v=3CycKKJiwis\n\n#define S smoothstep\n#define NUM_LAYERS 4.\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float \n        n = N21(id+offs),\n        n1 = fract(n*10.),\n        n2 = fract(n*100.),\n        a = t+n;\n        \n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat Connect(vec2 a, vec2 b, vec2 uv, float t) {\n    t = .5-abs(t-.5);\n    float \n        d = Line(uv, a, b),\n        d2 = length(a-b),\n        fade = S(1.5, .5, d2+t)*S(.9,.6, t*2.),\n        r = 6./iResolution.y;\n    \n    return S(r, 0., d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float T) {\n    vec2 \n        id = floor(st)+n,\n        p[9];\n\n    float \n        t = iTime+10.,\n        m=0., d, s,\n        pulse, sparkle=0.;\n    \n    st = fract(st)-.5;\n    \n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    for(int i=0; i<9; i++) {\n        m += Connect(p[4], p[i], st, T);\n\n        d = length(st-p[i]);\n\n        s = (.005/(d*d));\n        s *= S(1., .7, d);\n        pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += Connect(p[1], p[3], st, T);\n\tm += Connect(p[1], p[5], st, T);\n    m += Connect(p[7], p[5], st, T);\n    m += Connect(p[7], p[3], st, T);\n    m += sparkle*S(.05, .5, abs(T-.5));\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \n        t, y, m = 0., r, d, glow, moon;\n        \n    vec2 \n        uv = (fragCoord-iResolution.xy*.5)/iResolution.y,\n        M = iMouse.xy/iResolution.xy,\n        st = uv,\n        offs = vec2(0, -y*300.);\n    \n    vec4 p = GetProgress(iTime, M);\n    t = p.x;\n    y = p.z;\n    offs.y = -p.w;\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float \n            size = mix(15., 1., i),\n            fade = S(0., .6, i)*S(1., .8, i);\n            \n        m += fade * NetLayer(st*size-offs, i, t);\n    }\n\t\n    vec3 \n        baseCol = GetBgCol(iTime),\n        col = baseCol*m*.2;\n    \n    glow = max(0., -t*(1.-t)*4.+.5-uv.y);\n    col += baseCol*(exp(offs.y/10.)+glow*glow);\n    \n    y = remap01(1., .92, y);\n    r = .12;\n    st = uv-vec2(0, y);\n    d=length(st);\n    moon = S(.002, -.002, d-r);\n    glow = S(.0,.01,  y)*.0005/(d*d*d);\n    glow = mix(glow, .4, moon);\n    if(d<r) {\n        r = .135; \n        moon *= WaveletNoise(st*5./(sqrt(r*r-d*d)/r), .1, 2.)*.5+.5;\n    }\n    col += moon+glow;\n    \n    fragColor = vec4(min(col,vec3(1)),1);\n}", "buffer_b_inputs": [], "common_code": "float remap01(float a, float b, float t) {\n\treturn (t-a)/(b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n    return ((t-a)/(b-a))*(d-c)+c;\n}\n\nvec2 local(vec2 uv, float x1, float y1, float x2, float y2) {\n\treturn vec2(uv.x-x1, uv.y-y1)/vec2(x2-x1, y2-y1);\n}\nvec2 local(vec2 uv, vec4 p) { return local(uv, p.x, p.y, p.z, p.w);}\n\nbool within(vec2 uv, float x1, float y1, float x2, float y2) {\n\treturn uv.x>x1&&uv.x<x2&&uv.y>y1&&uv.y<y2;\n}\nbool within(vec2 uv, vec4 p) {\n    return within(uv, p.x, p.y, p.z, p.w);\n}\nfloat Line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 \n        pa = p - a, \n        ba = b - a;\n        \n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n\t\n    return length(pa - ba * h);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    float t = dot(s-ro, rd);\n    vec3 p = ro+rd*t;\n    float y = length(s-p);\n    if(y<r) {\n        float x = sqrt(r*r-y*y);\n        return vec2(t-x, t+x);\n    }\n    return vec2(-1, -1);\n}\n\nvec4 GetProgress(float T, vec2 M) {\n    T += M.x/.03; \n    float \n        t = fract(T*.03),\n        y = t*(1.-t)*4.;\n    return vec4(t, 1.-abs(t-.5)*2., y, y*75.);\n}\n\nvec3 GetBgCol(float T) {\n    return vec3(1., .7, .2).brg;\n}\n\nfloat WaveletNoise(vec2 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<4.; i++) {\n        vec2 q = p*s, g=fract(floor(q)*vec2(123.34,233.53));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3;// +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5)*mat2(cos(a),-sin(a),sin(a),cos(a));\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = p*mat2(.54,-.84, .84, .54)+i;\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Min(float a, float b, float c) {\n  return min(a, min(b, c));\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssczf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[961, 961, 985, 985, 1170], [1172, 1172, 1195, 1195, 1633], [1635, 1635, 1669, 1669, 1877], [1879, 1879, 1906, 1906, 2251], [2253, 2253, 2303, 2303, 2497], [2499, 2499, 2528, 2528, 2831], [2833, 2833, 2867, 2867, 4083], [4085, 4085, 4142, 4142, 5016]]}
{"id": "Ddsczf", "name": "My Perlin noise", "author": "saboofa", "description": "This shader uses the random() and noise() functions to create Perlin noise, which is then used to calculate the colour of each pixel.", "tags": ["noise"], "likes": 0, "viewed": 156, "published": 3, "date": "1687058123", "time_retrieved": "2024-07-30T17:49:01.042931", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(mix(random(i + vec2(0.0,0.0)), \n                   random(i + vec2(1.0,0.0)), u.x),\n               mix(random(i + vec2(0.0,1.0)), \n                   random(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    st *= 10.0;\n    float n = 0.0;\n    for (int i = 0; i < 5; i++) {\n        n += noise(st);\n        st *= 2.0;\n    }\n    color.r = sin(n * 2.0 * 3.14159) * 0.5 + 0.5;\n    color.g = sin((n + 0.5) * 2.0 * 3.14159) * 0.5 + 0.5;\n    color.b = sin((n + 1.0) * 2.0 * 3.14159) * 0.5 + 0.5;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddsczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 102], [104, 104, 130, 130, 416], [418, 418, 473, 473, 868]]}
{"id": "DdlcRf", "name": "(WIP) a Wug at TaCoS", "author": "jakel101", "description": "learning some more shader programming by recreating some graphics\nmouse controls the shape of them.", "tags": ["2d", "logo"], "likes": 0, "viewed": 129, "published": 3, "date": "1687052642", "time_retrieved": "2024-07-30T17:49:01.911609", "image_code": "// no additional license restrictions, would love to learn about your projects!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 in the center square)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    // set all pixels to grey\n    vec3 col = vec3(0.23);\n    \n    // slanted blue box on the left\n    float thickness = 0.02;\n    float slant = -0.25;\n    \n    float width = iMouse.x/iResolution.x;\n    if (iMouse.x<=0.0) {width = 0.3;};\n    float height = iMouse.y/iResolution.y;\n    if (iMouse.y<=0.0) {height = 0.5;};\n    vec2 wug_pos = vec2(-0.4, 0.0);\n    \n    \n    float b = smoothstep(width+thickness,width,abs(uv.x-wug_pos.x+(uv.y*slant)));\n    b *= smoothstep(height+thickness,height,abs(uv.y-wug_pos.y));\n    \n    col.b += b;\n    \n    //joke: eye\n    vec2 eye_pos = vec2(wug_pos.x + 0.6*width, wug_pos.y + 0.7*height);\n    float w = 1.0-smoothstep(0.0, thickness, length(uv-eye_pos)- thickness);\n    col += vec3(w);\n    \n    //legs\n    float leg_length = height*0.4;\n    float leg_slant = sin(iTime) * 0.6;\n    //y component first\n    float wug_bottom = wug_pos.y-(height);\n    float l = smoothstep(wug_bottom+thickness, wug_bottom, uv.y-wug_pos.y);\n    l *= smoothstep(wug_bottom-leg_length, wug_bottom-leg_length+thickness, uv.y-wug_pos.y);\n    // x components\n    float l_1 = smoothstep(thickness,0.0,abs(uv.x-wug_pos.x+(uv.y*(slant+leg_slant))));\n    float l_2 = smoothstep(thickness,0.0,abs(uv.x-wug_pos.x+(uv.y*(slant-leg_slant))));\n    l *= (l_1 + l_2); // combine to legs\n    col -= l;\n    \n    //feet\n    float feet_length = leg_length * width;\n    float leg_end = wug_bottom-leg_length;\n    float f = smoothstep(leg_end+thickness, leg_end, uv.y-wug_pos.y);\n    f *= smoothstep(leg_end-thickness, leg_end, uv.y-wug_pos.y);\n    vec2 f_1_pos = vec2(uv.x-wug_pos.x+(uv.y*(slant+leg_slant)), leg_end);\n    vec2 f_2_pos = vec2(uv.x-wug_pos.x+(uv.y*(slant-leg_slant)), leg_end);\n    float f_1 = smoothstep(leg_length+thickness,leg_length,abs(f_1_pos.x-0.15)+feet_length);\n    float f_2 = smoothstep(leg_length+thickness,leg_length,abs(f_2_pos.x-0.15)+feet_length);\n    f *= (f_1 + f_2);\n    col -= f;\n    \n    \n    \n    //add red circle on top\n    float d = length(uv-eye_pos);\n    d -= sin(iTime*2.5)*0.03;\n    d = smoothstep(4.0*thickness, 0.0, d);\n    col.r += d;\n\n    // Output to screen (add alpha)\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 138, 210, 2435]]}
{"id": "DssczX", "name": "(A+B), (A-B), (A-B) / (A+B)", "author": "bcourter", "description": "When working with SDFs, the sum represents local clearance and the difference represents a midsurface.  With unit gradient fields (UGFs), a generalization of SDFs, the sum and difference are always orthogonal fields, creating an interpolation space. ", "tags": ["sdf", "interpolation", "ugf", "twobody"], "likes": 11, "viewed": 3551, "published": 3, "date": "1687050585", "time_retrieved": "2024-07-30T17:49:03.058542", "image_code": "// The sum, difference, and two-body fields.\n// Post: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.0;\nvec2 direction = vec2(1.0, 1.0);\nint viz = 4;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    float angle = (-0.5 + readFloat(2.)) * pi;\n    direction = vec2(cos(angle), sin(angle));\n    viz = int(readFloat(1.) * 5.);\n    \n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    float padding = iResolution.x * (0.3 + cos(iTime) * 0.05);\n    float size = iResolution.x * 0.1 + sin(iTime) * 12.0;\n\n    Implicit a = RectangleUGFSDFCenterRotated(fragCoord, vec2(padding, iResolution.y / 2.0), size * 1.8, iTime * 0.1, vec4(1., 0., 0., 1));\n //   Implicit a = RectangleCenterRotated(fragCoord, vec2(padding, iResolution.y / 2.0), vec2(size * 1.8), iTime * 0.1, vec4(1., 0., 0., 1));\n    Implicit b = Circle(fragCoord, vec2(iResolution.x - padding, iResolution.y / 2.0), size, vec4(0., 0., 1., 1));\n    \n    Implicit shapes = Min(a, b);\n    Implicit sum = Add(a, b);   \n    Implicit diff = Subtract(a, b);\n    Implicit interp = Divide(diff, sum);\n    \n    switch (viz) {\n    case 0:\n        opColor = drawImplicit(shapes, opColor);\n        break;\n    case 1:\n        opColor = drawImplicit(Multiply(sum, 0.5), opColor);\n        break;\n    case 2:\n        opColor = drawImplicit(Multiply(diff, 0.5), opColor);\n        break;\n    case 3:\n        opColor = min(\n            drawImplicit(Multiply(sum, 0.5), opColor),\n            drawImplicit(Multiply(diff, 0.5), opColor)\n        );\n        break;\n    default:\n        opColor = min(\n            drawImplicit(Multiply(interp, 100.), opColor),\n            drawImplicit(Multiply(Subtract(1., Abs(interp)), 100.), opColor)\n        );\n        break;\n    }\n    \n    if (shapes.Distance < 0.)\n        opColor.rgb = min(opColor.rgb, opColor.rgb * 0.65 + shapes.Color.rgb * 0.2);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n //   opColor = DrawVectorField(p3, Divide(shape, length(shape.Gradient)), opColor, 25., 1.);\n    \n    fragColor = opColor;\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}", "buffer_a_code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * 2. - 1., prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _A _ A N D _ _B\n    }\n    else if (data.r < 2. * increment){\n        _A _ PLUS _ _B\n    }\n    else if (data.r < 3. * increment){\n        _A _ MINUS _ _B\n    }\n    else if (data.r < 4. * increment){\n        _A _ PLUS _ _B _ A N D _ _A _ MINUS _ _B\n    }\n    else {\n        LPAREN _A _ MINUS _ _B RPAREN _ SLASH _ LPAREN _A _ PLUS _ _B RPAREN\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,4.0,5)  _V I S U A L I Z A T I O N      \n//    EASYSLIDER(0,0.5)  _O F F S E T  \n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 340, 372, 372, 461], [462, 462, 491, 491, 569], [571, 571, 628, 628, 845], [847, 847, 889, 889, 1354], [1356, 1356, 1397, 1397, 1465], [1467, 1467, 1508, 1508, 1607], [1609, 1609, 1664, 1664, 3751]]}
{"id": "dsXyzf", "name": "purple-blue liquid gradient", "author": "fouad", "description": "purple-blue liquid gradient", "tags": ["gradient", "liquid"], "likes": 20, "viewed": 1546, "published": 3, "date": "1687043467", "time_retrieved": "2024-07-30T17:49:03.859401", "image_code": "/*\n\tThank you to \"MartinRGB\" for the core elements from:\n    https://www.shadertoy.com/view/DttSRB\n*/\n\n#define time iTime\n\nconst float arrow_density = 4.5;\nconst float arrow_length = .45;\n\nconst int iterationTime1 = 20;\nconst int iterationTime2 = 20;\nconst int vector_field_mode = 0;\nconst float scale = 6.;\n\nconst float velocity_x = 0.1;\nconst float velocity_y = 0.2;\n\nconst float mode_2_speed = 2.5;\nconst float mode_1_detail = 200.;\nconst float mode_1_twist = 50.;\n\nconst bool isArraw = true;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n\n\nfloat f(in vec2 p)\n{\n    return sin(p.x+sin(p.y+time*velocity_x)) * sin(p.y*p.x*0.1+time*velocity_y);\n}\n\n\nstruct Field {\n    vec2 vel;\n    vec2 pos;\n};\n\n//---------------Field to visualize defined here-----------------\n\nField field(in vec2 p,in int mode)\n{\n    Field field;\n    if(mode == 0){\n    \tvec2 ep = vec2(0.05,0.);\n        vec2 rz= vec2(0);\n        //# centered grid sampling\n        for( int i=0; i<iterationTime1; i++ )\n        {\n            float t0 = f(p);\n            float t1 = f(p + ep.xy);\n            float t2 = f(p + ep.yx);\n            vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n            vec2 t = vec2(-g.y,g.x);\n            \n            //# need update 'p' for next iteration,but give it some change.\n            p += (mode_1_twist*0.01)*t + g*(1./mode_1_detail);\n            p.x = p.x + sin( time*mode_2_speed/10.)/10.;\n            p.y = p.y + cos(time*mode_2_speed/10.)/10.;\n            rz= g; \n        }\n        field.vel = rz;\n        return field;\n    }\n    \n    if(mode == 1){\n        vec2 ep = vec2(0.05,0.);\n        vec2 rz= vec2(0);\n        //# centered grid sampling\n        for( int i=0; i<iterationTime1; i++ )\n        {\n            float t0 = f(p);\n            float t1 = f(p + ep.xy);\n            float t2 = f(p + ep.yx);\n            vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n            vec2 t = vec2(-g.y,g.x);\n\n            //# need update 'p' for next iteration,but give it some change.\n            p += (mode_1_twist*0.01)*t + g*(1./mode_1_detail);\n            p.x = p.x + sin( time*mode_2_speed/10.)/10.;\n            p.y = p.y + cos(time*mode_2_speed/10.)/10.;\n            rz= g;\n        }\n        \n        field.vel = rz;\n        // add curved effect into curved mesh\n        for(int i=1; i<iterationTime2; i++){\n            //# try comment these 2 lines,will give more edge effect\n            p.x+=0.3/float(i)*sin(float(i)*3.*p.y+time*mode_2_speed) + 0.5;\n            p.y+=0.3/float(i)*cos(float(i)*3.*p.x + time*mode_2_speed) + 0.5;\n        }\n        field.pos = p;\n        return field;\n    }\n    \n    return field;\n}\n//---------------------------------------------------------------\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*20.*arrow_density;\n}\n\nfloat fieldviz(in vec2 p,in int mode)\n{\n    vec2 ip = floor(p*arrow_density)/arrow_density + .5/arrow_density;   \n    vec2 t = field(ip,mode).vel;\n    float m = min(0.1,pow(length(t),0.5)*(arrow_length/arrow_density));\n    vec2 b = normalize(t)*m;\n    float rz = segm(p, ip, ip+b);\n    vec2 prp = (vec2(-b.y,b.x));\n    rz = min(rz,segm(p, ip+b, ip+b*0.65+prp*0.3));\n    return clamp(min(rz,segm(p, ip+b, ip+b*0.65-prp*0.3)),0.,1.);\n}\n\n\nvec3 getRGB(in Field fld,in int mode){\n\n    if(mode == 0){\n        vec2 p = fld.vel;\n        vec3 origCol = vec3(p * 0.5 + 0.5, 1.5);\n        return origCol;\n    }\n    \n    if(mode == 1){\n        vec2 p = fld.pos;\n        float r=cos(p.x+p.y+1.)*.5+.5;\n        float g=sin(p.x+p.y+1.)*.5+.5;\n        float b=(sin(p.x+p.y)+cos(p.x+p.y))*.3+.5;\n        vec3 col = sin(vec3(-.3,0.1,0.5)+p.x-p.y)*0.65+0.35;\n        return vec3(r,g,b);\n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5 ;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= scale;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col;\n    float fviz;\n    \n    int vector_mode = 0;\n    Field fld = field(p,vector_mode);\n    col = getRGB(fld,vector_mode) * 0.85;    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n#define barWidth 0.002\n#define slideValY 0.5\n//(cos(iTime)+1.)/2.\n#define slideValX 0.5\n//(sin(iTime/2.)+1.)/2.\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 567, 567, 650], [767, 767, 803, 803, 2604], [2672, 2672, 2727, 2727, 2859], [2861, 2861, 2900, 2900, 3294], [3297, 3297, 3335, 3335, 3737], [3739, 3739, 3796, 3796, 4119]]}
{"id": "dsscRj", "name": "", "author": "SnoopethDuckDuck", "description": "It's an eye", "tags": ["eye"], "likes": 30, "viewed": 238, "published": 3, "date": "1687015750", "time_retrieved": "2024-07-30T17:49:04.628345", "image_code": "#define res iResolution.xy\n#define pi 3.14159\n#define tanh2(a) ((exp2(a)-1.)/(exp2(a)+1.))\n#define thc(a,b) tanh2((a)*cos(b))/tanh2(a)\n#define ths(a,b) tanh2((a)*sin(b))/tanh2(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\nfloat h11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    float t = iTime;\n    \n    // Intro zoom\n    uv *= mix(9., 1., tanh(t));\n    \n    // Two eyes\n    if (iMouse.z > 0.) {\n        uv *= 1.5;\n        uv.x = sign(uv.x) * (abs(uv.x)-0.65);   \n    }\n    \n    vec3 col = vec3(0);\n       \n    float r1mn = 0.1 - 0.5 * (step(12., t) - step(19., t)); // 0.1 -> -0.4, looks cool  \n    float r1mx = 0.36;\n    float rosc = .5 + .5 * thc(7., t);\n    float r1 = mix(r1mn, r1mx, rosc);\n    float r2 = 0.49; // 0.5\n    \n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    float dr = (d - r1) / (r2 - r1); // rescaled d to [r1,r2] range\n         \n    // store pcol stuff\n    vec3 col2 = vec3(0);\n    \n    float n = 17.;\n    for (float i = n-1.; i >= 0.; i--) {\n        // Split into regions by angle\n        a += pi / n;\n        float sc = floor(0.25*i)+7.;\n        float fa = fract(sc*a/pi + 0.4*cos(3.*d+a*i - 0.08*t)) - 0.5; \n        float ia = floor(sc*a/pi) + 0.5;\n            \n        // mix stuff (?) between r1, r2\n        float osc = (.5+.5*thc(80. * (r2-r1)*(r2-r1), 0.25*pi*h11(i+ia)+ 12.*dr));\n        float r3 = 0.02 + 0.05/cosh(-2.*dr)* osc\n                 + 0.15 /cosh(-34.*abs(d-r1));\n        r3 *= 1.25 - 0.5 * h11(ia);\n         \n        // mix between inner and outer color\n        vec3 pcol = .5 + .5 * cos(2.*pi*(0.4*i/n + 0.45*vec3(0.2,1,2)/3.));\n        vec3 pcol2 = .5 + .5 * cos(2.*pi*(0.8*i/n + 0.*vec3(0.2,1,2)/3.));\n        pcol2 = vec3(2,1.3,0.5) * clamp(1.-dr,0.,1.);       \n        \n        pcol = mix(pcol, mix(pcol2, pcol, 0.*dr*dr+0.9*exp(-3.*dr)), 0.8);\n        pcol = clamp(pcol, 0., 1.);\n        \n        float s = smoothstep(0., 0.04, r3 /d - abs(fa));\n        col = mix(col, pcol, s);       \n    }\n    \n    // Redden and lighten\n    col = mix(col, vec3(1), 0.12/cosh(100.*max(0., 0.8 * r2 - d)));\n    col = mix(col, vec3(1,0.4,0), 0.16/cosh(10.*max(0., 0.8 * r2 - d)));\n    \n    // Apply tint outside eye\n    vec3 tint = mix(vec3(0), vec3(1, .55, .2), 1. / cosh(4.*max(0., d-r2)));\n    col = mix(col, tint * col, 0.4 / cosh(100.*max(0., r2-d))); // do 1. - 1./...\n    \n    // Darken pupil\n    col *= 0.28+0.72 / cosh(200.*max(0.,r1-d));\n    \n    // Blue noise texture\n    float tx = texture(iChannel0,0.5*vec2(a/pi, dr)).r;\n    col *= mix(1., 0.5 + tx, exp(-1.5*dr));\n    \n    // Background bars\n    col *= .65+.35*smoothstep(-0.2, 0.2, 0.65- abs(uv*rot(pi/4.)).x);\n   \n    // Pupil reflections\n    float l = max(0., length(uv - vec2(r1/sqrt(2.)-0.04))-0.015);\n    col = mix(col, vec3(1), exp(-5.*sqrt(l)));\n    float l2 =max(0., length(uv - vec2(0.6,-1)*r1/sqrt(1.+.6*.6))-0.005);\n    col = mix(col, vec3(1), exp(-7.*sqrt(l2)));\n    \n    // Arc reflection\n    float arc = exp(0.4-20.*(abs(d - mix(r1, r2, 0.5))));\n    arc *= clamp((uv*rot(pi/4.)).y + 0., 0., 1.);\n    col += 0.4 * arc;\n\n    // Video\n    vec3 vid = texture(iChannel1, (uv+0.5)).rrr;\n    vec3 vid2 = texture(iChannel2, (uv+0.5)).rrr;\n    vid = mix(col, mix(vid,vid2,rosc), max(0.2 * tanh(0.05*max(0.,t-8.)), step(15., t)));\n    col = mix(vid, col, smoothstep(0., 0.1, d - r1+0.1));\n    \n    // Gamma and saturate\n    col = pow(col, vec3(1./1.2));\n    col *= 1.06;\n    \n    // Clicky\n    if (iMouse.z > 0.)\n        col *= 1.-1. / cosh(100. * abs(ouv.x));\n    \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsscRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 335, 335, 420], [422, 422, 464, 464, 3755]]}
{"id": "cdscz2", "name": "Test: Analog clock (MitSync)", "author": "Mitsync", "description": "A simple analog clock displaying real-time. Smoothing on second hand can be changed around line 55, sizes of the different elements around line 65. Suitable as Lively wallpaper if you so desire. Please note that this AA implementation is bad.", "tags": ["test", "simple", "time", "clock", "antialiasing", "analog", "smoothstep", "wallpaper", "lively"], "likes": 2, "viewed": 190, "published": 3, "date": "1687015000", "time_retrieved": "2024-07-30T17:49:05.738377", "image_code": "// MitSync, 2023\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Calculates if the uv coordinate is on a hand with a certain angle and length\n// hand_size is a vec3 containing start and end distances from the center and width\n//    eg vec3(0.1, 0.5, 0.01) for a short, thin hand. Negative start distance is allowed\nfloat on_hand( in float hand_angle, in vec3 hand_size, in vec2 uv, in float aa_size )\n{\n    // Calculate vector at the hand angle and normal at 90deg to it\n    vec2 hand = vec2(cos(hand_angle), sin(hand_angle));\n    vec2 hand_normal = vec2(cos(hand_angle + .5*M_PI), sin(hand_angle + .5*M_PI));\n    \n    // Calculate (signed) distance from UV point to infinite line through the hand, and line at 90deg to hand\n    float d_hand = dot(uv, hand_normal);\n    float d_norm = dot(uv, hand);\n    \n    // Distance to the normal should be between hand_size.xy and distance to hand less than width hand_size.z\n    // Calculate AA'd rectangle\n    float lum_width = 1. - smoothstep(hand_size.z-aa_size,hand_size.z, abs(d_hand));\n    float lum_length = smoothstep(hand_size.x-aa_size, hand_size.x, d_norm) - smoothstep(hand_size.y-aa_size, hand_size.y, d_norm);\n    return lum_width * lum_length;\n}\n\n// If you really think about it, ticks are just small, static hands\n// Ok not really but we can use the same code to draw them\nfloat on_tick( in vec3 tick_size, in vec2 uv, in float pix_siz )\n{\n    float num_ticks = 12.;\n    float sum = 0.;\n    for (float i = 0.; i < num_ticks; i++) sum += on_hand(2.*M_PI*i/num_ticks, tick_size, uv, pix_siz);\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates ((0,0) is center, y goes from -1 to 1, aspect ratio preserved)\n    vec2 uv = ((2.0 * fragCoord)-iResolution.xy) / iResolution.y;\n    \n    // Size of pixels in UV, used for my poor-mans AA (smoothstep instead of conditionals)\n    float aa_size = 3. / iResolution.y;\n    \n    // Angles of the three hands: x=hour, y=minute, z=second\n    float t = iDate.w;\n    vec3 angles = vec3(0.0);\n    // Calculate angles from time\n    angles.x = 0.5*M_PI - (2.*M_PI * fract(t/(12.*3600.)));\n    angles.y = 0.5*M_PI - (2.*M_PI * fract(t/3600.));\n    \n    // floor(t) to get snapping motion of second hand, smoothstep(fract(t)) to add smoothing\n    // Change jerk_alignment and jerk_length to change snapping feel\n    float jerk_alignment = 1. / 0.50;\n    float jerk_length = 1.20 / 2.;\n    float jerky_t = (floor(jerk_alignment*t)+smoothstep(0.5-jerk_length, 0.5+jerk_length, fract(jerk_alignment*t))) / jerk_alignment;\n    angles.z = 0.5*M_PI - (2.*M_PI * fract(jerky_t/60.));\n    \n    // Make sure angles are within [0, 2*PI)\n    angles.x = angles.x < 0. ? angles.x + 2.*M_PI : angles.x;\n    angles.y = angles.y < 0. ? angles.y + 2.*M_PI : angles.y;\n    angles.z = angles.z < 0. ? angles.z + 2.*M_PI : angles.z;\n    \n    // Calculate contributions of each element of the clock\n    float uv_dist = length(uv);\n    float edge = smoothstep(0.9-aa_size, 0.9, uv_dist) - smoothstep(0.915-aa_size, 0.915, uv_dist);\n    float hub = 1. - smoothstep(0.03-aa_size, 0.03, uv_dist);\n    float tick = on_tick(vec3(0.83, 0.88, 0.008), uv, aa_size);\n    float hour_hand = on_hand(angles.x, vec3(0.075, 0.45, 0.010), uv, aa_size);\n    float minute_hand = on_hand(angles.y, vec3(0.075, 0.7, 0.008), uv, aa_size);\n    float second_hand = on_hand(angles.z, vec3(-0.075, 0.8, 0.005), uv, aa_size);\n\n    // Merge contributions from the different clock elements and output a final color\n    vec3 edge_col = (edge + tick) * vec3(0.322,0.322,0.322);\n    vec3 hand_col = (hub + hour_hand + minute_hand + second_hand) * vec3(1.000,1.000,1.000);\n\n    fragColor = vec4(edge_col + hand_col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdscz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 319, 406, 474, 1204], [1206, 1333, 1399, 1399, 1568], [1570, 1570, 1627, 1726, 3720]]}
{"id": "Dsc3Ds", "name": "Bloody Fixed", "author": "IAI95", "description": "Bloody Fixed", "tags": ["water", "fluid", "blood", "bloody"], "likes": 7, "viewed": 239, "published": 3, "date": "1687004354", "time_retrieved": "2024-07-30T17:49:06.701801", "image_code": "// Fork of \"Bloody\" by huwb. https://shadertoy.com/view/4sKGWw\n// 2023-03-05 10:29:04\n\n// remix of milky: https://www.shadertoy.com/view/Msy3D1\n// which is based in turn on https://www.shadertoy.com/view/Xsd3DB\n\n// turns out two sim steps per frame is important for motion to\n// get nice, fast waves and oscillation\n\n// this makes pretty terrible use of the simulation domain (comment\n// out RAYMARCH to see it) but i like how the result looks at this scale.\n// i should reduce the simulation domain size a la https://www.shadertoy.com/view/4dKGDw\n\n\n#define RAYMARCH\n#define HEIGHTMAPSCALE 99.\n#define MARCHSTEPS 8\n\nfloat hscale = 4.;\n\nvec3 cam( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n    float camRadius = 30.0;\n\tfloat theta = -3.141592653/2.;\n    float xoff = 30.0 * cos(theta);\n    float zoff = 30.0 * sin(theta);\n    cameraPos = vec3(xoff,34.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,-27.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\nfloat h( vec3 p ) { return hscale*texture(iChannel0, p.xz/HEIGHTMAPSCALE + 0.5 ).x; }\n// boost the step size, we resort to the secant method if we overstep the surface\nfloat DE( vec3 p ) { return 1.2 * ( p.y - h(p) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 qq = q*2.-1.;\n    float eps = 0.1;\n    \n#ifdef RAYMARCH\n    \n    vec3 L = normalize(vec3(.3,.9,1.));\n    \n    // raymarch the milk surface\n    vec3 ro;\n    vec3 rd = cam( qq, ro );\n    float t = 0.;\n    float d = DE(ro+t*rd);\n    \n    for( int i = 0; i < MARCHSTEPS; i++ )\n    {\n        if( abs(d) < eps )\n            break;\n        \n        float dNext = DE(ro+(t+d)*rd);\n        \n        // detect surface crossing, if so use secant method\n        // https://www.shadertoy.com/view/Mdj3W3\n\t\tfloat dNext_over_d = dNext/d;\n        if( dNext_over_d < 0.0 )\n        {\n            // estimate position of crossing\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\tdNext = DE( ro+rd*(t+d) );\n        }\n        \n\t\tt += d;\n\t\td = dNext;\n    }\n    \n    // hit the BLOOD\n    {\n        vec3 p = ro+t*rd;\n        \n        // finite difference normal\n        float h0 = h(p);\n        vec2 dd = vec2(0.01,0.);\n        vec3 n = normalize(vec3( h0-h(p + dd.xyy), dd.x, h0-h(p + dd.yyx) ));\n        \n        // diffuse / subtle subsurface\n        float ndotL = clamp(dot(n,L),0.,1.);\n        float dif = 1.52*(0.7+0.3*ndotL);\n        float ao = mix( 0.6, .64, smoothstep(0.,1.,(h0+1.5)/6.));\n        vec4 difCol = vec4(0.82,0.,0.,1.);\n        fragColor = difCol*(dif)*ao;\n        \n        // specular\n        float s = .6*pow( clamp( dot( L, reflect( rd, n ) ), 0., 1. ), 4000. );\n        fragColor += vec4(s, 0.0, 0.0, 1.0);\n    }\n    \n\t// vignette (borrowed from donfabio's Blue Spiral)\n\tvec2 uv =  q.xy-0.5;\n\tfloat distSqr = dot(uv, uv);\n\tfragColor *= vec4(1.0 - 1.*distSqr, 1.0, 1.0, 1.0);\n    \n#else\n    float sh = 1. - texture(iChannel0, q).x;\n    vec3 c = vec3(exp(pow(sh-.25,2.)*-5.), exp(pow(sh-.4,2.)*-5.), exp(pow(sh-.7,2.)*-20.));\n    fragColor = vec4(c, 1.0);\n#endif\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Originally from tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n//\n\n#define HEIGHTMAPSCALE 99.0\n\nvec3 cam( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n    float camRadius = 30.0;\n\tfloat theta = -3.141592653/2.;\n    float xoff = 30.0 * cos(theta);\n    float zoff = 30.0 * sin(theta);\n    cameraPos = vec3(xoff,34.0,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,-27.0);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    float p11 = texture(iChannel0, q).x;\n    float p10 = texture(iChannel1, q-e.zy).x;\n    float p01 = texture(iChannel1, q-e.xz).x;\n    float p21 = texture(iChannel1, q+e.xz).x;\n    float p12 = texture(iChannel1, q+e.zy).x;\n\n    // accel on fluid surface\n    float d = 0.;\n\n    if( iMouse.z > 0. )\n    {\n        vec3 ro;\n        vec3 rd = cam( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            float screenscale = iResolution.x/iResolution.y;\n            d += .06*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n        }\n    }\n    \n    // force from video sampled by buffer B to avoid vid sync problems\n    d += texture(iChannel1, q).y;\n\n    // The actual propagation:\n    d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n    d *= .97; // damping\n    if( iFrame == 0 ) d = 0.;\n    d = d*.5 + .5;\n\n    fragColor = vec4(d, 0.0, 0.0, 1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Originally from tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n//\n\n#define HEIGHTMAPSCALE 99.0\n\nvec3 cam( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n    float camRadius = 30.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = 30.0 * cos(theta);\n    float zoff = 30.0 * sin(theta);\n    cameraPos = vec3(xoff,34.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,-27.0);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    float p11 = texture(iChannel0, q).x;\n\n    float p10 = texture(iChannel1, q-e.zy).x;\n    float p01 = texture(iChannel1, q-e.xz).x;\n    float p21 = texture(iChannel1, q+e.xz).x;\n    float p12 = texture(iChannel1, q+e.zy).x;\n\n    // accel on fluid surface\n    float d = 0.;\n\n    if( iMouse.z > 0. )\n    {\n        vec3 ro;\n        vec3 rd = cam( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            float screenscale = iResolution.x/iResolution.y;\n            d += .06*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n        }\n    }\n    \n    // sample video\n    vec2 vuv = q*3.-vec2(1.,.17);\n    float d_vid = 0.;\n    //if( vuv.x > 0. && vuv.x < 1. && vuv.y > 0. && vuv.y < 0. )\n\t    d_vid = .06*(texture(iChannel2,vuv).x-0.7);\n    d += d_vid;\n    \n    // The actual propagation:\n    d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n    d *= .97; // damping\n    if( iFrame == 0 ) d = 0.;\n    d = d*.5 + .5;\n\n    fragColor = vec4(d, d_vid, 0.0, 1.0);\n}\n\n", "buffer_b_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsc3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 636, 679, 714, 1274], [1277, 1277, 1296, 1296, 1362], [1363, 1445, 1465, 1465, 1496], [1498, 1498, 1555, 1555, 3353]]}
{"id": "msXcWM", "name": "Year of Truchets #039", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n\n2D pattern https://www.shadertoy.com/view/msXcWM", "tags": ["raymarching", "truchet", "tiles"], "likes": 23, "viewed": 291, "published": 3, "date": "1687000409", "time_retrieved": "2024-07-30T17:49:08.522932", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #039\n    06/18/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.1415926\n#define PI2         6.2831853\n\n#define MIN_DIST    .1e-5\n#define MAX_DIST    15.\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 hp,hitpoint;\nvec2 gid, sid;\nfloat speed=0.,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nmat2 cam,sam;\n\nconst float size = 1.5;\nconst float hlf = .75;\nconst float tk = .2;\n    \nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n \n    p.y += speed;\n\n    vec2 uv = mod(p.xy+hlf,size)-hlf;\n    vec2 id = floor((p.xy+hlf)/size);\n    \n    float rnd = hash21(id);\n    if(rnd>.5) uv.y = -uv.y;\n    rnd=fract(rnd*32.23);\n    \n    float sn = hash21(id.yx)*11.;\n    sn = mod(sn,10.);\n    \n    float t1 = lsp(sn,sn+1.,tmod);\n    float t2 = lsp(sn+2.,sn+3.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    cam=rot((t1+t2)*1.5707);\n    uv.xy*=cam;\n    vec3 q = vec3(uv.xy,p.z);\n    vec2 u2 = vec2(length(uv-hlf),length(uv+hlf));\n    vec2 q2 = u2.x<u2.y ? uv-hlf : uv+hlf;\n    \n    float d1 = length(uv)-(.725);\n    float d2 = abs(length(q2)-hlf)-tk;\n    if(rnd>.85) d2 = min(length(q.x)-tk,length(q.y)-tk);\n   \n    d2 = max(d1,-d2);\n    d2 = opx(d2,q.z+.45,6.)-.0125;\n    \n    if(d2<res.x) {\n        res=vec2(d2,2.);\n        hp=q;\n        gid=id;\n        \n    }\n\n    return res;\n}\n\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p) {\n    float d=0.,m=0.;\n    for(int i=0;i<80;i++){\n        vec2 t = map(p);\n        d += i<32? t.x*.4:t.x;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(t.x<d*MIN_DIST||d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n.xy*=sam;\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    vec2 ray = marcher(ro,rd,p);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n     sid = gid; hitpoint = hp; sam = cam;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(5.,17,15);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.15,1.);\n        float shdw = 1.;\n        for( float t = .01; t < 10.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 10.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.45);\n    \n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),0.),24.);\n        vec3 h = vec3(1.);\n        if(m == 2.) {\n            float rnd = hash21(sid);\n            h = rnd>.85?mix(vec3(.4,.4,.5),tex3D(iChannel2,abs(hitpoint*.25),n).rrr,.5):\n            rnd>.65?tex3D(iChannel1,abs(hitpoint*.5),n).rgb:\n            vec3(.91,.30,.15)*tex3D(iChannel0,abs(hitpoint*1.3),n).rrb;\n        }\n        if(m == 3.) h = vec3(.005);\n        ref = h;\n        \n        C = h * diff+max(spec,-shdw);\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,d);\n}\n\n\nvec3 FC = vec3(0.016,0.012,0.004);\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    speed = T*.25;\n    tspeed = T*.6;\n    tmod = mod(tspeed,15.);\n    \n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,11);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    // mouse //\n    float x = M.xy==vec2(0) || M.z<1. ? 0. : -(M.y/R.y*.14-.07)*PI;\n    float y = M.xy==vec2(0) || M.z<1. ? 0. : -(M.x/R.x*.14-.07)*PI;\n    float ff= .1*sin(T*.0879), fx= .1*cos(T*.12);\n    mat2 rx = rot(.28-fx-x), ry = rot(ff-y);\n    \n    ro.zy *= rx;rd.zy *= rx;\n    ro.xz *= ry;rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0),ref = vec3(0), fil = vec3(1);\n    float d = 0., a = 0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC,C,exp(-.0045*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXcWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[364, 364, 382, 382, 427], [428, 428, 449, 449, 504], [505, 505, 542, 542, 576], [577, 577, 596, 596, 623], [625, 625, 671, 671, 764], [949, 949, 967, 967, 1864], [1867, 1867, 1897, 1897, 2136], [2139, 2139, 2185, 2185, 2411], [2413, 2413, 2460, 2460, 2679], [2681, 2681, 2764, 2764, 4042], [4080, 4080, 4121, 4121, 5059]]}
{"id": "Dslczj", "name": "Checkerboard bulge", "author": "evpevdev", "description": "Click on the screen to create a bulge at your cursor.\n\nWorks by displacing the uv coordinates towards the centre of the bulge, according to a function. Generally,the value of this function appears to be the steepness of the bulge.", "tags": ["effect"], "likes": 2, "viewed": 96, "published": 3, "date": "1686997638", "time_retrieved": "2024-07-30T17:49:09.799519", "image_code": "#define PI 3.1415926\n\nfloat checkerboard(vec2 uv, int rows){\n    float value = mod(floor(mod(uv.x*float(rows), 2.0)) + floor(mod(uv.y*float(rows), 2.0)), 2.0);\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 bulgePos = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    bulgePos.x *= iResolution.x/iResolution.y;\n    \n    vec2 uvMoved = uv - bulgePos;\n    float len = length(uvMoved);\n    vec2 dir = (uvMoved)/len;\n    //uv += dir * (pow(2.0, length(uvMoved))-1.0) * 1.0;\n    //uv += dir * pow(smoothstep(0.0, 1.0, length(uvMoved)), 1.0) * 0.5;\n    //uv += dir * pow(length(uvMoved), 2.0) * 1.0;\n    \n    // Displace the uv coordinates towards the centre of the bulge\n    // Generally,the value of this function appears to be the steepness.\n    uv -= dir * (0.02 * len)/(pow(len, 6.0)+0.045);\n    \n    vec4 col1 = vec4(0.2, 0.80, 0.42, 1);\n    vec4 col2 = vec4(0.02, 0.4, 0.12, 1);\n    vec3 col = vec3(mix(col1, col2, checkerboard(uv, 6)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dslczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 60, 60, 179], [182, 182, 239, 289, 1177]]}
{"id": "cslczj", "name": "Bloom Downsampling Filter", "author": "TinyTexel", "description": "A downsampling filter designed to be used in a bloom downsampling chain.\nThe implementation uses 9 bilinear samples to emulate a 6x6 kernel.", "tags": ["antialiasing", "filtering", "bloom", "downsampling"], "likes": 10, "viewed": 331, "published": 3, "date": "1686997293", "time_retrieved": "2024-07-30T17:49:11.001306", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm/status/1673425464579194883\n\n/*\n    A downsampling filter designed to be used in a bloom downsampling chain.\n    The implementation uses 9 bilinear samples to emulate a 6x6 kernel.\n    \n    This filter produces less residual aliasing than the commonly used 13 (bilinear) samples kernel.\n    \n    It is, however, less forgiving with regard to sloppy implementations: \n    it is important that the sample positions are properly aligned with the texel grid of the source texture.\n        \n    The main difference between the implementations of both filters is that the 13 samples kernel limits itself to always sample exactly\n    in the center of a 2x2 texel group, which the the 9 samples kernel does not.\n    \n    (As a result, I think optimizing the 13 samples kernel using shared memory might be more straightforward than it is for the 9 samples variant.)\n    \n    Optimized sample weights for the 13 samples kernel are also provided.\n    \n    EDIT:\n    \n    The idea to use just 9 samples is not new: Mikkel Gjoel already described this approach in 2016 (his parameters are different from mine, though).\n    \n    Also, turns out it is important to make sure that the bilinear sampler doesn't mess with the texcoord offsets in a way that corrupts the\n    symmetry of the filter kernel. Otherwise the resulting error amplifies when the filter is repeatedly applied in a mipchain.\n    For that reason, I pre-quantize all relevant texcoord offsets used by the 9 samples kernel designs.\n    \n    \n    left : filtered test image\n    right: amplitude spectrum\n    \n    Downsampling is turned off by default.\n    If downsampling is active a small amount of jittering is applied to the test image. This helps to highlight the residual aliasing.\n    \n    Shift - toggle on/off low amplitude highlighting (useful to ensure that filter response is symmetrical)\n    Space - toggle downsampling on/off (square shaped indicator)\n    Tab   - toggle test image between white noise and texture\n    Ctrl  - toggle thresholding of test image on/off (useful to test kernel shape)\n1,2,3,4,5 - change filter kernel (circular indicators):\n\n        1 -  9 samples kernel (optimized stop-band)\n        2 -  9 samples kernel with improved radial symmetry (but more aliasing)\n        3 -  9 samples kernel with params by Mikkel Gjoel (\"The Rendering of Inside, High Fidelity, Low Complexity\" (GDC 2016))\n        \n        4 - 13 samples kernel with optimized weights\n        5 - 13 samples kernel from \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n    \n    \n    Buffer A: test image creation\n    Buffer B: filtering/downsampling implementation\n    Buffer C: horizontal discrete Fourier transform\n    Buffer D: vertical   discrete Fourier transform\n    Image   : visualization\n    \n    \n    Related:\n    \n        practical implementation of the down-sampling filters in a complete bloom mipchain: \"Bloom.\"\n        https://www.shadertoy.com/view/mdsyDf\n        \n        13 samples kernel design: \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n        http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n        \n        9 samples kernel that tries to match the original 13 samples kernel: \"The Rendering of Inside, High Fidelity, Low Complexity\" (GDC 2016)\n        https://loopit.dk/rendering_inside.pdf#page=17\n        https://twitter.com/pixelmager/status/1691731512004071785\n*/\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(false)\n    {\n        // show test image\n        ivec2 uvi = ivec2(uv0 - 0.5);\n        \n        vec3 col = texelFetch(iChannel2, uvi, 0).rgb;\n\n        col = pow(col, vec3(1.0/2.2));\n        \n        outCol = vec4(col, 1.0);\n        \n        return;\n    }\n    \n    float b = ceil((iResolution.y - SIZE)*0.5);\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // fft\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        amp *= 0.005;\n        \n        // amp = sqrt(amp);\n        \n        float b = 16.0;\n        amp = log2(amp * b + 1.0) / log2(b + 1.0);\n        \n        col = vec3(amp);\n\n        #if 1\n        if(ReadKeyToggle(KEY_SHIFT) != 0.0)\n        {\n            // highlight low amplitudes\n            if(amp <= exp2(-8.0)) col = sqrt((amp*exp2(8.0)))* vec3(.0, 0.0, 1.0);\n        }\n        #endif\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // input\n        float n = texelFetch(iChannel0, ivec2(uv0-0.5), 0).x;\n        \n        col = pow(clamp01(vec3(n)), vec3(1.0/2.2));\n    }\n    \n    {\n        vec2 uv = uv0;\n\n        float filterType = texelFetch(iChannel2, ivec2(0, 0), 0).a;\n\n        if(ReadKeyToggle(KEY_CTRL) != 0.0) col = 1.0 - col;\n        \n        // circular filter type indicators\n        uv -= 16.0;    \n        float l = length(uv);\n        col *= min(max(clamp01(l - 10.0), 1.0 - clamp01(l - 6.0)), filterType == 0.0 ? clamp01(l - 4.0) : 1.0);\n        uv.x -= 24.0;\n        l = length(uv);\n        col *= min(max(clamp01(l - 10.0), 1.0 - clamp01(l - 6.0)), filterType == 1.0 ? clamp01(l - 4.0) : 1.0);\n        uv.x -= 24.0;\n        l = length(uv);\n        col *= min(max(clamp01(l - 10.0), 1.0 - clamp01(l - 6.0)), filterType == 2.0 ? clamp01(l - 4.0) : 1.0);\n        uv.x -= 24.0;\n        l = length(uv);\n        col *= min(max(clamp01(l - 9.0), 1.0 - clamp01(l - 4.0)), filterType == 3.0 ? clamp01(l - 2.0) : 1.0);\n        uv.x -= 24.0;\n        l = length(uv);\n        col *= min(max(clamp01(l - 9.0), 1.0 - clamp01(l - 4.0)), filterType == 4.0 ? clamp01(l - 2.0) : 1.0);\n        \n        // square shaped downsampling indicator\n        uv.x -= 32.0;\n        l = max(abs(uv.x), abs(uv.y));\n        col *= min(max(clamp01(l - 10.0), 1.0 - clamp01(l - 6.0)), DO_DOWNSAMPLE_COND ? clamp01(l - 4.0) : 1.0);\n        \n        if(ReadKeyToggle(KEY_CTRL) != 0.0) col = 1.0 - col;\n        \n    }\n\n    outCol = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\n#define READ_TEXTURE_COND (ReadKeyToggle(KEY_TAB) != 0.0)\n#define DO_DOWNSAMPLE_COND (ReadKeyToggle(KEY_SPACE) != 0.0)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. ONeill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n    backups\n\n        BloomKernel9B\n    // radial symmetry + half Nyquist = 0 (along x & y)\n        (oa      , ob  )   aliasing       radial symmetry \n        (0.290956, 0.20)   -------------- ------------\n        (0.291459, 0.21)   -----------    -----------\n        (0.291945, 0.22)   --------       ----------\n        (0.292413, 0.23)   -----          ---------\n        (0.292864, 0.24)   ----           --------\n        (0.293298, 0.25)   ---            -------\n        (0.293714, 0.26)   --             ------\n        (0.294112, 0.27)   --             -----\n        (0.294493, 0.28)   -              ----\n        (0.294856, 0.29)   -              ---\n        (0.295202, 0.30)   -              --\n        (0.295266, 0.3019) .              -\n        (0.295531, 0.31)   -              .\n        \n    After playing around some more with different filters in a complete bloom mip chain it seems to me that it is a desirable property for the filter\n    to have an amplitude response that falls off to 0 halfway to Nyquist (in addition to minimizing the stop-band response).\n    The reason being that this way the error in the final effect appears to be more consistent and therefore less noticeable.\n    -> nope, was a problem with texcoord quantization by hardware\n    \n#elif 0\n    // more blurry\n    w0 = 0.1666050;\n    wa = 0.0936696;\n    wb = 0.0781594;\n    wc = 0.0365198;\n\n// non-separable variant, virtually no improvements\nvec4 BloomKernel9(vec2 uv)\n{\n    float w0 = 0.28397;\n\tfloat a = 0.124413;\n\tfloat b = 0.0545943;\n\tfloat oa = 0.75 + 0.5 * 0.262180;\n\tfloat ob = 0.75 + 0.5 * 0.262641;\n\n\tvec4 c = vec4(0.0);\n    c += Read(uv, vec2(0.0)) * w0;\n\n\tc += Read(uv, vec2(-1.0, 0.0) * oa) * a;\n\tc += Read(uv, vec2( 1.0, 0.0) * oa) * a;\n\tc += Read(uv, vec2( 0.0,-1.0) * oa) * a;\n\tc += Read(uv, vec2( 0.0, 1.0) * oa) * a;\n    \n\tc += Read(uv, vec2(-1.0,-1.0) * ob) * b;\n\tc += Read(uv, vec2( 1.0,-1.0) * ob) * b;\n\tc += Read(uv, vec2(-1.0, 1.0) * ob) * b;\n\tc += Read(uv, vec2( 1.0, 1.0) * ob) * b;\n\n\treturn c;\n}\n\n    {\n        // 2x2 box filter\n        v = 0.0;\n        v += Read(uv, vec2(0.0, 0.0)) * 0.25;\n        v += Read(uv, vec2(1.0, 0.0)) * 0.25;\n        v += Read(uv, vec2(0.0, 1.0)) * 0.25;\n        v += Read(uv, vec2(1.0, 1.0)) * 0.25;\n    }\n    \n        float size = SIZE*InputScale;\n        if(uv.x < 0.0) uv.x += size;\n        if(uv.y < 0.0) uv.y += size;\n\n        if(uv.x >= size) uv.x -= size;\n        if(uv.y >= size) uv.y -= size;\n\n        v = Hash01(uv, 0u);\n        \n        v = v > 0.99 ? 8.0 : 0.0;\n        \n// [1/32, 5/32, 10/32, 10/32, 5/32, 1/32]^2\nvec4 Pascal6x6Ref(vec2 uv)\n{\n\tvec4 c = vec4(0.0);\n\tfor(float y = -1.25; y <= 1.25; y += 0.5)\n\tfor(float x = -1.25; x <= 1.25; x += 0.5)\n\t{\n\t\tvec2 o = vec2(x, y);\n\n\t\tfloat wx = abs(o.x) == 0.25 ? 10.0 / 32.0 :\n\t\t\t       abs(o.x) == 0.75 ?  5.0 / 32.0 : 1.0 / 32.0;\n        float wy = abs(o.y) == 0.25 ? 10.0 / 32.0 :\n\t\t\t       abs(o.y) == 0.75 ?  5.0 / 32.0 : 1.0 / 32.0;\n\n\t\tc += Read(uv + 0.5 + o * 2.0) * (wx * wy);\n\t}\n\n\treturn c;\n}\n\nfloat Read2(vec2 uv)\n{\n    //if(ReadKeyToggle(KEY_TAB) != 0.0) \n    return Read(uv);\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    return mix(mix(Read(uvI + vec2(0.0, 0.0)), Read(uvI + vec2(1.0, 0.0)), uvF.x),\n               mix(Read(uvI + vec2(0.0, 1.0)), Read(uvI + vec2(1.0, 1.0)), uvF.x), uvF.y);\n}\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\nvec4 Moo3x3(vec2 uv)\n{\n    uv += 0.5;\n    float o = 2.0;\n\n    float b = 4.0;// 0 works much better, i.e. a box filter\n\n\tvec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\n\tsum += b * Read2(uv);\n\n\tsum += Read2(uv + vec2(-1.0, -1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2( 1.0,  1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2( 1.0, -1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2(-1.0,  1.0) * 0.5 * o);\n    \n    return sum / (b + 4.0);\n}\n\n*/", "buffer_a_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    test image creation\n*/\n\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\nfloat ReadKey(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 0), 0).x;}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 uv = floor(uv0);\n\n    float filterType = texelFetch(iChannel1, ivec2(0, 0), 0).a;\n    \n    if(ReadKey(KEY_N1) != 0.0) filterType = 0.0;\n    if(ReadKey(KEY_N2) != 0.0) filterType = 1.0;\n    if(ReadKey(KEY_N3) != 0.0) filterType = 2.0;\n    if(ReadKey(KEY_N4) != 0.0) filterType = 3.0;\n    if(ReadKey(KEY_N5) != 0.0) filterType = 4.0;\n    \n\n    vec2 res = vec2(SIZE);\n    \n    if(READ_TEXTURE_COND) res = iChannelResolution[0].xy;\n    \n    if(uv.x >= res.x) if(uv.x < res.x + 8.0) uv.x -= res.x; else uv.x -= iResolution.x - res.x;\n    if(uv.y >= res.y) if(uv.y < res.y + 8.0) uv.y -= res.y; else uv.y -= iResolution.y - res.y;\n\n   #if 1\n    // jittering\n    if(DO_DOWNSAMPLE_COND)\n    {\n        uint h = uint(iFrame) / 2u;\n        \n        bool a = (h & 1u) != 0u;\n        bool b = (h & 2u) != 0u;\n        \n        if(a != b) uv.x += 1.0;\n        if(b     ) uv.y += 1.0;\n        \n        if(uv.x == res.x) uv.x = 0.0;\n        if(uv.y == res.y) uv.y = 0.0;\n    }\n   #endif\n   \n    ivec2 uvi = ivec2(uv);\n\n    float noise = Hash01(uv, 0u);\n        \n    vec3 col = vec3(noise);\n\n    if(READ_TEXTURE_COND)\n    {\n        col = texelFetch(iChannel0, uvi, 0).rgb;\n\n        col = pow(col, vec3(2.2));    \n    }\n\n    if(ReadKeyToggle(KEY_CTRL) != 0.0) col = vec3(col.r > 0.99 ? 1.0 : 0.0);\n\n    outCol = vec4(col, filterType);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    filtering/downsampling implementation\n*/\n\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\n\nfloat Read(vec2 uv)\n{\n    //uv += off * 2.0;// * 2.0 because offsets assume that the target has a 1/(2x2) lower resolution (which usually is the case (but isn't here))\n    \n    vec2 res = vec2(SIZE);\n\n    if(READ_TEXTURE_COND) res = iChannelResolution[0].xy;\n\n    uv = fract(uv / res) * res;// wrap\n    \n    float v = textureLod(iChannel1, (uv + 0.) / iResolution.xy, 0.0).g;\n        \n    return v;\n}\n\nfloat filterType;// set in mainImage(..)\n\n// 4x4 samples downsampling kernel implemented via 4 bilinear samples\nvec4 BloomKernel4(vec2 uv)\n{\n    // optimal stop band\n    float la = 0.3533943809268811;\n    \n\tfloat oa = 0.5 + la;\n    \n\tvec4 ca = vec4(0.0);\n\tca += Read(uv + vec2(-1.0,-1.0) * oa);\n\tca += Read(uv + vec2( 1.0,-1.0) * oa);\n\tca += Read(uv + vec2(-1.0, 1.0) * oa);\n\tca += Read(uv + vec2( 1.0, 1.0) * oa);\n    \n    return ca * 0.25;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples\nvec4 BloomKernel8B(vec2 uv)\n{\n#if 1\n    // optimal stop band\n    float la = 0.553811;\n    float lb = 0.35856;    \n#else\n    float la = 0.245966;\n    float lb = 0.333333;\n#endif\n    \n\tvec2 o = vec2(1.5, 0.5) + vec2(la, lb);\n   //o*=.5;\n\tvec4 col = vec4(0.0);\n\tcol += Read(uv + vec2( 1.0, 1.0) * o.xy);\n\tcol += Read(uv + vec2(-1.0, 1.0) * o.xy);\n\tcol += Read(uv + vec2( 1.0,-1.0) * o.xy);\n\tcol += Read(uv + vec2(-1.0,-1.0) * o.xy);\n    \n    col += Read(uv + vec2( 1.0, 1.0) * o.yx);\n\tcol += Read(uv + vec2(-1.0, 1.0) * o.yx);\n\tcol += Read(uv + vec2( 1.0,-1.0) * o.yx);\n\tcol += Read(uv + vec2(-1.0,-1.0) * o.yx);\n    \n    return col * 0.125;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples\nvec4 BloomKernel8(vec2 uv)\n{\n#if 0\n    // optimal stop band\n    float a = 0.13433339843769723; \n    float la = 0.9108132736411344;\n    float lb = 0.37269896061302266;\n#elif 0\n    float a = 0.0181804; \n    float la = 0.0744041;\n    float lb = 0.370778;\n#elif 0\n    float a = 0.055432; \n    float la = 0.553841;\n    float lb = 0.334987;\n#elif 0\n    float a  = 0.215607; \n    float la = 0.591313;\n    float lb = 0.36029;\n#elif 1\n    // optimal stop band 2\n    float a  = 0.125143; \n    float la = 0.701224;\n    float lb = 0.330373;    \n#else\n    // new Nyquist = 0\n    float a = 0.32761490937746784;\n    float la = 0.5;\n    float lb = 0.5;\n#endif\n    \n\tfloat oa = 1.5 + la;\n\tfloat ob = 0.5 + lb;\n    \n\tvec4 ca = vec4(0.0);\n\tca += Read(uv + vec2(-1.0, 0.0) * oa);\n\tca += Read(uv + vec2( 1.0, 0.0) * oa);\n\tca += Read(uv + vec2( 0.0,-1.0) * oa);\n\tca += Read(uv + vec2( 0.0, 1.0) * oa);\n    \n    vec4 cb = vec4(0.0);\n\tcb += Read(uv + vec2(-1.0,-1.0) * ob);\n\tcb += Read(uv + vec2( 1.0,-1.0) * ob);\n\tcb += Read(uv + vec2(-1.0, 1.0) * ob);\n\tcb += Read(uv + vec2( 1.0, 1.0) * ob);\n    \n    return (cb * (1.0 - a) + ca * a) * 0.25;\n}\n\n// 6x6 downsampling kernel implemented via 9 bilinear samples (non-separable variant)\nvec4 BloomKernel9B(vec2 uv)\n{\n#if 0\n    // optimal stop-band\n    float w0 = 0.28397;\n\tfloat a  = 0.124413;\n\tfloat b  = 0.0545943;\n\tfloat oa = 1.5 + 0.262180;\n\tfloat ob = 1.5 + 0.262641;\n#elif 0\n    // radial symmetry + optimal stop-band\n    float w0 = 0.309247;\n\tfloat a  = 0.129306;\n\tfloat b  = 0.0433824;\n\tfloat oa = 1.5 + 0.25;// ~ 0.246235\n\tfloat ob = 1.5 + (0.125+1.0/32.0);\n#elif 1\n    // radial symmetry + optimal stop-band\n    float w0 = 0.302001;\n\tfloat a  = 0.127963;\n\tfloat b  = 0.0465365;\n\tfloat oa = 1.5 + 0.25;// ~ 0.250795\n\tfloat ob = 1.5 + (0.125+1.0/16.0);    \n#elif 1\n    // params by Mikkel Gjoel;; half Nyquist = 0 (along x & y)\n    // (https://twitter.com/pixelmager/status/1691731512004071785)\n    float w0 = 4.0/16.0;\n\tfloat a  = 2.0/16.0;\n\tfloat b  = 1.0/16.0;\n\tfloat oa = 1.5 + 0.25;\n\tfloat ob = 1.5 + 0.2052; //(1.0 - 0.7948);       \n#elif 1\n    // radial symmetry + half Nyquist = 0 (along x & y)\n    float w0 = 4.0/16.0;\n\tfloat a  = 2.0/16.0;\n\tfloat b  = 1.0/16.0;\n\tfloat oa = 1.5 + 0.292864;\n\tfloat ob = 1.5 + 0.24;\n#else    \n    // optimal stop-band + half Nyquist = 0 (along x & y)\n    float w0 = 4.0/16.0;\n\tfloat a  = 2.0/16.0;\n\tfloat b  = 1.0/16.0;\n\tfloat oa = 1.5 + 0.295266;\n\tfloat ob = 1.5 + 0.3019;\n#endif\n\n    if(filterType == 2.0)\n    {\n        // params by Mikkel Gjoel \n        // (https://twitter.com/pixelmager/status/1691731512004071785)\n        w0 = 4.0/16.0;\n        a  = 2.0/16.0;\n        b  = 1.0/16.0;\n        oa = 1.5 + 0.25;\n        ob = 1.5 + 0.2052; //(1.0 - 0.7948);   \n    }\n\n\tvec4 c = vec4(0.0);\n    c += Read(uv + vec2(0.0)) * w0;\n\n\tc += Read(uv + vec2(-1.0, 0.0) * oa) * a;\n\tc += Read(uv + vec2( 1.0, 0.0) * oa) * a;\n\tc += Read(uv + vec2( 0.0,-1.0) * oa) * a;\n\tc += Read(uv + vec2( 0.0, 1.0) * oa) * a;\n    \n\tc += Read(uv + vec2(-1.0,-1.0) * ob) * b;\n\tc += Read(uv + vec2( 1.0,-1.0) * ob) * b;\n\tc += Read(uv + vec2(-1.0, 1.0) * ob) * b;\n\tc += Read(uv + vec2( 1.0, 1.0) * ob) * b;\n\n\treturn c;\n}\n\n// 6x6 downsampling kernel implemented via 9 bilinear samples\nvec4 BloomKernel9(vec2 uv)\n{\n    float wa, o;\n    \n#if 0\n    // optimal stop band\n    wa = 7.46602 / 32.0;\n\to  = 1.5 + 0.261629;    \n#elif 1\n    // optimal stop band but o is chosen so as to keep frequency response \n    // symmetric despite lower-precision hardware bilinear filtering\n   #if 1\n    wa = 7.49862 / 32.0;\n\to  = 1.5 + (0.25+1.0/64.0);\n   #elif 1\n    wa = 7.44733 / 32.0;\n\to  = 1.5 + (0.25+1.0/128.0);\n   #else\n    wa = 7.37167 / 32.0;\n\to  = 1.5 + 0.25; \n   #endif\n#elif 1\n    // new Nyquist = 0\n    wa = 8.0 / 32.0;\n\to  = 1.5 + 0.297785;\n#elif 0\n    // pascal kernel (gauss approx), no ripples in stop band\n\twa = 6.0 / 32.0;\n\to  = 1.5 + (1.0 / 6.0);\n#endif\n\n\tfloat wb = 1.0 - wa * 2.0;\n\n\tvec4 c = vec4(0.0);\n    c += Read(uv + vec2(0.0)) * (wb * wb);\n\n\tc += Read(uv + vec2(-1.0, 0.0) * o) * (wa * wb);\n\tc += Read(uv + vec2( 1.0, 0.0) * o) * (wa * wb);\n\tc += Read(uv + vec2( 0.0,-1.0) * o) * (wa * wb);\n\tc += Read(uv + vec2( 0.0, 1.0) * o) * (wa * wb);\n    \n\tc += Read(uv + vec2(-1.0,-1.0) * o) * (wa * wa);\n\tc += Read(uv + vec2( 1.0,-1.0) * o) * (wa * wa);\n\tc += Read(uv + vec2(-1.0, 1.0) * o) * (wa * wa);\n\tc += Read(uv + vec2( 1.0, 1.0) * o) * (wa * wa);\n\n\treturn c;\n}\n\n// original 13 samples kernel design: \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n\n// 6x6 downsampling kernel implemented via 13 bilinear samples\nvec4 BloomKernel13(vec2 uv)\n{\n    float w0, wa, wb, wc;\n    \n#if 1\n    // optimal stop band\n    w0 = 0.173633;\n    wa = 0.0991668;\n    wb = 0.0744867;\n    wc = 0.0329382;    \n#elif 0\n    // radial symmetry\n    w0 = 0.144622;\n    wa = 0.105596;\n    wb = 0.0822943;\n    wc = 0.0259547;\n#elif 0\n    // hybrid\n    w0 = 0.15377;\n    wa = 0.106554;\n    wb = 0.0781547;\n    wc = 0.0268489;\n#else\n    // original weights (new Nyquist = 0)\n    w0 = 4.0/32.0;// 0.125\n    wa = 4.0/32.0;// 0.125\n    wb = 2.0/32.0;// 0.0625\n    wc = 1.0/32.0;// 0.03125\n#endif\n\n    if(filterType == 4.0)\n    {\n        // original weights (new Nyquist = 0)\n        w0 = 4.0/32.0;// 0.125\n        wa = 4.0/32.0;// 0.125\n        wb = 2.0/32.0;// 0.0625\n        wc = 1.0/32.0;// 0.03125\n    }\n\n\tvec4 c = vec4(0.0);\n\n\tc += w0 * Read(uv + vec2(0.0));\n\n\tc += wa * Read(uv + vec2(-1.0,-1.0));\n\tc += wa * Read(uv + vec2( 1.0, 1.0));\n\tc += wa * Read(uv + vec2( 1.0,-1.0));\n\tc += wa * Read(uv + vec2(-1.0, 1.0));\n\n\tc += wb * Read(uv + vec2( 2.0, 0.0));\n\tc += wb * Read(uv + vec2(-2.0, 0.0));\n\tc += wb * Read(uv + vec2( 0.0, 2.0));\n\tc += wb * Read(uv + vec2( 0.0,-2.0));\n\n\tc += wc * Read(uv + vec2( 2.0, 2.0));\n\tc += wc * Read(uv + vec2(-2.0, 2.0));\n\tc += wc * Read(uv + vec2( 2.0,-2.0));\n\tc += wc * Read(uv + vec2(-2.0,-2.0));\n    \n    return c;\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n    }\n    \n    filterType = texelFetch(iChannel1, ivec2(0, 0), 0).a;\n    \n    vec2 uv = floor(uv0);\n        \n    if(DO_DOWNSAMPLE_COND) uv *= 2.0;\n    \n    float v = 0.0;\n\n    if(filterType == 0.0)\n    {     \n        v = BloomKernel9(uv).r;\n    }\n    else if(filterType == 1.0 ||\n            filterType == 2.0)\n    {     \n        v = BloomKernel9B(uv).r;\n    }\n    else\n    {        \n        v = BloomKernel13(uv).r;\n    }\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n}\n", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        //vec2 yn = texelFetch(iChannel0, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\t//fragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\t//vec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel0, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\t//fragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslczj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[3563, 3563, 3597, 3597, 3651], [3653, 3653, 3699, 3699, 6322]]}
{"id": "msXcz2", "name": "green gradient waves", "author": "fouad", "description": "green gradient waves", "tags": ["greenwavesgradient"], "likes": 2, "viewed": 222, "published": 3, "date": "1686983967", "time_retrieved": "2024-07-30T17:49:11.819119", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0 / 3.0, 1.0, 1.0 / 3.0, 1.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat range(float val, float mi, float ma) {\n    return val * (ma - mi) + mi;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat t = iTime / 5.;\n    \n\t// main code, *original shader by: 'Plasma' by Viktor Korsun (2011)\n\tfloat x = p.x;\n\tfloat y = p.y;\n    \n\tfloat mov0 = x+y+cos(sin(t)*2.0)*100.+sin(x/100.)*1000.;\n\tfloat mov1 = y / 0.3 +  t;\n\tfloat mov2 = x / 0.2;\n    \n    float c1 = abs(sin(mov1+t)/2.+mov2/2.-mov1-mov2+t);\n    float c2 = abs(sin(c1+sin(mov0/1000.+t)+sin(y/40.+t)+sin((x+y)/100.)*3.));\n\tfloat c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));\n    \n    vec3 col = hsv2rgb(vec3(range(c2, 0.85, 0.95), range(c3, 0.5, 0.55), range(c3, 1., 0.75)));\n    \n    \n\tfragColor = vec4(col, 1.);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [192, 192, 236, 236, 271], [272, 272, 329, 329, 976]]}
{"id": "dsXcRj", "name": "synthwave sunset visualizer", "author": "TheWindowStreamz", "description": "As a music visualizer! (channel 0)", "tags": ["raymarching", "sunset", "tesselation", "synthwave", "cineshader"], "likes": 2, "viewed": 1350, "published": 3, "date": "1686967939", "time_retrieved": "2024-07-30T17:49:12.579087", "image_code": "#define VAPORWAVE\n//#define AA 2\n//#define stereo\n#define speed 10. \n//#define wave_thing\n#define city\n\n#ifndef disable_sound_texture_sampling\n    #undef speed \n    // lower value of speed when using as audio visualizer\n    #define speed 5.\n#endif\n\n//self-explainatory\n#define audio_vibration_amplitude .200\n\n\n\nvec4 textureMirror(sampler2D tex, vec2 c){\n    #ifdef disable_sound_texture_sampling\n    return vec4(0);\n    #else\n    vec2 cf = fract(c);\n    return texture(tex,mix(cf,1.-cf,mod(floor(c),2.)));\n    #endif\n}\n\nfloat jTime;\n\nfloat amp(vec2 p){\n    return smoothstep(1.,8.,abs(p.x));   \n}\n\nfloat pow512(float a){\n    a*=a;//^2\n    a*=a;//^4\n    a*=a;//^8\n    a*=a;//^16\n    a*=a;//^32\n    a*=a;//^64\n    a*=a;//^128\n    a*=a;//^256\n    return a*a;\n}\nfloat pow1d5(float a){\n    return a*sqrt(a);\n}\nfloat hash21(vec2 co){\n    return fract(sin(dot(co.xy,vec2(1.9898,7.233)))*45758.5433);\n}\nfloat hash(vec2 uv){\n    float a = amp(uv);\n    #ifdef wave_thing\n    float w = a>0.?(1.-.4*pow512(.51+.49*sin((.02*(uv.y+.5*uv.x)-jTime)*2.))):0.;\n    #else\n    float w=1.;\n    #endif\n    return (a>0.?\n        a*pow1d5(\n        texture(iChannel0,uv/iChannelResolution[0].xy).r\n        )*w\n        :0.)-(textureMirror(iChannel0,vec2((uv.x*29.+uv.y)*.03125,1.)).x)*audio_vibration_amplitude;\n}\n\nfloat edgeMin(float dx,vec2 da, vec2 db,vec2 uv){\n    uv.x+=5.;\n    vec3 c = fract((round(vec3(uv,uv.x+uv.y)))*(vec3(0,1,2)+0.61803398875));\n    float a1 = textureMirror(iChannel0,vec2(c.y,0.)).x>.6?.15:1.;\n    float a2 = textureMirror(iChannel0,vec2(c.x,0.)).x>.6?.15:1.;\n    float a3 = textureMirror(iChannel0,vec2(c.z,0.)).x>.6?.15:1.;\n\n    return min(min((1.-dx)*db.y*a3,da.x*a2),da.y*a1);\n}\n\nvec2 trinoise(vec2 uv){\n    const float sq = sqrt(3./2.);\n    uv.x *= sq;\n    uv.y -= .5*uv.x;\n    vec2 d = fract(uv);\n    uv -= d;\n\n    bool c = dot(d,vec2(1))>1.;\n\n    vec2 dd = 1.-d;\n    vec2 da = c?dd:d,db = c?d:dd;\n    \n    float nn = hash(uv+float(c));\n    float n2 = hash(uv+vec2(1,0));\n    float n3 = hash(uv+vec2(0,1));\n\n    \n    float nmid = mix(n2,n3,d.y);\n    float ns = mix(nn,c?n2:n3,da.y);\n    float dx = da.x/db.y;\n    return vec2(mix(ns,nmid,dx),edgeMin(dx,da, db,uv+d));\n}\n\n\nvec2 map(vec3 p){\n    vec2 n = trinoise(p.xz);\n    return vec2(p.y-2.*n.x,n.y);\n}\n\nvec3 grad(vec3 p){\n    const vec2 e = vec2(.005,0);\n    float a =map(p).x;\n    return vec3(map(p+e.xyy).x-a\n                ,map(p+e.yxy).x-a\n                ,map(p+e.yyx).x-a)/e.x;\n}\n\nvec2 intersect(vec3 ro,vec3 rd){\n    float d =0.,h=0.;\n    for(int i = 0;i<200;i++){ //look nice with 50 iterations\n        vec3 p = ro+d*rd;\n        vec2 s = map(p);\n        h = s.x;\n        d+= h*.5;\n        if(abs(h)<.003*d)\n            return vec2(d,s.y);\n        if(d>150.|| p.y>2.) break;\n    }\n    \n    return vec2(-1);\n}\n\n\nvoid addsun(vec3 rd,vec3 ld,inout vec3 col){\n    \n\tfloat sun = smoothstep(.21,.2,distance(rd,ld));\n    \n    if(sun>0.){\n        float yd = (rd.y-ld.y);\n\n        float a =sin(3.1*exp(-(yd)*14.)); \n\n        sun*=smoothstep(-.8,0.,a);\n\n        col = mix(col,vec3(1.,.8,.4)*.75,sun);\n    }\n}\n\n\nfloat starnoise(vec3 rd){\n    float c = 0.;\n    vec3 p = normalize(rd)*300.;\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p)-.5;\n        vec3 id = floor(p);\n        float c2 = smoothstep(.5,0.,length(q));\n        c2 *= step(hash21(id.xz/id.y),.06-i*i*0.005);\n        c += c2;\n        p = p*.6+.5*p*mat3(3./5.,0,4./5.,0,1,0,-4./5.,0,3./5.);\n    }\n    c*=c;\n    float g = dot(sin(rd*10.512),cos(rd.yzx*10.512));\n    c*=smoothstep(-3.14,-.9,g)*.5+.5*smoothstep(-.3,1.,g);\n    return c*c;\n}\n\nvec3 gsky(vec3 rd,vec3 ld,bool mask){\n    float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));\n    \n\n    float st = mask?pow512(texture(iChannel0,(rd.xy+vec2(300.1,100)*rd.z)*10.).r)*(1.-min(haze,1.)):0.;\n    //float st = mask?pow512(hash21((rd.xy+vec2(300.1,100)*rd.z)*10.))*(1.-min(haze,1.)):0.;\n    //float st = mask?(starnoise(rd))*(1.-min(haze,1.)):0.;\n    vec3 back = vec3(.4,.1,.7)*(1.-.5*textureMirror(iChannel0,vec2(.5+.05*rd.x/rd.y,0.)).x\n    *exp2(-.1*abs(length(rd.xz)/rd.y))\n    *max(sign(rd.y),0.));\n    #ifdef city\n    float x = round(rd.x*30.);\n    float h = hash21(vec2(x-166.));\n    bool building = (h*h*.125*exp2(-x*x*x*x*.0025)>rd.y);\n    if(mask && building)\n        back*=0.,haze=.8, mask=mask && !building;\n    #endif\n    vec3 col=clamp(mix(back,vec3(.7,.1,.4),haze)+st,0.,1.);\n    if(mask)addsun(rd,ld,col);\n    return col;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    #ifdef AA\n        for(float x = 0.;x<1.;x+=1./float(AA)){\n        for(float y = 0.;y<1.;y+=1./float(AA)){\n    #else\n        const float AA=1.,x=0.,y=0.;\n    #endif\n    vec2 uv = (2.*(fragCoord+vec2(x,y))-iResolution.xy)/iResolution.y;\n    \n\tfloat dt = fract(texture(iChannel0,float(AA)*(fragCoord+vec2(x,y))/iChannelResolution[0].xy).r+iTime);\n    //float dt = fract(hash21(float(AA)*(fragCoord+vec2(x,y)))+iTime);\n    jTime = mod(iTime-dt*iTimeDelta*.25,4000.);\n    vec3 ro = vec3(0.,1,(-20000.+jTime*speed));\n    \n        #ifdef stereo\n            ro+=vec3(.2*(float(uv.x>0.)-.5),0.,0.); //-= for x-view\n            const float de = .9;\n            uv.x=uv.x+.5*(uv.x>0.?-de:de);\n            uv*=2.;\n\t\t#endif\n        \n    vec3 rd = normalize(vec3(uv,4./3.));\n    vec3(uv,sqrt(1.-dot(uv,uv)));\n    \n    vec2 i = intersect(ro,rd);\n    float d = i.x;\n    \n    vec3 ld = normalize(vec3(0,.125+.05*sin(.1*jTime),1));\n\n    vec3 fog = d>0.?exp2(-d*vec3(.14,.1,.28)):vec3(0.);\n    vec3 sky = gsky(rd,ld,d<0.);\n    \n    vec3 p = ro+d*rd;\n    vec3 n = normalize(grad(p));\n    \n    float diff = dot(n,ld)+.1*n.y;\n    vec3 col = vec3(.1,.11,.18)*diff;\n    \n    vec3 rfd = reflect(rd,n); \n    vec3 rfcol = gsky(rfd,ld,true);\n    \n    col = mix(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));\n    #ifdef VAPORWAVE\n    col = mix(col,vec3(.4,.5,1.),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    col = sqrt(col);\n    #else\n    col = mix(col,vec3(.8,.1,.92),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    //no gamma for that old cg look\n    #endif\n    if(d<0.)\n        d=1e6;\n    d=min(d,10.);\n    fragColor += vec4(clamp(col,0.,1.),d<0.?0.:.1+exp2(-d));\n     #ifdef AA\n    }\n    }\n    fragColor/=float(AA*AA);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"another synthwave sunset thing\",\n\t\"description\": \"I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\",\n\t\"model\": \"car\"\n}\n*/\n", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 353, 353, 518], [534, 534, 552, 552, 596], [598, 598, 620, 620, 757], [758, 758, 780, 780, 804], [805, 805, 827, 827, 894], [895, 895, 915, 915, 1287], [1289, 1289, 1338, 1338, 1684], [1686, 1686, 1709, 1709, 2176], [2179, 2179, 2196, 2196, 2260], [2262, 2262, 2280, 2280, 2445], [2447, 2447, 2479, 2479, 2775], [2778, 2778, 2822, 2822, 3065], [3068, 3068, 3093, 3093, 3565], [3567, 3567, 3604, 3604, 4415]]}
{"id": "dsXyRj", "name": "Sunset Drive Visualizer", "author": "TheWindowStreamz", "description": "Retro futuristic game and animation.\nI've modified the controls on channel 1 to use audio in Buffer A, is NOT a proper audio visualizer.\nI've removed the old music from it, so no double music.\nOriginal by Michal Klos", "tags": ["3d", "raymarching", "game", "retro", "text", "audio", "ui", "80", "multipass", "synthwave", "klos"], "likes": 4, "viewed": 378, "published": 3, "date": "1686965437", "time_retrieved": "2024-07-30T17:49:13.874623", "image_code": "// Copyright  2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Sunset Drive Unlimited\n//  Endless runner with synthwave stylization\n//\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n//\thttps://www.shadertoy.com/view/wssSD4\n\n// #define options in Common tab\n//  Some effects can be disabled on low end gpus\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU\n\n// First draft created in 24h on Game Jam Square 26-28.04.2019\n//\tFinished after couple of spare evenings on 24.06.2019\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Other snippets credits in comments next to the code\n// Thank you guys for sharing it, hope you like it :)\n\n// Music: Lifelike - So Electric\n//  https://soundcloud.com/rombo_rama/lifelike-so-electric\n\n\nvec3 fxaa( vec3 color )\n{\n\t// FXAA implementation by mudlord (I think?)\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\tvec2 pp = 1.0 / R.xy;\n    float lumaNW = dot(texture(iChannel0, (F.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (F.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (F.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (F.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, F.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, F.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, F.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, F.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        return rgbA;\n    } else {\n        return rgbB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.0 );\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n    float bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif // FORCED_RATIO\n       \n    fragColor = texture( iChannel0, vec2( uv ) );\n\n#ifdef FXAA\t\n\tfragColor.rgb = fxaa( fragColor.rgb );\n#endif\n\n#ifdef NOISE\n    fragColor.rgb *= 0.8 + 0.2 * hash22( 1000.0 * ( F.xy / R.xy + fract( iTime ) ) ).x;\n#endif\n\n#ifdef FPS_COUNTER    \n    vec2 h = F.xy / R.xy;\n    h.x *= R.x / R.y;\n    fragColor.rgb += printInt( ( h -vec2( 0.0, 0.21 ) ) * 30.0, iFrameRate );\n#endif \n\n    // gamma\n\tfragColor.rgb = pow( fragColor.rgb, vec3( 0.4545 ) );\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Copyright  2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Sunset Drive Unlimited\n//  Endless runner with synthwave stylization\n//\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n//\thttps://www.shadertoy.com/view/wssSD4\n\n// #define options in Common tab\n//  Some effects can be disabled on low end gpus\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU\n\n// First draft created in 24h on Game Jam Square 26-28.04.2019\n//\tFinished after couple of spare evenings on 24.06.2019\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Other snippets credits in comments next to the code\n// Thank you guys for sharing it, hope you like it :)\n\n// Music: Lifelike - So Electric\n//  https://soundcloud.com/rombo_rama/lifelike-so-electric\n\n\n\nAppState updateGame( AppState s, float isDemo )\n{\n    if ( isDemo > 0.0 )\n    {\n        s.timeAccumulated += 1.0 * iTimeDelta;\n    \ts.playerPos.y = 5.0 * s.timeAccumulated;\n    }\n    else\n    {\n        float playerCellID = floor( s.playerPos.y );\n        s.paceScale = saturate( ( playerCellID - 50.0) / 500.0);\n        float timeMultiplier = mix( 0.75, 2.0, pow( s.paceScale, 1.0 ) );\n\n        s.timeAccumulated += timeMultiplier * iTimeDelta;\n        s.playerPos.y = 5.0 * s.timeAccumulated;\n    }    \n    \n    float playerCellID = floor( s.playerPos.y );\n\n    if ( isDemo > 0.0 )\n    {           \n        float cellOffset = 1.0;\n        float nextPlayerCellID = playerCellID + cellOffset;\n\n        float nextCellCoinRND = hash11( nextPlayerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n        nextCellCoinRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n        nextCellCoinRND = mix( nextCellCoinRND, -1.0, step( nextPlayerCellID, 5.0 ) ); // head start\n        float nextCellCoinCol = floor( 3.0 * nextCellCoinRND );\n\n        // OBSTACLE\n        float nextCellObsRND = hash11( 100.0 * nextPlayerCellID + s.seed );\n        nextCellObsRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 3.0 ), 1.5 ) );\n        nextCellObsRND = mix( nextCellObsRND, -1.0, step( nextPlayerCellID, 7.0 ) ); // head start\n        float nextCellObsCol = floor( 3.0 * nextCellObsRND );\n        \n        float inputObs = 0.0;                \n        if ( nextCellObsCol > -0.5 )\n        {\n            nextCellCoinCol -= 0.5; // pos fix\n        \tfloat toObs = nextCellObsCol - s.playerPos.x;\n        \n            if ( nextCellObsCol == 1.0 )\n                inputObs = hash11( nextPlayerCellID + s.seed );\n            \n            if ( nextCellObsCol < 1.0 )\n                inputObs = 1.0;\n\n            if ( nextCellObsCol > 1.0 )\n                inputObs = -1.0;\n        }\n        \n        \n        float inputCoin = 0.0;\n        if ( nextCellCoinCol > -0.5 )\n        {               \n            nextCellCoinCol -= 0.5; // pos fix\n            float toCoin = nextCellCoinCol - s.playerPos.x;\n            \n\t\t\tinputCoin = sign(toCoin) * saturate( abs( toCoin ) );\n        }\n\n        float inputDir = inputCoin + 5.0 * inputObs;\n        inputDir = sign( inputDir ) * 4.0 * saturate( abs( inputDir ) );\n        \n        s.isPressedLeft  = step( 0.5, -inputDir );\n        s.isPressedRight = step( 0.5,  inputDir );\n    }\n\n    float speed = mix( 0.1, 0.15, isDemo );\n    s.playerPos.x -= speed * s.isPressedLeft; \n    s.playerPos.x += speed * s.isPressedRight; \n\n    s.playerPos.x = clamp( s.playerPos.x, -0.5, 1.5 );\n\n    if ( playerCellID != s.coin0Pos ) \n    {\n        s.coin3Pos \t = s.coin2Pos;\n        s.coin3Taken = s.coin2Taken;\n\n        s.coin2Pos \t = s.coin1Pos;\n        s.coin2Taken = s.coin1Taken;\n\n        s.coin1Pos \t = s.coin0Pos;\n        s.coin1Taken = s.coin0Taken;\n\n        s.coin0Pos = playerCellID;\n        s.coin0Taken = 0.0;\n    }\n \n    // COIN start\n    float cellCoinRND = hash11( playerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellCoinRND *= mix( 1.0, -1.0, step( mod( playerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( playerCellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n\n    vec2 coinPos = -vec2( 0.0, playerCellID )\t// cell pos\n        +vec2( 0.5, -0.5 )\t// move to cell center\n        -vec2( cellCoinCol, 0.0 ); // move to column\n\n    if ( cellCoinRND >= 0.0 )\n    {        \n        float distCoinPlayer = length( coinPos + s.playerPos );\n\n        if ( distCoinPlayer < 0.5 && s.coin0Taken < 0.5 )\n        {\n            if ( isDemo < 1.0 )\n            \ts.score++;\n            \n            s.coin0Taken = 1.0;\n            s.timeCollected = iTime;\n        }\n    }\n    // COIN end\n\n    // OBSTACLE start\n    float cellObsRND = hash11( 100.0 * playerCellID + s.seed );\n    cellObsRND *= mix( 1.0, -1.0, step( mod( playerCellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( playerCellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {   \n        vec2 obstaclePos = -vec2( 0.0, playerCellID )\t// cell pos\n            +vec2( 0.5, -0.25 )\t// move to cell center\n            -vec2(cellObsCol, 0.0 ); // move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n\n        if ( distObstaclePlayer < 0.5 && isDemo < 1.0 )\n        {\n            s.timeFailed = iTime;\n            s.timeCollected = -1.0;\n            s.highscore = max( s.highscore, s.score );\n        }\n    }\n    // OBSTACLE end        \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    s.showUI = mod( s.showUI + texelFetch( iChannel1, ivec2( ASCII_U, 1 ), 0 ).x, 2.0 );\n    float isSpacePressed = texelFetch( iChannel1, ivec2( ASCII_SPACE, 1 ), 0 ).x;\n   \n  \t// read keys that people usually press\n    // https://www.shadertoy.com/view/lsXGzf\n    float keyLeft = 0.0;\n    for ( int i = 0; i < keysLeft.length(); ++i )\n        keyLeft = max( keyLeft, texelFetch( iChannel1, ivec2( keysLeft[i], 0 ), 0 ).x );\n    \n\ts.isPressedLeft = keyLeft;    \n            \n    float keyRight = 0.0;\n    for ( int i = 0; i < keysRight.length(); ++i )\n        keyRight = max( keyRight, texelFetch( iChannel1, ivec2( keysRight[i], 0 ), 0 ).x );\n    \n    s.isPressedRight = keyRight;    \n       \n    if ( s.stateID == GS_SPLASH ) // splash\n    {                             \n        if ( isSpacePressed > 0.5 || s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 )\n        {\n            s = setStateStartGame( s, iTime );\n            s.stateID = GS_GAME;            \n            s.timeStarted = iTime;\n            s.timeAccumulated = 0.0;\n            s.seed += iTime;\n        }\n        else\n        {\n            s = updateGame( s, 1.0 );\n        }        \n    }\n    else if ( s.stateID == GS_GAME ) // game\n    {\n        if ( s.timeFailed > s.timeStarted )\n        {   \n            if ( iTime > s.timeFailed + 1.0 \n                && ( s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 ) )\n            {            \n            \ts.timeStarted = iTime;\n                s.timeFailed = -1.0;\n            }\n                        \n            if ( iTime > s.timeFailed + 5.0 )\n            {                \n                s = setStateStartGame( s, iTime );\n                s.stateID = GS_SPLASH;\n            }\n            \n            s.isPressedLeft = 0.0;\n            s.isPressedRight = 0.0;\n        }\n        else\n        {\n            s = updateGame( s, 0.0 );\n        }\n    }\n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}", "buffer_a_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright  2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Sunset Drive Unlimited\n//  Endless runner with synthwave stylization\n//\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n//\thttps://www.shadertoy.com/view/wssSD4\n\n// #define options in Common tab\n//  Some effects can be disabled on low end gpus\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU\n\n// First draft created in 24h on Game Jam Square 26-28.04.2019\n//\tFinished after couple of spare evenings on 24.06.2019\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Other snippets credits in comments next to the code\n// Thank you guys for sharing it, hope you like it :)\n\n// Music: Lifelike - So Electric\n//  https://soundcloud.com/rombo_rama/lifelike-so-electric\n\n\n\n// switches, enable/disable effects:\n#define REFLECTIONS // needs good gpu\n#define VOLUMETRICS // needs good gpu\n#define FXAA\n#define GRADE\n#define NOISE\n#define FORCED_RATIO\n// debug:\n#define SHOW_UI\n// #define FPS_COUNTER\n// #define DEBUG_2D\n// #define DEBUG_CAMERA\n// #define CAM_STICKED\n\n\n#define ZERO (min(iFrame,0))\n#define R iResolution\n#define F gl_FragCoord\n// fix by adx\n#define texture(s,u) textureLod(s,u,0.)\n\nconst float g_forceRatio = 2.39;\nconst float PI = float(3.14159);\n\n// control loop\nconst float keysLeft[] = float[] ( \n\t 37.0,  // Arrow left\n\t 65.0,  // A\n\t 197.0  // a \n);\n\nconst float keysRight[] = float[] ( \n\t 39.0, // Arrow right\n\t 68.0, // D\n     100.0 // d\n);\n\nconst int ASCII_U\t\t= 85;\nconst int ASCII_SPACE\t= 32;\n\n// Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n// Cell State\nstruct AppState\n{\n\tfloat stateID;\n    float isPressedLeft;\n    float isPressedRight;\n    float timeStarted;\n    \n    vec2 playerPos;\n    float score;\n    float timeFailed;\n    \n    float highscore;\n    float timeCollected;\n    float timeAccumulated;\n    float showUI;\n    \n    float paceScale;\n    float seed;\n    \n    float coin0Pos;\n    float coin0Taken;\n    float coin1Pos;\n    float coin1Taken;\n    float coin2Pos;\n    float coin2Taken;\n    float coin3Pos;\n    float coin3Taken;\n};\n\n   \n// https://www.shadertoy.com/view/4djSRW\nfloat hash11( float p )\n{\n\tvec3 p3  = fract( vec3( p ) * .1031 );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.x + p3.y) * p3.z );\n}\n\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * vec3( .1031, .1030, .0973 ) );\n\tp3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * vec3( .1031, .1030, .0973 ) );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\n// from Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\nfloat hash( float n ) { return fract( sin( n ) * 1e4 ); }\nfloat noise( vec3 x ) { const vec3 step = vec3( 110, 241, 171 ); vec3 i = floor( x ); vec3 f = fract( x ); float n = dot( i, step ); vec3 u = f * f * ( 3.0 - 2.0 * f ); return mix( mix( mix( hash( n + dot( step, vec3( 0, 0, 0 ) ) ), hash( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 0 ) ) ), hash( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ), mix( mix( hash( n + dot( step, vec3( 0, 0, 1 ) ) ), hash( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 1) ) ), hash( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z ); }\n\n#define DEFINE_FBM(name, OCTAVES) float name( vec3 x ) { float v = 0.0; float a = 0.5; vec3 shift = vec3( 100 ); for ( int i = 0; i < OCTAVES; ++i ) { v += a * noise( x ); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.isPressedLeft\t\t= data.x;\n    s.isPressedRight\t= data.y;\n    s.stateID      \t\t= data.z;\n\ts.timeStarted \t\t= data.w;    \n    \n    data = loadValue( tex, 1, 0 );\n    s.playerPos\t\t\t= data.xy;\n    s.score\t\t\t\t= data.z;\n    s.timeFailed \t\t= data.w;\n    \n    data = loadValue( tex, 2, 0 );\n    s.highscore \t\t= data.x;\n    s.timeCollected\t\t= data.y;\n    s.timeAccumulated\t= data.z;\n    s.showUI\t\t\t= data.w;\n    \n    data = loadValue( tex, 3, 0 );\n    s.paceScale\t\t\t= data.x;\n    s.seed\t\t\t\t= data.y;\n   \n    data = loadValue( tex, 0, 1 );\n    s.coin0Pos = data.x;\n    s.coin0Taken = data.y;\n    s.coin1Pos = data.z;\n    s.coin1Taken = data.w;\n    data = loadValue( tex, 1, 1 );\n    s.coin2Pos = data.x;\n    s.coin2Taken = data.y;\n    s.coin3Pos = data.z;\n    s.coin3Taken = data.w;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nAppState setStateStartGame( in AppState s, float iTime )\n{    \n    s.stateID \t\t\t=  GS_SPLASH;\n    s.timeStarted\t\t=  iTime;\n    s.playerPos\t\t\t=  vec2( 0.5, 0.0 );\n    s.score\t\t\t\t=  0.0;\n    s.timeFailed\t\t= -1.0;\n    s.timeCollected\t\t= -1.0;\n    s.timeAccumulated\t=  0.0;\n    s.showUI\t\t\t=  1.0;\n\n    s.coin0Pos\t\t= 0.0;\n    s.coin0Taken\t= 0.0;\n    s.coin1Pos\t\t= 0.0;        \n    s.coin1Taken\t= 0.0;\n    s.coin2Pos\t\t= 0.0;        \n    s.coin2Taken\t= 0.0;\n    s.coin3Pos\t\t= 0.0;        \n    s.coin3Taken\t= 0.0;    \n    \n    return s;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{\n    if (iFrame <= 0)\n    {\n        s.seed = fbm3( iDate.yzw );\n \t\ts = setStateStartGame( s, iTime );\n\t}\n    \n    vec4 ret = vec4( 0.);\n\tstoreValue( vec2( 0., 0. ), vec4( s.isPressedLeft,\t\ts.isPressedRight,\ts.stateID,\t\t\ts.timeStarted),\tret, fragCoord );    \n\tstoreValue( vec2( 1., 0. ), vec4( s.playerPos,\t\t\t\t\t\t\t\ts.score,\t\t\ts.timeFailed),\tret, fragCoord );\n\tstoreValue( vec2( 2., 0. ), vec4( s.highscore,\t\t\ts.timeCollected,\ts.timeAccumulated,\ts.showUI),\t\tret, fragCoord );\n    storeValue( vec2( 3., 0. ), vec4( s.paceScale,\t\t\ts.seed,\t\t\t\t0.0,\t\t\t\t0.0),\t\t\tret, fragCoord );\n    \n    storeValue( vec2( 0., 1. ), vec4( s.coin0Pos, s.coin0Taken, s.coin1Pos, s.coin1Taken ), ret, fragCoord );\n    storeValue( vec2( 1., 1. ), vec4( s.coin2Pos, s.coin2Taken, s.coin3Pos, s.coin3Taken ), ret, fragCoord );\n    return ret;\n}\n\n// math\n\nfloat saturate( float x ) { return clamp( x, 0., 1. ); }\n\nvec3 saturate( vec3 x ) { return clamp( x, vec3( 0. ), vec3( 1. ) ); }\n\nmat2 rot( float a ) { float s = sin( a ); float c = cos( a ); return mat2( c, -s, s, c ); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv =          ( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nfloat impulse( float k, float x ) {\n    float h = k * x;\n    return h * exp( 1.0 - h );\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat sampleDigit( const in float n, const in vec2 vUV )\n{\t\t\n\tif ( vUV.x  < 0.0 ) return 0.0;\n\tif ( vUV.y  < 0.0 ) return 0.0;\n\tif ( vUV.x >= 1.0 ) return 0.0;\n\tif ( vUV.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2 vPixel = floor( vUV * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data / pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat printInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) / log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif( digitID > 0.0 && digitID < maxDigits )\n\t{\n        float digitVa = mod( floor( value / pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = sampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}", "buffer_b_code": "// Copyright  2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Sunset Drive Unlimited\n//  Endless runner with synthwave stylization\n//\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n//\thttps://www.shadertoy.com/view/wssSD4\n\n// #define options in Common tab\n//  Some effects can be disabled on low end gpus\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU\n\n// First draft created in 24h on Game Jam Square 26-28.04.2019\n//\tFinished after couple of spare evenings on 24.06.2019\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Other snippets credits in comments next to the code\n// Thank you guys for sharing it, hope you like it :)\n\n// Music: Lifelike - So Electric\n//  https://soundcloud.com/rombo_rama/lifelike-so-electric\n\n\n\nAppState g_S;\n\nfloat g_glowCoin = 1e10;\nfloat g_glowCoinRefl = 1e10;\nfloat g_glowEnemy = 1e10;\nfloat g_glowEnemyRefl = 1e10;\nfloat g_glowPlayer = 1e10;\nfloat g_glowPlayerRefl = 1e10;\nfloat g_glowPlayerFront = 1e10;\nfloat g_glowPlayerLights = 1e10;\nfloat g_cameraMode = 0.0;\n\nconst float GRID_SIZE = 0.5;\nconst float GRID_LINE_SIZE = 1.25;\n\nconst float GRID_CAR_SIZE = 0.5;\nconst float GRID_CAR_LINE_SIZE = 1.5;\n\nconst vec3 GRID_COLOR_1 = vec3(0.00, 0.02, 0.20);\nconst vec3 GRID_COLOR_2 = vec3(26.00, 14.0, 122.0)/255.;\n\nconst vec3 SUN_DIRECTION = vec3(0.0, 0.025, 0.5);\nconst vec3 SKY_COLOR_1 = vec3(49., 33., 66.)/255.;\nconst vec3 SKY_COLOR_2 = vec3(0.00,0.02,0.20);\n\nconst vec3 SUN_COLOR_1 = vec3(1.0, 0.3, 0.1) * 0.5;\nconst vec3 SUN_COLOR_2 = vec3(1.0, 1.0, 0.1) * 0.5;\n\nconst vec3 CAR_COLOR_1 = vec3(1.0, 0.5, 0.1) * 0.0;\nconst vec3 CAR_COLOR_2 = vec3(1.0, 0.0, 0.0) * 1.5;\n\nconst vec3 CAR_PLAYER_COLOR_1 = vec3(0.1, 1.0, 0.5) * 0.1;\nconst vec3 CAR_PLAYER_COLOR_2 = vec3(0.1, 1.0, 0.5) * 1.5;\n\nconst vec3 FOG_COLOR = vec3(193.00, 24.0, 123.0)/255.;\n\n\nstruct sHit {\n    float t;\n    float m;\n    vec3 lPos;\n};\n    \nsHit createHit( float t, float m, vec3 lPos )\n{\n    sHit h;\n    h.t = t;\n    h.m = m;\n    h.lPos = lPos;\n    return h;\n}\n\nvoid drawCoin( inout vec3 color, vec2 p, vec2 coinPos )\n{  \n    float sCoin = length(\n        p\n        -vec2( 0.0, coinPos.y )\t// cell pos\n        +vec2( 0.5, -0.5 )\t\t// move to cell center\n        -vec2( coinPos.x, 0.0 ) // move to column\n    ) - 0.25; \t\t\t\t\t// radius of coin\n\n    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );\n}\n\nvoid drawGameFlat( inout vec4 color, vec2 p, AppState s )\n{\n    // game\n\tvec2 p0 = p;    \n    // float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );\n    float cameraAnim = 0.0;\n\tp0 *= mix( 5.0, 10.0, cameraAnim );\t\t// scale field of view\n    p0.x += 0.25;\t\t\t\t\t\t\t// fix track centering\n    p0.y += mix( 2.0, 8.0, cameraAnim );\t// move camera pos\n    p0.y += s.playerPos.y;\n    \n    float playerCellID = floor( s.playerPos.y );\n    float sPlayer = length( p0 - s.playerPos ) - 0.25;\n           \n    vec2 p1 = p0;\n    p1.y += 2.0 * s.playerPos.y;\n    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );\n    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );\n       \n\t// COIN start\n    float cellID = floor( p0.y );\n    float cellCoinRND = hash11( cellID + g_S.seed );\t\t\t\t\t// skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) );\t// gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step (cellID, 5.0 ) );\t\t// head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n       \n    if ( cellCoinRND >= 0.0 )\n    {\n        if ( cellID > playerCellID )\n           \tdrawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID && s.coin0Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n       \n        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n    }    \n// COIN end\n\n// OBSTACLE start\n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );\t\t// skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0) );\t// head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n    \n\tif ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {        \n    \tfloat sObstacle = length(\n            p0\n            -vec2( 0.0, cellID )\t\t// cell pos\n            +vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            -vec2( cellObsCol, 0.0 )\t// move to column\n        ) - 0.25;\t\t\t\t\t\t// radius of coin\n        \n    \tcolor.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );\n        \n        vec2 obstaclePos = -vec2( 0.0, cellID )\t\t\t// cell pos\n            \t\t\t\t+vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            \t\t\t\t-vec2( cellObsCol, 0.0 );\t// move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n        \n        if ( distObstaclePlayer < 0.5 ) \n        {\n            color.rgb += vec3( 0.5 );\n        }\n    }\n    \n    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );\n\n// OBSTACLE end        \n\n}\n\nfloat circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1. ) * r;\n}\n\nvoid opRotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nsHit opUS( sHit d1, sHit d2 )\n{\n    if ( d1.t < d2.t )\n        return d1;\n    else \n        return d2;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n   \tp = vec3( p.z, p.x, -p.y ); // Coord fix\n    // n must be normalized\n          \n    vec3 p0 = vec3(p.x, p.y, p.z);\n\n    float fgProf = 0.2 * smoothstep( 1.5, 2.0, abs( p0.y ) );\n    float bgProf = 1.0 * smoothstep( 3.5, 4.5, abs( p0.y ) );\n    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy / 10. ).r, 0.0, 1.0 );\n    float bg = 0.1 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy / 40.).r, 0.0, 1.0 );\n    float displace = 1.5 * fg + 2.5 * bg;\n    \n    float sGround = dot(\n        vec3( p.x, p.y, max( p.z + displace, p.z ) ),\n        n.xyz )\n        + n.w;\n    \n    sGround *= 0.5;\n    \n  \treturn sGround;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\nfloat opUnion( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat opIntersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat opSubstract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat opSubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn( vec3 p, float r, float id )\n{\n    return vec2( ( ( abs( p.x ) + abs( p.y ) ) - r ) / sqrt( 2.0 ), id );\n}\n\nfloat sdCoin( vec3 p, float id )\n{       \n    float sCyl = cylinder( p.yzx, 0.1, 0.02 );    \n\n    if ( id == 2.0 )\n        g_glowCoin = min( g_glowCoin, sCyl );\n    \n    if ( id == 12.0 )\n    \tg_glowCoinRefl = min( g_glowCoin, sCyl );\n    \n    return sCyl;\n}\n\n// From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\nfloat car( vec3 p, float id )\n{        \n    p *= 5.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float b = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float c = plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float d = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    opRotate( t.yx, -0.05 );\n    float e = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float f = plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n        \n    if ( id == 1.0 )\n    {\n        float bloomF = box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n        t.z = abs( t.z );\n        t.z -= 1.5;       \n        float bloomB = box( t + vec3( -4.4, -0.2, 0.0 ), vec3( 0.2, 0.4, 0.2 ) );\n    \tg_glowPlayer = min( g_glowPlayer, 1.0 / 5.5 * min( bloomF, bloomB ) );\n    }\n    \n    if ( id == 3.0 )\n        g_glowEnemy = min( g_glowEnemy, 1.0 / 5.5 * box( t + vec3( -2.0, 0.7, 0.0 ), vec3( 3.0, 1.0, 1.0 ) ) );\n\n    t = p + vec3( 1.0, -0.6, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float frontWindow = box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float backWindow = box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = opSubstract( a, opUnion( opUnion( opUnion( b, c ), opIntersect( d, e ) ), f ) );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    opRotate( t.yz, -0.9 );\n    float sideCutPlanes = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = opSubstractChamfer( body, opUnion( backWindow, frontWindow ), 0.1 );\n    body = opSubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.65 );\n    float wheel = cylinder( t, 0.7, 1.0 );\n    body = opSubstract( body, wheel );\n    t.y -= .1;\n    wheel = opSubstract( cylinder( t, 0.6, 0.3 ), sphere( t + vec3( 0.0, -0.45, 0.0 ), 0.45 ) );\n    \n    body = opUnion( body, wheel );\n    \n    body /= 5.5;\n    \n    return body;\n}\n\nfloat carFront( vec3 p, float id )\n{        \n    // front lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float front = cylinder( p.zxy + vec3( -0.06, -0.77, -0.02 ), 0.05, 0.01 );\n    \n    if ( id == 1.5 )\n        g_glowPlayerFront = min( g_glowPlayerFront, front );\n       \n    return front;\n}\n\nfloat carLights( vec3 p, float id )\n{        \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerLights = min( g_glowPlayerLights, back );\n       \n    return back;\n}\n\n\nfloat carRefl( vec3 p, float id )\n{        \n    float body = box( p + vec3( 0.0, -0.07, 0.0 ), vec3( 0.6, 0.02, 0.2) );\n    body = min( body, box( p + vec3( 0.2, -0.1, 0.0 ), vec3( 0.4, 0.02, 0.2 ) ) );\n    \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float bloom = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );    \n    \n    bloom = min( bloom, body );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerRefl = min( g_glowPlayerRefl, bloom );\n    \n    if ( id == 3.5 )\n        g_glowEnemyRefl = min( g_glowEnemyRefl, bloom );\n       \n    return body;\n}\n\nvec2 getBent()\n{\n    float bentSide\t= sin( g_S.timeAccumulated / PI );\n    float bentUp\t= ( ( cos( 0.25 * g_S.timeAccumulated / PI ) * 0.5 ) + 0.5 ) * 1.5;\n    return vec2( bentSide, bentUp );\n}\n\nsHit map( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, 0.0, pos );\n\n\t// player, in place in fact\n    vec2 bent = getBent();\n    \n    // game\n    vec3 p0 = pos;    \n    // bending    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI ) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI ) * bent.y;\n   \n    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );\n    \n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    // sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); // debug collider\n    \n\tfloat rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI );\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX );\n    // pPlayer.yz *= rot( -10.0*iTime ); // mothman\n    pPlayer.y += 0.05;    \n    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );\n\tsRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );\n    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );\n    \n    vec3 pEnv = p0;\n    pEnv.z += 2.0 * g_S.playerPos.y;\n    pEnv.x -= 0.5;\n    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -1, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );\n    \n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;\n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) - 0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if (cellCoinRND >= 0.0)\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        // sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); // debug colider\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );\n        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );\n        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );\n    }\n\n    return sRes;\n}\n\nsHit mapRefl( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, -1.0, pos );\n\n    vec2 bent = getBent();\n    vec3 p0 = pos;    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;\n   \n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );\n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);\n    pPlayer.y += 0.05;\n\tsRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );\n\n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;      \n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if ( cellCoinRND >= 0.0 )\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );\n    }\n\n    return sRes;\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nsHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 15.0 ), rd, vec3( 7.0, 4.0, 45.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 128 && t < tmax; i++ )\n        {\n            sHit h = map( ro + rd * t );\n            if( abs( h.t ) < ( 0.001 * t ) )\n            { \n                // res = vec2(t,h.y); \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n    \n    return sRes;\n}\n\nsHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 5.0 ), rd, vec3( 4.0, 4.0, 25.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 32 && t < tmax; i++ )\n        {\n            sHit h = mapRefl( ro + rd * t );\n            if( abs( h.t ) < ( 0.001 * t ) )\n            { \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n\n    return sRes;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    // vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 e = vec2( 1.0, -1.0 ) * 0.5773 * 0.01;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map( pos + 0.0005 * e ).x;\n    }\n    return normalize( n );\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = ZERO; i < 5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) / 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -( dd - hr ) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 ) * (0.5 + 0.5 * nor.y );\n}\n\nvec3 getSkyColor( vec3 rd )\n{\n    vec3 color = mix( SKY_COLOR_1 * 1.4, SKY_COLOR_2, rd.y / 9.0 );\n\t\n    float fogFalloff = clamp( 8.0 * rd.y, 0.0, 1.0 );\n    color = mix( FOG_COLOR, color, fogFalloff );\n    color = mix( color, GRID_COLOR_1, smoothstep( -0.1, -0.2, rd.y ) );\n\n    vec3 sunDir = normalize( SUN_DIRECTION );\n    float sunGlow = smoothstep( 0.9, 1.0, dot( rd, sunDir ) );\n        \n    rd = mix( rd, sunDir, -1.0 ); // easier to bend vectors than fiddle with falloff :P\n    float sun = smoothstep( 0.987, 0.99, dot(rd, sunDir ) );\n    sun -= smoothstep( 0.1, 0.9, 0.5 );\t\t\t        \n    \n    float stripes = mod( 50.0 * ( pow( rd.y + 0.15, 1.5 ) ) + 0.5, 1.0 ) -0.5;\n    stripes = smoothstep( 0.2, 0.21, abs( stripes ) );\n        \n    \n    // based on https://www.shadertoy.com/view/tssSz7\n    vec2 starTile   = floor( rd.xy * 40.0 );\n    vec2 starPos    = fract( rd.xy * 40.0 ) * 2.0 - 1.0;\n    vec2 starRand = hash22( starTile );\n    starPos += starRand * 2.0 - 1.0;\n    float stars = saturate( 1.0 - ( ( sin( iTime * 1.0 + 50.0 * rd.y ) ) * 0.5 + 6.0 ) * length( starPos ) );\n    stars *= step( 0.0, -sun );\n    stars *= step( 0.9, starRand.x );\n    stars *= 5.0;\n           \n    sun = 2.0 * clamp( sun * stripes, 0.0, 1.0 );\n    \n    vec3 sunCol = 4.0 * mix( SUN_COLOR_1, SUN_COLOR_2, -( rd.y - 0.1 ) / 0.3 );\n    color = mix( color, sunCol, sun );\n\n\tcolor = mix( FOG_COLOR, color, 0.8 + 0.2 * fogFalloff );\n    color = mix( color, sunCol, 0.25 * sunGlow );\n    \n    color += stars;\n\n    // return vec3(stripes);\n    // return vec3(sun);\n    // return vec3(sunGlow);\n    return color;\n}\n\nvec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )\n{       \n    vec2 bent = getBent();\n    // repeat car rotation with fixes\n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;\n\n    vec3 albedo = vec3( 0.5 );\n    float met = 1.0;\n    vec4 color = vec4( albedo, met );\n    vec3 emissive = vec3( 0.0 );\n        \n    if ( m == 0.0 )\n    {\n        vec2 p0 = lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1.) / GRID_SIZE;\n        \n    \talbedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE / GRID_SIZE, gln ) );\n        \n        float pSideLine = lPos.x;\n\t\tpSideLine = abs( pSideLine );\n        pSideLine -= 1.45;\n        pSideLine = abs( pSideLine );\n        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );\n        \n        float pCenterLine = lPos.x;\n\t\tpCenterLine = abs( pCenterLine );\n        pCenterLine -= 0.55;\n        pCenterLine = abs( pCenterLine );\n        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );\n        \n        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;\n        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );\n        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );\n        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );\n               \n        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.5, lPos.z - 2.0 * g_S.playerPos.y );\n        pTrail.x += 4.0 * rotY; // move the cos\n        pTrail.x -= 4.0 * rotY * ( cos( 0.75 * pTrail.y - 0.1 * PI ) * 0.5 + 0.5 ); // fake car turns\n        pTrail.x = abs( pTrail.x );\n        pTrail.x -= 0.28;\n        pTrail.x = abs( pTrail.x );\n               \n        float trailMask = exp( -30.0 * pTrail.x );\n        trailMask += 0.2 * saturate( exp( -4.0 * pTrail.x ) );\n        trailMask *= saturate( -pTrail.y + 0.5 );\t\t// clamp on Y\n        trailMask *= saturate(  pTrail.y * 0.5 + 1.5 );\t// clamp on Y\n        emissive += vec3( 1.5, 0.2, 0.0 ) * trailMask;       \n    }\n    \n    if ( m == 1.0 )\n    {\n        vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n        \n        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );\n        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );\n        \n        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );\n        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );\n    }\n    \n    if ( m == 1.5 )\n    {\n        emissive = albedo = vec3( 1.5, 0.5, 0.5 );\n    }\n    \n    if ( m == 1.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.5 );\n    }\n    \n    if ( m == 2.0 )\n    {\n        albedo = vec3( 1.0, 1.0, 0.5 );\n        emissive = 10.0 * albedo;\n    }\n    \n    if ( m == 3.0 )\n    {\n       vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );         \n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        \n        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n    }\n    \n    if ( m == 3.5 )\n    {\n        emissive = albedo = vec3( 1.0, 0.5, 0.5 );\n    }\n    \n    if ( m == 3.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.0 );\n    }\n\n    if ( m == 4.0 )\n    {\n        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );\n    }\n            \n\t// spotlight, paramteres-\n    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );\n    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );\n    pSpot -= perSpotOffset;\n    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    vec3 spotColor  = 100.0 * vec3( 1.0 );\n    \n    pSpot.yz *= rot( -0.2  * bent.y );\n    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );\n    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );\n    spotDir.yz *= rot( 0.2 * bent.y );\n    spotDir.xz *= rot(-0.2 * rotY );\n    spotDir.yz *= rot(-0.2 * rotX );\n    \n    // spotlight, color\n    float maskDist = fract( ( length( pSpot ) - 1.0 ) );\n    float spotAtt = 1.0 / pow( 1.0 * length( pSpot ), 2.0 );\n    spotAtt *= smoothstep( 0.1, 1.1, dot( normalize( pSpot ), spotDir ) );\n    spotAtt *= saturate( dot( -nor, spotDir ) );\n    emissive += albedo * spotColor * spotAtt;    \n        \n    float fre = pow( 0.5 * ( 1.0 + dot( nor, rd ) ), 2.0 );\n    float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n    float occ = calcAO( wPos, nor );    \n    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.2, 0.0 ) );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tvec3  hal = normalize( lig - rd );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 64.0 )\n        * dif\n        * ( 0.04 + 0.96 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 1.0 ), 5.0 ) );\n   \n    color.rgb = albedo * ( 0.5 + 0.5 * occ ) * ( 0.7 + 0.3 * dif ) + spe * vec3( 1.0, 0.5, 0.1 );\n\tcolor.rgb += emissive;\n\tcolor.a = fre;\n    \n    return color;\n    // return vec4(vec3(0.4) * m, 0.5); // debug material ID\n    // return vec4(vec3(fre), 0.0);\n}\n\nfloat densityNoise( vec3 pos )\n{\n    vec2 bent = getBent();\n    \n    float noise = 1.0;\n    float noiseDetail = textureLod( iChannel1, vec2( 1.0, 1.0 ) * pos.xz / 64.0, 0.0 ).x;        \n    pos.x -= pos.y;\n    vec2 uv1 = vec2( 0.2, 1.5 ) * pos.xz / 64.0 + iTime * vec2( 0.01, 0.1 );\n    float noiseBase = textureLod( iChannel1, uv1, 0.0 ).y;\n    noise = step( 0.6, noiseBase );\n    noise *= noiseDetail * 0.5 + 0.5;\n    noise *= smoothstep( 1.5, 0.0, pos.y ); // height falloff    \n    noise *= ( 1.0 - bent.y ); // disable on hills    \n\treturn noise;\n}\n\nvoid volumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT )\n{ // From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n    float gFogDensity\t\t= 0.1;\n    rayOrigin.z += 2.0 * g_S.playerPos.y;\n    \n    sceneT = sceneT <= 0.0 ? 100.0 : sceneT;\n    \n    vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    float dither = fract( seed.z * fract( dot( gl_FragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = ZERO; i < 32; ++i )\n    {\n        float t = ( float( i ) + 0.5 + dither ) * 5.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n            float s = densityNoise( p );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.0 - saturate( fogAlpha );\n    vec3 fogColor = FOG_COLOR + vec3( 1.0 );\n    color = mix( fogColor, color, fogAlpha );\n    // color = vec3(0.01)*sceneT;\n}\n\nvec3 Bloom()\n{\n    vec3 bloom = vec3( 0.0 );\n    bloom += vec3( 1.0, 0.2, 0.1 )  * 0.5 * vec3( exp( -g_glowCoin * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.1 )  * 0.3 * vec3( exp( -g_glowCoinRefl * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 1.0 * vec3( exp( -saturate(g_glowPlayer) * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.5 * vec3( exp( -saturate(g_glowPlayerRefl) * 10.0 ) );\n    bloom += vec3( 1.0, 0.05, 0.0 ) * 0.3 * vec3( exp( -saturate(g_glowPlayerLights) * 15.0 ) );\n    bloom += vec3( 0.0, 0.05, 1.0 ) * 0.3 * vec3( exp( -saturate(g_glowPlayerFront) * 15.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.5 * vec3( exp( -saturate(g_glowEnemy) * 5.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.0 * vec3( exp( -saturate(g_glowEnemyRefl) * 5.0 ) );\n    return bloom;\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 sky = getSkyColor( rd );\n    vec4 col = vec4( sky, 1.0 );\n    sHit sRes = castRay( ro, rd, 1.0, 40.0 );\n    float t = sRes.t;\n\tfloat m = sRes.m;\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\t\t\n        col = shade( pos, sRes.lPos, nor, rd, m );\n\n#ifdef REFLECTIONS\n        vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n\t    float dither = fract( seed.z * fract( dot( gl_FragCoord.yx + fract( iTime ), seed.xy ) ) );\n\n        vec4 bounceCol = vec4( getSkyColor( ref ), 0.0 );\n        ref = normalize( mix( ref, vec3(0.0, 1.0, 0.0 ), dither * 0.1 ) );\n        sHit bounceRes = castRayRefl( pos, ref, 0.1, 20.0 ); // only trace for bloom, do not shade\n        float bounceT = bounceRes.t;\n        if ( bounceRes.m < 0.0 )\n        \tbounceCol = vec4( getSkyColor( ref ), 0.0 );\n\n        col = vec4( mix( col.xyz, bounceCol.xyz, col.w ), 0.0 );\n            \n#endif // REFLECTIONS\n        \n        col.rgb += Bloom();\n        col.rgb *= 1.5;        \n    }\n        \n    col.rgb = mix( col.rgb, FOG_COLOR, 1.0 - exp( -0.00005 * t * t * t ) );\n\n#ifdef VOLUMETRICS\n    volumetricFog( col.rgb, ro, rd, t );\n#endif // VOLUMETRICS\n    \n    // blur mask\n    col.a = 1.0 - ( dot( rd, normalize( SUN_DIRECTION + vec3( 0.0, 0.05, 0.0 ) ) ) * 0.5 + 0.5 );\n    \n\treturn col;\n}\n\nvoid drawGame3D( inout vec4 color, vec2 uv, AppState s )\n{   \n    vec2 mo = iMouse.xy / iResolution.xy;\n   \n    vec2 bent = getBent();\n\n    float fbm = fbm3( vec3( 1000.0 * iTime ) );\n    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );\n    // camera\t    \n    float roll = -0.1 * bent.x;\n    float arm = 3.5 + 0.2 * s.paceScale;\n    float angleH = -0.5 * PI + 0.1 * bent.x;\n    float height = 1.2 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;\n    float fov = 2.0 - 0.5 * s.paceScale;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );\n        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );\n        angleH += iTime - s.timeFailed;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;\n        roll = -0.1 * ( mo.x - 0.5 );\n        angleH += 0.5 * ( mo.x - 0.5 );\n        height += 0.5 * (mo.y - 0.5 );                \n    }\n    \n    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );\n    \n#ifdef DEBUG_CAMERA    \n    roll = 0.0;\n    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );\n#endif        \n    \n    vec3 ta = vec3(\n        0.0, \n        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),\n        0.0\n    );\n\n#ifdef CAM_STICKED    \n    ro.x += s.playerPos.x;\n    ta.x += s.playerPos.x;\n#endif    \n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, roll );\n   \n    // ray direction\n    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );\n    \n    // render\t\n    vec4 col = render( ro, rd );\n       \n    color = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.0);\n    \n\tvec2 q = F.xy / R.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\n#endif // FORCED_RATIO    \n    \n    AppState s;\n    loadState( iChannel0, s );\n    g_S = s;\n\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n       \n    vec2 pGame = p;\n    pGame.x *= -1.0; // flip axis to match Flat version\n    drawGame3D( color, pGame, s );\n   \n#ifdef DEBUG_2D\n    vec2 p0 = p;    \n    p0 *= 2.0;\n    p0 -= vec2( -3.0, 0.0 );\n    if ( p0.x < 0.7 && p0.y > -1.0 )\n    {\n        // drawGameFlat( color, p0, s );\n    \t// drawUI(color, p0, s);\n    }\n#endif    \n    \n\tfragColor = color;\n}", "buffer_b_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Copyright  2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Sunset Drive Unlimited\n//  Endless runner with synthwave stylization\n//\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n//\thttps://www.shadertoy.com/view/wssSD4\n\n// #define options in Common tab\n//  Some effects can be disabled on low end gpus\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU\n\n// First draft created in 24h on Game Jam Square 26-28.04.2019\n//\tFinished after couple of spare evenings on 24.06.2019\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Other snippets credits in comments next to the code\n// Thank you guys for sharing it, hope you like it :)\n\n// Music: Lifelike - So Electric\n//  https://soundcloud.com/rombo_rama/lifelike-so-electric\n\n\n\nfloat textSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\n\nvoid menuText( inout vec3 color, vec2 p, in AppState s )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? ( t.x < 4. ? 1768452929u : ( t.x < 8. ? 1768777835u : ( t.x < 12. ? 5653614u : 0u ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 1752383839u : ( t.x < 16. ? 1835559785u : 5664361u ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 86u : 0u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n\tvec3 textColor = vec3( 1.0 );\n\n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nfloat titleText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? ( t.x < 4. ? 1397642579u : ( t.x < 8. ? 1142969413u : ( t.x < 12. ? 1163282770u : ( t.x < 16. ? 1280202016u : ( t.x < 20. ? 1414090057u : 17477u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat spaceText(vec2 p)\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = (p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat highscoreText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );\n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1751607624u : ( t.x < 8. ? 1919902579u : 14949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nvoid drawUI(inout vec3 color, vec2 p, AppState s)\n{\n    p *= R.y / R.x; // ratio and resolution indepenent scaling\n    p *= 1.75;\n    \n    // splash screen   \n    if ( s.stateID == GS_SPLASH )\n    {\n        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); // dark text bg\n\t\tvec2 p2 = p;\n\t\tp2 *= 50.;\n\t\tp2 -= vec2( -45, 27. );\n        // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); // horiz guide\n        \n        float maskTitle = titleText( p2 ); // Sunset Drive Unlimited\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );\n        \n\t\tvec2 p1 = p;\n\t\tp1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );\n\t\tp1 -= vec2( -47., -42. );\n        float maskSpace = spaceText( p1 ); // press [space] to start\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );\n\n\t\tvec2 p3 = p;\n\t\tp3 *= 60.;\n\t\tp3 -= vec2( -30, 25. );\n        float maskHs = highscoreText( p3 ); // Highscore\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );\n\n\t\tvec2 pScore = p;\n        pScore *= 12.0;\n        pScore -= vec2( 1.3, 5.3 );\n        float sScore = printInt( pScore, s.highscore );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n    else\n    {\n        vec2 pScore = p;\n        pScore *= 6.0;\n        pScore -= vec2( -0.9, 3.4 );\n        float maxDigits = ceil( log2( s.score ) / log2( 10.0 ) );\n        pScore.x += 0.5 * maxDigits;\n        float sScore = printInt( pScore, s.score );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n\n\t// color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); // center guide\n    // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); // horiz guide\n}\n\nconst float gaussianWeights[6] = float[] (\n\t0.12801,\n\t0.12299,\n\t0.10908,\n\t0.08931,\n\t0.06750,\n\t0.04709 \n);\n\nvec3 rbg( sampler2D t, vec2 UV, vec2 dir )\n{\n\tvec3 c = vec3( 0 );\n\tvec2 uv = 1.0 - 2.0 * UV;\t\n    vec2 rRcp = 1.0 / vec2( 1920.0, 1080.0 );\n\tfor( int i = -5; i < 6; ++i )\n    {\n\t\tc += gaussianWeights[abs( i )] * textureLod( t, 0.5 - 0.5 * ( uv + rRcp * dir * float( i ) ), 0.0 ).rgb;\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n \tvec2 uv = F.xy / R.xy;\n    vec2 p = -1. + 2. * uv;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n    \n    AppState s;\n    loadState( iChannel1, s );\n    \n    float scale = 5.0 * s.paceScale;\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        scale = 1.0;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        scale = 4.0;\n    }\n    \n    scale += 0.1;\n\n\tvec4 beauty = texture( iChannel0, uv );\n    vec2 dir = normalize( vec2( dFdx( beauty.a ), dFdy( beauty.a ) ) );\n    vec3 blurred = rbg( iChannel0, uv, dir * scale );    \n    float blurMask = 0.1 + smoothstep( 0.0, 0.2, beauty.a ); // 0.1 bias to blur a bit dithered volumetrics at center\n    vec3 color = mix( beauty.rgb, blurred, blurMask ); \n\n#ifdef SHOW_UI\n        drawUI( color, p, s );\n#endif\n        \n    fragColor = vec4( color, 1.0 );\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Copyright  2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Sunset Drive Unlimited\n//  Endless runner with synthwave stylization\n//\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n//\thttps://www.shadertoy.com/view/wssSD4\n\n// #define options in Common tab\n//  Some effects can be disabled on low end gpus\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU\n\n// First draft created in 24h on Game Jam Square 26-28.04.2019\n//\tFinished after couple of spare evenings on 24.06.2019\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Other snippets credits in comments next to the code\n// Thank you guys for sharing it, hope you like it :)\n\n// Music: Lifelike - So Electric\n//  https://soundcloud.com/rombo_rama/lifelike-so-electric\n\n\n\nvec2 barrelDistortion( vec2 coord, float amt, float zoom )\n{ // based on gtoledo3 (XslGz8)\n  // added zoomimg\n\tvec2 cc = coord - 0.5;\n    vec2 p = cc * zoom;\n    coord = p + 0.5;\n\tfloat dist = dot( cc, cc );\n\treturn coord + cc * dist * amt;\n}\n\nvec3 tonemapACES( vec3 x )\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\t        \n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 ca( sampler2D t, vec2 UV )\n{\t\n\tconst int N = 8;\t\n    float scale = 1.0;\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3( 0 );\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0 / float( N );\n\tfor( int i = 0; i < N; ++i )\n    {\n\t\tc.r += f * texture( t, 0.5 - 0.5 * ( ( uv ) * rf ) ).r;\n\t\tc.g += f * texture( t, 0.5 - 0.5 * ( ( uv ) * gf ) ).g;\n\t\tc.b += f * texture( t, 0.5 - 0.5 * ( ( uv ) * bf ) ).b;\n\t\trf *= mix( 1.0, 0.9972, scale );\n\t\tgf *= mix( 1.0, 0.998,  scale );\n        bf /= mix( 1.0, 0.9988, scale );\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO        \n\tfloat bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n\n    // barrel distortion\n\tvec2 uvb = barrelDistortion( uv, 0.1, 0.97 );\n    \n    // chromatic aberration\t\n    vec3 color;\n\tcolor.rgb = ca( iChannel0, uv );\n    // color = texture( iChannel0, uv ).rgb;\n    \n    // vignette\n\tcolor.rgb *= 0.7 + 0.3 * clamp( pow( 28.0 * uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 2.0 ), 0.0, 1.0 );\n\t\n\t// grade\n#ifdef GRADE\n    color.rgb = smoothstep( vec3( -0.05 ), vec3( 0.8 ), color.rgb );\n#endif\n          \n    color.rgb = tonemapACES( color.rgb );\n     \n\tfragColor.rgb = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXyRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[960, 960, 985, 1031, 2507], [2509, 2509, 2566, 2566, 3267]]}
{"id": "ddsyzS", "name": "Fractal braids", "author": "AndrewB330", "description": "Inspired by: https://twitter.com/Yugemaku/status/1669282000077983744?t=owWEnj-YCzsDxlyV2GAqHg&s=35", "tags": ["fractal", "curves", "reproduction", "braids"], "likes": 24, "viewed": 303, "published": 3, "date": "1686964052", "time_retrieved": "2024-07-30T17:49:14.633594", "image_code": "const float M_PI = 3.14159265358979323846264338327950288;\nconst float M_PI_T2 = M_PI * 2.0;\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\nconst vec3 LIGHT = normalize(vec3(1.0));\n\nfloat sqr(float x) { return x * x; }\n\nvec3 point_on_curve(float t, float phase, float stretch)\n{\n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    return vec3(cs, t * stretch, sn * cs);\n}\n\nfloat dist_to_point_on_curve(vec3 p, float t, float phase, float stretch)\n{\n    return length(point_on_curve(t, phase, stretch) - p);\n}\n\nfloat dist_to_point_on_curve_dt(vec3 p, float t, float phase, float stretch)\n{\n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    return 2.0 * (sn * (p.x - cs) + (sqr(sn) - sqr(cs)) * (p.z - sn * cs) - stretch * (p.y - stretch * t));\n}\n\nfloat nearest_point_on_curve(vec3 p, float phase, float stretch)\n{\n    float t = p.y / stretch;\n    for (int i = 0; i < 16;i++)\n    {\n        float dt = dist_to_point_on_curve_dt(p, t, phase, stretch);\n        t -= dt * 0.1;\n    }\n    return t;\n}\n\nfloat dist_to_curve(vec3 p, float phase, float stretch)\n{\n    float t = nearest_point_on_curve(p, phase, stretch);\n    return dist_to_point_on_curve(p, t, phase, stretch);\n}\n\nfloat approximate_curve_length(float t, float phase, float stretch)\n{\n    return t * (pow(stretch * 2.2, 1.8) + 9.9)/10.0 - sin((t + phase) * 2.0) * 0.1 * ((0.95 - cos(2.0 * (t + phase))) * 0.83) + sin(phase * 2.0) * 0.095;\n}\n\nvec3 curve_transform(vec3 p, float phase, float stretch, float radius, float target_radius)\n{\n    float t = nearest_point_on_curve(p, phase, stretch);\n    float l = approximate_curve_length(t, phase, stretch);\n    vec3 pp = point_on_curve(t, phase, stretch);\n    \n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    \n    vec3 ny = normalize(vec3(-sn, stretch, cs * cs - sn * sn));\n    vec3 nz = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 nx = normalize(cross(ny, nz));\n    nz = normalize(cross(nx, ny));\n    \n    float scale = (1.0 + target_radius) / radius;\n    return vec3(dot(p - pp, nx), l, dot(p - pp, nz)) * scale;\n}\n\nfloat sd_curve(vec3 p, float phase, float stretch, float radius)\n{\n    return (dist_to_curve(p, phase, stretch) - radius) * 0.5;\n}\n\nvec4 op(vec4 a, vec4 b)\n{\n    return a.w < b.w ? a : b;\n}\n\nvec2 uv = vec2(0.0);\n\nvec4 map(vec3 p)\n{\n    p.xyz = p.yxz;\n    float a = iTime * 0.9;\n    vec4 res = vec4(0.0, 0.0, 0.0, 1000.0);\n    \n    float stretch = 1.5;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        vec3 pp = curve_transform(p, M_PI * 4.0 / 3.0 * float(i), stretch, 0.45, 0.55);\n        \n        if (length(vec2(pp.x, pp.z)) > 2.0)\n        {\n            res = op(res, vec4(vec3(0.0), length(vec2(pp.x, pp.z)) - 0.0));\n            continue;\n        }\n        \n        float f = (sqr(sin(iTime + float(i) * 3.14 / 3.0)) + iTime) * 0.8;\n        for (int j = 0; j < 3; j++)\n        {            \n            vec3 ppp = curve_transform(pp, M_PI * 4.0 / 3.0 * float(j) + f, stretch, 0.55, 0.55);\n            \n            if (length(vec2(ppp.x, ppp.z)) > 2.0)\n            {\n                res = op(res, vec4(vec3(0.0), length(vec2(ppp.x, ppp.z)) - 0.0));\n                continue;\n            }\n            \n            for (int k = 0; k < 3; k++)\n            {\n                vec3 pppp = curve_transform(ppp, M_PI * 4.0 / 3.0 * float(k) + f / 0.2, stretch, 0.55, 0.3);\n                vec3 col = vec3(0.5 + float(i) * 0.1, 0.8 + float(j) * 0.07, 0.4 + float(k) * 0.1);\n                float index = float(i * 9 + j * 3 + k);\n                float t1 = (sin(iTime / 32.0) * 0.5 + 0.5) * 27.0;\n                float t2 = (sin(iTime / 32.0 + 16.0) * 0.5 + 0.5) * 27.0;\n                col = mix(vec3(0.4, 1.1, 1.8), col, clamp(sqr(index - t1), 0.0, 1.0));\n                col = mix(vec3(1.9, 0.99, 0.5), col, clamp(sqr(index - t2), 0.0, 1.0));\n                res = op(res, vec4(col, (length(vec2(pppp.x, pppp.z)) - 0.9)));\n            }\n        }\n    }\n    \n    res.w *= 0.03;\n    return res;\n}\n\nvec4 trace(vec3 origin, vec3 dir)\n{\n    float t = 0.0;\n    for (int i = 0; i < 80; i++)\n    {\n        vec4 h = map(origin);\n        origin += dir * h.w;\n        t += h.w;\n        if (h.w < 0.01) return vec4(h.rgb, t);\n        if (origin.z < -50.0) break;\n    }\n\n    return vec4(-1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.02;\n    return normalize(e.xyy*map(pos + e.xyy).w +\n\t\t\t\t\t e.yyx*map(pos + e.yyx).w +\n\t\t\t\t\t e.yxy*map(pos + e.yxy).w +\n\t\t\t\t\t e.xxx*map(pos + e.xxx).w);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n    vec2 ratio = iResolution.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3((uv - 0.5) * ratio, -1.0));\n    vec3 origin = vec3(0.0 + iTime * 0.1, 0.0, 4.0);\n    \n    vec4 res = trace(origin, dir);\n    if (res.w > 0.0)\n    {\n        vec3 n = calcNormal(origin + res.w * dir);\n        float l = clamp(dot(LIGHT, n), 0.0, 1.0) * 0.8 + 0.2;\n        fragColor = vec4(res.rgb * l,1.0);\n        return;\n    }\n\n    fragColor = vec4(vec3(0.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 214, 214, 230], [232, 232, 290, 290, 397], [399, 399, 474, 474, 534], [536, 536, 614, 614, 786], [788, 788, 854, 854, 1034], [1036, 1036, 1093, 1093, 1209], [1211, 1211, 1280, 1280, 1436], [1438, 1438, 1531, 1531, 2072], [2074, 2074, 2140, 2140, 2204], [2206, 2206, 2231, 2231, 2263], [2287, 2287, 2305, 2305, 3966], [3968, 3968, 4003, 4003, 4254], [4256, 4302, 4334, 4334, 4527], [4529, 4529, 4586, 4636, 5121]]}
{"id": "DdXczj", "name": "Kishimisu tutorial by leocb", "author": "leocb", "description": "As seen in https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["neon"], "likes": 1, "viewed": 202, "published": 3, "date": "1686955096", "time_retrieved": "2024-07-30T17:49:15.444426", "image_code": "vec3 pallet(in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.698, 0.028, 0.968);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.; i < 3.; i++)\n    {\n\n        // Divide the original UV into smaller fracts of itself\n        uv = fract(uv * 1.5) - .5;\n\n        // the distance from the cender of the uv (SDF)\n        float d = length(uv) * exp(-length(uv0));\n\n        // the color, based on the original uv\n        vec3 col = pallet(length(uv0) + i*.452 + iTime);\n\n        // move the SDFs\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        // the range we want to see of the SDFs, this also causes a glow\n        d = pow(0.008/d,1.3);\n\n\n        // multiply our color pallet by the visible portion of the SDF\n        col *= d;\n\n        // Iterate\n        finalColor += col;\n    }\n\n    \n    \n    fragColor = vec4(finalColor,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 210], [214, 214, 271, 271, 1136]]}
{"id": "cdfcR2", "name": "Braids", "author": "AndrewB330", "description": "Experimenting with curves", "tags": ["raymarching", "curves"], "likes": 9, "viewed": 192, "published": 3, "date": "1686954953", "time_retrieved": "2024-07-30T17:49:16.524538", "image_code": "const float M_PI = 3.14159265358979323846264338327950288;\nconst float M_PI_T2 = M_PI * 2.0;\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\nconst vec3 LIGHT = normalize(vec3(1.0));\n\nfloat sqr(float x) { return x * x; }\n\nvec3 point_on_curve(float t, float phase, float stretch)\n{\n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    return vec3(cs, t * stretch, sn * cs);\n}\n\nfloat dist_to_point_on_curve(vec3 p, float t, float phase, float stretch)\n{\n    return length(point_on_curve(t, phase, stretch) - p);\n}\n\nfloat dist_to_point_on_curve_dt(vec3 p, float t, float phase, float stretch)\n{\n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    return 2.0 * (sn * (p.x - cs) + (sqr(sn) - sqr(cs)) * (p.z - sn * cs) - stretch * (p.y - stretch * t));\n}\n\nfloat nearest_point_on_curve(vec3 p, float phase, float stretch)\n{\n    float t = p.y / stretch;\n    for (int i = 0; i < 16;i++)\n    {\n        float dt = dist_to_point_on_curve_dt(p, t, phase, stretch);\n        t -= dt * 0.1;\n    }\n    return t;\n}\n\nfloat dist_to_curve(vec3 p, float phase, float stretch)\n{\n    float t = nearest_point_on_curve(p, phase, stretch);\n    return dist_to_point_on_curve(p, t, phase, stretch);\n}\n\nfloat sd_curve(vec3 p, float phase, float stretch, float radius)\n{\n    return (dist_to_curve(p, phase, stretch) - radius) * 0.5;\n}\n\nvec4 op(vec4 a, vec4 b)\n{\n    return a.w < b.w ? a : b;\n}\n\nvec4 map_braid(vec3 p, float phase, float stretch)\n{\n    float radius = 0.65;\n    \n    // Check if near the bounding cylinder\n    float bb = length(vec2(p.x, p.z)) - 1.0 - radius;\n    if (bb > 0.3)\n    {\n        return vec4(1.0, 1.0, 1.0, bb * 0.7);\n    }\n    \n    // Union of 3 curves with phase shift\n    // 235, 209, 138\n    vec4 res = vec4(vec3(0.9, 0.8, 0.5), sd_curve(p, M_PI * 0.0 / 3.0 + phase, stretch, radius));\n    res = op(res, vec4(vec3(0.99, 0.9, 0.7), sd_curve(p, M_PI * 2.0 / 3.0 + phase, stretch, radius)));\n    res = op(res, vec4(vec3(0.8, 0.6, 0.4), sd_curve(p, M_PI * 4.0 / 3.0 + phase, stretch, radius)));\n    return res;\n}\n\nvec3 transform(vec3 p, vec3 up, vec3 forward, vec3 center, float angle)\n{\n    p -= center;\n    up = normalize(up);\n    forward = normalize(forward);\n    vec3 right = cross(up, forward);\n    forward = cross(up, right);\n    p = vec3(dot(p, right), dot(p, up), dot(p, forward));\n    p = vec3(p.x * cos(angle) + p.z * sin(angle), p.y, p.z * cos(angle) - p.x * sin(angle));\n    return p;\n}\n\nvec4 map(vec3 p)\n{\n    float a = iTime * 0.1;\n    p = vec3(p.x * cos(a) + p.y * sin(a), p.y * cos(a) - p.x * sin(a), p.z);\n    \n    vec4 res = vec4(0.0, 0.0, 0.0, 1000.0);\n    \n    float h1 = 0.0;\n    float h2 = 0.0;\n\n    for (int i = 0; i < 14; i++)\n    {\n        // Random transform\n        h1 += 0.1523;\n        h2 += 0.1723;\n        float dx = fract(sin(h1 * 12.9898) * 43758.5453) - 0.5;\n        float dy = fract(sin(h1 * 78.233) * 43758.5453) - 0.5;\n        float x = (fract(sin(h2 * 12.9898) * 43758.5453) - 0.5) * 8.0;\n        float y = (fract(sin(h2 * 78.233) * 43758.5453) - 0.5) * 8.0;\n        vec3 pp = transform(p, vec3(dx, dy, 0.0), vec3(0.0, 0.0, 1.0), vec3(x, y, -3.0) * float(i), 3.0 * cos(iTime + h2 * 10.0));\n        res = op(res, map_braid(pp, iTime, 1.5 + sin(iTime + h1 * 15.0) * 0.5));\n    }\n    \n    return res;\n}\n\nvec4 trace(vec3 origin, vec3 dir, out float sum)\n{\n    float t = 0.0;\n    float mn = 100.0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec4 h = map(origin);\n        origin += dir * h.w;\n        t += h.w;\n        if (h.w < 0.01) return vec4(h.rgb, t);\n        sum += 1.0;\n        if (origin.z < -50.0) break;\n    }\n\n    return vec4(map(origin).rgb, -mn);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.02;\n    return normalize(e.xyy*map(pos + e.xyy).w +\n\t\t\t\t\t e.yyx*map(pos + e.yyx).w +\n\t\t\t\t\t e.yxy*map(pos + e.yxy).w +\n\t\t\t\t\t e.xxx*map(pos + e.xxx).w);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ratio = iResolution.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3((uv - 0.5) * ratio, -1.0));\n    vec3 origin = vec3(0.0, 0.0 + iTime * 0.0, 15.0);\n    \n    float res_sum = 0.0;\n    vec4 res = trace(origin, dir, res_sum);\n    if (res.w > 0.0)\n    {\n        vec3 n = calcNormal(origin + res.w * dir);\n        float l = clamp(dot(LIGHT, n), 0.0, 1.0) * 0.8 + 0.2 + clamp(res_sum * 0.01, 0.0, 1.0);\n        vec4 shadow_res = trace(origin + res.w * dir + LIGHT * 0.1, LIGHT, res_sum);\n        if (shadow_res.w > 0.0)\n        {\n            //l = 0.2;\n        }\n        fragColor = vec4(res.rgb * l,1.0);\n        return;\n    }\n\n    fragColor = vec4(vec3(0.99, 0.9, 0.7) * res_sum * 0.005, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 214, 214, 230], [232, 232, 290, 290, 397], [399, 399, 474, 474, 534], [536, 536, 614, 614, 786], [788, 788, 854, 854, 1034], [1036, 1036, 1093, 1093, 1209], [1211, 1211, 1277, 1277, 1341], [1343, 1343, 1368, 1368, 1400], [1402, 1402, 1454, 1454, 2046], [2048, 2048, 2121, 2121, 2432], [2434, 2434, 2452, 2452, 3271], [3273, 3273, 3323, 3323, 3633], [3635, 3681, 3713, 3713, 3906], [3908, 3908, 3965, 4015, 4764]]}
{"id": "DslyD8", "name": "Mandelbrot Zoom (cuzzo008)", "author": "cuzzo008", "description": " Mandelbrot Zoom\nMy first shader program.\nRuns out of float precision pretty fast!", "tags": ["fractal", "mandelbrot", "psychedelic"], "likes": 2, "viewed": 221, "published": 3, "date": "1686946518", "time_retrieved": "2024-07-30T17:49:17.415157", "image_code": "const float E = exp(1.0);\nconst float PI = radians(180.0);\nconst int depth = 1000;\nconst float logDepth = log(float(depth));\nconst float limitNorm = 100.0;\nconst float squaredLimitNorm = limitNorm * limitNorm;\nconst vec2 zoomCenter = vec2(-0.77568377, 0.13646737);\nconst float timeConstant = 2.0;\nconst float baseWidth = 1.0;\nconst float baseWidthInverse = 1.0 / baseWidth;\n\nconst vec2 redMap = vec2(0.0, 1.0);\nconst vec2 greenMap = vec2(PI/3.0, 1.0);\nconst vec2 blueMap = vec2(2.0*PI/3.0, 1.0);\nconst vec3 colorMin = vec3(0.0, 0.0, 0.0);\nconst vec3 colorMax = vec3(1.0, 1.0, 1.0);\nconst float colorChangeFiddleFactor = 1.0;\n\nvec2 complexProd( in vec2 p1, in vec2 p2) {\n    float imaginaryPart = dot(p1.xy, p2.yx);\n    p1.y = -p1.y;\n    float realPart = dot(p1.xy, p2.xy);\n    return vec2(realPart, imaginaryPart);\n}\n\nfloat invLerp( in float a, in float b, in float c) {\n    return (b - a) / (c - a);\n}\n\nfloat iterationsBeforeLimit( in vec2 c) {\n    int iterations = 1;\n    vec2 currentPoint = vec2(0.0,0.0);\n    float lastContainedSquaredNorm = 0.0;\n    float currentPointSquaredNorm = 0.0;\n    for (int i = 0; i < depth; i++) {\n        currentPoint = complexProd(currentPoint, currentPoint);\n        currentPoint += c;\n        currentPointSquaredNorm = dot(currentPoint, currentPoint);\n        iterations += (currentPointSquaredNorm < squaredLimitNorm) ? 1 : 0;\n        lastContainedSquaredNorm = (currentPointSquaredNorm < squaredLimitNorm)\n                                 ? currentPointSquaredNorm\n                                 : lastContainedSquaredNorm;\n    }\n    float fractionalPart = invLerp(limitNorm, lastContainedSquaredNorm, squaredLimitNorm);\n    return float(iterations) - fractionalPart;\n}\n\nvec3 color( in float iterations )\n{\n    float a = 4.0*PI * log(iterations) / logDepth;\n    float adjTime = iTime*colorChangeFiddleFactor;\n    vec3 b = sin(a + vec3(redMap.x + adjTime*redMap.y, greenMap.x + adjTime*greenMap.y, blueMap.x + adjTime*blueMap.y));\n    b *= b;\n    return b;\n}\n\nvec2 complexCoord( in vec2 NDC ) {\n    vec2 coord = vec2(0.5 - NDC.x, NDC.y - 0.5);\n    coord /= (baseWidthInverse * exp(iTime/timeConstant));\n    coord.y *= iResolution.y / iResolution.x;\n    coord += zoomCenter;\n    return coord;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 complexCoord = complexCoord(uv);\n\n    // Time varying pixel color\n    vec3 col = color(iterationsBeforeLimit(complexCoord));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[626, 626, 669, 669, 816], [818, 818, 870, 870, 902], [904, 904, 945, 945, 1709], [1711, 1711, 1746, 1746, 1997], [1999, 1999, 2033, 2033, 2232], [2234, 2234, 2291, 2341, 2573]]}
{"id": "DdlyRB", "name": "Component Highlighter", "author": "cuzzo008", "description": "Rudimentary highlighter of \"smooth components\" of a 2D scene.\nNeeds some time to converge, more time if resolution is higher.\nClick around, some components are invisibly small.", "tags": ["graph", "interactivity", "persistence", "computation"], "likes": 2, "viewed": 176, "published": 3, "date": "1686945333", "time_retrieved": "2024-07-30T17:49:18.282837", "image_code": "#define IMG_CHAN iChannel0\n#define COMP_CHAN iChannel1\n#define BLURRED_IMG_CHAN iChannel2\n\n// direction should be normalized\nfloat shimmer(vec2 coord, vec2 direction, float width, float len, float rate, float gleam, float gleamRate) {\n    float isoLine = mod(dot(coord, direction.yx) + (iTime * len) / rate, len);\n    isoLine = mix(len - isoLine, isoLine, step(0.0, isoLine));\n    float sine = sin(isoLine * PI / width);\n    float glimmer = sin(iTime* PI / gleamRate);\n    glimmer = (1.0 - gleam) + gleam*(glimmer * glimmer);\n    return glimmer * mix(sine * sine, 0.0, step(width, isoLine));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixelCoord = ivec2(fragCoord);\n    ivec2 mouseCoord = ivec2(iMouse.xy);\n    \n    vec4 pixelComponentID = texelFetch(COMP_CHAN, pixelCoord, 0);\n    vec4 mouseComponentID = texelFetch(COMP_CHAN, mouseCoord, 0);\n    bool sameComponent = all(equal(pixelComponentID, mouseComponentID));\n    \n    vec4 baseColor = texelFetch(IMG_CHAN, pixelCoord, 0);\n    vec2 shimmerCoord = fragCoord;\n    vec2 shimmerDirection = vec2(-sqrt(2.0)/2.0, sqrt(2.0)/2.0);\n    // radial shimmering from mouseclick point\n    // shimmerCoord = fragCoord - iMouse.xy;\n    // shimmerDirection = -normalize(shimmerCoord).yx;\n    float scalar = shimmer(shimmerCoord, shimmerDirection, 15.0, 120.0, 1.0, 0.6, 1.59283);\n    \n    fragColor = mix(0.75 * baseColor, (0.90 * baseColor) + 0.1*scalar * vec4(1.0), float(sameComponent));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DOWN_PRESSED() texelFetch(KEY_CHAN, ivec2(KEY_DOWN, 0), 0).r\n\nconst float PI = radians(180.0);\nconst int KEY_DOWN  = 40;\n\nconst float distThreshold = 0.01; // Tweak me!\nconst float distThresholdSquared = distThreshold * distThreshold;\n\nconst float blurRadius = 5.0; // Tweak me!\nconst float blurRadiusCeil = ceil(blurRadius);\nconst float blurRadiusSquared = blurRadius * blurRadius;\nfloat blurredPixelWeight(float squaredDist) {\n    return mix(0.0, inversesqrt(1.0 + squaredDist), step(squaredDist, blurRadiusSquared));\n}\n\n/* The main thing that needs adjustment is the color distance function should correspond\n * better to human perception.  Maybe we need some kind of edge detection buffer too.\n * Could consider using some 2D linear-best-fit ideas.\n */", "buffer_a_code": "// Buffer A holds the source image to analyze\n\n#define IMG_CHAN iChannel0\n#define IMG_CHAN_RES ivec2(iChannelResolution[0].xy)\n#define SELF_CHAN iChannel1\n#define SELF_CHAN_RES ivec2(iChannelResolution[1].xy)\n#define KEY_CHAN iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 10 && DOWN_PRESSED() == 0.0) {\n        fragColor = texelFetch(SELF_CHAN, ivec2(fragCoord), 0);\n    } else {\n        fragColor = texelFetch(IMG_CHAN, ivec2(fragCoord) % IMG_CHAN_RES, 0);\n    }\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B holds a processed version of Buffer A\n\n#define IMG_CHAN iChannel0\n#define SELF_CHAN iChannel1\n#define IMG_CHAN_RES ivec2(iChannelResolution[1].xy)\n#define KEY_CHAN iChannel3\n\nvec4 blur(vec2 coord) {\n    vec4 aggr = vec4(0.0);\n    float aggrWeight = 0.0;\n    for (float i = -blurRadiusCeil; i <= blurRadiusCeil; i++) {\n        for (float j = -blurRadiusCeil; j <= blurRadiusCeil; j++) {\n            vec2 pixelOffset = vec2(i, j);\n            ivec2 pixelCoord = ivec2(coord + pixelOffset);\n            float withinBounds = float(   pixelCoord.x >= 0\n                                       && pixelCoord.y >= 0\n                                       && pixelCoord.x < IMG_CHAN_RES.x\n                                       && pixelCoord.y < IMG_CHAN_RES.y);\n            float squaredDistance = dot(pixelOffset, pixelOffset);\n            float weight = blurredPixelWeight(squaredDistance);\n            \n            aggrWeight += weight;\n            aggr += weight * texelFetch(IMG_CHAN, ivec2(pixelCoord), 0);        \n        }\n    }\n    return aggr / aggrWeight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 10 && DOWN_PRESSED() == 0.0) {\n        fragColor = texelFetch(SELF_CHAN, ivec2(fragCoord), 0);\n    } else {\n        fragColor = blur(fragCoord);\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/* Buffer C holds per-pixel component identification info\n * Component IDs propagate at a rate of 1 pixel per frame\n * Component IDs are the pair .xy of a pixel color, initially\n * the coordinates of the pixel.\n * Could use sequential ints for a nice speed boost, but I was a\n * bit worried about resolutions exceeding 16.7 MP getting buggy.\n */ \n\n#define IMG_CHAN iChannel0\n#define SELF_CHAN iChannel1\n#define SELF_CHAN_RES ivec2(iChannelResolution[1].xy)\n#define KEY_CHAN iChannel3\n\nconst ivec2[] neighborhood = ivec2[](\n    ivec2(-1, -1),\n    ivec2(-1, 0),\n    ivec2(-1, 1),\n    ivec2(0,-1),\n    ivec2(0,1),\n    ivec2(1,-1),\n    ivec2(1,0),\n    ivec2(1,1)\n);\n\n/*\nconst ivec2[] neighborhood = ivec2[](\n    ivec2(-1,0),\n    ivec2(0,-1),\n    ivec2(0,1),\n    ivec2(1,0)\n);\n*/\n\n// Could possibly be done faster with some clever tricks?\n// In general this method takes 2n - 1 comparisons for dimension n.\nvec2 lexicographicMin(vec2 v1, vec2 v2) {\n    vec2 minimum = mix(v1, v2, step(v2.y, v1.y));\n    minimum = mix(v1, minimum, step(minimum.x, v1.x));\n    minimum = mix(v2, minimum, step(minimum.x, v2.x));\n    return minimum;\n}\n\nfloat distanceWithinThreshold(vec3 c1, vec3 c2) {\n    vec3 diff = c1 - c2;\n    float squaredDist = dot(diff, diff);\n    return step(squaredDist, distThresholdSquared);\n}\n\nvec2 minOfNeighborhood(ivec2 centerCoord) {\n    ivec2 texelCoord = centerCoord;\n    vec2 minimum = texelFetch(SELF_CHAN, centerCoord, 0).xy;\n    vec3 centerColor = texelFetch(IMG_CHAN, centerCoord, 0).xyz;\n    for (int i = 0; i < neighborhood.length(); i++) {\n        texelCoord = centerCoord + neighborhood[i];\n        texelCoord.x = clamp(texelCoord.x, 0, SELF_CHAN_RES.x - 1);\n        texelCoord.y = clamp(texelCoord.y, 0, SELF_CHAN_RES.y - 1);\n        vec2 candidateMinimum = texelFetch(SELF_CHAN, texelCoord, 0).xy;\n        vec3 candidateColor = texelFetch(IMG_CHAN, texelCoord, 0).xyz;\n        candidateMinimum = mix(minimum, candidateMinimum, distanceWithinThreshold(centerColor, candidateColor));\n        minimum = lexicographicMin(minimum, candidateMinimum);\n    }\n    return minimum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 10 && DOWN_PRESSED() == 0.0) {\n        fragColor = vec4(minOfNeighborhood(ivec2(fragCoord)), 0.0, 0.0);\n    } else {\n        fragColor = vec4(fragCoord, 0.0, 0.0);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 125, 234, 234, 593], [595, 595, 652, 652, 1459]]}
{"id": "dsfczS", "name": "Oily Black Hole", "author": "kanduvisla", "description": "My second non-tutorial shader :-P", "tags": ["wavy"], "likes": 2, "viewed": 203, "published": 3, "date": "1686910460", "time_retrieved": "2024-07-30T17:49:19.157499", "image_code": "#define PI 3.1415926538\n\nfloat calculateColor( vec2 uv, float d, float offset )\n{\n    return\n        step(0.5, 0.5 + sin(\n            (sin((uv.x / 10.) + iTime / 10.) + sin(uv.y) * d) +\n                // We add the similar step for the Y-axis, and\n                // multiply it with PI so it matches with the outer sin func\n                (step(0.9 + (0.1 - d / 50.), 0.5 + cos(\n                    cos(offset + (iTime) + (uv.x * 3.)) + (uv.y * d * 2.)\n                ) * 0.5) * PI)\n        ) * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Checkerboard:\n    float d = length(uv);\n    \n    vec3 col = vec3(\n        calculateColor( uv, d * 1.25, (PI / d) * 0.03),\n        calculateColor( uv, sin(d), (PI / d) * 0.09),\n        calculateColor( uv, sin(d * d), (PI / d) * 0.2)\n    );\n    col /= pow(d, d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 81, 81, 506], [508, 508, 565, 565, 957]]}
{"id": "mdXyRB", "name": "Truchet Path Journey", "author": "dr2", "description": "An unending path based on hexagonal Truchet tiles", "tags": ["grid", "hexagon", "truchet"], "likes": 16, "viewed": 256, "published": 3, "date": "1686909450", "time_retrieved": "2024-07-30T17:49:20.311414", "image_code": "// \"Truchet Path Journey\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 8 in \"Truchet Path\" series\n    \"Generalized Truchet Path\"    (mdXGRf)\n    \"Twisted Passage\"             (DdX3Rl)\n    \"Truchet Nets\"                (msj3RR)\n    \"Truchet's Train\"             (dd2GRy)\n    \"Forest Train Ride\"           (csjGDd)\n    \"Monorail\"                    (cdfSzl)\n    \"Monorail 2\"                  (msc3zn)\n*/\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat HexEdgeDist (vec2 p, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n\nvec4 cPath[PLEN];\nvec3 qHit, sunDir, pPos[2];\nvec2 cIdB, cIdS, cMidB, cMidS;\nfloat dstFar, tCur, hgSizeB, hgSizeS, pilHt, tEnd[PLEN + 1], tLen, trVel, cDir, cType;\nint nFrame, idObj, pType;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = sign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - vec3 (cMidS, pilHt).xzy;\n  d = HexEdgeDist (q.xz, hgSizeS - 0.001);\n  d = SmoothMax (d, q.y, 0.02);\n  DMINQ (pType);\n  return dMin;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nvoid SConf ()\n{\n  vec3 g;\n  vec2 q;\n  float s;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  cIdB = PixToHex (cMidS / hgSizeB);\n  BConf ();\n  q = (cMidS - cMidB) / hgSizeB;\n  s = min (abs (hgSizeB * TruchSDist (q).x), hgSizeB * HexEdgeDist (q) + 2.);\n  pType = (abs (s - 4.) <= 1.) ? 3 : ((s < 3.) ? 1 : 2);\n  g = (pType == 1) ? vec3 (0.02, 2.5, 0.02) : ((pType == 2) ? vec3 (0.2, 1., 0.3) :\n     vec3 (0.1, 12., 1.));\n  pilHt = g.x + g.y * Fbm2 (g.z * cMidS);\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeS;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeS));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.1;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    d = SObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    h = SObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.1, h);\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < 2; k ++) {\n    q = p - pPos[k];\n    d = length (q) - 1.3;\n    DMINQ (4);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, cm3, bgCol;\n  vec2 w, vf;\n  float dstObj, dstObjS, sh, dt, rc, ac;\n  int maxRefl;\n  maxRefl = 3;\n  bgCol = SkyCol (rd);\n  for (int k = VAR_ZERO; k < maxRefl; k ++) {\n    dstObj = ObjRay (ro, rd);\n    dstObjS = SObjRay (ro, rd);\n    if (k < maxRefl - 1 && dstObj < min (dstObjS, dstFar)) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n    } else break;\n  }\n  col = bgCol;\n  vf = vec2 (0.);\n  if (min (dstObj, dstObjS) < dstFar) {\n    ro += min (dstObj, dstObjS) * rd;\n    if (dstObj < dstObjS) {\n      vn = ObjNf (ro);\n    } else {\n      vn = SObjNf (ro);\n      dstObj = dstObjS;\n    }\n    if (idObj <= 3) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      cMidS = HexToPix (cIdS * hgSizeS);\n      BConf ();\n    }\n    if (idObj == 1) {\n      col4 = vec4 (0.4, 0.4, 0.4, 0.) * (0.9 + 0.1 * Fbm2 (8. * ro.xz));\n      cm3 = TruchSDist ((ro.xz - cMidB) / hgSizeB);\n      dt = hgSizeB * abs (cm3.x);\n      rc = abs (cm3.y);\n      ac = 18. * abs (cm3.z);\n      if (cType <= 2. && abs (cm3.y) != 0. && OnTrk ((cMidS - cMidB) / hgSizeB) && dt < 0.2)\n         col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.),\n         smoothstep (0., 0.02, abs (fract (32. * rc * ac + 0.5) - 0.5) - 0.1));\n      vf = vec2 (8., 0.2);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.2, 0.5, 0.2, 0.);\n      vf = vec2 (2., 1.);\n    } else if (idObj == 3) {\n      col4 = vec4 (HsvToRgb (vec3 (fract (0.9 + 0.3 * Hashfv2 (cIdS)), 0.4, 0.8)), 0.1);\n      w = qHit.xz / hgSizeS;\n      col4.rgb *= 1. - 0.1 * ((qHit.y > -0.02) ? smoothstep (0.5, 0.6, fract (12. *\n         HexEdgeDist (w, 1.))) : max (smoothstep (0.4, 0.41, abs (fract (3. * qHit.y) - 0.5)),\n         smoothstep (0.96, 0.97, length (w))));\n    } else if (idObj == 4) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    }\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = min (ObjSShadow (ro + 0.01 * vn, sunDir), SObjSShadow (ro + 0.01 * vn, sunDir));\n    col = col4.rgb * (0.3 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.75, 0.95, dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nfloat EvalPht (vec2 p)\n{\n  return 2. + 2.5 * Fbm2 (0.02 * p);\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, q;\n  float el, az, zmFac, asp, sr, t;\n  int vuId, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 2.;\n  asp = canvas.x / canvas.y;\n  sWin = false;\n  if (sWin) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n    if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  }\n  hgSizeB = 24.;\n  hgSizeS = 1.;\n  SetPath ();\n  trVel = 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  t = tCur  * trVel + 10.;\n  q = EvalPPos (t);\n  pPos[0] = vec3 (q, EvalPht (q)).xzy;\n  q = EvalPPos (t + 1.);\n  pPos[1] = vec3 (q, EvalPht (q)).xzy;\n  if (vuId == 0) {\n    ro.xz = EvalPPos (t - 1.5);\n    ro.y = EvalPht (ro.xz) + 4. + 1.5 * sin (0.1 * pi * tCur);\n    vd = normalize (pPos[0] - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += 0.5 * asin (vd.y);\n    el = clamp (el, -0.3 * pi, 0.1 * pi);\n    zmFac = 2.5;\n    dstFar = 12. * hgSizeB;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 80., (-1.5 * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.x -= 1.5 * hgSizeB;\n    vd = normalize (pPos[0] - ro);\n    az = 0.3 * az + atan (vd.z, - vd.x) - 0.5 * pi;\n    el = 0.3 * el + asin (vd.y);\n    el = clamp (el, -0.4 * pi, -0.12 * pi);\n    zmFac = 5.;\n    dstFar = 16. * hgSizeB;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.7, 0.7);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat HexEdgeDist (vec2 p, float h)\n{\n  p = abs (p);\n  p -= vec2 (0.5, - sqrt3/2.) * min (p.x - sqrt3 * p.y, 0.);\n  p.x -= h * sqrt3/2.;\n  return sign (p.x) * max (abs (p.x), abs (p.y) - 0.5 * h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXyRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1292, 1292, 1313, 1313, 1336], [1338, 1338, 1364, 1364, 2348], [2350, 2350, 2371, 2371, 3017], [3019, 3019, 3036, 3036, 3881], [3883, 3883, 3908, 3908, 4560], [4562, 4562, 4585, 4585, 4773], [4775, 4775, 4790, 4790, 5499], [5501, 5501, 5516, 5516, 5956], [5958, 5958, 5992, 5992, 7238], [7240, 7240, 7262, 7262, 7518], [7520, 7520, 7558, 7558, 7959], [7961, 7961, 7983, 7983, 8143], [8145, 8145, 8178, 8178, 8362], [8364, 8364, 8385, 8385, 8640], [8642, 8642, 8679, 8679, 8934], [8936, 8936, 8959, 8959, 9122], [9124, 9124, 9159, 9159, 11497], [11499, 11499, 11523, 11523, 11562], [11582, 11582, 11638, 11638, 14602], [14604, 14604, 14628, 14628, 14858], [14860, 14860, 14884, 14884, 14940], [14942, 14942, 14970, 14970, 15050], [15052, 15052, 15089, 15089, 15250], [15252, 15252, 15274, 15274, 15301], [15303, 15303, 15325, 15325, 15352], [15354, 15354, 15376, 15376, 15414], [15416, 15416, 15461, 15461, 15553], [15555, 15555, 15600, 15600, 15638], [15640, 15640, 15664, 15664, 15781], [15783, 15783, 15819, 15819, 16025], [16027, 16027, 16057, 16057, 16170], [16172, 16172, 16203, 16203, 16267], [16301, 16301, 16325, 16325, 16385], [16387, 16387, 16411, 16411, 16523], [16525, 16525, 16550, 16550, 16734], [16736, 16736, 16757, 16757, 16912], [16914, 16914, 16943, 16943, 17155], [17157, 17157, 17196, 17196, 17448]]}
{"id": "ddXyRS", "name": "Fractal Voyage", "author": "djstomp", "description": "Derived from \"Alien Structures\" by Chris Webb\nhttps://www.shadertoy.com/view/MtdBD8", "tags": ["raymarching", "fractal"], "likes": 11, "viewed": 217, "published": 3, "date": "1686906031", "time_retrieved": "2024-07-30T17:49:21.170117", "image_code": "#define ANTIALIAS 1\n#define MAX_STEPS 512\n#define PRECISION 0.001\n#define ITERATIONS 20\n\nstruct keyframe\n{\n    float time;\n    vec3 position;\n    vec3 direction;\n    float rotation;\n    float yOffset;\n    float scale;\n    vec3 offset;\n    float fieldOfView;\n    float fade;\n    vec3 g0position;\n    float g0Size;\n    float g0Strength;\n    vec3 g0c0;\n    vec3 g0c1;\n    float g1Strength;\n    vec3 g1c0;\n    vec3 g1c1;\n};\n\nkeyframe frames[] = keyframe[] \n(          \n    keyframe(0.0, \n        vec3(0.0, 0.0, 5.025), \n        vec3(0.0, 0.0, 1.0), \n        0.0, 0.74, 1.8, \n        vec3(2.8, 0.5, 0.0), \n        0.35, 0.5, \n        vec3(0.0, 0.0, 5.04), \n        0.03, 2.0, \n        vec3(1.0, 0.3, 0.1), \n        vec3(0.9, 0.25, 0.1), \n        1.5, \n        vec3(0.5, 0.2, 0.0), \n        vec3(0.5, 0.95, 0.0)),\n    keyframe(30.0, \n       vec3(0.0, 0.0, 4.975), \n       vec3(1.0, 1.0, 0.0),\n       0.0, 0.74, 1.8, \n       vec3(2.8, 0.5, 0.0),\n       1.0, 0.5, \n       vec3(0.0, 0.0, 5.04),\n       0.01, \n       1.0, \n       vec3(1.0, 0.5, 0.0), \n       vec3(0.9, 0.05, 0.0), \n       1.0, \n       vec3(0.5, 0.1, 0.0), \n       vec3(0.5, 0.7, 0.0)),\n\n    keyframe(30.0, \n       vec3(2.0, 2.0, 0.4), \n       vec3(-1.0, -1.0, -1.0), \n       0.0, 0.64, 1.8, \n       vec3(1.669, 0.022, 0.0765), \n       1.0, 0.5, \n       vec3(0.0, 0.0, 5.04), \n       0.1, 1.0, \n       vec3(0.5, 0.4, 0.9), \n       vec3(0.2, 0.5, 0.6), \n       2.0, \n       vec3(0.3, 0.5, 0.5), \n       vec3(0.9, 0.2, 0.0)),\n    keyframe(60.0, \n       vec3(2.5, 2.5, 1.0), \n       vec3(-1.0,-1.0,1.0), \n       0.0, 0.64, 1.8, \n       vec3(1.659, 0.02, 0.0765), \n       1.0, 0.5, \n       vec3(0.0, 0.0, 0.0), \n       5.0, 0.5, \n       vec3(0.9, 0.2, 0.0), \n       vec3(0.3, 0.5, 0.5), \n       3.0, \n       vec3(0.3, 0.4, 0.5), \n       vec3(0.9, 0.2, 0.0)),\n       \n    keyframe(60.0, \n       vec3(-1.10, 0.0, 3.5), \n       vec3(-1.0, 0.0,-1.0), \n       0.0, 0.74, 1.8, \n       vec3(2.1, 2.1, 0.4), \n       3.0, 0.5, \n       vec3(0.0, 0.0, 5.04), \n       0.1, 2.0, \n       vec3(0.5, 0.4, 0.9), \n       vec3(0.2, 0.5, 0.7), \n       2.0, \n       vec3(0.73, 0.5, 0.1), \n       vec3(0.5, 0.95, 0.3)),\n    keyframe(90.0, \n       vec3(0.0, 0.0, 4.8), \n       vec3(0.0, 0.0,-1.0), \n       0.0, 0.74, 1.8, \n       vec3(2.1, 2.1, 0.4), \n       1.0, 0.5, \n       vec3(0.0, 0.0, 5.04), \n       0.1, 1.0, \n       vec3(0.5, 0.4, 0.9), \n       vec3(0.2, 0.5, 0.7), \n       10.0, \n       vec3(0.73, 0.5, 0.1), \n       vec3(0.5, 0.95, 0.3)),\n\n    keyframe(90.0, \n       vec3(0.0,0.1, 2.25), \n       vec3(1.0,0.0,0.7), \n       0.0, 0.75, 1.8, \n       vec3(2.59, 0.5, 0.05), \n       1.0, 0.5, \n       vec3(0.0, 0.1, 2.25), \n       1.0, 0.5, \n       vec3(0.7, 0.2, 0.2), \n       vec3(0.3, 0.3, 0.9), \n       3.0, \n       vec3(0.7, 0.2, 0.2), \n       vec3(0.3, 0.3, 0.9)),\n    keyframe(120.0, \n       vec3(0.0, 1.5, 2.35), \n       vec3(1.0, -0.5, 0.7), \n       0.0, 0.75, 1.8, \n       vec3(2.59, 0.5, 0.05),\n       0.85, 0.5, \n       vec3(0.0, 0.1, 2.25), \n       1.5, 0.5, \n       vec3(0.2, 0.2, 0.5), \n       vec3(0.3, 0.3, 0.9), \n       3.0, \n       vec3(0.5, 0.2, 0.2), \n       vec3(0.3, 0.3, 0.9)),\n\n    keyframe(120.0, \n       vec3(0.0, 0.0, 4.0), \n       vec3(1.0, 0.0, 0.0), \n       1.0, 1.25, 2.5, \n       vec3(2.028, 1.0, 0.48), \n       1.0, 0.5, \n       vec3(0.0, 0.0, 5.04), \n       0.3, \n       1.0, \n       vec3(0.5, 0.4, 0.9), \n       vec3(0.2, 0.5, 0.7), \n       5.0, \n       vec3(0.73, 0.5, 0.1), \n       vec3(0.5, 0.95, 0.3)),\n    keyframe(150.0, \n       vec3(0.0, 1.0, 2.0), \n       vec3(1.0, 0.0, 1.0), \n       0.0, 1.4, 3.25, \n       vec3(4.0,0.5,0.8), \n       1.0, 1.0, \n       vec3(0.0, 0.0, 5.04), \n       0.3, 1.0, \n       vec3(0.5, 0.4, 0.9), \n       vec3(0.2, 0.5, 0.7), \n       5.0, \n       vec3(0.73, 0.5, 0.1), \n       vec3(0.5, 0.95, 0.3)),\n\n    keyframe(150.0, \n       vec3(2.0, 2.0, 1.0), \n       vec3(1.0, 1.0, 1.0), \n       0.0, 0.64, 1.8, \n       vec3(1.45, 0.01, 0.17), \n       1.0, 0.5, \n       vec3(2.0, 2.0, 1.0), \n       0.0, 0.3, \n       vec3(1.0, 0.0, 0.0), \n       vec3(0.2, 0.2, 0.2), \n       3.5, \n       vec3(0.4, 0.4, 0.9), \n       vec3(0.9, 0.3, 0.3)),\n    keyframe(180.0, \n       vec3(1.75, 1.75, 0.99), \n       vec3(1.0,-1.0,1.0), \n       1.0, 0.64, 1.8, \n       vec3(1.45, 0.01, 0.17), \n       1.0, 0.5, \n       vec3(2.0, 2.0, 1.0), \n       0.0, 0.3, \n       vec3(1.0, 1.0, 1.0), \n       vec3(0.2, 0.2, 0.2), \n       3.5, \n       vec3(0.3, 0.4, 1.0), \n       vec3(1.0, 0.4, 0.3))\n);\n\nkeyframe interpolateFrames(keyframe a, keyframe b, float time)\n{\n  \tkeyframe frame;\n    frame.time = time;\n    frame.position = mix(a.position, b.position, time);\n    frame.direction = mix(a.direction, b.direction, time);\n    frame.rotation = mix(a.rotation, b.rotation, time);\n    frame.yOffset = mix(a.yOffset, b.yOffset, time);\n    frame.scale = mix(a.scale, b.scale, time);\n    frame.offset = mix(a.offset, b.offset, time);\n    frame.fieldOfView = mix(a.fieldOfView, b.fieldOfView, time);\n    float timeotalTime = b.time-a.time;\n    frame.fade = clamp(0.0, 1.0, min(time * (timeotalTime/a.fade), (1.0-time) * (timeotalTime/b.fade)));    \n    frame.g0position = mix(a.g0position, b.g0position, time);\n    frame.g0Size = mix(a.g0Size, b.g0Size, time);\n    frame.g0Strength = mix(a.g0Strength, b.g0Strength, time);\n    frame.g0c0 = mix(a.g0c0, b.g0c0, time);\n\tframe.g0c1 = mix(a.g0c1, b.g0c1, time);    \n    frame.g1Strength = mix(a.g1Strength, b.g1Strength, time);\n    frame.g1c0 = mix(a.g1c0, b.g1c0, time);\n\tframe.g1c1 = mix(a.g1c1, b.g1c1, time);\n    return frame;  \n}\n\nkeyframe evaluateFrame()\n{\n    float t = 0.0;\n    float timeLoop = mod(iTime, frames[frames.length()-1].time);\n\n    int i = 0;\n    for(; i < frames.length()-1; ++i)\n    {\n        if(timeLoop < frames[i+1].time)\n        {\n            float tTime = frames[i+1].time - frames[i].time;\n            float tUp = timeLoop - frames[i].time;\n            t = tUp / tTime;\n            break;\n        }\n    }\n    \n    return interpolateFrames(frames[i], frames[i+1], t);\n}\n\nfloat map(vec3 p, keyframe frame)\n{\n    p /= 2.0;\n    float ov = 1.0 / 3.0;\n\tfloat r;\n\tint i = 0;\n\twhile (i < ITERATIONS && dot(p, p) < 10000.0)\n\t{\n\t\tp.xy = abs(p.xy);\n\t\tif(p.y > p.x) p.xy = p.yx;\n\t\tp.y = frame.yOffset - abs(p.y - frame.yOffset);\n\t\tp.x += ov;\n\t\tif(p.z > p.x) p.xz = p.zx;\n\t\tp.x -= ov;\n\t\tp.x -= ov;\n\t\tif(p.z > p.x) p.xz = p.zx;\n\t\tp.x += ov;\n\t\tp = frame.scale * (p - frame.offset) + frame.offset;\n\t\tr = dot(p, p);\n\t\t++i;\n\t}\n\n\treturn abs(length(p) - length(frame.offset)) * pow(frame.scale, float(-i));\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv, keyframe frame)\n{ \n    const float breakout = 20.0;\n    \n    int iteration = 0;\n    float depth = 0.0;\n    \n    for(; iteration < MAX_STEPS; ++iteration)\n    {\n\t    float precis = PRECISION * depth;\n\t    float dist = map(ro + rd * depth, frame);\n        \n        if(dist < precis || depth > breakout) \n        {\n            break;\n        }\n        depth += dist;\n    }\n    \n    vec3 position = ro + depth * rd;\n    \n    float glow0 = float(iteration) / float(MAX_STEPS);\n    glow0 = clamp(pow(glow0 * 3.0, 1.0), 0.0, 1.0);\n    float glow1 = pow(glow0, 3.20);\n    \n    float distFromPoint = clamp(0.0, 1.0, distance(position, frame.g0position) / frame.g0Size);\n\t\n    vec3 glowColor0 = mix(frame.g0c0, frame.g0c1, clamp(distFromPoint, 0.0, 1.0));\n    vec3 col = glowColor0 * glow0 * frame.g0Strength;\n    \n    vec3 glowColor1 = mix(frame.g1c0, frame.g1c1, clamp(0.0, 1.0, uv.y/2.0));\n\tcol.rgb += glowColor1 * glow1 * frame.g1Strength;\n    \n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tkeyframe frame = evaluateFrame();\n    \n    vec3 cSum = vec3(0.0, 0.0, 0.0);\n    \n    for(int i = 0; i < ANTIALIAS; ++i)\n    {\n        for(int j = 0; j < ANTIALIAS; ++j)\n        {\n            vec2 o = vec2(float(i),float(j)) / float(ANTIALIAS) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord+o)) / iResolution.y;\n            vec3 ro = frame.position;\n            float cr = frame.rotation;\n            vec3 cw = normalize(frame.direction);\n            vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n            vec3 cu = normalize(cross(cw ,cp));\n            vec3 cv = normalize(cross(cu, cw));\n            mat3 ca = mat3(cu, cv, cw);\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0 * frame.fieldOfView));\n\n            cSum += render(ro, rd, p, frame);\n        }\n    }\n    \n    cSum /= float(ANTIALIAS*ANTIALIAS);\n    \n    #ifndef OVERRIDE_FRAME\n    cSum.rgb *= frame.fade;\n    #endif\n\n    cSum = pow(cSum, vec3(0.4545));\n    cSum = cSum * 1.2 - 0.1;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv *=  1.0 - uv.yx;\n    \n    cSum *= clamp(0.0, 1.0, pow(uv.x*uv.y * 5.0, 0.1));\n    \n    float n = texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r;\n    cSum.rgb += mix(-3.0 / 255.0, 3.0 / 255.0, n);\n\n    fragColor = vec4(cSum, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4469, 4469, 4533, 4533, 5542], [5544, 5544, 5570, 5570, 6004], [6006, 6006, 6041, 6041, 6524], [6526, 6526, 6591, 6591, 7527], [7529, 7529, 7584, 7584, 8846]]}
{"id": "DdfyRB", "name": "Wavy CheckerBoard", "author": "kanduvisla", "description": "My first non-tutorial shader :-P", "tags": ["checkerboard"], "likes": 4, "viewed": 184, "published": 3, "date": "1686902348", "time_retrieved": "2024-07-30T17:49:22.052757", "image_code": "#define PI 3.1415926538\n\nfloat calculateColor( vec2 uv, float d, float offset )\n{\n    return\n        step(0.5, 0.5 + sin(\n            (sin(offset + iTime + (uv.y * 3. * d))) + (uv.x * 15. * pow(d, d)) +\n                // We add the similar step for the Y-axis, and\n                // multiply it with PI so it matches with the outer sin func\n                (step(0.5, 0.5 + cos(\n                    cos(offset + (iTime) + (uv.x * 3. * d)) + (uv.y * 15. * pow(d, d))\n                ) * 0.5) * PI)\n        ) * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Checkerboard:\n    float uvy = sin(uv.y * 10.);\n    float d = length(uv);\n    \n    vec3 col = vec3(\n        calculateColor( uv, 0.5 + d * 0.5, 0.0 ),\n        calculateColor( uv, 0.5 + d * 0.49, 0.1 ),\n        calculateColor( uv, 0.5 + d * 0.51, 0.2 )\n    );\n    col /= pow(d, d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 81, 81, 518], [520, 520, 577, 577, 987]]}
{"id": "ddlcDM", "name": "ResonanceFUCK", "author": "SUBAUX", "description": "I DONT KNOW WHAT THE FUCK IM DOING!!!!!", "tags": ["waves", "ripple"], "likes": 1, "viewed": 159, "published": 3, "date": "1686882828", "time_retrieved": "2024-07-30T17:49:22.953349", "image_code": "void mainImage(out vec4 o,vec2 c){\n    vec2 r=iResolution.xy,\n         m=iMouse.xy/r;\n    float t=iTime;\n    vec2 n,q,p=(c-0.5*r)/r.y;\n    float d=dot(p,p),S=50.,i,a,j;\nfor(mat2 m=mat2(cos(5.),sin(5.),-sin(5.),cos(5.));j++<300.;){\n    p*=m;\n    n*=m;\n    q=p*S+t*1.+sin(j)+n;\n    a+=dot(sin(q)/S,vec2(1.2));\n    n-=abs(sin(cos(q)+cos(t)*20.))/r;\n    S*=1.0;\n}\n    o=vec4(clamp(((cos(a*10.)*1.)*vec4(2.*cos(t),1,cos(t),0)+a-10.*abs(a-sin(d+t*.6))/11.).xyz,0.,1.),1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 466]]}
{"id": "mdsyDM", "name": "Random Quadtree Pattern", "author": "oneshade", "description": ".", "tags": ["random", "tiles", "quadtree"], "likes": 19, "viewed": 253, "published": 3, "date": "1686881680", "time_retrieved": "2024-07-30T17:49:23.720298", "image_code": "// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat Hash21(in vec2 p) {\n    vec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash31(in vec3 p3) {\n    p3 = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 quadtree(in vec2 uv, in float seed, in float blockiness, in int maxDepth, out vec2 cellPos, out float cellSize) {\n    cellPos = vec2(0.0);\n    cellSize = 1.0;\n    for (int i = 0; i < maxDepth; i++) {\n        uv *= 2.0;\n        cellSize *= 0.5;\n        vec2 cellId = floor(uv);\n        cellPos += cellId * cellSize;\n        uv -= cellId;\n        if (Hash31(vec3(cellPos * 1000.0, seed)) < blockiness) break;\n    }\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + 0.1 * iTime;\n    float unit = 1.25 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 cellPos;\n    float cellSize;\n    vec2 quv = quadtree(uv, 0.0005 * iTime, 0.5, 10, cellPos, cellSize);\n\n    //color += Hash21((cellPos + 0.5 * cellSize) * 1000.0);\n\n    /**/\n    float rot = Hash21(cellPos + 0.5 * cellSize) + iTime * (2.0 * Hash21(cellPos + cellSize) - 1.0);\n    float co = cos(rot), si = sin(rot);\n    quv = (quv - 0.5) * mat2(co, si, -si, co);\n    color += smoothstep(unit / cellSize, 0.0, abs(max(abs(quv.x), abs(quv.y)) - 0.25) - 0.01);\n    /**/\n\n    /**\n    unit /= cellSize;\n    vec2 center = cellPos + 0.5 * cellSize;\n    quv -= 0.5;\n    color += smoothstep(unit, 0.0, 0.45 - max(abs(quv.x), abs(quv.y)));\n    float rand = Hash21(center * 1000.0);\n    if (rand < 0.5) quv = quv.yx;\n    if (fract(rand * 2.0) < 0.5) quv.y = -quv.y;\n    float time = iTime * 0.25 + Hash31(vec3(center * 1000.0, 10.0));\n    float pos = mix(Hash31(vec3(center, floor(time))), Hash31(vec3(center, ceil(time))), smoothstep(0.0, 1.0, fract(time))) - 0.5;\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(quv.y - pos) - 0.04));\n    /**/\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 67, 67, 153], [155, 155, 180, 180, 294], [296, 296, 322, 322, 428], [430, 430, 548, 548, 865], [867, 867, 922, 922, 2161]]}
{"id": "DslyD7", "name": "Cybernetic Lichen 2", "author": "tomachi", "description": "This has a life algorithm but is tainted by also allowing it to migrate to \"greener\" pixel pastures.", "tags": ["2d", "colors", "automata", "life", "cellular", "screensaver", "colours", "lichen", "amoeba"], "likes": 3, "viewed": 178, "published": 3, "date": "1686871302", "time_retrieved": "2024-07-30T17:49:24.697685", "image_code": "/* IMAGE */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*\nchannels:\nBuffer A - Cells states\nBuffer B - background trails\nBuffer C - density mask ( used to fill blanks mid-game)\n*/\nvec4 sand(in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec4 part = texture(iChannel3,uv);\n\tfloat c = step(0.1,part.x);\n\tvec3 col=vec3(1.,.9,.8)*c*(1.-abs(uv.x-.5));\n    vec4 fragColor = vec4(col,1.);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float rain = therain(uv).x*20.59;\n    float bug =   amoeba(uv).x*5.;\n    float bugpiss = amoeba(uv).y*3.;\n    float herbi = habitat(uv).x*0.8;\n    float red =   rain + bug*15.95 + bugpiss *0.5;\n    float green = rain + herbi*2.5  + bug*0.91 + bugpiss*0.5;\n    float blue =  rain*1.3 + herbi*0.9 + bug*0.13 + bugpiss*0.0625;\n  \n    fragColor = vec4(red, green, blue, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* AMOEBA/LIFE */\n#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n#define R iResolution.xy\n\n#define webcam(pos) texture(iChannel3, pos)\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*float checkPixel(float col, float value) // mapping function\n{\n    if (value >= 0.90001) {\n        return col + value;\n    } else {\n        return 0.;\n    }\n}*/\nbool isHerbivore(vec2 uv) {\n    if (habitat(uv).x > 0.51) { return true; } else { return false; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    float brightest = 0.;\n    float veges = tex1(uv);\n    float col = tex0(uv);\n    float D = tex3(uv);\n    vec4 colour = vec4(webcam(uv).r*1.1, 0.1, webcam(uv).r, 0.);\n\n    if(iFrame < 2 ) // fill blank space with cells\n    {\n        if (rand(uv)  > 0.8 + uv.y*0.5 ) {\n            fragColor = vec4(rand(uv)) * uv.y*0.5;\n            return;\n        }\n    }\n    \n\n\n\n    int n = 0; // game of life logics\n    float amoeba = 0.; // amoeba logic\n    float onepix = p.x;\n    float twopix = onepix * 2.;\n\n    vec2 lup   = vec2(uv.x-p.x, uv.y-p.y);\n    vec2 ldown = vec2(uv.x-p.x, uv.y+p.y);\n    vec2 rup   = vec2(uv.x+p.x, uv.y-p.y);\n    vec2 rdown = vec2(uv.x+p.x, uv.y+p.y);\n\n    vec2 left = vec2(uv.x+p.x, uv.y);\n    vec2 right= vec2(uv.x-p.x, uv.y);\n    vec2 up   = vec2(uv.x, uv.y-p.y);\n    vec2 down = vec2(uv.x, uv.y+p.y);\n\n    // count neighbours\n    n += int(tex(lup));\n    n += int(tex(ldown));\n    n += int(tex(rup));\n    n += int(tex(rdown));\n\n    n += int(tex(left));\n    n += int(tex(right));\n    n += int(tex(up));\n    n += int(tex(down));\n    \n    if (habitat(uv).x > 0.1) colour.y -= 0.0625; // if the forest grows, it consumes the excrement\n\n    //if(col > 0.1 && colour.y == 0.){\n    if(col > 0.1 ){\n       if( n == 3) col += 1.; // rebirth\n    }\n    else if(col > .0991 && !(n == 3 || n == 4)) {\n       col = 0.; // overcrowd death\n       colour.y *= 1.1;// add to the cemetry\n     } \n   //  if (abs(col)>100.65)  { col = 0.; } \n       \n    // if the cell at 180 degrees around from herbi is not better move here\n    // if to the left, theh check 2 pixels to the left\n\n    if (isHerbivore(lup)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y - twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(ldown)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y + twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rup)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rdown)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n\n    if (isHerbivore(left)) { // left\n      if(veges > tex1(vec2(uv.x - twopix, uv.y))) {\n         col += tex1(vec2(uv.x - twopix, uv.y));\n      } else { col = 0.01; }\n    }\n    if (isHerbivore(right)) { // right\n      if(veges > tex1(vec2(uv.x + twopix, uv.y))) {\n          col += tex1(vec2(uv.x + twopix, uv.y));\n      } else { col = 0.01; }\n    }\n    if (isHerbivore(up)) { // up\n      if(veges > tex1(vec2(uv.x, uv.y - twopix))) {\n          col += tex1(vec2(uv.x, uv.y - twopix));\n      } else { col = 0.001; }\n    }\n    if (isHerbivore(down)) { // down\n      if(veges > tex1(vec2(uv.x, uv.y + twopix))) {\n          col += tex1(vec2(uv.x, uv.y + twopix));\n      } else { col = uv.x; }\n    }\n             \n  \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 64.) ) {\n        float r = rand(uv);\n        if (r < 0.1) {\n         \tfragColor = vec4(rand(uv),0.,0,1.);\n        } else {\n          \tfragColor = vec4(1.,1.,0,1.);\n        }\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n        return;\n    }\n\n  \n    fragColor = vec4(vec3(abs(col)), 1.0);\n   // fragColor = vec4(vec3(col), 1.0);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n/* HABITAT */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos)\n#define tex3(pos) texture(iChannel3, pos).z\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float A = tex0(uv);\n    vec4  B = tex1(uv);\n    float D = tex3(uv);\n\n    vec4 veges = vec4(0.);\n    vec4 herbivore = vec4(0.);\n    vec4 colour = habitat(uv);// + vec4(0., amoeba(uv).r*1.1, 0., 0.);\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n\n    B-=A*1.8; // herb gets eaten by herivore\n    \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.)) {\n        if (length(vec2(0.5,0.5) - uv.xy) < 0.1) {    \n           fragColor += vec4(0., 0.05, 0., 0.) ; ///,0.1,uv);\n        } else {\n            fragColor += vec4(0.005,0.,0.,0.) ; \n        }\n       return;\n    }\n    \n    if(iFrame < 5 && length(vec2(0.5,0.5) - uv.xy) < 0.081) // fill blank space with cells\n    {\n        if (rand(uv) > 0.9) {\n            fragColor = vec4(rand(uv)*uv.y);\n            return;\n        }\n        \n       \n    }\n\n   /* veges += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += habitat(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    veges += habitat(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down   */\n\n    \n    // if i recall correct i was trying to make analog / floating point life\n    herbivore +=  amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    herbivore += amoeba(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    herbivore += amoeba(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    herbivore += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y)); // left \n    herbivore += habitat(vec2(uv.x, uv.y-p.y)); // up\n    herbivore += habitat(vec2(uv.x, uv.y+p.y)); // down\n   \n    veges += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += amoeba(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += habitat(vec2(uv.x+p.x, uv.y)); // right\n    veges += amoeba(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down\n   \n    float e = veges.x; // convenience\n    float h = herbivore.x; // convenience\n    \n    colour += abs(veges.x)*0.000951951 * D; // absorb the rain?\n    // growth functino\n    if (e > 0.3521 && e < 1.09) { colour += vec4(0.0051+uv.y*0.065, 0., 0., 0.); }\n    colour = abs(colour);\n  //  B = clamp(B, 0., 10.);\n    \n    if (e > 150. || h > 120.91) colour = vec4(0.);\n    \n\n\n    fragColor = abs(colour);\n   // fragColor = colour;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\nfloat rand(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nuint seed2 = uint(0);\nfloat r(uint s)  // random float\n{\n    return float(Hash(s)) / 4294967295.0;\n}\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r(uint(p.x*100.));\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\nfloat roughNoise1(vec2 uv, int depth, float roughness, uint s)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(s), 5.754*r(s)); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness, uint s)\n{\n    uv += vec2(27.238*r(s), 16.162*r(s+uint(1)));\n\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(s+uint(2)), 5.754*r(s+uint(3))); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}", "buffer_c_code": "#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <3 ) {\n        fragColor = vec4(0.75) -  vec4(fragCoord,fragCoord.x,fragCoord.y);\n        return;\n     }\n\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/* THE RAIN */\n#define A 4\n\n#define rainSpeed 4. // float of A\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nfloat hash(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check if there is an arriving particle at this pixel in next frame\nfloat arrivingParticle(vec2 coord, out vec4 partData) {\n\t// scan area from -D to D\n\tvec2 uv = coord / iResolution.xy;\n    float veges = habitat(uv).x;\n    float returnval = 0.;\n    partData = therain(uv);\n\t// scan area from -D to D\n    for (int i=-A; i<A; i++) {\n        for (int j=-A; j<A; j++) {\n            // position to check\n            vec2 arrCoord = coord + vec2(i,j);\n            vec4 data = texture(iChannel3, arrCoord/iResolution.xy);\n            vec4 amoeba = texture(iChannel1, arrCoord/iResolution.xy);\n            \n            // no particles here\n            if (dot(data,data)<1.9991) continue;\n            if (amoeba(uv).x > 0.) {\n                return 0.;\n            }\n            // get next position of particle\n            vec2 nextCoord = data.xy + data.zw;\n\n            // distance between next position and current pixel\n            vec2 offset = abs(coord - nextCoord);\n            // if the distance is within half a pixel pick this particle\n            // (other arriving particles are dismissed)\n            if (offset.x<.5 && offset.y<.5) {\n                partData += data;\n                returnval++;\n//                return 1.;\n            }\n        }\n    }\n    // no particles arriving here\n\treturn returnval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n \t// random particles at the top, xy is position, zw velocity\n    if (fragCoord.y > iResolution.y - float(A) || fragCoord.x > iResolution.x - float(A)) {\n        fragColor = vec4(fragCoord.xy, hash(vec2(uv.x , iTime)) * rainSpeed, hash(vec2(uv.y , iTime)) * -rainSpeed); \n        return;\n    }\n   \n    // get the data of a particle arriving at this pixel \n    vec4 partData;\n    float p = arrivingParticle(fragCoord, partData);\n\n    // no particles, empty pixel\n    if (p < 1.) {\n    \tfragColor = vec4(p);\n        return;\n    }\n    \n    // update position with current velocity altered by channels r & b in the video\n    float vel = max(0.,1.-length(texture(iChannel1,fragCoord/iResolution.xy).rb));\n    partData.xy += partData.zw*vel;\n\n    //set particle data\n    fragColor = partData;\n}", "buffer_d_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 494, 525, 525, 736], [737, 737, 794, 794, 1214]]}
{"id": "cdlcWM", "name": "Playing #4", "author": "matheusgirola", "description": "Playing now with triangles, translation and rotation", "tags": ["shader"], "likes": 1, "viewed": 139, "published": 3, "date": "1686871296", "time_retrieved": "2024-07-30T17:49:25.564368", "image_code": "// signed distance to an equilateral triangle\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n#define PI 3.14159265359\n\n// cosine based palette, 4 vec3 params\nvec3 palette( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(0.50, 0.20, 0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 p0 = p;\n    p *= 2.0;\n    vec3 finalColor = vec3(0.0);\n    \n    vec2 translate = vec2(cos(iTime),sin(iTime));\n    p += translate*0.45;\n    \n    \n    for(float i =0.0; i < 9.0; i++){\n        p = rotate2d(iTime*0.01)*p;\n        \n        float d = sdEquilateralTriangle(p*i, 3.*PI*sin(iTime))*exp(-1.5*length(p));\n        d = sin(d*8. + 2.*iTime)/8.;\n\n        vec3 col = (d>0.0) ? palette( 10.*i) : palette( 10.) ;\n        col *= 1.0 - exp(abs(d)*PI);\n        col *= 0.6+ 1.*cos(80.0*d);\n        col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n        finalColor += col;\n        }\n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 101, 101, 308], [310, 310, 338, 338, 424], [452, 491, 516, 516, 699], [702, 702, 759, 759, 1456]]}
{"id": "DslyW7", "name": "Cybernetic Lichen Roots", "author": "tomachi", "description": "This has a life algorithm but is tainted by also allowing it to migrate to \"greener\" pixel pastures.", "tags": ["2d", "colors", "automata", "life", "cellular", "screensaver", "colours", "lichen", "amoeba"], "likes": 1, "viewed": 160, "published": 3, "date": "1686868269", "time_retrieved": "2024-07-30T17:49:26.508843", "image_code": "/* IMAGE */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*\nchannels:\nBuffer A - Cells states\nBuffer B - background trails\nBuffer C - density mask ( used to fill blanks mid-game)\n*/\nvec4 sand(in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec4 part = texture(iChannel3,uv);\n\tfloat c = step(0.1,part.x);\n\tvec3 col=vec3(1.,.9,.8)*c*(1.-abs(uv.x-.5));\n    vec4 fragColor = vec4(col,1.);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float rain = therain(uv).x*0.575;\n    float red =   rain + amoeba(uv).x*0.95  + (habitat(uv).x * 0.002)      + amoeba(uv).y *0.125;\n    float green = rain + habitat(uv).x * 1.91 + amoeba(uv).x*0.1  + amoeba(uv).y*0.0625;\n    float blue = rain*1.3 + (habitat(uv).x * 0.13) + rain  - amoeba(uv).y  *0.0625 + amoeba(uv).x*0.02;\n\n  \n    fragColor = vec4(red,green,blue,1.);// + therain(uv)*0.75;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* AMOEBA/LIFE */\n#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n#define R iResolution.xy\n\n#define webcam(pos) texture(iChannel3, pos)\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*float checkPixel(float col, float value) // mapping function\n{\n    if (value >= 0.90001) {\n        return col + value;\n    } else {\n        return 0.;\n    }\n}*/\nbool isHerbivore(vec2 uv) {\n    if (habitat(uv).x > 0.51) { return true; } else { return false; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    float brightest = 0.;\n    float veges = tex1(uv);\n    float col = tex0(uv);\n    float D = tex3(uv);\n    vec4 colour = vec4(webcam(uv).r*1.1, 0.1, webcam(uv).r, 0.);\n\n    if(iFrame < 2 ) // fill blank space with cells\n    {\n        if (rand(uv)  > 0.8 + uv.y*0.5 ) {\n            fragColor = vec4(rand(uv)) * uv.y*0.5;\n            return;\n        }\n    }\n    \n\n\n\n    int n = 0; // game of life logics\n    float amoeba = 0.; // amoeba logic\n    float onepix = p.x;\n    float twopix = onepix * 2.;\n\n    vec2 lup   = vec2(uv.x-p.x, uv.y-p.y);\n    vec2 ldown = vec2(uv.x-p.x, uv.y+p.y);\n    vec2 rup   = vec2(uv.x+p.x, uv.y-p.y);\n    vec2 rdown = vec2(uv.x+p.x, uv.y+p.y);\n\n    vec2 left = vec2(uv.x+p.x, uv.y);\n    vec2 right= vec2(uv.x-p.x, uv.y);\n    vec2 up   = vec2(uv.x, uv.y-p.y);\n    vec2 down = vec2(uv.x, uv.y+p.y);\n\n    // count neighbours\n    n += int(tex(lup));\n    n += int(tex(ldown));\n    n += int(tex(rup));\n    n += int(tex(rdown));\n\n    n += int(tex(left));\n    n += int(tex(right));\n    n += int(tex(up));\n    n += int(tex(down));\n    \n    if (habitat(uv).x > 0.1) colour.y -= 0.0625; // if the forest grows, it consumes the excrement\n\n    //if(col > 0.1 && colour.y == 0.){\n    if(col > 0.1 ){\n       if( n == 3) col += 1.; // rebirth\n    }\n    else if(col > .0991 && !(n == 3 || n == 4)) {\n       col = 0.; // overcrowd death\n       colour.y *= 1.1;// add to the cemetry\n     } \n   //  if (abs(col)>100.65)  { col = 0.; } \n       \n    // if the cell at 180 degrees around from herbi is not better move here\n    // if to the left, theh check 2 pixels to the left\n\n    if (isHerbivore(lup)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y - twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(ldown)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y + twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rup)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rdown)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n\n    if (isHerbivore(left)) { // left\n      if(veges > tex1(vec2(uv.x - twopix, uv.y))) {\n         col += tex1(vec2(uv.x - twopix, uv.y));\n      } else { col = 0.01; }\n    }\n    if (isHerbivore(right)) { // right\n      if(veges > tex1(vec2(uv.x + twopix, uv.y))) {\n          col += tex1(vec2(uv.x + twopix, uv.y));\n      } else { col = 0.01; }\n    }\n    if (isHerbivore(up)) { // up\n      if(veges > tex1(vec2(uv.x, uv.y - twopix))) {\n          col += tex1(vec2(uv.x, uv.y - twopix));\n      } else { col = 0.001; }\n    }\n    if (isHerbivore(down)) { // down\n      if(veges > tex1(vec2(uv.x, uv.y + twopix))) {\n          col += tex1(vec2(uv.x, uv.y + twopix));\n      } else { col = uv.x; }\n    }\n             \n  \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 64.) ) {\n        float r = rand(uv);\n        if (r < 0.1) {\n         \tfragColor = vec4(rand(uv),0.,0,1.);\n        } else {\n          \tfragColor = vec4(1.,1.,0,1.);\n        }\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n        return;\n    }\n\n  \n    fragColor = vec4(vec3(abs(col)), 1.0);\n   // fragColor = vec4(vec3(col), 1.0);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n/* HABITAT */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos)\n#define tex3(pos) texture(iChannel3, pos).z\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float A = tex0(uv);\n    vec4  B = tex1(uv);\n    float D = tex3(uv);\n\n    vec4 veges = vec4(0.);\n    vec4 colour = habitat(uv);// + vec4(0., amoeba(uv).r*1.1, 0., 0.);\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n\n    B-=A*1.8; // herb gets eaten by herivore\n    \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.)) {\n        if (length(vec2(0.5,0.5) - uv.xy) < 0.45) {    \n            fragColor += 1.95+ dot(iDate,vec4(A)) ; ///,0.1,uv);\n       } \n       return;\n    }\n    \n    if(iFrame < 5 && length(vec2(0.5,0.5) - uv.xy) < 0.081) // fill blank space with cells\n    {\n        if (rand(uv) > 0.9) {\n            fragColor = vec4(rand(uv)*uv.y);\n            return;\n        }\n        \n       \n    }\n\n    veges += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += habitat(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    veges += habitat(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down   \n\n    \n    // if i recall correct i was trying to make analog / floating point life\n  /*  veges +=  amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += amoeba(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += amoeba(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += amoeba(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    veges += amoeba(vec2(uv.x-p.x, uv.y)); // left \n    veges += amoeba(vec2(uv.x, uv.y-p.y)); // up\n    veges += amoeba(vec2(uv.x, uv.y+p.y)); // down*/\n   \n  /*  veges += habitat(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += habitat(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += habitat(vec2(uv.x+p.x, uv.y)); // right\n    veges += habitat(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down*/\n   \n    float e = veges.x; // convenience\n    \n    colour += abs(veges)*0.000951951 * D; // absorb the rain?\n    if (e > 0.3521 && e < 0.9) { colour += vec4(0.0051+uv.y*0.65, 0., 0., 0.); }\n    B = abs(B);\n    B = clamp(B, 0., 10.);\n    \n    if (veges.x > 100. || amoeba(uv).x > 0.5) colour = vec4(0.);\n    \n\n\n  //  fragColor = abs(colour);\n    fragColor = colour;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\nfloat rand(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nuint seed2 = uint(0);\nfloat r(uint s)  // random float\n{\n    return float(Hash(s)) / 4294967295.0;\n}\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r(uint(p.x*100.));\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\nfloat roughNoise1(vec2 uv, int depth, float roughness, uint s)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(s), 5.754*r(s)); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness, uint s)\n{\n    uv += vec2(27.238*r(s), 16.162*r(s+uint(1)));\n\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(s+uint(2)), 5.754*r(s+uint(3))); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}", "buffer_c_code": "#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <3 ) {\n        fragColor = vec4(0.75) -  vec4(fragCoord,fragCoord.x,fragCoord.y);\n        return;\n     }\n\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/* THE RAIN */\n#define A 4\n\n#define rainSpeed 8. // float of A\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nfloat hash(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check if there is an arriving particle at this pixel in next frame\nfloat arrivingParticle(vec2 coord, out vec4 partData) {\n\t// scan area from -D to D\n\tvec2 uv = coord / iResolution.xy;\n    float veges = habitat(uv).x;\n    float returnval = 0.;\n\t// scan area from -D to D\n    for (int i=-A; i<A; i++) {\n        for (int j=-A; j<A; j++) {\n            // position to check\n            vec2 arrCoord = coord + vec2(i,j);\n            vec4 data = texture(iChannel3, arrCoord/iResolution.xy);\n            vec4 amoeba = texture(iChannel1, arrCoord/iResolution.xy);\n            \n            // no particles here\n            if (dot(data,data)<1.9991) continue;\n            if (amoeba.x > 0.) continue;\n            // get next position of particle\n            vec2 nextCoord = data.xy + data.zw;\n\n            // distance between next position and current pixel\n            vec2 offset = abs(coord - nextCoord);\n            // if the distance is within half a pixel pick this particle\n            // (other arriving particles are dismissed)\n            if (offset.x<.5 && offset.y<.5) {\n                partData = data;\n                return 1.;\n            }\n        }\n    }\n    // no particles arriving here\n\treturn 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n \t// random particles at the top, xy is position, zw velocity\n    if (fragCoord.y > iResolution.y - float(A) || fragCoord.x > iResolution.x - float(A)) {\n        fragColor = vec4(fragCoord.xy, hash(vec2(uv.x , iTime)) * rainSpeed, hash(vec2(uv.y , iTime)) * -rainSpeed); \n        return;\n    }\n   \n    // get the data of a particle arriving at this pixel \n    vec4 partData;\n    float p = arrivingParticle(fragCoord, partData);\n\n    // no particles, empty pixel\n    if (p < 1.) {\n    \tfragColor = vec4(p);\n        return;\n    }\n    \n    // update position with current velocity altered by channels r & b in the video\n    float vel = max(0.,1.-length(texture(iChannel1,fragCoord/iResolution.xy).rb));\n    partData.xy += partData.zw*vel;\n\n    //set particle data\n    fragColor = partData;\n}", "buffer_d_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 494, 525, 525, 736], [737, 737, 794, 794, 1235]]}
{"id": "DdlcWH", "name": "Year of Truchets #038", "author": "byt3_m3chanic", "description": "shut up - its got truchets!\n\nOk so the pistons have truchets on them - otherwise remixing some parts of my last shader to make a fun audio reactive thing.", "tags": ["raymarching", "reflection", "audio", "truchet", "piston"], "likes": 16, "viewed": 447, "published": 3, "date": "1686863175", "time_retrieved": "2024-07-30T17:49:27.366549", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #038\n    06/15/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Ok so the pistons have truchets on them - otherwise remixing\n    some parts of my last shader to make a fun audio reactive \n    thing.\n    \n    Noise/FBM Based on Morgan McGuire @morgan3d\n    https://www.shadertoy.com/view/4dS3Wd (in common tab)\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-5\n\n// globals\nvec3 hit,hitPoint;\nvec2 sid,gid;\nmat2 r90,r45;\nfloat ghs,shs,sd,gd,gtk,stk,speed,flow,sfr,gfr;\n\n// constants\nconst float size = 1.1;\nconst float hlf = size/2.;\n\n\nfloat sampleFreq(float freq) { return texture(iChannel0, vec2(freq, .25)).x;}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)+iDate.z))*478.53);}\n\n//@iq extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n    pos.xz += vec2(speed,0);\n    \n    vec2 uv = pos.xz;\n\n\n    float idx = floor((uv.x+hlf)/size);\n    float rx = mod(uv.x+hlf,size)-hlf;\n    \n    float idz = floor((uv.y+hlf)/size)-2.;\n    float rz = uv.y-size*clamp(round(uv.y/size),-2.,2.);\n    \n    vec2 id = vec2(idx,idz);\n    vec2 r = vec2(rx,rz);\n    \n    float fr = sampleFreq(mod((idz*.2)+(idx*.1),1.))*1.85;\n\n    gfr=fr;\n\n    float b = length(r)-.2;\n    float b1= opx(abs(b)-.01,pos.y,fr)-.0025;\n    if(b1<res.x) {\n        gd = b;\n        res = vec2(b1,4.);\n        hit=vec3(r.x,pos.y-fr,r.y);\n        gid = id;\n    }\n\n    float gnd = pos.y+.01;\n    if(gnd<res.x) {\n        res = vec2(gnd,1.);\n        hit=pos;\n        gid = id;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.9;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(in vec3 t) { \n    t.x+=10.;\n    return .45 + .375*cos(PI2*t.x*(vec3(.985,.98,.95)*vec3(0.941,0.835,0.157))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n    hitPoint = hit;  \n    shs = ghs;sd = gd;\n    sid = gid;sfr=gfr;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(2.,12.,5.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.25);\n        \n        if(m==1.) {\n            float px = 4./R.x;\n            \n            vec3 clr = hue(vec3(hitPoint.x*.08,1.,.5));\n            vec3 cld = clr*.5;\n            float ff = fbm(hitPoint.xz);\n            \n            ff=smoothstep(.15,.16,.5+.5*sin(ff*22.));\n            h = mix(clr*.1,vec3(.01),ff);  \n            vec2 f = mod(hitPoint.xz+hlf,size)-hlf;\n\n            vec2 d = abs(vec2(f.x,hitPoint.z))-vec2(hlf*5.);\n            float d1 = length(max(d,0.)) + min(max(d.x,d.y),0.);\n            float d2 = abs(max(abs(f.x),abs(f.y))-hlf)-.0125;\n            float fr = sfr*.5;\n            vec3 lfr = (fr<.5) ? vec3(0.) : cld;\n            h = mix(h,lfr,smoothstep(px,-px,d1));\n            h = mix(h,cld*.5,smoothstep(px,-px,max(d2,d1)));    \n            h = mix(h,cld*.5,smoothstep(px,-px,abs(d1)-.0125));  \n        \n            float d4 = smoothstep(px,-px,abs(sd-.045)-.05);\n            float d5 = smoothstep(px,-px,abs(sd)-.05);\n            h = mix(h, vec3(.03), d4);\n            h = mix(h, cld, d5);\n            \n            ref = vec3(clamp(.55-d4,0.,1.) );\n        }\n        \n  \n        if(m==4.) { \n     \n            vec2 uv = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n            vec2 id = floor(uv*10.)+sid;\n            vec2 q = fract(uv*10.)-.5;\n            vec3 clr = hue(vec3((p.x+T*.4)*.08,1.,.5));\n            float ck =mod(id.x+id.y,2.)*2.-1.;\n            float rnd = hash21(id);\n            float rhs = hash21(sid);\n            float fr = sfr*.5;\n            float px = d*.01;\n            \n            if (rnd>.5) q.x=-q.x; \n            \n            vec2 cv = vec2(length(q-.5),length(q+.5));\n            vec2 p2 = cv.x<cv.y ? q-.5:q+.5;\n    \n            float d = abs(length(p2)-.5)-.2;\n            if(fract(rnd*32.381)>.75) d = min(length(q.x),length(q.y))-.2;\n            if(rhs>.5) {\n              d=smoothstep(px,-px,d);\n            } else if(rhs>.3){\n              d = length(p2)-.5;\n              d = (ck>.5^^rnd<.5) ? smoothstep(-px,px,d): smoothstep(px,-px,d);\n            } else {\n              d = smoothstep(-px,px,abs(abs(d)-.15)-.05);\n            }\n            \n            vec3 ph = mix(clr,vec3(.001),d); \n            h = mix(vec3(.05),ph,fr<.5 ? .1:fr);\n            ref = vec3(1.-d)*.25; \n        }\n \n        C = (diff*h);\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,d);\n}\n\nvec3 FC = vec3(.075);\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    speed = T*.4;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,-.25,5.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.1-.05)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*.4-.2)*PI;\n\n    float ff = .3*sin(T*.08);\n    mat2 rx = rot(-(.56+ff-x)), ry = rot(-ff-.1-y);//-.38\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref = vec3(0), fil = vec3(.95);\n    float d = 0., a = 0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC,C,exp(-.00025*a*a*a));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n\n", "image_inputs": [{"id": 33674, "src": "https://soundcloud.com/alldayidream/tim-green-lune", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float rnd (in vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// this works on OSX/PC without fracture lines.\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv), f = fract(uv);\n    float a = rnd(i);\n    float b = rnd(i + vec2(1, 0));\n    float c = rnd(i + vec2(0, 1));\n    float d = rnd(i + vec2(1, 1));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nconst vec2 shift = vec2(100.);\nconst mat2 r3 = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\nfloat fbm ( in vec2 uv) {\n    float v = .0, a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        v += a * noise(uv);\n        uv = r3 * uv * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlcWH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[823, 823, 853, 853, 900], [901, 901, 919, 919, 962], [963, 963, 984, 984, 1047], [1049, 1063, 1112, 1112, 1208], [1210, 1210, 1229, 1229, 1969], [1971, 1971, 2001, 2001, 2240], [2242, 2242, 2274, 2274, 2501], [2503, 2503, 2524, 2524, 2623], [5846, 5846, 5887, 5887, 6738]]}
{"id": "ddfyD7", "name": "Complicating things even further", "author": "mrange", "description": "CC0: Complicating things even further\nThat is what I do.\n\n", "tags": ["3d"], "likes": 71, "viewed": 1166, "published": 3, "date": "1686858466", "time_retrieved": "2024-07-30T17:49:28.628177", "image_code": "// CC0: Complicating things even further\n//  That is what I do.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define BPM         (143.0*0.5)\n#define PCOS(a)     0.5*(cos(a)+1.0)\n\nconst float planeDist = 1.0-0.75;\nconst int   furthest  = 12;\nconst int   fadeFrom  = max(furthest-4, 0);\nconst float fadeDist  = planeDist*float(furthest - fadeFrom);\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 offset(float z) {\n  float a = z*0.5;\n  vec2 p = -0.25*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.6))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  const float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  const float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return vec3(0.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan_approx(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec3 palette( float t ) {\n  return (1.0+cos(1.0*vec3(0.0, 1.0, 2.0)+TAU*t))*0.5;\n}\n\n// License: Unknown, author: kishimisu, found: https://www.shadertoy.com/view/mtyGWy\nvec3 kishimisu(vec3 col, vec2 p, float tm, float n) {\n  vec2 p0 = p;\n  vec3 finalColor = vec3(0.0);\n    \n  vec2 p1 = p;\n  for (float i = 0.0; i < 4.0; i++) {\n    p1 = fract(p1 * 2.0+0.0125*tm) - 0.5;\n\n    float d = length(p1) * exp(-length(p0));\n\n    vec3 cc = palette(length(p0) + i*.4 + tm*.2);\n\n    d = sin(d*8. + tm)/8.;\n    d = abs(d);\n\n    d -= 0.0025;\n    d = max(d, 0.005);\n    d = (0.0125 / d);\n    d *= d;\n\n    col += cc * d;\n  }\n\n  return 0.5*(col);  \n}\n\nvec3 effect(vec2 p, float tm, float n) {\n  vec3 col = vec3(0.0);\n  vec2 kp = p;\n  float kl = dot(kp, kp);\n  float nn = 2.0*floor(mix(3.0, 16.0, 0.5+0.5*sin(0.1*n)));\n  float kn = smoothKaleidoscope(kp, 0.1, nn);\n  kp += 0.5*sin(vec2(1.0, sqrt(0.5))*tm*0.21);\n  col = kishimisu(col, kp, tm, n);\n  col -= 0.75*vec3(0.0, 1.0, 2.0).zyx*dot(p, p);\n  col = clamp(col, 0.0, 4.0);\n  return col;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  float l = length(p);\n  p *= mix(0.5, 0.75, 0.5+0.5*sin(n*0.071));\n  float tm = 0.5*0.125*TIME+0.125*n;\n  p *= ROT(-tm);  \n  float fade = smoothstep(0.1, 0.15, l);\n  if (fade < 0.05) return vec4(0.0);\n  vec4 col = vec4(0.0);\n  \n  col.xyz = effect(p, tm, n);\n  float i = max(max(col.x, col.y), col.z)*0.75;\n  col.w = (tanh_approx(0.5+l+max((i), 0.0))*fade);\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float rdd_per   = 10.0;\n  float rdd =  (1.75+0.75*pow(lp,1.5)*tanh_approx(lp+0.9*PCOS(rdd_per*p.x)*PCOS(rdd_per*p.y)));\n//  float rdd = 2.0;\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.975;\n  bool cutOut = false;\n\n  float maxpd = 0.0;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.w *= fadeOut*fadeIn;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = planeDist*TIME*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col *= smoothstep(1.0, 10.0, TIME);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 33681, "src": "https://soundcloud.com/astrix-official/astrix-rising-dust-universo-coming-soon", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 570, 610, 610, 769], [771, 831, 871, 871, 913], [915, 975, 1003, 1069, 1145], [1147, 1147, 1169, 1169, 1306], [1308, 1308, 1331, 1331, 1415], [1417, 1417, 1441, 1441, 1527], [1529, 1529, 1562, 1562, 1584], [1586, 1672, 1709, 1709, 1816], [1818, 1818, 1840, 1840, 1891], [1893, 1893, 1914, 1914, 1959], [1961, 2047, 2092, 2092, 2246], [2248, 2348, 2387, 2387, 2472], [2474, 2474, 2504, 2504, 2532], [2534, 2534, 2595, 2595, 2808], [2810, 2810, 2835, 2835, 2892], [2894, 2979, 3032, 3032, 3443], [3445, 3445, 3485, 3485, 3833], [3835, 3835, 3903, 3903, 4321], [4323, 4323, 4379, 4379, 5850], [5852, 5852, 5882, 5882, 6270], [6272, 6272, 6327, 6327, 6503]]}
{"id": "cdfcD7", "name": "Dot Product Visualization", "author": "ferrazrx", "description": "# COPY FROM https://www.shadertoy.com/view/fdtyDH\n\nA simple showcase how the dot product works. Grey/White line color and leght show the dot product result from the red and blue vector. If the white line becomes green the value is negative", "tags": ["dot"], "likes": 2, "viewed": 203, "published": 3, "date": "1686848231", "time_retrieved": "2024-07-30T17:49:29.496854", "image_code": "// COPY FROM https://www.shadertoy.com/view/fdtyDH\n\n// https://www.shadertoy.com/view/tsj3Rd\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b)\n{\n    // Find vectors pa and ba:\n    vec2 pa = p-a, ba = b-a;\n    // Compute the dot product of vectors and divide to get the ratio\n    // Clamp the ratio between 0.0 and 1.0\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    // Return the distance from the given point to the nearest point on line ab\n    return length(pa - ba*h);\n}\n#define UNIT                      (  4.0 / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y * 2.0;\n    vec2 mousePosOld = abs(iMouse.zw) / iResolution.y * 2.0;\n    vec2 mousePosCur = iMouse.xy / iResolution.y * 2.0;\n\n    float gradient = sin(uv.x * 0.8) * sin(uv.y * 1.57);\n    gradient = pow(gradient, 0.1);\n    vec3 outputCol = vec3(0.2, 0.2, 0.2) * gradient;\n\n\n    vec2 ro1 = vec2(1.6, 1.0);\n    vec2 rd1 = vec2(1.0, 0.0);\n    \n    vec2 ro2 = ro1;\n    vec2 rd2 = normalize(mousePosCur - ro2);\n    \n    float Drd1rd2 = dot(rd1, rd2);\n    \n    vec2 ro3 = ro1 + rd1 * Drd1rd2;\n    vec2 rd3 = normalize((ro2 + rd2) - ro3);\n    float rd3l = length((ro2 + rd2) - ro3);\n    \n    float lineSide = -sign(dot(vec2(0.0, 1.0), rd2));   \n    \n    vec2 ro4 = ro1 + vec2(0.0, 0.1) * lineSide;\n    vec2 rd4 = rd1 * Drd1rd2;\n    vec3 r4c = abs(Drd1rd2) * vec3(sign(Drd1rd2), 1.0, sign(Drd1rd2));\n\n    \n    float line1 = sdLine(uv, ro1, ro1 + rd1);\n    outputCol = mix(outputCol, vec3(0.1, 0.1, 0.9), SMAA(line1));\n    \n    float line2 = sdLine(uv, ro2, ro2 + rd2);\n    outputCol = mix(outputCol, vec3(1.0, 0.1, 0.1), SMAA(line2));\n    \n    float line3 = sdLine(uv, ro3, ro3 + rd3 * rd3l);\n    outputCol = mix(outputCol, vec3(0.1, 0.9, 0.1), SMAA(line3));\n\n    float line4 = sdLine(uv, ro4, ro4 + rd4);\n    outputCol = mix(outputCol, r4c, SMAA(line4));\n\n    // Output to screen\n    fragColor = vec4(outputCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 93, 138, 169, 476], [600, 600, 657, 707, 2055]]}
{"id": "dlyXRK", "name": "Fork Shock Wave MartinRGB 199", "author": "MartinRGB", "description": "I need public api for my blog.my article about this effect:https://martinrgb.github.io/blog/#/Namedrop_Animation", "tags": ["wave", "water", "saturation", "shockwave", "ripple", "shock"], "likes": 4, "viewed": 982, "published": 3, "date": "1686842613", "time_retrieved": "2024-07-30T17:49:30.340598", "image_code": "//Use as you will.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Sawtooth function to pulse from centre.\n    float offset = (iTime- floor(iTime))/iTime;\n\tfloat CurrentTime = (iTime)*(offset);    \n    \n\tvec3 WaveParams = vec3(10.0, 0.8, 0.1 ); \n    \n    float ratio = iResolution.y/iResolution.x;\n    \n    //Use this if you want to place the centre with the mouse instead\n\t//vec2 WaveCentre = vec2( iMouse.xy / iResolution.xy );\n       \n    vec2 WaveCentre = vec2(0.5, 0.5);\n    WaveCentre.y *= ratio; \n   \n\tvec2 texCoord = fragCoord.xy / iResolution.xy;      \n    texCoord.y *= ratio;    \n\tfloat Dist = distance(texCoord, WaveCentre);\n    \n\t\n\tvec4 Color = texture(iChannel0, texCoord);\n    \n//Only distort the pixels within the parameter distance from the centre\nif ((Dist <= ((CurrentTime) + (WaveParams.z))) && \n\t(Dist >= ((CurrentTime) - (WaveParams.z)))) \n\t{\n        //The pixel offset distance based on the input parameters\n\t\tfloat Diff = (Dist - CurrentTime); \n\t\tfloat ScaleDiff = (1.0 - pow(abs(Diff * WaveParams.x), WaveParams.y)); \n\t\tfloat DiffTime = (Diff  * ScaleDiff);\n        \n        //The direction of the distortion\n\t\tvec2 DiffTexCoord = normalize(texCoord - WaveCentre);         \n        \n        //Perform the distortion and reduce the effect over time\n\t\ttexCoord += ((DiffTexCoord * DiffTime) / (CurrentTime * Dist * 40.0));\n\t\tColor = texture(iChannel0, texCoord);\n        \n        //Blow out the color and reduce the effect over time\n\t\tColor += (Color * ScaleDiff) / (CurrentTime * Dist * 40.0);\n\t} \n    \n\tfragColor = Color; \n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 123, 1566]]}
{"id": "ddsyDN", "name": "Kaleidoscope by Kanduvisla", "author": "kanduvisla", "description": "This is the first shader I made, a kaleidoscope. Thanks to kishimisu for his excelent tutorial!", "tags": ["kaleidoscope"], "likes": 12, "viewed": 329, "published": 3, "date": "1686840977", "time_retrieved": "2024-07-30T17:49:31.177361", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.388, 0.508, 0.500);\n    vec3 b = vec3(-0.392, 0.488, 0.428);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(1.000, 1.328, 1.268);\n    \n    return a + b * cos( 6.28318 * (c * t * d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for ( float i = 0.0; i < 7.0; i += 1.0 ) {\n        uv = fract(uv * (0.5 + i / 3.0)) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + (iTime / 15.0 * i));\n\n        d = sin(d * 8. + sin(iTime / (1.0 + i)) + iTime)/8.;\n        d = abs(d);\n        d = pow(0.01 / d, 1.5);\n\n        col *= d;\n    \n        finalColor += col;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 241], [243, 243, 300, 300, 845]]}
{"id": "DtdSzM", "name": "Year of Truchets #037", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n2d pattern here -> https://www.shadertoy.com/view/ctKSWh", "tags": ["3d", "raymarching", "reflection", "truchet"], "likes": 18, "viewed": 279, "published": 3, "date": "1686827785", "time_retrieved": "2024-07-30T17:49:32.035067", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #037\n    06/15/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Noise/FBM Based on Morgan McGuire @morgan3d\n    https://www.shadertoy.com/view/4dS3Wd (in common tab)\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-5\n\n// globals\nvec3 hit,hitPoint;\nvec2 sid,gid;\nmat2 r90,r45;\nfloat ghs,shs,sd,gd,gtk,stk,speed,flow;\n\n// constants\nconst float size = .85;\nconst float hlf = size/2.;\nconst float db = size*5.;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)+iDate.z))*43758.5453);}\n\n//@iq extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n    vec2 uv = pos.xz;\n  \n    vec2 r = (uv*size)-.5;\n    vec2 ir = floor(r);\n         r = fract(r)-.5;\n    float ck = mod(ir.x+ir.y,2.)*2.-1.;\n    gid = ir;\n    \n    vec2 id = floor(uv*size); \n    vec2 q = fract(uv*size)-.5;\n    \n    float rnd = hash21(id);\n\n    if (rnd>.5) q.x=-q.x; \n    rnd = fract(rnd*32.381);\n    \n    vec2 cv = vec2(length(q-.5),length(q+.5));\n    vec2 p = cv.x<cv.y ? q-.5:q+.5;\n    \n    float thc = .085+.035*sin(pos.x*1.135);\n    float k = length(p)-.5;k = abs(k)-thc;\n    \n    float sw = .3+.29*sin(pos.x*1.135);\n          sw+= .3+.29*cos(pos.z*.75);\n    ghs = sw;\n\n    if(rnd>.75) k = min(length(q.x)-thc,length(q.y)-thc);\n    gd = k;\n\n    float d3= opx(k+.1,pos.y,.01+sw)-.1;\n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit=pos-vec3(0,sw,0);\n    }\n\n    float b = length(r)-.15;\n    float b1= opx(abs(b)-.01,pos.y,ck>.5?1.:.2)-.0025;\n    if(b1<res.x) {\n        gd = b;\n        res = vec2(b1,4.);\n        hit=vec3(r.x,pos.y,r.y);\n    }\n\n    float gnd = pos.y+.01;\n    if(gnd<res.x) {\n        res = vec2(gnd,1.);\n        hit=pos;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(in vec3 t) { \n    t.x+=10.;\n    return .45 + .375*cos(PI2*t.x*(vec3(.985,.98,.95)*vec3(0.941,0.690,0.337))); \n}\n\nvec3 FC = vec3(.3);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n    hitPoint = hit;  \n    shs = ghs;\n    sd = gd;\n    sid = gid;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(2.,12.,5.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.25);\n        \n        if(m==1.) {\n            float px = 4./R.x;\n            \n            vec3 clr = hue(vec3(hitPoint.z*.08,1.,.5));\n            float ff = fbm(hitPoint.xz*3.);\n            \n            ff=smoothstep(.15,.16,.5+.5*sin(ff*22.));\n            h = mix(vec3(.029),vec3(.1),ff);  \n   \n            float d = smoothstep(px,-px,abs(sd-.045)-.05);\n            float d2 = smoothstep(px,-px,sd-.045);\n            h = mix(h, vec3(.03), d);\n            h = mix(h, clr*.5, d2);\n            \n            ref = vec3(clamp(.55-d,0.,1.));\n        }\n        \n        if(m==2.) { \n            h = hue(vec3(hitPoint.z*.08,1.,.5));\n            ref = h; \n        }\n\n        if(m==4.) { \n            hitPoint.xz*=rot(speed);\n            vec2 uv = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n            vec2 id = floor(uv*10.)+sid;\n            vec2 q = fract(uv*10.)-.5;\n            vec3 clr = hue(vec3(p.z*.08,1.,.5));\n            float ck =mod(id.x+id.y,2.)*2.-1.;\n            float rnd = hash21(id);\n            float rhs = hash21(sid);\n\n            float px = d*.01;\n\n            if (rnd>.5) q.x=-q.x; \n\n            vec2 cv = vec2(length(q-.5),length(q+.5));\n            vec2 p2 = cv.x<cv.y ? q-.5:q+.5;\n\n            float d = abs(length(p2)-.5)-.15;\n            if(fract(rnd*32.381)>.75) d = min(length(q.x),length(q.y))-.15;\n            if(rhs>.5) {\n              d=smoothstep(px,-px,d);\n            } else if(rhs>.3){\n              d = length(p2)-.5;\n              d = (ck>.5^^rnd<.5) ? smoothstep(-px,px,d): smoothstep(px,-px,d);\n            } else {\n              d = smoothstep(-px,px,abs(abs(d)-.15)-.025);\n            }\n\n            h = mix(clr*.5,vec3(.08),d); \n            ref = vec3(d)*.25; \n        }\n \n        C = (diff*h);\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    speed = T*.23;\n    flow = T*.133;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(12,0,5.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*.5-.25)*PI;\n\n    float ff = -T*.03;\n    mat2 rx = rot(-.86-x), ry = rot(-.78-ff-y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC,C,exp(-.00008*a*a*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n\n", "image_inputs": [], "common_code": "float rnd (in vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// this works on OSX/PC without fracture lines.\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv), f = fract(uv);\n    float a = rnd(i);\n    float b = rnd(i + vec2(1, 0));\n    float c = rnd(i + vec2(0, 1));\n    float d = rnd(i + vec2(1, 1));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nconst vec2 shift = vec2(100.);\nconst mat2 r3 = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\nfloat fbm ( in vec2 uv) {\n    float v = .0, a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        v += a * noise(uv);\n        uv = r3 * uv * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdSzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[696, 696, 714, 714, 757], [758, 758, 779, 779, 846], [848, 862, 911, 911, 1007], [1009, 1009, 1028, 1028, 2146], [2148, 2148, 2178, 2178, 2417], [2419, 2419, 2451, 2451, 2679], [2681, 2681, 2702, 2702, 2801], [5483, 5483, 5524, 5524, 6384]]}
{"id": "cslcWN", "name": "Simple Shock Wave", "author": "MartinRGB", "description": "inspired by https://www.shadertoy.com/view/dlyXRK,my article about this effect:https://martinrgb.github.io/blog/#/Namedrop_Animation", "tags": ["waveshockripple"], "likes": 7, "viewed": 821, "published": 3, "date": "1686825681", "time_retrieved": "2024-07-30T17:49:32.812987", "image_code": "#define u_resolution iResolution\n#define u_time iTime\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 st = uv;\n    vec2 WaveCentre = vec2(0.5, 0.5);\n    float ratio = u_resolution.y/u_resolution.x;\n    WaveCentre.y *= ratio; \n    //st.y *= ratio;    \n    \n    float downScale = 2.;\n\tfloat dist = distance(vec2(st.x,st.y*ratio), WaveCentre) * downScale;\n    \n    float val = dist;\n    float a = 3.;\n    \n    // you can interpolate this value for animation curve\n    float pulseSpeed = u_time*10.3;\n    \n    float cosFuns = cos(val*20.- u_time*10.3);\n    float powFuns = pow(val*2.5,a);\n    float limtedPowFuns = 0.5 * pow(a/(a + powFuns),2.);\n    \n    float waveStrength = 1.;\n    \n    float finalRes = smoothstep(0.,1.,limtedPowFuns * cosFuns) * waveStrength;\n    \n \tvec3 col = finalRes*vec3(1.);\n    \n    // Convert uv range to -1 to 1\n    st = st * 2.0 - 1.0;\n    // Scale uv\n    st *= 1. + finalRes * 0.1;\n    // Convert back to 0 to 1 range\n    st = st * 0.5 + 0.5;\n\n    vec4 texCol = texture(iChannel0,st);\n    texCol += (texCol * finalRes) / ( dist * 10.0);\n    \n    // Output to screen\n    vec4 rippleCol = vec4(col ,1.);\n    fragColor = rippleCol;\n    fragColor = texCol ;\n    \n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 137, 187, 1328]]}
{"id": "cdXcD8", "name": "Geometry functions", "author": "Wither362", "description": "Circle in progress.", "tags": ["geometry"], "likes": 0, "viewed": 107, "published": 3, "date": "1686818012", "time_retrieved": "2024-07-30T17:49:33.769430", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float W = 1. / 2.;\n    \n    // Output to screen\n    fragColor = vec4(\n                     createRect(uv, vec2(0,0),           vec2(W,W), col)\n                   + createRect(uv, vec2(1. - W,1. - W), vec2(W,W), abs(cos(col)))\n                   + createRect(uv, vec2(1. - W,0),      vec2(W,W), 0.5 + 0.25 * abs(sin(tan(4. * col))))\n                   + createRect(uv, vec2(0,1. - W),      vec2(W,W), abs(fract(1. - col))),1.0);\n}", "image_inputs": [], "common_code": "vec3 createRect(vec2 uv, vec2 position, vec2 size, vec3 color) {\n    if(uv.x > position.x && uv.x < position.x + size.x && uv.y > position.y && uv.y < position.y + size.y) {\n        return color;\n    }\n    return vec3(0,0,0);\n}\nvec3 createCircle(vec2 uv, vec2 position, float radius, vec3 color) {\n    float x = uv.x - position.x - pow(uv.x - position.x, 2.);\n    if(x > .0) {\n        if(uv.y < sqrt(x) && uv.y < sqrt(x)) {\n            return color;\n        }\n    }\n    return vec3(0,0,0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXcD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 671]]}
{"id": "7tKcDK", "name": "Sound Experiment #8", "author": "oneshade", "description": "Stereo.", "tags": ["sound", "experiment"], "likes": 10, "viewed": 256, "published": 3, "date": "1686806054", "time_retrieved": "2024-07-30T17:49:34.582257", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.2831853072\n\nfloat midi(in float note) {\n    return 440.0 * exp2((note - 69.0) / 12.0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat sine(in float t) {\n    return sin(TAU * fract(t));\n}\n\nfloat triangle(in float t) {\n    return abs(mod(4.0 * t - 1.0, 4.0) - 2.0) - 1.0;\n}\n\nfloat striangle(in float t, in float k) {\n    return asin(k * sin(TAU * t)) / asin(k);\n}\n\nfloat square(in float t) {\n    return 1.0 - 2.0 * mod(floor(2.0 * t), 2.0);\n}\n\nfloat ssquare(in float t, in float w) {\n    t *= 2.0;\n    return 1.0 - 2.0 * abs(mod(floor(t), 2.0) - smoothstep(-w, w, abs(fract(t) - 0.5) - 0.5));\n}\n\nvec2 makeNoise(in float time) {\n    vec2 sound = vec2(0.0);\n\n    float t = time * (mod(floor(time * (mod(2.0 * floor(time), 2.0) + 1.0)), 2.0) + 1.0);\n    float t1 = fract(t);\n    sound.x += Hash11(t1 * 1000.0) * exp(-8.0 * t1) * smoothstep(1.0, 0.0, t1);\n\n    float t2 = fract(t - 0.5);\n    sound.y += Hash11(t2 * 1000.0) * exp(-8.0 * t2) * smoothstep(1.0, 0.0, t2);\n\n    float t3 = fract(time);\n    float env1 = exp(-5.0 * t3) * smoothstep(1.0, 0.0, t3);\n    sound += sine(t3 * midi(mix(35.0, 36.0, mod(floor(time), 2.0)))) * env1;\n\n    float t4 = fract(time * 4.0);\n    float env2 = exp(-5.0 * t4) * smoothstep(1.0, 0.0, t4);\n    sound += 1.5 * sine(t4 * midi(35.0) / 4.0) * env2;\n\n    float osc = sine(time * 128.0);\n    sound *= mix(vec2(osc, 1.0), vec2(1.0, osc), mod(floor(time * 0.5), 2.0));\n    sound *= osc;\n\n    return sound;\n}", "sound_code": "vec2 mainSound(int samp, float time) {\n    return makeNoise(float(samp % (11 * int(iSampleRate))) / iSampleRate);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1411]]}
{"id": "DsfcW4", "name": "Fractal mosaic 39 (music)", "author": "jarble", "description": "A fractal mosaic pattern.", "tags": ["fractal", "mosaic", "sitar"], "likes": 9, "viewed": 298, "published": 3, "date": "1686796722", "time_retrieved": "2024-07-30T17:49:35.475868", "image_code": "vec2 f1(vec2 a){\n    return\n        //fract(a)\n        fract(a-fract(a*4.))\n        //fract(a-fract(a*pow(floor(a.x),2.)))\n        //abs(fract(a)+fract(a/16.)/16.)/(1.+1./16.)\n        //mod(a*sign(1.-2.*mod(floor(a/2.),2.)),4.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5*2.;\n    vec2 uv = (fragCoord)/iResolution.y/1.5/t1;\n    uv.x += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.x = mod(uv.x,.25)+.25+.125;\n    //uv.y = mod(uv.y,.5)+.25-.125;\n    for(int k = 0; k < 4; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv-.5*sign(uv.x-uv.y)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        col.x =\n            max(sign(uv.x),col.x)\n            //abs(sign(uv.x)-col.x)/2.\n        ;\n        \n        //awesome kaleidoscope effect!\n        //if(t2.y>t2.x) {t2 = t2.yx; uv=uv.yx-iTime/8.;}\n        \n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n        //if(uv.y < .5) uv.y += .5;\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fract1(float a){\n    return\n        .125+abs(.125-fract(a))\n        //abs(fract(a)*1.125-.125)\n    ;\n}\n\nfloat fmod2(float a, float b){\n    return b*mod(floor(a),b);\n}\n\nfloat fmod1(float a, float b){\n    //a -= mod(a,3.);\n    \n    //a -= fmod2(a/4.,4.)/2.;\n    //a += fmod2(a+1.,b);\n    //a += mod(floor(a/2.),2.);\n    //a = a + floor(a/b)/b*8.;\n    //a += pow(2.,mod(floor(a/8.),b*b));\n    \n    /*\n    for(float a2 = 64.*2.; a2 < 128.*2.; a2 *= 2.){\n        a += mod(floor(a/a2),2.)+mod(floor(a/a2/2.),3.)+mod(floor(a/a2/4.),4.);\n        a /= 1. + mod(floor(a),2.);\n    }\n    */\n    return\n        mod(mod(floor(a),b)*mod(floor((a)/b),b),b)\n        //floor(mod(a/(1.+mod(floor(a+b),2.)),b))\n        //mod(mod(floor(floor(floor(a)*3.)/(8.-b)),b)*mod(floor((a)/b),b),b)\n        //mod(floor(a/2.)+floor(mod(a,2.)/2.),b)\n        //mod(floor(a/8.+8./b)+floor(a/b),b)\n        //mod(mod(floor(a*b/4.),b)*mod(floor(a/b)*floor(a*b/4.),b*2.),b*2.)\n        //mod(floor(a/8.+b/8.),floor(8./b))\n        //mod(mod(floor(a/2.+4.),floor(floor(b*8.+3.)/2.)),b)\n        //mod(mod(4.+floor(a*b/8.),4.+floor(a*b)),b)\n        //floor(mod(floor(a*b/(8.-b)),b))\n        //mod(mod(floor(a),b+mod(floor(a/b),b)),b)\n        //mod(mod(floor(a),1.+mod(floor(a),b))*mod(floor(a/b),1.+mod(floor(a/b),1.+mod(floor(a),b))),b)\n        //mod(mod(floor(a),b)*mod(floor(a/b/8.),b),b)\n        //mod(floor(a+pow(floor(b/(.5+mod(floor(a/8.),8.))),b)),b)\n        //mod(floor(a+pow(2.,b)/b/b),b)\n        //floor(sqrt(mod(mod(floor(a),b)*mod(floor(a*4./b),b),b*b)))\n        //floor(sqrt(mod(floor(a),b)*mod(floor(a/b),b*b)))\n        //mod(floor(a*sign(1.-2.*mod(floor(a/8.),2.))),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    \n    \n    return\n        fmod1(a,b)\n        //fmod1(mod(a+b,b*7.5),b)\n        //fmod1(a+fmod1(a/2.,b),b+fmod1(a/2.,b))\n        //fmod1(fmod1(a,b+8.),b)\n        //fmod1(a+fmod1(a*b/4.,b)*4./b,b)\n        //fmod1(a+fmod1(a/(8.-b),b),b)\n        //fmod1(a+fmod1(a,b*(b+1.)),b)\n        //floor(fmod1(a/2.,b*b)*fmod1(a,b*2.)/2./b)\n        //fmod1(a/(1.+mod(floor(a/2.),2.)),b)\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  time /= 2.;\n  float s1 =\n      8.,\n  s2 = 8.,\n  t = time/2.,\n  m1 = fmod(t,s1/2.);\n  t = \n      s1*pow(2.,fmod(t*16.+m1,2.))*t/(1.+fmod(floor(t*4.),2.))\n      //s1*pow(2.,fmod(t*16.,2.))*t\n  ;\n  float\n  m3 =\n      floor(fmod(time*16.,s1/2.)/2.)\n      //floor(fmod(time*8.,s1)/2.)\n      //floor(fmod(time*16.,s1)/4.)\n      //floor(fmod(t,s1*2.)/2.)\n      //floor(fmod(time*8.,s1*2.)/2.)\n  ;\n  float m2 =\n      1. + fmod(t,s1/2.);\n  ;\n  float a=\n      pow(1.-log(fract(t/2.)),2.)*2.\n      //pow(log(1./8.+fract(t/2.)/4.),2.)*2.\n      //time*128.*pow((1.-sqrt(fract1(t/2.)/2.))/2.,2.)\n  ;\n  float nb =\n      time*pow(2.,(m3+m2-m1)/7.+9.)\n      //time*pow(2.,(m3/2.+m2-m1)/2.5+8.)\n  ;\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb))*1.5)*a\n      \n      //sitar\n      \n      \n      log(.125+abs(abs(a/8.)-abs(a/8.-abs(.5-vec2(fract(nb/2.+.5),fract(nb)))*a)))\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //abs(1./16.-abs(.5-vec2(fract(nb*.998),fract(nb))*1.5))*a\n      //log(1.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 235], [237, 237, 264, 264, 449], [451, 451, 508, 508, 1539]]}
{"id": "dlGSDV", "name": "Spherical harmonics glyphs", "author": "christoph_peters", "description": "An efficient implementation of an intersection test for spherical harmonics glyphs.\nIncludes a well-optimized GPU implementation of polynomial root finding using this method: https://doi.org/10.1145/3543865", "tags": ["raytracing", "visualization", "intersection", "sphericalharmonics", "hardi"], "likes": 16, "viewed": 979, "published": 3, "date": "1686779514", "time_retrieved": "2024-07-30T17:49:37.098530", "image_code": "// Supplemental code for \"Ray Tracing Spherical Harmonics Glyphs\":\n// https://momentsingraphics.de/VMV2023.html\n// View results of this shader here: https://www.shadertoy.com/view/dlGSDV\n// (c) 2023, Christoph Peters\n// This work is licensed under a CC0 1.0 Universal License. To the extent\n// possible under law, Christoph Peters has waived all copyright and related or\n// neighboring rights to the following code. This work is published from\n// Germany. https://creativecommons.org/publicdomain/zero/1.0/\n\n// The index of the highest used band of the spherical harmonics basis. Must be\n// even, at least 2 and at most 12.\n#define SH_DEGREE 4\n// The number of spherical harmonics basis functions\n#define SH_COUNT (((SH_DEGREE + 1) * (SH_DEGREE + 2)) / 2)\n// Degree of polynomials for which we have to find roots\n#define MAX_DEGREE (2 * SH_DEGREE + 2)\n// If GL_EXT_control_flow_attributes is available, these defines should be\n// defined as [[unroll]] and [[loop]] to give reasonable hints to the compiler.\n// That avoids register spilling, which makes execution considerably faster.\n#ifndef _unroll_\n#define _unroll_\n#endif\n#ifndef _loop_\n#define _loop_\n#endif\n// When there are fewer intersections/roots than theoretically possible, some\n// array entries are set to this value\n#define NO_INTERSECTION 3.4e38\n// pi and its reciprocal\n#define M_PI 3.141592653589793238462643\n#define M_INV_PI 0.318309886183790671537767526745\n\n\n// Searches a single root of a polynomial within a given interval.\n// \\param out_root The location of the found root.\n// \\param out_end_value The value of the given polynomial at end.\n// \\param poly Coefficients of the polynomial for which a root should be found.\n//        Coefficient poly[i] is multiplied by x^i.\n// \\param begin The beginning of an interval where the polynomial is monotonic.\n// \\param end The end of said interval.\n// \\param begin_value The value of the given polynomial at begin.\n// \\param error_tolerance The error tolerance for the returned root location.\n//        Typically the error will be much lower but in theory it can be\n//        bigger.\n// \\return true if a root was found, false if no root exists.\nbool newton_bisection(out float out_root, out float out_end_value,\n    float poly[MAX_DEGREE + 1], float begin, float end,\n    float begin_value, float error_tolerance)\n{\n    if (begin == end) {\n        out_end_value = begin_value;\n        return false;\n    }\n    // Evaluate the polynomial at the end of the interval\n    out_end_value = poly[MAX_DEGREE];\n    _unroll_\n    for (int i = MAX_DEGREE - 1; i != -1; --i)\n        out_end_value = out_end_value * end + poly[i];\n    // If the values at both ends have the same non-zero sign, there is no root\n    if (begin_value * out_end_value > 0.0)\n        return false;\n    // Otherwise, we find the root iteratively using Newton bisection (with\n    // bounded iteration count)\n    float current = 0.5 * (begin + end);\n    _loop_\n    for (int i = 0; i != 90; ++i) {\n        // Evaluate the polynomial and its derivative\n        float value = poly[MAX_DEGREE] * current + poly[MAX_DEGREE - 1];\n        float derivative = poly[MAX_DEGREE];\n        _unroll_\n        for (int j = MAX_DEGREE - 2; j != -1; --j) {\n            derivative = derivative * current + value;\n            value = value * current + poly[j];\n        }\n        // Shorten the interval\n        bool right = begin_value * value > 0.0;\n        begin = right ? current : begin;\n        end = right ? end : current;\n        // Apply Newton's method\n        float guess = current - value / derivative;\n        // Pick a guess\n        float middle = 0.5 * (begin + end);\n        float next = (guess >= begin && guess <= end) ? guess : middle;\n        // Move along or terminate\n        bool done = abs(next - current) < error_tolerance;\n        current = next;\n        if (done)\n            break;\n    }\n    out_root = current;\n    return true;\n}\n\n\n// Finds all roots of the given polynomial in the interval [begin, end] and\n// writes them to out_roots. Some entries will be NO_INTERSECTION but other\n// than that the array is sorted. The last entry is always NO_INTERSECTION.\nvoid find_roots(out float out_roots[MAX_DEGREE + 1], float poly[MAX_DEGREE + 1], float begin, float end) {\n    float tolerance = (end - begin) * 1.0e-4;\n    // Construct the quadratic derivative of the polynomial. We divide each\n    // derivative by the factorial of its order, such that the constant\n    // coefficient can be copied directly from poly. That is a safeguard\n    // against overflow and makes it easier to avoid spilling below. The\n    // factors happen to be binomial coefficients then.\n    float derivative[MAX_DEGREE + 1];\n    derivative[0] = poly[MAX_DEGREE - 2];\n    derivative[1] = float(MAX_DEGREE - 1) * poly[MAX_DEGREE - 1];\n    derivative[2] = (0.5 * float((MAX_DEGREE - 1) * MAX_DEGREE)) * poly[MAX_DEGREE - 0];\n    _unroll_\n    for (int i = 3; i != MAX_DEGREE + 1; ++i)\n        derivative[i] = 0.0;\n    // Compute its two roots using the quadratic formula\n    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];\n    if (discriminant >= 0.0) {\n        float sqrt_discriminant = sqrt(discriminant);\n        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));\n        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);\n        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);\n        out_roots[MAX_DEGREE - 2] = min(root_0, root_1);\n        out_roots[MAX_DEGREE - 1] = max(root_0, root_1);\n    }\n    else {\n        // Indicate that the cubic derivative has a single root\n        out_roots[MAX_DEGREE - 2] = begin;\n        out_roots[MAX_DEGREE - 1] = begin;\n    }\n    // The last entry in the root array is set to end to make it easier to\n    // iterate over relevant intervals, all untouched roots are set to begin\n    out_roots[MAX_DEGREE] = end;\n    _unroll_\n    for (int i = 0; i != MAX_DEGREE - 2; ++i)\n        out_roots[i] = begin;\n    // Work your way up to derivatives of higher degree until you reach the\n    // polynomial itself. This implementation may seem peculiar: It always\n    // treats the derivative as though it had degree MAX_DEGREE and it\n    // constructs the derivatives in a contrived way. Changing that would\n    // reduce the number of arithmetic instructions roughly by a factor of two.\n    // However, it would also cause register spilling, which has a far more\n    // negative impact on the overall run time. Profiling indicates that the\n    // current implementation has no spilling whatsoever.\n    _loop_\n    for (int degree = 3; degree != MAX_DEGREE + 1; ++degree) {\n        // Take the integral of the previous derivative (scaled such that the\n        // constant coefficient can still be copied directly from poly)\n        float prev_derivative_order = float(MAX_DEGREE + 1 - degree);\n        _unroll_\n        for (int i = MAX_DEGREE; i != 0; --i)\n            derivative[i] = derivative[i - 1] * (prev_derivative_order * (1.0 / float(i)));\n        // Copy the constant coefficient without causing spilling. This part\n        // would be harder if the derivative were not scaled the way it is.\n        _unroll_\n        for (int i = 0; i != MAX_DEGREE - 2; ++i)\n            derivative[0] = (degree == MAX_DEGREE - i) ? poly[i] : derivative[0];\n        // Determine the value of this derivative at begin\n        float begin_value = derivative[MAX_DEGREE];\n        _unroll_\n        for (int i = MAX_DEGREE - 1; i != -1; --i)\n            begin_value = begin_value * begin + derivative[i];\n        // Iterate over the intervals where roots may be found\n        _unroll_\n        for (int i = 0; i != MAX_DEGREE; ++i) {\n            if (i < MAX_DEGREE - degree)\n                continue;\n            float current_begin = out_roots[i];\n            float current_end = out_roots[i + 1];\n            // Try to find a root\n            float root;\n            if (newton_bisection(root, begin_value, derivative, current_begin, current_end, begin_value, tolerance))\n                out_roots[i] = root;\n            else if (degree < MAX_DEGREE)\n                // Create an empty interval for the next iteration\n                out_roots[i] = out_roots[i - 1];\n            else\n                out_roots[i] = NO_INTERSECTION;\n        }\n    }\n    // We no longer need this array entry\n    out_roots[MAX_DEGREE] = NO_INTERSECTION;\n}\n\n\n// Evaluates the spherical harmonics basis in bands 0, 2, ..., SH_DEGREE.\n// Conventions are as in the following paper.\n// M. Descoteaux, E. Angelino, S. Fitzgibbons, and R. Deriche. Regularized,\n// fast, and robust analytical q-ball imaging. Magnetic Resonance in Medicine,\n// 58(3), 2007. https://doi.org/10.1002/mrm.21277\n// \\param out_shs Values of SH basis functions in bands 0, 2, ..., SH_DEGREE in\n//        this order.\n// \\param point The point on the unit sphere where the basis should be\n//        evaluated.\nvoid eval_sh(out float out_shs[SH_COUNT], vec3 point) {\n#if SH_DEGREE == 2\n    eval_sh_2(out_shs, point);\n#elif SH_DEGREE == 4\n    eval_sh_4(out_shs, point);\n#elif SH_DEGREE == 6\n    eval_sh_6(out_shs, point);\n#elif SH_DEGREE == 8\n    eval_sh_8(out_shs, point);\n#elif SH_DEGREE == 10\n    eval_sh_10(out_shs, point);\n#elif SH_DEGREE == 12\n    eval_sh_12(out_shs, point);\n#endif\n}\n\n\n// Evaluates the gradient of each basis function given by eval_sh() and the\n// basis itself\nvoid eval_sh_grad(out float out_shs[SH_COUNT], out vec3 out_grads[SH_COUNT], vec3 point) {\n#if SH_DEGREE == 2\n    eval_sh_grad_2(out_shs, out_grads, point);\n#elif SH_DEGREE == 4\n    eval_sh_grad_4(out_shs, out_grads, point);\n#elif SH_DEGREE == 6\n    eval_sh_grad_6(out_shs, out_grads, point);\n#elif SH_DEGREE == 8\n    eval_sh_grad_8(out_shs, out_grads, point);\n#elif SH_DEGREE == 10\n    eval_sh_grad_10(out_shs, out_grads, point);\n#elif SH_DEGREE == 12\n    eval_sh_grad_12(out_shs, out_grads, point);\n#endif\n}\n\n\n// Outputs a matrix that turns equidistant samples on the unit circle of a\n// homogeneous polynomial into coefficients of that polynomial.\nvoid get_inv_vandermonde(out float v[(SH_DEGREE + 1) * (SH_DEGREE + 1)]) {\n#if SH_DEGREE == 2\n    v[0*3 + 0] = -0.3333333333;     v[0*3 + 1] = 0.6666666667;      v[0*3 + 2] = 0.6666666667;\n    v[1*3 + 0] = -0.0;              v[1*3 + 1] = 1.1547005384;      v[1*3 + 2] = -1.1547005384;\n    v[2*3 + 0] = 1.0;               v[2*3 + 1] = 0.0;               v[2*3 + 2] = 0.0;\n#elif SH_DEGREE == 4\n    v[0*5 + 0] = 0.2;               v[0*5 + 1] = -0.2472135955;     v[0*5 + 2] = 0.6472135955;      v[0*5 + 3] = 0.6472135955;      v[0*5 + 4] = -0.2472135955;\n    v[1*5 + 0] = 0.0;               v[1*5 + 1] = -0.1796111906;     v[1*5 + 2] = 1.9919186279;      v[1*5 + 3] = -1.9919186279;     v[1*5 + 4] = 0.1796111906;\n    v[2*5 + 0] = -2.0;              v[2*5 + 1] = 2.3416407865;      v[2*5 + 2] = -0.3416407865;     v[2*5 + 3] = -0.3416407865;     v[2*5 + 4] = 2.3416407865;\n    v[3*5 + 0] = -0.0;              v[3*5 + 1] = 1.7013016167;      v[3*5 + 2] = -1.0514622242;     v[3*5 + 3] = 1.0514622242;      v[3*5 + 4] = -1.7013016167;\n    v[4*5 + 0] = 1.0;               v[4*5 + 1] = 0.0;               v[4*5 + 2] = 0.0;               v[4*5 + 3] = 0.0;               v[4*5 + 4] = 0.0;\n#elif SH_DEGREE == 6\n    v[0*7 + 0] = -0.1428571429;     v[0*7 + 1] = 0.1585594663;      v[0*7 + 2] = -0.2291250674;     v[0*7 + 3] = 0.6419941725;      v[0*7 + 4] = 0.6419941725;      v[0*7 + 5] = -0.2291250674;     v[0*7 + 6] = 0.1585594663;\n    v[1*7 + 0] = -0.0;              v[1*7 + 1] = 0.0763582145;      v[1*7 + 2] = -0.2873137468;     v[1*7 + 3] = 2.8127602518;      v[1*7 + 4] = -2.8127602518;     v[1*7 + 5] = 0.2873137468;      v[1*7 + 6] = -0.0763582145;\n    v[2*7 + 0] = 3.0;               v[2*7 + 1] = -3.2929766145;     v[2*7 + 2] = 4.4513463718;      v[2*7 + 3] = -1.1583697574;     v[2*7 + 4] = -1.1583697574;     v[2*7 + 5] = 4.4513463718;      v[2*7 + 6] = -3.2929766145;\n    v[3*7 + 0] = 0.0;               v[3*7 + 1] = -1.5858139579;     v[3*7 + 2] = 5.5818117995;      v[3*7 + 3] = -5.0751495106;     v[3*7 + 4] = 5.0751495106;      v[3*7 + 5] = -5.5818117995;     v[3*7 + 6] = 1.5858139579;\n    v[4*7 + 0] = -5.0;              v[4*7 + 1] = 4.7858935686;      v[4*7 + 2] = -1.0200067492;     v[4*7 + 3] = 0.2341131806;      v[4*7 + 4] = 0.2341131806;      v[4*7 + 5] = -1.0200067492;     v[4*7 + 6] = 4.7858935686;\n    v[5*7 + 0] = -0.0;              v[5*7 + 1] = 2.3047648710;      v[5*7 + 2] = -1.2790480077;     v[5*7 + 3] = 1.0257168633;      v[5*7 + 4] = -1.0257168633;     v[5*7 + 5] = 1.2790480077;      v[5*7 + 6] = -2.3047648710;\n    v[6*7 + 0] = 1.0;               v[6*7 + 1] = 0.0;               v[6*7 + 2] = 0.0;               v[6*7 + 3] = 0.0;               v[6*7 + 4] = 0.0;               v[6*7 + 5] = 0.0;               v[6*7 + 6] = 0.0;\n#elif SH_DEGREE == 8\n    v[0*9 + 0] = 0.1111111111;      v[0*9 + 1] = -0.1182419747;     v[0*9 + 2] = 0.1450452544;      v[0*9 + 3] = -0.2222222222;     v[0*9 + 4] = 0.6398633870;      v[0*9 + 5] = 0.6398633870;      v[0*9 + 6] = -0.2222222222;     v[0*9 + 7] = 0.1450452544;      v[0*9 + 8] = -0.1182419747;\n    v[1*9 + 0] = 0.0;               v[1*9 + 1] = -0.0430365592;     v[1*9 + 2] = 0.1217074194;      v[1*9 + 3] = -0.3849001795;     v[1*9 + 4] = 3.6288455938;      v[1*9 + 5] = -3.6288455938;     v[1*9 + 6] = 0.3849001795;      v[1*9 + 7] = -0.1217074194;     v[1*9 + 8] = 0.0430365592;\n    v[2*9 + 0] = -4.0;              v[2*9 + 1] = 4.2410470634;      v[2*9 + 2] = -5.1195045066;     v[2*9 + 3] = 7.3333333333;      v[2*9 + 4] = -2.4548758901;     v[2*9 + 5] = -2.4548758901;     v[2*9 + 6] = 7.3333333333;      v[2*9 + 7] = -5.1195045066;     v[2*9 + 8] = 4.2410470634;\n    v[3*9 + 0] = -0.0;              v[3*9 + 1] = 1.5436148932;      v[3*9 + 2] = -4.2957743433;     v[3*9 + 3] = 12.7017059222;     v[3*9 + 4] = -13.9222930051;    v[3*9 + 5] = 13.9222930051;     v[3*9 + 6] = -12.7017059222;    v[3*9 + 7] = 4.2957743433;      v[3*9 + 8] = -1.5436148932;\n    v[4*9 + 0] = 14.0;              v[4*9 + 1] = -14.3366589404;    v[4*9 + 2] = 14.6711193836;     v[4*9 + 3] = -6.0;              v[4*9 + 4] = 1.6655395568;      v[4*9 + 5] = 1.6655395568;      v[4*9 + 6] = -6.0;              v[4*9 + 7] = 14.6711193836;     v[4*9 + 8] = -14.3366589404;\n    v[5*9 + 0] = 0.0;               v[5*9 + 1] = -5.2181171131;     v[5*9 + 2] = 12.3105308637;     v[5*9 + 3] = -10.3923048454;    v[5*9 + 4] = 9.4457442082;      v[5*9 + 5] = -9.4457442082;     v[5*9 + 6] = 10.3923048454;     v[5*9 + 7] = -12.3105308637;    v[5*9 + 8] = 5.2181171131;\n    v[6*9 + 0] = -9.3333333333;     v[6*9 + 1] = 8.0330865684;      v[6*9 + 2] = -1.8540394597;     v[6*9 + 3] = 0.6666666667;      v[6*9 + 4] = -0.1790471086;     v[6*9 + 5] = -0.1790471086;     v[6*9 + 6] = 0.6666666667;      v[6*9 + 7] = -1.8540394597;     v[6*9 + 8] = 8.0330865684;\n    v[7*9 + 0] = -0.0;              v[7*9 + 1] = 2.9238044002;      v[7*9 + 2] = -1.5557238269;     v[7*9 + 3] = 1.1547005384;      v[7*9 + 4] = -1.0154266119;     v[7*9 + 5] = 1.0154266119;      v[7*9 + 6] = -1.1547005384;     v[7*9 + 7] = 1.5557238269;      v[7*9 + 8] = -2.9238044002;\n    v[8*9 + 0] = 1.0;               v[8*9 + 1] = 0.0;               v[8*9 + 2] = 0.0;               v[8*9 + 3] = 0.0;               v[8*9 + 4] = 0.0;               v[8*9 + 5] = 0.0;               v[8*9 + 6] = 0.0;               v[8*9 + 7] = 0.0;               v[8*9 + 8] = 0.0;\n#elif SH_DEGREE == 10\n    v[0*11 + 0] = -0.0909090909;    v[0*11 + 1] = 0.0947470106;     v[0*11 + 2] = -0.1080638444;    v[0*11 + 3] = 0.1388220215;     v[0*11 + 4] = -0.2188392043;    v[0*11 + 5] = 0.6387885621;     v[0*11 + 6] = 0.6387885621;     v[0*11 + 7] = -0.2188392043;    v[0*11 + 8] = 0.1388220215;     v[0*11 + 9] = -0.1080638444;    v[0*11 + 10] = 0.0947470106;\n    v[1*11 + 0] = -0.0;             v[1*11 + 1] = 0.0278202324;     v[1*11 + 2] = -0.0694484159;    v[1*11 + 3] = 0.1602091533;     v[1*11 + 4] = -0.4791910159;    v[1*11 + 5] = 4.4428720384;     v[1*11 + 6] = -4.4428720384;    v[1*11 + 7] = 0.4791910159;     v[1*11 + 8] = -0.1602091533;    v[1*11 + 9] = 0.0694484159;     v[1*11 + 10] = -0.0278202324;\n    v[2*11 + 0] = 5.0;              v[2*11 + 1] = -5.2029168239;    v[2*11 + 2] = 5.8988796576;     v[2*11 + 3] = -7.4503199653;    v[2*11 + 4] = 10.9868742757;    v[2*11 + 5] = -4.2325171441;    v[2*11 + 6] = -4.2325171441;    v[2*11 + 7] = 10.9868742757;    v[2*11 + 8] = -7.4503199653;    v[2*11 + 9] = 5.8988796576;     v[2*11 + 10] = -5.2029168239;\n    v[3*11 + 0] = 0.0;              v[3*11 + 1] = -1.5277142200;    v[3*11 + 2] = 3.7909797649;     v[3*11 + 3] = -8.5981275876;    v[3*11 + 4] = 24.0578988657;    v[3*11 + 5] = -29.4378033460;   v[3*11 + 6] = 29.4378033460;    v[3*11 + 7] = -24.0578988657;   v[3*11 + 8] = 8.5981275876;     v[3*11 + 9] = -3.7909797649;    v[3*11 + 10] = 1.5277142200;\n    v[4*11 + 0] = -30.0;            v[4*11 + 1] = 30.8179361182;    v[4*11 + 2] = -33.2247539061;   v[4*11 + 3] = 35.8884989085;    v[4*11 + 4] = -19.5374870834;   v[4*11 + 5] = 6.0558059629;     v[4*11 + 6] = 6.0558059629;     v[4*11 + 7] = -19.5374870834;   v[4*11 + 8] = 35.8884989085;    v[4*11 + 9] = -33.2247539061;   v[4*11 + 10] = 30.8179361182;\n    v[5*11 + 0] = -0.0;             v[5*11 + 1] = 9.0489625020;     v[5*11 + 2] = -21.3522528115;   v[5*11 + 3] = 41.4175356200;    v[5*11 + 4] = -42.7811292411;   v[5*11 + 5] = 42.1190556280;    v[5*11 + 6] = -42.1190556280;   v[5*11 + 7] = 42.7811292411;    v[5*11 + 8] = -41.4175356200;   v[5*11 + 9] = 21.3522528115;    v[5*11 + 10] = -9.0489625020;\n    v[6*11 + 0] = 42.0;             v[6*11 + 1] = -41.1161037573;   v[6*11 + 2] = 36.2032364762;    v[6*11 + 3] = -16.3373898141;   v[6*11 + 4] = 7.4261062994;     v[6*11 + 5] = -2.1758492042;    v[6*11 + 6] = -2.1758492042;    v[6*11 + 7] = 7.4261062994;     v[6*11 + 8] = -16.3373898141;   v[6*11 + 9] = 36.2032364762;    v[6*11 + 10] = -41.1161037573;\n    v[7*11 + 0] = 0.0;              v[7*11 + 1] = -12.0727773496;   v[7*11 + 2] = 23.2664073304;    v[7*11 + 3] = -18.8543529304;   v[7*11 + 4] = 16.2609045881;    v[7*11 + 5] = -15.1333636234;   v[7*11 + 6] = 15.1333636234;    v[7*11 + 7] = -16.2609045881;   v[7*11 + 8] = 18.8543529304;    v[7*11 + 9] = -23.2664073304;   v[7*11 + 10] = 12.0727773496;\n    v[8*11 + 0] = -15.0;            v[8*11 + 1] = 12.0883694702;    v[8*11 + 2] = -2.8781222629;    v[8*11 + 3] = 1.1465503415;     v[8*11 + 4] = -0.5020543475;    v[8*11 + 5] = 0.1452567988;     v[8*11 + 6] = 0.1452567988;     v[8*11 + 7] = -0.5020543475;    v[8*11 + 8] = 1.1465503415;     v[8*11 + 9] = -2.8781222629;    v[8*11 + 10] = 12.0883694702;\n    v[9*11 + 0] = -0.0;             v[9*11 + 1] = 3.5494655329;     v[9*11 + 2] = -1.8496568659;    v[9*11 + 3] = 1.3231896304;     v[9*11 + 4] = -1.0993456751;    v[9*11 + 5] = 1.0102832265;     v[9*11 + 6] = -1.0102832265;    v[9*11 + 7] = 1.0993456751;     v[9*11 + 8] = -1.3231896304;    v[9*11 + 9] = 1.8496568659;     v[9*11 + 10] = -3.5494655329;\n    v[10*11 + 0] = 1.0;             v[10*11 + 1] = 0.0;             v[10*11 + 2] = 0.0;             v[10*11 + 3] = 0.0;             v[10*11 + 4] = 0.0;             v[10*11 + 5] = 0.0;             v[10*11 + 6] = 0.0;             v[10*11 + 7] = 0.0;             v[10*11 + 8] = 0.0;             v[10*11 + 9] = 0.0;             v[10*11 + 10] = 0.0;\n#elif SH_DEGREE == 12\n    v[0*13 + 0] = 0.0769230769;     v[0*13 + 1] = -0.0792252178;    v[0*13 + 2] = 0.0868739663;     v[0*13 + 3] = -0.1027681661;    v[0*13 + 4] = 0.1354125166;     v[0*13 + 5] = -0.2169261613;    v[0*13 + 6] = 0.6381715239;     v[0*13 + 7] = 0.6381715239;     v[0*13 + 8] = -0.2169261613;    v[0*13 + 9] = 0.1354125166;     v[0*13 + 10] = -0.1027681661;   v[0*13 + 11] = 0.0868739663;    v[0*13 + 12] = -0.0792252178;\n    v[1*13 + 0] = -0.0;             v[1*13 + 1] = -0.0195272624;    v[1*13 + 2] = 0.0455949748;     v[1*13 + 3] = -0.0910446506;    v[1*13 + 4] = 0.1961788986;     v[1*13 + 5] = -0.5719872785;    v[1*13 + 6] = 5.2558153553;     v[1*13 + 7] = -5.2558153553;    v[1*13 + 8] = 0.5719872785;     v[1*13 + 9] = -0.1961788986;    v[1*13 + 10] = 0.0910446506;    v[1*13 + 11] = -0.0455949748;   v[1*13 + 12] = 0.0195272624;\n    v[2*13 + 0] = -6.0;             v[2*13 + 1] = 6.1747539478;     v[2*13 + 2] = -6.7522392818;    v[2*13 + 3] = 7.9352584366;     v[2*13 + 4] = -10.2779620900;   v[2*13 + 5] = 15.4120340799;    v[2*13 + 6] = -6.4918450925;    v[2*13 + 7] = -6.4918450925;    v[2*13 + 8] = 15.4120340799;    v[2*13 + 9] = -10.2779620900;   v[2*13 + 10] = 7.9352584366;    v[2*13 + 11] = -6.7522392818;   v[2*13 + 12] = 6.1747539478;\n    v[3*13 + 0] = -0.0;             v[3*13 + 1] = 1.5219401578;     v[3*13 + 2] = -3.5438485554;    v[3*13 + 3] = 7.0300255289;     v[3*13 + 4] = -14.8901987371;   v[3*13 + 5] = 40.6381940129;    v[3*13 + 6] = -53.4651544987;   v[3*13 + 7] = 53.4651544987;    v[3*13 + 8] = -40.6381940129;   v[3*13 + 9] = 14.8901987371;    v[3*13 + 10] = -7.0300255289;   v[3*13 + 11] = 3.5438485554;    v[3*13 + 12] = -1.5219401578;\n    v[4*13 + 0] = 55.0;             v[4*13 + 1] = -56.2709061445;   v[4*13 + 2] = 60.2549306937;    v[4*13 + 3] = -67.2511796347;   v[4*13 + 4] = 75.2477722397;    v[4*13 + 5] = -47.9480941911;   v[4*13 + 6] = 15.9674770369;    v[4*13 + 7] = 15.9674770369;    v[4*13 + 8] = -47.9480941911;   v[4*13 + 9] = 75.2477722397;    v[4*13 + 10] = -67.2511796347;  v[4*13 + 11] = 60.2549306937;   v[4*13 + 12] = -56.2709061445;\n    v[5*13 + 0] = 0.0;              v[5*13 + 1] = -13.8695326974;   v[5*13 + 2] = 31.6242271914;    v[5*13 + 3] = -59.5793462127;   v[5*13 + 4] = 109.0152185187;   v[5*13 + 5] = -126.4287338180;  v[5*13 + 6] = 131.5040045727;   v[5*13 + 7] = -131.5040045727;  v[5*13 + 8] = 126.4287338180;   v[5*13 + 9] = -109.0152185187;  v[5*13 + 10] = 59.5793462127;   v[5*13 + 11] = -31.6242271914;  v[5*13 + 12] = 13.8695326974;\n    v[6*13 + 0] = -132.0;           v[6*13 + 1] = 132.5319409049;   v[6*13 + 2] = -132.4780513404;  v[6*13 + 3] = 123.5674782081;   v[6*13 + 4] = -74.4320682907;   v[6*13 + 5] = 38.8801193717;    v[6*13 + 6] = -12.0694188537;   v[6*13 + 7] = -12.0694188537;   v[6*13 + 8] = 38.8801193717;    v[6*13 + 9] = -74.4320682907;   v[6*13 + 10] = 123.5674782081;  v[6*13 + 11] = -132.4780513404; v[6*13 + 12] = 132.5319409049;\n    v[7*13 + 0] = -0.0;             v[7*13 + 1] = 32.6661895777;    v[7*13 + 2] = -69.5298450306;   v[7*13 + 3] = 109.4712331409;   v[7*13 + 4] = -107.8334673306;  v[7*13 + 5] = 102.5184492897;   v[7*13 + 6] = -99.4006071501;   v[7*13 + 7] = 99.4006071501;    v[7*13 + 8] = -102.5184492897;  v[7*13 + 9] = 107.8334673306;   v[7*13 + 10] = -109.4712331409; v[7*13 + 11] = 69.5298450306;   v[7*13 + 12] = -32.6661895777;\n    v[8*13 + 0] = 99.0;             v[8*13 + 1] = -93.9113626635;   v[8*13 + 2] = 75.3147168618;    v[8*13 + 3] = -35.2795800772;   v[8*13 + 4] = 18.0521608541;    v[8*13 + 5] = -8.8650350126;    v[8*13 + 6] = 2.6891000373;     v[8*13 + 7] = 2.6891000373;     v[8*13 + 8] = -8.8650350126;    v[8*13 + 9] = 18.0521608541;    v[8*13 + 10] = -35.2795800772;  v[8*13 + 11] = 75.3147168618;   v[8*13 + 12] = -93.9113626635;\n    v[9*13 + 0] = 0.0;              v[9*13 + 1] = -23.1470719837;   v[9*13 + 2] = 39.5282127035;    v[9*13 + 3] = -31.2549806126;   v[9*13 + 4] = 26.1530700733;    v[9*13 + 5] = -23.3751762359;   v[9*13 + 6] = 22.1467313083;    v[9*13 + 7] = -22.1467313083;   v[9*13 + 8] = 23.3751762359;    v[9*13 + 9] = -26.1530700733;   v[9*13 + 10] = 31.2549806126;   v[9*13 + 11] = -39.5282127035;  v[9*13 + 12] = 23.1470719837;\n    v[10*13 + 0] = -22.0;           v[10*13 + 1] = 16.9531714429;   v[10*13 + 2] = -4.0999479387;   v[10*13 + 3] = 1.7021989010;    v[10*13 + 4] = -0.8387165175;   v[10*13 + 5] = 0.4056079008;    v[10*13 + 6] = -0.1223137885;   v[10*13 + 7] = -0.1223137885;   v[10*13 + 8] = 0.4056079008;    v[10*13 + 9] = -0.8387165175;   v[10*13 + 10] = 1.7021989010;   v[10*13 + 11] = -4.0999479387;  v[10*13 + 12] = 16.9531714429;\n    v[11*13 + 0] = -0.0;            v[11*13 + 1] = 4.1785814689;    v[11*13 + 2] = -2.1518186743;   v[11*13 + 3] = 1.5080166355;    v[11*13 + 4] = -1.2150906493;   v[11*13 + 5] = 1.0695001374;    v[11*13 + 6] = -1.0073446769;   v[11*13 + 7] = 1.0073446769;    v[11*13 + 8] = -1.0695001374;   v[11*13 + 9] = 1.2150906493;    v[11*13 + 10] = -1.5080166355;  v[11*13 + 11] = 2.1518186743;   v[11*13 + 12] = -4.1785814689;\n    v[12*13 + 0] = 1.0;             v[12*13 + 1] = 0.0;             v[12*13 + 2] = 0.0;             v[12*13 + 3] = 0.0;             v[12*13 + 4] = 0.0;             v[12*13 + 5] = 0.0;             v[12*13 + 6] = 0.0;             v[12*13 + 7] = 0.0;             v[12*13 + 8] = 0.0;             v[12*13 + 9] = 0.0;             v[12*13 + 10] = 0.0;            v[12*13 + 11] = 0.0;            v[12*13 + 12] = 0.0;\n#endif\n}\n\n\n// Determines all intersections between a ray and a spherical harmonics glyph.\n// \\param out_ray_params The ray parameters at intersection points. The points\n//        themselves are at ray_origin + out_ray_params[i] * ray_dir. Some\n//        entries may be NO_INTERSECTION but other than that the array is\n//        sorted.\n// \\param sh_coeffs SH_COUNT spherical harmonic coefficients defining the\n//        glyph. Their exact meaning is defined by eval_sh().\n// \\param ray_origin The origin of the ray, relative to the glyph center.\n// \\param ray_dir The normalized direction vector of the ray.\nvoid ray_sh_glyph_intersections(out float out_ray_params[MAX_DEGREE], float sh_coeffs[SH_COUNT], vec3 ray_origin, vec3 ray_dir) {\n    // Determine the direction from the glyph center to the closest point on\n    // the ray\n    float dir_dot_origin = dot(ray_dir, ray_origin);\n    vec3 closest_dir = normalize(ray_origin - dir_dot_origin * ray_dir);\n    // Evaluate the SH polynomial at SH_DEGREE + 1 points. That is enough to\n    // know its value everywhere along the ray.\n    float sh_values[SH_DEGREE + 1];\n    _unroll_\n    for (int i = 0; i != SH_DEGREE + 1; ++i) {\n        vec3 point = cos(float(i) * (M_PI / float(SH_DEGREE + 1))) * ray_dir\n                   + sin(float(i) * (M_PI / float(SH_DEGREE + 1))) * closest_dir;\n        float shs[SH_COUNT];\n        eval_sh(shs, point);\n        sh_values[i] = 0.0;\n        _unroll_\n        for (int j = 0; j != SH_COUNT; ++j)\n            sh_values[i] += sh_coeffs[j] * shs[j];\n    }\n    // Compute coefficients of the SH polynomial along the ray in the\n    // coordinate frame given by ray_dir and closest_dir\n    float radius_poly[SH_DEGREE + 1];\n    float inv_vander[(SH_DEGREE + 1) * (SH_DEGREE + 1)];\n    get_inv_vandermonde(inv_vander);\n    _unroll_\n    for (int i = 0; i != SH_DEGREE + 1; ++i) {\n        radius_poly[i] = 0.0;\n        _unroll_\n        for (int j = 0; j != SH_DEGREE + 1; ++j)\n            radius_poly[i] += inv_vander[i * (SH_DEGREE + 1) + j] * sh_values[j];\n    }\n    // Compute a bounding circle around the glyph in the relevant plane\n    float radius_max = 0.0;\n    _unroll_\n    for (int i = 0; i != SH_DEGREE + 1; ++i) {\n        float bound = sqrt(pow(float(i), float(i)) * pow(float(SH_DEGREE - i), float(SH_DEGREE - i)) / pow(float(SH_DEGREE), float(SH_DEGREE)));\n        // Workaround for buggy compilers where 0^0 is 0\n        bound = (i == 0 || i == SH_DEGREE) ? 1.0 : bound;\n        radius_max += bound * abs(radius_poly[i]);\n    }\n    // Figure out the interval, where (if at all) the ray intersects the circle\n    float closest_dot_origin = dot(closest_dir, ray_origin);\n    if (radius_max < abs(closest_dot_origin)) {\n        _unroll_\n        for (int i = 0; i != MAX_DEGREE; ++i)\n            out_ray_params[i] = NO_INTERSECTION;\n        return;\n    }\n    float radius_over_dot = radius_max / closest_dot_origin;\n    float u_max = sqrt(radius_over_dot * radius_over_dot - 1.0);\n    // Take the square of radius_poly\n    float poly[MAX_DEGREE + 1];\n    _unroll_\n    for (int i = 0; i != MAX_DEGREE + 1; ++i)\n        poly[i] = 0.0;\n    _unroll_\n    for (int i = 0; i != SH_DEGREE + 1; ++i)\n        _unroll_\n        for (int j = 0; j != SH_DEGREE + 1; ++j)\n            poly[i + j] += radius_poly[i] * radius_poly[j];\n    // Subtract the scaled (2 * SH_DEGREE + 2)-th power of the distance to the\n    // glyph center\n    float dot_sq = closest_dot_origin * closest_dot_origin;\n    float binomial = 1.0;\n    _unroll_\n    for (int i = 0; i != SH_DEGREE + 2; ++i) {\n        poly[2 * i] -= binomial * dot_sq;    \n        // Update the binomial coefficient using a recurrence relation\n        binomial *= float(SH_DEGREE + 1 - i) / float(i + 1);\n    }\n    // Find roots of the polynomial within the relevant bounds\n    float roots[MAX_DEGREE + 1];\n    find_roots(roots, poly, -u_max, u_max);\n    // Convert them back to the original coordinate frame (i.e. ray parameters)\n    _unroll_\n    for (int i = 0; i != MAX_DEGREE; ++i)\n        out_ray_params[i] = (roots[i] != NO_INTERSECTION)\n                            ? (roots[i] * closest_dot_origin - dir_dot_origin)\n                            : NO_INTERSECTION;\n}\n\n\n// Provides a normalized normal vector for a spherical harmonics glyph.\n// \\param sh_coeffs SH_COUNT spherical harmonic coefficients defining the\n//        glyph. Their exact meaning is defined by eval_sh().\n// \\param point A point on the surface of the glyph, relative to its center.\n// \\return A normalized surface normal pointing away from the origin.\nvec3 get_sh_glyph_normal(float sh_coeffs[SH_COUNT], vec3 point) {\n    float shs[SH_COUNT];\n    vec3 grads[SH_COUNT];\n    float length_inv = inversesqrt(dot(point, point));\n    vec3 normalized = point * length_inv;\n    eval_sh_grad(shs, grads, normalized);\n    float value = 0.0;\n    vec3 grad = vec3(0.0);\n    _unroll_\n    for (int i = 0; i != SH_COUNT; ++i) {\n        value += sh_coeffs[i] * shs[i];\n        grad += sh_coeffs[i] * grads[i];\n    }\n    return normalize(point - (value * length_inv) * (grad - dot(grad, normalized) * normalized));\n}\n\n\n// This is the glTF BRDF for dielectric materials, exactly as described here:\n// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#appendix-b-brdf-implementation\n// \\param incoming The normalized incoming light direction.\n// \\param outgoing The normalized outgoing light direction.\n// \\param normal The normalized shading normal.\n// \\param roughness An artist friendly roughness value between 0 and 1\n// \\param base_color The albedo used for the Lambertian diffuse component\n// \\return The BRDF for the given directions.\nvec3 gltf_dielectric_brdf(vec3 incoming, vec3 outgoing, vec3 normal, float roughness, vec3 base_color) {\n    float ni = dot(normal, incoming);\n    float no = dot(normal, outgoing);\n    // Early out if incoming or outgoing direction are below the horizon\n    if (ni <= 0.0 || no <= 0.0)\n        return vec3(0.0);\n    // Save some work by not actually computing the half-vector. If the half-\n    // vector were h, ih = dot(incoming, h) and\n    // sqrt(nh_ih_2 / ih_2) = dot(normal, h).\n    float ih_2 = dot(incoming, outgoing) * 0.5 + 0.5;\n    float sum = ni + no;\n    float nh_ih_2 = 0.25 * sum * sum;\n    float ih = sqrt(ih_2);\n\n    // Evaluate the GGX normal distribution function\n    float roughness_2 = roughness * roughness;\n    float roughness_4  = roughness_2 * roughness_2;\n    float roughness_flip = 1.0 - roughness_4;\n    float denominator = ih_2 - nh_ih_2 * roughness_flip;\n    float ggx = (roughness_4 * M_INV_PI * ih_2) / (denominator * denominator);\n    // Evaluate the \"visibility\" (i.e. masking-shadowing times geometry terms)\n    float vi = ni + sqrt(roughness_4 + roughness_flip * ni * ni);\n    float vo = no + sqrt(roughness_4 + roughness_flip * no * no);\n    float v = 1.0 / (vi * vo);\n    // That completes the specular BRDF\n    float specular = v * ggx;\n\n    // The diffuse BRDF is Lambertian\n    vec3 diffuse = M_INV_PI * base_color;\n\n    // Evaluate the Fresnel term using the Fresnel-Schlick approximation\n    const float ior = 1.5;\n    const float f0 = ((1.0 - ior) / (1.0 + ior)) * ((1.0 - ior) / (1.0 + ior));\n    float ih_flip = 1.0 - ih;\n    float ih_flip_2 = ih_flip * ih_flip;\n    float fresnel = f0 + (1.0 - f0) * ih_flip * ih_flip_2 * ih_flip_2;\n\n    // Mix the two components\n    return mix(diffuse, vec3(specular), fresnel);\n}\n\n\n// Applies the non-linearity that maps linear RGB to sRGB\nfloat linear_to_srgb(float linear) {\n    return (linear <= 0.0031308) ? (12.92 * linear) : (1.055 * pow(linear, 1.0 / 2.4) - 0.055);\n}\n\n// Inverse of linear_to_srgb()\nfloat srgb_to_linear(float non_linear) {\n    return (non_linear <= 0.04045) ? ((1.0 / 12.92) * non_linear) : pow(non_linear * (1.0 / 1.055) + 0.055 / 1.055, 2.4);\n}\n\n// Turns a linear RGB color (i.e. rec. 709) into sRGB\nvec3 linear_rgb_to_srgb(vec3 linear) {\n    return vec3(linear_to_srgb(linear.r), linear_to_srgb(linear.g), linear_to_srgb(linear.b));\n}\n\n// Inverse of linear_rgb_to_srgb()\nvec3 srgb_to_linear_rgb(vec3 srgb) {\n    return vec3(srgb_to_linear(srgb.r), srgb_to_linear(srgb.g), srgb_to_linear(srgb.b));\n}\n\n// Logarithmic tonemapping operator. Input and output are linear RGB.\nvec3 tonemap(vec3 linear) {\n    float max_channel = max(max(1.0, linear.r), max(linear.g, linear.b));\n    return linear * ((1.0 - 0.02 * log2(max_channel)) / max_channel);\n}\n\n\nvoid mainImage(out vec4 out_color, vec2 frag_coord) {\n    // Define a camera ray for a pinhole camera\n    vec3 camera_pos = vec3(0.0, -5.0, 0.0);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    float zoom = 0.8;\n    vec3 right = (aspect / zoom) * vec3(3.0, 0.0, 0.0);\n    vec3 up = (1.0 / zoom) * vec3(0.0, 0.0, 3.0);\n    vec3 bottom_left = -0.5 * (right + up);\n    vec2 uv = frag_coord / vec2(iResolution.xy);\n    vec3 ray_dir = normalize(bottom_left + uv.x * right + uv.y * up - camera_pos);\n    // Rotate the camera slowly\n    float pitch = -0.2 * M_PI;\n    float yaw = 0.1 * M_PI * iTime;\n    mat3 rot_z = mat3(cos(yaw), sin(yaw), 0.0, -sin(yaw), cos(yaw), 0.0, 0.0, 0.0, 1.0);\n    mat3 rot_x = mat3(1.0, 0.0, 0.0, 0.0, cos(pitch), sin(pitch), 0.0, -sin(pitch), cos(pitch));\n    camera_pos = rot_z * rot_x * camera_pos;\n    ray_dir = normalize(rot_z * rot_x * ray_dir);\n    // Define SH coefficients (measured up to band 8, noise beyond that)\n    float sh_coeffs[SH_COUNT];\n    sh_coeffs[0] = -0.2739740312099;  sh_coeffs[1] = 0.2526670396328;  sh_coeffs[2] = 1.8922271728516;  sh_coeffs[3] = 0.2878578901291;  sh_coeffs[4] = -0.5339795947075;  sh_coeffs[5] = -0.2620058953762;\n#if SH_DEGREE >= 4\n    sh_coeffs[6] = 0.1580424904823;  sh_coeffs[7] = 0.0329004973173;  sh_coeffs[8] = -0.1322413831949;  sh_coeffs[9] = -0.1332057565451;  sh_coeffs[10] = 1.0894461870193;  sh_coeffs[11] = -0.6319401264191;  sh_coeffs[12] = -0.0416776277125;  sh_coeffs[13] = -1.0772529840469;  sh_coeffs[14] = 0.1423762738705;\n#endif\n#if SH_DEGREE >= 6\n    sh_coeffs[15] = 0.7941166162491;  sh_coeffs[16] = 0.7490307092667;  sh_coeffs[17] = -0.3428381681442;  sh_coeffs[18] = 0.1024847552180;  sh_coeffs[19] = -0.0219132602215;  sh_coeffs[20] = 0.0499043911695;  sh_coeffs[21] = 0.2162453681231;  sh_coeffs[22] = 0.0921059995890;  sh_coeffs[23] = -0.2611238956451;  sh_coeffs[24] = 0.2549301385880;  sh_coeffs[25] = -0.4534865319729;  sh_coeffs[26] = 0.1922748684883;  sh_coeffs[27] = -0.6200597286224;\n#endif\n#if SH_DEGREE >= 8\n    sh_coeffs[28] = -0.0532187558711;  sh_coeffs[29] = -0.3569841980934;  sh_coeffs[30] = 0.0293972902000;  sh_coeffs[31] = -0.1977960765362;  sh_coeffs[32] = -0.1058669015765;  sh_coeffs[33] = 0.2372217923403;  sh_coeffs[34] = -0.1856198310852;  sh_coeffs[35] = -0.3373193442822;  sh_coeffs[36] = -0.0750469490886;  sh_coeffs[37] = 0.2146576642990;  sh_coeffs[38] = -0.0490148440003;  sh_coeffs[39] = 0.1288588196039;  sh_coeffs[40] = 0.3173974752426;  sh_coeffs[41] = 0.1990085393190;  sh_coeffs[42] = -0.1736343950033;  sh_coeffs[43] = -0.0482443645597;  sh_coeffs[44] = 0.1749017387629;\n#endif\n#if SH_DEGREE >= 10\n    sh_coeffs[45] = -0.0151847425660;  sh_coeffs[46] = 0.0418366046081;  sh_coeffs[47] = 0.0863263587216;  sh_coeffs[48] = -0.0649211244490;  sh_coeffs[49] = 0.0126096132283;  sh_coeffs[50] = 0.0545089217982;  sh_coeffs[51] = -0.0275142164626;  sh_coeffs[52] = 0.0399986574832;  sh_coeffs[53] = -0.0468244261610;  sh_coeffs[54] = -0.1292105653111;  sh_coeffs[55] = -0.0786858322658;  sh_coeffs[56] = -0.0663828464882;  sh_coeffs[57] = 0.0382439706831;  sh_coeffs[58] = -0.0041550330365;  sh_coeffs[59] = -0.0502800566338;  sh_coeffs[60] = -0.0732471630735;  sh_coeffs[61] = 0.0181751900972;  sh_coeffs[62] = -0.0090119333757;  sh_coeffs[63] = -0.0604443282359;  sh_coeffs[64] = -0.1469985252752;  sh_coeffs[65] = -0.0534046899715;\n#endif\n#if SH_DEGREE >= 12\n    sh_coeffs[66] = -0.0896672753415;  sh_coeffs[67] = -0.0130841364808;  sh_coeffs[68] = -0.0112942893801;  sh_coeffs[69] = 0.0272257498541;  sh_coeffs[70] = 0.0626717616331;  sh_coeffs[71] = -0.0222197983050;  sh_coeffs[72] = -0.0018541504308;  sh_coeffs[73] = -0.1653251944056;  sh_coeffs[74] = 0.0409697402846;  sh_coeffs[75] = 0.0749921454327;  sh_coeffs[76] = -0.0282830872616;  sh_coeffs[77] = 0.0006909458525;  sh_coeffs[78] = 0.0625599842287;  sh_coeffs[79] = 0.0812529816082;  sh_coeffs[80] = 0.0914693020772;  sh_coeffs[81] = -0.1197222726745;  sh_coeffs[82] = 0.0376277453183;  sh_coeffs[83] = -0.0832617004142;  sh_coeffs[84] = -0.0482175038043;  sh_coeffs[85] = -0.0839003635737;  sh_coeffs[86] = -0.0349423908400;  sh_coeffs[87] = 0.1204519568256;  sh_coeffs[88] = 0.0783745984003;  sh_coeffs[89] = 0.0297401205976;  sh_coeffs[90] = -0.0505947662525;\n#endif\n    // Perform the intersection test\n    float ray_params[MAX_DEGREE];\n    ray_sh_glyph_intersections(ray_params, sh_coeffs, camera_pos, ray_dir);\n    // Identify the first intersection\n    float first_ray_param = NO_INTERSECTION;\n    _unroll_\n    for (int i = 0; i != MAX_DEGREE; ++i) {\n        if (ray_params[i] != NO_INTERSECTION && ray_params[i] > 0.0) {\n            first_ray_param = ray_params[i];\n            break;\n        }\n    }\n    // Evaluate shading for a directional light\n    vec3 color = vec3(1.0);\n    if (first_ray_param != NO_INTERSECTION) {\n        vec3 intersection = camera_pos + first_ray_param * ray_dir;\n        vec3 normal = get_sh_glyph_normal(sh_coeffs, intersection);\n        vec3 base_color = srgb_to_linear_rgb(abs(normalize(intersection)));\n        const vec3 incoming = normalize(vec3(1.23, -4.56, 7.89));\n        float ambient = 0.04;\n        float exposure = 4.0;\n        vec3 outgoing = -ray_dir;\n        vec3 brdf = gltf_dielectric_brdf(incoming, outgoing, normal, 0.45, base_color);\n        color = exposure * (brdf * max(0.0, dot(incoming, normal)) + base_color * ambient);\n    }\n    out_color = vec4(linear_rgb_to_srgb(tonemap(color)), 1.0);\n}\n", "image_inputs": [], "common_code": "void eval_sh_2(out float out_shs[6], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n}\n\n\nvoid eval_sh_4(out float out_shs[15], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n}\n\n\nvoid eval_sh_6(out float out_shs[28], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n}\n\n\nvoid eval_sh_8(out float out_shs[45], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    b = z2 * a - 0.251748252 * b;\n    a = b - 0.251282051 * a;\n    d = 58.473368113 * a;\n    out_shs[36] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    a = z2 * b - 0.244755245 * a;\n    b = a - 0.246153846 * b;\n    d = -77.964490818 * b;\n    out_shs[35] = -c1 * d;\n    out_shs[37] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    b = z2 * a - 0.223776224 * b;\n    a = b - 0.230769231 * a;\n    d = 65.229772956 * a;\n    out_shs[34] = c0 * d;\n    out_shs[38] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    a = z2 * b - 0.188811189 * a;\n    b = a - 0.205128205 * b;\n    d = -48.175380057 * b;\n    out_shs[33] = -c1 * d;\n    out_shs[39] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    b = z2 * (a - 0.13986014);\n    a = b - 0.169230769 * a;\n    d = 31.097074109 * a;\n    out_shs[32] = c0 * d;\n    out_shs[40] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    a = (z2 - 7.69230769e-02) * z;\n    b = a - 0.123076923 * z;\n    d = -17.24955311 * b;\n    out_shs[31] = -c1 * d;\n    out_shs[41] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    a = z2 - 6.66666667e-02;\n    d = 7.984991491 * a;\n    out_shs[30] = c0 * d;\n    out_shs[42] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.915706641 * z;\n    out_shs[29] = -c1 * d;\n    out_shs[43] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.72892666;\n    out_shs[28] = c0 * d;\n    out_shs[44] = s0 * d;\n}\n\n\nvoid eval_sh_10(out float out_shs[66], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    b = z2 * a - 0.251748252 * b;\n    a = b - 0.251282051 * a;\n    d = 58.473368113 * a;\n    out_shs[36] = d;\n    b = z2 * a - 0.250980392 * b;\n    a = b - 0.250773994 * a;\n    d = 233.240148813 * a;\n    out_shs[55] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    a = z2 * b - 0.244755245 * a;\n    b = a - 0.246153846 * b;\n    d = -77.964490818 * b;\n    out_shs[35] = -c1 * d;\n    out_shs[37] = s1 * d;\n    a = z2 * b - 0.247058824 * a;\n    b = a - 0.247678019 * b;\n    d = -314.500952502 * b;\n    out_shs[54] = -c1 * d;\n    out_shs[56] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    b = z2 * a - 0.223776224 * b;\n    a = b - 0.230769231 * a;\n    d = 65.229772956 * a;\n    out_shs[34] = c0 * d;\n    out_shs[38] = s0 * d;\n    b = z2 * a - 0.235294118 * b;\n    a = b - 0.238390093 * a;\n    d = 272.365814381 * a;\n    out_shs[53] = c0 * d;\n    out_shs[57] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    a = z2 * b - 0.188811189 * a;\n    b = a - 0.205128205 * b;\n    d = -48.175380057 * b;\n    out_shs[33] = -c1 * d;\n    out_shs[39] = s1 * d;\n    a = z2 * b - 0.215686275 * a;\n    b = a - 0.222910217 * b;\n    d = -213.661323441 * b;\n    out_shs[52] = -c1 * d;\n    out_shs[58] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    b = z2 * (a - 0.13986014);\n    a = b - 0.169230769 * a;\n    d = 31.097074109 * a;\n    out_shs[32] = c0 * d;\n    out_shs[40] = s0 * d;\n    b = z2 * a - 0.188235294 * b;\n    a = b - 0.20123839 * a;\n    d = 151.081370682 * a;\n    out_shs[51] = c0 * d;\n    out_shs[59] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    a = (z2 - 7.69230769e-02) * z;\n    b = a - 0.123076923 * z;\n    d = -17.24955311 * b;\n    out_shs[31] = -c1 * d;\n    out_shs[41] = s1 * d;\n    a = z2 * b - 0.152941176 * a;\n    b = a - 0.173374613 * b;\n    d = -95.552248675 * b;\n    out_shs[50] = -c1 * d;\n    out_shs[60] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    a = z2 - 6.66666667e-02;\n    d = 7.984991491 * a;\n    out_shs[30] = c0 * d;\n    out_shs[42] = s0 * d;\n    b = z2 * (a - 0.109803922);\n    a = b - 0.139318885 * a;\n    d = 53.41533086 * a;\n    out_shs[49] = c0 * d;\n    out_shs[61] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.915706641 * z;\n    out_shs[29] = -c1 * d;\n    out_shs[43] = s1 * d;\n    a = (z2 - 5.88235294e-02) * z;\n    b = a - 9.90712074e-02 * z;\n    d = -25.910241313 * b;\n    out_shs[48] = -c1 * d;\n    out_shs[62] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.72892666;\n    out_shs[28] = c0 * d;\n    out_shs[44] = s0 * d;\n    a = z2 - 5.26315789e-02;\n    d = 10.577811722 * a;\n    out_shs[47] = c0 * d;\n    out_shs[63] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -3.4318953 * z;\n    out_shs[46] = -c1 * d;\n    out_shs[64] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.767395118;\n    out_shs[45] = c0 * d;\n    out_shs[65] = s0 * d;\n}\n\n\nvoid eval_sh_12(out float out_shs[91], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    b = z2 * a - 0.251748252 * b;\n    a = b - 0.251282051 * a;\n    d = 58.473368113 * a;\n    out_shs[36] = d;\n    b = z2 * a - 0.250980392 * b;\n    a = b - 0.250773994 * a;\n    d = 233.240148813 * a;\n    out_shs[55] = d;\n    b = z2 * a - 0.250626566 * b;\n    a = b - 0.250517598 * a;\n    d = 931.186918633 * a;\n    out_shs[78] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    a = z2 * b - 0.244755245 * a;\n    b = a - 0.246153846 * b;\n    d = -77.964490818 * b;\n    out_shs[35] = -c1 * d;\n    out_shs[37] = s1 * d;\n    a = z2 * b - 0.247058824 * a;\n    b = a - 0.247678019 * b;\n    d = -314.500952502 * b;\n    out_shs[54] = -c1 * d;\n    out_shs[56] = s1 * d;\n    a = z2 * b - 0.248120301 * a;\n    b = a - 0.248447205 * b;\n    d = -1265.233874957 * b;\n    out_shs[77] = -c1 * d;\n    out_shs[79] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    b = z2 * a - 0.223776224 * b;\n    a = b - 0.230769231 * a;\n    d = 65.229772956 * a;\n    out_shs[34] = c0 * d;\n    out_shs[38] = s0 * d;\n    b = z2 * a - 0.235294118 * b;\n    a = b - 0.238390093 * a;\n    d = 272.365814381 * a;\n    out_shs[53] = c0 * d;\n    out_shs[57] = s0 * d;\n    b = z2 * a - 0.240601504 * b;\n    a = b - 0.242236025 * a;\n    d = 1121.509962433 * a;\n    out_shs[76] = c0 * d;\n    out_shs[80] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    a = z2 * b - 0.188811189 * a;\n    b = a - 0.205128205 * b;\n    d = -48.175380057 * b;\n    out_shs[33] = -c1 * d;\n    out_shs[39] = s1 * d;\n    a = z2 * b - 0.215686275 * a;\n    b = a - 0.222910217 * b;\n    d = -213.661323441 * b;\n    out_shs[52] = -c1 * d;\n    out_shs[58] = s1 * d;\n    a = z2 * b - 0.228070175 * a;\n    b = a - 0.231884058 * b;\n    d = -915.709049803 * b;\n    out_shs[75] = -c1 * d;\n    out_shs[81] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    b = z2 * (a - 0.13986014);\n    a = b - 0.169230769 * a;\n    d = 31.097074109 * a;\n    out_shs[32] = c0 * d;\n    out_shs[40] = s0 * d;\n    b = z2 * a - 0.188235294 * b;\n    a = b - 0.20123839 * a;\n    d = 151.081370682 * a;\n    out_shs[51] = c0 * d;\n    out_shs[59] = s0 * d;\n    b = z2 * a - 0.210526316 * b;\n    a = b - 0.217391304 * a;\n    d = 686.781787352 * a;\n    out_shs[74] = c0 * d;\n    out_shs[82] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    a = (z2 - 7.69230769e-02) * z;\n    b = a - 0.123076923 * z;\n    d = -17.24955311 * b;\n    out_shs[31] = -c1 * d;\n    out_shs[41] = s1 * d;\n    a = z2 * b - 0.152941176 * a;\n    b = a - 0.173374613 * b;\n    d = -95.552248675 * b;\n    out_shs[50] = -c1 * d;\n    out_shs[60] = s1 * d;\n    a = z2 * b - 0.187969925 * a;\n    b = a - 0.198757764 * b;\n    d = -471.12841933 * b;\n    out_shs[73] = -c1 * d;\n    out_shs[83] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    a = z2 - 6.66666667e-02;\n    d = 7.984991491 * a;\n    out_shs[30] = c0 * d;\n    out_shs[42] = s0 * d;\n    b = z2 * (a - 0.109803922);\n    a = b - 0.139318885 * a;\n    d = 53.41533086 * a;\n    out_shs[49] = c0 * d;\n    out_shs[61] = s0 * d;\n    b = z2 * a - 0.160401003 * b;\n    a = b - 0.175983437 * a;\n    d = 293.800188384 * a;\n    out_shs[72] = c0 * d;\n    out_shs[84] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.915706641 * z;\n    out_shs[29] = -c1 * d;\n    out_shs[43] = s1 * d;\n    a = (z2 - 5.88235294e-02) * z;\n    b = a - 9.90712074e-02 * z;\n    d = -25.910241313 * b;\n    out_shs[48] = -c1 * d;\n    out_shs[62] = s1 * d;\n    a = z2 * b - 0.127819549 * a;\n    b = a - 0.149068323 * b;\n    d = -165.101452729 * b;\n    out_shs[71] = -c1 * d;\n    out_shs[85] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.72892666;\n    out_shs[28] = c0 * d;\n    out_shs[44] = s0 * d;\n    a = z2 - 5.26315789e-02;\n    d = 10.577811722 * a;\n    out_shs[47] = c0 * d;\n    out_shs[63] = s0 * d;\n    b = z2 * (a - 9.02255639e-02);\n    a = b - 0.118012422 * a;\n    d = 82.550726364 * a;\n    out_shs[70] = c0 * d;\n    out_shs[86] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -3.4318953 * z;\n    out_shs[46] = -c1 * d;\n    out_shs[64] = s1 * d;\n    a = (z2 - 4.76190476e-02) * z;\n    b = a - 8.2815735e-02 * z;\n    d = -36.028090689 * b;\n    out_shs[69] = -c1 * d;\n    out_shs[87] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.767395118;\n    out_shs[45] = c0 * d;\n    out_shs[65] = s0 * d;\n    a = z2 - 4.34782609e-02;\n    d = 13.3042542 * a;\n    out_shs[68] = c0 * d;\n    out_shs[88] = s0 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -3.923210529 * z;\n    out_shs[67] = -c1 * d;\n    out_shs[89] = s1 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.800821996;\n    out_shs[66] = c0 * d;\n    out_shs[90] = s0 * d;\n}\n\n\nvoid eval_sh_grad_2(out float out_shs[6], out vec3 out_grads[6], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    c0 = 1.0;\n    s0 = 0.0;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    out_grads[2][0] = -c0 * d;\n    out_grads[4][0] = s0 * d;\n    out_grads[2][1] = s0 * d;\n    out_grads[4][1] = c0 * d;\n    d = 1.892349392 * z;\n    out_grads[3][2] = d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    d = 1.092548431;\n    out_grads[1][0] = c1 * d;\n    out_grads[5][0] = s1 * d;\n    out_grads[1][1] = -s1 * d;\n    out_grads[5][1] = c1 * d;\n    d = -1.092548431;\n    out_grads[2][2] = -c1 * d;\n    out_grads[4][2] = s1 * d;\n    out_grads[0][0] = 0.0;\n    out_grads[0][1] = 0.0;\n    out_grads[0][2] = 0.0;\n    out_grads[1][2] = 0.0;\n    out_grads[3][0] = 0.0;\n    out_grads[3][1] = 0.0;\n    out_grads[5][2] = 0.0;\n}\n\n\nvoid eval_sh_grad_4(out float out_shs[15], out vec3 out_grads[15], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    c0 = 1.0;\n    s0 = 0.0;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    out_grads[2][0] = -c0 * d;\n    out_grads[4][0] = s0 * d;\n    out_grads[2][1] = s0 * d;\n    out_grads[4][1] = c0 * d;\n    d = 1.892349392 * z;\n    out_grads[3][2] = d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    out_grads[9][0] = -c0 * d;\n    out_grads[11][0] = s0 * d;\n    out_grads[9][1] = s0 * d;\n    out_grads[11][1] = c0 * d;\n    d = 14.809976568 * b;\n    out_grads[10][2] = d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    d = 1.092548431;\n    out_grads[1][0] = c1 * d;\n    out_grads[5][0] = s1 * d;\n    out_grads[1][1] = -s1 * d;\n    out_grads[5][1] = c1 * d;\n    d = -1.092548431;\n    out_grads[2][2] = -c1 * d;\n    out_grads[4][2] = s1 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    d = 6.62322287 * a;\n    out_grads[8][0] = c1 * d;\n    out_grads[12][0] = s1 * d;\n    out_grads[8][1] = -s1 * d;\n    out_grads[12][1] = c1 * d;\n    d = -14.049977415 * a;\n    out_grads[9][2] = -c1 * d;\n    out_grads[11][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    d = -5.310392309 * z;\n    out_grads[7][0] = -c0 * d;\n    out_grads[13][0] = s0 * d;\n    out_grads[7][1] = s0 * d;\n    out_grads[13][1] = c0 * d;\n    d = 6.62322287 * z;\n    out_grads[8][2] = c0 * d;\n    out_grads[12][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    d = 2.503342942;\n    out_grads[6][0] = c1 * d;\n    out_grads[14][0] = s1 * d;\n    out_grads[6][1] = -s1 * d;\n    out_grads[14][1] = c1 * d;\n    d = -1.77013077;\n    out_grads[7][2] = -c1 * d;\n    out_grads[13][2] = s1 * d;\n    out_grads[0][0] = 0.0;\n    out_grads[0][1] = 0.0;\n    out_grads[0][2] = 0.0;\n    out_grads[1][2] = 0.0;\n    out_grads[3][0] = 0.0;\n    out_grads[3][1] = 0.0;\n    out_grads[5][2] = 0.0;\n    out_grads[6][2] = 0.0;\n    out_grads[10][0] = 0.0;\n    out_grads[10][1] = 0.0;\n    out_grads[14][2] = 0.0;\n}\n\n\nvoid eval_sh_grad_6(out float out_shs[28], out vec3 out_grads[28], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    c0 = 1.0;\n    s0 = 0.0;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    out_grads[2][0] = -c0 * d;\n    out_grads[4][0] = s0 * d;\n    out_grads[2][1] = s0 * d;\n    out_grads[4][1] = c0 * d;\n    d = 1.892349392 * z;\n    out_grads[3][2] = d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    out_grads[9][0] = -c0 * d;\n    out_grads[11][0] = s0 * d;\n    out_grads[9][1] = s0 * d;\n    out_grads[11][1] = c0 * d;\n    d = 14.809976568 * b;\n    out_grads[10][2] = d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    out_grads[20][0] = -c0 * d;\n    out_grads[22][0] = s0 * d;\n    out_grads[20][1] = s0 * d;\n    out_grads[22][1] = c0 * d;\n    d = 88.106914343 * b;\n    out_grads[21][2] = d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    d = 1.092548431;\n    out_grads[1][0] = c1 * d;\n    out_grads[5][0] = s1 * d;\n    out_grads[1][1] = -s1 * d;\n    out_grads[5][1] = c1 * d;\n    d = -1.092548431;\n    out_grads[2][2] = -c1 * d;\n    out_grads[4][2] = s1 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    d = 6.62322287 * a;\n    out_grads[8][0] = c1 * d;\n    out_grads[12][0] = s1 * d;\n    out_grads[8][1] = -s1 * d;\n    out_grads[12][1] = c1 * d;\n    d = -14.049977415 * a;\n    out_grads[9][2] = -c1 * d;\n    out_grads[11][2] = s1 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    d = 30.399773564 * a;\n    out_grads[19][0] = c1 * d;\n    out_grads[23][0] = s1 * d;\n    out_grads[19][1] = -s1 * d;\n    out_grads[23][1] = c1 * d;\n    d = -96.132524816 * a;\n    out_grads[20][2] = -c1 * d;\n    out_grads[22][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    d = -5.310392309 * z;\n    out_grads[7][0] = -c0 * d;\n    out_grads[13][0] = s0 * d;\n    out_grads[7][1] = s0 * d;\n    out_grads[13][1] = c0 * d;\n    d = 6.62322287 * z;\n    out_grads[8][2] = c0 * d;\n    out_grads[12][2] = s0 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    d = -30.399773564 * b;\n    out_grads[18][0] = -c0 * d;\n    out_grads[24][0] = s0 * d;\n    out_grads[18][1] = s0 * d;\n    out_grads[24][1] = c0 * d;\n    d = 60.799547128 * b;\n    out_grads[19][2] = c0 * d;\n    out_grads[23][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    d = 2.503342942;\n    out_grads[6][0] = c1 * d;\n    out_grads[14][0] = s1 * d;\n    out_grads[6][1] = -s1 * d;\n    out_grads[14][1] = c1 * d;\n    d = -1.77013077;\n    out_grads[7][2] = -c1 * d;\n    out_grads[13][2] = s1 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    d = 22.200855632 * a;\n    out_grads[17][0] = c1 * d;\n    out_grads[25][0] = s1 * d;\n    out_grads[17][1] = -s1 * d;\n    out_grads[25][1] = c1 * d;\n    d = -30.399773564 * a;\n    out_grads[18][2] = -c1 * d;\n    out_grads[24][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    d = -11.833095811 * z;\n    out_grads[16][0] = -c0 * d;\n    out_grads[26][0] = s0 * d;\n    out_grads[16][1] = s0 * d;\n    out_grads[26][1] = c0 * d;\n    d = 11.100427816 * z;\n    out_grads[17][2] = c0 * d;\n    out_grads[25][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    d = 4.099104631;\n    out_grads[15][0] = c1 * d;\n    out_grads[27][0] = s1 * d;\n    out_grads[15][1] = -s1 * d;\n    out_grads[27][1] = c1 * d;\n    d = -2.366619162;\n    out_grads[16][2] = -c1 * d;\n    out_grads[26][2] = s1 * d;\n    out_grads[0][0] = 0.0;\n    out_grads[0][1] = 0.0;\n    out_grads[0][2] = 0.0;\n    out_grads[1][2] = 0.0;\n    out_grads[3][0] = 0.0;\n    out_grads[3][1] = 0.0;\n    out_grads[5][2] = 0.0;\n    out_grads[6][2] = 0.0;\n    out_grads[10][0] = 0.0;\n    out_grads[10][1] = 0.0;\n    out_grads[14][2] = 0.0;\n    out_grads[15][2] = 0.0;\n    out_grads[21][0] = 0.0;\n    out_grads[21][1] = 0.0;\n    out_grads[27][2] = 0.0;\n}\n\n\nvoid eval_sh_grad_8(out float out_shs[45], out vec3 out_grads[45], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    c0 = 1.0;\n    s0 = 0.0;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    b = z2 * a - 0.251748252 * b;\n    a = b - 0.251282051 * a;\n    d = 58.473368113 * a;\n    out_shs[36] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    out_grads[2][0] = -c0 * d;\n    out_grads[4][0] = s0 * d;\n    out_grads[2][1] = s0 * d;\n    out_grads[4][1] = c0 * d;\n    d = 1.892349392 * z;\n    out_grads[3][2] = d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    out_grads[9][0] = -c0 * d;\n    out_grads[11][0] = s0 * d;\n    out_grads[9][1] = s0 * d;\n    out_grads[11][1] = c0 * d;\n    d = 14.809976568 * b;\n    out_grads[10][2] = d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    out_grads[20][0] = -c0 * d;\n    out_grads[22][0] = s0 * d;\n    out_grads[20][1] = s0 * d;\n    out_grads[22][1] = c0 * d;\n    d = 88.106914343 * b;\n    out_grads[21][2] = d;\n    a = z2 * b - 0.244755245 * a;\n    b = a - 0.246153846 * b;\n    d = -77.964490818 * b;\n    out_shs[35] = -c1 * d;\n    out_shs[37] = s1 * d;\n    out_grads[35][0] = -c0 * d;\n    out_grads[37][0] = s0 * d;\n    out_grads[35][1] = s0 * d;\n    out_grads[37][1] = c0 * d;\n    d = 467.786944906 * b;\n    out_grads[36][2] = d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    d = 1.092548431;\n    out_grads[1][0] = c1 * d;\n    out_grads[5][0] = s1 * d;\n    out_grads[1][1] = -s1 * d;\n    out_grads[5][1] = c1 * d;\n    d = -1.092548431;\n    out_grads[2][2] = -c1 * d;\n    out_grads[4][2] = s1 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    d = 6.62322287 * a;\n    out_grads[8][0] = c1 * d;\n    out_grads[12][0] = s1 * d;\n    out_grads[8][1] = -s1 * d;\n    out_grads[12][1] = c1 * d;\n    d = -14.049977415 * a;\n    out_grads[9][2] = -c1 * d;\n    out_grads[11][2] = s1 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    d = 30.399773564 * a;\n    out_grads[19][0] = c1 * d;\n    out_grads[23][0] = s1 * d;\n    out_grads[19][1] = -s1 * d;\n    out_grads[23][1] = c1 * d;\n    d = -96.132524816 * a;\n    out_grads[20][2] = -c1 * d;\n    out_grads[22][2] = s1 * d;\n    b = z2 * a - 0.223776224 * b;\n    a = b - 0.230769231 * a;\n    d = 65.229772956 * a;\n    out_shs[34] = c0 * d;\n    out_shs[38] = s0 * d;\n    d = 130.459545912 * a;\n    out_grads[34][0] = c1 * d;\n    out_grads[38][0] = s1 * d;\n    out_grads[34][1] = -s1 * d;\n    out_grads[38][1] = c1 * d;\n    d = -545.751435723 * a;\n    out_grads[35][2] = -c1 * d;\n    out_grads[37][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    d = -5.310392309 * z;\n    out_grads[7][0] = -c0 * d;\n    out_grads[13][0] = s0 * d;\n    out_grads[7][1] = s0 * d;\n    out_grads[13][1] = c0 * d;\n    d = 6.62322287 * z;\n    out_grads[8][2] = c0 * d;\n    out_grads[12][2] = s0 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    d = -30.399773564 * b;\n    out_grads[18][0] = -c0 * d;\n    out_grads[24][0] = s0 * d;\n    out_grads[18][1] = s0 * d;\n    out_grads[24][1] = c0 * d;\n    d = 60.799547128 * b;\n    out_grads[19][2] = c0 * d;\n    out_grads[23][2] = s0 * d;\n    a = z2 * b - 0.188811189 * a;\n    b = a - 0.205128205 * b;\n    d = -48.175380057 * b;\n    out_shs[33] = -c1 * d;\n    out_shs[39] = s1 * d;\n    d = -144.52614017 * b;\n    out_grads[33][0] = -c0 * d;\n    out_grads[39][0] = s0 * d;\n    out_grads[33][1] = s0 * d;\n    out_grads[39][1] = c0 * d;\n    d = 391.378637737 * b;\n    out_grads[34][2] = c0 * d;\n    out_grads[38][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    d = 2.503342942;\n    out_grads[6][0] = c1 * d;\n    out_grads[14][0] = s1 * d;\n    out_grads[6][1] = -s1 * d;\n    out_grads[14][1] = c1 * d;\n    d = -1.77013077;\n    out_grads[7][2] = -c1 * d;\n    out_grads[13][2] = s1 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    d = 22.200855632 * a;\n    out_grads[17][0] = c1 * d;\n    out_grads[25][0] = s1 * d;\n    out_grads[17][1] = -s1 * d;\n    out_grads[25][1] = c1 * d;\n    d = -30.399773564 * a;\n    out_grads[18][2] = -c1 * d;\n    out_grads[24][2] = s1 * d;\n    b = z2 * (a - 0.13986014);\n    a = b - 0.169230769 * a;\n    d = 31.097074109 * a;\n    out_shs[32] = c0 * d;\n    out_shs[40] = s0 * d;\n    d = 124.388296437 * a;\n    out_grads[32][0] = c1 * d;\n    out_grads[40][0] = s1 * d;\n    out_grads[32][1] = -s1 * d;\n    out_grads[40][1] = c1 * d;\n    d = -240.876900283 * a;\n    out_grads[33][2] = -c1 * d;\n    out_grads[39][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    d = -11.833095811 * z;\n    out_grads[16][0] = -c0 * d;\n    out_grads[26][0] = s0 * d;\n    out_grads[16][1] = s0 * d;\n    out_grads[26][1] = c0 * d;\n    d = 11.100427816 * z;\n    out_grads[17][2] = c0 * d;\n    out_grads[25][2] = s0 * d;\n    a = (z2 - 7.69230769e-02) * z;\n    b = a - 0.123076923 * z;\n    d = -17.24955311 * b;\n    out_shs[31] = -c1 * d;\n    out_shs[41] = s1 * d;\n    d = -86.247765552 * b;\n    out_grads[31][0] = -c0 * d;\n    out_grads[41][0] = s0 * d;\n    out_grads[31][1] = s0 * d;\n    out_grads[41][1] = c0 * d;\n    d = 124.388296437 * b;\n    out_grads[32][2] = c0 * d;\n    out_grads[40][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    d = 4.099104631;\n    out_grads[15][0] = c1 * d;\n    out_grads[27][0] = s1 * d;\n    out_grads[15][1] = -s1 * d;\n    out_grads[27][1] = c1 * d;\n    d = -2.366619162;\n    out_grads[16][2] = -c1 * d;\n    out_grads[26][2] = s1 * d;\n    a = z2 - 6.66666667e-02;\n    d = 7.984991491 * a;\n    out_shs[30] = c0 * d;\n    out_shs[42] = s0 * d;\n    d = 47.909948945 * a;\n    out_grads[30][0] = c1 * d;\n    out_grads[42][0] = s1 * d;\n    out_grads[30][1] = -s1 * d;\n    out_grads[42][1] = c1 * d;\n    d = -51.748659331 * a;\n    out_grads[31][2] = -c1 * d;\n    out_grads[41][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.915706641 * z;\n    out_shs[29] = -c1 * d;\n    out_shs[43] = s1 * d;\n    d = -20.409946485 * z;\n    out_grads[29][0] = -c0 * d;\n    out_grads[43][0] = s0 * d;\n    out_grads[29][1] = s0 * d;\n    out_grads[43][1] = c0 * d;\n    d = 15.969982982 * z;\n    out_grads[30][2] = c0 * d;\n    out_grads[42][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.72892666;\n    out_shs[28] = c0 * d;\n    out_shs[44] = s0 * d;\n    d = 5.831413281;\n    out_grads[28][0] = c1 * d;\n    out_grads[44][0] = s1 * d;\n    out_grads[28][1] = -s1 * d;\n    out_grads[44][1] = c1 * d;\n    d = -2.915706641;\n    out_grads[29][2] = -c1 * d;\n    out_grads[43][2] = s1 * d;\n    out_grads[0][0] = 0.0;\n    out_grads[0][1] = 0.0;\n    out_grads[0][2] = 0.0;\n    out_grads[1][2] = 0.0;\n    out_grads[3][0] = 0.0;\n    out_grads[3][1] = 0.0;\n    out_grads[5][2] = 0.0;\n    out_grads[6][2] = 0.0;\n    out_grads[10][0] = 0.0;\n    out_grads[10][1] = 0.0;\n    out_grads[14][2] = 0.0;\n    out_grads[15][2] = 0.0;\n    out_grads[21][0] = 0.0;\n    out_grads[21][1] = 0.0;\n    out_grads[27][2] = 0.0;\n    out_grads[28][2] = 0.0;\n    out_grads[36][0] = 0.0;\n    out_grads[36][1] = 0.0;\n    out_grads[44][2] = 0.0;\n}\n\n\nvoid eval_sh_grad_10(out float out_shs[66], out vec3 out_grads[66], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    c0 = 1.0;\n    s0 = 0.0;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    b = z2 * a - 0.251748252 * b;\n    a = b - 0.251282051 * a;\n    d = 58.473368113 * a;\n    out_shs[36] = d;\n    b = z2 * a - 0.250980392 * b;\n    a = b - 0.250773994 * a;\n    d = 233.240148813 * a;\n    out_shs[55] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    out_grads[2][0] = -c0 * d;\n    out_grads[4][0] = s0 * d;\n    out_grads[2][1] = s0 * d;\n    out_grads[4][1] = c0 * d;\n    d = 1.892349392 * z;\n    out_grads[3][2] = d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    out_grads[9][0] = -c0 * d;\n    out_grads[11][0] = s0 * d;\n    out_grads[9][1] = s0 * d;\n    out_grads[11][1] = c0 * d;\n    d = 14.809976568 * b;\n    out_grads[10][2] = d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    out_grads[20][0] = -c0 * d;\n    out_grads[22][0] = s0 * d;\n    out_grads[20][1] = s0 * d;\n    out_grads[22][1] = c0 * d;\n    d = 88.106914343 * b;\n    out_grads[21][2] = d;\n    a = z2 * b - 0.244755245 * a;\n    b = a - 0.246153846 * b;\n    d = -77.964490818 * b;\n    out_shs[35] = -c1 * d;\n    out_shs[37] = s1 * d;\n    out_grads[35][0] = -c0 * d;\n    out_grads[37][0] = s0 * d;\n    out_grads[35][1] = s0 * d;\n    out_grads[37][1] = c0 * d;\n    d = 467.786944906 * b;\n    out_grads[36][2] = d;\n    a = z2 * b - 0.247058824 * a;\n    b = a - 0.247678019 * b;\n    d = -314.500952502 * b;\n    out_shs[54] = -c1 * d;\n    out_shs[56] = s1 * d;\n    out_grads[54][0] = -c0 * d;\n    out_grads[56][0] = s0 * d;\n    out_grads[54][1] = s0 * d;\n    out_grads[56][1] = c0 * d;\n    d = 2332.401488133 * b;\n    out_grads[55][2] = d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    d = 1.092548431;\n    out_grads[1][0] = c1 * d;\n    out_grads[5][0] = s1 * d;\n    out_grads[1][1] = -s1 * d;\n    out_grads[5][1] = c1 * d;\n    d = -1.092548431;\n    out_grads[2][2] = -c1 * d;\n    out_grads[4][2] = s1 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    d = 6.62322287 * a;\n    out_grads[8][0] = c1 * d;\n    out_grads[12][0] = s1 * d;\n    out_grads[8][1] = -s1 * d;\n    out_grads[12][1] = c1 * d;\n    d = -14.049977415 * a;\n    out_grads[9][2] = -c1 * d;\n    out_grads[11][2] = s1 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    d = 30.399773564 * a;\n    out_grads[19][0] = c1 * d;\n    out_grads[23][0] = s1 * d;\n    out_grads[19][1] = -s1 * d;\n    out_grads[23][1] = c1 * d;\n    d = -96.132524816 * a;\n    out_grads[20][2] = -c1 * d;\n    out_grads[22][2] = s1 * d;\n    b = z2 * a - 0.223776224 * b;\n    a = b - 0.230769231 * a;\n    d = 65.229772956 * a;\n    out_shs[34] = c0 * d;\n    out_shs[38] = s0 * d;\n    d = 130.459545912 * a;\n    out_grads[34][0] = c1 * d;\n    out_grads[38][0] = s1 * d;\n    out_grads[34][1] = -s1 * d;\n    out_grads[38][1] = c1 * d;\n    d = -545.751435723 * a;\n    out_grads[35][2] = -c1 * d;\n    out_grads[37][2] = s1 * d;\n    b = z2 * a - 0.235294118 * b;\n    a = b - 0.238390093 * a;\n    d = 272.365814381 * a;\n    out_shs[53] = c0 * d;\n    out_shs[57] = s0 * d;\n    d = 544.731628762 * a;\n    out_grads[53][0] = c1 * d;\n    out_grads[57][0] = s1 * d;\n    out_grads[53][1] = -s1 * d;\n    out_grads[57][1] = c1 * d;\n    d = -2830.508572514 * a;\n    out_grads[54][2] = -c1 * d;\n    out_grads[56][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    d = -5.310392309 * z;\n    out_grads[7][0] = -c0 * d;\n    out_grads[13][0] = s0 * d;\n    out_grads[7][1] = s0 * d;\n    out_grads[13][1] = c0 * d;\n    d = 6.62322287 * z;\n    out_grads[8][2] = c0 * d;\n    out_grads[12][2] = s0 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    d = -30.399773564 * b;\n    out_grads[18][0] = -c0 * d;\n    out_grads[24][0] = s0 * d;\n    out_grads[18][1] = s0 * d;\n    out_grads[24][1] = c0 * d;\n    d = 60.799547128 * b;\n    out_grads[19][2] = c0 * d;\n    out_grads[23][2] = s0 * d;\n    a = z2 * b - 0.188811189 * a;\n    b = a - 0.205128205 * b;\n    d = -48.175380057 * b;\n    out_shs[33] = -c1 * d;\n    out_shs[39] = s1 * d;\n    d = -144.52614017 * b;\n    out_grads[33][0] = -c0 * d;\n    out_grads[39][0] = s0 * d;\n    out_grads[33][1] = s0 * d;\n    out_grads[39][1] = c0 * d;\n    d = 391.378637737 * b;\n    out_grads[34][2] = c0 * d;\n    out_grads[38][2] = s0 * d;\n    a = z2 * b - 0.215686275 * a;\n    b = a - 0.222910217 * b;\n    d = -213.661323441 * b;\n    out_shs[52] = -c1 * d;\n    out_shs[58] = s1 * d;\n    d = -640.983970322 * b;\n    out_grads[52][0] = -c0 * d;\n    out_grads[58][0] = s0 * d;\n    out_grads[52][1] = s0 * d;\n    out_grads[58][1] = c0 * d;\n    d = 2178.926515046 * b;\n    out_grads[53][2] = c0 * d;\n    out_grads[57][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    d = 2.503342942;\n    out_grads[6][0] = c1 * d;\n    out_grads[14][0] = s1 * d;\n    out_grads[6][1] = -s1 * d;\n    out_grads[14][1] = c1 * d;\n    d = -1.77013077;\n    out_grads[7][2] = -c1 * d;\n    out_grads[13][2] = s1 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    d = 22.200855632 * a;\n    out_grads[17][0] = c1 * d;\n    out_grads[25][0] = s1 * d;\n    out_grads[17][1] = -s1 * d;\n    out_grads[25][1] = c1 * d;\n    d = -30.399773564 * a;\n    out_grads[18][2] = -c1 * d;\n    out_grads[24][2] = s1 * d;\n    b = z2 * (a - 0.13986014);\n    a = b - 0.169230769 * a;\n    d = 31.097074109 * a;\n    out_shs[32] = c0 * d;\n    out_shs[40] = s0 * d;\n    d = 124.388296437 * a;\n    out_grads[32][0] = c1 * d;\n    out_grads[40][0] = s1 * d;\n    out_grads[32][1] = -s1 * d;\n    out_grads[40][1] = c1 * d;\n    d = -240.876900283 * a;\n    out_grads[33][2] = -c1 * d;\n    out_grads[39][2] = s1 * d;\n    b = z2 * a - 0.188235294 * b;\n    a = b - 0.20123839 * a;\n    d = 151.081370682 * a;\n    out_shs[51] = c0 * d;\n    out_shs[59] = s0 * d;\n    d = 604.325482728 * a;\n    out_grads[51][0] = c1 * d;\n    out_grads[59][0] = s1 * d;\n    out_grads[51][1] = -s1 * d;\n    out_grads[59][1] = c1 * d;\n    d = -1495.629264084 * a;\n    out_grads[52][2] = -c1 * d;\n    out_grads[58][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    d = -11.833095811 * z;\n    out_grads[16][0] = -c0 * d;\n    out_grads[26][0] = s0 * d;\n    out_grads[16][1] = s0 * d;\n    out_grads[26][1] = c0 * d;\n    d = 11.100427816 * z;\n    out_grads[17][2] = c0 * d;\n    out_grads[25][2] = s0 * d;\n    a = (z2 - 7.69230769e-02) * z;\n    b = a - 0.123076923 * z;\n    d = -17.24955311 * b;\n    out_shs[31] = -c1 * d;\n    out_shs[41] = s1 * d;\n    d = -86.247765552 * b;\n    out_grads[31][0] = -c0 * d;\n    out_grads[41][0] = s0 * d;\n    out_grads[31][1] = s0 * d;\n    out_grads[41][1] = c0 * d;\n    d = 124.388296437 * b;\n    out_grads[32][2] = c0 * d;\n    out_grads[40][2] = s0 * d;\n    a = z2 * b - 0.152941176 * a;\n    b = a - 0.173374613 * b;\n    d = -95.552248675 * b;\n    out_shs[50] = -c1 * d;\n    out_shs[60] = s1 * d;\n    d = -477.761243376 * b;\n    out_grads[50][0] = -c0 * d;\n    out_grads[60][0] = s0 * d;\n    out_grads[50][1] = s0 * d;\n    out_grads[60][1] = c0 * d;\n    d = 906.488224092 * b;\n    out_grads[51][2] = c0 * d;\n    out_grads[59][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    d = 4.099104631;\n    out_grads[15][0] = c1 * d;\n    out_grads[27][0] = s1 * d;\n    out_grads[15][1] = -s1 * d;\n    out_grads[27][1] = c1 * d;\n    d = -2.366619162;\n    out_grads[16][2] = -c1 * d;\n    out_grads[26][2] = s1 * d;\n    a = z2 - 6.66666667e-02;\n    d = 7.984991491 * a;\n    out_shs[30] = c0 * d;\n    out_shs[42] = s0 * d;\n    d = 47.909948945 * a;\n    out_grads[30][0] = c1 * d;\n    out_grads[42][0] = s1 * d;\n    out_grads[30][1] = -s1 * d;\n    out_grads[42][1] = c1 * d;\n    d = -51.748659331 * a;\n    out_grads[31][2] = -c1 * d;\n    out_grads[41][2] = s1 * d;\n    b = z2 * (a - 0.109803922);\n    a = b - 0.139318885 * a;\n    d = 53.41533086 * a;\n    out_shs[49] = c0 * d;\n    out_shs[61] = s0 * d;\n    d = 320.491985161 * a;\n    out_grads[49][0] = c1 * d;\n    out_grads[61][0] = s1 * d;\n    out_grads[49][1] = -s1 * d;\n    out_grads[61][1] = c1 * d;\n    d = -477.761243376 * a;\n    out_grads[50][2] = -c1 * d;\n    out_grads[60][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.915706641 * z;\n    out_shs[29] = -c1 * d;\n    out_shs[43] = s1 * d;\n    d = -20.409946485 * z;\n    out_grads[29][0] = -c0 * d;\n    out_grads[43][0] = s0 * d;\n    out_grads[29][1] = s0 * d;\n    out_grads[43][1] = c0 * d;\n    d = 15.969982982 * z;\n    out_grads[30][2] = c0 * d;\n    out_grads[42][2] = s0 * d;\n    a = (z2 - 5.88235294e-02) * z;\n    b = a - 9.90712074e-02 * z;\n    d = -25.910241313 * b;\n    out_shs[48] = -c1 * d;\n    out_shs[62] = s1 * d;\n    d = -181.371689194 * b;\n    out_grads[48][0] = -c0 * d;\n    out_grads[62][0] = s0 * d;\n    out_grads[48][1] = s0 * d;\n    out_grads[62][1] = c0 * d;\n    d = 213.661323441 * b;\n    out_grads[49][2] = c0 * d;\n    out_grads[61][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.72892666;\n    out_shs[28] = c0 * d;\n    out_shs[44] = s0 * d;\n    d = 5.831413281;\n    out_grads[28][0] = c1 * d;\n    out_grads[44][0] = s1 * d;\n    out_grads[28][1] = -s1 * d;\n    out_grads[44][1] = c1 * d;\n    d = -2.915706641;\n    out_grads[29][2] = -c1 * d;\n    out_grads[43][2] = s1 * d;\n    a = z2 - 5.26315789e-02;\n    d = 10.577811722 * a;\n    out_shs[47] = c0 * d;\n    out_shs[63] = s0 * d;\n    d = 84.622493774 * a;\n    out_grads[47][0] = c1 * d;\n    out_grads[63][0] = s1 * d;\n    out_grads[47][1] = -s1 * d;\n    out_grads[63][1] = c1 * d;\n    d = -77.73072394 * a;\n    out_grads[48][2] = -c1 * d;\n    out_grads[62][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -3.4318953 * z;\n    out_shs[46] = -c1 * d;\n    out_shs[64] = s1 * d;\n    d = -30.887057699 * z;\n    out_grads[46][0] = -c0 * d;\n    out_grads[64][0] = s0 * d;\n    out_grads[46][1] = s0 * d;\n    out_grads[64][1] = c0 * d;\n    d = 21.155623443 * z;\n    out_grads[47][2] = c0 * d;\n    out_grads[63][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.767395118;\n    out_shs[45] = c0 * d;\n    out_shs[65] = s0 * d;\n    d = 7.673951182;\n    out_grads[45][0] = c1 * d;\n    out_grads[65][0] = s1 * d;\n    out_grads[45][1] = -s1 * d;\n    out_grads[65][1] = c1 * d;\n    d = -3.4318953;\n    out_grads[46][2] = -c1 * d;\n    out_grads[64][2] = s1 * d;\n    out_grads[0][0] = 0.0;\n    out_grads[0][1] = 0.0;\n    out_grads[0][2] = 0.0;\n    out_grads[1][2] = 0.0;\n    out_grads[3][0] = 0.0;\n    out_grads[3][1] = 0.0;\n    out_grads[5][2] = 0.0;\n    out_grads[6][2] = 0.0;\n    out_grads[10][0] = 0.0;\n    out_grads[10][1] = 0.0;\n    out_grads[14][2] = 0.0;\n    out_grads[15][2] = 0.0;\n    out_grads[21][0] = 0.0;\n    out_grads[21][1] = 0.0;\n    out_grads[27][2] = 0.0;\n    out_grads[28][2] = 0.0;\n    out_grads[36][0] = 0.0;\n    out_grads[36][1] = 0.0;\n    out_grads[44][2] = 0.0;\n    out_grads[45][2] = 0.0;\n    out_grads[55][0] = 0.0;\n    out_grads[55][1] = 0.0;\n    out_grads[65][2] = 0.0;\n}\n\n\nvoid eval_sh_grad_12(out float out_shs[91], out vec3 out_grads[91], vec3 point) {\n    float x, y, z, z2, c0, s0, c1, s1, d, a, b;\n    x = point[0];\n    y = point[1];\n    z = point[2];\n    z2 = z * z;\n    c0 = 1.0;\n    s0 = 0.0;\n    d = 0.282094792;\n    out_shs[0] = d;\n    a = z2 - 0.333333333;\n    d = 0.946174696 * a;\n    out_shs[3] = d;\n    b = z2 * (a - 0.266666667);\n    a = b - 0.257142857 * a;\n    d = 3.702494142 * a;\n    out_shs[10] = d;\n    b = z2 * a - 0.253968254 * b;\n    a = b - 0.252525253 * a;\n    d = 14.684485724 * a;\n    out_shs[21] = d;\n    b = z2 * a - 0.251748252 * b;\n    a = b - 0.251282051 * a;\n    d = 58.473368113 * a;\n    out_shs[36] = d;\n    b = z2 * a - 0.250980392 * b;\n    a = b - 0.250773994 * a;\n    d = 233.240148813 * a;\n    out_shs[55] = d;\n    b = z2 * a - 0.250626566 * b;\n    a = b - 0.250517598 * a;\n    d = 931.186918633 * a;\n    out_shs[78] = d;\n    c1 = x;\n    s1 = y;\n    d = -1.092548431 * z;\n    out_shs[2] = -c1 * d;\n    out_shs[4] = s1 * d;\n    out_grads[2][0] = -c0 * d;\n    out_grads[4][0] = s0 * d;\n    out_grads[2][1] = s0 * d;\n    out_grads[4][1] = c0 * d;\n    d = 1.892349392 * z;\n    out_grads[3][2] = d;\n    a = (z2 - 0.2) * z;\n    b = a - 0.228571429 * z;\n    d = -4.683325805 * b;\n    out_shs[9] = -c1 * d;\n    out_shs[11] = s1 * d;\n    out_grads[9][0] = -c0 * d;\n    out_grads[11][0] = s0 * d;\n    out_grads[9][1] = s0 * d;\n    out_grads[11][1] = c0 * d;\n    d = 14.809976568 * b;\n    out_grads[10][2] = d;\n    a = z2 * b - 0.238095238 * a;\n    b = a - 0.242424242 * b;\n    d = -19.226504963 * b;\n    out_shs[20] = -c1 * d;\n    out_shs[22] = s1 * d;\n    out_grads[20][0] = -c0 * d;\n    out_grads[22][0] = s0 * d;\n    out_grads[20][1] = s0 * d;\n    out_grads[22][1] = c0 * d;\n    d = 88.106914343 * b;\n    out_grads[21][2] = d;\n    a = z2 * b - 0.244755245 * a;\n    b = a - 0.246153846 * b;\n    d = -77.964490818 * b;\n    out_shs[35] = -c1 * d;\n    out_shs[37] = s1 * d;\n    out_grads[35][0] = -c0 * d;\n    out_grads[37][0] = s0 * d;\n    out_grads[35][1] = s0 * d;\n    out_grads[37][1] = c0 * d;\n    d = 467.786944906 * b;\n    out_grads[36][2] = d;\n    a = z2 * b - 0.247058824 * a;\n    b = a - 0.247678019 * b;\n    d = -314.500952502 * b;\n    out_shs[54] = -c1 * d;\n    out_shs[56] = s1 * d;\n    out_grads[54][0] = -c0 * d;\n    out_grads[56][0] = s0 * d;\n    out_grads[54][1] = s0 * d;\n    out_grads[56][1] = c0 * d;\n    d = 2332.401488133 * b;\n    out_grads[55][2] = d;\n    a = z2 * b - 0.248120301 * a;\n    b = a - 0.248447205 * b;\n    d = -1265.233874957 * b;\n    out_shs[77] = -c1 * d;\n    out_shs[79] = s1 * d;\n    out_grads[77][0] = -c0 * d;\n    out_grads[79][0] = s0 * d;\n    out_grads[77][1] = s0 * d;\n    out_grads[79][1] = c0 * d;\n    d = 11174.243023595 * b;\n    out_grads[78][2] = d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.546274215;\n    out_shs[1] = c0 * d;\n    out_shs[5] = s0 * d;\n    d = 1.092548431;\n    out_grads[1][0] = c1 * d;\n    out_grads[5][0] = s1 * d;\n    out_grads[1][1] = -s1 * d;\n    out_grads[5][1] = c1 * d;\n    d = -1.092548431;\n    out_grads[2][2] = -c1 * d;\n    out_grads[4][2] = s1 * d;\n    a = z2 - 0.142857143;\n    d = 3.311611435 * a;\n    out_shs[8] = c0 * d;\n    out_shs[12] = s0 * d;\n    d = 6.62322287 * a;\n    out_grads[8][0] = c1 * d;\n    out_grads[12][0] = s1 * d;\n    out_grads[8][1] = -s1 * d;\n    out_grads[12][1] = c1 * d;\n    d = -14.049977415 * a;\n    out_grads[9][2] = -c1 * d;\n    out_grads[11][2] = s1 * d;\n    b = z2 * (a - 0.19047619);\n    a = b - 0.212121212 * a;\n    d = 15.199886782 * a;\n    out_shs[19] = c0 * d;\n    out_shs[23] = s0 * d;\n    d = 30.399773564 * a;\n    out_grads[19][0] = c1 * d;\n    out_grads[23][0] = s1 * d;\n    out_grads[19][1] = -s1 * d;\n    out_grads[23][1] = c1 * d;\n    d = -96.132524816 * a;\n    out_grads[20][2] = -c1 * d;\n    out_grads[22][2] = s1 * d;\n    b = z2 * a - 0.223776224 * b;\n    a = b - 0.230769231 * a;\n    d = 65.229772956 * a;\n    out_shs[34] = c0 * d;\n    out_shs[38] = s0 * d;\n    d = 130.459545912 * a;\n    out_grads[34][0] = c1 * d;\n    out_grads[38][0] = s1 * d;\n    out_grads[34][1] = -s1 * d;\n    out_grads[38][1] = c1 * d;\n    d = -545.751435723 * a;\n    out_grads[35][2] = -c1 * d;\n    out_grads[37][2] = s1 * d;\n    b = z2 * a - 0.235294118 * b;\n    a = b - 0.238390093 * a;\n    d = 272.365814381 * a;\n    out_shs[53] = c0 * d;\n    out_shs[57] = s0 * d;\n    d = 544.731628762 * a;\n    out_grads[53][0] = c1 * d;\n    out_grads[57][0] = s1 * d;\n    out_grads[53][1] = -s1 * d;\n    out_grads[57][1] = c1 * d;\n    d = -2830.508572514 * a;\n    out_grads[54][2] = -c1 * d;\n    out_grads[56][2] = s1 * d;\n    b = z2 * a - 0.240601504 * b;\n    a = b - 0.242236025 * a;\n    d = 1121.509962433 * a;\n    out_shs[76] = c0 * d;\n    out_shs[80] = s0 * d;\n    d = 2243.019924866 * a;\n    out_grads[76][0] = c1 * d;\n    out_grads[80][0] = s1 * d;\n    out_grads[76][1] = -s1 * d;\n    out_grads[80][1] = c1 * d;\n    d = -13917.572624524 * a;\n    out_grads[77][2] = -c1 * d;\n    out_grads[79][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -1.77013077 * z;\n    out_shs[7] = -c1 * d;\n    out_shs[13] = s1 * d;\n    d = -5.310392309 * z;\n    out_grads[7][0] = -c0 * d;\n    out_grads[13][0] = s0 * d;\n    out_grads[7][1] = s0 * d;\n    out_grads[13][1] = c0 * d;\n    d = 6.62322287 * z;\n    out_grads[8][2] = c0 * d;\n    out_grads[12][2] = s0 * d;\n    a = (z2 - 0.111111111) * z;\n    b = a - 0.161616162 * z;\n    d = -10.133257855 * b;\n    out_shs[18] = -c1 * d;\n    out_shs[24] = s1 * d;\n    d = -30.399773564 * b;\n    out_grads[18][0] = -c0 * d;\n    out_grads[24][0] = s0 * d;\n    out_grads[18][1] = s0 * d;\n    out_grads[24][1] = c0 * d;\n    d = 60.799547128 * b;\n    out_grads[19][2] = c0 * d;\n    out_grads[23][2] = s0 * d;\n    a = z2 * b - 0.188811189 * a;\n    b = a - 0.205128205 * b;\n    d = -48.175380057 * b;\n    out_shs[33] = -c1 * d;\n    out_shs[39] = s1 * d;\n    d = -144.52614017 * b;\n    out_grads[33][0] = -c0 * d;\n    out_grads[39][0] = s0 * d;\n    out_grads[33][1] = s0 * d;\n    out_grads[39][1] = c0 * d;\n    d = 391.378637737 * b;\n    out_grads[34][2] = c0 * d;\n    out_grads[38][2] = s0 * d;\n    a = z2 * b - 0.215686275 * a;\n    b = a - 0.222910217 * b;\n    d = -213.661323441 * b;\n    out_shs[52] = -c1 * d;\n    out_shs[58] = s1 * d;\n    d = -640.983970322 * b;\n    out_grads[52][0] = -c0 * d;\n    out_grads[58][0] = s0 * d;\n    out_grads[52][1] = s0 * d;\n    out_grads[58][1] = c0 * d;\n    d = 2178.926515046 * b;\n    out_grads[53][2] = c0 * d;\n    out_grads[57][2] = s0 * d;\n    a = z2 * b - 0.228070175 * a;\n    b = a - 0.231884058 * b;\n    d = -915.709049803 * b;\n    out_shs[75] = -c1 * d;\n    out_shs[81] = s1 * d;\n    d = -2747.127149409 * b;\n    out_grads[75][0] = -c0 * d;\n    out_grads[81][0] = s0 * d;\n    out_grads[75][1] = s0 * d;\n    out_grads[81][1] = c0 * d;\n    d = 11215.099624332 * b;\n    out_grads[76][2] = c0 * d;\n    out_grads[80][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.625835735;\n    out_shs[6] = c0 * d;\n    out_shs[14] = s0 * d;\n    d = 2.503342942;\n    out_grads[6][0] = c1 * d;\n    out_grads[14][0] = s1 * d;\n    out_grads[6][1] = -s1 * d;\n    out_grads[14][1] = c1 * d;\n    d = -1.77013077;\n    out_grads[7][2] = -c1 * d;\n    out_grads[13][2] = s1 * d;\n    a = z2 - 9.09090909e-02;\n    d = 5.550213908 * a;\n    out_shs[17] = c0 * d;\n    out_shs[25] = s0 * d;\n    d = 22.200855632 * a;\n    out_grads[17][0] = c1 * d;\n    out_grads[25][0] = s1 * d;\n    out_grads[17][1] = -s1 * d;\n    out_grads[25][1] = c1 * d;\n    d = -30.399773564 * a;\n    out_grads[18][2] = -c1 * d;\n    out_grads[24][2] = s1 * d;\n    b = z2 * (a - 0.13986014);\n    a = b - 0.169230769 * a;\n    d = 31.097074109 * a;\n    out_shs[32] = c0 * d;\n    out_shs[40] = s0 * d;\n    d = 124.388296437 * a;\n    out_grads[32][0] = c1 * d;\n    out_grads[40][0] = s1 * d;\n    out_grads[32][1] = -s1 * d;\n    out_grads[40][1] = c1 * d;\n    d = -240.876900283 * a;\n    out_grads[33][2] = -c1 * d;\n    out_grads[39][2] = s1 * d;\n    b = z2 * a - 0.188235294 * b;\n    a = b - 0.20123839 * a;\n    d = 151.081370682 * a;\n    out_shs[51] = c0 * d;\n    out_shs[59] = s0 * d;\n    d = 604.325482728 * a;\n    out_grads[51][0] = c1 * d;\n    out_grads[59][0] = s1 * d;\n    out_grads[51][1] = -s1 * d;\n    out_grads[59][1] = c1 * d;\n    d = -1495.629264084 * a;\n    out_grads[52][2] = -c1 * d;\n    out_grads[58][2] = s1 * d;\n    b = z2 * a - 0.210526316 * b;\n    a = b - 0.217391304 * a;\n    d = 686.781787352 * a;\n    out_shs[74] = c0 * d;\n    out_shs[82] = s0 * d;\n    d = 2747.127149409 * a;\n    out_grads[74][0] = c1 * d;\n    out_grads[82][0] = s1 * d;\n    out_grads[74][1] = -s1 * d;\n    out_grads[82][1] = c1 * d;\n    d = -8241.381448228 * a;\n    out_grads[75][2] = -c1 * d;\n    out_grads[81][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.366619162 * z;\n    out_shs[16] = -c1 * d;\n    out_shs[26] = s1 * d;\n    d = -11.833095811 * z;\n    out_grads[16][0] = -c0 * d;\n    out_grads[26][0] = s0 * d;\n    out_grads[16][1] = s0 * d;\n    out_grads[26][1] = c0 * d;\n    d = 11.100427816 * z;\n    out_grads[17][2] = c0 * d;\n    out_grads[25][2] = s0 * d;\n    a = (z2 - 7.69230769e-02) * z;\n    b = a - 0.123076923 * z;\n    d = -17.24955311 * b;\n    out_shs[31] = -c1 * d;\n    out_shs[41] = s1 * d;\n    d = -86.247765552 * b;\n    out_grads[31][0] = -c0 * d;\n    out_grads[41][0] = s0 * d;\n    out_grads[31][1] = s0 * d;\n    out_grads[41][1] = c0 * d;\n    d = 124.388296437 * b;\n    out_grads[32][2] = c0 * d;\n    out_grads[40][2] = s0 * d;\n    a = z2 * b - 0.152941176 * a;\n    b = a - 0.173374613 * b;\n    d = -95.552248675 * b;\n    out_shs[50] = -c1 * d;\n    out_shs[60] = s1 * d;\n    d = -477.761243376 * b;\n    out_grads[50][0] = -c0 * d;\n    out_grads[60][0] = s0 * d;\n    out_grads[50][1] = s0 * d;\n    out_grads[60][1] = c0 * d;\n    d = 906.488224092 * b;\n    out_grads[51][2] = c0 * d;\n    out_grads[59][2] = s0 * d;\n    a = z2 * b - 0.187969925 * a;\n    b = a - 0.198757764 * b;\n    d = -471.12841933 * b;\n    out_shs[73] = -c1 * d;\n    out_shs[83] = s1 * d;\n    d = -2355.642096651 * b;\n    out_grads[73][0] = -c0 * d;\n    out_grads[83][0] = s0 * d;\n    out_grads[73][1] = s0 * d;\n    out_grads[83][1] = c0 * d;\n    d = 5494.254298819 * b;\n    out_grads[74][2] = c0 * d;\n    out_grads[82][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.683184105;\n    out_shs[15] = c0 * d;\n    out_shs[27] = s0 * d;\n    d = 4.099104631;\n    out_grads[15][0] = c1 * d;\n    out_grads[27][0] = s1 * d;\n    out_grads[15][1] = -s1 * d;\n    out_grads[27][1] = c1 * d;\n    d = -2.366619162;\n    out_grads[16][2] = -c1 * d;\n    out_grads[26][2] = s1 * d;\n    a = z2 - 6.66666667e-02;\n    d = 7.984991491 * a;\n    out_shs[30] = c0 * d;\n    out_shs[42] = s0 * d;\n    d = 47.909948945 * a;\n    out_grads[30][0] = c1 * d;\n    out_grads[42][0] = s1 * d;\n    out_grads[30][1] = -s1 * d;\n    out_grads[42][1] = c1 * d;\n    d = -51.748659331 * a;\n    out_grads[31][2] = -c1 * d;\n    out_grads[41][2] = s1 * d;\n    b = z2 * (a - 0.109803922);\n    a = b - 0.139318885 * a;\n    d = 53.41533086 * a;\n    out_shs[49] = c0 * d;\n    out_shs[61] = s0 * d;\n    d = 320.491985161 * a;\n    out_grads[49][0] = c1 * d;\n    out_grads[61][0] = s1 * d;\n    out_grads[49][1] = -s1 * d;\n    out_grads[61][1] = c1 * d;\n    d = -477.761243376 * a;\n    out_grads[50][2] = -c1 * d;\n    out_grads[60][2] = s1 * d;\n    b = z2 * a - 0.160401003 * b;\n    a = b - 0.175983437 * a;\n    d = 293.800188384 * a;\n    out_shs[72] = c0 * d;\n    out_shs[84] = s0 * d;\n    d = 1762.801130306 * a;\n    out_grads[72][0] = c1 * d;\n    out_grads[84][0] = s1 * d;\n    out_grads[72][1] = -s1 * d;\n    out_grads[84][1] = c1 * d;\n    d = -3297.898935312 * a;\n    out_grads[73][2] = -c1 * d;\n    out_grads[83][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -2.915706641 * z;\n    out_shs[29] = -c1 * d;\n    out_shs[43] = s1 * d;\n    d = -20.409946485 * z;\n    out_grads[29][0] = -c0 * d;\n    out_grads[43][0] = s0 * d;\n    out_grads[29][1] = s0 * d;\n    out_grads[43][1] = c0 * d;\n    d = 15.969982982 * z;\n    out_grads[30][2] = c0 * d;\n    out_grads[42][2] = s0 * d;\n    a = (z2 - 5.88235294e-02) * z;\n    b = a - 9.90712074e-02 * z;\n    d = -25.910241313 * b;\n    out_shs[48] = -c1 * d;\n    out_shs[62] = s1 * d;\n    d = -181.371689194 * b;\n    out_grads[48][0] = -c0 * d;\n    out_grads[62][0] = s0 * d;\n    out_grads[48][1] = s0 * d;\n    out_grads[62][1] = c0 * d;\n    d = 213.661323441 * b;\n    out_grads[49][2] = c0 * d;\n    out_grads[61][2] = s0 * d;\n    a = z2 * b - 0.127819549 * a;\n    b = a - 0.149068323 * b;\n    d = -165.101452729 * b;\n    out_shs[71] = -c1 * d;\n    out_shs[85] = s1 * d;\n    d = -1155.7101691 * b;\n    out_grads[71][0] = -c0 * d;\n    out_grads[85][0] = s0 * d;\n    out_grads[71][1] = s0 * d;\n    out_grads[85][1] = c0 * d;\n    d = 1762.801130306 * b;\n    out_grads[72][2] = c0 * d;\n    out_grads[84][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.72892666;\n    out_shs[28] = c0 * d;\n    out_shs[44] = s0 * d;\n    d = 5.831413281;\n    out_grads[28][0] = c1 * d;\n    out_grads[44][0] = s1 * d;\n    out_grads[28][1] = -s1 * d;\n    out_grads[44][1] = c1 * d;\n    d = -2.915706641;\n    out_grads[29][2] = -c1 * d;\n    out_grads[43][2] = s1 * d;\n    a = z2 - 5.26315789e-02;\n    d = 10.577811722 * a;\n    out_shs[47] = c0 * d;\n    out_shs[63] = s0 * d;\n    d = 84.622493774 * a;\n    out_grads[47][0] = c1 * d;\n    out_grads[63][0] = s1 * d;\n    out_grads[47][1] = -s1 * d;\n    out_grads[63][1] = c1 * d;\n    d = -77.73072394 * a;\n    out_grads[48][2] = -c1 * d;\n    out_grads[62][2] = s1 * d;\n    b = z2 * (a - 9.02255639e-02);\n    a = b - 0.118012422 * a;\n    d = 82.550726364 * a;\n    out_shs[70] = c0 * d;\n    out_shs[86] = s0 * d;\n    d = 660.405810914 * a;\n    out_grads[70][0] = c1 * d;\n    out_grads[86][0] = s1 * d;\n    out_grads[70][1] = -s1 * d;\n    out_grads[86][1] = c1 * d;\n    d = -825.507263643 * a;\n    out_grads[71][2] = -c1 * d;\n    out_grads[85][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -3.4318953 * z;\n    out_shs[46] = -c1 * d;\n    out_shs[64] = s1 * d;\n    d = -30.887057699 * z;\n    out_grads[46][0] = -c0 * d;\n    out_grads[64][0] = s0 * d;\n    out_grads[46][1] = s0 * d;\n    out_grads[64][1] = c0 * d;\n    d = 21.155623443 * z;\n    out_grads[47][2] = c0 * d;\n    out_grads[63][2] = s0 * d;\n    a = (z2 - 4.76190476e-02) * z;\n    b = a - 8.2815735e-02 * z;\n    d = -36.028090689 * b;\n    out_shs[69] = -c1 * d;\n    out_shs[87] = s1 * d;\n    d = -324.252816204 * b;\n    out_grads[69][0] = -c0 * d;\n    out_grads[87][0] = s0 * d;\n    out_grads[69][1] = s0 * d;\n    out_grads[87][1] = c0 * d;\n    d = 330.202905457 * b;\n    out_grads[70][2] = c0 * d;\n    out_grads[86][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.767395118;\n    out_shs[45] = c0 * d;\n    out_shs[65] = s0 * d;\n    d = 7.673951182;\n    out_grads[45][0] = c1 * d;\n    out_grads[65][0] = s1 * d;\n    out_grads[45][1] = -s1 * d;\n    out_grads[65][1] = c1 * d;\n    d = -3.4318953;\n    out_grads[46][2] = -c1 * d;\n    out_grads[64][2] = s1 * d;\n    a = z2 - 4.34782609e-02;\n    d = 13.3042542 * a;\n    out_shs[68] = c0 * d;\n    out_shs[88] = s0 * d;\n    d = 133.042542003 * a;\n    out_grads[68][0] = c1 * d;\n    out_grads[88][0] = s1 * d;\n    out_grads[68][1] = -s1 * d;\n    out_grads[88][1] = c1 * d;\n    d = -108.084272068 * a;\n    out_grads[69][2] = -c1 * d;\n    out_grads[87][2] = s1 * d;\n    c1 = x * c0 - y * s0;\n    s1 = y * c0 + x * s0;\n    d = -3.923210529 * z;\n    out_shs[67] = -c1 * d;\n    out_shs[89] = s1 * d;\n    d = -43.155315818 * z;\n    out_grads[67][0] = -c0 * d;\n    out_grads[89][0] = s0 * d;\n    out_grads[67][1] = s0 * d;\n    out_grads[89][1] = c0 * d;\n    d = 26.608508401 * z;\n    out_grads[68][2] = c0 * d;\n    out_grads[88][2] = s0 * d;\n    c0 = x * c1 - y * s1;\n    s0 = y * c1 + x * s1;\n    d = 0.800821996;\n    out_shs[66] = c0 * d;\n    out_shs[90] = s0 * d;\n    d = 9.609863949;\n    out_grads[66][0] = c1 * d;\n    out_grads[90][0] = s1 * d;\n    out_grads[66][1] = -s1 * d;\n    out_grads[90][1] = c1 * d;\n    d = -3.923210529;\n    out_grads[67][2] = -c1 * d;\n    out_grads[89][2] = s1 * d;\n    out_grads[0][0] = 0.0;\n    out_grads[0][1] = 0.0;\n    out_grads[0][2] = 0.0;\n    out_grads[1][2] = 0.0;\n    out_grads[3][0] = 0.0;\n    out_grads[3][1] = 0.0;\n    out_grads[5][2] = 0.0;\n    out_grads[6][2] = 0.0;\n    out_grads[10][0] = 0.0;\n    out_grads[10][1] = 0.0;\n    out_grads[14][2] = 0.0;\n    out_grads[15][2] = 0.0;\n    out_grads[21][0] = 0.0;\n    out_grads[21][1] = 0.0;\n    out_grads[27][2] = 0.0;\n    out_grads[28][2] = 0.0;\n    out_grads[36][0] = 0.0;\n    out_grads[36][1] = 0.0;\n    out_grads[44][2] = 0.0;\n    out_grads[45][2] = 0.0;\n    out_grads[55][0] = 0.0;\n    out_grads[55][1] = 0.0;\n    out_grads[65][2] = 0.0;\n    out_grads[66][2] = 0.0;\n    out_grads[78][0] = 0.0;\n    out_grads[78][1] = 0.0;\n    out_grads[90][2] = 0.0;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGSDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[8449, 8968, 9023, 9023, 9346], [9349, 9441, 9531, 9531, 9950], [9953, 10092, 10166, 10166, 24813], [29907, 30436, 30540, 30540, 32197], [32200, 32258, 32294, 32294, 32392], [32394, 32425, 32465, 32465, 32589], [32591, 32645, 32683, 32683, 32780], [32782, 32817, 32853, 32853, 32944], [32946, 33016, 33043, 33043, 33189]]}
{"id": "cslyDH", "name": "Fork HODL romanscz 529", "author": "romanscz", "description": "See comments for details. Use mouse to scrub time.", "tags": ["crypto", "coin", "blockchain", "bitcoin", "btc", "nft", "currency"], "likes": 4, "viewed": 249, "published": 3, "date": "1686776897", "time_retrieved": "2024-07-30T17:49:37.859495", "image_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// I had started a bitcoin texture a couple of years ago but\n// never finished it. With the recent bullrun I got motivated\n// again to finish it. I tried to use symmetries as much as possible\n// but in the end, its still a shitload of manual tweaks because\n// the thing really isn't as symmetrical as it looks. Oww well.\n//\n// Music: Fly Me To The Moon (prod. ibrahim) - Going Spaceward\n// https://soundcloud.com/going-spaceward/fly-me-to-the-moon\n\n//#define SHOW_COIN_TEXTURE\n//#define SHOW_BACKGROUND\n\n// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Background layer. See my tutorial about this here:\n// https://www.youtube.com/watch?v=3CycKKJiwis\n\n#define S smoothstep\n#define NUM_LAYERS 2.\n\nfloat Line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 \n        pa = p - a, \n        ba = b - a;\n        \n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n\t\n    return length(pa - ba * h);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec4 GetProgress(float T, vec2 M) {\n    T += M.x/.03; \n    float \n        t = fract(T*.03),\n        y = t*(1.-t)*4.;\n    return vec4(t, 1.-abs(t-.5)*2., y, y*75.);\n}\n\nvec3 GetBgCol(float T) {\n    return vec3(1., .7, .2).brg;\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float \n        n = N21(id+offs),\n        n1 = fract(n*10.),\n        n2 = fract(n*100.),\n        a = t+n;\n        \n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat Connect(vec2 a, vec2 b, vec2 uv, float t) {\n    t = .5-abs(t-.5);\n    float \n        d = Line(uv, a, b),\n        d2 = length(a-b),\n        fade = S(1.5, .5, d2+t)*S(.9,.6, t*2.),\n        r = 6./iResolution.y;\n    \n    return S(r, 0., d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float T) {\n    vec2 \n        id = floor(st)+n,\n        p[9];\n\n    float \n        t = iTime+10.,\n        m=0., d, s,\n        pulse, sparkle=0.;\n    \n    st = fract(st)-.5;\n    \n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    for(int i=0; i<9; i++) {\n        m += Connect(p[4], p[i], st, T);\n\n        d = length(st-p[i]);\n\n        s = (.0005/(d*d));\n        s *= S(1., 0.1, d);\n        pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*2.)*.4+.6;\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += Connect(p[1], p[3], st, T);\n\tm += Connect(p[1], p[5], st, T);\n    m += Connect(p[7], p[5], st, T);\n    m += Connect(p[7], p[3], st, T);\n    m += sparkle*S(.05, .5, abs(T-.5));\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    float \n        t, y, m = 0., r, d, glow, moon;\n        \n    vec2 \n        uv = (fragCoord-iResolution.xy*.5)/iResolution.y,\n        M = iMouse.xy/iResolution.xy,\n        st = uv;\n    \n    t = 1.;\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float \n            size = mix(15., 1., i),\n            fade = S(0., .6, i)*S(1., .8, i);\n            \n        m += fade * NetLayer(st*size, i, t);\n    }\n\t\n    vec3 \n        baseCol = GetBgCol(iTime),\n        col = baseCol*m*.2;\n    \n    //col += baseCol*(exp(offs.y/10.)+glow*glow);\n    \n    fragColor = vec4(min(col,vec3(1)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslyDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1298, 1298, 1343, 1343, 1490], [1492, 1492, 1511, 1511, 1646], [1648, 1648, 1683, 1683, 1813], [1815, 1815, 1839, 1839, 1874], [1876, 1876, 1918, 1918, 2087], [2089, 2089, 2138, 2138, 2339], [2341, 2341, 2384, 2384, 3177], [3179, 3179, 3236, 3236, 3830]]}
{"id": "ddfyDH", "name": "tube nest 2", "author": "FabriceNeyret2", "description": "mouse controls camera\nvariant of https://shadertoy.com/view/mdXyDH", "tags": ["short", "golf"], "likes": 41, "viewed": 474, "published": 3, "date": "1686763155", "time_retrieved": "2024-07-30T17:49:38.623452", "image_code": "// variant of https://shadertoy.com/view/mdXyDH\n\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                    // rotation\n//#define L(q)      max( abs(q.z)-1., length(abs(q.xy)-1.) ) - .1   // cube\n#define L(q)        max( q.z, length(q.xy) ) - .1                   // tripod ( or cube, with  q = abs(q) - 1. )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r,i;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -R.y) - R),                       // ray direction\n          p = vec3(0,0,3), q, P,                                    // marching point along ray \n          C = iMouse.z > -0. ? 6.* iMouse.xyz/R -3.                 // camera control\n                             : 3.* cos(.3*iTime + vec3(0,11,0));\n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 ) {                // march scene\n        P = p, \n        P.yz *= rot(-C.y),                                          // rotations\n        P.xz *= rot(-C.x);\n        for ( i=0.; i++ < 5. ; P.xy *= rot(1.26) )                  // 2pi/5 rotational symmetry\n            q = P,\n            q.x-=.7, q.xz *= rot(.4), q.yz*=rot(.4),                // offset and tilt\n            q = abs(q) - 1.,\n            t = min( min(t,L(q)), min(L(q.yzx),L(q.zxy)) );         // 3 ortho cylinders\n        \n        p += .3*t*D;                                                // step forward = dist to obj  \n    }\n    \n   O *= O*O*O*2.;                                                   // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 356, 356, 1472]]}
{"id": "msXyDH", "name": "wavelength2rgb approx.", "author": "FordPerfect", "description": "Small, self-contained spectrum approximation.\nUse at your own risk: this may or may not be a cunning application of Cunningham's Law.", "tags": ["spectrum", "wavelength", "cie", "cmf"], "likes": 10, "viewed": 256, "published": 3, "date": "1686763131", "time_retrieved": "2024-07-30T17:49:39.582887", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Wavelength to RGB conversion, under CIE 1931 2 Standard Observer\n// (see https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_standard_observer )\n// using \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\",\n// (see https://jcgt.org/published/0002/02/01/), same as e.g. https://www.shadertoy.com/view/4ttBRB .\n\n// The approximation error is (claimed) below variance in source data.\n\n// Several potentially non-obvious points:\n//   1. Produced RGB may well be negative: sRGB is incapable\n//      of representing pure spectral colors. You can e.g. blend with\n//      gray background, or do something fancier.\n//   2. The core function works in linear space (XYZ and RGB)\n//      so conversion is necessary for a proper look, since\n//      Shadertoy (presumably) considers output a gamma-ful sRGB. Between\n//      the Shadertoy, browsers, and monitor profiles, this is\n//      a murky territory anyway.\n//   3. The XYZ values produced are \"densities\", in *wavelength domain*, i.e.\n//      you are supposed to integrate them with spectral radiance,\n//      see https://en.wikipedia.org/wiki/CIE_1931_color_space#Computing_XYZ_from_spectral_data .\n//      Sampling it is equivalent to integrating with delta-function,\n//      corresponding to a highly monochromatic light source *of unit intensity*.\n//      The plot of the function corresponds to a light source with a flat spectrum\n//      in *wavelength domain* (which is non-flat in frequency domain), which might\n//      be not what you want.\n//      For black body (e.g. Sun) spectrum you may use https://en.wikipedia.org/wiki/Planck%27s_law .\n\n// Helper function (separately-sloped gaussian).\nfloat f(float t,float l,float h) {t*=mix(l,h,step(0.0,t)); return exp(-0.5*t*t);}\n\n// Input is in nanometers.\nvec3 wavelength2xyz(float lambda)\n{\n    return vec3(\n        +0.362*f(lambda-442.0,0.0624,0.0374)\n        +1.056*f(lambda-599.8,0.0264,0.0323)\n        -0.065*f(lambda-501.1,0.0490,0.0382),\n        +0.821*f(lambda-568.8,0.0213,0.0247)\n        +0.286*f(lambda-530.9,0.0613,0.0322),\n        +1.217*f(lambda-437.0,0.0845,0.0278)\n        +0.681*f(lambda-459.0,0.0385,0.0725));\n}\n\n// Output is linear RGB.\nvec3 xyz2rgb(vec3 xyz)\n{\n    return mat3( // WARNING: column-major.\n        +3.2404542, -0.9692660, +0.0556434,\n        -1.5371385, +1.8760108, -0.2040259,\n        -0.4985314, +0.0415560, +1.0572252)*xyz;\n}\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    float lambda=mix(350.0,750.0,uv.x);\n    vec3 col=0.25+0.25*xyz2rgb(wavelength2xyz(lambda)); // Fits in [0;1]^3, just barely.\n    col=linear2srgb(col);\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXyDH.jpg", "access": "api", "license": "public-domain", "functions": [[1692, 1741, 1775, 1775, 1822], [1824, 1851, 1886, 1886, 2224], [2226, 2251, 2275, 2275, 2457], [2459, 2459, 2487, 2487, 2571], [2573, 2573, 2627, 2627, 2851]]}
{"id": "mdXyDH", "name": "tube nest", "author": "FabriceNeyret2", "description": "mouse controls camera\ninspiration: https://twitter.com/Yugemaku/status/1668965718279467009\n\nhow it looks from outside ;-) : https://www.shadertoy.com/view/ddfyDH", "tags": ["short", "golf", "reproduction"], "likes": 20, "viewed": 286, "published": 3, "date": "1686763060", "time_retrieved": "2024-07-30T17:49:40.461538", "image_code": "\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                    // rotation\n//#define L(q)      max( abs(q.z)-1., length(abs(q.xy)-1.) ) - .1   // cube\n#define L(q)        max( q.z, length(q.xy) ) - .1                   // tripod ( or cube, with  q = abs(q) - 1. )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r,i;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -R.y) - R),                       // ray direction\n          p, q, P,                                                  // marching point along ray \n          C = iMouse.z > -0. ? 6.* iMouse.xyz/R -3.                 // camera control\n                             : 3.* cos(.3*iTime + vec3(0,11,0));\n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 ) {                // march scene\n        P = p, \n        P.yz *= rot(-C.y),                                          // rotations\n        P.xz *= rot(-C.x);\n        for ( i=0.; i++ < 5. ; P.xy *= rot(1.26) )                  // 2pi/5 rotational symmetry\n            q = P,\n            q.x-=.7, q.xz *= rot(.4), q.yz*=rot(.4),                // offset and tilt\n            q = abs(q) - 1.,\n            t = min( min(t,L(q)), min(L(q.yzx),L(q.zxy)) );         // 3 ortho cylinders\n        \n        p += .3*t*D;                                                // step forward = dist to obj  \n    }\n    \n   O *= O*O*O*2.;                                                   // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 307, 307, 1423]]}
{"id": "csfcWH", "name": "Photon - based on Fabrice Neyret", "author": "MotionMountain", "description": "Not yet correct when seen from the side. Left end should always be below, right one always above the centre segment.\nBut I do not know how to do it. Help appreciated.\n\nSo far, good enough for my website at https://www.motionmountain.net/research.html#pt", "tags": ["photon"], "likes": 3, "viewed": 2447, "published": 3, "date": "1686753487", "time_retrieved": "2024-07-30T17:49:41.231479", "image_code": "// Variant of https://shadertoy.com/view/DdcXRj by Fabrice Neyert\n// Fork of https://www.shadertoy.com/view/DstXRs by Fabrice Neyert\n\n// CS sees the following two shortcomings in this animation file, that he modified himself, and that he wants to be corrected:\n//\n//       Please click and draw the animation to watch it from the side!\n//       \n//       (1) If you look at one tether, you can see that it passes alternativeley to one side of teh green axis and then to the other.\n//       I do NOT want this.\n//\n//       The motion should be simplified: in the deafult view, the rotating segment should always be at MIDDLE height \n//       (thus in the paper plane),\n//       one tether, say the left one, should ALWAYS be BELOW the paper plane (thus below the green axis), and the other tether,  \n//       the right one, should ALWAYS be above the paper plane, thus above the green axis (in the default view).\n//       But the code is too cryptic for me: I do no to understand it and cannot improve it.\n//       And Fabrice Neyret has no time to do it.\n//\n//       (2) Also a \"nicer\", more rounded shape during rotation would be welcome, but is not necessary.\n//\n//       Changes should be commented and put in a separate shadertoy file that is made public. Accounts at shadertoy are free.\n//\n//       The result will be made public on https://www.motionmountain.net/research.html#et and on the top of that same page.\n//\n//       A second, separate upworks job will be uploaded soon, for improving this animation:  https://www.shadertoy.com/view/cld3zX\n//\n//       There will be more such jobs in future - at least a dozen.\n\n#define N true                                               // display the triangle normal ( green ) // CS: \"false\" switches green axis off\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))                         // 2D rotation // CS: number change has strange effects\n#define rot3(P,A,a)  ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )  // 3D rot around an arbitrary axis\n  \n#define L(q) length(q.xy) -.2                                // changed by CS to have only one strand\n\n#define d(q)  (   min( r= L((q).yzx), N ? g= max(length(q)-1.5,length(q-dot(q,vec3(1./3.))))-.1 : 1e2 )            )   //\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., w=0., r=w,b=w,g=w;                      // CS: t=9., w=0. is original, no changes for different numbers\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),                          // ray direction - CS: size of triangle, orig is -12.*R.y\n          p = vec3(0,0,90), q,a,                                           // marching point along ray - CS: observer position\n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n                            : vec3(-.8,0,0); // vec3(0,1.,0) // vec3(.5,-.5,0)   // CS: original was -.8,0,0 perp view with -12,0,0\n        p.yz *= rot(-M.y),                                                 // camera rotations - CS: and orientation\n        p.xz *= rot(-M.x), \n        D.yz *= rot(-M.y),\n        D.xz *= rot(-M.x); \n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )                        // march scene - CS: original is O-=.005, makes shading\n        q = p,\n#if 1                                                                      // set 0 for no antitwister - CS: 1 makes things rotate\n\n        a = vec3(sin(iTime),0,cos(iTime)),                                 // CS: original is  vec3(sin(iTime),0,cos(iTime))\n                                                                           // CS: adding phase has no effect\n        \n        a = rot3( a, vec3(-.71,0,.71), 3.14/2. ),                          // variant - CS: comment out to get different rotation axis\n                                                                           // CS: original is rot3( a, vec3(.71,0,-.71), 3.14/2. )\n                                                                           // CS: sign of vec3 yields different rotation direction\n                                                                           // different sin & cos make green axis tumble\n                                                                           \n        q = rot3( p,a, \n               // 3.14 *smoothstep(8., 0., length(p)) ),                   // the magic is there\n                 3.14 *smoothstep(.05, .6, 1./length(p)) ),                // CS: (.05, .6. 1./length(p)) is original ; 2./ changes surr.\n                //3.14 ),                                                  // test: rot with no antitwister\n#endif\n\n        q = rot3( q,vec3(.71,0,-.71), .6 ),                                // make triangle vertical - CS: other sin & cos have no effect           \n     // q = rot3( q,vec3(.71,0,-.71), .955 ), // acos(1/sqrt(3))                                      \n     // J = inverse( mat3( D(p+e) -q, D(p+e.yxy) -q, D(p+e.yyx) -q ) / e.x ), // Jacobian\n        t = d(q),                                                          \n        p += .2*t*D;                                                       // step forward = dist to obj - CS: number changes blackness\n\n    O *= O*O*2.;                                                           // color scheme - CS: white is more white with *6.\n    O *= vec4( t==b, t==g, t==r, 1)*vec4(2,1,2,1) + float(t==w);\n    if (O.a < 0.) O += .9;                                                 // white background - CS: also works in grey with .+= .777\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mdlyWn", "name": "Cubic squares", "author": "Starfish", "description": "A line of rotating rectangles is moving along a cubic path.", "tags": ["sdf", "squares", "cubicfunction", "totation"], "likes": 3, "viewed": 147, "published": 3, "date": "1686731549", "time_retrieved": "2024-07-30T17:49:41.990449", "image_code": "vec2 cubic(float x, float a, float b, float c, float d){\n    float y = a * x * x * x + b * x * x + c * x + d;\n    \n    return vec2(x, y);\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n\n//signed distance function for rectangles, credit: inigo quilez\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //move (0., 0.) into middle of screen, scaled coordinates from (-2.,-2.) to (2., 2.)\n    vec2 uv = fragCoord/iResolution.xy * 4.0 - 2.;\n    \n\n    //calculates whether a pixel is within a square or not. To achieve this, all x positions\n    //of the squares are iterated through to check which square is closest, then uv is shifted\n    //so that the coordinates of that square are centered to calculate the signed distance function\n    float squareNum = 16.;\n    \n    //any number bigger than the longest possible distance will do\n    float squareCoordDist = 20.0;\n    float squarePos;\n    \n    for(float n=0.0; n<squareNum; n++){\n        float nearestSquarePos = mod(n * 4. / squareNum + 0.5 * iTime, 4.) - 2.0;\n        \n        if(abs(uv.x - nearestSquarePos) < squareCoordDist){\n            squareCoordDist = abs(uv.x - nearestSquarePos);\n            squarePos = nearestSquarePos;\n        }\n    }       \n     \n    //centering square coordinates is done with the x coord of the selected square and the\n    //correlated y value of its cubic to achieve the wavy movement of the squares\n    uv -= cubic(squarePos, 0.7, 0.0, -2.0, 0.0);\n    \n    //adjusting the aspect ratio, without this the squares will be shown as rectangles\n    uv.x *= iResolution.x/iResolution.y;\n\n    //add some rotation\n    uv = rotate(0.5 * iTime) * uv; \n    \n    //calculates the color from the square sdf, using smoothstep to prevent rough edges\n    float distToCirclePos = smoothstep(0.001, 0.015, sdBox(uv, vec2(0.15, 0.15)));\n\n    \n    vec3 col = vec3(distToCirclePos);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 139], [141, 141, 167, 167, 251], [254, 318, 355, 355, 435], [437, 437, 494, 583, 2103]]}
{"id": "cdlcDr", "name": "First Raymarching Shader", "author": "ApeSander", "description": "This is my first raymarching shader :)", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 144, "published": 3, "date": "1686730209", "time_retrieved": "2024-07-30T17:49:42.748423", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat smoothMax(float a, float b, float k) {\n        return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smoothMin(float a, float b, float k) {\n    return -log(exp(k * -a) + exp(k * - b)) / k;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat getDist( vec3 p ) {\n    vec4 s = vec4(0, 1, 6, 1);\n    s.y = sin(iTime) - 1.0;\n    float sD = length(p-s.xyz) - s.w;\n    float pD = p.y;\n    float d = smoothMax(-sD, pD, 1.0);\n    \n    return d;\n}\n\nvec3 getNormal( vec3 p ) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat rayMarch( vec3 ro, vec3 rd ) \n{\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat getLight( vec3 p ) {\n    vec3 lightPos = vec3(0, 5, 6);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = rayMarch(p+n*SURF_DIST*2.0, l);\n    if (d < length(lightPos-p)) dif *= 0.2;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 3, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    float dif = getLight(p);\n    \n    d /= 6.0;\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 113, 113, 164], [166, 166, 210, 210, 261], [263, 263, 296, 296, 361], [363, 363, 388, 388, 565], [567, 567, 593, 593, 786], [788, 788, 825, 825, 1050], [1052, 1052, 1078, 1078, 1335], [1337, 1337, 1394, 1394, 1736]]}
{"id": "mdSXW1", "name": "Sound Experiment #7", "author": "oneshade", "description": "Experimenting with beats.", "tags": ["sound", "beat", "experiment"], "likes": 9, "viewed": 483, "published": 3, "date": "1686718126", "time_retrieved": "2024-07-30T17:49:43.531330", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n\n    // Aspect correct, centered UVs and 2 pixel AA width for soft edges\n    uv = fragCoord / iResolution.y - vec2(0.0, 0.5);\n    float unit = 2.0 / iResolution.y;\n\n    // Graph sound wave (MUCH slower than actual speed)\n    float x = mod(0.02 * (uv.x + 2.0 * iTime), 11.0);\n    float graphDist = abs(uv.y - 0.5 * makeNoise(x));\n    float slope = 0.02 * (makeNoise(x + 0.0001) - makeNoise(x - 0.0001)) / 0.0002;\n    graphDist /= sqrt(slope * slope + 1.0);\n    graphDist += 0.0025;\n\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, graphDist));\n\n    fragColor = vec4(color, 1.0);\n\n    // Uncenter\n    uv += vec2(0.0, 0.5);\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.2831853072\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat sine(in float t) {\n    return sin(TAU * t);\n}\n\nfloat triangle(in float t) {\n    return abs(mod(4.0 * t - 1.0, 4.0) - 2.0) - 1.0;\n}\n\nfloat square(in float t) {\n    return 1.0 - 2.0 * mod(floor(2.0 * t), 2.0);\n}\n\nfloat makeNoise(in float time) {\n    float sound = 0.0;\n\n    time = mod(4.5 * time, 2.0);\n    if (time < 1.0) {\n        vec2 atk = vec2(0.06, 1.0);\n        vec2 dec = vec2(0.03, 0.5);\n        vec2 sus = vec2(0.15, 0.5);\n        vec2 rel = vec2(0.09, 0.0); \n\n        float envelope = 0.0;\n        float t1 = time;\n        float t2 = t1 - atk.x;\n        float t3 = t2 - dec.x;\n        float t4 = t3 - sus.x;\n        float t5 = t4 - rel.x;\n        if (t1 < atk.x) envelope = t1 / atk.x * atk.y;\n        else if (t2 < dec.x) envelope = t2 / dec.x * (dec.y - atk.y) + atk.y;\n        else if (t3 < sus.x) envelope = t3 / sus.x * (sus.y - dec.y) + dec.y;\n        else if (t4 < rel.x) envelope = t4 / rel.x * (rel.y - sus.y) + sus.y;\n\n        float waveform = sine(11.0 * time);\n        sound += waveform * envelope;\n    }\n\n    else if (time < 2.0) {\n        time -= 1.0;\n\n        vec2 atk = vec2(0.04, 1.0);\n        vec2 dec = vec2(0.02, 0.5);\n        vec2 sus = vec2(0.1, 0.5);\n        vec2 rel = vec2(0.06, 0.0); \n\n        float envelope = 0.0;\n        float t1 = mod(time, 0.45);\n        float t2 = t1 - atk.x;\n        float t3 = t2 - dec.x;\n        float t4 = t3 - sus.x;\n        float t5 = t4 - rel.x;\n        if (t1 < atk.x) envelope = t1 / atk.x * atk.y;\n        else if (t2 < dec.x) envelope = t2 / dec.x * (dec.y - atk.y) + atk.y;\n        else if (t3 < sus.x) envelope = t3 / sus.x * (sus.y - dec.y) + dec.y;\n        else if (t4 < rel.x) envelope = t4 / rel.x * (rel.y - sus.y) + sus.y;\n\n        float waveform = triangle(11.0 * time);\n        sound += waveform * envelope;\n    }\n\n    return sound;\n}", "sound_code": "vec2 mainSound(in int samp, in float time) {\n    return vec2(makeNoise(float(samp % (12 * int(iSampleRate))) / iSampleRate));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1934]]}
{"id": "DsscWn", "name": "Psychedelic Zoom 1", "author": "rceballos98", "description": "Psychedelic Zoom 1", "tags": ["zoom", "psychedelic"], "likes": 11, "viewed": 179, "published": 3, "date": "1686718057", "time_retrieved": "2024-07-30T17:49:44.466828", "image_code": "void mainImage( out vec4 c, vec2 p ) {\n    vec2 v = iResolution.xy;\n    float zoom = -5. + abs(sin(iTime * 0.05)) * 4.;  // oscillates zoom\n    p = ((p-v*.5)*.4 / v.y) / zoom; // Apply zoom\n    p += p * sin(dot(p, p)*20.-iTime) * .04;\n    c *= 0.;\n    for (float i = .5 ; i < 8. ; i++)\n        p = abs(2.*fract(p-.5)-1.) * mat2(cos(.01*(iTime+iMouse.x*.1)*i*i + .78*vec4(1,7,3,1))),\n        c += exp(-abs(p.y)*5.) * (cos(vec4(1,2,3,0)*i)*.3+.2);  // Reduced values for darker colors\n    c -= vec4(0.3, 0.3, 0.3, 0);  // Subtract base color for contrast\n    c = clamp(c, 0.0, 1.0); // Ensure colors stay within valid range\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsscWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 623]]}
{"id": "DsfyDr", "name": "Resonance of Time", "author": "Pink", "description": "Time driven progressively changing blobby psychedelic pattern", "tags": ["2d", "psychedelic", "sinusoidal", "candy"], "likes": 3, "viewed": 179, "published": 3, "date": "1686696621", "time_retrieved": "2024-07-30T17:49:45.388364", "image_code": "vec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.1,0.5);\n    vec3 b = vec3(0.5,1.0,0.15);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float zoomout = 4.0 + iTime * 0.1;\n\n    // Centered aspect corrected normalized pixel coordinates\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y) * zoomout;\n\n    float a = zoomout - length(uv);\n    float d = length(uv) - zoomout * 0.5;\n    \n    a += 0.5 + 0.5 * sin(iTime * 0.6 + uv.x);\n    d -= 0.5 + 0.5 * sin(iTime + uv.x);\n\n\n    a += 1.0 + 0.5 * cos(iTime * 1.3 + uv.y);\n    d -= 1.0 + 0.5 * cos(iTime * 1.6 + uv.y);\n    \n    d = pow(1.1 / abs(d * a), 0.1);\n    a = pow(1.1 / abs(a), 2.4);\n\n\n    vec3 col = smoothstep(0.1, 0.9, d * 0.5 + 0.5 * palette(sin( d * iTime + zoomout)));\n    col = col - a - 0.5 + 0.5 * palette(sin(a * iTime * 0.1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 71, 250], [253, 253, 310, 310, 1044]]}
{"id": "DdfyDn", "name": "test 1, learning the ropes", "author": "Yukinyan", "description": "testing how things work in GLSL", "tags": ["fractal"], "likes": 2, "viewed": 141, "published": 3, "date": "1686689156", "time_retrieved": "2024-07-30T17:49:46.206178", "image_code": "vec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d){\n\n    return a + b*cos( 6.228318*(c*t*d));\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec4 fragColour = fragColor;\n     vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n     vec2 uv0 = uv;\n     \n     vec3 finalColour = vec3(0.0);\n     \n     for (float i = 0.0; i<2.0; i++){\n     \n     \n     uv = fract(uv * 1.5) -0.5;\n     \n     float d = length(uv) * exp(-length(uv0));\n \n     vec3 col = palette((length(uv0) + iTime*0.4) ,vec3(0.821, 0.328, 0.242),vec3(0.659, 0.481, 0.896), vec3(0.612, 0.340, 0.296), vec3(2.820, 3.026, -0.273)); \n     d = sin(d * 8. + iTime)/8.;\n     d = abs(d);\n     \n     d= pow(0.01 / d, 2.0);\n     \n     finalColour += col * d;\n     \n     fragColour =vec4(finalColour, 1.0);\n     }\n\n     fragColor = fragColour;\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 100], [105, 105, 162, 162, 835]]}
{"id": "csXyDn", "name": "glsl bug #68", "author": "FabriceNeyret2", "description": "At least on OpenGL/nVidia, swapping line 13 with 14 or 15 doesn't give the same result.\nBasically, any change in the shader makes the bug disappear.\nE.g.replacing the 3 O line 13,14,15 with O.r, O.g, O.b,   or doing either #13 or #15  dep on iFrame%2 ", "tags": ["glsl", "bug"], "likes": 7, "viewed": 249, "published": 3, "date": "1686688732", "time_retrieved": "2024-07-30T17:49:47.159629", "image_code": "// acid test from https://shadertoy.com/view/mslcRM\n\nvoid mainImage( out vec4 O,  vec2 u )\n{ \n    vec2  R = iResolution.xy,\n          U = u / R.y;                        //  normalized coordinates\n    O = vec4(0);\n\n    for( float j=0.; j < 6.; j += 1./21. ) \n    {\n        float w = .1 /  ( 3. + pow( 18., sin( j+ 1e-9*iTime ) ) ), // 0.*iTime kills the bug\n              l = length( U - .1*j ) ;        // doing l = () - w then testing l<0 changes #14\n        O += float( l < w ) ;                 // these 3 lines dont yield the same result\n     // O +=        l < w ? 1. : 0. ; \n     // if        ( l < w ) O++; \n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 92, 92, 623]]}
{"id": "DsXcWn", "name": "Overcomplicating things", "author": "mrange", "description": "CC0: Overcomplicating things\nI really enjoyed the color explosion and simplicity of kishimisu's\nhttps://www.shadertoy.com/view/mtyGWy\nSo I decided to overcomplicate it!\nIt's still pretty colorful\n", "tags": ["2d"], "likes": 37, "viewed": 836, "published": 3, "date": "1686686895", "time_retrieved": "2024-07-30T17:49:48.034290", "image_code": "// CC0: Overcomplicating things\n//  I really enjoyed the color explosion and simplicity of kishimisu's\n//  https://www.shadertoy.com/view/mtyGWy\n//  So I decided to overcomplicate it!\n//  It's still pretty colorful\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 palette( float t ) {\n  return (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*t))*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\n\n// License: Unknown, author: kishimisu, found: https://www.shadertoy.com/view/mtyGWy\nvec3 kishimisu(vec3 col, vec2 p) {\n  vec2 p0 = p;\n  vec3 finalColor = vec3(0.0);\n    \n  vec2 p1 = p;\n  for (float i = 0.0; i < 4.0; i++) {\n    p1 = fract(p1 * 2.0+0.0125*TIME) - 0.5;\n\n    float d = length(p1) * exp(-length(p0));\n\n    vec3 cc = palette(length(p0) + i*.4 + TIME*.2);\n\n    d = sin(d*8. + TIME)/8.;\n    d = abs(d);\n\n    d = max(d, 0.005);\n    d = (0.0125 / d);\n    d *= d;\n\n    col += cc * d;\n  }\n\n  return col;  \n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  vec3 col = vec3(0.0);\n  mat2 rot = ROT(0.025*TIME); \n  p *= rot;\n  vec2 kp = p;\n  float r  = RESOLUTION.x/RESOLUTION.y;\n  kp.x -= r-0.125;\n  float kl = dot(kp, kp);\n  float kn = smoothKaleidoscope(kp, 0.05, 50.0);\n  kp += 0.5*sin(vec2(1.0, sqrt(0.5))*TIME*0.21);\n  kp /= r;\n  col = kishimisu(col, kp);\n  col = clamp(col, 0.0, 4.0);\n  vec3 scol = palette(0.125*TIME);\n  col += 0.025*scol*scol/max(length(kl), 0.001);\n  col -= .0033*vec3(1.0, 2.0, 3.0).zyx*kl;\n  col = aces_approx(col);\n  col = max(col, 0.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 419, 419, 472], [474, 574, 613, 613, 698], [700, 700, 739, 739, 768], [770, 770, 800, 800, 827], [830, 937, 963, 963, 1147], [1149, 1149, 1171, 1171, 1215], [1217, 1217, 1238, 1238, 1283], [1285, 1285, 1330, 1330, 1484], [1486, 1486, 1547, 1547, 1760], [1763, 1848, 1882, 1882, 2276], [2278, 2278, 2308, 2308, 2853], [2855, 2855, 2910, 2910, 3085]]}
{"id": "ddsyR7", "name": "The Love of Colour", "author": "Pink", "description": "Tribute to the beautiful sea of colour.", "tags": ["2d", "colourful"], "likes": 2, "viewed": 159, "published": 3, "date": "1686683464", "time_retrieved": "2024-07-30T17:49:49.037607", "image_code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//inline comments may not be completely accurate.\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat gaussian(float t)\n{\n    return exp(-(5.0 * pow(t - 0.5, 2.0)));\n}\n\nfloat dot2( in vec2 v ) \n{ \n    return dot(v,v); \n}\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float timeSine = 0.5 + 0.5 * sin(iTime*0.25);\n\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y) * 2.0;// + sin(iTime*10.3);\n\n    uv.x -= sin(iTime * 0.2);\n    uv.y += 0.5 + 0.25 * cos(iTime * 0.4);\n        \n    float red =   gaussian(gold_noise(uv, timeSine * 1.25)) + 2.0;\n    float green = gaussian(gold_noise(uv, timeSine * 1.025)) + 4.0;\n    float blue =  gaussian(gold_noise(uv, timeSine * 1.15)) + 8.0;\n\n    float d = abs(sdHeart(uv));\n    d = gaussian(pow(0.05 / d, 0.5));\n    float v = 1.0 / 1.0 - length(uv);\n\n    vec3 col = v * 0.5 + 0.5 + sin(iTime + uv.yyy + vec3(red, green, blue) * d) - cos(iTime*0.5 + uv.xxx + vec3(red, green, blue) * d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 412, 456, 456, 516], [518, 518, 543, 543, 589], [591, 591, 617, 617, 642], [644, 644, 672, 672, 892], [894, 894, 951, 951, 1687]]}
{"id": "cdsyzM", "name": "BC: Color Sprial", "author": "BackwardsCap", "description": "A colorful spiral", "tags": ["spiral", "color", "colorsphere"], "likes": 14, "viewed": 273, "published": 3, "date": "1686681779", "time_retrieved": "2024-07-30T17:49:50.273303", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat circle(vec2 p, float r)\n{\n    return smoothstep(3./iResolution.y,0.,length(p)-r);\n}\n\nvec3 color(vec2 p, float r, float off)\n{\n    vec2 auv = vec2(atan(p.x,p.y), length(p));\n    float time = iTime + off;\n    float o = sin(time+p.x*3.*cos(auv.x*2.)*10.)*0.01;\n    float f = cos(time - auv.x*2.);\n    float s = r + cos(time+p.y)*o*r;\n\n    return vec3(circle(p + o, s),\n                circle(p - o * f, s),\n                circle(p - o, s));\n}\n\nvec3 drawLines(vec2 p, float offset, float width)\n{\n    vec3 c = color(p, width, offset);\n    c *= (1.0 - color(p, width * 0.99, offset));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv /= 8.0;\n        \n    vec3 col = drawLines(uv, 0.0, 0.1);\n    \n    float iter = 40.0;\n    for(float i=0.0;i<iter;i++)\n    {\n        uv *= rot(3.1415927/iter);\n        uv *= 1.01;\n        col += drawLines(uv, i/iter, 0.1);\n    }\n    \n    col /= 3.0;\n            \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float fade = .45;\n    float up = 1.5;\n    float sway = 0.005;\n    col += texture(iChannel1, (uv-(up/8.75+vec2(cos(iTime),sin(iTime))*sway))*up).bgr * fade;\n    fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 174]]}
{"id": "DsscR8", "name": "Protean clouds fork", "author": "AndreiN95", "description": "Fully procedural 3D animated volume with three evaluations per step (for shading) running fast enough for 1080p rendering.\n\nFeaturing simple mouse interaction.", "tags": ["procedural", "3d", "fast", "volumetric"], "likes": 6, "viewed": 298, "published": 3, "date": "1686670152", "time_retrieved": "2024-07-30T17:49:51.257672", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarily rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    //float cl = mag2(p2.xy);\n    float cl = texture(iChannel0, p).x * 10.;//mag2(p2.xy);\n    //float cl = textureLod(iChannel1, p.xy, 0.0).x * 10.;//mag2(p2.xy);\n\n    //float cl = (1. - length((gl_FragCoord.xy/iResolution.xy - 0.5) * 2.)) * 15.;\n    float d = 0.;\n    //p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5;// + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\t//float fogC = exp(t*0.2 - 2.2);\n\t\t//col.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\t//fogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0, 2, 0);\n        \n    float dspAmp = .85;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(tgtDst)*dspAmp, tgtDst));\n    ro.x -= bsMo.x*5.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    prm1 = 1.;\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsscR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1131, 1131, 1152, 1152, 1204], [1316, 1316, 1335, 1335, 1352], [1353, 1353, 1405, 1405, 1449], [1489, 1489, 1508, 1508, 1559], [1561, 1561, 1579, 1579, 2260], [2262, 2262, 2313, 2313, 3271], [3273, 3273, 3330, 3330, 4045]]}
{"id": "ddXczM", "name": "random kd-tree  (398ch)", "author": "FabriceNeyret2", "description": "translate and move with mouse.\nregolfing https://shadertoy.com/view/4lXSWl", "tags": ["procedural", "kdtree", "mondrian", "short", "piet"], "likes": 26, "viewed": 319, "published": 3, "date": "1686662166", "time_retrieved": "2024-07-30T17:49:52.181202", "image_code": "// golfing 567 chars  2015 shader https://shadertoy.com/view/4lXSWl\n\n\n#define H(v) fract(4e4*sin(dot( v+R*I, vec2(13.46,41.74))+17.34))             // hash(seed),I=cellId\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, I,\n         m = iMouse.z>0. ?  iMouse.xy : R * (.5+.5*sin(.1*iTime+vec2(0,33))); // mouse control or demo mode\n    U.x -= 8.* (m.x - R.x/2. );                                               // translate\n    U /= ( 1. - m.y/R.y ) *4.;                                                // zoom\n    \n    for (int i; i++ < 16; ) {                                                 // browse LODs\n        I = ceil(U/R)-.5;                                                     // cell id\n        if ( H() < .2+.2*sin(iTime) ) break;                                  // random depth\n        R[ H(.1) < .5 ? 0 : 1 ] /= 3.;                                        // random dir of subdiv\n    }\n    \n    U = R/2. - abs( U - R*I );                                                // coord relative to border\n    O = min(U.x,U.y) < 2. ? vec4(0)                                           // border\n             : H(.2) < .8 ? vec4(1)                                           // bg\n             :              cos(6.3*H(1.) +vec4(0,21,23,0));                  // colored leaf\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 214, 214, 1299]]}
{"id": "csfyz7", "name": "Jiggle voronoi", "author": "nhobb", "description": "Voronoi cells that jiggle", "tags": ["voronoi"], "likes": 1, "viewed": 165, "published": 3, "date": "1686655542", "time_retrieved": "2024-07-30T17:49:53.057859", "image_code": "/* noise and hash from https://www.shadertoy.com/view/4dS3Wd */\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nvec2 randomVertex(float seed) {\n    float jigglex = 0.8 + 2.4*(sin(iTime + seed)/0.1);\n    float jiggley = 0.8 + 3.2*(cos(iTime/0.4 + seed)/0.1);\n    vec2 result = vec2(noise(seed*123.32+321.2)*1280., noise(seed*321.32+ 11.1323)*720.);\n    return vec2(result.x + jigglex, result.y + jiggley);\n}\n\nvec3 randomColour(float seed) {\n    return vec3(noise(seed*32123.2 + 213.2), noise(seed*3213.32+ 213.2), noise(123.3*seed+ 213.2));\n}\n\n\nvec3 nearestVoronoi(vec2 p) {\n    int LEN = 40;\n    \n    vec3 result = vec3(0.);\n    float nearest = 1.0e10;\n\n    for (int i=0; i<LEN; i++) {\n      float d = distance(p, randomVertex(float(i)));\n      result = step(0., nearest - d) * randomColour(float(i)) + step(0., d-nearest) * result;\n      nearest = step(0., nearest - d) * d + step(0., d-nearest) * nearest;\n    }\n    \n    \n    \n    vec3 col1 = vec3(0., 0.5, 0.2);\n    vec3 col2 = vec3(.5, .0, 0.);\n    vec3 col3 = vec3(0., .5, .5);\n    \n    float f = 1.;\n    \n    float R = 5.;\n    \n    for (int i=0; i<LEN; i++) {\n      result = result * (step(R, distance(p, randomVertex(float(i)))));\n    }\n\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;//iResolution.xy;\n    \n    // Time varying pixel color\n    //vec3 col = vec3(0.5+0.5*cos(0.1 * dist(vec2(600., 300.), uv) - iTime*20.));\n    \n    vec3 col = nearestVoronoi(fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 64, 85, 85, 152], [153, 153, 175, 175, 307], [309, 309, 340, 340, 603], [605, 605, 636, 636, 738], [741, 741, 770, 770, 1412], [1415, 1415, 1472, 1522, 1788]]}
{"id": "DdXyz7", "name": "Wandering Stars", "author": "ApeSander", "description": "This is the third shader I ever made. I tried to create something interesting using bezier curves.", "tags": ["random", "animated", "neon"], "likes": 16, "viewed": 712, "published": 3, "date": "1686655300", "time_retrieved": "2024-07-30T17:49:53.893624", "image_code": "// Function to create the colors (https://iquilezles.org/articles/palettes/)\nvec3 palette( in float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize uv with a fixed aspect ratio\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 color = palette(uv.x + iTime / 4.0);\n    \n    float d0 = 0.0;\n    for (float j = 1.0; j < 6.0; j++) { // Makes 5 groups of stars\n        for (float i = 0.0; i < 20.0; i++) { // Makes 20 stars in every group\n            // Bezier curve (https://www.youtube.com/watch?v=aVwxzDHniEw)\n            float t = (sin(iTime + i*2.0) + 1.0) / 2.0;\n            \n            // 0.84, -0.67, 1.45 and so on are just random values to make the movement look random \n            vec2 p1 = vec2(sin(iTime * 0.83 * j), cos(iTime * -0.67 * j / 2.0)); // Multiplying by j to create the kind of flower effect\n            vec2 p2 = vec2(cos(iTime * 1.45), cos(iTime * 0.78));\n            vec2 p3 = vec2(cos(iTime * -0.67), sin(iTime * 0.23));\n            vec2 p4 = vec2(sin(iTime * -0.19), sin(iTime * -0.35));\n            vec2 p5 = p1;\n\n            vec2 q1 = p1 + t * (p2 - p1);\n            vec2 q2 = p2 + t * (p3 - p2);\n            vec2 q3 = p3 + t * (p4 - p3);\n            vec2 q4 = p4 + t * (p5 - p4);\n\n            vec2 r1 = q1 + t * (q2 - q1);\n            vec2 r2 = q2 + t * (q3 - q2);\n            vec2 r3 = q3 + t * (q4 - q3);\n\n            vec2 s1 = r1 + t * (r2 - r1);\n            vec2 s2 = r2 + t * (r3 - r2);\n\n            vec2 u1 = s1 + t * (s2 - s1);\n\n            float d = length(uv - u1);\n\n            d = 0.02 / d;\n\n            if (d > d0) d0 = d;\n        }\n    }\n    \n    fragColor = vec4(color*d0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 105, 105, 292], [294, 294, 351, 397, 1875]]}
{"id": "mdscRH", "name": "Year of Truchets #036", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! ", "tags": ["2d", "warp", "truchet", "polar"], "likes": 21, "viewed": 213, "published": 3, "date": "1686654687", "time_retrieved": "2024-07-30T17:49:54.829123", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #036\n    06/13/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    mat2 r45 = rot(.7853981634);\n    \n    vec3 C = vec3(.085);\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    vec2 vv = uv;\n\n    uv = uv-vec2(.3535,0);\n    if(vv.x>-.3) {\n        // background patterns\n        vec2 ft = fract((vv*8.+vec2(T*.2,0))*rot(.78))-.5;\n        C = mix(vec3(.1),vec3(.075),mod(floor(ft.x),3.)==0.?1.:0.);\n        // warp and turn\n        float scale = 1.91;   //7.//5.41//3.5;//2.545;//1.91;//1.2726;//.6365;\n        uv *= rot(-T*.035);\n        uv = vec2(log(length(uv)), atan(uv.y, uv.x))*scale;\n        uv.x -= T*.3;\n    \n    }else{\n        vec2 ft = fract((vv*32.)*rot(.78))-.5;\n        C = mix(vec3(.075),vec3(.1),mod(floor(ft.x),3.)==0.?1.:0.);\n        uv *= 10.;\n        uv.x -= T*.3;\n    }\n\n    float px = fwidth(uv.x); \n    \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float hs = hash21(id.xy);\n\n    if(hs>.5)  q.xy *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    float wd = .01, mv = .12;\n\n    //q *= r45;\n    vec2 spc = vec2(-.5,.0);\n    vec2 p2 = vec2(length(q+spc),length(q-spc));\n    vec2 pq = p2.x<p2.y? q+spc : q-spc;\n  \n    pq *= r45;\n \n    // main pattern\n    float d = length(pq.x);\n    d=abs(d)-mv;\n    //d=1e5;\n    // alt pattern\n    if(hs>.85) d = min(length(q.x)-mv,length(q.y)-mv);\n    \n    // posts\n    float b = length(vec2(abs(q.x)-.5,q.y))-(mv*1.5);\n    b = min(length(vec2(q.x,abs(q.y)-.5))-(mv*1.5),b);\n    d = min(b,d);\n    d = max(d,-(b+.1));\n    float md = d;\n    \n    d=abs(d)-wd;\n    \n    // grid lines\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.01;\n    d2 = max(d2,-(b+.075));\n    vec3 clr = hsv2rgb(vec3((uv.x*.035),1.,.5));\n\n    // color mixdown\n    if(M.z>0.) C = mix(C,vec3(.3),smoothstep(px,-px,d2));\n\n    C = mix(C,C*.35,smoothstep(.075+px,-px,d));\n    C = mix(C,clr,smoothstep(px,-px,d));\n    C = mix(C,vec3(.0025),smoothstep(px,-px,md));\n    \n    if(vv.x<-.3&&vv.x>-.305) C = vec3(.25);\n    \n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdscRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[352, 352, 371, 371, 414], [415, 415, 437, 437, 495], [497, 514, 541, 541, 657], [659, 659, 700, 700, 2642]]}
{"id": "DdfyR7", "name": "Strange pattern of many", "author": "Wither362", "description": "I will need a table for the different colors it can make", "tags": ["trigonometry"], "likes": 0, "viewed": 135, "published": 3, "date": "1686651597", "time_retrieved": "2024-07-30T17:49:55.705779", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(fract(uv.x * iTime) / length(iMouse.xy / iResolution.xy),sin(uv.y / iTime) * 8.,tan(mod((iMouse.x + iMouse.y) / iResolution.x, .5) * uv.y * iTime) / iTime));\n\n    // Output to screen\n    fragColor = vec4(col / distance(uv.xyx, iMouse.xyx / iResolution.xyx) / 5., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 498]]}
{"id": "cdfcRM", "name": "Black holes", "author": "tuxifan", "description": "Trippy inefficient shader", "tags": ["trippy"], "likes": 3, "viewed": 160, "published": 3, "date": "1686649046", "time_retrieved": "2024-07-30T17:49:56.513619", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord*((sin(iTime*0.17)+2.0)*0.5);\n    float brightness = distance(fragCoord, iResolution.xy*0.5)/max(iResolution.x, iResolution.y);\n    fragColor = vec4(brightness*(sin(iTime)+1.1), brightness*(sin(iTime*0.8)+1.1), brightness*(sin(iTime*1.1)+0.8), brightness);\n    \n    fragCoord = fragCoord*((sin(iTime*0.76)+2.0)*0.5);\n    brightness = distance(fragCoord, iResolution.xy*0.5)/max(iResolution.x, iResolution.y);\n    fragColor /= brightness;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 522]]}
{"id": "mssyR4", "name": "Flower pattern rug", "author": "jarble", "description": "A rug with a flower pattern.", "tags": ["fractal", "flower", "carpet", "rug"], "likes": 4, "viewed": 190, "published": 3, "date": "1686632605", "time_retrieved": "2024-07-30T17:49:57.344398", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.x/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/16.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.25)+2.25+.25+.125;\n    uv.x = mod(uv.x,.25)+.25+.125;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv-t2)/1.5*sign(uv.y-uv.x)\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv-.5).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        col.x =\n            max((t2.y+t2.x),col.x)\n        ;\n        col =\n            abs(col-1.+col.x);\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "#define fmod(x,y) floor(max(mod(floor(-(x/y))*pow(2.,1.+mod(floor(x*2.),2.)),y),mod(floor(x)*3.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x/y))*pow(2.,mod(floor(x*2.),2.)),y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  float\n  s1 =\n      pow(2.,2.+fmod(time/8.,2.))\n      //pow(2.,2.-fmod(time*8.,2.))\n  ,\n  s2 = pow(2.,1.+fmod1(time/8.,2.)),\n  m1 = s1*(1.+fmod(time/s2/s1+1.,2.)),\n  t =\n      //time\n      time*s1/8.\n  ,\n  m4 = fmod1(t*s1/(1.+fmod(t/s1,2.)),s2),\n  m3 = fmod((t+m4)*s1/m1,s2);\n  /*\n  for(int i = 0; i < 3; i++){\n      t += floor(t/s2/2.);\n  }\n  */\n  t *= s1*s1/(1.+fmod(t/s1,2.));\n\n  float m2 = 1. + fmod(t/s1,s1),\n  a = 128.*pow((1.-sqrt(fract(t/s1)/m1))/4.,2.),\n  nb = time*pow(2.,(m3+m2)/5.+6.5);\n  return\n      log(abs(.5-1.*vec2(fract(nb*.998),fract(nb)))*a)\n      //log(abs(a/16. - abs(.5-1.*vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 168], [170, 170, 227, 227, 1036]]}
{"id": "cdsyz4", "name": "Mt. Fuji", "author": "djstomp", "description": "Forked from https://www.shadertoy.com/view/Wt33Wf", "tags": ["vaporwave"], "likes": 0, "viewed": 160, "published": 3, "date": "1686620188", "time_retrieved": "2024-07-30T17:49:58.087411", "image_code": "\nfloat sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + (iTime * 0.25) * 0.2 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.02;\n    uv += vec2(0.0, (iTime * 0.25) * 4.0 * (battery + 0.08));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / iResolution.y;\n    //else battery = 0.8;\n    \n    //if (abs(uv.x) < (9.0 / 16.0))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= battery * 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.85, 0.3);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + (iTime * 0.25) * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + (iTime * 0.25) * 0.1, 4.0) - 2.0;\n            float cloudTime = (iTime * 0.25) * 0.5;\n            float cloudY = -0.6;\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.21;\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 350], [352, 352, 388, 388, 698], [700, 700, 724, 724, 743], [745, 745, 810, 810, 1120], [1122, 1122, 1171, 1171, 1290], [1292, 1292, 1329, 1329, 1413], [1415, 1415, 1464, 1464, 1567], [1569, 1569, 1652, 1718, 2322], [2324, 2324, 2381, 2381, 6234]]}
{"id": "cslyR4", "name": "Endless Rainbow Gradient w/ Dots", "author": "djstomp", "description": "Smoothly interpolates over a pseudorandom color gradient over time", "tags": ["gradient", "abstract", "rainbow"], "likes": 2, "viewed": 199, "published": 3, "date": "1686616066", "time_retrieved": "2024-07-30T17:49:58.831422", "image_code": "float absin( in float f)\n{\n    return abs(sin(f));\n}\n\nvec3 timify( in vec3 a)\n{\n    float lTime = 20.+0.07*iTime;\n    return vec3(a.x*absin(lTime/5.), a.y*absin(lTime/3.), a.z*absin(lTime/1.));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 paltime( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float y_factor )\n{\n    return timify(a) + timify(b)*cos( 6.28318*(timify(c)*t+timify(d)) + y_factor );\n}\n// Modified signed distance function for multiple circles\nfloat circleSDF(vec2 p, vec2 center, float radius, int numCircles)\n{\n    float sdf = 1e3;\n    for(int i = 0; i < numCircles; i++)\n    {\n        float phase = float(i) / float(numCircles) * 2.0 * 3.1416; // Calculate phase based on current circle\n        vec2 circleCenter = center + vec2(cos(phase), sin(phase)) * 0.3; // Move the center of each circle\n        float dist = length(p - circleCenter) - radius;\n        sdf = min(sdf, dist); // Keep the minimum distance (creates a \"union\" of the circles)\n    }\n    return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    float lTime = 2.*abs(sin(iTime/11.)*1.2) + 3.;\n    // Apply zoom\n    float zoom = 3. + 2.*sin(iTime/5.)+1.+sin(2./(lTime-0.5));\n    uv /= zoom;\n    \n    // Apply camera rotation\n    float cameraRotation = abs(cos(iTime/13.))*3.14*sin(0.2+ iTime/7.); // Rotate over time\n    float cs = cos(cameraRotation);\n    float sn = sin(cameraRotation);\n    vec2 p = mat2(cs, -sn, sn, cs) * uv;\n\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    float windowSize = 0.01;\n    \n    // animate\n    p.x += .02* (lTime + cos(lTime*0.1));\n    vec3 col = paltime(max(p.x, p.y), vec3(0.8,0.5,0.4), vec3(0.2,0.4,0.2), vec3(2.0,1.0,1.0), vec3(0.0,0.25,0.25), \n        0.5*(cos(lTime+10.) + 0.8*cos(lTime+10.) + 0.45*sin(lTime+10.))*p.y*3.14159 );\n\n    // Smoothly interpolate colors\n    float edge0 = 0.1; // define minimum value of the color components\n    float edge1 = 0.9; // define maximum value of the color components\n    col = mix(vec3(edge0), vec3(edge1), smoothstep(edge0, edge1, col));\n    \n    // Add the SDF to the color\n    vec2 center = vec2(0.0); // Center of the circle\n    float radius = 0.005; // Radius of the circle\n    int numCircles = 100; // Number of circles\n    float sdf = circleSDF(p, center, radius, numCircles);\n    float line = fract(sdf * 2.0); // Create a repeating pattern of lines\n    col += vec3(line); // Add the line color to the existing color\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 33598, "src": "https://soundcloud.com/djstompzone/because-why-not?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 52], [54, 54, 79, 79, 195], [197, 197, 265, 265, 308], [310, 310, 401, 401, 487], [488, 546, 614, 614, 1072], [1074, 1074, 1131, 1131, 2607]]}
{"id": "ctKSz3", "name": "Year of Truchets #035", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n\nif slow turn AA off 1 ", "tags": ["3d", "raymarching", "truchet"], "likes": 19, "viewed": 289, "published": 3, "date": "1686592221", "time_retrieved": "2024-07-30T17:49:59.641256", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #035\n    06/12/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Square truchet with offset to match corner roundness \n    \n*/\n\n//if slow turn AA off 1 \n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n#define MAX_DIST    45.\n\nvec3 hp,hitpoint;\nfloat gid,sid,speed,tspd;\nmat2 r90,rta;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n//@iq\nfloat box(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2(d,abs(z)-h);return min(max(w.x, w.y),0.)+length(max(w,0.));\n}\n\nconst float sz = 8.5;\nconst float hf = 4.25;\nconst float scale = .1;\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    \n    //@mla inversion\n    float k = 8./dot(p,p); \n    p *= k;\n    \n    p.y += speed;\n    vec3 pp = p;\n    \n    float pid = floor((p.y+hf)/sz);\n    p.y = mod(p.y+hf,sz)-hf;\n\n    p.xz*=rot(tspd+(pid*.234));\n    pp.xz = p.xz;\n    \n    vec2 id = floor(p.xz*scale), q = fract(p.xz*scale)-.5;\n    float hs = hash21(id.xy+pid);\n    if(hs>.5)  q.xy *= r90;\n    \n    hs = fract(hs*575.3+pid);\n    const float pf = .45,wd = .1;\n    \n    vec2 p2 = vec2(length(q.xy-pf),length(q.xy+pf));\n    vec2 r = p2.x<p2.y? q.xy-pf : q.yx+pf;\n    \n    // patterns\n    float d = abs(box(r,vec2(.15))-.3)-wd;\n    float d1 = 1e5, d2=1e5, d3=1e5;\n    \n    p.y *= scale;\n    \n    if(hs>.75) {\n        d2 = length(q.x)-wd;\n        d = length(q.y)-wd;\n        \n        float ff = .125*cos(q.y*PI2)+.125;\n        float py = fract(hs*37.72)>.65? p.y-ff : p.y+ff;\n        d3 = opx(d2,py,wd);\n    } else if(hs<.25) {\n        d = length(q.x)-wd;\n        d = min(length(abs(q.xy)-vec2(.5,0))-wd,d);\n    }\n\n    d1 = opx(d,p.y,wd);\n    \n    if(d1<res.x) {\n        res = vec2(d1,2.);\n        hp = pp;\n    }\n   \n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hp = pp;\n    }\n    \n    // compensate for scaling and warp\n    res.x /= scale;\n    res.x *= 1./k;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<80;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<MIN_DIST) hit = true;\n        d += i<45? t.x*.3 : t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout float d) {\n        \n    vec3 RC = vec3(0), p = ro;\n    float m = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p,hit);\n    d = ray.x;\n    m = ray.y;\n    hitpoint = hp;\n\n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 l = normalize(vec3(.2,8,.2)-p);\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        float spec = .75*pow(max(dot(normalize(p-ro),reflect(l,n)),0.),5.);\n        vec3 h = hsv2rgb(vec3(hitpoint.y*.01,1.,.5));\n        RC = h * diff+min(shdw,spec);\n    } \n    return RC;\n}\n\nmat2 rx,ry;\n\nconst vec3 FC = vec3(.012,.098,.188);\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    speed=T*.7;\n    r90=rot(1.5707);\n    tspd=T*.012*PI2;\n    \n    // mouse\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*1.-.5)*PI;\n \n    rx =rot(-x-1.5707);\n    ry =rot(-y);\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        // ro + rd\n        vec3 ro = vec3(0,0,1.);\n        vec3 rd = normalize(vec3(uv,-1));\n\n        ro.zy*=rx;rd.zy*=rx;\n        ro.xz*=ry;rd.xz*=ry;\n\n        float d = 0.;\n\n        vec3 color = render(ro,rd,d);\n        color = mix(FC,color,exp(-2.5*d*d*d));\n        \n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKSz3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[595, 595, 613, 613, 658], [659, 659, 680, 680, 735], [736, 742, 769, 769, 838], [839, 839, 885, 885, 965], [1037, 1037, 1055, 1055, 2328], [2330, 2405, 2435, 2435, 2674], [2676, 2676, 2738, 2738, 3006], [3008, 3022, 3049, 3049, 3162], [3164, 3164, 3222, 3222, 4026]]}
{"id": "DdlyRH", "name": "Affteron_MyFirstShader", "author": "Affteron", "description": "My first steps in shader.  Repeated by kishimisu (https://www.youtube.com/watch?v=f4s1h2YETNY)", "tags": ["example"], "likes": 3, "viewed": 187, "published": 3, "date": "1686587680", "time_retrieved": "2024-07-30T17:50:00.387262", "image_code": "vec3 palette( float t ) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;    \n    vec2 uv0 = uv;    \n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime);\n\n        d = sin(d * 8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 216], [218, 218, 275, 275, 765]]}
{"id": "mdfyz8", "name": "Knitted Pattern raymarch", "author": "henrmota", "description": "Knitted pattern with raymarching. The background was done with gyroid", "tags": ["raymarch", "uv"], "likes": 22, "viewed": 517, "published": 3, "date": "1686582546", "time_retrieved": "2024-07-30T17:50:01.388585", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat2 rot(float angle) {\n    float c = cos(angle), s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat pingpong(float x, float a, float p) {\n    return a/p * (p - abs(mod(x,(2.*p)) - p) );\n}\n\nfloat knittedPattern(vec2 uv) {\n     vec2 scale = vec2(1.5, 1.);\n    vec2 scaled = uv * scale;\n\n    scaled.y += pingpong(scaled.x, 1., 1.);\n    vec2 guv = fract(scaled) - 0.5;\n    \n    float d = smoothstep(1., 0., length(guv));\n    d -= .3 * smoothstep(.2, 0.1, abs(cos((guv.x - guv.y) * 40. + cos((uv.x + uv.y) * 100.)) * 0.5));\n    d = max(0., d);\n    \n    return d;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat arm(vec3 p, vec3 a, vec3 b, float rotation) {\n    \n    p.x = abs(p.x);\n    p.xy*=rot(rotation);\n   \n    float radius = mix(.15, 0.3, smoothstep(a.x, b.x, abs(p.x)));\n    radius *= mix(.9, 1., smoothstep(0., .3, abs(p.y - 0.25)));\n    radius *= mix(1., .7, smoothstep(2., 0.15, p.y));\n    radius += 0.015 * knittedPattern(vec2(atan(p.z, p.y), p.x) * 8.) - 0.05;\n    p.x = abs(p.x);\n   \n   \n    return sdCapsule(p, a, b, radius);\n}\n\nvec2 map(vec3 p) {\n    \n    p.xz *= rot(0.7 * iTime);\n    \n    //head\n    \n    float radius = 1.;\n    radius *= mix(.9, 1., smoothstep(0., .3, abs(p.y - 0.25)));\n    radius *= mix(1., .7, smoothstep(2., 0.15, p.y));\n    radius += 0.025 * knittedPattern(vec2(atan(p.z, p.x), p.y) * 8.) - 0.05;\n    float b = sdCapsule(p, vec3(0., 1., 0), vec3(0., -1., 0.), radius);\n   \n    float a = arm(p, vec3(0.5, 0., 0.1), vec3(1.5, 0.,0.2), 0.3);\n \n\n    float d = smin(b, a, 0.15); \n    \n    float l = arm(p, vec3(.5, -1., 0.), vec3(1.5, -1.5, 0.), 0.5);\n    \n    d = smin(d, l, 0.2); \n    \n    float bodyId = 1.;\n    \n    //eyes\n    vec3 q = p;\n    q.x = abs(q.x);\n    float eyeD = length(q-vec3(0.28, 1., .73)) - 0.2;\n    \n    \n    d = smin(d, eyeD + 0.1, 0.3);\n    d = min(d, eyeD);\n    if (d == eyeD) bodyId = 2.;\n    \n    \n    //nose\n    q = p;\n    q-=vec3(0., 0.6, .73);\n    q.y -= abs(q.x) * 2.;\n    float noseD = (length(q) - 0.2) * 0.4;\n    \n    d = smin(d, noseD + 0.1, 0.3);\n    d = min(d, noseD);\n    if (d == noseD) bodyId = 3.;\n    \n    return vec2(d, bodyId);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float id = -1.;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        t += d.x;\n        id = d.y; \n        if (d.x < 0.01 || t > 100.) break;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    \n    \n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 rd, float specularFactor) {\n    vec3 light = vec3(1., 1., 1.) * 5.;\n    vec3 sky = vec3(0.1, 0.2, 0.8);\n    vec3 ground = vec3(0.4, 0.2, 0.4);\n    vec3 hemiMix = mix(ground, sky, smoothstep(-.5, .5, n.y)); \n    \n    vec3 lightDir = normalize(vec3(.5 , .5, .5));\n    \n    float diffusePower = max(0., dot(n, lightDir));\n    vec3 diffuse = diffusePower * light * 0.7;\n    \n    vec3 r = normalize(reflect(-lightDir, n));\n    float specularPower = pow(max(0., dot(rd, r)), 16.);\n    vec3 specular = specularPower * light * specularFactor;\n    \n    float fresnel = pow(1. - max(0., dot(rd, n)), 10.);\n    return 0.5 * fresnel * light + diffuse + specular ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 0., 5.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    vec2 di = rayMarch(ro, rd);\n    float d = di.x;\n    vec3 p = ro + d*rd; \n    if (d < 100.) {\n   \n        vec3 n = getNormal(p);\n        vec3 q = p;\n        q.xz *= rot(0.7 * iTime);\n        if(di.y == 1.) {\n            \n            \n            col += vec3(.3, 0.2, 0.2) * getLight(p, n, normalize(ro - p), 0.);\n            col -=  0.3 * noise(q.xy * 10.) * noise(q.xy * 20.);\n        }\n        \n         if(di.y == 2.) {\n         \n             col += fbm(q.xz * 50. - iTime) * vec3(0.1, 0.1, 0.1) * getLight(p, n, normalize(ro - p), 3.);\n            \n         }\n         \n          if(di.y == 3.) {\n         \n             col += vec3(.3, 0.05, 0.05) * getLight(p, n, normalize(ro - p), 3.);\n         }\n    } else {\n        p= fract(rd * 10.) - 0.5;\n        p.xy += iTime * 0.1;\n        p.z += 0.2 * iTime;\n        \n        vec3 color = vec3(\n             dot(cos(p * 10.), sin(p.zxy * 15.)) * 0.5 + 0.5\n        );\n        \n        \n        col = (0.1/abs(color) - .2);\n        col *= vec3(1., 1., 1.) * 0.1 * rd * rd;\n        col *= 0.5;\n    }\n    \n    col = pow(col, vec3(1./2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 216, 243, 243, 625], [650, 650, 676, 676, 1014], [1016, 1016, 1039, 1039, 1118], [1120, 1120, 1163, 1163, 1213], [1215, 1215, 1246, 1246, 1585], [1587, 1587, 1639, 1639, 1760], [1762, 1762, 1803, 1803, 1896], [1898, 1898, 1949, 1949, 2333], [2335, 2335, 2353, 2353, 3399], [3401, 3401, 3434, 3434, 3679], [3681, 3681, 3705, 3705, 3915], [3917, 3917, 3979, 3979, 4605], [4607, 4607, 4664, 4714, 6027]]}
{"id": "dtVSzw", "name": "Hybrid SDF-Voxel Traversal", "author": "gelami", "description": "Voxel traversal using a hybrid SDF-voxel method\n\nTraversal is done by doing raymarching/sphere tracing initially, switching\nto voxel traversal when the distance is less than the bounding radius of the voxel\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "raymarching", "sdf", "voxel", "traversal"], "likes": 276, "viewed": 20226, "published": 3, "date": "1686577330", "time_retrieved": "2024-07-30T17:50:02.525545", "image_code": "\n// Hybrid SDF-Voxel Traversal - gelami\n// https://www.shadertoy.com/view/dtVSzw\n\n/* \n * Voxel traversal using a hybrid SDF-voxel method\n * \n * Traversal is done by doing raymarching/sphere tracing initially, switching\n * to voxel traversal when the distance is less than the bounding radius of the voxel\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * This was much faster than octree traversal which I've done before\n * Around similar speeds with sphere tracing more or less depending on voxel size\n * \n * Other hybrid SDF-voxel traversal shaders:\n * \n * Twisted Eye (Voxelmarched) - Elyxian\n * https://www.shadertoy.com/view/ts23zy\n * \n * Moon voxels - nimitz\n * https://www.shadertoy.com/view/tdlSR8\n * \n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-31 08:11:32\n\nvec3 getCameraPos(float t)\n{\n    t += CAMERA_TIME_OFFSET;\n    return vec3(\n        (cos(t * 0.35 * CAMERA_SPEED) + sin(t * 0.25 * CAMERA_SPEED) * 0.5) * 0.55,\n        (sin(t * 0.25 * CAMERA_SPEED) + cos(t * 0.2 * CAMERA_SPEED) * 0.4) * 0.35,\n        t * CAMERA_SPEED);\n}\n\nfloat map(vec3 p)\n{\n    float d = MAX_DIST;\n    \n    float sc = 0.3;\n    \n    vec3 q = sc * p / iChannelResolution[1].xyz;\n    q -= vec3(0.003, -0.006, 0.0);\n    \n    d  = texture(iChannel1, q*1.0).r*0.5;\n    d += texture(iChannel1, q*2.0 + 0.3).r*0.25;\n    d += texture(iChannel1, q*4.0 + 0.7).r*0.125;\n    \n    float tp = smoothstep(50.0, -6.0, p.y);\n    tp = tp*tp;\n    \n    d = (d/0.875 - SURFACE_FACTOR) / sc;\n    \n    d = smax(d, p.y - MAX_HEIGHT, 0.6);\n    \n    float c = TUNNEL_RADIUS - length(p.xy - getCameraPos(p.z / CAMERA_SPEED - CAMERA_TIME_OFFSET).xy);\n    \n    d = smax(d, c, 0.75);\n    \n    return d;\n}\n\nvec3 grad(vec3 p)\n{\n    const vec2 e = vec2(0, 0.1);\n    return (map(p) - vec3(\n        map(p - e.yxx),\n        map(p - e.xyx),\n        map(p - e.xxy))) / e.y;\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec3 id;\n    int i;\n};\n\nvec3 getVoxelPos(vec3 p, float s)\n{\n    return (floor(p / s) + 0.5) * s;\n}\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, const float tmax)\n{\n    const float s = VOXEL_SIZE;\n    const float sd = s * sqrt(3.0);\n    \n    vec3 ird = 1.0 / rd;\n    vec3 iro = ro * ird;\n    vec3 srd = sign(ird);\n    vec3 ard = abs(ird);\n    \n    float t = 0.0;\n    \n    #ifdef SDF_TRAVERSAL\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = map(pos);\n        \n        if (d < EPS)\n        {\n            hit.t = t;\n            hit.id = pos;\n            hit.n = normalize(grad(pos));\n            hit.i = i;\n            return true;\n        }\n        \n        t += d;\n        \n        if (t >= tmax || (rd.y > 0.0 && pos.y > MAX_HEIGHT))\n            return false;\n    }\n    #else\n    \n    vec3 vpos = getVoxelPos(ro, s);\n    \n    bool voxel = false;\n    int vi = 0;\n    vec3 prd = vec3(0);\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 pos = ro + rd * t;\n\n        float d = map(voxel ? vpos : pos);\n        \n        if (!voxel)\n        {\n            t += d;\n            \n            if (d < sd)\n            {\n                vpos = getVoxelPos(ro + rd * max(t - sd, 0.0), s);\n                voxel = true;\n                vi = 0;\n            }\n            \n        } else\n        {\n            vec3 n = (ro - vpos) * ird;\n            vec3 k = ard * s * 0.5;\n\n            vec3 t1 = -n - k;\n            vec3 t2 = -n + k;\n\n            float tF = min(min(t2.x, t2.y), t2.z);\n            //float tN = max(max(t1.x, t1.y), t1.z);\n            \n            #if 0\n            vec3 nrd = srd * step(t2, t2.yzx) * step(t2, t2.zxy);\n            #else\n            vec3 nrd = t2.x <= t2.y && t2.x <= t2.z ? vec3(srd.x,0,0) :\n                       t2.y <= t2.z ? vec3(0,srd.y,0) : vec3(0,0,srd.z);\n            #endif\n            \n            if (d < 0.0)\n            {\n                hit.t = t;\n                hit.id = vpos;\n                hit.n = -prd;\n                hit.i = i;\n                return true;\n            } else if (d > sd && vi > 2)\n            {\n                voxel = false;\n                t = tF + sd;\n                continue;\n            }\n            \n            vpos += nrd * s;\n            prd = nrd;\n            t = tF;\n            vi++;\n        }\n        \n        if (t >= tmax || (rd.y > 0.0 && pos.y > MAX_HEIGHT))\n            return false;\n    }\n    #endif\n\n    return false;\n}\n\nvec3 triplanar(sampler2D tex, vec3 p, vec3 n, const float k)\n{\n    n = pow(abs(n), vec3(k));\n    n /= dot(n, vec3(1));\n\n    vec3 col = texture(tex, p.yz).rgb * n.x;\n    col += texture(tex, p.xz).rgb * n.y;\n    col += texture(tex, p.xy).rgb * n.z;\n    \n    return col;\n}\n\nvec3 triplanarLod(sampler2D tex, vec3 p, vec3 n, const float k, float lod)\n{\n    n = pow(abs(n), vec3(k));\n    n /= dot(n, vec3(1));\n\n    vec3 col = textureLod(tex, p.yz, lod).rgb * n.x;\n    col += textureLod(tex, p.xz, lod).rgb * n.y;\n    col += textureLod(tex, p.xy, lod).rgb * n.z;\n    \n    return col;\n}\n\nconst vec3 lcol = vec3(1, 0.9, 0.75) * 2.0;\nconst vec3 ldir = normalize(vec3(0.85, 1.2, 0.8));\n\nconst vec3 skyCol = vec3(0.353, 0.611, 1);\nconst vec3 skyCol2 = vec3(0.8, 0.9, 1);\n\nvec2 getBiome(vec3 pos)\n{\n    float snow = textureLod(iChannel3, pos.xz * 0.00015, 0.0).r;\n    snow = smoothstep(0.695, 0.7, snow);\n    \n    float desert = textureLod(iChannel3, 0.55-pos.zx * 0.00008, 0.0).g;\n    desert = smoothstep(0.67, 0.672, desert);\n    \n    return vec2(desert, snow);\n}\n\nvec3 getAlbedo(vec3 vpos, vec3 gn, float lod)\n{\n    vec3 alb = 1.0-triplanarLod(iChannel2, vpos * 0.08, gn, 4.0, lod);\n    alb *= alb;\n    \n    vec3 alb2 = 1.0-triplanarLod(iChannel3, vpos * 0.08, gn, 4.0, lod);\n    alb2 *= alb2;\n    \n    float k = triplanarLod(iChannel0, vpos * 0.0005, gn, 4.0, 0.0).r;\n    k = smoothstep(0.3, 0.25, k);\n    \n    float wk = smoothstep(MAX_WATER_HEIGHT, MAX_WATER_HEIGHT + 0.5, vpos.y);\n    float top = smoothstep(0.3, 0.7, gn.y);\n    \n    alb = alb * 0.95 * vec3(1, 0.7, 0.65) + 0.05;\n    alb = mix(alb, alb2 * vec3(0.55, 1, 0.1), top * wk);\n    \n    alb = mix(alb, smoothstep(vec3(0.0), vec3(1.0), alb2), k * (1.0 - top));\n    \n    vec2 biome = getBiome(vpos);\n    \n    vec3 snow = alb2 * 0.8 + 0.2 * vec3(0.25, 0.5, 1);\n    snow = mix(snow, vec3(0.85, 0.95, 1), top * wk * 0.5);\n    \n    alb = mix(alb, saturate(vec3(1,0.95,0.9)-alb2*0.65), biome.x);\n    alb = mix(alb, snow * 2.0, biome.y);\n    \n    vec3 dcol = vec3(0.8, 0.55, 0.35);\n    dcol = mix(dcol, vec3(0.8, 0.65, 0.4), biome.x);\n    dcol = mix(dcol, vec3(0.2, 0.6, 0.8), biome.y);\n    \n    alb = mix(alb, alb * dcol, (1.0 - wk) * mix(1.0 - k, 1.0, max(biome.x, biome.y)));\n    \n    return alb;\n}\n\nvec3 shade(vec3 pos, vec3 ldir, float lod, HitInfo hit)\n{\n    vec3 vpos = hit.id;\n    \n    vec3 g = grad(vpos);\n    float gd = length(g);\n    vec3 gn = g / gd;\n    vec3 n = hit.n;\n    \n    float dif = max(dot(n, ldir), 0.0);\n    \n    if (dif > 0.0)\n    {\n        #ifdef SDF_TRAVERSAL\n        pos += hit.n * 0.05;\n        #else\n        pos += hit.n * 1e-3;\n        #endif\n        \n        HitInfo hitL;\n        bool isHitL = trace(pos, ldir, hitL, 12.0);\n\n        dif *= float(!isHitL);\n    }\n    \n    const float s = exp2(-4.0);\n    vec3 uvw = fract(pos / s);\n    vec2 vuv = abs(n.x) * uvw.yz + abs(n.y) * uvw.xz + abs(n.z) * uvw.xy;\n    \n    vec3 col = getAlbedo(vpos, gn, lod);\n    \n    float ao = smoothstep(-0.08, 0.04, map(pos) / length(grad(pos)));\n    float hao = smoothstep(WATER_HEIGHT - 12.0, WATER_HEIGHT, pos.y);\n    \n    #ifndef SDF_TRAVERSAL\n    col *= dot(abs(n), vec3(0.8, 1, 0.9));\n    #endif\n    \n    col *= (dif * 0.6 + 0.4) * lcol;\n    \n    col *= ao * 0.6 + 0.4;\n    col *= hao * 0.6 + 0.4;\n    \n    return col;\n}\n\nvec3 shade2(vec3 pos, vec3 ldir, float lod, HitInfo hit)\n{\n    vec3 vpos = hit.id;\n    \n    vec3 g = grad(vpos);\n    float gd = length(g);\n    vec3 gn = g / gd;\n    vec3 n = hit.n;\n    \n    float dif = max(dot(n, ldir), 0.0);\n    \n    const float s = exp2(-4.0);\n    vec3 uvw = fract(pos / s);\n    vec2 vuv = abs(n.x) * uvw.yz + abs(n.y) * uvw.xz + abs(n.z) * uvw.xy;\n    \n    vec3 col = getAlbedo(vpos, gn, lod);\n    \n    float ao = smoothstep(-0.08, 0.04, map(pos) / length(grad(pos)));\n    float hao = smoothstep(WATER_HEIGHT - 12.0, WATER_HEIGHT, pos.y);\n    \n    #ifndef SDF_TRAVERSAL\n    col *= dot(abs(n), vec3(0.8, 1, 0.9));\n    #endif\n    \n    col *= (dif * 0.6 + 0.4) * lcol;\n    \n    col *= ao * 0.6 + 0.4;\n    col *= hao * 0.6 + 0.4;\n    \n    return col;\n}\n\nvec3 getSky(vec3 rd)\n{\n    vec3 col = mix(skyCol2, skyCol, smoothstep(0.0, 0.2, rd.y)) * 1.2;\n    \n    #define SUN_ANGLE_DEGREES 0.52\n    const float sunAngle = SUN_ANGLE_DEGREES * PI / 180.0;\n    const float sunCost = cos(sunAngle);\n    \n    float cost = max(dot(rd, ldir), 0.0);\n    float dist = cost - sunCost;\n    \n    float bloom = max(1.0 / (0.02 - min(dist, 0.0)*500.0), 0.0) * 0.02;\n    \n    vec3 sun = 10.0 * lcol * (smoothstep(0.0, 0.0001, dist) + bloom);\n    \n    return col + sun;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    const float fov = 80.0;\n    const float invTanFov = 1.0 / tan(radians(fov) * 0.5);\n    \n    #ifdef MOTION_BLUR\n    float mb = MOTION_BLUR * dot(pv, pv) / invTanFov * hash13(vec3(fragCoord, iFrame));\n    vec3 ro = getCameraPos(iTime + mb);\n    #else\n    vec3 ro = getCameraPos(iTime);\n    #endif\n    vec3 lo = vec3(0,0,-1);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    #ifdef STATIC_CAM\n    m = vec2(0.6, 0.45);\n    m = vec2(0.3, 0.42);\n    m = vec2(0.43, 0.48);\n    #endif\n    \n    float ax = -m.x * TAU + PI;\n    float ay = -m.y * PI + PI * 0.5;\n    \n    #ifdef STATIC_CAM\n    if (true)\n    #else\n    if (iMouse.z > 0.0)\n    #endif\n    {\n        lo.yz *= rot2D(ay);\n        lo.xz *= rot2D(ax);\n        lo += ro;\n    } else\n    {\n        #ifdef MOTION_BLUR\n        lo = getCameraPos(iTime + mb + 0.12);\n        #else\n        lo = getCameraPos(iTime + 0.12);\n        #endif\n    }\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n    \n    HitInfo hit;\n    bool isHit = trace(ro, rd, hit, MAX_DIST);\n    \n    float t = hit.t;\n    \n    vec3 pos = ro + rd * t;\n    vec3 vpos = hit.id;\n    \n    float lod = clamp(log2(distance(ro, vpos)) - 2.0, 0.0, 6.0);\n    \n    vec3 col = shade(pos, ldir, lod, hit);\n\n    const float a = 0.012;\n    const float b = 0.08;\n    float fog = (a / b) * exp(-(ro.y - WATER_HEIGHT) * b) * (1.0 - exp(-t * rd.y * b)) / rd.y;\n\n    vec2 biome = getBiome(vpos);\n\n    vec3 fogCol = vec3(0.5, 0.8, 1);\n    fogCol = mix(fogCol, vec3(1, 0.85, 0.6), biome.x);\n\n    col = mix(col, fogCol, fog);\n    \n    if (!isHit)\n    {\n        t = MAX_DIST;\n        col = getSky(rd);\n    }\n    \n    float pt = -(ro.y - WATER_HEIGHT) / rd.y;\n    \n    if (pt > 0.0 && pt < t || ro.y < WATER_HEIGHT)\n    {\n        if (!isHit)\n        {\n            col = fogCol;\n        }\n        \n        vec3 wcol = vec3(0.5, 1, 1);\n        wcol = mix(wcol, vec3(0.5,1,0.9), biome.x);\n        wcol = mix(wcol, vec3(0.2, 0.8, 1), biome.y);\n        \n        vec3 wabs = vec3(0.15,0.8,1);\n        \n        pt = ro.y < WATER_HEIGHT && pt < 0.0 ? MAX_DIST : pt;\n        \n        vec3 wpos = ro + rd * pt;\n        \n        const float e = 0.001;\n        const float wnstr = 1500.0;\n        \n        vec2 wo = vec2(1, 0.8) * iTime * 0.01;\n        vec2 wuv = wpos.xz * 0.08 + wo;\n        float wh = texture(iChannel2, wuv).r;\n        float whdx = texture(iChannel2, wuv + vec2(e, 0)).r;\n        float whdy = texture(iChannel2, wuv + vec2(0, e)).r;\n        \n        vec3 wn = normalize(vec3(wh - whdx, e * wnstr, wh - whdy));\n        \n        vec3 wref = reflect(rd, wn);\n        \n        vec3 rcol = vec3(0);\n        \n        if (ro.y > WATER_HEIGHT)\n        {\n            HitInfo hitR;\n            bool isHitR = trace(wpos + vec3(0, 0.01, 0), wref, hitR, 15.0);\n\n            rcol = isHitR ? shade2(wpos, ldir, lod, hitR) : getSky(wref);\n        }\n        \n        float spec = pow(max(dot(wref, ldir), 0.0), 50.0);\n        \n        const float r0 = 0.35;\n        float fre = r0 + (1.0 - r0) * pow(max(dot(rd, wn), 0.0), 5.0);\n        \n        if (rd.y < 0.0 && ro.y < WATER_HEIGHT)\n            fre = 0.0;\n        \n        float abt = ro.y < WATER_HEIGHT ? min(t, pt) : t - pt;\n        col *= exp(-abt * (1.0 - wabs) * 0.08);\n        \n        if (pt < t)\n        {\n        \n            col = mix(col, wcol * (rcol + spec), fre);\n        \n            vec3 wp = wpos + wn * vec3(1,0,1) * 0.2;\n            float wd = map(wp) / length(grad(wp));\n            float foam = sin((wd - iTime * 0.03) * 60.0);\n            foam = smoothstep(0.22, 0.0, wd + foam * 0.03 + (wh - 0.5) * 0.12);\n\n            col = mix(col, col + vec3(1), foam * 0.4);\n        }\n    }\n    \n    float cost = max(dot(rd, ldir), 0.0);\n    col += 0.12 * lcol * pow(cost, 6.0);\n    \n    #ifdef SHOW_NORMALS\n    col = hit.n;\n    #endif\n    \n    #ifdef SHOW_STEPS\n    col = turbo(float(hit.i) / float(STEPS));\n    \n    if (fragCoord.y < 10.0)\n        col = turbo(uv.x);\n    #endif\n    \n    col = max(col, vec3(0));\n    //col = col / (1.0 + col);\n    //col = ReinhardExtLuma(col, 5.0);\n    col = ACESFilm(col * 0.35);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define MAX_HEIGHT 5.0\n\n#define MAX_WATER_HEIGHT -2.2\n#define WATER_HEIGHT MAX_WATER_HEIGHT\n// (MAX_WATER_HEIGHT * cos(iTime*0.01))\n\n#define TUNNEL_RADIUS 1.1\n    \n#define SURFACE_FACTOR 0.42\n\n#define CAMERA_SPEED -1.5\n#define CAMERA_TIME_OFFSET 0.0\n//9.32\n\n#define VOXEL_LEVEL 4\n#define VOXEL_SIZE exp2(-float(VOXEL_LEVEL))\n\n//#define SDF_TRAVERSAL\n\n//#define STATIC_CAM\n//#define SHOW_NORMALS\n//#define SHOW_STEPS\n\n//#define MOTION_BLUR 0.03\n\n#define STEPS 512\n#define MAX_DIST 60.0\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// matplotlib colormaps + turbo - mattz\n// https://www.shadertoy.com/view/3lBXR3\nvec3 turbo(float t) {\n\n    const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n    const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n    const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n    const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n    const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n    const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n    const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[836, 836, 864, 864, 1106], [1108, 1108, 1127, 1127, 1727], [1729, 1729, 1748, 1748, 1890], [1962, 1962, 1997, 1997, 2036], [2038, 2038, 2103, 2103, 4389], [4391, 4391, 4453, 4453, 4660], [4662, 4662, 4738, 4738, 4969], [5151, 5151, 5176, 5176, 5443], [5445, 5445, 5492, 5492, 6637], [6639, 6639, 6696, 6696, 7673], [7675, 7675, 7733, 7733, 8443], [8445, 8445, 8467, 8467, 8939]]}
{"id": "mtVSRd", "name": "Lens Flare Post-Processing", "author": "gelami", "description": "Lens flare post-processing effect featuring ghosts, halo, glare, and bloom\n\nMouse drag to look around\nDefines in Common", "tags": ["lens", "post", "effect", "bloom", "chromatic", "aberration", "flare", "halo", "processing", "glare", "ghosts"], "likes": 50, "viewed": 1070, "published": 3, "date": "1686570172", "time_retrieved": "2024-07-30T17:50:03.809113", "image_code": "\n// Lens Flare Post-Processing - gelami\n// https://www.shadertoy.com/view/mtVSRd\n\n/* \n * Lens flare post-processing effect featuring ghosts, halo, glare, and bloom\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * Resources:\n * \n * Custom Lens-Flare Post-Process in Unreal Engine - Froyok\n * https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/\n * \n * Pseudo Lens Flare - John Chapman\n * http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html\n * \n * Bloom pass based from:\n * 2-Pass Buffer Bloom - gelami\n * https://www.shadertoy.com/view/cty3R3\n * \n */\n\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-06-09 09:23:00\n\nvec2 fisheye(vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    \n    const float f = 0.5;\n    const float scale = f * atan(1.0 / f);\n    float rd = length(uv) * scale;\n    float ru = f*tan(rd / f);\n    float phi = atan(uv.y, uv.x);\n    uv = (vec2(cos(phi), sin(phi)) * ru + 1.0) * 0.5;\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1);\n    \n    vec3 ro = getCameraPos(iMouse, iResolution.xy, iTime);\n    vec3 lo = getLookAtPos();\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec2 iuv = 1.0 - uv;\n    \n    const float k = length(vec2(0.5));\n    \n    float l = length(0.5 - iuv) / k;\n    \n    // Dirt texture\n    float dirt = 1.0 - textureLod(iChannel3, (pv + 1.0) * 0.5, 1.0).r;\n    dirt = dirt*dirt * 0.4 + 0.6;\n    \n    float crot = cmat[0].z + cmat[1].y + cmat[2].x;\n    \n    vec2 suv = rot2D(crot) * pv;\n    \n    // Starburst texture\n    float star = atan(suv.y, suv.x) / TAU + 0.5;\n    star = textureLod(iChannel3, vec2(star * 2.5, 0), 0.0).b;\n    star = smoothstep(0.1, 0.65, star);\n    star = mix(star, 0.1, smoothstep(1.0, 0.35, l));\n    \n    dirt *= star;\n    \n    #ifdef GHOSTS\n    float gstr = GHOSTS_OFFSET;\n    vec2 guv = (0.5 - iuv) * gstr;\n    \n    const float ca = CHROMATIC_ABERRATION_STRENGTH;\n    vec3 caStr = vec3(-px.y, 0, px.y) * ca;\n    vec2 dir = normalize(guv);\n    \n    vec3 res = vec3(0);\n    for (int i = 0; i < GHOSTS_COUNT; i++)\n    {\n        vec2 p = iuv + guv * float(i);\n        \n        float d = length(0.5 - p) / k;\n        float w = pow(max(1.0 - d, 0.0), 8.0);\n    \n        float f = texture(iChannel3, vec2(0.12 * d, 0)).b * 5.0;\n        \n        vec3 c = palette2(f) * 3.0;\n        \n        #ifdef CHROMATIC_ABERRATION\n        res += sampleDistorted(iChannel0, p, dir, caStr) * w * c;\n        #else\n        res += sampleBuffer(iChannel0, p) * w * c;\n        #endif\n    }\n    \n    col += res * dirt * GHOSTS_STRENGTH;\n    \n    #endif\n    \n    #ifdef HALO\n    const float hstr = HALO_RADIUS;\n    vec2 huv = normalize(pv) * hstr;\n    \n    vec2 fuv = fisheye(iuv);\n    float hw = length(0.5 - fract(huv / aspect + iuv)) / k;\n    hw = pow(max(1.0 - hw, 0.0), 8.0) * smoothstep(0.1, 0.0, length(pv) - hstr * 2.0) * HALO_STRENGTH;\n    \n    #ifdef CHROMATIC_ABERRATION\n    col += sampleDistorted(iChannel0, huv / aspect + iuv, dir, caStr) * hw * dirt;\n    #else\n    col += sampleBuffer(iChannel0, huv / aspect + iuv) * hw * dirt;\n    #endif\n    \n    #endif\n    \n    #ifdef BLOOM\n    vec3 bloom = vec3(0);\n    \n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 0).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 1).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 2).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 3).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 4).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 5).rgb;\n    \n    bloom /= 6.0;\n    \n    col += bloom * BLOOM_STRENGTH;\n    #endif\n    \n    #ifdef GLARE\n    col += texture(iChannel2, uv * 0.5).rgb * GLARE_STRENGTH;\n    #endif\n    \n    col *= EXPOSURE;\n    col = max(col, vec3(0));\n    \n    #ifdef SHOW_FALSE_COLOR\n    col = palette(saturate(luminance(col)));\n    \n    if (fragCoord.y < 10.0)\n        col = palette(uv.x);\n    #endif\n    \n    col = ReinhardJodie(col);\n    //col = ReinhardExtLuma(col, 2.5);\n    //col = ACESFilm(col * 0.35);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Defines\n\n#define EXPOSURE 0.7\n\n#define ENV_MAP_WHITE_POINT 100.0\n\n#define CHROMATIC_ABERRATION\n#define CHROMATIC_ABERRATION_STRENGTH 1.5\n\n#define GHOSTS\n#define GHOSTS_COUNT 4\n#define GHOSTS_OFFSET 0.2\n#define GHOSTS_STRENGTH 0.6\n\n#define HALO\n#define HALO_RADIUS 0.6\n#define HALO_STRENGTH 0.4\n\n#define GLARE\n#define GLARE_COUNT 20\n#define GLARE_STEP_SIZE 4.0\n#define GLARE_STRENGTH 0.6\n\n#define BLOOM\n#define BLOOM_MAX_LOD 6\n#define BLOOM_THRESHOLD 2.0\n#define BLOOM_STRENGTH 0.4\n\n//#define SHOW_FALSE_COLOR\n\n#define STEPS 512\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getLookAtPos()\n{\n    return vec3(0, 0, 0);\n}\n\nvec3 getCameraPos(vec4 mouse, vec2 res, float time)\n{\n    vec2 m = mouse.xy / res.xy;\n    \n    vec3 ro = vec3(0, 0, 1);\n    \n    float ax = mouse.z < 0. || mouse.x == 0. ? -0.5 + time * PI / 10.0 : -m.x * TAU + PI;\n    float ay = mouse.z < 0. || mouse.y == 0. ? -PI * 0.1 : -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += getLookAtPos();\n    \n    return ro;\n}\n\n#define TEX_BIAS 1.0\n#define TEX_SCALE 0.4\n\nvec3 sampleBuffer(sampler2D tex, vec2 uv)\n{\n    return max(textureLod(tex, uv, 2.5).rgb - TEX_BIAS, vec3(0)) * TEX_SCALE;\n}\n\nvec3 sampleBufferLod(sampler2D tex, vec2 uv, float lod)\n{\n    return max(textureLod(tex, uv, lod).rgb - TEX_BIAS, vec3(0)) * TEX_SCALE;\n}\n\nvec3 sampleDistorted(sampler2D tex, vec2 uv, vec2 dir, vec3 str)\n{\n    return vec3(\n        sampleBuffer(tex, uv + dir * str.r).r,\n        sampleBuffer(tex, uv + dir * str.g).g,\n        sampleBuffer(tex, uv + dir * str.b).b\n    );\n}\n\nvec4 SampleLod(sampler2D tex, vec2 uv, vec2 res, const int lod)\n{\n    vec2 hres = floor(res / 2.0);\n    \n    vec2 nres = hres;\n    float xpos = 0.0;\n    int i = 0;\n    for (; i < lod; i++)\n    {\n        xpos += nres.x;\n        \n        nres = floor(nres / 2.0);\n    }\n    \n    vec2 nuv = uv * vec2(nres);\n    \n    nuv = clamp(nuv, vec2(0.5), vec2(nres)-0.5);\n    nuv += vec2(xpos, 0);\n    \n    return texture(tex, nuv / res);\n}\n\n\nvec3 uvToDir(vec2 uv)\n{\n    uv -= 0.5;\n    float phi = uv.x * TAU;\n    float theta = uv.y * PI;\n    return vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta));\n}\n\nvec2 dirToUv(vec3 dir)\n{\n    float theta = atan(dir.z, dir.x);\n    float phi = atan(dir.y, length(dir.xz));\n    \n    return vec2(theta / TAU, phi / PI) + 0.5;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .25, .5)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n\n// From Jodie\n// https://www.shadertoy.com/view/4dBcD1\nvec3 ReinhardJodie(vec3 v)\n{\n    float l = luminance(v);\n    vec3 tv = v / (1.0f + v);\n    return mix(v / (1.0f + l), tv, tv);\n}\n", "buffer_a_code": "\n// Skybox pass\n\n// Formula found from\n// Inverse Aces Tonemap Operator - Chrisy\n// https://www.shadertoy.com/view/wlfyWr\nvec3 inverseReinhard(vec3 color, float exposure)\n{\n    return color / (exposure * max((1.0 - color) / exposure, 1e-3));\n}\n\nvec3 getSky(vec3 rd)\n{\n    vec3 sky = sRGBToLinear(texture(iChannel0, rd).rgb);\n    \n    sky = inverseReinhard(sky, ENV_MAP_WHITE_POINT);\n    sky /= vec3(1, 0.5, 0.4);\n    \n    vec3 dir = normalize(vec3(1, 0.5, -1));\n    \n    //sky += vec3(1) * smoothstep(0.995, 1.0, dot(rd, dir)) * 20.0;\n    \n    return sky;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = getCameraPos(iMouse, iResolution.xy, iTime);\n    vec3 lo = getLookAtPos();\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    const float invTanFov = 1.25;\n    \n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n\n    vec3 col = getSky(rd);\n    \n    fragColor = vec4(col, 1);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Bloom pass based from:\n// 2-Pass Buffer Bloom - gelami\n// https://www.shadertoy.com/view/cty3R3\n\nconst int rad = 5;\nconst float sigma = float(rad) * 0.4;\n\n#if 1\nvec4 prefilter(vec4 col)\n{\n    const float threshold = BLOOM_THRESHOLD;\n    float brightness = max(max(col.r, col.g), col.b);\n    float contrib = max(brightness - threshold, 0.0) / max(brightness, 1e-5);\n    return col * contrib;\n}\n#else\nvec4 prefilter(vec4 col)\n{\n    return col;\n}\n#endif\n\nfloat gaussian(vec2 i, float sigma) {\n    return exp(-(dot(i,i) / (2.0 * sigma*sigma)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 hres = floor(iResolution.xy / 2.0);\n        \n    vec2 res = hres;\n    float xpos = 0.0;\n    int lod = 0;\n    for (; lod < BLOOM_MAX_LOD; lod++)\n    {\n        xpos += res.x;\n        \n        if (xpos > fragCoord.x || res.x <= 1.0)\n            break;\n        res = floor(res / 2.0);\n    }\n    \n    if (fragCoord.y >= res.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    fragColor = vec4(0);\n    \n    vec2 px = 1.0 / iResolution.xy;\n    vec2 p = (fragCoord - vec2(xpos - res.x, 0)) / iResolution.xy;\n    vec2 uv = (fragCoord - vec2(xpos - res.x, 0)) / vec2(res);\n    \n    // Skip blurring LOD 0 for performance\n    #if 1\n    if (lod == 0)\n    {\n        fragColor = prefilter(textureLod(iChannel0, uv, 1.0));\n        return;\n    }\n    #endif\n    \n    float sc = exp2(float(lod));\n    float w = 0.0;\n    for (int x = -rad; x <= rad; x++)\n    {\n        for (int y = -rad; y <= rad; y++)\n        {\n            vec2 o = vec2(x, y);\n            float wg = gaussian(o, sigma);\n            vec2 p = uv + o / vec2(res);\n            \n            //p = clamp(p, 0.5 / res, (res - 0.5) / res);\n            \n            if (p == clamp(p, vec2(0.5) / res, (res - 0.5) / res))\n                fragColor += wg * prefilter(textureLod(iChannel0, p, float(lod)));\n            w += wg;\n        }\n    }\n    fragColor /= w;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// Glare pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord * 2.0;\n    \n    if (fc.x >= iResolution.x || fc.y >= iResolution.y)\n        discard;\n\n    vec2 uv = fragCoord / iResolution.xy * 2.0;\n    \n    #ifdef GLARE\n    \n    vec2 gdir = normalize(vec2(sqrt(0.5))) / iResolution.xy;\n    vec2 gdir2 = normalize(vec2(-1, 1)) / iResolution.xy;\n    \n    vec3 glare = vec3(0);\n    float glarew = 0.0;\n    \n    for (int i = -GLARE_COUNT; i <= GLARE_COUNT; i++)\n    {\n        float d = float(i) * GLARE_STEP_SIZE;\n        vec2 p = uv + gdir * d;\n        vec2 p2 = uv + gdir2 * d;\n        \n        float k = float(i) / float(GLARE_COUNT);\n        \n        vec3 c = palette2(k * 3.0) * 0.8 + 0.2;\n        \n        const float sigma = float(GLARE_COUNT) * GLARE_STEP_SIZE * 0.45;\n        float w = exp(-d*d / (2.0 * sigma*sigma));\n        //glare += textureLod(iChannel0, p, 1.0).rgb;\n        //glare += textureLod(iChannel0, p2, 1.0).rgb;\n        \n        glare += sampleBufferLod(iChannel0, p, 1.0) * w * c;\n        glare += sampleBufferLod(iChannel0, p2, 1.0) * w * c;\n        glarew += w;\n    }\n    \n    vec3 col = glare / (2.0 * glarew);\n    \n    fragColor = vec4(col, 1);\n    \n    #else\n    \n    fragColor = vec4(0,0,0,1);\n    \n    #endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[700, 700, 723, 723, 992], [994, 994, 1051, 1051, 4397]]}
{"id": "cdXcz8", "name": "Train (fast moving lines)", "author": "Wither362", "description": "The shader will automatically detect if your frame rate is good enough, if it isnt, it will turn red.\nUsing trigonometry and the formula of the circle.", "tags": ["lines", "shader", "framerateinfluence"], "likes": 0, "viewed": 128, "published": 3, "date": "1686553758", "time_retrieved": "2024-07-30T17:50:04.596009", "image_code": "float d(in float x) {\n    return x - (x * x);\n}\nvec3 r(in vec3 x) {\n    vec3 g = x - 0.1;\n    return vec3(d(g.x * 2.0), d(g.y * 2.), d(g.z * 2.)) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(vec3(1.1, 1.1, 1.1) * vec3(1.05,iFrameRate / 60.,iFrameRate / 60.) * sqrt(r((uv.y - abs(tanh((mod(iTime, 42.)))))\n      + vec3(1,1,1) / abs(tan(d(iTime + uv.x))))), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 47], [48, 48, 67, 67, 153], [155, 155, 212, 262, 520]]}
{"id": "DdXcR8", "name": "Fork Simple Mus notdaniel 389", "author": "notdaniel", "description": "Simple Music Visualizer", "tags": ["music", "bars"], "likes": 3, "viewed": 179, "published": 3, "date": "1686546393", "time_retrieved": "2024-07-30T17:50:05.562425", "image_code": "const vec3 COL_LOW = vec3(0.3,0.3,1.0);\nconst vec3 COL_MID = vec3(0.3,1.0,0.3);\nconst vec3 COL_HIGH = vec3(1.0,0.3,0.3);\nconst float NUM_BARS = 32.0;\n\nfloat discretize(float x, float nbars) {\n    return (floor(x * nbars) + 0.5)/nbars;\n}\n\nfloat get_sample_gain(float offset) {\n    return texture(iChannel0, vec2(offset, 0.75)).x;\n}\n\nfloat get_freq_gain(float freq) {\n    return texture(iChannel0, vec2(freq, 0.25)).x;\n}\n\nfloat get_overall_gain() {\n    float gain = 0.0;\n    for(float x = 0.0; x<1.0; x += 1.0/NUM_BARS)\n        gain += texture(iChannel0, vec2(discretize(x, NUM_BARS), 0.25)).x;\n    gain /= NUM_BARS;\n    return gain;\n}\n\nvec3 mix3(vec3 a, vec3 b, vec3 c, float x) {\n    return mix(b, c, (x-0.5)*2.0) * step(0.5, x) +\n           mix(a, b, x*2.0) * step(x, 0.5) ;\n}\n\nvec3 draw_background(vec2 uv) {\n    vec3 col = vec3(get_sample_gain(uv.x),\n                    get_freq_gain(uv.y),\n                    sin(iTime*30.0)*min(get_overall_gain()*2.0, 1.0));\n    return col * 0.2;\n}\n\nvec3 draw_bars(vec2 uv) {\n    uv.y *= 2.0;\n    float freq = discretize(uv.x, NUM_BARS);\n    float gain = get_freq_gain(freq);\n    vec3 col = mix3(COL_LOW, COL_MID, COL_HIGH, gain);\n    float cut = step(uv.y, max(gain, 0.01));\n    return col * cut;\n}\n\nvec3 draw_wave(vec2 uv) {\n    float gain = get_sample_gain(uv.x);\n    uv = (uv - 0.5)*4.0;\n    uv.y -= 1.0;\n    uv.y += gain - 0.5;\n\tfloat line_width = 2.0/iResolution.y;\n    float dist = length(uv.y) - line_width;\n    float cut = smoothstep(0.01, 0.0, dist);\n    vec3 col = mix3(COL_LOW, COL_MID, COL_HIGH, gain);\n    return col * cut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = draw_background(uv);\n    col += draw_bars(uv);\n    col += draw_wave(uv);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 33589, "src": "https://soundcloud.com/bt/mercury-solace-helsloot-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 191, 191, 236], [238, 238, 275, 275, 330], [332, 332, 365, 365, 418], [420, 420, 446, 446, 633], [635, 635, 679, 679, 777], [779, 779, 810, 810, 989], [991, 991, 1016, 1016, 1240], [1242, 1242, 1267, 1267, 1580], [1582, 1582, 1639, 1639, 1801]]}
{"id": "DsfyR8", "name": "Fork Soap Bubbl notdaniel 213", "author": "notdaniel", "description": "playing around with shaders. Killing time. Having fun", "tags": ["raymarching", "simple", "music"], "likes": 1, "viewed": 192, "published": 3, "date": "1686545223", "time_retrieved": "2024-07-30T17:50:06.345332", "image_code": "mat3 rotateYmat(float ang)\n{\n    return mat3(cos(ang), 0.0, sin(ang),\n                0.0, 1.0, 0.0,\n                -sin(ang), 0.0, cos(ang));\n}\nmat3 rotateXmat(float ang)\n{\n    return mat3(1.0, -0.0, 0.0,\n                0.0, cos(ang), -sin(ang),\n                0.0, sin(ang), cos(ang));\n}\n\nmat3 rotateZmat(float ang)\n{\n    return mat3(cos(ang), -sin(ang), 0.0,\n                sin(ang), cos(ang), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat map( vec3 p, vec3 origin, float s )\n{    \n    vec3 offset = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\n\tfloat d = length(p + offset - origin)- s;\n\toffset = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\n    for(int i = 0; i < 3; i++)\n    {\n        \n        float prism2 = length(p + offset*float(i) - origin)- s;\n        d = max(d, -prism2);\n    }\n  \treturn d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    mat3 rotation = //mat3(1.0);\n      rotateXmat(iTime*0.4)*rotateYmat(iTime*0.5);\n    vec3 direction = normalize(vec3(uv.x,uv.y, 1.0)*rotation);\n\n\n   \n    \n    float t = 0.0;\n\tvec3 p;\n    vec3 finalColor; \n\t\n    vec3 origin = vec3(0.,0.,-4.)*rotation;\n    vec3 offset;\n    vec3 sphereOrigin = vec3(0., 0., 0.0);\t\t\t\t\n\n    vec4 sound = texture (iChannel0,vec2(fragCoord.x/iResolution.x, 0.75));      \n    float soundColor = texture (iChannel0,vec2(0.5, 0.75)).x;   \n \n    vec3 color = vec3(.5 + sin(uv.x+iTime +soundColor*50.)*.4,.5 +cos(uv.y+iTime + soundColor*5.)*.5,.5);\n    for (int k = 0; k <15; k++)\n    {\n        p = origin + t*direction;\n        float d = map(p,sphereOrigin, 2.0);\n\n        {\n            vec3 directionalOffset = -normalize(p)*sound.x*normalize(vec3(uv, 1.0));\n            vec3 position = p + directionalOffset;\n            float radius = 0.1+float(k)*.5;        \n            float lineThickness = 0.02 + float(k)*0.01;\n            //position.y += position.y*abs(uv.x);\n            float distanceFromCenter = length(position);\n            float condition = step( distanceFromCenter, radius)\n                - step(distanceFromCenter, radius - lineThickness);\n            finalColor += color*condition;\n        }\n\n        t += d;\n    }\n    float fog = 1.0/(1.0+t*t*0.1);\n    fragColor = vec4(finalColor+color*vec3(fog), fog);    \n    \n}", "image_inputs": [{"id": 33588, "src": "https://soundcloud.com/bt/mercury-solace-helsloot-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 145], [146, 146, 174, 174, 292], [294, 294, 322, 322, 439], [441, 441, 484, 484, 842], [843, 843, 900, 900, 2371]]}
{"id": "cdXcR8", "name": "Fork Circle Mus notdaniel 215", "author": "notdaniel", "description": "Circle Music Visualizer V2", "tags": ["musicvisualizer"], "likes": 0, "viewed": 139, "published": 3, "date": "1686545220", "time_retrieved": "2024-07-30T17:50:07.101311", "image_code": "#define bars 70.0\t\t\t\t// How many buckets to divide spectrum into\n#define barSize 1.0 / bars\t\t// Constant to avoid division in main loop\n#define barGap 0.1 * barSize\t// 0.1 represents gap on both sides, so a bar is\n#define sampleSize 2.0\t\t\t// How accurately to sample spectrum, must be a factor of 1.0\n#define PI 3.14159265359\n#define circleRadius 0.4;\n\n// used\n// https://www.shadertoy.com/view/XdX3z2\n\n// atan2 en lerp:\n// http://http.developer.nvidia.com/Cg/index_stdlib.html\n\n// colors\n// https://color.adobe.com/nl/Mijn-Kuler-thema-color-theme-4149936/?showPublished=true\n\n#define c1 vec4(0.24)\t\t\t\t// grey\n#define c2 vec4(.71,.32,.36,1.0)\t// red\n#define c3 vec4(.91,.64, .0,1.0)\t// yello\n#define c4 vec4(.27,.48,.44,1.0)\t// green\n#define c5 vec4(.21,.40,.51,1.0)\t// blue\n\n#define colorOnCenter c3\n#define colorOff c5\n#define colorOn c2\n    \n\nfloat lerp(float a, float b, float t)\n{\n  return a + t*(b-a);\n}\n\nvec4 lerp(vec4 a, vec4 b, float t)\n{\n  return a + t*(b-a);\n}\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.0) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.0) ? -t3 : t3;\n\n  return t3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / vec2(iResolution.y,iResolution.y);\n    \n    // calculate stuff\n    vec2 center = vec2((0.5*(iResolution.x/iResolution.y)),0.5);\n    float deltaYFromCenter = center.y - uv.y;\n    float deltaXFromCenter = center.x - uv.x;\n    \n    // create music map red (angle center)\n\tvec4 musicMap;\n    float angleFromCenter = atan2(deltaYFromCenter,deltaXFromCenter);  \n    musicMap.r = (angleFromCenter+PI)/(PI*2.0);\n    \n    // create music map blue (dist center)\n    float distFromCenter = sqrt((deltaYFromCenter*deltaYFromCenter)+(deltaXFromCenter*deltaXFromCenter));\n    float circleFromCenter = (distFromCenter*3.0);\n    circleFromCenter = circleFromCenter-circleRadius;\n    musicMap.b = circleFromCenter;\n    \n    if(musicMap.b < 0.0){\n        fragColor = colorOnCenter;\n    }else{\n\n        // use music map red\n        float musicChannelnput = texture( iChannel0, vec2( musicMap.r,0.0)).r;\n\n        // Get the starting x for this bar by rounding down\n        float barStart = floor(musicMap.r * bars) / bars;\n\n        // Sample spectrum in bar area, keep cumulative total\n        float intensity = 0.0;\n        for(float s = 0.0; s < barSize; s += barSize * sampleSize) {\n            intensity += texture(iChannel0, vec2(barStart + s, 0.0)).r;\n        }\n        intensity *= sampleSize;\n        if(musicMap.r - barStart < barGap || musicMap.r > barStart + barSize - barGap) {\n            intensity = 0.0;\n        }\n\n        // use music map blue\n        float onOff = musicMap.b-intensity;\n        onOff = clamp(onOff,-0.5,0.5); \n        onOff = floor(onOff+1.0);\n        fragColor = lerp(colorOn, colorOff,onOff);\n\n    }\n    // used to debug music map\n    // fragColor = musicMap;\n}\n\n\n", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[846, 846, 885, 885, 909], [911, 911, 947, 947, 971], [973, 973, 1004, 1004, 1549], [1551, 1551, 1608, 1640, 3344]]}
{"id": "ddlcRr", "name": "Eye of the Shader", "author": "isaacchurchill", "description": "The output of line segment SDFs get adjusted and added up. The result is fed into a palette function that determines the color.", "tags": ["2d", "eye", "spiral", "rainbow"], "likes": 5, "viewed": 185, "published": 3, "date": "1686534238", "time_retrieved": "2024-07-30T17:50:07.853300", "image_code": "#define PI 3.14159265\n\n///////////////////////////////////////////////////\n\n// Line segment SDF by iq\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n///////////////////////////////////////////////////\n\nmat2 rotmat(float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, s, -s, c);\n}\n\nvec3 palette(float x)\n{\n/*    return vec3(1.0 - 1.0 / exp(x * 1.5),\n                1.0 - 1.0 / exp(x * 0.7),\n                1.0 - 1.0 / exp(x * 0.3));*/\n      return 0.5 + 0.5 * sin(x - 2.0 + vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    p /= 1.3;\n    float plen = length(p);\n    float x = 1.0 / (1.2 + plen); // Slight color gradient\n    x += exp(abs(plen - mod(iTime, 2.0)) * -50.0 + 1.5); // Expanding rings\n    for (float t = 0.0; t < PI * 2.0; t += PI / 8.0) {\n        vec2 a = vec2(-0.5, 0.3);\n        vec2 b = vec2(0.5, 0.2);\n        vec2 offs = vec2(0.2, 0.0);\n        mat2 m = rotmat(iTime);\n        a = (a + offs) * m - offs;\n        b = (b + offs) * m - offs;\n        x += exp(sdSegment(p * rotmat(t), a, b) * -50.0 + 1.0); // Accumulate adjusted line SDF\n    }\n    vec3 col = palette(x) / (1.0 + pow(plen, 2.5)); // Palette color divided by gradient factor\n    col *= smoothstep(0.03, 0.06, plen); // Black dot\n    col += palette(atan(p.y,p.x) + iTime * 4.0) * smoothstep(-0.0075, 0.0, 0.0025-abs(plen - 0.045)); // Rainbow center\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 207, 207, 326], [381, 381, 403, 403, 479], [481, 481, 504, 635, 690], [692, 692, 749, 749, 1657]]}
{"id": "dslyzn", "name": "Barcode waterfall", "author": "nhobb", "description": "5px waterfall", "tags": ["pixel"], "likes": 0, "viewed": 126, "published": 3, "date": "1686528209", "time_retrieved": "2024-07-30T17:50:08.697044", "image_code": "\n\nfloat PIXEL = 5.;\n\n\n/* uv from -1 to 1 but stepped by a pixel resolution*/\n/* horizontally goes further than -1, 1 because it's wider */\nvec2 pixelCoord(vec2 fragCoord) {\n  int ix = int(floor(fragCoord.x / PIXEL));\n  int iy = int(floor(fragCoord.y / PIXEL));\n  float scaling = iResolution.y / PIXEL;\n  vec2 center = vec2(iResolution.x / iResolution.y, 1.0);\n  float x = float(ix)/scaling*2.0 - center.x;\n  float y = float(iy)/scaling*2.0 - center.y;\n  return vec2(x,y);\n}\n\n\n/* noise and hash from https://www.shadertoy.com/view/4dS3Wd */\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = pixelCoord(fragCoord);\n\n    float bg = 0.9*step(0.4,noise((uv.y-floor(iTime*2.)/PIXEL/2.)*1132.23))+0.7;\n\n    \n    vec3 col = bg*vec3(0.8);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 139, 172, 172, 473], [476, 540, 561, 561, 628], [629, 629, 651, 651, 783], [786, 786, 843, 843, 1031]]}
{"id": "DlyXz3", "name": "langtons ant", "author": "hexagon8899", "description": "go to the \"common\" tab to change the rules.", "tags": ["ant", "langtonsant"], "likes": 1, "viewed": 126, "published": 3, "date": "1686521294", "time_retrieved": "2024-07-30T17:50:09.554751", "image_code": "\n\nvoid mainImage( out vec4 col, in vec2 pos ) {\n    vec2 RES = iResolution.xy/2.;\n    pos -= RES;\n    pos /= SCALE;\n    pos += RES;\n    pos = floor( pos );\n    \n    ivec2 xy = ivec2(pos);\n    vec4 curr = texelFetch(iChannel0, xy, 0);\n    \n    col = (curr.xxxx + 1.) / float(RULE_COUNT+3);\n    vec2 diff = abs(curr.yz-pos);\n    if ( max(diff.x, diff.y)< .5 ) {\n        col = vec4(1,0,0,1);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define F 0.\n#define B 2.\n#define L 1.\n#define R 3.\n#define RR R,R\n#define LL L,L\n#define FF F,F\n#define BB B,B\n/*------------------change these------------------*/\n\nconst float SCALE = 5.;\n\n// uncomment a line to select it\nconst float rules[] = float[](\n//R,L /*\n//L,R,R,L /*\n//L,L,L,L,R /*\nR,L\n//*/\n);\n\nconst vec2 movements[] = vec2[](\n    vec2( 1, 0),\n    vec2( 0, 1),\n    vec2(-1, 0),\n    vec2( 0,-1)\n);\n/*------------------change these------------------*/\n\n\n\n\n\nconst int RULE_COUNT = rules.length();\nconst int MOVEMENT_COUNT = movements.length();\n\n\n", "buffer_a_code": "void mainImage( out vec4 col, in vec2 pos ) {\n    pos = floor(pos); \n    ivec2 xy = ivec2(pos);\n    vec4 curr = texelFetch(iChannel0, xy, 0);\n\n    col = curr;\n    \n    \n    float antpix = texelFetch(iChannel0, ivec2(col.yz), 0).x;\n    \n    vec2 diff = abs(curr.yz-pos);\n    \n    if ( max(diff.x, diff.y) < 1. ) {\n        col.x = mod( curr.x  + 1. , float(RULE_COUNT));\n    }\n    \n    col.w += rules[ int( antpix ) % RULE_COUNT ];\n    col.yz = col.yz + movements[ int( col.w ) % MOVEMENT_COUNT ];\n    \n    \n    \n    \n    \n    if (iFrame == 0) { \n        col = vec4( 0, iResolution.xy/2. , 2 );\n    }\n    \n  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 47, 47, 396]]}
{"id": "msXyRr", "name": "firstt", "author": "Your_Death27", "description": "first one made ", "tags": ["trippy"], "likes": 1, "viewed": 112, "published": 3, "date": "1686518706", "time_retrieved": "2024-07-30T17:50:10.304745", "image_code": "vec3 palette( float t){\n    vec3 a = vec3(1.088 ,0.288 ,0.458);\n    vec3 b = vec3(0.595, 0.595, 0.595); \n    vec3 c = vec3(3.449, 3.735, 0.903);\n    vec3 d = vec3(1.127, -0.833, -0.073);\n    \n    return a + b*cos (4.28318*(c*t*d) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =(fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0 ; i < 4.0 ; i++){\n    \n    uv = fract(uv * 1.5)- 0.5;\n    uv *= 1.5;\n    \n    float d =length(uv) * exp(-length(uv0));\n\n    vec3 col= palette(length(uv0) + iTime*.4);\n\n    d = sin (d*8. + iTime)/9.;\n    d = abs(d);\n\n    d = pow(0.01 / d, 1.4);\n    \n    finalColor += col * d;\n    }\n    fragColor = vec4(finalColor , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 235], [237, 237, 293, 293, 762]]}
{"id": "DdlyRr", "name": "Fork Wind Waker lush3dash1 877", "author": "lush3dash1", "description": "Wind Waker Shader Clone Recolor. Credit to PolyFlare for original", "tags": ["3d", "waves", "sea", "water", "ocean", "zelda"], "likes": 5, "viewed": 164, "published": 3, "date": "1686518056", "time_retrieved": "2024-07-30T17:50:11.081668", "image_code": "// \"Wind Waker Ocean\" by @Polyflare (29/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Source code for the texture generator is available at:\n// https://github.com/lmurray/circleator\n\n//-----------------------------------------------------------------------------\n// User settings\n\n// 0 = No antialiasing\n// 1 = 2x2 supersampling antialiasing\n#define ANTIALIAS 1\n\n// 0 = Static camera\n// 1 = Animate the camera\n#define ANIMATE_CAM 0\n\n// 0 = Do not distort the water texture\n// 1 = Apply lateral distortion to the water texture\n#define DISTORT_WATER 1\n\n// 0 = Disable parallax effects\n// 1 = Change the height of the water with parallax effects\n#define PARALLAX_WATER 1\n\n// 0 = Antialias the water texture\n// 1 = Do not antialias the water texture\n#define FAST_CIRCLES 1\n\n//-----------------------------------------------------------------------------\n#define WATER3_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER4_COL vec3(0.0, 0.4180, 0.6758)\n\n#define WATER_COL vec3(0.374, 0.8453, 0.5305)\n#define WATER2_COL vec3(0.374, 0.8180, 0.4758)\n#define FOAM_COL vec3(0.5125, 0.9609, 0.9648)\n#define FOG_COL vec3(0.7006, 0.9453, 0.9336)\n#define SKY_COL vec3(0.0, 0.8203, 1.0)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n#if FAST_CIRCLES\n    return dot(c, c) < s ? -1.0 : 0.0;\n#else\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n#endif\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv, vec3 cdir)\n{\n    uv *= vec2(0.25);\n    \n#if PARALLAX_WATER\n    // Parallax height distortion with two directional waves at\n    // slightly different angles.\n    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset\n    float h = sin(uv.x + iTime); // Height at UV\n    uv += a * h;\n    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);\n    uv += a * h;\n#endif\n    \n#if DISTORT_WATER\n    // Texture distortion\n    float d1 = mod(uv.x + uv.y, M_2PI);\n    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);\n    d1 = iTime * 0.07 + d1;\n    d2 = iTime * 0.5 + d2;\n    vec2 dist = vec2(\n    \tsin(d1) * 0.15 + sin(d2) * 0.05,\n    \tcos(d1) * 0.15 + cos(d2) * 0.05\n    );\n#else\n    const vec2 dist = vec2(0.0);\n#endif\n    \n    vec3 ret = mix(WATER_COL, WATER2_COL, waterlayer(uv + dist.xy));\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 pixpos;\n    pixpos.xy = uv - 0.5;\n    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction\n    pixpos.z = -0.6; // Focal length (Controls field of view)\n    return normalize(pixpos);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 qvec = q.xyz;\n    vec3 uv = cross(qvec, v);\n    vec3 uuv = cross(qvec, uv);\n    uv *= (2.0 * q.w);\n    uuv *= 2.0;\n    return v + uv + uuv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if ANTIALIAS\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n        \tvec2 offset = vec2(0.5) * vec2(x, y) - vec2(0.25);\n#else\n        \tvec2 offset = vec2(0.0);\n#endif\n            // Camera stuff\n            vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n            vec3 cpos = vec3(0.0, 7.0, 10.0); // Camera position\n            vec3 cdir = pixtoray(uv);\n            cdir = quatmul( // Tilt down slightly\n                vec4(-0.19867, 0.0, 0.0, 0.980067), cdir);\n#if ANIMATE_CAM\n            // Rotating camera\n            float cost = cos(iTime * -0.05);\n            float sint = sin(iTime * -0.05);\n            cdir.xz = cost * cdir.xz + sint * vec2(-cdir.z, cdir.x);\n            cpos.xz = cost * cpos.xz + sint * vec2(-cpos.z, cpos.x);\n#endif\n\n            // Ray-plane intersection\n            const vec3 ocean = vec3(0.0, 1.0, 0.0);\n            float dist = -dot(cpos, ocean) / dot(cdir, ocean);\n            vec3 pos = cpos + dist * cdir;\n\n            vec3 pix;\n            if(dist > 0.0 && dist < 100.0) {\n                // Ocean\n                vec3 wat = water(pos.xz, cdir);\n                pix = mix(wat, FOG_COL, min(dist * 0.01, 1.0));\n            } else {\n                // Sky\n                pix = mix(FOG_COL, SKY_COL, min(cdir.y * 4.0, 1.0));\n            }\n#if ANTIALIAS\n        \tfragColor.rgb += pix * vec3(0.25);\n    \t}\n    }\n#else\n    fragColor.rgb = pix;\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlyRr.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1241, 1241, 1280, 1280, 1467], [1469, 1538, 1565, 1565, 6032], [6034, 6081, 6113, 6113, 6970], [6972, 7019, 7043, 7043, 7248], [7250, 7286, 7316, 7316, 7467]]}
{"id": "cdsczn", "name": "Thing (smth like a donut)", "author": "Wither362", "description": "Trying to approve maths.", "tags": ["donut"], "likes": 0, "viewed": 71, "published": 3, "date": "1686517080", "time_retrieved": "2024-07-30T17:50:11.830665", "image_code": "float f(in float x) {\n    return sqrt(x - (x * x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 v = uv / 2.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime + sin(uv.xyx) + vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(f(distance(vec2(1,1) * fract(abs(sin(cos(iTime)))), uv)) * col * 2.0 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 53], [55, 55, 112, 162, 457]]}
{"id": "msXczr", "name": "Cool party", "author": "Wither362", "description": "A lighting effect using trigonometry, functions and more.", "tags": ["lighteffect", "colorshader"], "likes": 1, "viewed": 146, "published": 3, "date": "1686513709", "time_retrieved": "2024-07-30T17:50:12.575674", "image_code": "const vec3 color = vec3(0.999999, 0.5, 0.99999999);\nconst float lightAmount = 0.05;\nconst vec2 lightPoint = vec2(0.5, 0.5);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(vec3(\n        color / distance(uv, lightPoint) * vec3(0.5 * abs(cos(iTime) * sin(iTime)) + 0.1,\n        0.4 * abs(sin(iTime) / tan(iTime)) + 0.1,\n        0.05 * abs(cos(iTime * iTime * iTime)) + 0.5))\n      * lightAmount * min(iTime * 0.5, 12.0) * vec3(1.0, 1.0, 1.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 183, 233, 597]]}
{"id": "msfczn", "name": "1 - First", "author": "sir_geronimo", "description": "First ever shared, following kishimisu video.\n\nhttps://youtu.be/f4s1h2YETNY", "tags": ["sirgeronimo"], "likes": 2, "viewed": 108, "published": 3, "date": "1686510193", "time_retrieved": "2024-07-30T17:50:13.405455", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.5, 1.5, 1.5);\n    vec3 d = vec3(0.27, 0.42, 0.56);\n\n    return a + b*cos(6.25*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    float time = iTime * 0.4;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.75) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + time + i);\n\n        d = sin(d * 5.0 + iTime);\n        d = abs(d);\n\n        d = pow(0.1/d, 1.01);\n\n        finalColor += col * d;\n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 201], [203, 203, 260, 310, 838]]}
{"id": "msfcRn", "name": "Playing #3", "author": "matheusgirola", "description": "Shader using a rouding cross and fractal. Experimented a lot with color combinations and a like a lot of them, but a think this one gives a good vibe as well.", "tags": ["shader"], "likes": 1, "viewed": 96, "published": 3, "date": "1686508767", "time_retrieved": "2024-07-30T17:50:14.239226", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(3.0, 2.0, 2.5);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdRoundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);               // k should be const/precomputed at modeling time\n    \n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :  // circular arc\n           sqrt(min(dot2(p-vec2(0,h)),     // top corner\n                    dot2(p-vec2(1,0))));   // right corner\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.35;\n    m *= 1.35;\n    vec3 finalColor = vec3(0.0);\n    \n      \n    for(float i = 0.0; i<2.0; i++){\n        \n        // animate\n        float he = 0.501-0.300*cos(iTime*2.1+1.0);\n        float ra = 0.100+0.100*sin(iTime*2.4+2.0);\n        \n        // fract the screen, iTime makes appear that \n        //the forms are getting close to screen\n        p = fract(p*(1.2 + 0.25*sin(iTime*0.5))) -0.5;\n\n        // compute\n        float d = sdRoundedCross( p, he ) - ra;\n        \n        vec3 col = palette(4.*length(p) + 0.1*iTime);\n        col *= 0.9 - exp(-3.0*abs(d)*i);\n        col *= 1.2 + 1.2*cos(100.0*d);\n        col = mix( col, vec3(0.5), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n        if( iMouse.z>0.001 )\n        {\n        d = sdRoundedCross(m, he) - ra;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n        }\n\n\n        finalColor += col;\n    }\n    \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 64, 64, 244], [246, 246, 271, 271, 290], [291, 291, 338, 338, 674], [676, 676, 733, 733, 1899]]}
{"id": "DlKXDd", "name": "11-06-2023 - 2 - Hallucinations", "author": "Eise", "description": "A cool pattern of circles.", "tags": ["circles", "hallucinations", "pattern", "cool"], "likes": 3, "viewed": 191, "published": 3, "date": "1686481869", "time_retrieved": "2024-07-30T17:50:14.982239", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 finCol = vec3(0.0);\n    vec3 col = vec3(0.8, 0.4, sin(iTime));\n\n    uv = fract(uv * 1.2);\n    uv -= 0.5;\n    float d = fract(length(uv) * 5.0 + iTime);\n    d = smoothstep(-0.1, 0.9, d);\n    \n    finCol += 0.8 * d * col;\n    \n    col = vec3(0.8, sin(iTime) - cos(iTime), 0.7);\n    \n    uv = fract(uv * 1.3);\n    uv -= 0.5;\n    d = fract(length(uv) * 5.0 + iTime);\n    d = smoothstep(-0.1, 1.5, d);\n    \n    finCol += 0.8 * d * col;\n    \n    col = vec3(cos(iTime), 0.4, 0.7);\n    \n    uv = fract(uv * 1.4);\n    uv -= 0.5;\n    d = fract(length(uv) * 5.0 + iTime);\n    d = smoothstep(-0.1, 1.5, d);\n\n    finCol += 0.3 * d * col;\n    \n    col = vec3(cos(iTime), sin(iTime), 0.7);\n    \n    uv = fract(uv * 3.0);\n    uv -= 0.5;\n    d = fract(length(uv) * 5.0 + iTime);\n    d = smoothstep(-0.1, 1.5, d);\n\n    finCol += 0.3 * d * col;\n    \n    fragColor = vec4(finCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1031]]}
{"id": "clVXWt", "name": "A cube for the cube enjoyers", "author": "mrange", "description": "CC0: A cube for the the cube enjoyers\nTinkering around with cubes\nThis one in particular I tinkered with a way to do some kind of \nlog/exp domain mapping but trying to avoid the classic overstepping artefacts\n", "tags": ["3d", "cube"], "likes": 42, "viewed": 905, "published": 3, "date": "1686474998", "time_retrieved": "2024-07-30T17:50:15.766143", "image_code": "// CC0: A cube for the cube enjoyers\n//  Tinkering around with cubes\n//  This one in particular I tinkered with a way to do some kind of \n//  log/exp domain mapping but trying to avoid the classic overstepping artefacts\n//  (The bane of many cool experiments)\n//  Thought it turned out good enough to share.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  24.0\n#define MAX_RAY_MARCHES 70\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define ZOOM        (1.045)\n\n#define FWD(x)      exp2((x)*ZOOM)\n#define REV(x)      (log2(x)/ZOOM)\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol0   = HSV2RGB(vec3(hoff+0.05, 0.85, 0.00125));\nconst vec3 glowCol1   = HSV2RGB(vec3(hoff+0.55, 0.85, 0.05));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.45, 0.5, 0.25));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nmat3 rotX(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    1.0 , 0.0 , 0.0\n  , 0.0 , +c  , +s\n  , 0.0 , -s  , +c\n  );\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nmat3 rotY(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , 0.0 , +s\n  , 0.0 , 1.0 , 0.0\n  , -s  , 0.0 , +c\n  );\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nmat3 rotZ(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , +s  , 0.0\n  , -s  , +c  , 0.0\n  , 0.0 , 0.0 , 1.0\n  );\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxf(vec3 p, vec3 b, float e) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25) - r;\n}\n\n\nmat3 g_rot;\nfloat g_gd;\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  float d0 = box(p, vec3(3.0));\n  float d1 = boxf(p, vec3(3.01), 0.0)-0.015;\n  float d3 = sphere4(p, 3.0);\n  \n  vec3 p2 = p;\n  p2 = abs(p2);\n  p2 -= 3.0;\n  \n  float fp2 = FWD(length(p2));\n\n  float n = floor(fp2);\n  \n  float x0 = REV(n);\n  float x1 = REV(n+1.0);\n\n  float m = (x0+x1)*0.5;\n  float w = x1-x0;\n  \n  float d2 = abs(length(p2)-m)-(w*0.5)+0.025;\n\n  d0 = max(d0, d2);\n  d0 = max(d0, -(d1-0.03));\n\n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d3);\n  \n  float gd = d1;\n  gd = min(gd, d3);\n  g_gd = min(g_gd, gd);\n  \n  return d;\n\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  \n//  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  iter = i;\n  \n  return t;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n\n\n  col += clamp(vec3(1.0/abs(rd.y))*glowCol0, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec3 render1(vec3 ro, vec3 rd, vec2 sp) {\n\n  g_gd = 1E3;\n  int iter;\n  float t = rayMarch(ro, rd, iter);\n  vec3 ggcol = (glowCol1)*inversesqrt(max(g_gd, 0.00025));\n  vec3 col = render0(ro, rd);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  float fre0 = 1.0+dot(rd, n);\n  float fre = fre0;\n  fre *= fre;\n  float dif = dot(sunDir1, n); \n\n  float ao = 1.0-float(iter)/float(MAX_RAY_MARCHES);\n  float fo = mix(0.2, 0.5, ao);\n  if (t < MAX_RAY_LENGTH) {\n    col = vec3(0.0);\n    col += sunCol1*dif*dif*diffCol*fo;\n    col += mix(0.33, 1.0, fre)*render0(p, r)*fo;\n  }\n  \n  col += clamp(ggcol, 0.0, 4.0);\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = TIME*0.5+10.0;\n  \n  g_rot = rotX(0.333*tm)*rotZ(0.5*tm)*rotY(0.23*tm);\n  \n  vec3 ro = 2.0*vec3(5.0, 1.0, 0.);\n  ro.xz *= ROT(-0.1*tm);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd, p);\n  col -= 0.05*length(pp);\n  col *= smoothstep(1.5, 0.5, length(pp));\n\n  col = aces_approx(col); \n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[879, 879, 901, 901, 1047], [1801, 1889, 1909, 1909, 2029], [2031, 2119, 2139, 2139, 2259], [2261, 2349, 2369, 2369, 2491], [2493, 2600, 2626, 2626, 2810], [2812, 2812, 2854, 2854, 2901], [2903, 3021, 3048, 3048, 3124], [3126, 3244, 3271, 3271, 3358], [3360, 3453, 3490, 3490, 3777], [3779, 3779, 3811, 3811, 3858], [3886, 3886, 3904, 3904, 4458], [4460, 4460, 4483, 4483, 4691], [4693, 4693, 4741, 4741, 5093], [5095, 5095, 5127, 5127, 5780], [5782, 5782, 5823, 5823, 6422], [6424, 6424, 6454, 6454, 7044], [7046, 7046, 7103, 7103, 7294]]}
{"id": "ctVXWc", "name": "11-06-2023 - 1 - Dunes", "author": "Eise", "description": "Cool pattern of sine functions and such, looking like dunes.", "tags": ["waves", "pattern", "cool", "dunes", "warm"], "likes": 8, "viewed": 163, "published": 3, "date": "1686472520", "time_retrieved": "2024-07-30T17:50:16.513146", "image_code": "float divisionD(vec2 uv, vec2 pos) {\n    float d = 0.0;\n    d = sin(iTime + uv.y * uv.x) * (uv.x - pos.x) - uv.y + pos.y;\n    float fase = mod(iTime, 6.283);\n    d = step(0.8, d); \n    return d;\n}\n\n// Only for debugging\nfloat pointD(vec2 uv, vec2 pos) {\n    float d = length(uv - pos);\n    d = step(0.05, d);\n    d = 0.00001 / d;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 finCol = vec3(0.0);\n    vec3 divCol = vec3(0.7, 0.3, 0.0);\n    vec3 pointCol = vec3(0.0, 1.0, 1.0);\n    \n    vec2 points[4] = vec2[4](vec2(sin(iTime), cos(iTime)), vec2(cos(iTime), 0.5), vec2(0.8, sin(iTime * 0.1)), vec2(cos(iTime)));\n    for (int i = 0; i < points.length(); i++) {   \n        finCol += divisionD(uv, points[i]) * divCol;\n        //finCol += pointD(uv, points[i]) * pointCol;\n    }\n\n\n    fragColor = vec4(finCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 196], [198, 220, 253, 253, 345], [347, 347, 404, 404, 949]]}
{"id": "DtKXDV", "name": "COOL_S", "author": "LydianLights", "description": "behold...", "tags": ["cools"], "likes": 5, "viewed": 193, "published": 3, "date": "1686451586", "time_retrieved": "2024-07-30T17:50:17.288074", "image_code": "vec3 mainPass(in vec2 fragCoord)\n{\n    vec2 uv0 = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv0.x *= iResolution.x / iResolution.y;\n    \n    float d0 = length(uv0);\n    vec3 color = vec3(0.0);\n    \n    const float iters = 5.0;\n    for (float i = 1.0; i <= iters; i++)\n    {\n        vec2 m = vec2(1.0, 2.5);\n        \n        vec2 uv = uv0;\n        uv = i * uv + m / 2.0;\n        \n        float iSign = mod(i, 2.0) == 0.0 ? 1.0 : -1.0;\n        uv.x += 0.2 * i * iTime * iSign;\n        \n        vec2 cell = floor(uv / m);\n        \n        float xSign = mod(cell.x, 2.0) == 0.0 ? -1.0 : 1.0;\n        uv.y += iSign * xSign * iTime + 0.5 * i * i;\n        \n        uv = mod(uv, m) - m / 2.0;\n        \n        float q = 0.01 + 0.003 * (iters + 1.0 - i);\n        float p = 0.9 + 0.3 * i;\n        \n        float d = sdf_COOL_S_SUNGLASSES_EMOJI(uv);\n        d *= 3.0 * exp(1.4 * -d0);\n        d = abs(d);\n        d = q / d;\n        d = pow(d, p);\n\n        vec3 c = d * palette(0.1 * i + 0.1 * iTime + 0.05 * uv0.x + 0.5);\n        \n        color += c;\n    }\n    \n    vec2 uv = uv0;\n    uv.x += 0.01 * sin(50.0 * uv.y + 10.0 * iTime);\n    float d = sdf_COOL_S_SUNGLASSES_EMOJI(uv);\n    d = abs(d);\n    d = smoothstep(0.02, 0.15, d);\n    color *= vec3(d);\n    \n    return color;\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = mainPass(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.8, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.66);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Thanks iq for optimizing my sdf :3\n// https://www.shadertoy.com/view/clVXWc\nfloat sdf_COOL_S_SUNGLASSES_EMOJI(vec2 p)\n{\n    // symmetry \n    p = (p.y>p.x) ? -p : p;   // can be p.y>0.0 too\n    vec2 q = vec2(abs(p.x),p.y);\n\n    // line segments\n    float d; vec2 v;\n    { v=q+vec2( .0,1.); v  -=clamp(.5*(v.x+v.y),.0,.4);                  d=dot(v,v);  }\n    { v=q-vec2( .2,.0); v  -=clamp(.5*(v.x+v.y),.0,.2);            d=min(d,dot(v,v)); }\n    { v=p-vec2(-.4,.2); v  -=clamp(.5*(v.x-v.y),.0,.4)*vec2(1,-1); d=min(d,dot(v,v)); }\n    { v=q-vec2( .0,.2); v  -=clamp(.5*(v.x-v.y),.0,.4)*vec2(1,-1); d=min(d,dot(v,v)); }\n    { v=q+vec2( .0,.6); v.y-=clamp(v.y,.0,.4);                     d=min(d,dot(v,v)); }\n    { v=q-vec2( .4,.2); v.y-=clamp(v.y,.0,.4);                     d=min(d,dot(v,v)); } \n    { v=q+vec2(-.4,.6); v.y-=clamp(v.y,.0,.4);                     d=min(d,dot(v,v)); }\n    \n    // interior vs exterior\n    float s = max(q.x-0.4+max(-q.y-0.6,0.0),q.x-0.2-abs(q.y));\n\n    return sqrt(d) * sign(s);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 1270], [1272, 1272, 1299, 1299, 1351], [1353, 1353, 1408, 1408, 1508]]}
{"id": "DlKSW3", "name": "Year of Truchets #034", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\nIf slow turn AA off (AA 1)\nSquare truchet with offset to match corner roundness ", "tags": ["raymarching", "square", "truchet"], "likes": 13, "viewed": 185, "published": 3, "date": "1686450488", "time_retrieved": "2024-07-30T17:50:18.039066", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #034\n    06/11/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Square truchet with offset to match corner roundness \n    \n*/\n\n// If slow turn AA off (AA 1)\n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    20.\n\nvec3 hp,hitpoint;\nfloat flow,time,tmod,ga1,ga2,ga3,ga4;\nmat2 r90;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nfloat lsp(float b, float e, float t) { return clamp((t-b)/(e-b),0.,1.); }\n//@iq\nfloat box(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2(d,abs(z)-h);return min(max(w.x, w.y),0.)+length(max(w,0.));\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    p.x += flow;\n    \n    vec2 uv = p.xz*.45;\n    float pv= p.y*.45;\n    \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    vec2 ik = floor(uv-.5), k = fract(uv-.5)-.5;\n    \n    float hs = hash21(id*32.123);\n    if(fract(hs*67.913)>.5) q.xy *= r90;\n\n    const float fs = .15, pf = .45, wd = .0751;\n    \n    vec2 p2 = vec2(length(q.xy-pf),length(q.xy+pf));\n    vec2 r = p2.x<p2.y? q.xy-pf : q.yx+pf;\n\n    // main pattern\n    float d = abs(box(r,vec2(.15))-.3)-wd;\n    \n    // alt pattern\n    float tk=1e5, d3=1e5;\n    if(hs>.7) {\n        tk = length(q.x)-wd;\n        d = length(q.y)-wd;\n    }\n    d=abs(d)-.03;\n    float d1 = opx(d,p.y,.085);\n    if(d1<res.x) {\n        res=vec2(d1,2.);\n        hp=p;\n    }\n\n    float ff = fs*cos(q.y*PI2)+fs;\n    float py = fract(hs*47.93)>.45? p.y-ff : p.y+ff;\n    tk=abs(tk)-.03;\n    if(hs>.7) { d3 = opx(tk,py,.085); }\n    if(d3<res.x) {\n        res=vec2(d3,2.);\n        hp=p;\n    }\n    \n    float fa = ik.x+ik.y*.5+T*.5;\n    float ss = .25*sin(fa), st = .25*cos(fa);\n    float b1 = length(vec3(k.x+st,pv+.175,k.y+ss))-.125;\n    if(b1<res.x) {\n        res=vec2(b1,4.);\n        hp=p;\n    }\n\n    float d2 = p.y+.75;\n    if(d2<res.x) {\n        res=vec2(d2,1.);\n        hp=p;\n    }\n\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit) {\n    float d=0., m = 0.;\n    for(int i=0;i<80;i++) {\n        vec2 t = map(p);\n        if(t.x<MIN_DIST) hit = true;\n        d+= i<15? t.x*.5 : t.x;\n        m = t.y;\n        p = ro + rd * d;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC = vec3(0),p = ro;\n    float m = 0., fA = 0., f = 0.;\n    \n    bool hit = false;\n    vec2 ray = marcher(ro,rd,p,hit);\n    \n    d = ray.x, m = ray.y;\n    hitpoint = hp;\n    \n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-2,12,1);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1., t = .1;\n        for( int i =0; i<14; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>8. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        //vec3 view = normalize(p-ro);\n        vec3 ret = reflect(normalize(lpos),n);\n        float spec =  0.45 * pow(max(dot(l, ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n        \n        vec3 SPC = hsv2rgb(vec3((p.x+p.z)*.025,1.,.5));\n        \n        if(m==4.) {\n            h = mix(SPC,vec3(.75),.175);\n            ref = SPC;\n        }\n        if(m==2.) {\n            vec3 BC = tex3D(iChannel0,hitpoint*.5,n).rgb;\n            h = mix(vec3(.5),BC,.75);\n            ref = vec3(1);\n        }\n        if(m==1.) {\n            h = tex3D(iChannel1,hitpoint*.25,n).rgb*vec3(0.518,0.596,0.624);\n            ref = vec3(.98);\n        }\n\n        \n        RC = h * diff + (spec*SPC);\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return clamp(RC,vec3(0),vec3(1));\n}\n\nvec3 renderALL( in vec2 uv, in vec2 F )\n{   \n\n    //wipe\n    float xln = ga1-(.025*sin(uv.y*25.+T*5.));\n    float zoom = 5.5,tilt = .7;\n    if(uv.x>xln) {zoom = 7.75;tilt = 1.5707;}\n    \n    vec3 ro = vec3(0,-1,zoom);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse //\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.2-.1)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(-tilt-x),ry = rot(-.78+.5*sin(T*.075)-y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(.95);\n    vec3 p = ro;\n    \n    float m = 0., d = 0., f = 0.;\n\n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill = ref; \n        if(i==0)f=d;\n    }\n    \n    C = mix(vec3(.1),C,exp(-.0005*f*f*f));\n    if(uv.x>xln && uv.x-.01<xln)C=vec3(1);\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    r90=rot(1.5707);\n    flow = T*.5;\n    \n    tmod = mod(flow, 10.);\n    float t1 = lsp(3.,  5., tmod);\n    float t2 = lsp(8., 10., tmod);\n    ga1 = ((t1-t2)*2.2)-1.1;\n    \n    vec3 C = vec3(0.);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = renderALL(uv,F);\n        // compress        \n        color = 1.35*color/(1.+color);\n        // gamma\n        color = pow( color, vec3(.4545) );\n\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKSW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[608, 608, 626, 626, 671], [672, 672, 694, 694, 752], [753, 753, 791, 791, 826], [827, 833, 860, 860, 929], [930, 930, 976, 976, 1056], [1058, 1058, 1076, 1076, 2334], [2336, 2411, 2441, 2441, 2680], [2682, 2682, 2744, 2744, 2993], [2995, 2995, 3042, 3042, 3246], [3248, 3265, 3292, 3292, 3408], [3410, 3410, 3493, 3493, 4990], [4992, 4992, 5033, 5048, 5903]]}
{"id": "ctySDd", "name": "2D Stylized Waterline", "author": "Bricktronic", "description": "2D Stylized Ocean\nI got burnt out while doing the clouds.", "tags": ["2d", "ocean", "stylized"], "likes": 5, "viewed": 195, "published": 3, "date": "1686450197", "time_retrieved": "2024-07-30T17:50:18.785071", "image_code": "float rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define PI 3.14159\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 2000.0 / freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nconst vec3 skyTop = vec3(0.5, 0.8, 0.97);\nconst vec3 skyHorizon = vec3(0.9, 0.9, 0.8);\nconst vec3 cloudColor = vec3(0.97, 0.95, 0.94);\nvec3 renderSky(vec2 uv)\n{\n    float horizonFac = map(uv.y, 0.5, 1.0, 0.0, 1.0);\n    vec3 skyColor = mix(skyHorizon, skyTop, horizonFac);\n    \n    vec2 cloudUV = vec2(uv.x + iTime * .05, uv.y);\n    float cloudFac = 1.5;\n    for(float i = 1.0; i < 3.; i++)\n    {\n        float n = noise(cloudUV + i, i * 10000.);\n        \n        if(n > 0.)\n            cloudFac *= n;\n    }\n    \n    cloudFac = clamp(cloudFac, 0., 1.) * horizonFac;\n    \n    return mix(skyColor, mix(skyHorizon, cloudColor, cloudFac), cloudFac);\n}\n\nconst vec3 waterColor = vec3(0.3, 0.68, 0.75);\nvec3 renderWater(vec2 uv, float depth)\n{\n    float lipFac = clamp(depth * 125., 0.25, 1.);\n    float depthFac = (1.0 - depth) + (uv.y * .75);\n    return waterColor * depthFac * lipFac;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float uvNoise = noise(uv + iTime, 2000.);\n    float height = 0.5 + (uvNoise * 0.1);\n    \n    if(uv.y < height)\n    color = renderWater(uv, height - uv.y);\n     else\n    color = renderSky(uv);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctySDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 87], [108, 108, 141, 141, 478], [480, 480, 552, 552, 618], [755, 755, 780, 780, 1266], [1315, 1315, 1355, 1355, 1501], [1503, 1503, 1560, 1560, 1927]]}
{"id": "DtGSDd", "name": "Caterpillar", "author": "deadlyunicorn", "description": "Something random I built", "tags": ["random"], "likes": 0, "viewed": 105, "published": 3, "date": "1686446849", "time_retrieved": "2024-07-30T17:50:19.527088", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x= uv.x * (iResolution.x/iResolution.y);\n    uv=uv-0.5;\n    uv.x=uv.x-0.35;\n    uv=uv*10.; //zoom out\n    \n    float distance = length(uv);\n    distance = sin(distance + iTime);\n    distance = abs(distance);\n    distance = sin(iTime)/distance;\n    \n    float redCol=0.1/40.*sin(cos(10.*distance)*sin(0.01*iTime));\n   \n   \n    fragColor = vec4(cos(iTime*redCol),1.0-distance*sin(iTime*redCol),sin(distance+iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 527]]}
{"id": "DtKXWV", "name": "Random thing", "author": "coolpersonlol", "description": "Moving deform", "tags": ["deform"], "likes": 4, "viewed": 142, "published": 3, "date": "1686444607", "time_retrieved": "2024-07-30T17:50:20.280075", "image_code": "vec3 deform( in vec2 p, in float t )\n{\n    t *= 2.0;\n    \n    p += 0.5*sin( t*vec2(1.1,1.3)+vec2(0.0,0.5) );\n\n\tfloat a = atan( p.y, p.x );\n    float r = length( p );\n    \n    float s = r * (1.0+0.5*cos(t*1.7));\n\n    vec2 uv = 0.1*t + 0.05*p.yx + 0.05*vec2( cos(t+a*2.0),  \n                                             sin(t+a*2.0))/s;\n\n    return texture( iChannel0, 0.5*uv ).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    \n    vec3 col = vec3(0.0);\n    for( int i=0; i<20; i++ )\n    {\n        float t = iTime + float(i)*0.0; \n        col += deform( p, t );\n    }\n    col /= 20.0;\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 382], [384, 384, 441, 441, 703]]}
{"id": "clySDt", "name": "broken fractal", "author": "cemysf", "description": "inspired by tutorial https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["fractal", "broken"], "likes": 1, "viewed": 118, "published": 3, "date": "1686441011", "time_retrieved": "2024-07-30T17:50:21.024086", "image_code": "float calcBasis(vec2 uv) {\n    float pp = pow(uv.x, 4.) / pow(uv.y, 2.0);\n    float d = pow(pp, iTime*0.001) - (pow(uv.x, 3.0)* pow(uv.y, 2.0)) ;\n    \n    //d -= 0.5;\n    \n    d = cos(d * iTime + iTime) / 2.;\n        \n    d = abs(d);\n    //d = smoothstep(0.0, 0.1, d);\n    \n    d = 0.15 / d;\n    \n    d = smoothstep(0.0, 1.0, d);\n    \n    d = 0.2 / d;\n    \n    d = pow(0.2 / d, 2.0);\n    \n    \n    return d;\n    \n}\n\n\nvec3 palette(float t){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n \n    return a + b*tan( 6.28318*(c*t + d));\n}\n\n\n// https://www.youtube.com/watch?v=f4s1h2YETNY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // and scale and shif\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    // fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 uv0 = uv;\n    \n    \n    vec3 finalColor = vec3(0.0);\n    \n    \n    for (float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * (2. + fract(i)) + i) - i;\n         \n    \n        // basis\n        float d = calcBasis(uv); //length(uv); //\n        d *= calcBasis(uv0);\n        \n        //d *= length(uv0); //\n        \n        d *= exp(-length(uv));\n        d *= exp(-length(uv0));\n\n        //vec3 col = palette(tan(d) * length(uv) * length(uv0) + i*0.3 + iTime*0.125);\n        vec3 col = palette(cos(uv.x) * cos(uv.y) * length(uv) * length(uv0) + i*0.3 + iTime*0.125);\n        finalColor += col * d;\n\n        // Time varying pixel color\n        //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clySDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 414], [417, 417, 439, 439, 627], [630, 677, 734, 810, 1718]]}
{"id": "mtVXD3", "name": "Another water shader", "author": "ianertson", "description": "Use the mouse to look around :)", "tags": ["sea", "water", "ocean", "sky", "foam", "sand"], "likes": 9, "viewed": 477, "published": 3, "date": "1686432034", "time_retrieved": "2024-07-30T17:50:21.989504", "image_code": "#define R iResolution.xy\n#define T (iTime*1.5)\n#define ZERO min(iFrame, 0)\n#define NEAR 0.0005\n#define FAR 800.0\n#define STEPS 60\n\n#define ID_GROUND 0\n#define ID_WATER 1\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n    bool hit;\n    bool water;\n    bool is_refract;\n};\n\nstruct Material {\n  float rough;\n  float metallic;\n  float spec;\n  float z;\n  vec3 bump;\n};\n\n#define NEW_MATERIAL Material(1.0, 0.0, 1.0, 0.0, vec3(0.0))\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1, false, false, false)\n\n//#define DEBUG_TEXTURE sandTexture\nvec3 sandTexture(in vec2 uv, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 lf1 = noise(uv, 0.028128, 4.5, 4);\n    vec3 lf2 = noise(uv, 5.555321, 9.5, 4);\n    vec3 hf1 = noise(uv, 9.281823, 128.5, 7);\n    vec3 grain = abs(normalize(cross(lf2*2.0-1.0, hf1*2.0-1.0)));\n    \n    \n    vec3 c1 = vec3(0.722, 0.596, 0.400);\n    vec3 c2 = vec3(0.616, 0.471, 0.302);\n    vec3 c3 = vec3(0.737, 0.592, 0.400);\n    vec3 c4 = vec3(0.773, 0.631, 0.427);\n    \n    vec3 c5 = (c2+vec3(0.537, 0.098, 0.039))*0.5;\n    vec3 c6 = vec3(0.188, 0.063, 0.027);\n    vec3 c7 = vec3(0.812, 0.722, 0.612);\n    vec3 c8 = vec3(0.149, 0.110, 0.082);\n    \n    float g1 = lf1.x*grain.x;\n    float g2 = lf2.x*grain.y;\n    \n    vec3 a1 = mix(c1, c2, lf1.x);\n    vec3 b1 = mix(c3, c4, lf1.y);\n    vec3 ab1 = mix(a1, b1, g1);\n    \n    vec3 a2 = mix(c5, c6, lf1.x);\n    vec3 b2 = mix(c7, c8, lf1.y);\n    vec3 ab2 = mix(a2, b2, g2);\n    \n    col += ab1;\n    \n    float spots = 0.5*grain.z * smoothstep(0.4, 0.7, lf1.x);\n    col = mix(col, ab2, spots);\n    \n    m.z = 0.5 - (spots*0.5);\n    m.bump = makeNormal(m.z, 0.5);\n    m.spec = clamp((spots+spots*spots)+(lf1.y*lf1.y*lf1.y*0.25), 0.01, 1.0);\n    \n    return col;\n}\n\nfloat waterHeight(in vec3 p) {\n    \n    float h = -2.0;\n    float t = T*0.25;\n    vec2 shift = vec2(sin(t), cos(t));\n    \n   // p.xz += shift*0.015;\n    \n    float r1 = unoise(p.xz+shift+vec2(cos(t*4.), sin(t*4.)), 0.298212, 0.25, 4);\n    float r2 = unoise(p.zx-(shift*6.), 24.48381, 0.011, 4);\n    shift *= (1.0 + (r2*0.1));\n    vec3 hm = noise(p.xz+(shift*0.25), 193.382812, 0.01, 2);\n    t *= mix(1.0, 1.2, smoothstep(0.4, 0.9, hm.y));\n    vec3 detail = noise(p.xz+shift+0.8*vec2(sin((t*2.) + 3.5*r2), cos((t*.2) + 3.5*r1)), 77.595892, 0.6, 6);\n    \n    float waveFreq = 0.89*mix(0.45, 0.25, 0.33*(0.5+(0.5*(sin(t-r1)))));\n    \n    float z = mix(p.z, p.x, 0.87*smoothstep(0.4, 0.9, r2*(0.5+(0.5*cos((t-r1)+3.3938321)))));\n    \n    h += exp(cos(z*waveFreq+t)-1.);\n    \n    \n    float hh = smoothstep(0.4, 0.7, hm.x);\n    \n    h *= hh;\n    \n    h += detail.x * smoothstep(0.6, 0.0, p.y-h);\n    \n    h -= (r1+r2)*0.5;\n    \n    return h;\n}\n\nfloat waterSDF(in vec3 p) {\n    if (p.y < -10. || p.y > 300.) return p.y;\n    float h = waterHeight(p);\n    return p.y - h;\n}\n\nfloat groundHeight(in vec3 p) {\n    if (p.y > 20. || p.y < -90.) return p.y;\n    float h = 0.0;\n    float n1 = unoise(p.xz, 0.039821, 0.4, 3);\n    float n2 = unoise(p.xz, 2.292813, 0.05, 3);\n    h += n1;\n    h -= smoothstep(0.25, 0.6, n2)*6.;\n    return h;\n}\n\nfloat groundSDF(in vec3 p) {\n    float h = groundHeight(p);\n    return p.y - h;\n}\n\nfloat sdf(in vec3 p, inout Data data) {\n    \n    float dist = FAR*2.;\n    \n    if (data.water) {\n        data.id = ID_WATER;\n        float water = waterSDF(p);\n        dist = min(dist, water);\n    } else {\n        data.id = ID_GROUND;\n        float ground = groundSDF(p);\n        dist = min(dist, ground);\n    }\n    \n    return dist;\n}\n\nbool march(in vec3 ro, in vec3 rd, inout Data data) {\n    float d = 0.0;\n    float next = 0.0;\n    vec3 p = vec3(0.0);\n\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        p = ro + rd * d;\n        next = sdf(p, data);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (abs(d) * 3.)))) break;\n        if ((d) >= FAR) return false;\n    }\n    \n    vec2 e = vec2(0.0009, 0.0);\n    data.n = normalize(next - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    data.d = abs(d);\n    data.p = p;\n    data.hit = true;\n    \n    return true;\n}\n\nvec3 getSky(in vec3 rd, in vec3 L, vec3 lcol) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = vec3(0.071, 0.471, 0.753);\n    col = pow(col, vec3(1.0 + (dotup*2.0)));\n    \n    \n    float sun = max(0.0, dot(rd, L));\n    col += pow(sun, 8.0) * lcol;\n    \n    return col;\n}\n#define L normalize(vec3(1, 2, 3.0))\n#define lcol vec3(0.8, 0.7, 0.66)\nvec3 ray(in vec3 ro, in vec3 rd, inout Data data) {\n    if (!march(ro, rd, data) || data.id < 0) return getSky(rd, L, lcol);\n    \n    vec3 albedo = vec3(0.77);\n    \n    Material m = NEW_MATERIAL;\n    \n    switch (data.id) {\n        case ID_GROUND: albedo = sandTexture(data.p.xz, m); break;\n        case ID_WATER: albedo = vec3(0.4, 0.5, 0.6); break;\n        default: albedo = vec3(0.77); break;\n    }\n    \n    vec3 diffuse = albedo / M_PI;\n    \n    vec3 N = normalize(data.n + 0.25*m.bump);\n    vec3 ref = reflect(L, N);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 64.0) * m.spec;\n    float ls = 4.0;\n    float NdotL = max(0.0, dot(N, L));\n    vec3 att = NdotL * lcol * ls;\n    \n    vec3 col = vec3(0.0);\n    \n    col += (diffuse + spec) * att;\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dist = FAR;\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    Data dataGround1 = NEW_DATA;\n    Data dataGround2 = NEW_DATA;\n    Data dataWater = NEW_DATA;\n    Data dataWaterReflect = NEW_DATA;\n    dataWater.water = true;\n    \n    vec3 groundColor = ray(ro, rd, dataGround1);\n    vec3 waterColor = ray(ro, rd, dataWater);\n    \n    if (!dataGround1.hit || !dataWater.hit) {\n        col = getSky(rd, L, lcol);\n        dist = FAR;\n    } else {\n        if (dataWater.d < dataGround1.d && dataWater.hit) {\n            col = waterColor;\n            vec3 ro2 = dataWater.p;//-(dataWater.n*0.9);\n            vec3 rd2 = refract(rd, dataWater.n, 1.0/1.33);\n            dataGround2.is_refract = true;\n            vec3 refractColor = ray(ro2, rd2, dataGround2);\n            col = (col/2.0)+refractColor;\n            dist = dataWater.d;\n            \n            vec3 ro3 = dataWater.p;\n            vec3 rd3 = reflect(rd, dataWater.n);\n            vec3 reflectColor = ray(ro3, rd3, dataWaterReflect);\n            reflectColor += getSky(rd3, L, lcol)*0.25;\n            float NdotV = dot(dataWater.n, -rd);\n            vec3 F0 = mix(vec3(0.04), waterColor, 0.5);\n            vec3 F = fresnelSchlickRoughness(NdotV, F0, 0.002);\n            \n            \n            float wd = distance(dataWater.p, dataGround1.p);\n            \n            col += reflectColor * F;\n            \n            col = mix(col, col*col, smoothstep(0.0, 1.0, wd));\n            \n            col.r /= (1.0 + wd*0.02);\n            col.g /= (1.0 + wd*0.008);\n            \n            \n            float nn = noise((dataWater.p.xz+(0.25*vec2(sin(T-dataWater.p.x), cos(T+dataWater.p.z))))*16., 0.32123).x;\n            \n            col += 0.27*smoothstep(0.5, 0.0, wd)*(0.06+(nn*nn*nn));\n           \n        } else {\n            dist = dataGround1.d;\n            col = groundColor;\n        }\n    }\n    \n    \n    \n    float depth = dist / FAR;\n    col += smoothstep(0.02, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.3, dotup));\n    \n    return col;\n}\n\n\n\nvec3 getNextPos(in vec3 old_pos, in float t) {\n    vec2 p = vec2(sin(t-0.25*cos(t+0.928183)), cos(t+0.25*sin(t-0.333271))) - (old_pos.xz*0.321233);\n    p.x -= t*0.07;\n    p.y += t*0.07;\n    p *= rot(sin(t+3.39281));\n    \n    p += vec2(sin(p.x), cos(-p.x)) / M_PI;\n    p += vec2(cos(p.y), sin(-p.y)) / M_PI;\n    \n    p += 0.000298813;\n    \n    \n    \n    return vec3(p.x, 0.0, p.y) * 40.;\n}\n\n\nfloat atan2(in float y, in float x) { return abs(x) <= 0.000001 ? sign(y)*M_PI/2. : atan(y, x); }\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc - 0.5 * R.xy)/R.y;\n    \n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    vec3 ro = vec3(0.0, 0.2, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    float t = T*0.08;\n    \n    bool control = false;\n    if (m.z > 0.001) {\n      rd.yz *= rot(m.y * TAU);\n      rd.xz *= rot(m.x * TAU);\n      control = true;\n    }\n    \n    float a = 0.0;\n    vec3 cur = getNextPos(ro, t);\n    vec3 next = getNextPos(ro, t+0.2182881);\n    vec2 dir1 = next.xz-cur.xz;\n    vec2 dir = normalize(dir1);\n\n    a = atan(dir.x, dir.y);\n      \n    float ss = smoothstep(2.5, 6.5, iTime);\n    a = mix(0.0, a, ss);\n      \n    ro.xz = mix(ro.xz, cur.xz, ss);\n    if (!control) {\n        rd.xz *= rot(a);\n    }\n      \n      ro.y += 4.0*(0.5+(0.5*sin(t*4.)));\n    //ro.z += T;\n    ro.y += 3.;\n    \n    #ifdef DEBUG_TEXTURE\n    Material m = NEW_MATERIAL;\n    col = DEBUG_TEXTURE(fc.xy/R.xy, m);\n    #else\n    col = render(ro, rd);\n    #endif\n    \n    col += (luma(col) * col) * 0.5;\n    col = mix(col, col*col, 0.45);\n    col /= (1.0 + (0.5*max(col-1.0, 0.0)));\n    col = aces(col);\n    \n    col = pow(col, vec3(1.0/2.2));\n    O = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifndef HW_PERFORMANCE\n#define iFrame 0\nuniform sampler2D iChannel3;\n#endif\n#define M_PI 3.14159\n#define TAU (M_PI*2.0)\n\n#define ZERO min(iFrame, 0)\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\n#define NOISE(p, s) textureLod(iChannel3, (p + 43.29183*s)/256.0, 0.0).rgb\n\nvec3 noise(in vec2 p, in float seed) {\n    p += 11.8182;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(NOISE(id, seed), NOISE(id+vec2(1, 0), seed), lv.x),\n        mix(NOISE(id+vec2(0, 1), seed), NOISE(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = ZERO; i < oct; i++) {\n        n += amp * noise(p*freq, seed);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat hash21(in vec2 ip, in float seed) {\n    uvec2 p = floatBitsToUint(ip);\n    uint s = floatBitsToUint(seed);\n    uint w = ~s;\n    uvec2 i = ~p;\n    p ^= p << 17U;\n    p += p * (w << p.y) * i;\n    p ^= p >> 13U;\n    p ^= p << 5U;\n    p += (p * i + (w << p.x)) >> 3U;\n    uint n = (p.x ^ p.y) + (p.x * w + p.y) * (p.x + p.y);\n    return float(n*1013U) / float(0xFFFFFFFFU);\n}\n\nfloat unoise(in vec2 p, in float seed) {\n    p += 11.8182;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat unoise(in vec2 p, in float seed, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = ZERO; i < oct; i++) {\n        n += amp * unoise(p*freq, seed);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 makeNormal(in float z, in float amp) {\n    float fx = dFdx(z);\n    float fy = dFdy(z);\n    float eps = 0.07;\n    vec2 dx = vec2(dFdx(z), eps);\n    vec2 dy = vec2(eps, dFdy(z));\n    \n    vec3 n = cross(vec3(dx, amp), vec3(dy, amp));\n    vec3 fn = fwidth(n);\n    n = (n + fn)*0.5;\n    return normalize(n);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 257], [607, 643, 691, 691, 1837], [1839, 1839, 1869, 1869, 2777], [2779, 2779, 2806, 2806, 2904], [2906, 2906, 2937, 2937, 3164], [3166, 3166, 3194, 3194, 3247], [3249, 3249, 3288, 3288, 3584], [3586, 3586, 3639, 3639, 4189], [4191, 4191, 4238, 4238, 4481], [4553, 4553, 4604, 4604, 5342], [5344, 5344, 5381, 5381, 7427], [7431, 7431, 7477, 7477, 7819], [7822, 7822, 7859, 7859, 7919], [7921, 7921, 7963, 7963, 9133]]}
{"id": "clVXWc", "name": "CoolS - distance", "author": "iq", "description": "Distance to the Cool S shape. Inspired by [url]https://www.shadertoy.com/view/ctVSDV[/url], but corrected, optimized and eventually rewritten.", "tags": ["2d", "sdf", "distance", "s", "cools"], "likes": 48, "viewed": 2141, "published": 3, "date": "1686428053", "time_retrieved": "2024-07-30T17:50:22.741493", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to the CoolS shape. https://en.wikipedia.org/wiki/Cool_S. Inspired\n// by https://www.shadertoy.com/view/ctVSDV but corrected the shape, added\n// interior distance, optimized the number of segments from 14 to 3through\n// symmetry, and in the end rewrote the whole thing anyways.\n\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdfCoolS( in vec2 p )\n{\n    // symmetries\n    float six = (p.y<.0) ? -p.x : p.x;\n    p.x = abs(p.x);\n    p.y = abs(p.y) - .2;\n    float rex = p.x - min(round(p.x/.4),.4);\n    float aby = abs(p.y-.2)-.6;\n    \n    // line segments\n    float d = dot2(vec2(six,-p.y)-clamp(.5*(six-p.y),.0,.2));\n    d = min(d,dot2(vec2(p.x,-aby)-clamp(.5*(p.x-aby),.0,.4)));\n    d = min(d,dot2(vec2(rex,p.y  -clamp(p.y         ,.0,.4))));\n    \n    // interior vs exterior\n    float s = 2.*p.x+aby+abs(aby+.4)-.4;\n\n    return sqrt(d) * sign(s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float scale = 1.25;\n    \n\tvec2  p = scale*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = scale*2.0/iResolution.y;\n    \n    float d = sdfCoolS(p);\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-20.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,3.0*px,abs(d)) );\n    \n    // mouse\n    if( iMouse.z>0.001 )\n    {\n        float d = sdfCoolS(m);\n        float l = length(p-m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, abs(l-abs(d))));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, l-px*3.0));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVXWc.jpg", "access": "api", "license": "mit", "functions": [[1370, 1370, 1392, 1392, 1411], [1412, 1412, 1441, 1459, 1942], [1944, 1944, 1999, 1999, 2774]]}
{"id": "DlVXDc", "name": "Spaceship Console", "author": "QuantumSuper", "description": "An auto-VJ of a 2.5d-spaceship-cockpit flying through space, including gauges, sound textures, and bass reactive animations.\n\n - Use with music in iChannel0 -", "tags": ["music", "25d"], "likes": 11, "viewed": 281, "published": 3, "date": "1686428017", "time_retrieved": "2024-07-30T17:50:23.488496", "image_code": "// Spaceship Console 0.6.230610 by QuantumSuper\n// auto-vj of a 2d spaceship ui flying through pseudo-3d space with gauges, fft textures, and bass reactive animations\n//\n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 2.133333*iTime\n\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvec3 getCol(float id){ //color definitions, for triplets\n    vec3 setCol = vec3(0);\n    id = mod(id,15.);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    else if (id<13.) setCol = vec3( 28,142, 77); //matrix green\n    else if (id<14.) setCol = vec3( 66,120, 91); //matrix green 2\n    else if (id<15.) setCol = vec3(173,  0, 27); //matrix red\n    return setCol/256.;\n}\n\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\nfloat aaStep( float fun, float minWidth){return smoothstep( max(fwidth(fun),minWidth), .0, fun);} //overload to set minimum width\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nfloat sdCircle( vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b;\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b){//source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\nvec3 getStar(vec2 p, vec2 id){\n    id = vec2( hash21(id), hash21(id+id.yx));\n    p *= 1. + id.y*2.; //different sizes\n    p += id.y*vec2(sin(id.x*aTime/8.),sin(id.y*iTime*.1)); //different postions\n    return smoothstep( .85, 1., id.x) //brightness\n        * (.8 + .2 * vec3( sin(id*aTime/4.), sin(dot(id,vec2(.5))*iTime))) * vec3(1.5,1.,1.5) //color\n        * ((.5 + .5 * sin(2.*aTime*id.x+2.*PI*id.x) * sin(iTime)) //brightness varying over time\n        * aaStep(1. - dot( .1/(abs(p)+fwidth(p)+.12), vec2(1))) //\"lens flare\" shape\n        + smoothstep( .2, .8, .07/length(p))); //round core \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    // General initialization\n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    float rho = atan(-abs(uv.x),uv.y)/PI+1.; //polar angle flipped & mirrored\n    \n    \n    // Animation definitions\n    vec4 bang = vec4(0);\n    for (int n=0;n<4;n++)\n        bang[n] = smoothstep( .91, 1., texelFetch( iChannel0, ivec2(n,0), 0 ).x);\n    float colId = 3. * floor(mod(aTime/16.,5.)); //color set id\n    mat2 spaceRot = rotM(.2*sin(aTime/8.+fft.x)*sin(iTime*.1)); //\"outside\" space rotation\n \n \n    // Object definitions\n    float winDistort = length(uv*vec2(1.2,2.)-vec2(0,.2)); //morphing window shape\n    vec4 tmp = vec4( uv*winDistort, vec2(.7,.3)); //temporary \"throw-away\" variable\n    float window = sdBox( tmp.xy, tmp.zw)-.1; //window frame\n    float frame = sdBox( .6*tmp.xy, tmp.zw)-.1; //frame of window frame\n    float sideBox = sdBox( vec2(abs(tmp.x),tmp.y)+vec2(-1.4,1.), vec2(.5)); //bottom edges\n    tmp.x = uv.x;\n    float vent = sdBox( tmp.xy-vec2(-.5,.75), vec2(.15,.3)); //top left \"vent\" shape\n    float ventAmp = sdSegment( fract(tmp.xy*33.), vec2(0), vec2(0,1))-.3; //vertical line texture   \n    \n    tmp = vec4( uv*winDistort+vec2(0,.53), vec2(.8,.09));\n    float bBar = sdBox( tmp.xy, tmp.zw); //bottom \"screen\"\n    float bBarAmp = texelFetch( iChannel0, ivec2(1024.*abs(tmp.x/(2.*tmp.z)),0),0).x; // sound texture, full\n    tmp = vec4( uv*winDistort+vec2(1.05,.0), vec2(.2,.4));\n    float lBar = sdBox( tmp.xy, tmp.zw); //left \"screen\"\n    float lBarAmp = texelFetch( iChannel0, ivec2(24.+71.*(tmp.y+tmp.w)/(2.*tmp.w),0),0).x; // sound texture, presence\n    tmp.x = uv.x*winDistort-1.05;\n    float rBar = sdBox( tmp.xy, tmp.zw); //right \"screen\"\n    float rBarAmp = texelFetch( iChannel0, ivec2(95.+417.*(tmp.y+tmp.w)/(2.*tmp.w),0),0).x; // sound texture, brilliance\n    \n    tmp = vec4( uv*spaceRot, .1/fft.y, 0.);\n    float reticle = sdCircle( uv, tmp.z); //reticle\n    float horBars = sdSegment( abs(tmp.xy), vec2(.1+tmp.z,.0), vec2(.4+tmp.z,.0)); //horizontal bars \n    float reticleAmp = (length(uv)<.1/fft.y+.1)? //inner/outer\n        texelFetch(iChannel0,ivec2(6.+17.*rho,0),0).x : //sound texture, speech\n        (tmp.x>.0)? //left/right\n            texelFetch(iChannel0,ivec2(94.-71.*(tmp.x-.1-tmp.z)/.3,0),0).x : //sound texture, -presence\n            texelFetch(iChannel0,ivec2(5.-5.*(-tmp.x-.1-tmp.z)/.3,0),0).x; //sound texture, -bass \n\n    vec4 cannonAngle = vec4(2.4,PI-2.4,2.5,PI-2.5); //orientation   \n    vec4 cannons = vec4(\n        sdBox( (uv+vec2(.8,.6))*rotM(cannonAngle.x)-vec2(0,.1*bang.x), vec2(.1,.55)-.5*vec2(uv.y+.3,-.1)) - .02, //left bottom cannon\n        sdBox( (uv+vec2(-.8,.6))*rotM(cannonAngle.y)+vec2(0,.1*bang.y), vec2(.1,.55)-.5*vec2(uv.y+.3,-.1)) - .02, //right bottom cannon\n        sdBox( (uv*3.+vec2(-2.,-1.5))*rotM(cannonAngle.z)+vec2(0,.2*bang.z), vec2(.01,.8)+.8*vec2(uv.y-.25,.1)) - .05, //right top cannon\n        sdBox( (uv*3.+vec2(2.,-1.5))*rotM(cannonAngle.w)-vec2(0,.2*bang.w), vec2(.01,.8)+.8*vec2(uv.y-.25,.1)) - .05); //left top cannon\n\n    tmp = vec4( -.9, .39, .02, .0);\n    vec4 led = vec4( //dot lights\n        sdCircle( uv-tmp.xy-vec2(-.02,.0), tmp.z),\n        sdCircle( uv-tmp.xy-vec2(.07,.02), tmp.z),\n        sdCircle( uv-tmp.xy-vec2(.09,.08), tmp.z),\n        sdCircle( uv-tmp.xy-vec2(.0,.06), tmp.z));\n    \n    tmp = vec4( uv*rotM(2.9)+vec2(.8,.6), .005, -.02);\n    float strip1 = sdSegment( tmp.xy, vec2(.0), vec2(.5,.0)) - tmp.z; //strip light 1 carve-out\n    float strip2 = sdSegment( tmp.xy, vec2(.0,tmp.w), vec2(.4,tmp.w)) - tmp.z; //strip light 2 carve-out\n    float strip3 = sdSegment( tmp.xy, vec2(.0,2.*tmp.w), vec2(.3,2.*tmp.w)) - tmp.z; //strip light 3 carve-out\n    float strip1fill = sdSegment( tmp.xy, vec2(.0), vec2(.5*ffts.x,.0)) - tmp.z; //strip light 1 fill, speech I\n    float strip2fill = sdSegment( tmp.xy, vec2(.0,tmp.w), vec2(.4*ffts.y,tmp.w)) - tmp.z; //strip light 2 fill, speech II \n    float strip3fill = sdSegment( tmp.xy, vec2(.0,2.*tmp.w), vec2(.3*ffts.z,2.*tmp.w)) - tmp.z; //strip light 3 fill, speech III\n    \n    \n    // Draw starfield\n    vec3 col = vec3(0); \n    vec2 myUv;\n    float aFrac;\n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-aTime/32.+.25*n) - .03*fft.w*fft.w*fft.w;\n        myUv = 30. * (.3+aFrac) * uv * spaceRot;\n        col += getStar(fract(myUv)-.5, ceil(myUv)+sin(n)) \n            * smoothstep(1.,.33,aFrac) //fade in\n            * smoothstep(.0,.33,aFrac); //fade out (not very graceful)\n    }\n    \n    \n    // Draw screen overlay   \n    reticle = clamp( .005/abs(reticle), .0, 1.) + clamp( .005/abs(horBars), .0, 1.); //glow\n    reticle = reticle * mix( 1., smoothstep(.2,.8,reticleAmp), .75*smoothstep(.66,1.,reticle)); //mix with texture\n    col += mix(reticle,pow(reticle,20.),reticle) * getCol(colId+0.); //heighten contrast & color\n\n    col -= clamp(-1.,.0,texelFetch( iChannel0, ivec2(512.*2.*abs(fragCoord.x/iResolution.x-.5)*winDistort,0),0).x \n        - 1.5*abs(fragCoord.y/iResolution.y-.5)*winDistort) * (.8+.2*getCol(colId)); //sound texture \"shield\"\n     \n     \n    // Draw cannons \n    vec4 flashX = vec4(.4,-.4,-.51,.51); //x position\n    vec4 flashY = vec4(.21,.21,-.3,-.3); //y position\n    vec4 flashMorphX = vec4(1,1,4,4); //x stretch\n    vec4 flashMorphY = vec4(5,5,20,20); //y stretch\n    for (int n=0;n<4;n++) //draw \"nuzzle\" flash\n        col += .1 * (clamp( .1 / clamp( \n            length( (uv+vec2(flashX[n],flashY[n]))*rotM(cannonAngle[n])*vec2(flashMorphX[n],flashMorphY[n]) - sign(flashX[n])*vec2(0,.18*bang[n])) - .05\n            , .001, 1.) * pow(bang[n],9.), .08, 10.) - .08);    \n    for (int n=0;n<4;n++)\n        tmp[n] = aaStep(cannons[n]);\n    col *= 1. - dot(tmp,vec4(1)); //delete col at cannon positions\n    for (int n=0;n<4;n++)\n           col += tmp[n] * (.05-cannons[n]) * (.6+.4*getCol(colId)) * (.5+.5*bang[n]); //cannons\n\n\n    // Draw inside    \n    col *= aaStep(window); //delete\n    col += (1.-aaStep(window)) * (.8+.2*getCol(colId)) * (.3+.7*ffts.w) * .1; //window frame\n    col -= (1.-aaStep(frame)) * (.8+.2*getCol(colId)) * (.3+.7*ffts.w) * .05; //frame of window frame\n\n    col *= 1. - aaStep(sideBox); //delete\n    col += aaStep(sideBox) * (.15+sideBox) * (.7+.3*getCol(colId)) * (.3+.7*ffts.w) * 1.5; //bottom side elements\n    \n    col *= 1. - aaStep(vent) * aaStep(ventAmp); //vent\n    \n    col *= 1.-(aaStep(bBar)+aaStep(lBar)+aaStep(rBar)); //delete\n    col += aaStep(bBar) * bBarAmp*bBarAmp*bBarAmp * getCol(colId+1.) //bottom \"screen\"\n        + aaStep(lBar) * lBarAmp*lBarAmp*lBarAmp*lBarAmp * getCol(colId) //left \"screen\"\n        + aaStep(rBar) * rBarAmp*rBarAmp * getCol(colId); //right \"screen\"        \n        \n    tmp = vec4(bBar,lBar,rBar,0);\n    for (int n=0;n<3;n++)\n        col *= 1. - aaStep(abs(tmp[n]),.01)  * .9; //\"screen\" frames   \n\n    col *= 1. - (aaStep(led.x)+aaStep(led.y)+aaStep(led.z)+aaStep(led.w)); //delete\n    for (int n=0;n<4;n++)\n        col += (aaStep(led[n]) + .001/length(led[n])) * (.2+.8*step(.6,fft[n])) * getCol(colId+float(n)); //round led lights\n    \n    col *= 1. - (aaStep(strip1) + aaStep(strip2) + aaStep(strip3)); //delete\n    col += aaStep(strip1fill) * getCol(colId+0.) * .7; //top right line 1\n    col += aaStep(strip2fill) * getCol(colId+1.) * .7; //top right line 2\n    col += aaStep(strip3fill) * getCol(colId+2.) * .7; //top right line 3\n \n    \n    // Finalizations\n    col -= length(uv) * .03; //vignette\n    col = pow(col, vec3(.4545)); //gamma correction\n \n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 33585, "src": "https://soundcloud.com/bop/imanu-noir-bop-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 332, 423, 1545], [1547, 1547, 1569, 1603, 2636], [2638, 2638, 2659, 2729, 2822], [2824, 2824, 2849, 2849, 2891], [2892, 2914, 2955, 2955, 3011], [3045, 3045, 3064, 3064, 3117], [3140, 3140, 3173, 3173, 3199], [3201, 3201, 3230, 3289, 3369], [3371, 3371, 3412, 3470, 3588], [3590, 3590, 3620, 3620, 4185], [4187, 4187, 4242, 4277, 11812]]}
{"id": "DtVSD3", "name": "10-06-2023 - 3 - Lorentzian Sine", "author": "Eise", "description": "A cool sine wave pattern (improved based on a suggestion from @maxwell)", "tags": ["pattern", "cool", "sinewaves"], "likes": 5, "viewed": 144, "published": 3, "date": "1686421969", "time_retrieved": "2024-07-30T17:50:24.244475", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gd = length(uv);\n    vec3 finCol = vec3(0.0);\n    \n    vec3 col = vec3(1.0, 2.0, gd);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        float speed = 3.0 - i;\n        float amp = 1.0 / (uv.x * uv.x + 1.0);\n        float freq = 4.0;\n\n        float d = amp * sin((uv.x + iTime * speed) * freq) - uv.y;\n        d = abs(d);\n        d = smoothstep(0.0, 0.2, d);\n        d = 0.02/d;\n\n        finCol += d * col;\n    }\n    \n    fragColor = vec4(finCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 625]]}
{"id": "DlGXDc", "name": "Playing #2", "author": "matheusgirola", "description": "Experiment with shaders using hexagons and 2 color palettes", "tags": ["shader"], "likes": 5, "viewed": 185, "published": 3, "date": "1686404242", "time_retrieved": "2024-07-30T17:50:24.995467", "image_code": "vec3 palette_1( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette_2( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(0.50, 0.20, 0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    vec2 s = sign(p);\n    p = abs(p);\n\tfloat w = dot(k.xy,p);    \n    p -= 2.0*min(w,0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    float d = length(p)*sign(p.y);\n    vec2  g = (w<0.0) ? mat2(-k.y,-k.x,-k.x,k.y)*p : p;\n    return vec3( d, s*g/d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 q = p;\n    // size\n\tfloat si = 0.3 + 0.25*sin( iTime );\n    // corner radious\n    float ra = 0.2*(0.5+0.5*cos(iTime*2.0));\n    \n    // fract the screen\n    p = fract(p*2.) - 0.5;\n    \n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgHexagon(p,si);\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n\n\t// coloring\n    vec3 col = (d>0.0) ? palette_2(0.4*length(q) + 0.1*iTime):\n                         palette_1(0.8*length(q) + 0.1*iTime);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-10.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 210], [212, 212, 239, 239, 422], [424, 424, 467, 467, 785], [787, 787, 844, 844, 1540]]}
{"id": "DtGXDc", "name": "10-06-2023 - 2 - Polyrhythm", "author": "Eise", "description": "Different polyrhythm, syncing and desyncing, in cool neon colors.", "tags": ["balls", "neon", "cool", "polyrithms"], "likes": 5, "viewed": 202, "published": 3, "date": "1686403609", "time_retrieved": "2024-07-30T17:50:25.785355", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += 1.0;\n\n    float gd = length(uv);\n    vec3 finCol = vec3(0.0);\n    vec3 col = 2.0 * vec3(0.5 + sin(iTime), 0.5 + sin(iTime + 3.1415), gd);\n    \n    float speed = 0.03 * 3.1415;\n   \n    for (float i = 1.0; i < 18.0; i++) {\n        float r = i / 10.0;\n\n        float d = length(uv.xy - vec2(r * cos(iTime * i * speed), r * abs(sin(iTime * i * speed))));\n        d -= 0.01;\n        d = smoothstep(0.0, 0.2, d);\n        d = 0.001 / d;\n\n        finCol += d * col;\n    }\n    \n    fragColor = vec4(finCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 672]]}
{"id": "clyXWc", "name": "10-06-2023 - 1 - Sine waves", "author": "Eise", "description": "A cool sine wave pattern", "tags": ["pattern", "cool", "sinewaves"], "likes": 2, "viewed": 177, "published": 3, "date": "1686401179", "time_retrieved": "2024-07-30T17:50:26.532358", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gd = length(uv);\n    vec3 finCol = vec3(0.0);\n    \n    vec3 col = vec3(1.0, 2.0, gd);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        float speed = 3.0 - i;\n        float amp = 0.5;\n        float freq = 4.0;\n\n        float d = amp * sin((uv.x + iTime * speed) * freq) - uv.y;\n        d = abs(d);\n        d = smoothstep(0.0, 0.2, d);\n        d = 0.02/d;\n\n        finCol += d * col;\n    }\n    \n    fragColor = vec4(finCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 603]]}
{"id": "ctyXW3", "name": "Hypnotica", "author": "AlexAnimations", "description": "A fun experiment with sin waves", "tags": ["spectrum", "hypnotic"], "likes": 1, "viewed": 115, "published": 3, "date": "1686391004", "time_retrieved": "2024-07-30T17:50:27.302299", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(sin(length((iMouse.xy-fragCoord))/10.+iTime),sin((length(iMouse.xy-fragCoord)+180.)/10.+iTime/2.),sin((length(iMouse.xy-fragCoord)+270.)/10.+iTime/3.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 411]]}
{"id": "clGXW3", "name": "show this to your bird", "author": "mikeyaboy", "description": "If your bird looks distressed turn down the volume by a lot. If your bird stops to listen just leave the project on.", "tags": ["harmonic"], "likes": 0, "viewed": 189, "published": 3, "date": "1686390384", "time_retrieved": "2024-07-30T17:50:28.122109", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor = vec4(vec3(0),1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    float harmonic = floor(fract(time/4.0)*16.0)+1.0;\n    float frequency = mod(time*2.0, 110.0);\n    return vec2(sin((acos(0.0)*4.0)*frequency*time*harmonic)+(fract(time*frequency)))/2.0;\n    }", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 118]]}
{"id": "DtGXW3", "name": "Dreamworld", "author": "AlexAnimations", "description": "This shader depicts a relaxing dreamworld of math.", "tags": ["clouds", "rainbow", "relaxing"], "likes": 1, "viewed": 116, "published": 3, "date": "1686390044", "time_retrieved": "2024-07-30T17:50:28.865122", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(sin(uv.x+iTime)/2.+.5,sin(uv.y+(iTime/3.)+180.)/2.,length(uv.xy-.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 220]]}
{"id": "ctGXW3", "name": "warping rings", "author": "REVAL", "description": "the 1st shader I've ever written", "tags": ["circles", "rings", "ring"], "likes": 1, "viewed": 112, "published": 3, "date": "1686389647", "time_retrieved": "2024-07-30T17:50:29.610129", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    //uv = fract(uv*1.5)-0.5;\n    uv.x *= sin(uv.y + iTime);\n    uv.y *= sin(uv.x * uv.x + iTime);\n    \n    float d = length(uv);\n    d *= .5;\n        \n    d = sin(d * 100.);\n    d = step(0.2, d);\n        \n    \n    //d = step(, d);\n\n    // Output to screen\n    fragColor = vec4(d ,sin(d * iTime) ,d , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 149, 506]]}
{"id": "dlKSDV", "name": "DotCamera", "author": "FabriceNeyret2", "description": "adapted from https://google.github.io/swissgl/#DotCamera\n\nchoose image or video source in BuffA\nchoose sensibility to target vs point-repulsion in buffB:18\n\n( stability probably not normalized vs resolution/FPS.\n  yep, I should use Voronoi tracking :-) )", "tags": ["video", "sampling", "points", "halftoning", "stipples"], "likes": 23, "viewed": 2235, "published": 3, "date": "1686387147", "time_retrieved": "2024-07-30T17:50:30.359126", "image_code": "// === display =====================================================\n// adapted from https://google.github.io/swissgl/#DotCamera\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U  = u / R.y, D;\n    O *= 0.;\n    O += .5 * texture(iChannel1, u/R ).a;             // display source image\n // O.r = texture(iChannel2, u/R ).z;                 // debug\n \n    float m = 9.;                                     // display points\n    for (int i=0; i < N*N; i++ )\n        D = U - texelFetch(iChannel0, ivec2(i%N,i/N), 0).xy,\n        m = min(m, dot(D,D));                         // get closest\n\n    O += smoothstep( 2./R.y,0., sqrt(m) -.003 );      // paint dot\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === force field toward target ==================== \n// .xy: gradient\n// .w : value\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O *= 0.;\n    for (float i=0.; i<7.; i++ )               // large filter so that gradient acts at all scales\n        O += textureLod(iChannel0, u/R, i );\n    O /= 7.;\n    \n    float v = dot( O.rgb, vec3(.21,.72,.07) ); // luminance\n    O = vec4( dFdx(v),dFdy(v),0,v);            \n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === points ===============\n// .xy = point coordinates\n\n#define H(p) fract(sin((mod(p,6.28))*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if ( int(min(u.x,u.y)) >= N ) discard;                // we track N*N points\n    \n    if (iFrame<1) {\n        O = vec4( H(u)*R/R.y, 0,0 );                      // start: random location\n        return;\n      }\n    O =  texelFetch(iChannel0, ivec2(u), 0);\n    vec2 T = O.xy * R.y/R;                                // renormalize coordinates for texture access\n    vec3 F = texture(iChannel2, T ).xyz;                  // read repulsion field\n    if (F.z > 1.9 ) O.xy += .2* ( H(u+iTime) -.5 ) / R.y; // repulsion by other points\n    F.xy = 1.*F.xy + 2.*texture(iChannel1, T ).xy;        // attraction by target image\n    O.xy = clamp( O.xy + 30.*F.xy/R.y, vec2(0), R/R.y );  // new location\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define N 32                             //we display N x N particles", "buffer_c_code": "// === repulsing field around points ===================\n// .xy : gradient\n// .z  : value\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U  = u / R.y, D;\n    O *= 0.;\n\n    for (int i=0; i < N*N; i++ )                               // for each point\n        D = U - texelFetch(iChannel0, ivec2(i%N,i/N), 0).xy,\n        D *= float(N),\n        O.xyz += vec3(D,1) * exp(-dot(D,D)*vec3(4,4,8));       // sum-up gradient + gaussian field\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 168, 168, 655]]}
{"id": "dlKSDK", "name": "shallow ocean", "author": "ianertson", "description": "A not so very deep ocean.\nUse the mouse to look around :)", "tags": ["sea", "water", "ocean", "foam"], "likes": 11, "viewed": 565, "published": 3, "date": "1686375546", "time_retrieved": "2024-07-30T17:50:31.103137", "image_code": "#define R iResolution.xy\n#define T ((iTime+90.)*2.1)\n#define ZERO min(iFrame, 0)\n#define NEAR 0.003\n#define FAR 1600.0\n#define MAX_STEPS 40\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nfloat smod(float x, float y) {\n    float k = abs(0.5-fract(x/y));\n    return smoothstep(0.0, 1.0, k);\n}\n\n#define NOISE(p, seed) (textureLod(iChannel3, ((p+0.289128) + (seed * 156.0))/256.0, 0.1).rgb)\n\nvec3 noise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(NOISE(id, seed), NOISE(id+vec2(1, 0), seed), lv.x),\n        mix(NOISE(id+vec2(0, 1), seed), NOISE(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * noise(p*freq, seed);\n        div += amp;\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n#define NEG(x) ((x)*2.0-1.0)\n\nfloat sdfWater(in vec3 p) {\n    if (p.y > 10.23) return p.y;\n    float t = T*0.15;\n    float freq = 0.59;\n    \n    vec2 offset = vec2(cos(t*2.0), sin(t*2.0))*1.3;\n    vec2 mp = vec2(smod(p.x, 200.0), smod(p.y, 200.0)) * 0.5;\n    \n    float h = 0.0;\n    vec2 shift = vec2(sin(t), cos(t)) * 1.5;\n    vec2 dir = vec2(1, 0);\n    float k1 = (0.5+(0.5*sin(mp.x*shift.y*0.1)));\n    float k2 = (0.5+(0.5*sin(mp.y*shift.x*0.1)));\n    float k = (k1 + k2) * 0.5;\n    dir = mix(dir, vec2(0, 1), k*0.25);\n    \n    dir *= rot(t);\n    vec3 n0 = noise(p.xz + (shift * 100.), 0.00001231, 0.009, 3);\n    shift *= (0.25+(0.75*dot(normalize(shift), dir)))*2.;\n    shift += 0.15*offset;\n    h += NEG(n0.x * n0.y + n0.z);\n    shift = mix(shift, (0.06*offset)+dir*vec2(sin(t+h-n0.x), cos(t+h-n0.y)), 0.5*smoothstep(0.4, 0.7, n0.x));\n    vec3 n1 = noise(p.zx + (shift * 50.0), 11.982715, 0.01, 4);\n    h += NEG(n1.x * n1.y + n1.z);\n    shift = mix(shift, dir*vec2(sin(t+h-n1.x), cos(t+h-n1.y)), 0.5*smoothstep(0.4, 0.7, n1.z));\n    shift -= offset*0.33;\n    vec3 n3 = noise(p.xz - (shift * 30.0), 55.555315, 0.06, 3);\n    h += NEG(n3.x) * smoothstep(0.4, 0.7, (n1.y+(n0.z*0.5))*0.6);\n    vec3 n4 = noise((offset*0.03)+p.zx + (shift * 30.0), 201.0928182, 0.08, 6);\n    float b = 0.15;\n    float ib = 1.0 - b;\n    h += NEG(n4.x * n4.y + n4.z) * (b + (ib * smoothstep(0.4, 0.9, (n0.z+n3.y+n0.z)*0.333333)));\n    \n    h *= 0.3333333;\n    \n    h *= 30.;\n    return ((p.y+h)/1.1)-4.;\n}\nfloat ground(in vec3 p) {\n    float h = 0.0;\n    \n    \n    vec3 n0 = noise(p.xz*1.9, 1.119281, 0.003, 6);\n    h += n0.x*(10.0+(n0.y + n0.z));\n    h += (h*h);\n    \n    vec3 n1 = noise(p.zx, 10.9281812, 0.02, 6);\n    h += (n1.x * n1.y + n1.z)*30. * smoothstep(0.4, 0.7, n0.y);\n    \n    vec3 n2 = noise(p.xz, 166.03989182, 0.003, 3);\n    \n    float fg = n2.x * n2.x;\n    float g = ((fg*fg) + (n0.z * n0.y + n0.z * n0.y)) * 40.0;\n    \n    h -= g*1.1111;\n    h += smoothstep(0.015, 0.5, n2.y)*100.*n2.y*n2.y*max(0.0, 1.0-fg);\n\n    \n    return h/1.05;\n}\nfloat sdf(in vec3 p, bool water) {\n    if (p.y < -200.) return p.y;\n    if (water) return sdfWater(p);\n    if (p.y > 16.2) return p.y;\n\n    float h = ground(p);\n    \n    return ((p.y+h)/1.1)+((p.y+4.0)*0.4);\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n};\n\nbool march(in vec3 ro, in vec3 rd, inout Data data, bool water, in float far) {\n    data.d = FAR;\n    float d = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * d;\n        float next = sdf(p, water);\n        \n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (abs(d) * 2.5)))) break;\n        if (d >= far) return false;\n    }\n    \n    d = abs(d);\n    vec3 p = ro + rd * d;\n    vec2 e = vec2(water ? 0.09 : 0.05, 0.0);\n    data.n = normalize(sdf(p, water) - vec3(\n        sdf(p - e.xyy, water),\n        sdf(p - e.yxy, water),\n        sdf(p - e.yyx, water)\n    ));\n    data.d = d;\n    data.p = p;\n    return true;\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = vec3(0.22, 0.66, 0.72);\n    col = col * col;\n    col = pow(col, vec3(1.0 + dotup*2.0));\n    return col;\n}\n\nvec3 blit(in vec3 ro, in vec3 rd, in Data data, in vec3 L, in vec3 lcol, in vec3 alb, float spf) {\n    vec3 col = vec3(0.0);\n    vec3 N = data.n;\n    vec3 ref = reflect(L, N);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 128.0) * spf;\n    vec3 diffuse = alb / M_PI;\n    float NdotL = max(0.0, dot(N, L));\n    vec3 att = NdotL * NdotL * diffuse * lcol;\n    col += (att + spec);\n    \n    \n    vec3 ref2 = reflect(rd, N);\n    \n\n    vec3 env = getSky(ref2);\n    \n    col += env * col;\n    return col;\n}\n\n\nvec3 tt(in sampler2D samp, in vec2 uv, in vec3 N, in float d) {\n    vec3 n1 = noise(uv, 0.329812, 2.5, 6);\n    vec3 n2 = noise(uv.yx, 66.329812, 0.5, 6);\n    vec3 n3 = noise(uv.xy+0.38281, 231.281, 0.4, 6);\n    vec3 n4 = noise(uv.yx+13.3333, 125.38281, 0.1, 3);\n    vec3 c1 = vec3(0.5, 0.3, 0.15);\n    vec3 c2 = vec3(0.8, 0.33, 0.2);\n    vec3 c3 = vec3(0.75, 0.39, 0.25);\n    vec3 col = mix(c1, c2, n1.x);\n    col = mix(col, c3, smoothstep(0.4, 0.7, n3.x));\n    col = mix(col, clamp((col/M_PI)+0.19, 0.0, 1.0), 0.5*smoothstep(0.4, 0.7, n4.y));\n    float cc = 1.0-smoothstep(0.01, 0.1, abs(n3.z*2.0-1.0));\n    \n    col += 0.5*(c2+col*0.8)*cc*smoothstep(0.4, 0.7, n4.z);\n    return col;\n}\nvec3 render(in vec3 ro, in vec3 rd, inout float depth) {\n    depth = FAR;\n    vec3 col = vec3(0.0);\n    Data data1 = Data(vec3(0.0), vec3(0.0), FAR);\n    Data data2 = Data(vec3(0.0), vec3(0.0), FAR);\n    Data data3 = Data(vec3(0.0), vec3(0.0), FAR);\n    vec3 L = normalize(vec3(1, 2, 3));\n    vec3 lcol = vec3(0.8, 0.7, 0.65);\n\n    vec3 tmp = vec3(0.0);\n  \n    // ground over water\n    if (march(ro, rd, data3, false, FAR)) {\n      vec3 alb = tt(iChannel2, data3.p.xz, data3.n, data3.d);\n      tmp = blit(ro, rd, data3, L, lcol, alb, 0.01);\n      depth = (data3.d / FAR);\n    } else {\n       depth = FAR;\n       return getSky(rd);\n    }\n   \n    // water\n    if (march(ro, rd, data1, true, FAR)) {\n        vec3 alb = vec3(0.21, 0.66, 0.75);\n        if (data1.d-0.001 < data3.d) {\n            col += blit(ro, rd, data1, L, lcol, 0.22222*((alb*alb*alb)+0.5), 1.0);\n            depth  = data1.d / FAR;\n        }\n        \n        if (data3.d > data1.d-0.001) {\n            float ior = 1.33;\n            vec3 rd2 = refract(rd, data1.n, 1.0/ior);\n            vec3 ro2 = data1.p-data1.n*0.001;\n            \n            \n            // ground under water\n            if (march(ro2, rd2, data2, false, FAR)) {\n\n\n                float dd = distance(data1.p, data2.p) / FAR;\n\n                vec3 alb = tt(iChannel2, data2.p.xz, data2.n, data2.d);\n                col +=  blit(ro2, rd2, data2, L, lcol, alb, 0.1) / (1.0 + dd*6.0+(data2.d/FAR));\n\n                depth = max(depth,  data2.d / FAR);\n\n                float kj = distance(data2.p, data3.p);\n                // foam\n                col += smoothstep(0.04, 0.06, depth)*smoothstep(3.0, -4.0, kj) * noise(data3.p.xz+vec2(sin(T), cos(T)), 0.23918, 2.0, 1).x;\n\n            }\n        } else {\n            float dd = distance(data1.p, data3.p) / FAR;\n            col += tmp /  (1.0 + (dd*6.0));\n        }\n    }\n  \n \n    return col;\n}\nvec3 nextRo(in vec3 ro, in float t) {\n    ro.y += (35.) + 10.0*(0.5*(0.5+sin(t)));\n    ro.z += t*25.;\n    ro.x += cos((t-11.2989122)*0.15)*90.;\n    return ro;\n}\nvoid mainImage( out vec4 O, in vec2 fc )\n{   vec3 col = vec3(0.0);\n    vec2 uv = (fc - 0.5 * R.xy)/R.y;\n    \n    vec3 ro = vec3(0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv.xy, mix(1.0, 0.6, 0.33*(0.5+(0.5*cos(0.33*(T+33.329281)))))));\n    \n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy)/R.y, iMouse.zw);\n    \n    if (m.z > 0.001) {\n      rd.yz *= rot(m.y * TAU);\n      rd.xz *= rot(m.x * TAU);\n    } else {\n        rd.yz *= rot(radians(-(15. + (0.5*(0.5+cos(T+1.82818))))));\n        rd.xz *= rot(0.5*sin((T+11.023321)*0.25));\n    }\n    \n    ro = nextRo(ro, T);\n    float g1 = ground(ro);\n    float g2 = ground(nextRo(ro, T+0.015));\n    float g3 = ground(nextRo(ro, T+0.05));\n    float g4 = ground(nextRo(ro, T+0.08));\n    \n    float g = (g1 + g2 + g3 + g4) * 0.25;\n    \n    ro.y += 3.0*(1.0 - 0.85*smoothstep(0.0, 30.0, distance(vec3(0, ro.y, 0), vec3(0, g, 0))));\n    \n    float depth = FAR;\n    col = render(ro, rd, depth);\n    float b = 0.45;\n    float ib = 1.0 - b;\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    float d = smoothstep(0.1, 0.9, depth);\n    col += (d*d)* max(0.0, 1.0 - smoothstep(0.0, 0.44, dotup));\n    \n    float l = luma(col);\n  \n    col += (l*l + (col*col));\n    col += (col*col*col*col);\n    \n    col *= (1.0+col*4.);\n    \n    col /= (1.0+max(col-0.25, 0.0));\n    \n    col = aces(col);\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    O = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKSDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 208, 208, 256], [257, 257, 276, 276, 329], [331, 331, 361, 361, 434], [532, 532, 570, 570, 832], [1159, 1159, 1181, 1181, 1245], [1277, 1277, 1304, 1304, 2732], [2733, 2733, 2758, 2758, 3280], [3281, 3281, 3315, 3315, 3490], [3547, 3547, 3626, 3626, 4197], [4199, 4199, 4224, 4224, 4397], [4399, 4399, 4497, 4497, 4922], [4925, 4925, 4988, 4988, 5611], [5612, 5612, 5668, 5668, 7489], [7490, 7490, 7527, 7527, 7650], [7651, 7651, 7693, 7693, 9036]]}
{"id": "ctVSDV", "name": "cool-S-sdf", "author": "LydianLights", "description": "Gives the distance to the boundaries, have fun (_)\n(Go check out https://www.shadertoy.com/view/clVXWc for iq-approved version, haha)", "tags": ["sdf", "cools"], "likes": 5, "viewed": 410, "published": 3, "date": "1686368479", "time_retrieved": "2024-07-30T17:50:31.861110", "image_code": "// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n// Thanks iq, symmetry is good\n// see: https://www.shadertoy.com/view/clVXWc\n// for iq's optimized version\nfloat sd_COOL_S_SUNGLASSES_EMOJI(vec2 p)\n{\n    const float y1 = 0.2;\n    const float y2 = 0.6;\n    const float x1 = 0.35;\n    const float x2 = 0.175;\n    \n    const vec2 a0 = vec2(0.0, -1.0);\n    const vec2 a1 = vec2(0.0, -y1);\n    const vec2 a2 = vec2(0.0, -y2);\n    const vec2 a3 = vec2(x1, -y1);\n    const vec2 a4 = vec2(x1, -y2);\n    const vec2 a5 = vec2(x1, y2);\n    const vec2 a6 = vec2(x1, y1);\n    const vec2 a7 = vec2(0.0, y1);\n    const vec2 a8 = vec2(-x1, y1);\n    const vec2 a9 = vec2(x2, 0.0);\n\n    p = (p.y > p.x) ? -p : p;\n    vec2 q = vec2(abs(p.x), p.y);\n\n    float d = sdSegment(p, a1, a2);\n    d = min(d, sdSegment(q, a3, a4));\n    d = min(d, sdSegment(p, a5, a6));\n    \n    d = min(d, sdSegment(q, a0, a4));\n\n    d = min(d, sdSegment(p, a7, a3));\n    d = min(d, sdSegment(p, a8, a1));\n    d = min(d, sdSegment(p, a6, a9));\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float d = sd_COOL_S_SUNGLASSES_EMOJI(uv);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d - 10.0 * iTime);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,3.0*fwidth(uv.x),abs(d)));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 102, 102, 217], [219, 326, 368, 368, 1189], [1191, 1191, 1246, 1246, 1644]]}
{"id": "clKSWV", "name": "Animation 2 by Vaz", "author": "Vazpera", "description": "worling on it", "tags": ["wip"], "likes": 6, "viewed": 168, "published": 3, "date": "1686363654", "time_retrieved": "2024-07-30T17:50:32.640028", "image_code": "//Color Palette \n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.1,0.2,0.3);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-vec2(0.5,0.5))*2.0;\n         uv.x *= (iResolution.x/iResolution.y);\n         \n    vec2 uv0 = uv;\n        \n        \n    float count = 5.0;\n    \n    vec3 finalColor = vec3(0.0);\n    for(float i = 0.0; i<count; i++) {  \n         uv = fract(uv*2.0)-0.5;\n\n    float d = (length(uv))*2.5+exp(length(uv0));\n          d = 2.0*cos(d-iTime*0.2);\n          d = sin(5.0*d+iTime*1.0);\n          \n    vec3 col = palette(length(uv0)+i*0.5+iTime);\n         col = col*pow(d,1.0);\n         finalColor += col;\n    }\n    \n    finalColor*=1./(count/2.0);\n    \n    // Time varying pixel color\n    \n    \n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 45, 45, 221], [223, 223, 280, 340, 1026]]}
{"id": "DlVXWK", "name": "Hmm with tag + description thing", "author": "coolpersonlol", "description": "Wavy\nThis is basically the Opera GX Wave Shader but simpler", "tags": ["operagx"], "likes": 0, "viewed": 153, "published": 3, "date": "1686358768", "time_retrieved": "2024-07-30T17:50:33.453852", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel thing\n    uv.y += sin(sin(uv.x+iTime));\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 111, 293]]}
{"id": "mtGXWK", "name": "Bubble hexagon", "author": "Iko", "description": "Just messing around with some basic functions :)\nFeel free to mess around with the parameters", "tags": ["round", "hexagon"], "likes": 3, "viewed": 112, "published": 3, "date": "1686348842", "time_retrieved": "2024-07-30T17:50:34.208833", "image_code": "const vec2 s = vec2(1, 1.7320508);\nconst float border = .025;\nconst float speed = 1.;\nconst float nb = 30.;\nconst float exponant = 1.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    float t = iTime;\n    \n    uv = abs(uv);\n    \n    float m =  max(dot(uv, s*.5), uv.x);\n    \n    m *= exp(-length(uv)*exponant);\n    m = sin(m*nb + t*speed)/nb;\n    m = abs(m);\n    m = step(border,m);\n   \n    vec3 finalCol = vec3(m);\n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 194, 194, 527]]}
{"id": "dtySWK", "name": "Geometric Series Blobs", "author": "SnoopethDuckDuck", "description": "Change r value to see different zooms ", "tags": ["grid", "circle", "tiling", "geometric", "series", "sum"], "likes": 18, "viewed": 179, "published": 3, "date": "1686348372", "time_retrieved": "2024-07-30T17:50:35.035622", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2 tile( vec2 uv, inout float r, inout float k, inout vec2 dim0 )\n{ \n    // dim0 is n in sum r^i, i.e. largest index in the sum\n    dim0 = log(uv + 0.0001) / log(r);\n    dim0 = floor(dim0);\n    \n    // dim is r^n itself, i.e. largest term in the sum\n    vec2 dim = pow(vec2(r), dim0);   \n    \n    // a is partial sum up to n\n    vec2 a = (1. - dim) / (1.-r);\n\n    float sc = 1. / (1.-r); \n    uv = (1. - uv) / (1. - r);\n\n    float md = min(dim.x, dim.y);\n    float mx = 0.;\n \n    // Move circles\n    // (period 8 so do mod(iTime, 8.) in main)\n    if (dim0.x < dim0.y)\n       mx = thc(2.5, pi * iTime + pi*dim0.x/2. + 2.*pi*dim0.y / 8.);\n    else if (dim0.y < dim0.x)\n       mx = ths(2.5, pi * iTime + pi*dim0.y/2. + 2.*pi*dim0.x / 8.);\n       \n    uv = (uv - a - 0.5 * mix(dim, vec2(md), mx)) / md;   \n       \n    k *= sc / md;\n\n    return uv;\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n\n    float id = .5 * sign(uv.x) + sign(uv.y);   \n    uv = abs(uv);\n  \n    // Geometric series parameter ([0,1] shrinks, >1 grows)\n    float r = 1.-0.9*exp(-4.*dot(ouv,ouv));\n    r = 0.5 * tanh(0.08 * iTime); // <--- CHANGE ME <---\n    \n    // Pixel scale\n    float k = 1. / res.y;\n    \n    // Time (doesnt loop perfectly)\n    float t = mod(0.5 * iTime + 0.5*cos(.25*pi*(iTime + id)), 8.);\n\n    // Zoom out and resize pixel scale\n    uv *= exp2(-t*log2(r));\n    k  *= exp2(-t*log2(r));\n\n    // Tile coordinates\n    vec2 dim0;\n    uv = tile(uv, r, k, dim0);\n    uv *= rot(.5*pi * id + iTime);\n                   \n    vec3 col = vec3(0);\n    \n    // Circle color\n    vec3 colb = vec3(1);\n    \n    // Multiply by uv\n    colb.rg *= 0.5 + 0.5 * clamp(uv + 0.5, 0., 1.);\n    \n    // Fake fresnel (fres2 used for blending)\n    float d = abs(.5 - length(uv));\n    float fres = exp(-24. * d);\n    float fres2 = exp(-20. * d * (1.-exp(-7.*length(ouv))));\n    colb += fres * uv.x;\n    \n    // Palette color\n    colb *= .5 + .5 * cos(2.*pi*(0.5*(dim0.x+dim0.y) + id\n                         + floor(1.5*(dim0.x+dim0.y))/5.\n                         + vec3(0,1,2)/3.));\n    colb = clamp(colb, 0., 1.);\n    \n    // Fake specular\n    colb = mix(colb, vec3(1), exp(-8. * dot(uv,uv)) * min(1., uv.y+0.5));\n\n    // Circle shape\n    float s = smoothstep(-k, k, 0.5 - length(uv));\n    \n    // Background color\n    col = mix(vec3(ouv,.5), vec3(1), exp(-0.4 * dot(ouv,ouv)));\n    \n    // Background grainy texture \n    col *= .975 + .05* texture(iChannel0, 0.9 * ouv).r;\n    \n    // Remap circle color\n    colb = 1.-1./cosh(3.5 * colb);\n   \n    // Blend circle into background\n    float band = smoothstep(-1./res.y, 1./res.y, abs(0.455 - abs(ouv.y))-0.025);\n    col = mix(col, colb, 0.85 * s * (1.-fres2) * (0.8 + 0.2 * band));\n\n    O = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtySWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 219, 279, 997], [999, 999, 1041, 1041, 2960]]}
{"id": "NlBGR1", "name": "pencilEffect", "author": "antoinefortin", "description": "dfgfdg", "tags": ["pencil"], "likes": 5, "viewed": 203, "published": 3, "date": "1686348193", "time_retrieved": "2024-07-30T17:50:35.816534", "image_code": "#define size 25.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 674.3) * 453.2);\n    float y = fract(sin(t * 2674.3) * 453.2);\n    \n    return vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 debug = vec3(Hash12(uv.y).x);\n    \n    \n    for(float i = 0.; i < size; i++)\n    {\n        vec2 dir= Hash12(i * Hash12(uv.x).x - sin(Hash12(uv.y).x)) - .5;\n        \n        float t = fract(iTime * .05);\n        float d = length(uv-dir * (t + uv.x * t * uv.y));\n        \n        float brightness = 0.002;\n        \n        col += vec3(brightness / d);\n        \n    \n    }\n  //  col = vec3(Hash12(12.).x);\n    // Output to screen\n    \n    \n    fragColor = vec4(vec3(1.0, 1.0, 1.0)- col * 2.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 40, 40, 160], [162, 162, 219, 219, 812]]}
{"id": "DtVXDG", "name": "neon-psychedelic-4", "author": "LydianLights", "description": "gaze into the eye of god (god is a rhombus btw)\nnot blown away with how this one came out but that is the nature of sketches", "tags": ["psychedelic"], "likes": 3, "viewed": 190, "published": 3, "date": "1686341967", "time_retrieved": "2024-07-30T17:50:36.579495", "image_code": "const float iters = 8.0;\nfloat getTheD(in vec2 uv, in vec2 a, in float i, in float rd0, in float d0)\n{\n    float d = sdRhombus(uv, 1.5 * a);\n    d *= exp(1.3 * -rd0);\n    float k = (a.x > a.y ? 3.0 : 7.0) / 7.0;\n    k *= mod(i, 4.0) == 0.0 ? -1.0 : 1.0;\n    d = sin(3.0 * d + 0.5 * k * -iTime * ((iters - 0.2 * i) / iters) + 0.3 * i);\n    d = 2.0 * abs(d);\n    d = 0.02 / d;\n    \n    return d;\n}\n\nconst vec3 t = vec3(2.2, 1.5, 0.0);\nconst vec2 s = vec2(2.0, 1.0);\nvec3 mainPass(in vec2 fragCoord)\n{\n    vec2 uv0 = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv0.x *= iResolution.x / iResolution.y;\n    uv0 *= 2.0;\n    \n    float d0 = length(uv0);\n    float rd0 = sdRhombus(uv0, s);\n    \n    vec2 uv = uv0;\n    vec3 color = vec3(0.0);\n    \n    for (float i = 0.0; i < iters; i++)\n    {\n        uv = fract(0.7 * uv) - 0.5;\n        float d1 = getTheD(uv + t.xz, s.xy, i, rd0, d0);\n        float d2 = getTheD(uv - t.xz, s.xy, i, rd0, d0);\n        float d3 = getTheD(uv + t.zy, s.yx, i, rd0, d0);\n        float d4 = getTheD(uv - t.zy, s.yx, i, rd0, d0);\n        float d = d1 + d2 + d3 + d4;\n        \n        d = pow(d, 2.5);\n\n        vec3 c = d * palette(0.8 * i + 0.2 * iTime);\n        \n        color += c;\n    }\n    \n    return color;\n}\n\nvec3 antialias(in vec2 fragCoord)\n{\n    const float AA_STAGES = 0.0;\n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = mainPass(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "const float PI = 3.1415927;\nconst float ROOT_3 = 1.7320508;\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.9);\n    vec3 b = vec3(0.1, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 102, 102, 395], [464, 464, 498, 498, 1235], [1237, 1237, 1272, 1272, 1729], [1731, 1731, 1758, 1758, 1810], [1812, 1812, 1867, 1867, 1967]]}
{"id": "mlKXDy", "name": "Strawberry Banana Zoom", "author": "djstomp", "description": "Fractal with rotation and zoom with a bright orange/yellow/pink/purple color scheme.", "tags": ["fractal"], "likes": 2, "viewed": 223, "published": 3, "date": "1686340746", "time_retrieved": "2024-07-30T17:50:37.333479", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(2.998, 0.658, 0.718);\n    vec3 b = vec3(1.951, 0.453, 1.050);\n    vec3 c = vec3(-0.352, 2.361, -0.764);\n    vec3 d = vec3(-0.503, -0.503, -1.113);\n\n    return a + b*cos( 7.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float zoom = 1.0 + 0.5 * sin(0.2 * iTime);\n    uv /= zoom;\n    float cameraRotation = 0.2 * iTime;\n    float cs = cos(cameraRotation);\n    float sn = sin(cameraRotation);\n    uv = mat2(cs, -sn, sn, cs) * uv;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    for (float i = 0.0; i < 5.0; i++) {\n        float angle = 7.0 * 3.14159 * (i / 7.);\n        float s = sin(angle);\n        float c = cos(angle);\n        mat2 m = mat2(c, -s * 1.5, s * 0.5, c);\n        uv = m * uv;\n        uv = fract(uv * 1.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.2);\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n        finalColor += col * d;\n    }  \n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 234], [236, 236, 293, 293, 1151]]}
{"id": "mtVSDy", "name": "Computers were made for cubes", "author": "mrange", "description": "Computers were made for cubes\nMade after hanging lug00ber twitch stream: https://www.twitch.tv/lug00ber\nHad a discussion that rotating cubes + music is really what computers are made for.", "tags": ["3d", "cubes"], "likes": 69, "viewed": 2061, "published": 3, "date": "1686340350", "time_retrieved": "2024-07-30T17:50:38.089457", "image_code": "// CC0: Computers were made for cubes\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  22.0\n#define MAX_RAY_MARCHES 70\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol0   = HSV2RGB(vec3(hoff+0.05, 0.85, 0.00125));\nconst vec3 glowCol1   = HSV2RGB(vec3(hoff+0.55, 0.85, 0.05));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.60, 0.75, 0.25));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nmat3 rotX(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    1.0 , 0.0 , 0.0\n  , 0.0 , +c  , +s\n  , 0.0 , -s  , +c\n  );\n}\n\nmat3 rotY(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , 0.0 , +s\n  , 0.0 , 1.0 , 0.0\n  , -s  , 0.0 , +c\n  );\n}\n\nmat3 rotZ(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , +s  , 0.0\n  , -s  , +c  , 0.0\n  , 0.0 , 0.0 , 1.0\n  );\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(vec2 p, float freq) {\n  // Approximate distance to cos\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n\n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n\n  float a = 0.18*freq;\n\n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxf(vec3 p, vec3 b, float e) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat lug00ber(vec2 p) {\n  vec2 p0 = p;\n  p0.y = abs(p0.y);\n  p0 -= vec2(-0.705, 0.41);\n  float d0 = length(p0)-0.16;\n  \n  float topy = 0.68;\n  vec2 bp = p-vec2(0.27, -0.8);\n  float d1 = segment(p, vec2(0.72, topy), vec2(0.27, -0.8))-0.06;\n  float d2 = segment(p, vec2(-0.13, topy), vec2(0.33, -0.8))-0.1;\n  float d3 = p.y-(topy-0.066);\n\n  float d4 = box(p-vec2(-0.1, topy), vec2(0.25, 0.03))-0.01;\n  float d5 = box(p-vec2(0.685, topy), vec2(0.19, 0.03))-0.01;\n  float d6 = min(d4, d5);\n  \n  vec2 ax7 = normalize(vec2(vec2(0.72, topy)-vec2(0.27, -0.8)));\n  vec2 nor7 = vec2(ax7.y, -ax7.x);\n  float d7 = dot(p, nor7)+dot(nor7, -vec2(vec2(0.72, topy)))+0.05;\n  \n  d2 = max(d2, d7);\n  float d = d1;\n  d = pmin(d,d2, 0.025);\n  d = max(d, d3);\n  d = pmin(d, d6, 0.1);\n  d = min(d,d0);\n  \n  return d; \n}\n\nmat3 g_rot;\nfloat g_gd;\n\nfloat df(vec3 p) {\n  vec3 p0 = p;\n  p0 *= g_rot;\n  float d0 = box(p0, vec3(3.0));\n  vec3 p1 = p0;\n  float d1 = boxf(p1, vec3(3.01), 0.)-0.01;\n\n  float d = d0;\n//  d = max(d, -(d1-0.03));\n  d = min(d, d1);\n  \n  g_gd = min(g_gd, abs(d1));\n\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n//  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n\n\n  col += clamp(vec3(1.0/abs(rd.y))*glowCol0, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec3 render1(vec3 ro, vec3 rd, vec2 sp) {\n  int iter;\n\n  g_gd = 1E3;\n  float t = rayMarch(ro, rd);\n  vec3 ggcol = (glowCol1)*inversesqrt(max(g_gd, 0.00025));\n  vec3 col = render0(ro, rd);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  float fre0 = 1.0+dot(rd, n);\n  float fre = fre0;\n  fre *= fre;\n  float dif = dot(sunDir1, n); \n\n  if (t < MAX_RAY_LENGTH) {\n    col = vec3(0.0);\n    col += sunCol1*dif*dif*diffCol*0.25;\n    col += mix(0.33, 1.0, fre)*render0(p, r);\n  }\n  \n  col *= smoothstep(0.1, -0.1, cos((TAU*TIME-2.0*sp.y)/30.0));\n  col += clamp(ggcol, 0.0, 4.0);\n\n  return col;\n}\n\nvec3 overlay(vec3 col, vec2 p) {\n  vec2 p0 = p;\n  float dl = lug00ber(p);\n\n  const float z1 = 0.25;\n  vec2 p1 = p;\n  p1.x += 0.1*TIME;\n  p1 /= z1;\n  float dc = dfcos(p1, 0.5)*z1;\n  dc = abs(dc)- mix(0.025, 0.00, smoothstep(0., 2.0, abs(p.x)));\n  float aa = 4.0/RESOLUTION.y;\n  \n  float d = dl;\n  d = pmax(d, -(dc-0.025), 0.025);\n  d = min(d, dc);\n  \n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, d));\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = TIME*0.5+10.0;\n  \n  g_rot = rotX(0.333*tm)*rotZ(0.5*tm)*rotY(0.23*tm);\n  \n  vec3 ro = 2.0*vec3(5.0, 1.0, 0.);\n  ro.xz *= ROT(-0.1*tm);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd, p);\n  col -= 0.05*length(pp);\n  col *= smoothstep(1.5, 0.5, length(pp));\n\n  col = aces_approx(col); \n  col *= smoothstep(2.0, 6.0, TIME);\n  col = overlay(col, p);\n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 508, 530, 530, 676], [1431, 1538, 1564, 1564, 1748], [1750, 1750, 1770, 1770, 1890], [1892, 1892, 1912, 1912, 2032], [2034, 2034, 2054, 2054, 2176], [2178, 2265, 2287, 2287, 2321], [2323, 2410, 2443, 2476, 2798], [2800, 2800, 2842, 2842, 2889], [2891, 3009, 3036, 3036, 3112], [3114, 3207, 3234, 3234, 3321], [3323, 3416, 3453, 3453, 3740], [3742, 3860, 3899, 3899, 4018], [4020, 4120, 4159, 4159, 4244], [4246, 4246, 4285, 4285, 4314], [4316, 4316, 4340, 4340, 5113], [5140, 5140, 5158, 5158, 5391], [5393, 5393, 5416, 5416, 5624], [5626, 5626, 5660, 5660, 5994], [5996, 5996, 6028, 6028, 6681], [6683, 6683, 6724, 6724, 7294], [7296, 7296, 7328, 7328, 7715], [7717, 7717, 7747, 7747, 8399], [8401, 8401, 8458, 8458, 8649]]}
{"id": "DlKXWG", "name": "RGB-circle", "author": "silica163", "description": "spin rgb color circle.", "tags": ["2d", "color", "circle", "rgb"], "likes": 2, "viewed": 173, "published": 3, "date": "1686326448", "time_retrieved": "2024-07-30T17:50:38.833468", "image_code": "#define PI 3.14159265\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv *= 2.;\n    //uv.x += iTime;\n    \n    vec3 col = vec3(0);\n    float a = atan(uv.x,uv.y)/2.+iTime;\n    col.r += abs(cos(a));\n    col.g += abs(cos(a+(4./3.)*PI));\n    col.b += abs(cos(a+(2./3.)*PI));\n    \n    col *= smoothstep(1.,.8,length(uv))-smoothstep(.8,.6,length(uv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 482]]}
{"id": "mtySDy", "name": "Playing #1", "author": "matheusgirola", "description": "#1 experiment with patterns", "tags": ["fractal"], "likes": 1, "viewed": 124, "published": 3, "date": "1686322758", "time_retrieved": "2024-07-30T17:50:39.602412", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(1.9, 0.20, 0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.xy;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    float d = length(uv);\n    \n    for (float i = 0.0; i <3.0 ; i++){\n        uv = fract(uv*2.5) - 0.5;\n\n        d = sin(d*3. + iTime)/3.;\n        \n        // playing with the three above lines made interesting patterns to explore\n        //d = abs(d);\n        //d = pow(0.01/d, 1.001);\n        d = 0.05/d;\n        //----\n\n        vec3 col = palette(length(uv) + i*1.2 + 0.4*iTime);\n\n        float r = 0.2 + 0.8*cos( atan(uv.y,uv.x)*10.0  + i*20. + 20.0*d);\n\n        col *= smoothstep(r, r+0.09, d);\n        \n        finalColor += col * d;\n        \n        }\n\n     // Output to screen\n     fragColor = vec4(finalColor,1.0);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtySDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 64, 64, 246], [248, 248, 305, 355, 1105]]}
{"id": "dtySDy", "name": "(Yet another) pixel2hex", "author": "FordPerfect", "description": "Convert pixel coordinates to containing hex location (in cube coordinates, see https://www.redblobgames.com/grids/hexagons/).", "tags": ["hexagon"], "likes": 4, "viewed": 227, "published": 3, "date": "1686322690", "time_retrieved": "2024-07-30T17:50:40.462114", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// See https://www.redblobgames.com/grids/hexagons/ for context.\n// The algorithm is nearly equivalent to\n// https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#justin-pombrio\n// but derived independently.\n\n// Returns point on the plane u+v+w=0 from\n// its x,y coordinates in specific\n// Cartesian 2D coordinate system on that plane.\nvec3 pixel2cube(vec2 xy)\n{\n    const float A=1.0/sqrt(3.0),B=1.0/3.0;\n    return mat2x3( // WARNING: column-major!\n        +A,0.0,-A,\n        -B,B+B,-B)*xy;\n}\n\n// Returns containing hexagon location in cube coordinates.\n// May easily return ivec3 instead.\n// WARNING: result has the wrong sign (i.e. the offset\n// from hex center is r+cube_round(r), NOT r-cube_round(r)).\nvec3 cube_round(vec3 uvw)\n{\n#if 0\n    // Concise but may violate constraint q+r+s=0 due to\n    // floating point accuracy, and also inefficient.\n    return round((floor(uvw.zxy-uvw)-floor(uvw-uvw.yzx))/3.0);\n#else\n    float xy=floor(uvw.x-uvw.y);\n    float yz=floor(uvw.y-uvw.z);\n    float zx=floor(uvw.z-uvw.x);\n    float q=round((zx-xy)/3.0);\n    float r=round((xy-yz)/3.0);\n    float s=-q-r;\n    return vec3(q,r,s);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Pixel coordinates.\n    vec2 xy=(fragCoord-iResolution.xy/2.0)/iResolution.x;\n    \n    // Scale.\n    xy*=15.0+10.0*sin(0.37*iTime);\n    xy+=10.0*vec2(sin(0.17*iTime),cos(0.17*iTime));\n\n    // Float-point cube coordinates.\n    vec3 uvw=pixel2cube(xy);\n    \n    // Integer cube coordinates.\n    vec3 qrs=cube_round(uvw);\n\n    // Output to screen.\n    fragColor=vec4(0.5*sin(28.0*qrs)+0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtySDy.jpg", "access": "api", "license": "public-domain", "functions": [[290, 417, 443, 443, 575], [577, 789, 816, 816, 1216], [1218, 1218, 1272, 1298, 1672]]}
{"id": "ctyXWG", "name": "09-06-2023 - 1 - Cicles", "author": "Eise", "description": "A cool pattern.", "tags": ["pattern"], "likes": 1, "viewed": 124, "published": 3, "date": "1686319978", "time_retrieved": "2024-07-30T17:50:41.348743", "image_code": "vec3 palette(float t)\n{\n    vec3 a = vec3(1.208, 0.718, 0.588); \n    vec3 b = vec3(1.938, 0.610, 0.518);\n    vec3 c = vec3(1.130, 1.010, 1.010);\n    vec3 d = vec3(-0.922, 0.333, 0.667);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Res, preserve aspact rat\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Globaul distance from center\n    float gd = length(uv);\n    \n    vec3 finCol = vec3(0.0);\n    \n    // Loop for effects sake\n    for (float i = 0.0; i < 2.0; i++) {\n        // Split into multiple windows/circles\n        uv = fract(uv * 2.0);\n        uv -= 0.5;\n\n        // Local distance in window, calc circle draw value\n        float ld = length(uv);\n        ld += exp(-length(-gd));\n        ld = sin(ld * 10.0 + iTime * i)/10.0;\n        ld = abs(ld);\n        ld = smoothstep(0.0, 0.1, ld);\n        ld = 0.1 / ld;\n\n        // Gradient over screen\n        vec3 col = palette(gd + iTime * 0.5);\n\n        // Draw col based on circle\n        finCol += col * ld;\n    }\n\n    fragColor = vec4(finCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 234], [236, 236, 293, 325, 1137]]}
{"id": "mlGXDG", "name": "09-06-2023 - 2 - Squares", "author": "Eise", "description": "A pattern of squares dancing", "tags": ["pattern", "squares"], "likes": 1, "viewed": 119, "published": 3, "date": "1686319908", "time_retrieved": "2024-07-30T17:50:42.111703", "image_code": "vec3 palette(in float t)\n{\n    vec3 a = vec3(0.500, 0.500, 0.500); \n    vec3 b = vec3(0.468, 0.378, -0.202);\n    vec3 c = vec3(2.000, 1.000, 1.500);\n    vec3 d = vec3(0.000, 0.468, 0.158);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Res, preserve aspact rat\n    vec2 uv0 = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv0.x *= iResolution.x / iResolution.y;\n    \n    float gd = length(uv0);\n    vec3 finCol = vec3(0.0);\n    \n    // First rev\n    vec2 uv1 = uv0;\n    for (float i = 1.0; i < 3.0; i++) {\n        uv1 = fract(uv1 * 1.5);\n        uv1 -= 0.5;\n        \n        // Create moving box\n        float boxSize = abs(sin(iTime * 3.0 * i)/2.0);\n        float ld = sdBox(uv1, vec2(boxSize));\n        ld = abs(ld) * exp(-ld);\n        ld = smoothstep(0.0, 0.2, abs(ld));\n        ld = 0.02 / ld;\n\n        // Add color to finCol if in square\n        finCol += ld * palette(fract(gd * i + iTime));\n    }\n    \n    // Second rev\n    vec2 uv2 = uv0;\n    for (float i = 1.0; i < 2.0; i++) {\n        uv2 = fract((uv0) * 1.5);\n        uv2 -= 0.5;\n        \n        float boxSize = abs(sin(iTime * 2.0 * i)/2.0);\n        float ld = sdBox(uv2, vec2(boxSize));\n        ld = abs(ld) * exp(-ld);\n        ld = smoothstep(0.0, 0.2, abs(ld));\n        ld = 0.02 / ld;\n\n        finCol += ld * palette(fract(gd * i + iTime));\n    }\n\n    fragColor = vec4(finCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 237], [239, 239, 274, 274, 359], [361, 361, 418, 450, 1539]]}
{"id": "clyXWG", "name": "Osculating Sphere Variations", "author": "dr2", "description": "To kiss or not to kiss with octahedral sphere packing", "tags": ["fractal", "schottky"], "likes": 17, "viewed": 275, "published": 3, "date": "1686312299", "time_retrieved": "2024-07-30T17:50:42.869676", "image_code": "// \"Osculating Sphere Variations\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/* Started from \"3D kissing-Schottky Orbit-sphere\" by soma_arc */\n\n#define AA    0  // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#define N_VERT  6\n\nvec3 ltDir, sPos[N_VERT];\nfloat dstFar, tCur, cRad, rRef;\nint nFrame, nIt;\nconst int maxIt = 40;\nconst float pi = 3.1415927;\n\nvoid Setup ()\n{\n  vec2 e;\n  e = vec2 (1., 0.);\n  sPos[0] = e.xyy;\n  sPos[1] = - e.xyy;\n  sPos[2] = e.yxy;\n  sPos[3] = - e.yxy;\n  sPos[4] = e.yyx;\n  sPos[5] = - e.yyx;\n  cRad = 1. / sqrt(2.);\n  rRef = cRad * 5. / 12.;  // (for kissing spheres)\n  rRef *= 1.2 + 0.85 * sin (0.2 * pi * tCur);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 q;\n  float r2, pp, sFac;\n  bool done;\n  r2 = cRad * cRad;\n  sFac = 1.05;  // (1.0 for the original)\n  nIt = 0;\n  q = vec4 (p, 1.);\n  for (int j = VAR_ZERO; j < maxIt; j ++) {\n    done = true;\n    for (int k = VAR_ZERO; k < N_VERT; k ++) {\n      p = q.xyz - sPos[k];\n      pp = dot (p, p);\n      if (pp < r2) {\n        q = sFac * (r2 / pp) * vec4 (p, q.w) + vec4 (sPos[k], 0.);\n        nIt = j + 1;\n        done = false;\n        break;\n      }\n    }\n    if (done) break;\n  }\n  return 0.1 * (length (q.xyz) - rRef) / q.w;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) dMin = d;\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dHit, d, nDotL;\n  Setup ();\n  col = vec3 (0.4, 0.42, 0.4);\n  if (BallHit (ro, rd, cRad) < dstFar) {\n    dHit = 0.;\n    for (int j = VAR_ZERO; j < 1000; j ++) {\n      d = ObjDf (ro + dHit * rd);\n      if (d < 1e-5 || dHit > dstFar) break;\n      dHit += d;\n    }\n    if (dHit < dstFar) {\n      ro += dHit * rd;\n      vn = ObjNf (ro);\n      nDotL = max (dot (ltDir, vn), 0.);\n      col = (nIt == 0) ? vec3 (0.95, 0.95, 1.) :\n         HsvToRgb (vec3 (fract (- 2. * log2 (float (nIt)) / log2 (float (maxIt))), 1., 1.));\n      col = col * (0.2 + 0.8 * nDotL * nDotL) +\n         vec3 (0.2) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  zmFac = 6.;\n  if (mPtr.z > 0.) {\n    az += 2.2 * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 14. * abs (mPtr.x);\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.2 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -5.);\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyXWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[507, 507, 522, 522, 797], [799, 799, 821, 821, 1350], [1352, 1352, 1373, 1373, 1630], [1632, 1632, 1677, 1677, 1864], [1866, 1866, 1901, 1901, 2588], [2590, 2590, 2646, 2646, 3733], [3735, 3735, 3759, 3759, 3881], [3883, 3883, 3919, 3919, 4125], [4127, 4127, 4157, 4157, 4270]]}
{"id": "dtKSRW", "name": "Neutron Star II", "author": "hashtagexo", "description": "gravity is strong enough near the surface of neutron stars to cause a curious relativistic light deflection effect: a perfect sphere that you can see more than half the surface of from any viewpoint", "tags": ["dynamic", "neutronstar"], "likes": 6, "viewed": 186, "published": 3, "date": "1686308786", "time_retrieved": "2024-07-30T17:50:43.627650", "image_code": "// Fork of \"Shader2 Sun\" by PatrickHuang. https://shadertoy.com/view/cl3SD7\n// 2023-06-05 14:42:27\n\n// based on https://www.shadertoy.com/view/4dXGR4\n\n// by trisomie21 -\n// vec3UVfloat uv.z\n\nfloat snoise(vec3 uv, float res)\t\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4); //1e210(1,100,10000) \n\t\n\tuv *= res; //uv* \n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n    //f\n\tvec3 f = fract(uv); f = f*f*(3.0-1.9*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-4)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(-sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.6;\n}\n\n//float\nfloat freqs[4];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // channel1freqs\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n    \n    //\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25; //[0,0.5]\n\tfloat radius\t\t= 0.31 + brightness * 0.096; //basic0.24 brightness\n\tfloat invRadius \t= 1.0/radius;\n\t\n    //\n\tvec3 orange\t\t\t= vec3( 0.2, 0.03, 0.93 ); // now they purple & bluish\n\tvec3 orangeRed\t\t= vec3( 0.1, 0.03, 0.998 );\n    \n    //iTime*0.1\n\tfloat time\t\t= iTime * 3.90;\n    \n    //Part1 \n    \n    //[-0.5,0.5]\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy; //uv[0,1]\n\tvec2 p \t\t\t= -0.5 + uv; //p[-0.5,0.5]\n\tp.x *= aspect;  //p.x [-0.85,0.85]\n    \n    //\n    //(0,0)2.2*p\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.55 ); //2.2. fade\n\tfloat fVal1\t\t= 1.0 - fade; //\n\tfloat fVal2\t\t= 1.0 - fade; //\n\t\n    //, \n\tfloat angle\t\t= atan( p.x, p.y )/3.1; //(x,y)y2pai[0,1]\n\tfloat dist\t\t= length(p); //(x,y)\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.4 ); //coord\n\t\n    //  \n    //1545\n\tfloat noise1\t= abs( snoise( coord + vec3( 0.0, -time * ( 1.65 + brightness * 0.1 ), time * -0.5 ), 95.0 ) );\n\tfloat noise2\t= abs( snoise( coord + vec3( 0.0, -time * ( 1.75 + brightness * 0.1 ), time * -0.5 ), 95.0 ) );\t\n\t\n    \n    // \n    //\n    //fval1fval2 noise[-1,1]\n    for( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) ); //power\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, time, time * 0.02 ), ( power * ( 10.0 ) * ( noise1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, time, time * 0.06 ), ( power * ( 15.0 ) * ( noise2 + 1.0 ) ) );\n\t}\n    \n\t//noisenoise\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.01 ) * 10.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.01 ) * 10.0;\n    \n    //()\n\tcorona\t\t\t\t*= 0.001 - noise1;\n    \n    if( dist < radius ){\n        //dist/radius[0,1] \n\t\tcorona\t\t\t*= pow( dist * invRadius, 6.0 );\n    }\n    \n    \n    //Part2 \t\n    //\n\tvec2 sp = -1.0 + 2.0 * uv; //sp[-1,1]\n\tsp.x *= aspect; //x[-1.7,1.7] \n\tsp *= ( 1.99 - brightness );//brightness\n  \tfloat r = dot(sp,sp); // x+y = r\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.2;  //\n    // (1.0-sqrt(abs(1.0-r)))x+y = 1sqrt(abs(1.0-r) = 0,(1.0-sqrt(abs(1.0-r)))= 1\n    //r\n    //brightness\n    \n    \n    //Part3 +\n    //\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, -1.04);\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 2.0 );//z\n\tvec3 starSphere\t\t= vec3( 0.02 );\n    \n\tif( dist < radius ){\n        //newUv\n  \t\tvec2 newUv;\n        //map\n        float MaptoSphere = (1.0-sqrt(abs(1.0-r)))/(r); //MaptoSpheremap\n \t\tnewUv.x = sp.x * MaptoSphere;\n  \t\tnewUv.y = sp.y * MaptoSphere;\n\t\tnewUv += vec2( time, 1.0001*time ); //xy0.1time \n\t\t\n        //UV\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 6.5 + time ); //*brightness + \n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 ); //x\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb; //map\n        //starSphere\t\t= texture( iChannel0, newUv ).rgb;\n\t}\n\t\n    //Part4 \n    \n    //min1max0\n\tfloat starGlow\t= min( max( 0.93 - dist * ( 1.0 - brightness ), 0.0 ), 1.4 );\n    starGlow *= 0.66; //\n\t\n    //RGB\n\tfragColor.rgb\t= vec3( f * ( 0.95 + brightness * 0.8 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n    //fragColor.rgb\t= vec3( f );//01\n    //fragColor.rgb\t= corona * orange; //02\n    //fragColor.rgb\t= starSphere; //03\n    //fragColor.rgb\t= starGlow * orangeRed; //04\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 346, 346, 1022], [1086, 1086, 1143, 1266, 7490]]}
{"id": "cdB3RD", "name": "2D Drawing Library", "author": "fad", "description": "A 2D drawing library to draw shapes and text. I made this so that I can easily visualise things on Shadertoy without having to write the same boilerplate code over and over again :)", "tags": ["2d", "antialiasing", "vector", "aa", "drawing", "alias", "library", "anti", "graphics"], "likes": 18, "viewed": 412, "published": 3, "date": "1686301703", "time_retrieved": "2024-07-30T17:50:44.569133", "image_code": "// Example use of drawing library (defined in Common tab)\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Create and bind a new context (i.e. initialize position)\n    vec2 p = fragCoord / iResolution.y;\n    vec2 topRight = iResolution.xy / iResolution.y;\n    Context ctx = newContext(p);\n    bindContext(ctx);\n    \n    // Draw the white background\n    drawPixel(vec4(1.0));\n    \n    // Draw the background grid\n    enableFill();\n    setFillColor(vec4(0.0, 0.0, 0.0, 0.03));\n    enableStroke();\n    setStrokeColor(vec4(0.7, 0.7, 0.7, 1.0));\n    setStrokeWidth(1.0 / getContext().scale);\n    // Dividing by getContext().scale converts the measurement to pixels\n    // in screenspace\n    drawGrid(vec2(-0.075), vec2(0.15, 0.2), vec2(0.02, 0.01));\n    \n    // Draw the blue blob as an implicit function\n    enableFill();\n    setFillColor(vec4(0.6, 0.7, 1.0, 1.0));\n    enableStroke();\n    setStrokeColor(vec4(0.2, 0.2, 0.5, 1.0));\n    setStrokeWidth(0.01);\n    drawImplicit(distance(p + sin(p * 25.0) * 0.03, topRight * 0.25) - 0.2);\n    \n    // Print the text\n    enableFill();\n    setFillColor(vec4(0.0, 0.0, 0.0, 1.0));\n    enableStroke();\n    strokeBehindFill();\n    setStrokeColor(vec4(1.0, 1.0, 1.0, 1.0));\n    setStrokeWidth(0.005);\n    setWritePosition(topRight * 0.2);\n    setCharSize(0.052);\n    // See all CH_char definitions in Common tab\n    printString((\n        CH_H,CH_e,CH_l,CH_l,CH_o,CH_CMA,CH_SPC, // Hello, \n        CH_w,CH_o,CH_r,CH_l,CH_d,CH_EXC,CH_SPC)); // world! \n    print(iFrame); // frame count\n    printString((\n        CH_SPC,CH_f,CH_r,CH_a,CH_m,CH_e,CH_s,CH_SPC, //  frames \n        CH_h,CH_a,CH_v,CH_e,CH_SPC, // have \n        CH_e,CH_l,CH_a,CH_p,CH_s,CH_e,CH_d,CH_SPC, // elapsed \n        CH_s,CH_o,CH_SPC, // so \n        CH_f,CH_a,CH_r,CH_DOT)); // far.     \n    strokeOverFill();\n    \n    // Mouse position for line\n    vec2 p1 = abs(iMouse.zw) / iResolution.y;\n    vec2 p2 = iMouse.xy / iResolution.y;\n    \n    // Draw dots at end of line\n    enableFill();\n    setFillColor(vec4(1.0, 0.0, 0.0, 1.0));\n    disableStroke();\n    drawCircle(p1, 0.01);\n    drawCircle(p2, 0.01);\n    \n    // Draw line\n    disableFill();\n    enableStroke();\n    setStrokeColor(vec4(0.0, 0.0, 0.0, 1.0));\n    setStrokeWidth(0.002);\n    drawLine(p1, p2, 0.01);\n    \n    // Draw green rectangle\n    enableFill();\n    setFillColor(vec4(0.0, 1.0, 0.0, 0.5));\n    disableStroke();\n    drawRect(topRight * 0.5, topRight * 0.5);\n    \n    // Output color\n    fragColor = premultiply(getColor());\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2D Drawing Library - by fad\n// https://www.shadertoy.com/view/cdB3RD\n// https://www.shadertoy.com/user/fad\n\n#define SDF_FONT_TEXTURE iChannel0\n\n// Treat the context as an opaque data type.\nstruct Context {\n    vec2 pixelCoord;\n    float scale;\n    bool drawingEnabled;\n    bool fillEnabled;\n    vec4 fillColor;\n    bool strokeEnabled;\n    bool strokeOverFill;\n    vec4 strokeColor;\n    float strokeWidth;\n    vec4 outColor;\n    vec2 writePosition;\n    float charSize;\n    float charWeight;\n    float lineSpacing;\n    float charSpacing;\n    int floatPrecision;\n    vec2 nextCharTopLeft;\n};\n\n// Create a new drawing context with the position of the pixel. The\n// mapping from fragCoord to pixelCoord is expected to be aspect-ratio\n// preserving, i.e. uniform scaling across both axes. The context\n// inherits its properties from the currently bound context. To use the\n// created canvas, bind it with bindContext().\nContext newContext(vec2 pixelCoord);\n\n// Bind a new context and return the previously bound context\nContext bindContext(Context ctx);\n\n// Get the currently bound context\nContext getContext();\n\n// Blit (copy) the canvas of a context onto the currently bound context,\n// optionally using another context canvas's alpha channel as a mask\nvoid blit(Context ctx);\nvoid blit(Context ctx, Context mask);\n\n// Draw the canvas of a context over the currently bound context,\n// optionally using another context canvas's alpha channel as a mask\nvoid drawCanvas(Context ctx);\nvoid drawCanvas(Context ctx, Context mask);\n\n// Get the rendered color so far (not premultiplied)\nvec4 getColor();\n\n// Enable or disable drawing\nvoid enableDrawing(bool drawingEnabled);\nvoid enableDrawing();\nvoid disableDrawing();\n\n// Enable or disable fill\nvoid enableFill(bool fillEnabled);\nvoid enableFill();\nvoid disableFill();\n\n// Set the fill color\nvoid setFillColor(vec4 fillColor);\n\n// Enable or disable stroke\nvoid enableStroke(bool strokeEnabled);\nvoid enableStroke();\nvoid disableStroke();\n\n// Set the stroke to render over or behind the fill\nvoid strokeOverFill(bool enable);\nvoid strokeOverFill();\nvoid strokeBehindFill();\n\n// Set the stroke color\nvoid setStrokeColor(vec4 strokeColor);\n\n// Set the stroke width\n// Note: a width of 0 does not work as expected\nvoid setStrokeWidth(float strokeWidth);\n\n// Draw a pixel for the current fragment\nvoid drawPixel(vec4 color);\n\n// Draw a shape\nvoid drawLine(vec2 start, vec2 end, float thickness);\nvoid drawRect(vec2 center, vec2 sideLength);\nvoid drawAABB(vec2 bottomLeft, vec2 topRight);\nvoid drawCircle(vec2 center, float radius);\nvoid drawGrid(vec2 spacing, vec2 thickness);\nvoid drawGrid(float spacing, float thickness);\n\n// Draw a shape defined by a signed distance value (sd < 0.0)\nvoid drawSD(float sd);\n\n// Draw a shape defined by an implicit function (f < 0.0)\nvoid drawImplicit(float f);\n\n// Draw a shape defined by the contour (zero-crossing) of an implicit\n// function (f == 0.0)\nvoid drawImplicitContour(float f, float width);\n\n// Text rendering functions\n// Set the top left position to write the text from\nvoid setWritePosition(vec2 writePosition);\n\n// Set the size of each character in pixels\nvoid setCharSize(float charSize);\n\n// Set the weight of each character (between 0 and 1)\nvoid setCharWeight(float charWeight);\n\n// Set the space between lines relative to character scale\nvoid setLineSpacing(float lineSpacing);\n\n// Set the space between successive characters relative to character\n// scale\nvoid setCharSpacing(float charSpacing);\n\n// Set the precision floating point numbers are printed at\nvoid setFloatPrecision(int floatPrecision);\n\n// Print Functions\nvoid printChar(int x);\n// These functions are also overloaded for vectors\nvoid print(bool x);\nvoid print(int x);\nvoid print(uint x);\nvoid print(float x);\n\n// The next two print functions are actually macros\n\n#define PREVENT_LOOP_UNROLLING 1\n\n// void printCharArray(int[] charArray);\n\n// void printString(string s);\n\n// Use printString with two pairs of brackets and comma separated chars,\n// e.g. printString((CH_H,CH_e,CH_l,CH_l,CH_o));\n\n// Calculate the color from blending the front color over the back color\nvec4 blendOver(vec4 front, vec4 back);\n\n// Premultiply a color\nvec4 premultiply(vec4 color);\n\n// Get the fraction of a pixel covered by an SDF (i.e. where sd < 0.0).\n// This function expects the SDF to be in screen-space where 1 unit of\n// distance corresponds to the width of a pixel.\nfloat sdfFill(float sd);\n\n// Get the fraction of a pixel covered by the outline of an SDF (i.e.\n// where abs(sd) < width / 2.0). This function expects the SDF to be in\n// screen-space where 1 unit of distance corresponds to the width of a\n// pixel.\nfloat sdfOutline(float sd, float width);\n\n// Get the fraction of a pixel covered by an implicit function (i.e.\n// where f < 0.0) by approximating the distance to the edge with\n// derivatives\nfloat implicitFill(float f);\n\n// Get the fraction of a pixel covered by the outline of an implicit\n// function (i.e. where (distance to f=0) < width / 2.0) by\n// approximating the distance to the edge with derivatives.\nfloat implicitOutline(float f, float width);\n\n// Return the fraction of the pixel where step(edge, x) == 1.0 by\n// approximating the distance to the edge with derivatives.\nfloat aastep(float edge, float x);\n\n// Character Definitions\nconst int CH_TAB = 9;   // \\t\nconst int CH_NL  = 10;  // \\n\nconst int CH_SPC = 32;  // space\nconst int CH_EXC = 33;  // !\nconst int CH_DQT = 34;  // \"\nconst int CH_HSH = 35;  // #\nconst int CH_DLR = 36;  // $\nconst int CH_PER = 37;  // %\nconst int CH_AMP = 38;  // &\nconst int CH_SQT = 39;  // '\nconst int CH_LP  = 40;  // (\nconst int CH_RP  = 41;  // )\nconst int CH_AST = 42;  // *\nconst int CH_PLS = 43;  // +\nconst int CH_CMA = 44;  // ,\nconst int CH_HYP = 45;  // -\nconst int CH_DOT = 46;  // .\nconst int CH_FSL = 47;  // /\nconst int CH_0   = 48;  // 0\nconst int CH_1   = 49;  // 1\nconst int CH_2   = 50;  // 2\nconst int CH_3   = 51;  // 3\nconst int CH_4   = 52;  // 4\nconst int CH_5   = 53;  // 5\nconst int CH_6   = 54;  // 6\nconst int CH_7   = 55;  // 7\nconst int CH_8   = 56;  // 8\nconst int CH_9   = 57;  // 9\nconst int CH_CLN = 58;  // :\nconst int CH_SCL = 59;  // ;\nconst int CH_LT  = 60;  // <\nconst int CH_EQ  = 61;  // =\nconst int CH_GT  = 62;  // >\nconst int CH_QST = 63;  // ?\nconst int CH_AT  = 64;  // @\nconst int CH_A   = 65;  // A\nconst int CH_B   = 66;  // B\nconst int CH_C   = 67;  // C\nconst int CH_D   = 68;  // D\nconst int CH_E   = 69;  // E\nconst int CH_F   = 70;  // F\nconst int CH_G   = 71;  // G\nconst int CH_H   = 72;  // H\nconst int CH_I   = 73;  // I\nconst int CH_J   = 74;  // J\nconst int CH_K   = 75;  // K\nconst int CH_L   = 76;  // L\nconst int CH_M   = 77;  // M\nconst int CH_N   = 78;  // N\nconst int CH_O   = 79;  // O\nconst int CH_P   = 80;  // P\nconst int CH_Q   = 81;  // Q\nconst int CH_R   = 82;  // R\nconst int CH_S   = 83;  // S\nconst int CH_T   = 84;  // T\nconst int CH_U   = 85;  // U\nconst int CH_V   = 86;  // V\nconst int CH_W   = 87;  // W\nconst int CH_X   = 88;  // X\nconst int CH_Y   = 89;  // Y\nconst int CH_Z   = 90;  // Z\nconst int CH_LB  = 91;  // [ \nconst int CH_BSL = 92;  // \\\nconst int CH_RB  = 93;  // ]\nconst int CH_CRT = 94;  // ^\nconst int CH_UND = 95;  // _\nconst int CH_GRV = 96;  // `\nconst int CH_a   = 97;  // a\nconst int CH_b   = 98;  // b\nconst int CH_c   = 99;  // c\nconst int CH_d   = 100; // d\nconst int CH_e   = 101; // e\nconst int CH_f   = 102; // f\nconst int CH_g   = 103; // g\nconst int CH_h   = 104; // h\nconst int CH_i   = 105; // i\nconst int CH_j   = 106; // j\nconst int CH_k   = 107; // k\nconst int CH_l   = 108; // l\nconst int CH_m   = 109; // m\nconst int CH_n   = 110; // n\nconst int CH_o   = 111; // o\nconst int CH_p   = 112; // p\nconst int CH_q   = 113; // q\nconst int CH_r   = 114; // r\nconst int CH_s   = 115; // s\nconst int CH_t   = 116; // t\nconst int CH_u   = 117; // u\nconst int CH_v   = 118; // v\nconst int CH_w   = 119; // w\nconst int CH_x   = 120; // x\nconst int CH_y   = 121; // y\nconst int CH_z   = 122; // z\nconst int CH_LC  = 123; // {\nconst int CH_VB  = 124; // |\nconst int CH_RC  = 125; // }\nconst int CH_TLD = 126; // ~\n\n// IMPLEMENTATION\n\nContext _ctx = Context(\n    vec2(0.0),\n    0.0,\n    false,\n    false,\n    vec4(0.0),\n    false,\n    false,\n    vec4(0.0),\n    0.0,\n    vec4(0.0),\n    vec2(0.0),\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0,\n    vec2(0.0)\n);\n\nContext newContext(vec2 pixelCoord) {\n    Context ctx;\n    float scale = 1.0 / length(vec2(dFdx(pixelCoord.x), dFdy(pixelCoord.x)));\n    \n    if (getContext().scale != 0.0) {\n        ctx = getContext();\n        ctx.outColor = vec4(0.0);\n        ctx.pixelCoord = pixelCoord;\n        ctx.scale = scale;\n    } else {\n        ctx.pixelCoord = pixelCoord;\n        ctx.scale = scale;\n        ctx.drawingEnabled = true;\n        ctx.fillEnabled = true;\n        ctx.fillColor = vec4(1.0, 0.0, 0.0, 1.0);\n        ctx.strokeEnabled = true;\n        ctx.strokeOverFill = true;\n        ctx.strokeColor = vec4(0.0, 0.0, 0.0, 1.0);\n        ctx.strokeWidth = 1.0;\n        ctx.outColor = vec4(0.0);\n        Context old = bindContext(ctx);\n        setWritePosition(vec2(100.0));\n        setCharSize(64.0);\n        setCharWeight(0.5);\n        setLineSpacing(0.0);\n        setCharSpacing(-0.55);\n        setFloatPrecision(5);\n        ctx = bindContext(old);\n    }\n    \n    return ctx;\n}\n\nContext bindContext(Context ctx) {\n    Context old = getContext();\n    _ctx = ctx;\n    return old;\n}\n\nContext getContext() {\n    return _ctx;\n}\n\nvoid blit(Context ctx) {\n    _ctx.outColor = ctx.outColor;\n}\n\nvoid blit(Context ctx, Context mask) {\n    _ctx.outColor = mix(_ctx.outColor, ctx.outColor, mask.outColor.a);\n}\n\nvoid drawCanvas(Context ctx) {\n    drawPixel(ctx.outColor);\n}\n\nvoid drawCanvas(Context ctx, Context mask) {\n    drawPixel(ctx.outColor * vec4(1.0, 1.0, 1.0, mask.outColor.a));\n}\n\nvoid enableDrawing(bool drawingEnabled) {\n    _ctx.drawingEnabled = drawingEnabled;\n}\n\nvoid enableDrawing() {\n    enableDrawing(true);\n}\n\nvoid disableDrawing() {\n    enableDrawing(false);\n}\n\nvoid enableFill(bool fillEnabled) {\n    _ctx.fillEnabled = fillEnabled;\n}\n\nvoid enableFill() {\n    enableFill(true);\n}\n\nvoid disableFill() {\n    enableFill(false);\n}\n\nvoid setFillColor(vec4 fillColor) {\n    _ctx.fillColor = clamp(fillColor, 0.0, 1.0);\n}\n\nvoid enableStroke(bool strokeEnabled) {\n    _ctx.strokeEnabled = strokeEnabled;\n}\n\nvoid enableStroke() {\n    enableStroke(true);\n}\n\nvoid disableStroke() {\n    enableStroke(false);\n}\n\nvoid strokeOverFill(bool enable) {\n    _ctx.strokeOverFill = enable;\n}\n\nvoid strokeOverFill() {\n    strokeOverFill(true);\n}\n\nvoid strokeBehindFill() {\n    strokeOverFill(false);\n}\n\nvoid setStrokeColor(vec4 strokeColor) {\n    _ctx.strokeColor = clamp(strokeColor, 0.0, 1.0);\n}\n\nvoid setStrokeWidth(float strokeWidth) {\n    _ctx.strokeWidth = max(strokeWidth, 0.0);\n}\n\nvoid drawPixel(vec4 color) {\n    if (_ctx.drawingEnabled) {\n        _ctx.outColor = blendOver(color, _ctx.outColor);\n    }\n}\n\nvoid _drawFillStroke(float fillOpacity, float strokeOpacity) {\n    if (_ctx.strokeEnabled && !_ctx.strokeOverFill) {\n        drawPixel(_ctx.strokeColor * vec4(1.0, 1.0, 1.0, strokeOpacity));\n    }\n\n    if (_ctx.fillEnabled) {\n        drawPixel(_ctx.fillColor * vec4(1.0, 1.0, 1.0, fillOpacity));\n    }\n    \n    if (_ctx.strokeEnabled && _ctx.strokeOverFill) {\n        drawPixel(_ctx.strokeColor * vec4(1.0, 1.0, 1.0, strokeOpacity));\n    }\n}\n\nvoid drawSD(float sd) {\n    sd *= _ctx.scale;\n    _drawFillStroke(sdfFill(sd), sdfOutline(sd, _ctx.scale * _ctx.strokeWidth));\n}\n\nvoid drawImplicit(float f) {\n    _drawFillStroke(implicitFill(f), implicitOutline(f, _ctx.scale * _ctx.strokeWidth));\n}\n\nvoid drawImplicitContour(float f, float width) {\n    float sd = abs(f) / length(vec2(dFdx(f), dFdy(f))) - _ctx.scale * width / 2.0;\n    _drawFillStroke(sdfFill(sd), sdfOutline(sd, _ctx.scale * _ctx.strokeWidth));\n}\n\nvoid drawLine(vec2 start, vec2 end, float thickness) {\n    vec2 ba = end - start;\n\tvec2 pa = _ctx.pixelCoord - start;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tdrawSD(length(pa - h * ba) - thickness);\n}\n\nvoid drawRect(vec2 center, vec2 sideLength) {\n    vec2 a = abs(_ctx.pixelCoord - center) - sideLength / 2.0;\n    drawSD(length(max(a, vec2(0.0))) + min(max(a.x, a.y), 0.0));\n}\n\nvoid drawAABB(vec2 bottomLeft, vec2 topRight) {\n    drawRect((bottomLeft + topRight) / 2.0, abs(topRight - bottomLeft));\n}\n\nvoid drawCircle(vec2 center, float radius) {\n    drawSD(distance(_ctx.pixelCoord, center) - radius);\n}\n\nvoid drawGrid(vec2 origin, vec2 spacing, vec2 thickness) {\n    vec2 a = \n        abs(mod(_ctx.pixelCoord - origin + spacing / 2.0, spacing) - spacing / 2.0) -\n        thickness / 2.0;\n    drawSD(min(a.x, a.y));\n    \n}\n\nvoid drawGrid(float spacing, float thickness) {\n    drawGrid(vec2(0.0), vec2(spacing), vec2(thickness));\n}\n\nvoid setWritePosition(vec2 writePosition) {\n    _ctx.writePosition = writePosition;\n    _ctx.nextCharTopLeft = writePosition;\n}\n\nvoid setCharSize(float charSize) {\n    _ctx.charSize = charSize;\n}\n\nvoid setCharWeight(float charWeight) {\n    _ctx.charWeight = charWeight;\n}\n\nvoid setLineSpacing(float lineSpacing) {\n    _ctx.lineSpacing = lineSpacing;\n}\n\nvoid setCharSpacing(float charSpacing) {\n    _ctx.charSpacing = charSpacing;\n}\n\nvoid setFloatPrecision(int floatPrecision) {\n    _ctx.floatPrecision = floatPrecision;\n}\n\n#ifndef HW_PERFORMANCE\nuniform sampler2D SDF_FONT_TEXTURE;\n#endif\n\nvoid printChar(int char) {\n    if (char == 10) {\n        _ctx.nextCharTopLeft.x = _ctx.writePosition.x;\n        _ctx.nextCharTopLeft.y -= (1.0 + _ctx.lineSpacing) * _ctx.charSize;\n        return;\n    }\n    \n    vec2 bottomLeft = _ctx.nextCharTopLeft - vec2(0.0, _ctx.charSize);\n    vec2 uv = (_ctx.pixelCoord - bottomLeft) / _ctx.charSize;\n    \n    if (clamp(uv, 0.0, 1.0) == uv) {\n        drawSD((texture(SDF_FONT_TEXTURE, (uv + vec2(char % 16, 15 - char / 16)) / 16.0).a - mix(0.45, 0.55, _ctx.charWeight)) * _ctx.charSize);\n    }\n    \n    _ctx.nextCharTopLeft.x += (1.0 + _ctx.charSpacing) * _ctx.charSize;\n}\n\n#ifndef HW_PERFORMANCE\nuniform int iFrame;\n#endif\n\n#define printCharArray(charArray) for (int i = 0; i < (charArray).length() + min(PREVENT_LOOP_UNROLLING * iFrame, 0); ++i) printChar((charArray)[i])\n\n#define printString(string) printCharArray(int[]string)\n\nvoid print(bool x) {\n    if (x) {\n        printString((CH_t,CH_r,CH_u,CH_e));\n    } else {\n        printString((CH_f,CH_a,CH_l,CH_s,CH_e));\n    }\n}\n\nvoid print(int x) {\n    if (x < 0) {\n        printChar(CH_HYP);\n        x = -x;\n    }\n    \n    print(uint(x));\n}\n\nvoid print(uint x) {\n    int n = 1;\n    uint t = x % 10u;\n    \n    while (x > 9u) {\n        ++n;\n        x /= 10u;\n        t = 10u * t + x % 10u;\n    }\n    \n    while (n --> 0) { // lol\n        printChar(CH_0 + int(t % 10u));\n        t /= 10u;\n    }\n}\n\nvoid print(float x) {\n    if (isnan(x)) {\n        printString((CH_n,CH_a,CH_n));\n        return;\n    }\n    \n    if (floatBitsToUint(x) >> 31 == 1u) {\n        printChar(CH_HYP);\n        x = -x;\n    }\n    \n    if (isinf(x)) {\n        printString((CH_i,CH_n,CH_f));\n        return;\n    }\n    \n    if (x == 0.0) {\n        printChar(CH_0);\n        return;\n    }\n    \n    float e = floor(log2(x)/log2(10.0));\n    x /= pow(10.0, e);\n    \n    for (int n = 0; x > 0.0 && n < _ctx.floatPrecision; ++n) {\n        if (n == 1) {\n            printChar(CH_DOT);\n        }\n        \n        float digit = floor(x);\n        printChar(CH_0 + int(digit));\n        x = (x - digit) * 10.0;\n    }\n    \n    printChar(CH_e);\n    print(int(e));\n}\n\n#define OVERLOAD_PRINT(T, n, c)                              \\\n    void print(T x) {                                        \\\n        printString((c, CH_v, CH_e, CH_c, CH_0 + n, CH_LP)); \\\n                                                             \\\n        for (int i = 0; i < n; ++i) {                        \\\n            print(x[i]);                                     \\\n                                                             \\\n            if (i != n - 1) {                                \\\n                printString((CH_CMA, CH_SPC));               \\\n            }                                                \\\n        }                                                    \\\n                                                             \\\n        printChar(CH_RP);                                    \\\n    }\n\n#define OVERLOAD_PRINT_FLOAT(T, n)                           \\\n    void print(T x) {                                        \\\n        printString((CH_v, CH_e, CH_c, CH_0 + n, CH_LP));    \\\n                                                             \\\n        for (int i = 0; i < n; ++i) {                        \\\n            print(x[i]);                                     \\\n                                                             \\\n            if (i != n - 1) {                                \\\n                printString((CH_CMA, CH_SPC));               \\\n            }                                                \\\n        }                                                    \\\n                                                             \\\n        printChar(CH_RP);                                    \\\n    }\n\nOVERLOAD_PRINT(bvec2, 2, CH_b)\nOVERLOAD_PRINT(bvec3, 3, CH_b)\nOVERLOAD_PRINT(bvec4, 4, CH_b)\nOVERLOAD_PRINT(ivec2, 2, CH_i)\nOVERLOAD_PRINT(ivec3, 3, CH_i)\nOVERLOAD_PRINT(ivec4, 4, CH_i)\nOVERLOAD_PRINT(uvec2, 2, CH_u)\nOVERLOAD_PRINT(uvec3, 3, CH_u)\nOVERLOAD_PRINT(uvec4, 4, CH_u)\nOVERLOAD_PRINT_FLOAT(vec2, 2)\nOVERLOAD_PRINT_FLOAT(vec3, 3)\nOVERLOAD_PRINT_FLOAT(vec4, 4)\n\nvec4 blendOver(vec4 top, vec4 bottom) {\n    float a = top.a + bottom.a * (1.0 - top.a);\n    return a > 0.0\n        ? vec4((top.rgb * top.a + bottom.rgb * bottom.a * (1.0 - top.a)) / a , a)\n        : vec4(0.0);\n}\n\nvec4 premultiply(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 getColor() {\n    return _ctx.outColor;\n}\n\nfloat _areaSquareLine(vec2 n, float d) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // https://www.desmos.com/calculator/dorvdj5nbq for visualization\n    n = abs(n);\n    n = vec2(max(n.x, n.y), min(n.x, n.y));\n    float a = abs(d);\n    float b;\n\n    if (n.y != 0.0 && n.x - n.y <= 2.0 * a) {\n        vec2 c = 1.0 + (n - 2.0 * a) / n.yx;\n        b = 1.0 - max(c.x, 0.0) * c.y / 8.0;\n    } else {\n        b = min(0.5 + a / n.x, 1.0);\n    }\n    \n    return d < 0.0 ? 1.0 - b : b;\n}\n\nfloat _areaSquareLineAverage(float d) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Approximate average value of areaSquareLine(n, d) w.r.t. n\n    float a = abs(d);\n    float b;\n    \n    if (a < 1.0 / sqrt(2.0)) {\n        b = 4.1434218 * pow(a, 12.647891) -\n            1.3070394 * pow(a, 3.9787831) +\n            1.0998631 * a +\n            0.5012205;\n        b = clamp(b, 0.0, 1.0);\n    } else {\n        b = 1.0;\n    }\n    \n    return d < 0.0 ? 1.0 - b : b;\n}\n\nfloat sdfFill(float sd) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Return the fraction of the pixel covered by the SDF (i.e. where\n    // sd < 0.0)\n    vec2 n = vec2(dFdx(sd), dFdy(sd));\n    \n    if (n == vec2(0.0) || isnan(n.x) || isnan(n.y)) {\n        // Ambiguous case, so instead we just return the average. This\n        // is the problem with using dFdx/dFdy that would occur much\n        // less frequently if we had access to the analytic derivatives.\n        return _areaSquareLineAverage(-sd);\n    }\n\n    n = normalize(n);\n    return _areaSquareLine(n, -sd);\n}\n\nfloat sdfOutline(float sd, float width) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Return the fraction of the pixel covered by the outline of the\n    // SDF (i.e. where abs(sd) < width / 2.0)\n    return sdfFill(sd - width / 2.0) - sdfFill(sd + width / 2.0);\n}\n\nfloat aastep(float edge, float x) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Return the fraction of the pixel where step(edge, x) == 1.0 by\n    // approximating the distance to the edge with derivatives.\n    x -= edge;\n    vec2 n = vec2(dFdx(x), dFdy(x));\n    \n    if (n == vec2(0.0) || isnan(n.x) || isnan(n.y)) {\n        // Ambiguous case, so we resort to using regular step(edge, x).\n        // We can't use areaSquareLineAverage(x) because that function\n        // assumes that x measures distance across pixels but we have no\n        // information about distance here as the derivatives are zero.\n        return step(edge, x);\n    }\n    \n    float l = length(n);\n    return _areaSquareLine(n / l, x / l);\n}\n\nfloat implicitFill(float f) {\n    return aastep(f, 0.0);\n}\n\nfloat implicitOutline(float f, float width) {\n    return implicitFill(abs(f) / length(vec2(dFdx(f), dFdy(f))) - width / 2.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdB3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 111, 175, 2510]]}
{"id": "DlKXzd", "name": "neon-psychedelic-3", "author": "LydianLights", "description": "hexagons are good", "tags": ["psychedelic"], "likes": 29, "viewed": 614, "published": 3, "date": "1686300697", "time_retrieved": "2024-07-30T17:50:45.337079", "image_code": "// https://www.shadertoy.com/view/Xljczw\nvec4 getHex(vec2 p)\n{\n    const vec2 s = vec2(1, ROOT_3);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nfloat hexDist(in vec2 p)\n{    \n    const vec2 s = vec2(1, ROOT_3);\n    p = abs(p);\n    return max(dot(p, s*.5), p.x);\n}\n\nvec3 mainPass(in vec2 fragCoord)\n{\n    const float r = PI / 6.0;\n    const mat2 rot = mat2(cos(r), sin(r), -sin(r), cos(r));\n\n    vec2 uv0 = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv0.x *= iResolution.x / iResolution.y;\n    vec2 uv = uv0;\n    \n    vec2 h0 = getHex(0.5 * uv).xy;\n    vec2 h = h0;\n    \n    float d0 = length(uv0);\n    vec3 color = vec3(0.0);\n    \n    for (float i = 0.0; i < 5.0; i++)\n    {\n        h = getHex(1.1 * ROOT_3 * h * rot).xy;\n        \n        float d = hexDist(h);\n        d = 2.0 * d * pow(0.2, d0);\n        d = 0.5 * sin(4.0 * d - 0.5 * iTime + i * 2.0 * PI / 7.0);\n        d = 0.04 / d;\n        d = pow(d, 2.0);\n        \n        vec3 c = d * palette(length(h0) + 0.3 * i);\n        color += c;\n    }\n    return color;\n}\n\n/*\nvec3 antialias(in vec2 fragCoord)\n{\n    const float AA_STAGES = 0.0;\n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n*/\n\nvec3 gamma(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = mainPass(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "const float PI = 3.1415927;\nconst float ROOT_3 = 1.7320508;\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.7);\n    vec3 b = vec3(0.8, 0.2, 0.7);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.2, 0.6);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 62, 62, 320], [322, 322, 348, 348, 441], [443, 443, 477, 477, 1198], [1700, 1700, 1727, 1727, 1769], [1771, 1771, 1826, 1826, 1926]]}
{"id": "clySzd", "name": "neon-psychedelic-2", "author": "LydianLights", "description": "i'm seeing colors that dont exist", "tags": ["psychedelic"], "likes": 4, "viewed": 204, "published": 3, "date": "1686288571", "time_retrieved": "2024-07-30T17:50:46.108018", "image_code": "vec3 mainPass(in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    \n    uv -= 0.5;\n    float d0 = length(uv0);\n    vec3 color = vec3(0.0);\n    \n    for (float i = 0.0; i < 5.0; i++)\n    {\n        uv = fract(vec2(1.0 + 0.18 * i) * uv) - 0.5;\n        vec3 polar = vec3(log(length(uv)), atan(uv.y / uv.x), atan(uv.x / uv.y));\n        \n        float p = mix(0.7, 1.5, d0 * d0);\n        float q = mix(0.02, 0.07, clamp(d0, 0.0, 1.0));\n\n        vec2 d = vec2(length(polar.xy), length(polar.xz));\n        d *= pow(0.03, d0 * 0.4);\n        d = sin(5.0 * d + 0.2 * vec2(5.0 * iTime, 3.0 * iTime));\n        d = abs(d);\n        d = pow(q / d, vec2(p));\n\n        float d0 = d.x + d.y;\n\n        vec3 c = palette(length(uv) + i + (0.1 + 0.2 * i) * iTime) * d0;\n        \n        color += c;\n    }\n    \n    return color;\n}\n\nvec3 antialias(in vec2 fragCoord)\n{\n    const float AA_STAGES = 2.0;\n    \n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = antialias(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.7, 0.1, 0.5);\n    vec3 b = vec3(0.6, 0.7, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.2, 0.4);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clySzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 896], [898, 898, 933, 933, 1395], [1397, 1397, 1424, 1424, 1466], [1468, 1468, 1523, 1523, 1624]]}
{"id": "mtGSRt", "name": "Fork 3 Rotating dontriskit 209", "author": "dontriskit", "description": "Each color channel is a different sphere rotating on a different axis.", "tags": ["sphere", "rotation", "roll", "yaw", "pitch", "3drotation"], "likes": 3, "viewed": 179, "published": 3, "date": "1686278356", "time_retrieved": "2024-07-30T17:50:46.897906", "image_code": "const float PI = 3.141592; \nconst float R = 1.;    // sphere radius\nconst float r = 0.09;  // circles radius\nconst float d = 0.1;   // circles distance\nconst vec3 a0 = vec3(0.); // starting angles (pitch, yaw, roll)\nconst vec3 speed = vec3(.5, .5, .5); // pitch, yaw, roll\n\nvec3 pitch(vec3 uv, float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec3(uv.x,\n                c*uv.y - s*uv.z,\n                s*uv.y + c*uv.z);\n}\n\nvec3 yaw(vec3 uv, float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec3(c*uv.x + s*uv.z,\n                uv.y,\n               -s*uv.x + c*uv.z);\n}\n\nvec3 roll(vec3 uv, float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec3(c*uv.x - s*uv.y,\n                s*uv.x + c*uv.y,\n                uv.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float z = sqrt( max(0., R*R - (uv0.x)*(uv0.x) - (uv0.y)*(uv0.y)) ); \n    vec3 uv = vec3(uv0, z); // virtually creating a Z axis\n    \n    vec3 angle = a0 + vec3(speed * iTime);\n    vec3 uv_r = vec3(pitch(uv, angle.x));\n    vec3 uv_g = vec3(  yaw(uv, angle.y));\n    vec3 uv_b = vec3( roll(uv, angle.z));\n    \n    float lr = length(mod(uv_r + r, 2.*d) - r);\n    float lg = length(mod(uv_g + r, 2.*d) - r);\n    float lb = length(mod(uv_b + r, 2.*d) - r);\n    vec3 l = vec3(lr, lg, lb);\n\n    vec3 pixel = smoothstep(3./iResolution.y, 0., l-r) * smoothstep(0., 3./iResolution.y, R - length(uv.xy) );\n    fragColor = vec4(pixel, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 305, 305, 444], [446, 446, 475, 475, 614], [616, 616, 646, 646, 785], [787, 787, 844, 844, 1543]]}
{"id": "DlyXRd", "name": "Metamorphisis", "author": "BeardThings", "description": "A pop art inspired metamorphisis", "tags": ["procedural", "popart", "art", "wind", "pop", "sway", "metamorphisis"], "likes": 5, "viewed": 206, "published": 3, "date": "1686277722", "time_retrieved": "2024-07-30T17:50:47.655879", "image_code": "float circle(vec2 p, vec2 t, float r)\n{\n    return distance(p,t)-r;\n}\n\nfloat slice(vec2 p, float h)\n{\n    return p.y - h;\n}\n\nfloat outline(float sdf, float t)\n{\n    return abs(sdf) > t ? 1.0 : 0.1; \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec3 rgb(int hex)\n{\n    return vec3((hex >> 16) & 0xFF, (hex >> 8) & 0xFF, hex & 0xFF) / 255.0;\n}\n\nvec2 repeat(vec2 p, float rep)\n{\n    return mod(p+rep*0.5, rep)-rep*0.5;\n}\n\nvec2 rotate(vec2 p, float t)\n{\n    mat2 rot = mat2(\n        cos(t), -sin(t),\n        sin(t), cos(t));\n        \n    return rot * p;\n}\n\nfloat halftone(vec2 p, float t, float f)\n{\n    p = rotate(p, t);\n    p = repeat(p, 0.025);\n    float sdf = circle(p, vec2(0.0, 0.0), 0.006 * f);\n    return sdf < 0.0 ? 0.5 : 1.0;\n}\n\nvec3 scene(vec2 p)\n{\n    vec3 col = rgb(0xBF40BF) * halftone(p, 0.2, 1.0);\n\n    float sdf = 0.0;\n\n    // Cocoon\n    {\n        vec2 pi = vec2(0.0,0.24);\n        vec2 cp = p;\n        vec2 o=vec2(-0.3,0.06);\n        cp-=o;\n        \n        // Animation\n        cp = rotate(cp-pi, sin(iTime) * 0.1) + pi;\n\n        float s = circle(cp*vec2(4.0,1.0), vec2(0.0,0.16), 0.05);\n\n        float c = circle(cp, vec2(0.0,0.0), 0.2011);\n        c = smin(c, s, 0.1);\n        \n        float h0 = -0.03;\n        float c2 = circle(cp * vec2(1.0,0.5), vec2(-0.011,h0), 0.19);\n        c2 = max(c2, slice(cp, h0+0.05));\n        sdf = smin(c, c2, 0.01);\n        float c3 = circle(cp, vec2(0.05,-0.28), 0.12);\n        sdf=smin(c3, sdf,0.1);\n        if(sdf < 0.0)\n        {\n            float h = circle(rotate(cp,0.8)*vec2(2.0,1.0), vec2(0.27,0.0), 0.05);\n            if(h < 0.0)\n            {\n                col = vec3(1.0,1.0,1.0);\n            }\n            else\n            {\n                col = rgb(0xa4fa7a)\n                    * outline(sdf, 0.011);\n            }\n        \n            \n        }\n    }\n    \n    // Tree\n    {\n        vec2 o = vec2(0.0, 0.03);\n        vec2 tp = p-o;\n        float bc = (circle(tp*vec2(0.5,1.0), vec2(0.2,-1.0), 1.3));\n        float tc = (circle(tp*vec2(0.25,1.0), vec2(0.3,-0.68), 1.3));\n        \n        float sdf = max(tc,-bc);\n        col = mix(col,\n            rgb(0x4c2f73)\n            * outline(sdf, 0.016), sdf < 0.0 ? 1.0 : 0.0);   \n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Supersampling, we want smooth edges\n    vec3 accum = vec3(0.0, 0.0, 0.0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec2 o[4];\n        o[0] = vec2(-0.25 / iResolution.x, -0.25 / iResolution.y);\n        o[1] = vec2( 0.25 / iResolution.x, -0.25 / iResolution.y);\n        o[2] = vec2( 0.25 / iResolution.x,  0.25 / iResolution.y);\n        o[3] = vec2(-0.25 / iResolution.x,  0.25 / iResolution.y);\n    \n        vec2 uv = fragCoord/iResolution.xy + o[i];\n        vec2 p = (uv * 2.0 - 1.0) * vec2(1.0,iResolution.y/iResolution.x);\n        accum += scene(p);\n    }\n    \n    fragColor = vec4(accum / 4.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 69], [71, 71, 101, 101, 123], [125, 125, 160, 160, 200], [202, 202, 243, 243, 327], [329, 329, 348, 348, 426], [428, 428, 460, 460, 502], [504, 504, 534, 534, 636], [638, 638, 680, 680, 818], [820, 820, 840, 840, 2301], [2303, 2303, 2360, 2403, 2976]]}
{"id": "DlGXzd", "name": "DRI #1", "author": "dontriskit", "description": "DRI #1", "tags": ["sdfsdg"], "likes": 5, "viewed": 158, "published": 3, "date": "1686277587", "time_retrieved": "2024-07-30T17:50:48.519570", "image_code": "\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\nvec3 blur(vec2 uv, float r){\nvec3 c = vec3(0.);\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec4 c2 = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyzw;\n     vec3 col = c2.xyz;\n     col = clamp(col,0.,1.);\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec4 c2 = texture(iChannel0, (p+coords)/iResolution.xy).xyzw;\n    vec3 c = c2.xyz / (c2.w+1.);\n    //c = c*c *1.8;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec3 col = texture(iChannel0, uv).xyz;\n    // Output to screen\n    vec3 col = blur2(uv, length((uv*2.0-1.0)*5.));\n    float off = texture(iChannel0, uv).w;\n     vec3 rad;\n    vec2 offset2 = (fragCoord - iResolution.xy/2.)*1.;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,15.-length(uv*2.0-1.)*1.5, float(i)/20.)*1.;\n       rad.x += texture(iChannel0, (offset+offset2*0.034)/iResolution.xy).x;\n       rad.y += texture(iChannel0, (offset)/iResolution.xy).y;\n       rad.z += texture(iChannel0, (offset-offset2*0.034)/iResolution.xy).z;\n\n    }\n    rad /= 16.;\n    \n    col += rad*0.8;\n    col = clamp(col, 0., 1.);\n     col = vec3(1.)-exp(-1.3*col);\n\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.4)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.1);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\ncol = pow(col, vec3(1.5))*1.8;\n//col = pow(col, vec3(0.7,0.8,0.9));\ncol = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float ring(vec2 p, vec2 s){\nreturn length(normalize(p)*s.x - p)-s.y;\n}\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x,a.y);\n}\n\nvec3 pal(float es, vec3 a){\nreturn 0.5 + 0.5*cos(2.0*3.14159*es + a);\n}\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat g = c;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\n\n//NOT MY CODE\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n/////////////\n\nfloat escape = 0.;\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n           escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\nfloat jb3(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n            escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n\n  float DEmine(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\nfor(int i = 0; i < 7; i++){\np*=4.79;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\nfloat m = length(p.xyz);\n\np/=dot(p.xyz,p.xyz)+mod(m, 1.);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\n\nreturn length(p.xyz)/p.w;\n}\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = .1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\n\nfloat de22( vec3 p ){\n    vec3 CSize = vec3(1., 1.7, 1.);\n    p = p.xzy;\n    float scale = 1.1;\n    for( int i=0; i < 8;i++ ){\n      p = 2.0*clamp(p, -CSize, CSize) - p;\n      float r2 = dot(p,p+sin(p.z*.3));\n      float k = max((2.)/(r2), .5);\n      p *= k; scale *= k;\n    }\n    float l = length(p.xy);\n    float rxy = l - 1.0;\n    float n = l * p.z;\n    rxy = max(rxy, (n) / 8.);\n    return (rxy) / abs(scale);\n  }\n/////////////////////////////////////\nfloat DEeerr(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               // p.xyz = abs(p.xyz);\n\n        //box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.,1.0));\n        p.xyz=abs(p.xyz)-vec3(3.5,.5,3.3);\n       //p*=1.2;\np.yxz -= sin(float(i)*1.)*0.9;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\nfloat newde(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\np.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\np.xy = (p.x > p.y)?p.yx:p.xy;\n\nfor(int i = 0; i < 12; i++){\n//p = abs(p);\n//p.xz = (p.x > p.z)?p.zx:p.xz;\n//p.yz = (p.y > p.z)?p.zy:p.yz;\n//p.xy = (p.x > p.y)?p.yx:p.xy;\n\np.xyz = mod(p.xyz-1., 2.)-1.;\np *= 1.1/clamp(dot(p.xyz,p.xyz),0.,1.2);\n//p.xyz -= vec3(2.,0.4,0.6);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\np/=p.w;\nreturn abs(p.x)*0.25;\n}\n\nfloat fractal(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.4+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.5,1.));\n        p.xyz-=vec3(0.2+rndf(seed)*0.2,0.6-rndf(seed)*0.3,2.3);\n        p*=1.2-rndf(seed)*0.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.5;\n}\n\nfloat fractal_de46(vec3 p){\n    float s = 2.;\n    float e = 0.;\n    escape = 0.;\n    for(int j=0;++j<7;){\n        p.xz=abs(p.xz)-2.3,\n        p.z>p.x?p=p.zyx:p,\n        p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.y=.9-abs(p.y-.4),\n        e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n        2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n        p=e*p-vec3(7,1,1),\n        s*=e;\n        escape+=exp(-0.2*dot(p,p));\n        }\n    return length(p)/s;\n}\n\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel1, (p+0.5)/256.0, 0.0 ).xy;\n}\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin(6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\n\nvec3 lens(vec2 p, vec2 mouse,inout uint k){\nvec3 col = vec3(exp(-20.*length(mouse-p)));\ncol += exp(-20.*length(-mouse*rndf(k)*0.5-p));\ncol += exp(-ring(-mouse*0.4-p, vec2(0.7, 0.01))*20.)\n*sin(texture(iChannel0, normalize(p*rndf(k))).x);\ncol *= pal(exp(-length(-mouse*rndf(k)*0.9-p)), vec3(0.9,0.5,0.9));\nfor(int i = 0;i < 5; i++){\ncol += exp(-ring(mouse*2.*(0.1+float(i)/5.0)-p, vec2(0.1-float(i)/15.0, 0.001*float(i+1)))*20.);\n}\ncol *= pal(length(mouse*rndf(k)-p), vec3(0.9,0.5,0.4))*0.4;//\n//col += exp(-length(mouse-p))*vec3(0.9,0.6,0.2)\n//*sin(texture(iChannel0, normalize(mouse-p)).x)*exp(-length(mouse-p)*5.)*2.;\n//col += exp(-length(mouse-p)*10.)*2.;\n//col *= pal(length(-mouse-p)*10., vec3(0.9,0.4,0.9));\ncol += exp(-(abs(box(-mouse*rndf(k)-p, vec2(0.1)))+0.2)*20.);\ncol += exp(-jb3((vec3(p*2.,iTime*0.4))/2.)*1000.);\ncol *= pal(escape, vec3(0.9,0.4,0.2));\n\ncol += exp(-voronoi(p).x*200.);\ncol *= pal(escape, vec3(0.9,0.4,0.2));\n\nreturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ///NOT MY CODE///\n    uint r = uint(uint(fragCoord.x) * uint(1973) \n    + uint(fragCoord.y) * uint(9277) \n    + uint(iFrame) * uint(26699)) | uint(1);\n    \n    ///////////////\n    \n    \nuv = uv * 2.0 - 1.0;\nuv.x *= 1.3;\nuv.y /= 1.3;\nuv *= 3.5;\n    // Time varying pixel color\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 15; i++){\n    uint k = uint(i+1);\n        float offset = rndf(k);\n        col += lens(rot(uv*(rndf(k)+0.04), offset*iTime), vec2(cos(offset*2.*3.14159+iTime), sin(offset*2.*3.14159-iTime)), k)*offset*0.4;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 38, 61, 61, 215], [252, 252, 280, 280, 779], [783, 783, 813, 813, 1321], [1323, 1323, 1380, 1430, 2607]]}
{"id": "dtVSzc", "name": "JH Hello Shader", "author": "JohnWithAnH", "description": "First Shader", "tags": ["helloworld"], "likes": 10, "viewed": 189, "published": 3, "date": "1686275062", "time_retrieved": "2024-07-30T17:50:49.362317", "image_code": "// Simplex noise function\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0; // Transform uv to [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Generate noise based on position\n    float noise = snoise(uv * 1.0 + 198.3); // Lower frequency for larger features\n    float waveNoise = snoise(uv * 20.0 + 500.0); \n    //add more noise\n    noise += snoise(uv * 5.0) * 0.1;\n    noise += snoise(uv * 10.0) * 0.05;\n    noise += snoise(uv * 20.0) * 0.025;\n    noise += snoise(uv * 40.0) * 0.0125;\n\n\n    // Add a radial fall off\n    float dist = length(uv);\n    noise = mix(noise, -1.0, smoothstep(0.4, 1.0, dist)); // Lower start value for a larger island\n\n    float wave = 0.0;\n    if(noise < -0.1){\n    wave = 0.05 * sin(5.0 * 3.1416 * dist - iTime * .5); // Add a sinusoidal wave\n    } \n    //add in wave effect\n    noise += wave;\n\n\n    // Define colors for different heights\n    vec3 waterColor = vec3(0.2, 0.5, 0.7);\n    vec3 sandColor = vec3(0.9, 0.8, 0.2);\n    vec3 grassColor = vec3(0.1, 0.6, 0.1);\n    vec3 forestColor = vec3(0.0, 0.4, 0.0);\n    vec3 rockColor = vec3(0.6, 0.6, 0.6);\n    vec3 mountainColor = vec3(0.5, 0.5, 0.5);\n    vec3 snowColor = vec3(1.0, 1.0, 1.0);\n\n    float sandStart = -0.1;\n\n    float waveWidth = 0.015;\n    float wave1loc = -0.3;\n    float wave2loc = -0.2;\n\n    // Choose color based on height\n    vec3 color = waterColor;\n    //before the sand, and in the wave range add white ripple lines\n    if(noise > wave1loc &&  noise < wave1loc + waveWidth && waveNoise < 0.0) color = vec3(1.0, 1.0, 1.0);\n    if(noise > wave2loc &&  noise < wave2loc + waveWidth && waveNoise < 0.0) color = vec3(1.0, 1.0, 1.0);\n    //terrain\n    if(noise > sandStart) color = sandColor; \n    if(noise > 0.1) color = grassColor;\n    if(noise > 0.2) color = forestColor;\n    if(noise > 0.5) color = rockColor;\n    if(noise > 0.6) color = mountainColor;\n    if(noise > 0.8) color = snowColor;\n\n    // Apply the color to the fragment\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 48, 48, 87], [89, 89, 110, 110, 995], [997, 997, 1054, 1054, 3024]]}
{"id": "DlGXzt", "name": "Tapestry 4", "author": "iterati", "description": "You spin me right round", "tags": ["ifs"], "likes": 2, "viewed": 110, "published": 3, "date": "1686272316", "time_retrieved": "2024-07-30T17:50:50.125277", "image_code": "float morphStar( in vec2 p, in float r, in float f )\n{\n    float rtn = 0.;\n    float x = mod(f, 1.) * 2. * PI;\n    float y = sinT(f, 1.);\n    int n = (int(f) + 1) * 4;\n    \n    return (sdCircle(p, r) * y) + (sdStar(p, r, n, float(n)) * (1. - y));\n}\n\nfloat sheen( in float d, in float x, in float g )\n{\n    //return pow(x / abs(d), g);\n    return 1. - smoothstep(0.0, x, abs(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 col = vec3(0.);\n    float d = 0.;\n    float f = mod(iTime / 7., 4.);\n    float r = sinT(iTime, 11.) * 0.2 + 0.4;\n    float x = sinT(iTime, 30.) * 1. + 3.5;\n    float y = sinT(iTime, 10.) * 45.;\n    float z = mod(iTime / 45., 2. * PI);\n\n    uv = rotate(uv, z);\n    d = sheen(morphStar(uv, r, f) * exp(-length(uv0) * sinT(iTime, 5.) * 2.), 0.0025, 1.1);\n    col = palette((length(uv0) + sin(iTime)) / 2.0);\n    finalColor += col * d;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        float rot = (int(i) % 2 == 0) ? PI * 0.25 : -PI * 0.25;\n        uv = fract(rotate(uv, rot) * x * (i + 1.) * 0.25) - 0.5;\n        d = sheen(morphStar(uv, r, f) * exp(-length(uv0) * sinT(iTime, 5.) * 2.), 0.0025 * (i + 1.) * x, 1.1);\n        col = palette((length(uv0) + sin(iTime) + i + 1.) / 2.0);\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5); //vec3(0.744, 0.244, 0.577);\n    vec3 b = vec3(0.5); //vec3(0.231, 0.395, 0.498);\n    vec3 c = vec3(1.); //vec3(0.759, 1.375, 0.932);\n    vec3 d = vec3(0.0, 0.333, 0.667); //vec3(3.477, 6.066, 1.898);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, in float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 301, 334, 380]]}
{"id": "clVXDm", "name": "Year of Truchets #033", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \n", "tags": ["2d", "warp", "truchet", "polar"], "likes": 25, "viewed": 309, "published": 3, "date": "1686269560", "time_retrieved": "2024-07-30T17:50:50.886242", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #033\n    06/10/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI         3.14159265359\n#define PI2        6.28318530718\nconst float scale = 10.;\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    \n    // upscale\n    float scale = 2.545;   //7.//5.41//3.5;//2.545;//1.91;//1.2726;//.6365;\n \n    // @stb dual polar thing.. \n    uv.x -= .25;\n    uv /= uv.x*uv.x + uv.y*uv.y;\n    uv.x += 2.;\n    \n    // warp and turn\n    uv *= rot(-T*.035);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*scale;\n    uv.x -= T*.3;\n    \n    float px = fwidth(uv.x); \n    vec3 C = mix(vec3(.005),texture(iChannel1,uv).rgb,.5);\n    \n    // basic setup\n    vec4 id = vec4(floor(uv),floor(uv-.5));\n    vec4 q = vec4(fract(uv)-.5,fract(uv-.5)-.5);\n    vec2 ck = vec2(mod(id.x+id.y,2.)*2.-1.,mod(id.z+id.w,2.)*2.-1.);\n \n    float hs = hash21(id.xy);\n    float wd = .17;\n    \n    //rnd turn rnd\n    if(hs>.45) q.xy *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    // closest corner\n    vec2 sp = vec2(length(q.xy-.5),length(q.xy+.5));\n    vec2 p = sp.x<sp.y? q.xy-.5 : q.yx+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n    float g = length(abs(q.xy)-.5)-(.425-wd);\n\n    if(hs<.15) d = min(length(abs(q.xy)-vec2(.5,0))-wd,length(q.x)-wd);\n    if(hs>.45) {\n        float tk = length(abs(q.x)-(wd*1.01))-(wd*.01);\n        d = max(min(length(q.y)-wd,length(q.x)-wd),-tk);\n    }\n    // accents\n    float b = length(q.zw)-.12;\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.0035;\n\n    // vectors for texture\n    vec2 arc = q.xy-sign(q.x+q.y+.001)*.5;\n    float angle = atan(arc.x, arc.y);\n    float ud = length(arc);\n    vec2 tuv = vec2(fract(4.*ck.x*angle/PI),(ud/.5)-.5);\n    // cross track changes\n    if (hs>.45) tuv = vec2(fract(2.*ck.x*abs(q.x)),q.y);\n    vec3 cf = texture(iChannel0,hs+tuv*2.).rgb;\n\n    // draw\n    if(ck.y>.5) {\n        d2=max(d2,-(b-.025));\n        C = mix(C,vec3(.05),smoothstep(px,-px,abs(b)-.015));\n    } else {\n        d2=max(d2,-(b-.025));\n        C = mix(C,vec3(.05),smoothstep(px,-px,b-.04)); \n        C = mix(C,hsv2rgb(vec3(uv.x*.1,.8,.35)),smoothstep(px,-px,b-.0125));    \n    }\n    \n    C = mix(C,vec3(.02),smoothstep(px,-px,d2));\n    C = mix(C,C*.25,smoothstep(.045+px,-px,d-.035));\n    C = mix(C,vec3(.001),smoothstep(px,-px,d));\n    C = mix(C,cf,smoothstep(px,-px,d+.045));\n\n\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVXDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[377, 377, 396, 396, 439], [440, 440, 462, 462, 520], [521, 521, 548, 548, 611], [613, 630, 657, 657, 773], [775, 775, 816, 816, 3041]]}
{"id": "dlVXRc", "name": "Mean Value Coordinates on Quad", "author": "iq", "description": "Implementing Mean Value Coordinates in a quadrilateral, as explained here: [url]https://diglib.eg.org/bitstream/handle/10.2312/EGGH.EGGH04.007-014/007-014.pdf[/url]", "tags": ["2d", "quad", "meanvaluecoordinates", "mvc"], "likes": 30, "viewed": 772, "published": 3, "date": "1686265033", "time_retrieved": "2024-07-30T17:50:51.653192", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Mean Value Coordiantes implemented as in this paper:\n//\n//    https://diglib.eg.org/bitstream/handle/10.2312/EGGH.EGGH04.007-014/007-014.pdf\n//\n// You can compare to regular bilinear coordinates here:\n//\n//    https://www.shadertoy.com/view/lsBSDm (https://iquilezles.org/articles/ibilinear)\n//\n// Other shaders using MVCs:\n//    https://www.shadertoy.com/view/XdXBWl\n//    https://www.shadertoy.com/view/7ljGDc\n//    https://www.shadertoy.com/view/flGGzV\n\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec2 mvc( in vec2 p, in vec2 pa, in vec2 pb, in vec2 pc, in vec2 pd )\n{\n    vec2 sa = pa - p;\n    vec2 sb = pb - p;\n    vec2 sc = pc - p;\n    vec2 sd = pd - p;\n    \n    vec4 r = vec4( length(sa), length(sb), length(sc), length(sd) );\n    vec4 d = vec4( dot(sa,sb), dot(sb,sc), dot(sc,sd), dot(sd,sa) );\n    vec4 a = vec4( cro(sa,sb), cro(sb,sc), cro(sc,sd), cro(sd,sa) );\n\n    vec4 t = (r.xyzw*r.yzwx - d) / a;\n    vec4 u = (t.xyzw  +  t.wxyz) / r;\n    \n    vec4 w = u / (u.x+u.y+u.z+u.w);\n    \n    return w.yw + w.z; // equivalent to the block below\n    \n    /*\n    return vec2(0,0)*w.x + \n           vec2(1,0)*w.y +\n           vec2(1,1)*w.z +\n           vec2(0,1)*w.w;\n    */           \n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    p -= a; b -= a;\n\treturn length( p-b*clamp(dot(p,b)/dot(b,b),0.0,1.0) );\n}\n\n// simple hash\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+3.0,n+7.0))*321.513); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3( 0.35 + 0.1*p.y );\n\n    // move points\n    vec2 a = cos( 1.11*iTime + vec2(0.1,4.0) );\n    vec2 b = cos( 1.13*iTime + vec2(1.0,3.0) );\n    vec2 c = cos( 1.17*iTime + vec2(2.0,2.0) );\n    vec2 d = cos( 1.15*iTime + vec2(3.0,1.0) );\n\n    // d = c+a-b; // enable this to test parallelograms\n    \n    // area of the quad\n    vec2 uv = mvc( p, a, b, c, d );\n    \n    // inside of quad if uv in [0..1]^2\n    if( max( abs(uv.x-0.5), abs(uv.y-0.5))<0.5 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    \n    // quad borders\n    float h = 2.0/iResolution.y;\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,a,b)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,b,c)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,c,d)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,d,a)));\n \n    // dither\n    col += (1.0/255.0)*hash3(p.x+1920.0*p.y);\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVXRc.jpg", "access": "api", "license": "mit", "functions": [[1608, 1608, 1643, 1643, 1671], [1672, 1672, 1743, 1743, 2362], [2364, 2394, 2446, 2446, 2524], [2526, 2541, 2564, 2564, 2614], [2616, 2616, 2673, 2673, 3757]]}
{"id": "dlVSR3", "name": "Diagonal Checkerboard", "author": "dchapes123", "description": "2D checkerboard moving on a diagonal defined by a given rotation.", "tags": ["2d", "checkerboard"], "likes": 2, "viewed": 129, "published": 3, "date": "1686257877", "time_retrieved": "2024-07-30T17:50:52.418147", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Input parameters\n    const float boardSize = 15.0;\n    const float colorScale = 1.125;\n    const float timeScale = 0.125;\n    const float rotation = M_PI * 1.125;\n    \n    // 2D rotation matrix \n    const mat2 R = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    \n    float resScale = min(iResolution.x, iResolution.y);\n    vec2 guv = fragCoord / vec2(resScale);\n    vec2 uv = guv * R;\n    \n    float time = iTime * timeScale;\n    \n    bool f = bool(((int((uv.x - time) * boardSize) % 2) + (int(uv.y * boardSize) % 2)) % 2);\n    float d = max(0.0, distance(guv, vec2(0.5)) - 0.25) * colorScale;\n    \n    vec3 col = vec3(float(f) - d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "DtySR3", "name": "Tapestry 3", "author": "iterati", "description": "sdStar is fun", "tags": ["ifs"], "likes": 1, "viewed": 103, "published": 3, "date": "1686255462", "time_retrieved": "2024-07-30T17:50:53.197064", "image_code": "float morphStar( in vec2 p, in float r, in float f )\n{\n    float rtn = 0.;\n    float x = mod(f, 1.) * 2. * PI;\n    float y = sinT(f, 1.);\n    int n = (int(f) + 2) * 2;\n    \n    return (sdCircle(p, r) * y) + (sdStar(p, r, n, float(n) -0.1) * (1. - y));\n}\n\nfloat sheen( in float d )\n{\n    return pow(0.0025 / abs(d), 1.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 col = vec3(0.);\n    float d = 0.;\n    float f = mod(iTime / 7., 5.);\n    float r = sinT(iTime, 11.) * 0.4 + 0.3;\n    float x = sinT(iTime, 30.) * 1. + 1.;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * x) - 0.5;\n        d = sheen(morphStar(uv, r, f) * exp(-length(uv0) * sinT(iTime, 5.) * 2.));\n        col = palette((length(uv0) / 4.) + sin(iTime / 4.) + (i / 4.));\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415926538\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5); //vec3(0.744, 0.244, 0.577);\n    vec3 b = vec3(0.5, 0.5, 0.5); //vec3(0.231, 0.395, 0.498);\n    vec3 c = vec3(1.0, 1.0, 1.0); //vec3(0.759, 1.375, 0.932);\n    vec3 d = vec3(0.0, 0.333, 0.667); //vec3(3.477, 6.066, 1.898);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sinT( in float t, in float l )\n{\n    return (sin(((t * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( in float t, in float l )\n{\n    return abs((mod(t / l, 1.) - 0.5) * 2.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtySR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 282, 282, 322], [324, 324, 381, 381, 981]]}
{"id": "DtGXR3", "name": "Classic Equalizer", "author": "akufishi", "description": "A simple rainbow equalizer", "tags": ["audio", "rainbow"], "likes": 8, "viewed": 356, "published": 3, "date": "1686241505", "time_retrieved": "2024-07-30T17:50:53.957032", "image_code": "\n#define NUM_PILLARS 27.0\n#define M_PI 3.141592653589\n#define PILLAR_DROPOFF_START 1.5\n#define PILLAR_DROPOFF_END 3.0\n\nvec3 hsv2rgb(float hue, float saturation, float value)\n{\n  float c = value * saturation;\n  float h = hue / 60.0;\n  float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n  float m = value - c;\n\n  vec3 rgb;\n\n  if (h >= 0.0 && h < 1.0) {\n    rgb = vec3(c, x, 0.0);\n  } else if (h >= 1.0 && h < 2.0) {\n    rgb = vec3(x, c, 0.0);\n  } else if (h >= 2.0 && h < 3.0) {\n    rgb = vec3(0.0, c, x);\n  } else if (h >= 3.0 && h < 4.0) {\n    rgb = vec3(0.0, x, c);\n  } else if (h >= 4.0 && h < 5.0) {\n    rgb = vec3(x, 0.0, c);\n  } else if (h >= 5.0 && h < 6.0) {\n    rgb = vec3(c, 0.0, x);\n  }\n\n  rgb += m;\n\n  return rgb;\n}\n\n\nvec3 hue(float t)\n{\n    return hsv2rgb(t * 360.0, 1.0, 1.0);\n}\n\n\nfloat gaussian(float t)\n{\n    return exp(-(5.0 * pow(t - 0.5, 2.0)));\n}\n\n\nfloat audio_sample(float t)\n{\n    int tx = int(t * 512.0);\n\n    float fft  = texelFetch( iChannel0, ivec2(tx, 0), 0 ).x;\n    \n    return fft * gaussian(t) + 0.01 + (sin((iTime / 2. + t) * 5.) / 2. + 1.) / 50.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pillar_index = floor(uv.x * NUM_PILLARS) / NUM_PILLARS;\n    float pillar_height = audio_sample(pillar_index);\n    float pillar_dropoff = smoothstep(0.5 - pillar_height / PILLAR_DROPOFF_START, \n                                      0.5 - pillar_height / PILLAR_DROPOFF_END, uv.y) *\n                           smoothstep(0.5 + pillar_height / PILLAR_DROPOFF_START, \n                                      0.5 + pillar_height / PILLAR_DROPOFF_END, uv.y);\n\n    float ground_reflection = step(0.5, uv.y) + smoothstep(0.5, 0.0, uv.y - 0.12);\n    float separation = clamp(1. - cos(uv.x * M_PI * NUM_PILLARS * 2.), 0.0, 1.48);\n    \n    vec3 color = hue(pillar_index) * pillar_dropoff * ground_reflection * separation;\n    \n    color = mix(color, vec3(1.0), 0.12);\n\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 175, 175, 721], [724, 724, 743, 743, 786], [789, 789, 814, 814, 860], [863, 863, 892, 892, 1074], [1076, 1076, 1133, 1133, 1977]]}
{"id": "DtGXzy", "name": "P-addic distance", "author": "Txoka", "description": "saw this representation of p addic distance on veritasiums video and wanted to make it", "tags": ["paddic"], "likes": 8, "viewed": 246, "published": 3, "date": "1686235811", "time_retrieved": "2024-07-30T17:50:54.723982", "image_code": "#define zoom 1.1\n\nconst float r=2.*sqrt(3.)-3.;\nconst float ang=radians(120.0);\n\n\nvec2 convertCoordinates(vec2 uv) {\n    float a = mod(atan(uv.y, uv.x)-ang/4.,ang)+ang/4.;\n    return vec2(cos(a),sin(a))*length(uv);\n}\n\nfloat dot2(vec2 x){\n    return dot(x,x);\n}\n\nvec3 distort(vec2 uv){\n    float pixel=5./iResolution.y;\n    for(int i=0;i<10;i++){\n        if(dot2(uv)<1.){\n            uv=convertCoordinates(uv);\n            uv.y-=1.-r;\n            pixel/=r;\n            uv=uv/r;\n        }else{\n            return vec3(uv,pixel);\n        }\n    }\n    return vec3(uv,pixel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R=iResolution.xy,\n\tuv=zoom*(2.*fragCoord-R)/R.y,\n    m=zoom*(2.*iMouse.xy-R)/R.y;\n    \n    \n    \n    vec3 col=vec3(0);\n\n\n   \tvec3 new=distort(uv);\n    vec2 uv2=new.xy;\n    float pix=new.z*zoom;\n\n    col+=smoothstep(pix,0.,abs(dot2(uv2)-1.));\n    if(dot2(uv)<1.)col+=smoothstep(pix/r,0.,abs(dot2(r*uv2+vec2(0,1.-r))-1.)/(r*r));\n    if(iMouse.z>1.)col+=vec3(0,0.1,0)*pix*pix/dot2(uv2-m);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 116, 116, 216], [218, 218, 237, 237, 260], [262, 262, 284, 284, 571], [573, 573, 629, 629, 1072]]}
{"id": "clyXz3", "name": "Chromatic Aberration Squared", "author": "Pink", "description": "Simple offset sin based colour mixing shader producing an exaggerated lens chromatic aberration type effect.", "tags": ["2d", "colourful"], "likes": 8, "viewed": 144, "published": 3, "date": "1686234098", "time_retrieved": "2024-07-30T17:50:55.482952", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime = iTime*0.5;\n    \n    float zoom_out = 8.0;\n    float vignette = 2.3;\n    \n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y) * (2.0 + sin(myTime));\n\n    float d = (1.0-length(uv) + (0.5 * 0.5 + sin(myTime))) + vignette;\n    uv *= zoom_out;\n    float red_one = 0.5 * 0.5 + sin(uv.x + (myTime * 1.0));\n    float green_one = 0.5 * 0.5 + sin(uv.x + (myTime * 1.3));\n    float blue_one = 0.5 * 0.5 + sin(uv.x + (myTime * 1.6));\n    \n    float red_two = 0.5 * 0.5 + cos(uv.y + (myTime * 1.1));\n    float green_two = 0.5 * 0.5 + cos(uv.y + (myTime * 1.4));\n    float blue_two = 0.5 * 0.5 + cos(uv.y + (myTime * 1.7));\n\n    vec3 col = vec3(red_one, green_one, blue_one) * vec3(red_two, green_two, blue_two);\n    col = smoothstep (0.1, 0.9, col);\n    col = d * pow(col,vec3(0.5)+0.5*sin(myTime));\n    col = smoothstep (0.15, 1.0, col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1057]]}
{"id": "DtGXz3", "name": "fake Ambient Occlusion", "author": "ianertson", "description": "fake AO", "tags": ["ao"], "likes": 3, "viewed": 325, "published": 3, "date": "1686233335", "time_retrieved": "2024-07-30T17:50:56.248904", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    // Time varying pixel color\n    vec3 s = texture(iChannel0, uv).rgb;\n    float l = dot(s, s);\n    float l2 = dot(s, vec3(0.299, 0.587, 0.114));\n    \n    l2 = l2 * l2 * (3.0 - 2.0 * l2);\n    \n    float lf = fwidth(l2);\n    float d = exp(-lf);\n    vec2 fuv = fwidth(uv)*lf;\n    \n    float z1 = distance(fwidth(uv), fwidth(s.xy));\n    float z2 = fwidth(dot(uv, vec2(exp(-z1), d)));\n  \n    \n    \n    col += (1.0-smoothstep(\n      0.04,\n      d*0.7,\n      fwidth(\n        dot(\n          normalize(0.25*d-fuv.xyy*vec3(fwidth(s.xy) - 0.33 * lf, z1)),\n          normalize(0.25*l-vec3(s.xy, z1))\n        )\n      )\n    )) * 0.25;\n    \n    col += (1.0-smoothstep(\n      0.03,\n      d*0.5,\n      fwidth(\n        dot(\n          normalize(0.25*d-fuv.yyx*vec3(fwidth(s.yz) - 0.25 * lf, z2)),\n          normalize(0.25*l-vec3(s.yz, z2))\n        )\n      )\n    )) * 0.25;\n    \n    col += (1.0-smoothstep(\n      0.02,\n      d*0.45,\n      fwidth(\n        dot(\n          normalize(0.25*l-vec3(fwidth(s.yz) - 0.5 * lf, z2)),\n          normalize(0.25*d-vec3(s.yz, z2))\n        )\n      )\n    )) * 0.25;\n    \n    col += (1.0-smoothstep(\n      0.000001,\n      d*0.33,\n      fwidth(\n        dot(\n          normalize(0.25*l-vec3(fuv - lf, z2-z1)),\n          normalize(0.25*d-vec3(s.yz, z2-z1))\n        )\n      )\n    )) * 0.25;\n    \n    col += col*(col / (1.0 + col*4.0));\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1559]]}
{"id": "mlKXRV", "name": "Math is pretty", "author": "utkarsh_1905", "description": "Inspired from kishimisu", "tags": ["neon"], "likes": 4, "viewed": 128, "published": 3, "date": "1686228770", "time_retrieved": "2024-07-30T17:50:57.007875", "image_code": "float sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n   for(float i = 0.0; i < 4.0; i++){\n   \n        uv = fract(uv * 1.5) - 0.5;\n\n        // float d = sdHexagram(uv,0.35);\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col =  palette(length(uv0)+iTime*.6+i*.4);\n\n\n        if(mod(i,2.0) == 0.00){\n        d = sin(d*8. + iTime)/8.;\n        }else{\n        d = sin(d*8. - iTime)/8.;\n        }\n        \n        d = abs(d);\n        \n\n        d = pow(0.01/d,1.8);\n\n        finalColor += col * d;\n   \n   }\n    \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 284], [286, 286, 313, 313, 491], [493, 493, 550, 600, 1259]]}
{"id": "mlVSRV", "name": "Pie Chart with fake 3D", "author": "LLB", "description": "A pie chart with fake 3D and contour highlighting.", "tags": ["chart", "pie", "camembert"], "likes": 13, "viewed": 214, "published": 3, "date": "1686227713", "time_retrieved": "2024-07-30T17:50:57.766846", "image_code": "// Sorted values between 0 and 1, with 1 at the end.\nfloat values[] = float[](0.35, 0.6, 0.8, 0.9, 0.95, 1.);\n\nconst float TAU = 6.28318;\nconst float RADIUS = 0.3;\nconst float DEPTH = 0.05;\nfloat ROTATION = 0.;\n\nint sliceId(float value) {\n  for (int i = 0; i < values.length(); i++) {\n    if (values[i] > value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nvec3 palette(float t) {   // https://iquilezles.org/articles/palettes/\n  return vec3(0.7) + vec3(0.3) * cos(TAU * (vec3(1.) * t + vec3(0., 0.1, 0.3)));\n}\n\nvec3 idToColor(int id) {\n  return palette(float(id) / float(values.length()));\n}\n\nint uv2id(vec2 uv) {\n  float angle = atan(uv.y, uv.x) / TAU + 0.5;\n  angle = mod(angle + ROTATION, 1.);\n  return sliceId(angle);\n}\n\nvec3 uv2col(vec2 uv) {\n  return idToColor(uv2id(uv));\n}\n\nvec3 depth(vec2 uv) {\n  float x = uv.x;\n  float y = - sqrt(RADIUS*RADIUS - x*x);\n  \n  vec3 col = vec3(0.1); // background color\n\n  if (uv.y < 0. && uv.x >= -RADIUS && uv.x < RADIUS) {\n    col = mix(col, uv2col(vec2(x, y) * 0.5) * 0.5, 1. - smoothstep(DEPTH, DEPTH + 0.005, y - uv.y));\n  }\n  return col;\n}\n\n// Shading based on the distance between the point and the nearest border.\nfloat shading(vec2 uv) {\n  int id = uv2id(uv);\n  \n  int prevId = id - 1 < 0 ? values.length() : id - 1;\n  float prevAngle = (values[prevId] - 0.5 - ROTATION) * TAU;\n  vec2 prev = vec2(cos(prevAngle), sin(prevAngle)) * length(uv);\n\n  float nextAngle = (values[id] - 0.5 - ROTATION) * TAU;\n  vec2 next = vec2(cos(nextAngle), sin(nextAngle)) * length(uv);\n  \n  float minEdge = min(distance(prev, uv), distance(next, uv));\n  float dist = min(minEdge, abs(RADIUS - length(uv)) * .4);\n  \n  return\n      mix(0.7, 1., pow(smoothstep(0.0, 0.1, dist), 0.15))\n    * mix(1.3, 0.8, smoothstep(0., 0.4, length(uv)))\n    * mix(0.5, 1., smoothstep(0., 0.008, pow(dist, 0.8)))\n    ;\n}\n\nvec3 pie(vec2 uv) {\n  float dist = length(uv);\n  vec3 col = uv2col(uv);\n  col *= shading(uv);\n  \n  return mix(col, depth(uv), smoothstep(RADIUS, RADIUS + 0.001, dist));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.y *= 0.8;\n    \n    // Animation\n    ROTATION = iTime * 0.05;\n    values[1] = 0.6 + sin(iTime) * 0.1;\n\n    fragColor = vec4(pie(uv), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 238, 238, 354], [356, 356, 379, 426, 509], [511, 511, 535, 535, 591], [593, 593, 613, 613, 723], [725, 725, 747, 747, 780], [782, 782, 803, 803, 1086], [1088, 1163, 1187, 1187, 1830], [1832, 1832, 1851, 1851, 2002], [2004, 2004, 2056, 2056, 2248]]}
{"id": "clySRm", "name": "rolling rush", "author": "abje", "description": "Using integers in this octree to make it more robust.\n2d testing [url]https://www.shadertoy.com/view/DtyXRK[/url]", "tags": ["3d", "octree"], "likes": 8, "viewed": 173, "published": 3, "date": "1686227697", "time_retrieved": "2024-07-30T17:50:58.539779", "image_code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nint vec3_min_index(vec3 a)\n{\n    if (a.x < a.y)\n        if (a.x < a.z)\n            return 0;\n        else\n            if (a.y < a.z)\n                return 1;\n            else\n                return 2;\n    else\n        if (a.y < a.z)\n            return 1;\n        else\n            if (a.x < a.z)\n                return 0;\n            else\n                return 2;\n}\n\nfloat map(vec3 p)\n{\n    float len = length(p.xy);\n    p.xy *= rot(p.z*0.05+len*0.04);\n    \n    float l = (3.0-abs(p.y));\n    //float l = 10000000.0;\n    \n    p.x += iTime*5.0;\n    p.y = mod(p.y, 4.0)-2.0;\n    p.xz = mod(p.xz, 10.0)-5.0;\n    l = min(l, length(p)-1.0);\n\n    return l*0.8;\n}\n\nvec3 get_color(vec3 p, vec3 n)\n{\n    float len = length(p.xy);\n    p.xy *= rot(p.z*0.05+len*0.04);\n    \n    float l = (3.0-abs(p.y));\n    \n    p.x += iTime*5.0;\n    p.y = abs(p.y)-2.0;\n    \n    vec3 p2 = p;\n    \n    p.xz = mod(p.xz, 10.0)-5.0;\n    l = max(length(p)-1.0,0.0);\n    \n    n.xz *= rot(p2.x);\n    n.xy *= rot(p2.z);\n    \n    vec3 c = vec3(1, 0.5, 0.8)+n*0.1;\n    \n    return c/(l*l+1.0);\n}\n\nint get_voxel(ivec3 id, float size)\n{\n    vec3 p = vec3(id)*size+size*0.5;\n    \n    // sqrt(1^2+1^2+1^2) distance from cube center to cube corner\n    size *= sqrt(3.0)*0.5;\n    \n    float d = map(p);\n    \n    if (d > size)\n        return 1;\n    if (d < -size)\n        return 2;\n    return 3;\n}\n\nvec3 shoot_ray(const vec3 ro, const vec3 rd)\n{\n    ivec3 id = ivec3(floor(ro));\n    \n    vec3 ird = 1.0/abs(rd);\n    \n    ivec3 isrd = ivec3(greaterThan(rd, vec3(0)));\n    \n    vec3 frp = fract(ro);\n    \n    float size = 1.0;\n    \n    vec3 p = ro;\n    float d = 0.0;\n    \n    vec3 dists = ird*(step(0.0,rd)-sign(rd)*fract(ro));\n    \n    \n    int depth = 0;\n    int j = 0;\n    \n    bool exit = false;\n    \n    for (int i = 0; i < 100; i++)\n    {\n        if (exit)\n        {\n            ivec3 grid = id&1;\n            frp += vec3(grid)*size;\n            id >>= 1;\n            depth--;\n            \n            grid = grid ^ isrd;\n            dists += ird*size*vec3(grid);\n            \n            size *= 2.0;\n            \n            exit = (id[j]&1) != isrd[j] && depth > 0;\n            \n            continue;\n        }\n    \n        int vox_stat = get_voxel(id, size);\n        if (vox_stat == 2)\n            break;\n        \n        if (vox_stat == 3)\n        {\n            if (depth >= 3) break;\n            size /= 2.0;\n            id <<= 1;\n            depth++;\n            \n            bvec3 grid = greaterThan(frp, vec3(size));\n            bvec3 look = lessThan(rd, vec3(0));\n            \n            id += ivec3(grid);\n            frp -= vec3(grid)*size;\n            dists -= ird*size*vec3(equal(grid, look));\n            \n            continue;\n        }\n    \n        j = vec3_min_index(dists);\n        \n        d = dists[j];\n        \n        dists[j] += ird[j]*size;\n        id[j] += isrd[j]*2-1;\n        \n        frp += ro+rd*d-p;\n        frp[j] -= sign(rd[j])*size;\n        \n        exit = (id[j]&1) != isrd[j] && depth > 0;\n\n        p = ro+rd*d;\n    }\n    \n    vec3 col = frp;\n    \n    vec3 n = vec3(0);\n    n[j] = 1.0;\n    n *= sign(rd);\n    col = get_color(p, n);\n    \n    col *= 1.0/(d*d*d*0.0005+1.0);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    if (length(iMouse.xy) < 10.0)\n        muv = vec2(0.5);\n\n    vec3 ro = vec3(0, 0, iTime);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    rd.yz *= rot(muv.y*3.14-3.14*0.5);\n    rd.xz *= rot(muv.x*3.14*4.0);\n    \n    vec3 col = shoot_ray(ro, rd);\n    \n    //some gamma stuff\n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clySRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 82, 82, 420], [422, 422, 441, 441, 710], [712, 712, 744, 744, 1112], [1114, 1114, 1151, 1151, 1407], [1409, 1409, 1455, 1455, 3242], [3244, 3244, 3299, 3299, 3753]]}
{"id": "mlVXRK", "name": "hoshino family's eyes", "author": "silica163", "description": "main caracters' eyes from Hoshi No Ko", "tags": ["eye"], "likes": 3, "viewed": 174, "published": 3, "date": "1686223904", "time_retrieved": "2024-07-30T17:50:59.305731", "image_code": "#define PI 3.14159265\nfloat circle(vec2 uv,vec2 p,float ir,float or)\n{\n    return smoothstep(or,or-.01,length(uv-p)) - smoothstep(ir,ir-.01,length(uv-p));\n}\n\nfloat sixRayStar(vec2 uv,vec2 p,float s)\n{\n    uv = uv-p;\n    float r = max(s-abs(cos(atan(uv.y,uv.x)*3.))*length(uv)*4.,0.);\n    return smoothstep(r,r-.3,length(uv*vec2(1.3,1)));\n}\n\nvec3 eye(vec2 uv,vec2 p,float s,float starC,float eC)\n{\n    uv = uv-p;\n    vec3 c = vec3(0);\n    float dist = length(uv*vec2(1.3,1));\n    float edge = smoothstep(s,s-.01,dist);\n    \n    // ai\n    c += mix(vec3(.8,0.3,.8),vec3(.1,0,.7),.3+uv.y+uv.x*uv.x)\n        *edge\n        *max(1.-mod(eC,3.),0.);\n        \n    // aqua \n    // ctop vec3(0,.1,.6)\n    // cbot vec3(.4,.8,1)\n    c += mix(vec3(0,.1,.6),vec3(.3,.8,1),pow(uv.x*1.6,2.)-uv.y*1.9+.3)\n        *edge\n        *max(1.-mod(eC+1.,3.),0.);\n        \n    // ruby\n    // ctop vec3(.7,.1,.4)\n    // cbotin vec3(1,.2,.5)\n    // cbotout vec3(1,.4,.6)\n    c += mix(\n        mix(\n            vec3(1,.2,.5),\n            vec3(1,.4,.6),\n            smoothstep(.3,.34,dist)-smoothstep(.45,.49,dist)\n        ),\n        vec3(.7,.1,.4),\n        1.-smoothstep(.6,.3,length(uv*1.4+vec2(0,.4)))\n        )*edge\n        *max(1.-mod(eC+2.,3.),0.);\n    \n    c += sixRayStar(uv,vec2(0),s-.1)*starC;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n    //col += circle(uv,vec2(0),.4,.41);\n    \n    if(floor(mod(iTime,12.)/2.) == 0.){\n        col += eye(uv,vec2(.7,0),.5,1.,0.);\n        col += eye(uv,vec2(-.7,0),.5,1.,0.);\n    }\n    if(floor(mod(iTime,12.)/2.) == 1.){\n        col += eye(uv,vec2(.7,0),.5,0.,2.);\n        col += eye(uv,vec2(-.7,0),.5,1.,2.);\n    }\n    if(floor(mod(iTime,12.)/2.) == 2.){\n        col += eye(uv,vec2(.7,0),.5,0.,2.);\n        col += eye(uv,vec2(-.7,0),.5,-1.,2.);\n    }\n    if(floor(mod(iTime,12.)/2.) == 3.){\n        col += eye(uv,vec2(.7,0),.5,0.,2.);\n        col += eye(uv,vec2(-.7,0),.5,0.,2.);\n    }\n    if(floor(mod(iTime,12.)/2.) == 4.){\n        col += eye(uv,vec2(.7,0),.5,1.,1.);\n        col += eye(uv,vec2(-.7,0),.5,0.,1.);\n    }\n    if(floor(mod(iTime,12.)/2.) == 5.){\n        col += eye(uv,vec2(.7,0),.5,-1.,1.);\n        col += eye(uv,vec2(-.7,0),.5,-1.,1.);\n    }\n    \n    col *= smoothstep(\n        .1,\n        .12,\n        -uv.y+cos(uv.x*4.5)*-.3*(.5-pow(mod(iTime,2.)-1.,2.))+.1+(.5-pow(mod(iTime,2.)-1.,2.))\n    );\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 70, 70, 156], [158, 158, 200, 200, 339], [341, 341, 396, 396, 1291], [1293, 1293, 1350, 1350, 2520]]}
{"id": "mtVSRK", "name": "patterns,zhouyi,yi,Hexagrams ", "author": "yufengjie", "description": "", "tags": ["patterns", "zhouyi", "yi", "hexagrams"], "likes": 11, "viewed": 189, "published": 3, "date": "1686222577", "time_retrieved": "2024-07-30T17:51:00.109582", "image_code": "\nconst float w = 0.8; // \nconst float h = 0.1; // \nconst float yinGap = 0.2; // \nconst float gap = 0.1; // \n\nfloat random(float seed) {\n  return fract(sin(seed) * 4563.5421);\n}\n\nfloat genCorner(vec2 D, vec2 st) {\n  vec2 halfS = smoothstep(D - vec2(0.01), D, st);\n  vec2 halfE = smoothstep(D, D + vec2(0.01), st);\n  vec2 c = halfS - halfE;\n  return c.x + c.y;\n}\n\nfloat genBound(vec2 st) {\n  float lb = genCorner(vec2(0.0), st);\n  float rt = genCorner(vec2(1.0), st);\n  return lb + rt;\n}\n\nfloat SMOOTH(float D, float d) {\n  return smoothstep(D - 0.01, D + 0.01, d);\n}\n\nfloat rect(vec2 st, float l, float r, float t, float b) {\n  float v = SMOOTH(b, st.y) - SMOOTH(t, st.y);\n  float h = SMOOTH(l, st.x) - SMOOTH(r, st.x);\n  return v * h;\n}\n\nfloat geneYao(vec2 st, bool yang) {\n  if(yang) {\n    return rect(st, 0.0, w, h, 0.0);\n  } else {\n    float l = rect(st, 0.0, w * 0.5 - yinGap * 0.5, h, 0.0);\n    float r = rect(st, w * 0.5 + yinGap * 0.5, w, h, 0.0);\n    return l + r;\n  }\n}\n\nfloat geneYi(vec2 st, bool y1, bool y2, bool y3) {\n  float W = w;\n  float H = h * 3.0 + gap * 2.0;\n  vec2 t = vec2(W * 0.5, H * 0.5);\n  st -= 0.5;\n  st += t;\n\n  float yao1 = geneYao(st, y1);\n  st.y -= gap + h;\n  float yao2 = geneYao(st, y2);\n  st.y -= gap + h;\n  float yao3 = geneYao(st, y3);\n  st.y -= gap + h;\n  return yao1 + yao2 + yao3;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy / iResolution.xx;\n  vec3 color = vec3(0.0);\n\n  float col = 10.0;\n\n  st *= col;\n\n  vec2 ipos = floor(st);\n  st = fract(st);\n  float b = genBound(st);\n  \n  float t = floor(iTime * 3.);\n\n  bool y1 = random(ipos.x + ipos.y + 11.13 + t) > 0.5;\n  bool y2 = random(ipos.x + ipos.y + 23.77 + t) > 0.5;\n  bool y3 = random(ipos.x + ipos.y + 51.67 + t) > 0.5;\n\n  float yi = geneYi(st, y1, y2, y3);\n\n  color += yi;\n  color += b;\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 192, 192, 233], [235, 235, 269, 269, 417], [419, 419, 444, 444, 542], [544, 544, 576, 576, 622], [624, 624, 681, 681, 793], [795, 795, 830, 830, 1035], [1037, 1037, 1087, 1087, 1379], [1383, 1383, 1440, 1440, 1917]]}
{"id": "mtKSRK", "name": "Purple/monochrome fractal", "author": "anti", "description": "This shader stuff is really cool. Hoping to continue making cooler stuff!", "tags": ["fractal", "circles", "repetition", "animated", "monochrome", "purple"], "likes": 2, "viewed": 149, "published": 3, "date": "1686220975", "time_retrieved": "2024-07-30T17:51:01.021145", "image_code": "/*\n    Made with kishimisu's tutorial (very good)\n\n    Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.938, 0.328, 0.718);\n    vec3 b = vec3(0.659, 0.438, 0.328);\n    vec3 c = vec3(0.388, 0.388, 0.296);\n    vec3 d = vec3(2.538, 2.478, 0.168);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    float l = length(uv);\n    vec3 finalCol = vec3(0.);\n    \n    for (float i=0.;i<1.2;i++) {\n        uv = fract(uv*1.5)-0.5;\n\n        float d = length(uv) * exp(-l);\n                    \n        d = exp(\n                0.01/(\n                        abs(\n                                sin(\n                                        8.*d+iTime\n                                   ) /8.\n                                    \n                             )\n                      )\n                )*0.9;\n\n  \n        vec3 col = palette(l-10.+iTime);\n        finalCol += col * d - 10.;\n\n    }\n\n\n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 127, 127, 335], [337, 337, 394, 394, 1083]]}
{"id": "DlVXzV", "name": "Infinite Rainbow Rings", "author": "Slykapar", "description": "It shows many rings and it zooms out at the same time. While zooming out the rings are shrinking and new ones are apperaring.", "tags": ["ringsrainbowinfinite"], "likes": 4, "viewed": 94, "published": 3, "date": "1686220870", "time_retrieved": "2024-07-30T17:51:01.913758", "image_code": "vec3 pallete(float t) {\n    vec3 a = vec3(0.718, 0.498, -0.222);\n    vec3 b = vec3(-0.032, 0.588, 0.968);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0., 0.333, 0.667);\n    \n    return a + b * cos( 1. * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= iTime * 1.;\n    uv = fract(uv);\n    uv -= 0.5;\n    \n    float d = length(uv);\n    \n    vec3 col = pallete(d + iTime);\n    \n    d = sin(d * 8. + iTime) / 8.;\n    d = abs(d);\n    d = 0.02 / d;\n    \n    col *= d;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 223], [225, 225, 282, 282, 630]]}
{"id": "DtVSzV", "name": "Bouncing Ball!", "author": "Starfish", "description": "White ball repeatedly bouncing from left to right.", "tags": ["sine"], "likes": 1, "viewed": 126, "published": 3, "date": "1686219383", "time_retrieved": "2024-07-30T17:51:02.697662", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //small zoom\n    uv *= vec2(2.0, 2.0);\n    \n    \n    //calculate the ball coordinates at a given time\n    //modulo is used to reset the ball position once the screen end is reached\n    //a small offset is added to the sin result, since the ball would sink halfway into the screen otherwise\n    vec2 ballPos = vec2(mod(iTime, 3.5), abs(sin(iTime)) + 0.05);\n\n    //set a pixel to white when within a certain distance of the ball coordinates\n    vec3 col = vec3(0.0);\n    if(distance(uv, ballPos) < 0.1){\n        col = vec3(1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 788]]}
{"id": "DtySWh", "name": "Shifting Spectrum", "author": "propagant", "description": "Simple screen-shader with shifting circles spectrum. Playaround with global params for different results.", "tags": ["circles", "spectrum", "colors", "screenshader"], "likes": 16, "viewed": 332, "published": 3, "date": "1686214658", "time_retrieved": "2024-07-30T17:51:03.459625", "image_code": "// Simple shifting circles spectrum written by Matej Vanco just for fun, June 2023.\n\n// Shader global params\n\nconst float particleCount = 124.;\nconst float speed = .5;\nconst float size = 20.;\nconst float brightness = 0.001;\nconst vec2 smoothness = vec2(0.1,0.5);\nconst vec2 sway = vec2(4.5,2.);\nconst float alpha = .8;\n\n// Hash methods\n\nvec3 Hash13(in float t)\n{\n\tvec3 xyz;\n\txyz.x = fract(sin(t * 782.287) * 248.842);\n\txyz.y = fract(sin((t+xyz.x) * 782.287) * 248.842);\n\txyz.z = fract(sin((t+xyz.y) * 1024.768) * 64.32);\n\treturn xyz;\n}\n\nfloat Hash1(in float t)\n{\n\tfloat x = fract(cos(t * 782.287) * 248.842);\n\treturn x;\n}\n\n\n\nvec3 Run(in vec2 uv, in float t)\n{\n\tvec3 res = vec3(0.);\n\t\n\tfor(float i = 0.; i < particleCount; i++)\n\t{\n        // Current time\n\t\tfloat ct = t + (i+1.) / particleCount;\n        // Current seed\n\t\tvec3 cseed = Hash13((i+1.) * (ct - t ))-.5;\n        // Current pos\n\t\tvec2 cp = uv - cseed.xy + vec2(sin(ct*sway.x*cseed.x), cos(ct*sway.y*cseed.y))*.1;\n\t\t// Current brightness\n\t\tfloat b = size+(sin(ct));\n        // Current alpha\n\t\tfloat a = clamp(abs(cos(ct*2.)), 0., 1.);\n        // Current circle\n\t\tfloat r = smoothstep(smoothness.x,smoothness.y,(brightness/length(cp))*b);\n        \n\t\tres += abs(cseed)*r*a;\n\t}\n\t\n\treturn res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy - (.5 * iResolution.xy)) / iResolution.x; // Switch to iResolution.y for aspect ratio correction\n    fragColor = vec4( Run(uv, (iTime+100.) * speed) * alpha, 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtySWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 362, 362, 535], [537, 537, 562, 562, 621], [625, 625, 659, 659, 1250], [1253, 1253, 1310, 1310, 1504]]}
{"id": "DlVXRK", "name": "Heater shader", "author": "Wither362", "description": "Shader which heats the image.", "tags": ["channel"], "likes": 2, "viewed": 121, "published": 3, "date": "1686212151", "time_retrieved": "2024-07-30T17:51:04.226574", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + abs(1.0 / sin(iTime)) * cos(iTime+uv.yyy + texture(iChannel0, uv).xyz);\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0, uv).xyz * col,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 360]]}
{"id": "mtyXzV", "name": "shadertoy-antialias-demo", "author": "LydianLights", "description": "Simple, readable demo of how to add antialiasing to your shader using a box filter algorithm. Careful, as this method is computationally expensive -- running your shader code n^2 times as AA_STAGES increases.\nExample: https://www.shadertoy.com/view/DlVSWD", "tags": ["tutorial", "demo", "antialias"], "likes": 8, "viewed": 370, "published": 3, "date": "1686209387", "time_retrieved": "2024-07-30T17:51:04.989535", "image_code": "// ====== MAIN SHADER CODE ====== //\n// Everything you'd normally put in your shader goes here\n// This just draws some rings on a checkerboard\nconst float PI = 3.1415927;\nvec3 mainPass(in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 rotUV = uv * mat2(cos(PI / 5.0), sin(PI / 5.0), -sin(PI / 5.0), cos(PI / 5.0));\n    rotUV.y += 0.1 * iTime;\n    rotUV = fract(1.5 * rotUV);\n    \n    float d0 = abs(step(rotUV.x, 0.5) - step(rotUV.y, 0.5));\n    \n    vec3 color = vec3(d0);\n   \n    float d1 = length(uv);\n    d1 = step(d1, 0.5) * step(0.3, d1);\n    if (d1 > 0.0) color = vec3(1.0, 0.25, 0.25);\n    \n    float d2 = length(uv - vec2(1.1, 0.0));\n    d2 = step(d2, 0.5) * step(0.3, d2);\n    if (d2 > 0.0) color = vec3(0.25, 1.0, 0.25);\n    \n    float d3 = length(uv + vec2(1.1, 0.0));\n    d3 = step(d3, 0.5) * step(0.3, d3);\n    if (d3 > 0.0) color = vec3(0.25, 0.25, 1.0);\n   \n    return color;\n}\n\n\n// ====== ANTIALIASING ====== //\n// Basically this calls your shader multiple times with a random subpixel offset and averages the results\n// Quick and easy to implement, but does have performance implications for intense shaders\n\n// Function for getting 2d noise\n// see https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 antialias(in vec2 fragCoord)\n{\n    // Set the number of AA passes here\n    // Note that your shader code is called n^2 times, so be careful\n    // Higher values have diminishing returns anyway\n    const float AA_STAGES = 2.0;\n    \n    // These constants don't need changing\n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    // Run the shader multiple times with a random subpixel offset each time and average the results\n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n\n\n// ====== GAMMA CORRECTION ====== //\n// Helps with color mixing -- good to have by default in almost any shader\n// See https://www.shadertoy.com/view/lscSzl\nvec3 gamma(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\n\n// ====== FINAL RENDERING ====== //\n// All the code here is just to show the comparison\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float sliderX = iMouse.z > 0.0 ? iMouse.x : iResolution.x / 2.0;\n    \n    vec3 base = mainPass(fragCoord);\n    vec3 antialiased = antialias(fragCoord);\n    \n    vec3 color = fragCoord.x < sliderX ? base : antialiased;\n    if (abs(fragCoord.x - sliderX) < 4.0)\n    {\n        color = vec3(0.5);\n    }\n    \n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}\n\n// This is all you would need in a normal shader:\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = antialias(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 205, 205, 976], [1210, 1288, 1309, 1309, 1442], [1444, 1444, 1479, 1641, 2247], [2250, 2407, 2434, 2434, 2476], [2479, 2567, 2624, 2624, 3036]]}
{"id": "clVSWW", "name": "Ceci n'est pas un point vert", "author": "fenix", "description": "Stare at the black cross and remember: there are no green dots in this image!\n\nInspired by:\n\nhttps://www.reddit.com/r/OpticalIllusionGifs/comments/3a2x7c/stare_at_the_center_dot_to_see_some_green/", "tags": ["illusion", "codegolf", "reproduction"], "likes": 13, "viewed": 190, "published": 3, "date": "1686199058", "time_retrieved": "2024-07-30T17:51:05.751497", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Stare at the black cross and remember: there are no green dots in this image!\n//\n//  Inspired by:\n//\n//      https://www.reddit.com/r/OpticalIllusionGifs/comments/3a2x7c/stare_at_the_center_dot_to_see_some_green/\n//\n//  If you're staring at the cross intently enough, the ring of pink dots will fade\n//  away, and a single rotating green dot will be left behind. This illusion is pretty\n//  easy to explain. It's based on the \"afterimage\" idea like those inverted color flags\n//  and whatnot:\n//\n//      hhttps://en.wikipedia.org/wiki/Afterimage\n//\n//  The pink dots \"antagonize\" or \"tire out\" the red and blue receptors in your retina,\n//  leaving a green afterimage. In this animated example, as long as you stare steadily\n//  at the cross, the green dots mostly just cancel out the pink ones, except for the one\n//  moving missing one, where we see the green. With the movement disabled, the pink\n//  dots still disappear; the disappearing one just give us a chance to see the negative\n//  afterimage.\n//\n//  The title of the shader means \"This is not a green dot\" and is a reference to the\n//  1929 painting \"The Treachery of Images\" by Ren Magritte. Which seems like a good\n//  title to inspire the title of an optical illusion shader...while I also admit that\n//  my usage is far more literal and less meta than the original. I'm not a French \n//  speaker so please correct me if this is not right: I just used Google Translate.\n//\n//  I feel pretty good about the code golfing on this one, but I probably missed something\n//  and submissions in the comments are encouraged.\n// ---------------------------------------------------------------------------------------\n\n// Original by me: 279 chars\n//*\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2 R = iResolution.xy,\n         u = (U - .5 * R) / R.y,\n         v = abs(u) / .01,                       // used to draw cross\n         a = atan(u.y, u.x) / 3.14 + vec2(1.06), // normalized angle\n         i = a - mod(a, .125);                   // angle index\n    \n    i.y -= .5; // generate sin in y component\n\n    O = vec4(v.x < 3. && v.y < .4 || v.y < 3. && v.x < .4 ? 0. : .7) + // draw cross\n            4.3 * vec4(1, -1, 1, 1) *                                  // dot color\n            max(0., .06                                                // size of dot\n                 - length(u + cos(i * 3.14) * .4)                      // distance to nearest dot\n                 - max(0., .2 - abs(mod(iTime * 2. + i.x, 2.))));      // turn off a rotating dot\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVSWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1888, 1921, 1957, 1957, 2728]]}
{"id": "mtySzK", "name": "LulenicaMicaTesting", "author": "lukacolic", "description": "Cool trick shaders!", "tags": ["testing", "learning", "shaders"], "likes": 3, "viewed": 134, "published": 3, "date": "1686198869", "time_retrieved": "2024-07-30T17:51:06.516452", "image_code": "void mainImage( out vec4 O, vec2 u ) {\n    vec2 R = iResolution.xy,\n         U = (u+u - R ) / R.y;\n    O *= 0.;\n    \n    for ( float l = length(U), d, i = 0.; i < 4.; i++)\n        U = fract(U * 1.5) - .5,\n        d = length(U) * exp(-l),\n        d = pow(abs( .08 / sin(d*8. + iTime) ) , 1.2),\n        O += d * ( .5 + .5*cos( 6.28*(l + i*.4 + iTime*.4 +vec4(.26,.42,.56,0) ) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtySzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 380]]}
{"id": "clGXRV", "name": "Tapestry 2", "author": "iterati", "description": "Trying multiple shapes", "tags": ["ifs"], "likes": 1, "viewed": 94, "published": 3, "date": "1686189845", "time_retrieved": "2024-07-30T17:51:07.293375", "image_code": "float sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n// [[0.744 0.244 0.577] [0.231 0.395 0.498] [0.759 1.375 0.932] [3.477 6.066 1.898]]\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5); //vec3(0.744, 0.244, 0.577);\n    vec3 b = vec3(0.5, 0.5, 0.5); //vec3(0.231, 0.395, 0.498);\n    vec3 c = vec3(1.0, 1.0, 1.0); //vec3(0.759, 1.375, 0.932);\n    vec3 d = vec3(0.0, 0.333, 0.667); //vec3(3.477, 6.066, 1.898);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat saw( in float f, in float t )\n{\n    return abs((mod(t, f) - (f * 0.5)) * 2.0 * f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    float x = (sin(iTime / 19.) * 0.5) + 1.75;\n    float y = saw(1., iTime / 17.) * 0.8 + 0.1;\n\n    for (float i = 0.0; i < 2.0; i++) {\n        uv = fract(uv * x) - 0.5;\n        float d = sdHexagram(uv, y) * exp(-length(uv0) * sin(iTime / 11.) * 2.);\n        vec3 col = palette((length(uv0) / 4.) + (iTime / 3.) + (i / 3.));\n        d = sin(d*12. + (iTime * 0.25)) / 12.;\n        d = abs(d);\n        d = step(d, 0.025 * (i + 1.));\n        finalColor += col * d;\n    }\n    for (float i = 0.0; i < 2.0; i++) {\n        uv = fract(uv * x) - 0.5;\n        float d = sdHexagon(uv, y) * exp(-length(uv0) * sin(iTime / 11.) * 2.);\n        vec3 col = palette((length(uv0) / 4.) + (iTime / 3.) + (i / 3.) + 0.25);\n        d = sin(d*6. + (iTime * 0.25)) / 6.;\n        d = abs(d);\n        d = step(d, 0.025 * (i + 1.));\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 232], [234, 234, 277, 277, 518], [520, 605, 632, 632, 931], [933, 933, 970, 970, 1023], [1025, 1025, 1082, 1082, 2086]]}
{"id": "DtySzK", "name": "Tapestry 1", "author": "iterati", "description": "Thanks for the motivation, kishimisu", "tags": ["ifs"], "likes": 1, "viewed": 101, "published": 3, "date": "1686185175", "time_retrieved": "2024-07-30T17:51:08.052345", "image_code": "float sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// [[0.744 0.244 0.577] [0.231 0.395 0.498] [0.759 1.375 0.932] [3.477 6.066 1.898]]\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5); //vec3(0.744, 0.244, 0.577);\n    vec3 b = vec3(0.5, 0.5, 0.5); //vec3(0.231, 0.395, 0.498);\n    vec3 c = vec3(1.0, 1.0, 1.0); //vec3(0.759, 1.375, 0.932);\n    vec3 d = vec3(0.0, 0.333, 0.667); //vec3(3.477, 6.066, 1.898);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat saw( in float f, in float t )\n{\n    return abs((mod(t, f) - (f * 0.5)) * 2.0 * f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    for (float i = 0.0; i < 4.0; i++) {\n        float x = (sin(iTime / 19.) * 0.5) + 1.75;\n        uv = fract(uv * x) - 0.5;\n        x = saw(1., iTime / 17.) * 0.8 + 0.1;\n        float d = sdHexagon(uv, x) * exp(-length(uv0) * sin(iTime / 11.) * 2.);\n        vec3 col = palette((length(uv0) / 4.) + (iTime / 3.) + (i / 3.));\n        d = sin(d*6. + (iTime * 0.25)) / 6.;\n        d = abs(d);\n        d = pow(0.0025 / d, 1.5);\n        finalColor += col * d;\n    }\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtySzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 232], [234, 319, 346, 346, 645], [647, 647, 684, 684, 737], [739, 739, 796, 796, 1416]]}
{"id": "dlcSWf", "name": "Year of Truchets #032", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n", "tags": ["raymarching", "hexagon", "truchet"], "likes": 31, "viewed": 443, "published": 3, "date": "1686174962", "time_retrieved": "2024-07-30T17:51:08.818298", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #032\n    06/07/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265\n#define PI2         6.28318530\n#define SQ3         1.732\n\n#define MIN_DIST 1e-3\n#define MAX_DIST 55.\n\n// globals and constants\nmat2 r60;\nvec2 speed=vec2(0);  \nvec3 hp=vec3(0),hit=vec3(0);\nvec4 hexTiles=vec4(0);\nfloat trigger=0.,stored=0.,tspeed=0.;\n\n// precal for speed\nconst float scale = .075;\nconst float sx = 23.0933;//SQ3/scale;\nconst float s4 = .577350;\nconst float s3 = .288683;\n\nconst float rep = 14.;\nconst float hrep = 7.;//rep/2.;\nconst float angle = .44879;//2.*PI/rep;\nconst float angfl = .22439;//angle/2.;\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\n// @iq.\nfloat ext(in float sdf, in float pz, in float h){vec2 w = vec2( sdf, abs(pz) - h );return min(max(w.x, w.y), 0.) + length(max(w, 0.));}\nfloat box( vec3 p, vec3 b ) {vec3 q=abs(p)-b;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat torus( vec3 p, vec2 t ) {vec2 q = vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\nfloat cap( vec3 p, float r, float h ) {vec2 d = abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat vcap( vec3 p, float h, float r ) {p.y -= clamp(p.y,0.,h);return length(p) - r;}\n\n// @Mercury_sexy\nfloat polar(inout vec2 p)  {\n    float a = atan(p.y, p.x) + angfl;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angfl;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (hrep)) ? abs(c) : c;\n} \n\nfloat column(vec3 q) {\n    float b = cap(q,.15,.05);\n    float c = box(vec3(q.x,abs(q.y)-.15,q.z),vec3(.065,.0125,.065))-.0005;\n    polar(q.xz);\n    float g = vcap(q-vec3(.07,-.1,0),.2,.025);\n    return min(c,max(b,-g));\n}\n// @Shane\nvec4 hexGrid(vec2 uv) {\n    const vec2 s = vec2(SQ3, 1.);\n    vec4 hC = floor(vec4(uv, uv - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\nfloat hex( in vec2 p, in float r ) {\n    const vec3 k = vec3(-.8660254,.5,.5773502);\n    p = abs(p);\n    p -= 2.*min(dot(k.xy,p),0.)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvec2 map(vec3 pos) {\n    vec2 res =vec2(1e5,0.);\n    pos *= scale;\n\n    hexTiles=hexGrid(pos.xz);\n    vec2 p  = hexTiles.xy;\n    vec2 id = hexTiles.zw;\n\n    float rnd = hash21(id);\n    float dir = 1.;\n\n    if (rnd>.5) {p *= r60; p.y=-p.y; dir = -1.;} \n    \n    // set vectors\n    vec2 p0 = p - vec2(-s3,.5);\n    vec2 p1 = p - vec2(s4,0);\n    vec2 p2 = p - vec2(-s3,-.5);\n\n    vec3 pp1 = vec3(p1.x,pos.y,p1.y);\n    vec3 pp2 = vec3(p2.x,pos.y,p2.y);\n    vec3 pp3 = vec3(p0.x,pos.y,p0.y); \n\n    float tk = .115+.05*sin(pos.z*1.5);\n    float tp = min(min(torus(pp1,vec2(s3,tk)),torus(pp2,vec2(s3,tk))),torus(pp3,vec2(s3,tk)));\n\n    float f= max(ext(hex(p,.49),pos.y+.1,.1),-tp)-.0035;\n    if(f<res.x) {\n        res=vec2(f,1.);\n        hp=vec3(p.x,pos.y+.1,p.y);\n    }\n\n    vec3 cp=vec3(p.x,pos.y-.165,p.y);\n    float c = column(cp);\n    if (c<res.x) {\n        res = vec2(c,5.);\n        hp = cp;\n    } \n\n    vec3 pm = pos*1.75+vec3(tspeed);\n    float fm = fbm(pm.xz)*.08;\n\n    float g = pos.y-.01+fm;\n    if (g<res.x) {\n        res = vec2(g,2.);\n        hp = pos;\n    } \n\n    // rescale\n    res.x *= 1./scale;\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<90;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<28?ray.x*.25:ray.x*.9;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec4 FC = vec4(0.169,0.263,0.271,.075);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    hit = hp;  \n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-12.*sin(T*.08),15.,12.*cos(T*.08));\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        float diff = clamp(dot(n,l),.01,.95);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 10.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 10.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        \n        if(m==1.) { \n            h=tex3D(iChannel0,hit*2.,n).rgb; \n            h=mix(h,vec3(.5),.25);\n            ref=h;\n        }\n        if(m==2.) { \n            h=vec3(.1,.22,.24); \n            ref=h;\n        }\n        if(m==5.) { \n            h=vec3(.5); \n            ref=h*.1;\n        }\n           \n        C = (diff*h);\n\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r60 = rot(1.047197);\n    tspeed = T*.45;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(18,0,10);\n    vec3 rd = normalize(vec3(uv,-1));\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(x-.525), ry = rot(y+T*.02);\n      // mouse //\n    ro.zy*=rx;ro.xz*=ry;\n    rd.zy*=rx;rd.xz*=ry; \n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(.95);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00006*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float random (in vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// this works on OSX/PC without fracture lines.\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1, 0));\n    float c = random(i + vec2(0, 1));\n    float d = random(i + vec2(1, 1));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 uv) {\n    float v = .0;\n    float a = .5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\n    for (float i = 0.; i < 4.; ++i) {\n        v += a * noise(uv);\n        uv = rot * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcSWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[838, 838, 857, 857, 902], [903, 903, 925, 925, 981], [983, 991, 1040, 1040, 1126], [1127, 1127, 1156, 1156, 1228], [1229, 1229, 1260, 1260, 1318], [1319, 1319, 1358, 1358, 1452], [1453, 1453, 1493, 1493, 1538], [1540, 1557, 1585, 1585, 1769], [1772, 1772, 1794, 1794, 1994], [1995, 2005, 2028, 2028, 2277], [2278, 2278, 2314, 2314, 2495], [2497, 2497, 2517, 2517, 3619], [3621, 3621, 3653, 3653, 3879], [3881, 3881, 3911, 3911, 4150], [4152, 4152, 4199, 4199, 4403], [4445, 4445, 4539, 4539, 5667], [5669, 5669, 5710, 5710, 6588]]}
{"id": "DlGXzy", "name": "BC: Color Picker", "author": "BackwardsCap", "description": "color picker experiment\nclick or drag to select your color and complementary colors will be selected automatically", "tags": ["colorpicker"], "likes": 4, "viewed": 365, "published": 3, "date": "1686168682", "time_retrieved": "2024-07-30T17:51:09.578266", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec4 bufferSample = texture(iChannel1, uv);\n    col = mix(col, bufferSample.rgb, bufferSample.a);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define px 3./iResolution.y\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = getColor(uv);\n    col *= circle(uv, 0.95, px);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "vec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn mix(vec3(1.0),mix( vec3(1.0), rgb, c.y), c.z);\n}\n\nfloat circle(vec2 p, float r, float px)\n{\n    return smoothstep(px,0., length(p)-r);\n}\n\nvec3 getColor(vec2 p)\n{\n    p.y*=-1.0;\n    float r = 3.14/2.;\n    p *= mat2(cos(r),sin(r),-sin(r), cos(r));\n    vec3 col = vec3(0);\n    \n    vec2 polar = vec2(atan(p.y, p.x), length(p));\n    \n    float pi = 3.1415927;\n    \n    float percent = (polar.x + pi) / (2.0 * pi);\n    \n    vec3 tc = vec3(percent, 1., polar.y);\n    \n    col = hsv2rgb_smooth(tc);\n    \n    return col;\n}", "buffer_b_code": "#define px 3./iResolution.y\n\nvec4 makeSample(vec2 samplePosition, vec2 displayPosition, float s)\n{\n    vec3 col = getColor(samplePosition).rgb;\n    return vec4(col, circle(displayPosition, s, px));\n}\n\nvec4 getColors(vec2 uv)\n{\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mid = uv - vec2(0.9*(iResolution.x/iResolution.y),0.);\n    float a = 0.0;\n    vec3 col = vec3(0);\n    float offset = 0.75;\n    \n    vec2 p = vec2(mouse.y, -mouse.x);\n    \n    float samples = 3.0;\n    \n    for(float i = -samples; i <= samples; i++)\n    {\n        float size = i == 0.0 ? 0.1 : 0.05;\n        vec2 pos = mouse + offset * p * i;\n        vec4 result = makeSample(pos, mid + vec2(0, 0.225) * i, size);\n        col = mix(col, result.rgb, result.a);\n        a = max(a, result.a);\n    }\n    \n    return vec4(col, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);   \n    vec4 complementaryColors = getColors(uv);\n    fragColor = vec4(complementaryColors.rgb,complementaryColors.a);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 274]]}
{"id": "DtKSRG", "name": "Sun Explosion", "author": "MorugaShestuck", "description": "A simple radiant of circle that gradually fills the entire space with the selected color", "tags": ["explosion", "circle", "cos", "radiant"], "likes": 0, "viewed": 159, "published": 3, "date": "1686166296", "time_retrieved": "2024-07-30T17:51:10.342223", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / vec2( iResolution.x, iResolution.y ) * 2.0 - 1.0;\n\tuv.x = uv.x * iResolution.x / iResolution.y;\n\n    float a, b, c = 0.0;\n    a = 1.0; // r var\n    b = 1.0; // g var\n    c = 0.1; // b var\n    \n    float d = length( uv )*0.5;\n    d = cos(d)*iTime/d;\n\n    fragColor = vec4(d*a, d*b, d*c, 1.0); // multiple circle distance by amount of color we want. Changing a, b & c variables change the color.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 476]]}
{"id": "DtyXRy", "name": "Late night truchet hacking+Color", "author": "timmaffett", "description": "just added color via hsb2rgb() -tmm all credit to @mrange\nCC0: Late night truchet hacking\nContinued a bit on the braided truchets\nTinkered around and liked the result\nCode is dirty and it is getting late\n", "tags": ["2d", "truchet"], "likes": 3, "viewed": 154, "published": 3, "date": "1686156537", "time_retrieved": "2024-07-30T17:51:11.106180", "image_code": "// Fork of \"Late night truchet hacking\" by mrange. https://shadertoy.com/view/DlVSRm\n// 2023-06-07 16:46:44\n\n// CC0: Late night truchet hacking\n//  Continued a bit on the braided truchets\n//  Tinkered around and liked the result\n//  Code is dirty and it is getting late\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat octogon(vec2 p, float r ) {\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\nvec3 braid(vec3 col, vec2 p, vec2 cp, float z, float aa) {\n  const float reps  = 32.0;\n  const float a     = TAU/reps;\n  const float bsz0  = a*0.3;\n  const mat2 rot2   = ROT(a*0.5);\n  const float sa    = a*-0.12;\n  const mat2 rot22   = ROT(sa);\n  const float bw    = 0.04;\n  const vec2 bp0 = -vec2(-0.5, 0.0);\n  const vec2 p00 = bp0*transpose(rot2);\n  const vec2 p01 = bp0*rot2;\n  const vec2 bp1 = -vec2(-0.5/cos(0.5*a+sa), 0.0);\n  const vec2 p10 = bp1*rot22;\n  const vec2 p11 = bp1*transpose(rot22);\n\n  float cd = length(cp)-0.5;\n  vec2 pp = cp;\n\n  pp *= rot2;\n  float n = modPolar(pp, reps);\n\n  float bd0 = segment(pp, p00, p10)-bw;\n  float bd1 = segment(pp, p01, p11)-bw;\n  bd0 = abs(bd0)-0.25*bw;\n  bd1 = abs(bd1)-0.25*bw;\n\n  float h = hash(n + 123.4);\n  if (sign(h-0.5)*cd > 0.) {\n    float tmp = bd0;\n    bd0 = bd1;\n    bd1 = tmp;\n  }\n\n  const float shd = 175.0;\n  col *= 1.0-exp(-shd*max(bd0, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, bd0));\n  col *= 1.0-exp(-shd*max(bd1, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, bd1));\n  //col = hsb2rgb(col);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float l = length(p);\n  const float pr = 10.0;\n  const float z = 1.0-0.25;\n  p /= z;\n\n  p *= ROT(0.05*TIME);\n  float n = smoothKaleidoscope(p, 0.075, 64.0);\n  p *= ROT(-0.05*TIME);\n  p += pr*sin(0.125*vec2(1.0, sqrt(0.5))*TIME/pr);\n\n  float aa = 4.0/(z*RESOLUTION.y);\n\n\n  vec2 cp = p;\n  vec2 np = round(cp);\n  float nh0 = hash(np+123.4);\n  cp -= np;\n  \n  if (nh0 > 0.5) cp = cp*ROT(PI/2.0);\n\n  vec3 col = vec3(0.1)*smoothstep(2.0, 0.0, l);\n  vec2 op = cp;\n  op = abs(op);\n  op -= 0.5;\n  float od1 = octogon(op, 1.0/6.0);\n  od1 = abs(od1)-1./16.0;\n  od1 = abs(od1)-1./32.0;\n  od1 = abs(od1)-1./96.0;\n  float od0 = length(op)-1.0/3.0;\n  \n  const float shd = 25.0;\n  col *= 1.0-exp(-shd*0.5*max(od0, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, od0));\n  col *= 1.0-exp(-shd*max(od1, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, od1));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, abs(od0)-0.011));\n  vec2 bp = cp;\n  float bn = ref(bp, normalize(vec2(1.0)));\n  bp -= 0.5;\n  col = braid(col, p, bp, z, aa);\n  col *= smoothstep(1.75, 0.5, length(pp));\n  col = sqrt(col);\n  col = hsb2rgb(vec3(col.y,0.9+col.x,0.7+col.z));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p*= 1.2;\n  \n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 450, 477, 477, 712], [715, 801, 846, 846, 1000], [1002, 1088, 1137, 1137, 1536], [1538, 1598, 1620, 1620, 1668], [1670, 1730, 1751, 1751, 1821], [1823, 1923, 1962, 1962, 2047], [2049, 2049, 2079, 2079, 2107], [2109, 2227, 2260, 2260, 2544], [2546, 2664, 2703, 2703, 2822], [2824, 2824, 2846, 2846, 2890], [2892, 2892, 2913, 2913, 2954], [2956, 3044, 3105, 3105, 3318], [3320, 3320, 3353, 3353, 3434], [3436, 3436, 3494, 3494, 4532], [4534, 4534, 4564, 4564, 5722], [5724, 5724, 5781, 5781, 5970]]}
{"id": "mlKSDm", "name": "Symmetric Moving Neon Shader", "author": "madmadi", "description": "Inspired by kishimisu's youtube video: https://www.youtube.com/watch?v=f4s1h2YETNY\nRepository: https://github.com/madmadi/symmetric-moving-neon-shader", "tags": ["moving", "pattern", "neon", "symmetric"], "likes": 3, "viewed": 290, "published": 3, "date": "1686149157", "time_retrieved": "2024-07-30T17:51:11.866149", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.428, 1.0, 1.0);\n    vec3 d = vec3(0.618, 0.333, 0.667);\n    \n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 uvo = uv;\n    vec3 finalColor = vec3(0.);\n\n    uv.y += iTime * .2;\n    \n    for (float i = 0.; i < 3.; i++) {\n        uv = fract(uv * 1.5) - .5;\n\n        float d = length(uv) * exp(-length(uvo));\n\n        vec3 color = palette(length(uvo) + i * .5 + iTime * .3);\n\n        d = sin(d * 10. + iTime) / 10.;\n        d = abs(d);\n\n        d = pow(.01 / d, 1.3);\n\n        finalColor += color * d;\n    } \n\n    fragColor = vec4(finalColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 213], [215, 215, 272, 272, 830]]}
{"id": "dtVSDw", "name": "Spin your brain", "author": "ivana888kitsune", "description": "<3", "tags": ["spinhypno"], "likes": 3, "viewed": 152, "published": 3, "date": "1686145717", "time_retrieved": "2024-07-30T17:51:12.632101", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Parametry spiralnego efektu\n    float speed = 0.5;       // Prdko obrotu spirali\n    float frequency = 100.0;   // Czstotliwo zmiany kolorw\n    float amplitude = 0.3;   // Amplituda zmiany kolorw\n\n    // Normalizacja wsprzdnych pikseli do zakresu od -1 do 1\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Oblicz kt dla kadego piksela\n    float angle = atan(uv.y, uv.x);\n\n    // Oblicz promie dla kadego piksela\n    float radius = length(uv);\n\n    // Oblicz przesunicie czasowe dla efektu animacji\n    float timeOffset = iTime * speed;\n\n    // Oblicz zmian kolorw na podstawie kta, promienia i czasu\n    vec3 color = vec3(\n        0.10 + 0.5 * sin(angle * frequency + timeOffset),\n        0.5 + 0.5 * sin(radius * frequency + timeOffset),\n        0.5 + 0.5 * sin((angle + radius) * frequency + timeOffset)\n    );\n\n    // Dodaj efekt zmiany kolorw do fragColor\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVSDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 90, 1024]]}
{"id": "mlKSWw", "name": "Glowstick Runner", "author": "SnoopethDuckDuck", "description": "Click the screen to change speed, click music in Buffer A if you want to hear it", "tags": ["animation", "nyancat", "walk", "run", "nose", "legs", "jedi"], "likes": 24, "viewed": 350, "published": 3, "date": "1686144624", "time_retrieved": "2024-07-30T17:51:13.399050", "image_code": "//#define l(d, p, q) d = min(d, seg(uv, p, q));\n#define l(d, p, q, r1, r2) d = min(d, cap(uv, p, q, r1, r2));\n\n// Custom smoothstep (don't use tanhC or atanhC)\nfloat tanhC(float x, float k) {float v = exp2(-k);return sign(x)*log2(v-(v-1.)*exp2(-abs(x)))/k;}\nfloat atanhC(float x, float k) {return sign(x)*log2((1.-exp2(k*(1.-abs(x))))/(1.-exp2(k)));}\nfloat smoothstepC(float x, float a, float o, float k) {\n    return .5+.5*tanhC(a*(atanhC(2.*x-1.,k)-atanhC(o,k)),k);\n}\n\n// X equations for feet\nfloat baseX(float x, float bo) {\n    return max(0., mod(x, 2.) - bo) / (2. - bo);\n}\n\nfloat leftX(float x, float bo, float a, float o, float k) {\n    return floor(0.5 * x) + smoothstepC(baseX(x, bo), a, o, k);\n}\n\nfloat rightX(float x, float bo, float a, float o, float k) {\n    return leftX(x + 1., bo, a, o, k) - 0.5;\n}\n\n// Y equation for feet\nfloat getY(float x, float o0, float a, float o, float k) {\n    return smoothstepC(.5+.5*cos(pi*(x+o0)), a, o, k);\n}\n\nvoid draw(inout vec3 col, vec2 ouv, vec2 uv, float t,\n          float bo, float ax, float ox, float kx,\n          float o0, float ay, float oy, float ky) {\n    // Feet\n    float Lx = 0.5 * leftX(t, bo, ax, ox, kx);\n    float Rx = 0.5 * rightX(t, bo, ax, ox, kx);    \n    vec2 pFootL = vec2(Lx - Rx, 0.2 * getY(t, o0, ay, oy, ky));\n    vec2 pFootR = vec2(Rx - Lx, 0.2 * getY(t + 1., o0, ay, oy, ky)); \n   \n    // Hip\n    float yL0 = 0.2 * getY(t + 0.05, o0, ay, oy, ky);\n    float yR0 = 0.2 * getY(t + 0.05 + 1., o0, ay, oy, ky);\n    float y = mix(yL0, yR0, 0.5);\n    vec2 pHip = vec2(mix(pFootL.x, pFootR.x, .5-.08*sin(pi*t)) - 0.05, \n                     y + 0.39);\n       \n    // Knees\n    vec2 pKneeL = pHip + solve(pFootL - pHip, 0.25, 0.27, -1.);\n    vec2 pKneeR = pHip + solve(pFootR - pHip, 0.25, 0.27, -1.);\n    \n    // Toes\n    vec2 pToeL = pFootL - 0.05 * Dir(getY(t-0.12, o0, ay, oy, ky));\n    vec2 pToeR = pFootR - 0.05 * Dir(getY(t+1.-0.12, o0, ay, oy, ky));\n    \n    // Body\n    float aBody = pi/2.+pi/12.+pi/16.*sin(-pi/8.+2.*pi*t);\n    vec2 pBody = pHip + 0.2 * Dir(0.*cos(2.*pi*t)+aBody);\n    \n    // Arms \n    float aArmL = pi/12.-pi/2.+pi/2.2*cos(pi*t);\n    float aArmR = pi/12.-pi/2.+pi/2.2*cos(pi*(t+1.));\n    vec2 pArmL = pBody + 0.2 * Dir(aArmL);\n    vec2 pArmR = pBody + 0.2 * Dir(aArmR);\n    \n    // Hands\n    float aHandL = aArmL -pi/12.- pi/4.*(1.+ths(3., pi*t));\n    float aHandR = aArmR -pi/12.- pi/4.*(1.+ths(3., pi*(t+1.)));\n    vec2 pHandL = pArmL + 0.15 * Dir(aHandL);\n    vec2 pHandR = pArmR + 0.15 * Dir(aHandR);\n    \n    // Fingies\n    vec2 pFingL = pHandL + 0.025 * Dir(aHandL + pi/8.*ths(3., pi/4.+pi*t));\n    vec2 pFingR = pHandR + 0.025 * Dir(aHandR + pi/8.*ths(3., pi/4.+pi*t));\n    \n    // Sticks\n    float aArmHandL = atan(pArmL.y-pHandL.y, pArmL.x-pHandL.x);\n    float aArmHandR = atan(pArmR.y-pHandR.y, pArmR.x-pHandR.x);\n    vec2 dirL = 0.05 * Dir(2.*pi*t+pi/2. + 0.3*pi * thc(6., pi*t) + aArmHandL);\n    vec2 dirR = 0.05 * Dir(2.*pi*(t+1.)+pi/2. + 0.3*pi * thc(6., pi*(t+1.)) + aArmHandR);\n    float timeRate = texture(iChannel0, vec2(0)).x;\n    //dC = min(dC, mix(0.45, 2., iMouse.y/res.y) - length(uv - pHip));\n    //dC = min(dC, 0.8 + 0.02*cos(pi*t) - length(ouv));\n    float dLightL = cap(uv, pFingL + dirL, pFingL + (8.-2.*timeRate) * dirL, 0.01, 0.01);\n    float dLightR = cap(uv, pFingR + dirR, pFingR + (8.-2.*timeRate) * dirR, 0.01, 0.01);\n    \n    // Head\n    float aHead = pi/2.+0.4+0.2*cos(2.*pi*t);\n    vec2 pHead = pBody + 0.1 * Dir(aHead);\n    vec2 pNose = pHead + 0.06 * Dir(pi/2. + aHead);\n    vec2 pEye = pHead + 0.025 * Dir(pi/3. + aHead);\n    \n    // Distances\n    float dL, dR, dC;\n    dL = dR = dC = 1e5;\n    l(dL, pHip, pKneeL, 0.04, 0.015);\n    l(dL, pKneeL, pFootL, 0.015, 0.01);\n    l(dL, pFootL, pToeL, 0.01, 0.005);\n    l(dL, pBody, pArmL, 0.035, 0.02);\n    l(dL, pArmL, pHandL, 0.02, 0.01);\n    l(dL, pHandL, pFingL, 0.01, 0.005);\n    l(dL, pFingL + dirL, pFingL - dirL, 0.01, 0.01);\n    \n    l(dR, pHip, pKneeR, 0.04, 0.015);\n    l(dR, pKneeR, pFootR, 0.015, 0.01);\n    l(dR, pFootR, pToeR, 0.01, 0.005);\n    l(dR, pBody, pArmR, 0.035, 0.02);\n    l(dR, pArmR, pHandR, 0.02, 0.01);\n    l(dR, pHandR, pFingR, 0.01, 0.005);\n    l(dR, pFingR + dirR, pFingR - dirR, 0.01, 0.01);\n      \n    l(dC, pHip, pBody, 0.04, 0.045);\n    dC = min(dC, length(uv - pHead) - 0.05);\n    l(dC, pHead, pBody, 0.02, 0.01);\n    l(dC, pHead, pNose, 0.01, 0.01);\n        \n    // Smoothsteps\n    float r = 0.0;\n    vec3 tint = vec3(1, .5, .5) * (uv.y + 0.5);\n    float sL = ss(1., r-dL);\n    float sC = ss(1., r-dC);\n    float sR = ss(1., r-dR);\n    float sLightL = ss(1., -dLightL);\n    float sLightR = ss(1., -dLightR);\n    float xpLightL = exp(-8.*sqrt(dLightL));   \n    float xpLightR = exp(-8.*sqrt(dLightR));\n    float d = min(dL, min(dC, dR));\n    d = min(d, min(dLightL, dLightR));\n    float sOutline = ss(1., 0.014 - d);\n    \n    // Mix color\n    col = mix(col, vec3(0.2), sOutline);\n    col = mix(col, vec3(0.2, 1, 0.2), sLightL);\n    col = mix(col, vec3(0.6) * tint, sL);     \n    col = mix(col, vec3(0.8) * tint, sC);\n    col = mix(col, vec3(1) * tint, sR);\n    col = mix(col, vec3(0, 1, 1), sLightR);\n    col = mix(col, vec3(0.2), ss(1., 0.012 - length(uv - pEye)));\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    uv += vec2(-0.12, 0.492);\n    \n    // Time\n    float t = -texelFetch(iChannel0, ivec2(px), 0).y;\n\n    // Parameters for foot trajectory - play with them here:\n    // https://www.desmos.com/calculator/fuxbacd7ae\n    float bo = 0.1;   // transition length (flat to steep)\n    float ax = 2.5;   // gradient (instant-ness of X motion)\n    float ox = -0.5;  // offset [-1,1]\n    float kx = 4.;    // sharpness    \n    float o0 = 1.3;   // wave offset\n    float ay = 1.;    // gradient\n    float oy = -0.5;  // offset [-1,1]\n    float ky = 0.82;  // sharpness\n     \n    // Background glow\n    vec3 col = exp(-0.55 * vec3(1,2,.5) * abs(uv.y));\n\n    // Background stripes\n    vec2 uv2 = uv;\n    uv2.x += -0.4 * t;\n    uv2 *= rot(pi/1.5);\n    col *= .98 + 0.08 * ss(1., fract(uv2.y) - 0.6);\n    \n    // Background nyan cat :)\n    vec3 tx = texture(iChannel1, vec2(-0.125,1) * uv + vec2(0.04*t,0)).rgb;\n    vec3 tx2 = texture(iChannel2, vec2(-0.125,1) * uv + vec2(0.04*t,0)).rgb;\n    col *= .8 + .2 *  mix(tx, tx2, .5 + .5 * cos(0.6 * iTime));\n  \n    // Jedi\n    draw(col, ouv, uv, t, bo, ax, ox, kx, o0, ay, oy, ky);\n    //draw(col, ouv, uv - vec2(0.2, 0), t, bo, ax, ox, kx, o0, ay, oy, ky);\n    //draw(col, ouv, uv + vec2(0.2,0), t+0.1*t, bo, ax, ox, kx, o0, ay, oy, ky);\n       \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// track: \n// https://soundcloud.com/koan-sound/intercept?si=f9d2ee4ead2f41c6ba601745efba4914\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 ms = iMouse.xy / res.y;\n    O = texelFetch(iChannel0, ivec2(px), 0);\n    \n    if (iFrame < 1)\n        O.x = 0.85;\n    \n    if (iMouse.z > 0.) \n        O.x = ms.x; // store mouse position for time rate\n    \n    // Music-synced running (messy but funny)\n    float v = texture(iChannel1, vec2(0.5, 0)).r;\n    //O.x = 0.2 + 4. * v;\n    \n    O.y += O.x / 60.; //iFrameRate;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33565, "src": "https://soundcloud.com/koan-sound/intercept?si=f9d2ee4ead2f41c6ba601745efba4914&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define res iResolution.xy\n#define pi 3.14159\n#define tanh2(a) ((exp2(a)-1.)/(exp2(a)+1.))\n#define thc(a,b) tanh2(a*cos(b))/tanh2(a)\n#define ths(a,b) tanh2(a*sin(b))/tanh2(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\n// iq's IK\nvec2 solve(vec2 p, float r1, float r2, float side) {\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + side * vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\nfloat seg( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Uneven capsule (unoptimised)\nfloat cap(vec2 uv, vec2 p, vec2 q, float r1, float r2)\n{\n    float h = length( p - q);\n    uv -= p;\n    float th = atan(q.y-p.y, q.x-p.x);\n    uv *= rot(-th + pi/2.);\n    uv.x = abs(uv.x);    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(uv,vec2(-b,a));\n    if( k < 0.0 ) return length(uv) - r1;\n    if( k > a*h ) return length(uv-vec2(0.0,h)) - r2;\n    return dot(uv, vec2(a,b) ) - r1;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 160, 191, 191, 257], [258, 258, 290, 290, 350], [351, 351, 406, 406, 469], [471, 495, 527, 527, 578], [580, 580, 639, 639, 705], [707, 707, 767, 767, 814], [816, 839, 897, 897, 954], [956, 956, 1111, 1123, 5187], [5189, 5189, 5231, 5231, 6591]]}
{"id": "clKSWm", "name": "more extreme psychedelic spiral", "author": "tungster24", "description": "an even more extreme version of the classic psychedelic spiral!", "tags": ["spiral", "psychedelic"], "likes": 5, "viewed": 150, "published": 3, "date": "1686139769", "time_retrieved": "2024-07-30T17:51:14.157023", "image_code": "/*\nextreme psychedelia by tungster24\n    -SUBSAMPLING should be kept between 1-8 for best effect\n    -MOTIONSTEPS should be kept between 10-20 for best effect (even lower\n     if SUBSAMPLING is high\n    -MOTIONBLUR should be kept between 1.0 and 3.0 for best effect.    \n    -added a BPM modifier if you wish to sync it to a song.\n\n*/\n#define SUBSAMPLING 1\n#define MOTIONSTEPS 10\n#define MOTIONBLUR 1.0\n#define BPM 200\n\nfloat theta(vec2 p) {return atan(p.y,p.x);}\nfloat dis(vec2 p) {return distance(vec2(0.0),p);}\nfloat wave(float x) {return min(mod(x,1.0)*2.0,mod(-x,1.0)*2.0);}\nvec4 preset(vec2 fragCoord,float timedisplacement)\n{\n    vec4 fragColor;\n    \n    vec2 uv = fragCoord/iResolution.xy-vec2(0.5,0.5);\n    uv*=2.0;\n    uv *= iResolution.xy/iResolution.yy;\n    \n    float ps = iTime+timedisplacement;\n    float s = 2.0*ps+2.0*sin(ps*6.2839*float(BPM)/60.0)/14.0/float(BPM)*60.0;\n    float t = theta(uv)/3.1415926, r = 1.0/pow(dis(uv),0.5);\n    \n    fragColor = vec4(0.0);\n    \n    fragColor.r = wave(r*5.0-t+2.0*s);\n    fragColor.g = wave(r*5.0*1.0/(pow(wave(t*3.0),2.0)/1.0+2.0)+t+s);\n    fragColor.b = wave(r*5.0*1.0/(pow(wave(t*3.0+1.5075),2.0)/1.0+2.0)+t+s);\n    \n    \n    //put this part in quotes to have a smooth spiral.\n    fragColor.r = round(wave(r*5.0-t+2.0*s));\n    fragColor.g = round(wave(r*5.0*1.0/(pow(wave(t*3.0),2.0)/1.0+2.0)+t+s*1.5))*0.8;\n    fragColor.b = round(wave(r*5.0*1.0/(pow(wave(t*3.0+1.5075),2.0)/1.0+2.0)+t-s*1.7));\n    \n    return fragColor;\n\n}\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    vec2 s[SUBSAMPLING*SUBSAMPLING];\n    for(int i = 0;i < SUBSAMPLING;i++) for(int j = 0;j < SUBSAMPLING;j++) {\n        s[SUBSAMPLING*i+j] = vec2(float(i)/float(SUBSAMPLING),float(j)/float(SUBSAMPLING));\n    }\n    float t[MOTIONSTEPS];\n    for(int i = 0;i < MOTIONSTEPS;i++) t[i] = MOTIONBLUR * iTimeDelta / float(MOTIONSTEPS) * float(i);\n    \n    C=vec4(0.0);\n    for(int i = 0;i < SUBSAMPLING*SUBSAMPLING;i++) for(int j = 0;j < MOTIONSTEPS;j++){\n        C+=preset(P+s[i],t[j])/float(SUBSAMPLING*SUBSAMPLING*MOTIONSTEPS);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[420, 420, 441, 441, 463], [464, 464, 483, 483, 513], [514, 514, 535, 535, 579], [580, 580, 632, 632, 1485], [1486, 1486, 1527, 1527, 2059]]}
{"id": "Dt3XWj", "name": "boykisser", "author": "Sunpy", "description": "Idea: https://www.youtube.com/watch?v=EQl4ODOsTMQ\nYes I am very aware that most of this code looks like someone fighting the machine and themselves for too long and that would be correct.\nIt should be possible to use the sound tab in place of soundcloud.", "tags": ["music", "meme", "boykisser"], "likes": 21, "viewed": 545, "published": 3, "date": "1686136505", "time_retrieved": "2024-07-30T17:51:15.113466", "image_code": "#define ETA 1.57078\n#define PI 3.14155\n#define TAU 6.2831\n\n#define SEED 0.12345679\n\nconst int ORDER_STEP[] = int[](1,0,1,2,2,2);\nconst int ORDER_SPIN[] = int[](-3,4,3,5);\n\nconst float TIME_STEP = 60./110.; // BPM is 110\nconst float TIME_SPIN = 60./110./2.;\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,\n                         vec2(6.8245,7.1248)))*\n        9.1283);\n}\n\nfloat particle(vec2 uv, float identifier, vec2 anchor, vec2 velocity, float creationTime, float time) {\n    float particleTime = max(0., time - creationTime);\n\n    float size = 1.-max(.9, particleTime); // max(0., 1. - particleTime) * .1; //.1 - (max(0.8,0.9) - .8) * 5. *.1;//max(0., clamp(particleTime, .01, .4));\n\n    vec2 velocityOffset = velocity * particleTime;\n    vec2 gravityOffset = vec2(0.,.4) * pow(particleTime, 1.798);\n    \n    vec2 point = anchor + velocityOffset + gravityOffset;\n    \n    float dist = distance(uv, point);\n    float hit = smoothstep(size, 0., dist);\n    \n    return hit;\n}\n\n#define C(c) U.x-=.5; v+= char(U,64+c)\nfloat char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).r;\n}\n\nmat2 rot(in float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nbool shouldDisplayError() {\n    return iChannelTime[1] < 0.001 && iTime > 2. && iTime < 45.;\n}\n\nfloat displayError(vec2 uv) {\n    vec2 U = (uv - vec2(-1.3, .6))*64.0/6.;\n    float v = 0.;\n    C(6);C(37);C(52);C(35);C(40);C(41);C(46);C(39);C(-32);C(33);C(53);C(36);C(41);C(47);C(-32);C(38);C(50);C(47);C(45);C(-32);C(51);C(47);C(53);C(46);C(36);C(35);C(44);C(47);C(53);C(36);C(-32);C(41);C(51);C(-32);C(52);C(33);C(43);C(41);C(46);C(39);C(-32);C(41);C(52);C(51);C(-32);C(52);C(41);C(45);C(37);C(-18);C(-18);C(-18);\n    \n    U = (uv - vec2(-.4, -.6))*64.0/6.;\n    C(16);C(44);C(37);C(33);C(51);C(37);C(-32);C(55);C(33);C(41);C(52);C(-32);C(-6);C(-23);\n    \n    for (float t = 0.; t < 1.; t+=.1) {\n        v += step(distance(uv * rot((iTime + t) * TAU * 1.1 + cos((iTime + t) * PI)), vec2(.16)), .02);\n    }\n    \n    return v;\n}\n\nfloat img(sampler2D channel, vec2 pos, int index)\n{\n    ivec2 coord = ivec2(max(min(pos, vec2(1.)), vec2(0.)) * 200.);\n    coord.x += (index / 3) * 255;\n    vec3 t = texelFetch(channel, coord, 0).rgb;\n    \n    return t[index % 3];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0.);\n    \n    if (shouldDisplayError()) {\n        fragColor = vec4(vec3(displayError(uv)), 1.0);\n        return;\n    }\n    \n    float time = max(.001, iChannelTime[1]); // .001 to fix visual error caused by negative time?\n    // loop\n    time = mod(time, 88.*TIME_STEP);\n    \n    int index = -1;\n    float flip = sign(sin(time * PI / TIME_STEP));\n\n    float order_progress = fract(time / TIME_STEP); //mod(time, TIME_STEP) / TIME_STEP;\n    index = ORDER_STEP[int(order_progress * float(ORDER_STEP.length()))];\n    \n    if (time < 8.*TIME_STEP) {\n        index = 5;\n        flip = 1.;\n    }\n    if (time < 7.*TIME_STEP)\n        index = -1;\n    \n    uv *= .8;\n    uv.y += .238;\n\n    if (time > 30.*TIME_STEP) {\n    \n        if (time > 30.3*TIME_STEP) {\n            float zoom_progress = sin((min(time,31.3*TIME_STEP)-30.3*TIME_STEP) * PI);\n            //uv.y -= .238 * zoom_progress;\n            uv /= mix(1., .6, zoom_progress);\n        }\n    \n        if (time < 31.*TIME_STEP) {\n            index = 2;\n            flip = -1.;\n        } else if (time < 32.*TIME_STEP) {\n            order_progress = fract(time / TIME_SPIN);\n            index = ORDER_SPIN[int(order_progress * float(ORDER_SPIN.length()))];\n            flip = -1. * float(sign(index));\n            index *= sign(index);\n        }\n    }\n    \n    if (time > 55.*TIME_STEP) {\n        if (time < 56.*TIME_STEP) {\n            index = 2;\n            flip = 1.;\n        } else if(time < 63.*TIME_STEP) {\n            index = 5;\n            flip = 1.;\n        } else if(time < 64.*TIME_STEP) {\n            order_progress = fract(time / TIME_SPIN);\n            index = ORDER_SPIN[int(order_progress * float(ORDER_SPIN.length()))];\n            flip = -1. * float(sign(index));\n            index *= sign(index);\n        }\n        \n        // zoom\n        float zoom_progress = clamp(floor((time-54.15*TIME_STEP)) / 4., 0., 1.);\n        \n        if (time > 64.*TIME_STEP) {\n            zoom_progress = max(0., 65.*TIME_STEP-time);\n        }\n        \n        uv /= mix(1., 1.7, zoom_progress);\n    }\n    \n    if (index >= 0) {\n        col += img(iChannel0, vec2(flip, 1.) * uv / 2. + vec2(.5), index);\n        \n        if (time < 32.*TIME_STEP) {\n            index = 2;\n            flip = -1.;\n        }\n        \n        if (time > 31.*TIME_STEP) {\n            col += img(iChannel0, vec2(flip, 1.) * uv / 2. + vec2(.5) + vec2(.8, -.1), index);\n            col += img(iChannel0, vec2(flip, 1.) * uv / 2. + vec2(.5) + vec2(-.8, -.1), index);\n        }\n    }\n    \n    // summon the demons\n    if (time > 65.*TIME_STEP) {\n        // first beat\n        if (time < 67.*TIME_STEP)\n            col += max(0., cos((time - 65.*TIME_STEP) * 3.));\n        \n        if (time > 67.*TIME_STEP) { // particles\n            //col += 1.;\n            for (float i = 0.0; i < 16.; i++) {\n                float seed = SEED + floor(i / 16. + time / 2.);\n                vec2 anchor = vec2(rand(vec2(seed, i)) * 4. - 2., -1.);\n                vec2 velocity = vec2(mix(-.5, .5, rand(vec2(seed+.1, i))), mix(1., 2., rand(vec2(i, seed))));\n\n                float creationTime = time - fract(i / 16. + time / 2.);\n                if (creationTime < 67.*TIME_STEP) {\n                    continue;\n                }\n\n                col.r += particle(uv, 0., anchor, velocity, creationTime, time);\n            }\n        }\n    \n        col.r += max(0., -uv.y - fract(time / TIME_STEP / 2. + TIME_STEP));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33560, "src": "https://soundcloud.com/super-346844965/the-penis-eek", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "const int img0[] = int[](2778205984,26607914,194053526,35327629,35197037,68358509,309068289,308808722,308678417,50401808,403641438,386864221,403510622,420287837,436999773,453711452,453711707,470423387,470488922,487200602,487200857,487200857,470423641,470488922,453711961,437000026,437000027,420222811,420288347,403576411,386864732,357696009,50927119,353244754,117572362,373752065,403248398,353244734,389749513,537400334,336467767,372647173,704779278,336402228,405941250,771888140,336336944,405680130,822219788,336140846,151136002,319363629,50472707,455804418,654578184,875234314,34285572,755184683,771896628,788673843,822228274,839005233,855782448,889336879,906114093,705167916,641218562,103561218,956441608,570822183,304429570,973218052,520426277,371407618,1023548676,436475938,421674243,1006901253,402921763,874724101,841169416,807613456,790900502,757410586,707143966,184952354,606349590,17699076,589702916,51057923,556344324,34281474,539697668,67246850,537133826,453123885,67306498,523050755,84091138,523181315,100803073,506469379,84091393,271718916,553782273,419694083,184749619,84744195,238294788,352652035,386074126,168037685,285414407,221648131,285870596,335745539,16911414,219089410,369168643,151391031,654510866,151391031,654510357,134679095,755172889,117901872,738395164,117901873,704840478,117901619,671351327,101189685,688063262,101189685,704905502,84543285,104213537,773850378,67831093,70529312,740164364,70451973,706544396,34341950,553781277,34341950,369167655,17695292,402918693,187695673,403112961,187564599,50463236,134682883,204276007,688063496,33688659,704710148,67243345,1196503298,1229932623,1229932878,1263422030,369243468,100732747,386145537,470355529,239605765,386341896,486740552,273160199,419961605,436604999,84217864,134284871,252189190,71762697,16910082,252123653,117572691,252123656,117572436,151129864,55775239,235341571,268896770,117637716,151195143,55840775,218629890,285542915,117638227,167906823,89264645,235341570,318966275,100861266,184749575,106042114,268829955,352454915,100861521,100929797,122754562,285476355,122754827,335676932,156243976,906101254,923273807,939724367,1246710095,1246644814,1263422030,1263356749,838997837,419828557,290264324,352590088,520425037,189535238,302522630,587402060,172757258,252519171,268765772,235867905,235211596,185863171,84413772,152440070,202444365,273483545,102501135,168824652,223085344,208734737,175245585,158533651,108332565,59966743,406);\nconst int img1[] = int[](2761494304,160695082,227347599,35196300,51842673,152571505,236326761,253038438,269815654,286462053,286462053,286462053,303173733,303173733,303173733,319885413,319885413,319885413,303108197,319819878,319819878,319819878,319819878,336531558,336531558,319754342,336466023,336466023,336466023,336466023,353177703,336466022,336466023,336466023,336466533,353179488,353179233,406720786,420288010,369825595,372972810,487003659,369890367,469893633,403182914,453116418,419894595,373497602,436404481,356655362,402718980,389883394,704780548,738342965,704908337,170798594,822224394,33818669,855778311,151127596,872555013,184681772,906108677,218235948,939662852,235078187,939662596,251855148,956439556,268566828,973216516,453185838,304954369,1006705155,419631917,304954625,1023547395,318964009,1040324355,302187048,1057101571,318964263,1073878275,318964519,1073878019,318899239,1023808260,318964264,1023939075,35259401,285414403,168246281,318964502,1024134915,68422917,251794179,268712717,570623505,302266895,553781007,889258260,118232323,807084035,134944259,807149059,151656451,773856513,134748419,740432644,16914947,436406532,503589158,419629570,486876713,386075394,470164779,369298179,436740909,352520963,302523183,335743245,269099568,335742735,235675953,117704963,322048771,219024385,117639427,288560385,219089667,288565251,185666052,255141635,169019909,238429699,152373510,67249411,134680112,587400984,221381378,85592072,33694212,118033460,604177947,118033461,587400476,118098487,16908571,171320070,623183370,84674869,154413856,807208204,84674611,50735643,84739890,17506848,68028210,104734245,522454030,87425287,237175567,87757826,86180368,369427714,34604344,33883936,33626119,34604338,16910621,33751299,151264003,34669350,50465817,671220996,34669350,117641497,36120321,471335186,36054787,504824082,36120321,1192624402,17957160,20727318,20727573,20727828,860899603,357569538,302324737,470290000,223286021,369499144,487001420,206312967,486801921,239802119,268901382,223085061,252123911,117507157,167841799,55906055,16909827,167841796,39259655,235406851,235342338,84083543,151195144,56037126,235341315,268830979,100795223,151195399,56037381,252118275,16910595,139661314,252052994,302123524,84084818,151261190,122884866,302319106,352454403,100861778,67310340,139597315,318965251,139597577,352454147,156310022,173094409,1229993991,1246710352,1246710351,1263422287,1280199502,855775053,402986061,290265601,402921989,470485325,139204358,369630729,570755148,155980810,319561478,218434636,286199042,134680140,236064258,252514636,290196500,169217294,202313805,256706330,225381391,191957777,158468626,141756692,91686166,1046);\nconst int img2[] = int[](2726694694,176031271,192613244,226036859,242749049,257491740,240650264,167838227,236129880,252841815,252841814,269553749,286265430,286265429,286265429,286265429,286265429,302977109,286199893,286134614,286134614,302846294,302846294,302846294,289867528,251990030,286069059,289934084,285345030,289934594,302123010,306580994,302123010,289607938,302123011,306058754,302123010,322639874,302123010,322444034,302123010,322313474,318899970,455941634,318899970,455876354,318899715,455745794,335676675,438968834,335676930,438838274,335676930,422126594,335741700,421996034,654448136,16849191,671290884,688010789,704789025,721566495,721567259,721566749,738343455,738342689,755119650,755119139,788673315,788670254,788669234,537332259,270544899,822222086,403117087,387854595,838997766,386079262,454898434,839128323,352459550,84027909,638202142,807339266,67313935,471150367,757072899,67246107,739640072,67375903,688918020,67374884,688591875,50662949,33822722,220669444,50462978,50534658,204023044,436339205,570688515,33884971,100801537,153952260,620823045,137240069,637600006,120593413,654442758,103881476,687997190,87038724,503578886,436472065,386729009,319031559,269484600,285412108,185860665,402854406,135725363,436409859,119079216,402855427,352585037,72358145,72429315,72559875,55978755,39331844,22554883,777595906,861155671,743584850,726598916,50790658,570493006,190915684,324343813,274012168,84083714,273683715,33752322,34083591,34021947,100995333,100934458,574299139,469895426,469904699,1245465148,1228753213,423512381,335613962,252320062,339612675,252248833,339416325,352786691,419632441,339023623,319363078,355664641,386203905,138153481,386402818,154930441,386468098,171707401,201918722,201918977,151128891,167840777,201523461,134415681,184683273,218235395,134349636,167971593,54726151,17106946,184748803,71437830,201918211,251988483,134350401,184749064,104861700,235341571,285346563,134415936,235012355,285346308,184748095,134483714,138285826,285346307,335807237,134416702,352981762,84085310,402986499,873073214,923143230,1228753213,1228753213,1228753469,771824189,755308349,369758781,272438785,352459782,520359485,205329668,335815171,604113725,188551941,285810947,285543229,252447490,218500413,219089666,117902910,185731589,34213438,152373511,152243518,205456665,52234004,101976640,85264738,51840867,35128678,25428611);\nconst int img3[] = int[](2693075492,192873504,241107225,257493524,274140434,290787089,290787343,307499279,307433998,324211214,324145933,307434253,307434253,67245069,336400972,306841090,84022540,322766599,402789388,336335672,322247426,469964043,336335667,321986051,520230156,336335409,305013251,587339020,352981805,321659907,620893451,369759019,321529346,671225098,352981801,321399042,704779530,352981799,338045698,738333961,352916517,321268738,755111177,352916261,321138178,771888393,336139044,321138434,805442569,336139043,321007874,822220040,386273827,790835458,790835458,790770178,790770178,790770178,773993218,773993218,773993218,773993218,50408963,268709410,50468358,84422178,50467855,303967778,773980675,33755168,237186338,757203459,17042724,16843299,203760389,523239684,17042214,67174693,187047175,453250088,237439528,153688325,386207783,304547882,120264196,335811623,321455404,86774533,318969129,355075372,70127875,285349163,19333935,53422083,654508583,52953392,19997955,620889128,604177498,570688858,537134427,102302273,155066116,503580437,135335485,322706692,486738444,201791547,440212227,436407556,235084605,742266884,775885830,759239429,289543171,335614474,638259012,755174983,33620232,939724092,906169407,872614466,822347847,755369547,738460752,755237203,106180694,89271041,22031363,620889863,621086549,67240523,621216771,17107272,486736643,172360709,84214018,256711938,520292099,553785930,570563144,1061568326,1212154881,205408061,302064898,487132223,188747779,251797257,386337601,201524740,386076227,201524741,352652356,184681991,100860485,101127685,21302018,352781827,218236423,100860227,335806722,268568072,319292996,318899720,100794686,101192456,20780034,319292930,385943048,100860219,101126919,37426946,319227394,167904775,37553924,319227139,167970310,84017992,67308807,167970564,50528835,235275523,151061762,54464002,84018434,251792902,171904514,251986947,268569859,67308350,168038148,188616963,50397443,302977282,352783422,238884107,386210053,1211975741,1228687677,1245399356,423316027,389754881,372977922,356135427,339358467,322581762,305804802,289027842,272250882,255473667,436346371,17108538,419764225,168234810,402984193,202314298,289019400,336464143,135270458,238752273,286459665,101911611,188420117,236455188,68487484,104664091,153027350,35128382,58853154);\nconst int img4[] = int[](2809925415,192087836,258870640,292229484,325653099,322961704,339544865,339415069,339350554,339285529,322573849,339285784,339285784,322639639,339351319,322639894,339417110,339482389,339482644,339482644,339548179,356259859,339613714,339613714,339613714,339679249,118097681,51320127,118953301,356974849,356455954,356261134,355935244,339028233,33630473,721884211,721818678,755504183,872879155,33821741,321468417,304561668,287588613,270681603,270682114,253774338,253644034,236932354,236932354,220089858,220024834,219959299,236671235,236671234,236671234,219959554,236671234,236605954,101142787,1359154957,235670275,235032835,1342377738,269029122,285363971,1275400455,285676034,923469830,319099906,318976540,168367621,335752969,772222212,738464515,721814274,721622020,704972034,704779269,671353090,721490694,654576130,201473543,990455299,604245506,268581385,957030916,369430530,923535618,336072450,906758404,336203266,856623107,302976002,839911172,286460162,823199492,269813762,789710341,253167618,789710341,236455938,772998406,33882370,67570969,16919573,67570721,84028182,50793246,169620759,907477512,34081052,136132119,873922825,841090848,807601953,790890019,774112293,790823719,824247079,857735720,910636360,33891665,593044304,654442838,822544447,906038076,1127891770,1245005625,1345277491,1328304172,1311591982,1328369452,1328303916,1345081388,1260999211,1277625604,1327891206,1194609204,1211385399,1194674228,1228097589,1244875059,1261521713,1261521713,1261521969,1261521713,1261521713,1261521713,439438129,372321795,321990151,67181063,288493825,33692932,254939140,252321539,520293938,238161420,134418948,254938382,134418436,271715089,117771269,254937364,17171976,118949378,102174258,204604953,68945177,68946226,120717855,72615197,22348831,41485090,24773241);\nconst int img5[] = int[](2759397415,16843804,241961585,292098154,308810088,308744807,322570532,322571296,322572062,322572571,339219481,339220246,402720779,554308666,251925306,305797121,419499780,302121271,402787589,352453940,402787586,16843522,352453933,419564546,103156482,184685826,268572675,352454433,419564290,152900098,167908610,352459266,352454938,419563779,169350914,134354434,419568130,352520981,419563522,202578690,117576963,486676994,352455698,419563011,202513922,100865282,537008386,369233167,436339970,219029762,84022786,587340034,369233165,436339714,218899458,67245570,620894466,369233164,419562498,218834434,67245570,654448898,369233162,419561987,218704130,33691394,704715010,386010377,402784770,201992706,33691394,704780290,386010122,419561730,201992706,16914178,721557506,386010122,721557509,386010122,721558274,369298187,738335234,839060235,168569858,755118339,822282509,151923970,755118338,805439248,50472963,805438738,33761283,805437973,33760518,805438228,17045523,788661012,17043994,236859161,790167812,790498336,773720610,67701028,119942673,755763976,235276071,69807370,755372295,319226667,53160965,721687304,336069165,19802883,704779528,1092947206,1076040706,1042421250,1025644546,1008867586,992090370,1445075459,1394955556,1328107815,1227770668,1110787377,960314936,843396672,67250759,738264130,961098056,893662786,776613704,793390666,860368969,721553733,604309314,54592516,726803719,927138310,369624115,419694083,369232177,403047429,523108866,16974338,553845251,33693481,570623237,100869159,740827651,757604867,1344807681,1311460906,688136235,587865900,604512301,671359276,369374763,486610984,201459718,419764517,218302215,386341155,235014152,386341664,251791368,151129633,134747911,170723074,369625346,84019208,151127858,134747656,33686786,134416429,118035976,153881090,369625090,184681993,134351148,101193480,153881346,386402051,201459207,117574188,83955976,201459207,117639724,100863751,218236676,117574444,100864007,235014145,100863019,218370055,220925698,302319362,285411844,117640490,84153603,237638149,386008579,237638667,436339716,254416646,287979528,1328167173,1328172842,1328238123,1328172842,522866474,489303554,472526340,352393731,402922026,388633605,335943941,419763243,288035593,167842053,271257867,151130118,237703181,134417674,204148495,117770254,170593555,202639133,85854252,103549209,119211295,69207341,53347359,22151969,41353763,374);\n\n#define img img0\n\n// Yea.. I couldnt find out how to pass dynamic arrays so im just copy pasting to force the compiler >.>\nfloat sampleImg0(ivec2 texelCoord, ivec2 offset) {\n    int width = (img[0] >> (2<<3)) & 0xFF;\n    \n    texelCoord -= ivec2((img[0] >> (0<<3)) & 0xFF, (img[0] >> (1<<3)) & 0xFF) + offset;\n    \n    if (texelCoord.x <= 0 || texelCoord.x > width) {\n        return 0.;\n    }\n    \n    int index = texelCoord.y * width + texelCoord.x;\n    for (int ii = 1; ii < img.length(); ii++) {\n        for (int i = 0; i < 4; i++) {\n            index -= (img[ii] >> (i<<3)) & 0xFF;\n            if (index < 0) {\n                return float(i % 2);\n            }\n        }\n    }\n    \n    return 0.;\n}\n\n#undef img\n#define img img1\n\nfloat sampleImg1(ivec2 texelCoord, ivec2 offset) {\n    int width = (img[0] >> (2<<3)) & 0xFF;\n    \n    texelCoord -= ivec2((img[0] >> (0<<3)) & 0xFF, (img[0] >> (1<<3)) & 0xFF) + offset;\n    \n    if (texelCoord.x <= 0 || texelCoord.x > width) {\n        return 0.;\n    }\n    \n    int index = texelCoord.y * width + texelCoord.x;\n    for (int ii = 1; ii < img.length(); ii++) {\n        for (int i = 0; i < 4; i++) {\n            index -= (img[ii] >> (i<<3)) & 0xFF;\n            if (index < 0) {\n                return float(i % 2);\n            }\n        }\n    }\n    \n    return 0.;\n}\n\n#undef img\n#define img img2\n\nfloat sampleImg2(ivec2 texelCoord, ivec2 offset) {\n    int width = (img[0] >> (2<<3)) & 0xFF;\n    \n    texelCoord -= ivec2((img[0] >> (0<<3)) & 0xFF, (img[0] >> (1<<3)) & 0xFF) + offset;\n    \n    if (texelCoord.x <= 0 || texelCoord.x > width) {\n        return 0.;\n    }\n    \n    int index = texelCoord.y * width + texelCoord.x;\n    for (int ii = 1; ii < img.length(); ii++) {\n        for (int i = 0; i < 4; i++) {\n            index -= (img[ii] >> (i<<3)) & 0xFF;\n            if (index < 0) {\n                return float(i % 2);\n            }\n        }\n    }\n    \n    return 0.;\n}\n\n#undef img\n#define img img3\n\nfloat sampleImg3(ivec2 texelCoord, ivec2 offset) {\n    int width = (img[0] >> (2<<3)) & 0xFF;\n    \n    texelCoord -= ivec2((img[0] >> (0<<3)) & 0xFF, (img[0] >> (1<<3)) & 0xFF) + offset;\n    \n    if (texelCoord.x <= 0 || texelCoord.x > width) {\n        return 0.;\n    }\n    \n    int index = texelCoord.y * width + texelCoord.x;\n    for (int ii = 1; ii < img.length(); ii++) {\n        for (int i = 0; i < 4; i++) {\n            index -= (img[ii] >> (i<<3)) & 0xFF;\n            if (index < 0) {\n                return float(i % 2);\n            }\n        }\n    }\n    \n    return 0.;\n}\n\n#undef img\n#define img img4\n\nfloat sampleImg4(ivec2 texelCoord, ivec2 offset) {\n    int width = (img[0] >> (2<<3)) & 0xFF;\n    \n    texelCoord -= ivec2((img[0] >> (0<<3)) & 0xFF, (img[0] >> (1<<3)) & 0xFF) + offset;\n    \n    if (texelCoord.x <= 0 || texelCoord.x > width) {\n        return 0.;\n    }\n    \n    int index = texelCoord.y * width + texelCoord.x;\n    for (int ii = 1; ii < img.length(); ii++) {\n        for (int i = 0; i < 4; i++) {\n            index -= (img[ii] >> (i<<3)) & 0xFF;\n            if (index < 0) {\n                return float(i % 2);\n            }\n        }\n    }\n    \n    return 0.;\n}\n\n#undef img\n#define img img5\n\nfloat sampleImg5(ivec2 texelCoord, ivec2 offset) {\n    int width = (img[0] >> (2<<3)) & 0xFF;\n    \n    texelCoord -= ivec2((img[0] >> (0<<3)) & 0xFF, (img[0] >> (1<<3)) & 0xFF) + offset;\n    \n    if (texelCoord.x <= 0 || texelCoord.x > width) {\n        return 0.;\n    }\n    \n    int index = texelCoord.y * width + texelCoord.x;\n    for (int ii = 1; ii < img.length(); ii++) {\n        for (int i = 0; i < 4; i++) {\n            index -= (img[ii] >> (i<<3)) & 0xFF;\n            if (index < 0) {\n                return float(i % 2);\n            }\n        }\n    }\n    \n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 texelCoord = ivec2(fragCoord);\n    \n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if (iFrame == 0) { // cache\n        col.r += sampleImg0(texelCoord, ivec2(0));\n        col.g += sampleImg1(texelCoord, ivec2(0));\n        col.b += sampleImg2(texelCoord, ivec2(0));\n\n        col.r += sampleImg3(texelCoord, ivec2(255, 0));\n        col.g += sampleImg4(texelCoord, ivec2(255, 0));\n        col.b += sampleImg5(texelCoord, ivec2(255, 0));\n        \n        col = min(max(col, vec4(0.)), vec4(1.));\n    }\n    \n    fragColor = col;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3XWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 279, 279, 377], [379, 379, 482, 482, 984], [1025, 1025, 1053, 1053, 1212], [1214, 1214, 1235, 1235, 1301], [1303, 1303, 1330, 1330, 1397], [1399, 1399, 1428, 1428, 2128], [2130, 2130, 2181, 2181, 2362], [2364, 2364, 2421, 2421, 5994]]}
{"id": "mlyXWw", "name": "Spiral rainbow", "author": "ivana888kitsune", "description": "rainbow spiral for wealth", "tags": ["spiralcolorful"], "likes": 2, "viewed": 165, "published": 3, "date": "1686130597", "time_retrieved": "2024-07-30T17:51:15.870443", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Parametry spiralnego efektu\n    float speed = 0.5;       // Prdko obrotu spirali\n    float frequency = 5.0;   // Czstotliwo zmiany kolorw\n    float amplitude = 0.3;   // Amplituda zmiany kolorw\n\n    // Normalizacja wsprzdnych pikseli do zakresu od -1 do 1\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Oblicz kt dla kadego piksela\n    float angle = atan(uv.y, uv.x);\n\n    // Oblicz promie dla kadego piksela\n    float radius = length(uv);\n\n    // Oblicz przesunicie czasowe dla efektu animacji\n    float timeOffset = iTime * speed;\n\n    // Oblicz zmian kolorw na podstawie kta, promienia i czasu\n    vec3 color = vec3(\n        0.5 + 0.5 * sin(angle * frequency + timeOffset),\n        0.5 + 0.5 * sin(radius * frequency + timeOffset),\n        0.5 + 0.5 * sin((angle + radius) * frequency + timeOffset)\n    );\n\n    // Dodaj efekt zmiany kolorw do fragColor\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlyXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 90, 1021]]}
{"id": "DtGXDw", "name": "Trippy neon patterns", "author": "charlieamer", "description": "Trippy fractal patterns.", "tags": ["2d", "fractal", "patterns", "trippy", "screensaver", "neon"], "likes": 7, "viewed": 281, "published": 3, "date": "1686124319", "time_retrieved": "2024-07-30T17:51:16.637391", "image_code": "vec3 palette( float t )\n{\n    vec3 a = vec3(0.878, 0.268, 0.658);\n    vec3 b = vec3(0.916, 0.609, 0.456);\n    vec3 c = vec3(0.497, 0.497, 0.379);\n    vec3 d = vec3(2.406, 2.346, 0.036);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv *= 2.0f;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 t = vec3(0.0f);\n    \n    for (float i=1.0f; i<=3.0f; i++) {\n        uv = vec2(fract(uv));\n        uv -= 0.5f;\n        uv *= -0.5f + (length(uv0) + sin(iTime * 0.7) + cos(iTime * 0.56) + 0.5f);\n        vec3 color = palette(length(uv * i * 0.3) + length(uv0) + iTime * 0.3f + i*0.4f);\n        float d = abs(sin(length(uv * i * 0.7) * i + length(uv0) * 0.3f + iTime * 0.5f));\n        d = pow(0.2 / d, 1.2f);\n        d *= smoothstep(0.9f, 3.0f, i);\n        d *= smoothstep(1.0f, 2.0f, 2.0f - length(uv0));\n        t += color * d;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(t), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 228], [230, 230, 287, 337, 1080]]}
{"id": "DtGXWw", "name": "patterns triangle", "author": "yufengjie", "description": "", "tags": ["patterns"], "likes": 3, "viewed": 144, "published": 3, "date": "1686122260", "time_retrieved": "2024-07-30T17:51:17.404341", "image_code": "#define PI 3.14159265358979323846\n\n\nfloat genCorner(vec2 D, vec2 st) {\n  vec2 halfS = smoothstep(D - vec2(0.01), D, st);\n  vec2 halfE = smoothstep(D, D + vec2(0.01), st);\n  vec2 c = halfS - halfE;\n  return c.x + c.y;\n}\n\nfloat genBound(vec2 st) {\n  float lb = genCorner(vec2(0.0), st);\n  float rt = genCorner(vec2(1.0), st);\n  return lb + rt;\n}\n\nvoid tile(inout vec2 st, float zoom) {\n  st *= zoom;\n  st = fract(st);\n}\n\n// \nfloat triangle(vec2 st) {\n  float z1 = 1.0 - smoothstep(st.x - 0.01, st.x, st.y);\n  float z2 = smoothstep(0.0, 0.01, st.y);\n  float z3 = 1.0 - smoothstep(1.0 - 0.01, 1.0, st.x);\n  return z1 * z2 * z3;\n}\n\nvoid rotate2D(inout vec2 st, float angle) {\n  st -= 0.5;\n  st = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * st;\n  st += 0.5;\n}\n\nvoid rotateTilePattern(inout vec2 st) {\n  st *= 2.0;\n  float index = 0.0;\n  index += step(1.0, mod(st.x, 2.0));\n  index += step(1.0, mod(st.y, 2.0)) == 1.0 ? 2.0 : 0.0; // 2\n\n  if(index == 0.0) {\n    // rotate2D(st, PI / 180.0 * 90.0);\n  } else if(index == 1.0) {\n    rotate2D(st, PI / 180.0 * 90.0);\n  } else if(index == 2.0) {\n    rotate2D(st, PI / 180.0 * 270.0);\n  } else if(index == 3.0) {\n    rotate2D(st, PI / 180.0 * 180.0);\n  }\n\n  st = fract(st);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy / iResolution.xx;\n  vec3 color = vec3(0.0);\n  \n  tile(st, 8.0);\n  \n\n  rotateTilePattern(st);\n\n  rotate2D(st, 10.0 * sin(iTime ));\n  \n  \n // float b = genBound(st);\n // color += vec3(b);\n\n  float t = triangle(st);\n  color += vec3(t);\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 70, 70, 218], [220, 220, 245, 245, 343], [345, 345, 383, 383, 417], [419, 471, 496, 496, 673], [675, 675, 718, 718, 813], [815, 815, 854, 854, 1296], [1300, 1300, 1357, 1357, 1650]]}
{"id": "DlySWw", "name": "", "author": "yufengjie", "description": "", "tags": ["patterns"], "likes": 0, "viewed": 114, "published": 3, "date": "1686122072", "time_retrieved": "2024-07-30T17:51:18.168299", "image_code": "\n#define PI 3.14159265359\n\nvoid tile(inout vec2 st, float n) {\n  st *= n;\n  st = fract(st);\n}\n\nvoid rotate2D(inout vec2 _st, float _angle) {\n  _st -= 0.5;\n  _st = mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle)) * _st;\n  _st += 0.5;\n}\n\nfloat SMOOTH(float D, float d) {\n  return smoothstep(D - 0.01, D + 0.01, d);\n}\n\nfloat box(vec2 size, vec2 st) {\n  float t = 0.0 + size.y / 2.0;\n  float b = 0.0 - size.y / 2.0;\n  float l = 0.0 - size.x / 2.0;\n  float r = 0.0 + size.x / 2.0;\n\n  float h = SMOOTH(b, st.y) - SMOOTH(t, st.y);\n  float w = SMOOTH(l, st.x) - SMOOTH(r, st.x);\n  return h * w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy / iResolution.xx;\n  vec3 color = vec3(0.0);\n\n  bool isRotate = false;\n\n  tile(st, 4.0);\n\n  if (isRotate) {\n    rotate2D(st, sin(iTime));\n  } else {\n    rotate2D(st, PI / 180.0 * -45.0);\n  }\n  st -= vec2(0.5);\n\n  float b = box(vec2(0.2) * (abs(cos(iTime))) + vec2(0.2), st);\n  vec3 bColor = vec3(0.61f, 0.04f, 0.04f);\n  color += b * bColor;\n  // st += vec2(0.5);\n\n\n  float lW = abs(sin(iTime)) * 0.1 + 0.05;\n  float l1 = SMOOTH(0.0 - lW / 2.0, st.x) - SMOOTH(lW / 2.0, st.x);\n  float l2 = SMOOTH(0.0 - lW / 2.0, st.y) - SMOOTH(lW / 2.0, st.y);\n  float l3 = SMOOTH(1.0 - lW / 2.0, st.x) - SMOOTH(1.0 + lW / 2.0, st.x);\n  float l4 = SMOOTH(1.0 - lW / 2.0, st.y) - SMOOTH(1.0 + lW / 2.0, st.y);\n  vec3 lineColor = vec3(0.84f, 0.51f, 0.07f);\n  color += (l1 + l2 +l3 + l4 ) * lineColor;\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlySWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 62, 62, 93], [95, 95, 140, 140, 243], [245, 245, 277, 277, 323], [325, 325, 356, 356, 597], [599, 599, 656, 656, 1497]]}
{"id": "clGXRW", "name": "Cell_Mix", "author": "KTSAMA", "description": "Cell,SDF", "tags": ["sdf", "learning", "cell"], "likes": 0, "viewed": 30, "published": 3, "date": "1686111544", "time_retrieved": "2024-07-30T17:51:19.109781", "image_code": "#define ZERO (min(iFrame,0))\n#define PI 3.1415926\n#define _BackGroundIntensity 0.8\n#define _LightDir normalize( vec3(0.1, 0.8, 0.1) )\n//#define _ColorSphere_CellSide1 vec4(0.74,0.77,0.79,0.92)\n//#define _ColorSphere_CellSide2 vec4(0.74,0.77,0.79,0.92)\n#define _ColorSphere_CellSide1 vec4(0.8,0.2,0.2,0.8)\n#define _ColorSphere_CellSide2 vec4(0.2,0.2,0.8,0.8)\n\n#define _ColorSphere_CellInSide1 vec4(0.11,0.15,0.25,1.0)\n#define _ColorSphere_CellInSide2 vec4(0.11,0.15,0.25,1.0)\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n vec3 mod2D289( vec3 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n  vec4 mod2D289( vec4 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n  vec3 permute( vec3 x ) { return mod2D289( ( ( x * 34.0 ) + 1.0 ) * x ); }\n            vec4 permute( vec4 x ) { return mod2D289( ( ( x * 34.0 ) + 1.0 ) * x ); }\n            //3DNoise\n            float noise3D(vec3 p)\n            {\n                vec3 a = floor(p);\n                vec3 d = p - a;\n                d = d * d * (3.0 - 2.0 * d);\n\n                vec4 b = vec4( a.x, a.x, a.y, a.y ) + vec4( 0.0, 1.0, 0.0, 1.0 );\n                vec4 k1 = permute( b.xyxy );\n                vec4 k2 = permute( k1.xyxy + b.zzww );\n\n                vec4 c = k2 + a.zzzz;\n                vec4 k3 = permute( c );\n                vec4 k4 = permute( c + 1.0 );\n\n                vec4 o1 = fract( k3 * ( 1.0 / 41.0 ) );\n                vec4 o2 = fract( k4 * ( 1.0 / 41.0 ) );\n\n                vec4 o3 = o2 * d.z + o1 * ( 1.0 - d.z );\n                vec2 o4 = o3.yw * d.x + o3.xz * ( 1.0 - d.x );\n\n                return o4.y * d.y + o4.x * ( 1.0 - d.y );\n            }\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n// Union\nfloat opU(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n// Union\nvec4 opU4(vec4 d1, vec4 d2)\n{\n\treturn d1.w<d2.w?d1:d2;\n}\n// SMOOTH BOOLEAN OPERATORS\n\nvec4 opUS4( vec4 d1, vec4 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n vec3 color = mix(d2.rgb, d1.rgb, h);\n    float dist = mix( d2.w, d1.w, h ) - k*h*(1.0-h); \n return vec4(color,dist);\n}\nvec4 opUS4(vec4 d1_col, vec4 d2_col,float d1,float d2,float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    vec3 color = mix(d2_col.rgb, d1_col.rgb, h);\n    float dist = mix(d2, d1, h) - k * h * (1.0 - h);\n    return vec4(color, dist);\n}\n\nfloat opUS( float d1, float d2,float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float dist = mix( d2, d1, h ) - k*h*(1.0-h); \n return dist;\n}\nvec2 opUS( float d1, float d2,float d1_num,float d2_num ,float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    vec2 dist=vec2(0.0,0.0);\n    dist.x = mix( d2, d1, h ) - k*h*(1.0-h); \n    dist.y=mix(d1_num,d2_num,h);\n return dist;\n}\n\nfloat opSS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opIS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res1 = vec2( pos.y, 0.0 );\n    vec2 res2 = vec2( pos.y, 1.0 );\n     res1.x =sdSphere(pos-vec3(cos(iTime+PI/2.0),0.0,0.0), 0.5);\n       \n     res2.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0), 0.5);\n       \n       vec2 result1=opUS(res1.x, res2.x,res1.y,res2.y,0.45);\n    return result1;\n}\n\nvec2 mapInside( in vec3 pos )\n{\n float noiseScale=10.0;\n   vec2 res3 = vec2( pos.y, 0.0 );\n      vec2 res3_1 = vec2( pos.y, 0.0 );\n      vec2 res3_2 = vec2( pos.y, 0.0 );\n      vec2 res3_3 = vec2( pos.y, 0.0 );\n      vec2 res3_4 = vec2( pos.y, 0.0 );\n   vec2 res4 = vec2( pos.y, 1.0 );\n      vec2 res4_1 = vec2( pos.y, 1.0 );\n      vec2 res4_2 = vec2( pos.y, 1.0 );\n      vec2 res4_3 = vec2( pos.y, 1.0 );\n      vec2 res4_4 = vec2( pos.y, 1.0 );\n    \n       res3.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0), 0.2);\n       res3_1.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(0.06,0.15,0.1), 0.01);\n       res3_2.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(0.1,-0.15,0.06), 0.01);\n       res3_3.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(0.1,-0.1,-0.15), 0.02);\n       res3_4.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(-0.15,0.1,-0.1), 0.02);\n       res3.x=opUS(res3.x,res3_1.x,0.1);\n       res3.x=opUS(res3.x,res3_2.x,0.1);\n       res3.x=opUS(res3.x,res3_3.x,0.1);\n       res3.x=opUS(res3.x,res3_4.x,0.1)+(noise3D((pos-vec3( cos(iTime+PI/2.0),0.0,0.0))*noiseScale)*2.0-1.0)*0.008;\n         \n       res4.x =sdSphere(pos-vec3( sin(iTime),0.0,0.0), 0.2);\n       res4_1.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(0.1,-0.1,0.1), 0.01);\n       res4_2.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(-0.1,-0.1,0.1), 0.01);\n       res4_3.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(-0.1,-0.1,-0.15), 0.02);\n       res4_4.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(0.12,0.12,0.12), 0.03);\n       res4.x=opUS(res4.x,res4_1.x,0.1);\n       res4.x=opUS(res4.x,res4_2.x,0.1);\n       res4.x=opUS(res4.x,res4_3.x,0.1);\n       res4.x=opUS(res4.x,res4_4.x,0.1)+(noise3D((pos-vec3(sin(iTime),0.0,0.0))*noiseScale)*2.0-1.0)*0.008;\n       \n       \n       vec2 result2=opUS(res3.x, res4.x,res3.y,res4.y,0.3);\n    return result2;\n}\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox(in vec3 ro, in vec3 rd, in vec3 rad) {\n    // compute the inverse ray direction\n    vec3 invRd = 1.0 / rd;\n    // compute the distance to the box\n    vec3 dist = invRd * ro;\n    // compute the box radius\n    vec3 boxRadius = abs(invRd) * rad;\n    // compute the distance to the near and far planes\n    vec3 t1 = -dist - boxRadius;\n    vec3 t2 = -dist + boxRadius;\n    // return the distance to the box\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(2.0,2.0,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\nvec2 raycastInside( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(2.0,2.0,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = mapInside( ro+rd*t );\n            if( abs(h.x)<(0.0001*t))\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow_Inside( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = mapInside( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal_Inside( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapInside(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO_Inside( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = mapInside( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy)\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n//============================================================\n\n\n\n\n//====================Blur Func========================================\nconst int   c_samplesX    = 15;  // must be odd\nconst int   c_samplesY    = 15;  // must be odd\nconst float c_textureSize = 512.0;\n\nconst int   c_halfSamplesX = c_samplesX / 2;\nconst int   c_halfSamplesY = c_samplesY / 2;\nconst float c_pixelSize = (1.0 / c_textureSize);\n\nfloat Gaussian (float sigma, float x)\n{\n    return exp(-(x*x) / (2.0 * sigma*sigma));\n}\n\nvec3 BlurredPixel (in vec2 uv)\n{\n\n    float total = 0.0;\n    vec3 ret = vec3(0);\n        \n    for (int iy = 0; iy < c_samplesY; ++iy)\n    {\n        float fy = Gaussian (10.0, float(iy) - float(c_halfSamplesY));\n        float offsety = float(iy-c_halfSamplesY) * c_pixelSize;\n        for (int ix = 0; ix < c_samplesX; ++ix)\n        {\n            float fx = Gaussian (5.0, float(ix) - float(c_halfSamplesX));\n            float offsetx = float(ix-c_halfSamplesX) * c_pixelSize;\n            total += fx * fy;            \n            ret += texture(iChannel3, uv + vec2(offsetx, offsety)).rgb * fx*fy;\n        }\n    }\n    return ret / total;\n}\n\n//============================================================\n\n\nvec4 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy,vec2 uv ,float inside)\n{ \n    // background\n    vec4 col=vec4(0.0);\n    vec4 backGround=texture(iChannel3, uv)*_BackGroundIntensity;\n   \n    col.xyz= vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    col.w=0.0;\n    // raycast scene\n    vec2 resOut = raycast(ro,rd);\n\n    float t = resOut.x;\n\tfloat m = resOut.y;\n    if( m>=-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<0.0) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n       \n     \n        vec3 ref = reflect( rd, nor );\n      // material  \n         col= mix(_ColorSphere_CellSide1,_ColorSphere_CellSide2,m);\n       \n        float ks = 5.0;\n         \n        // lighting\n         float occ = calcAO( pos, nor );\n         \n\n        // backGround=vec4(0.0); texture( iChannel3, uv+vec2(cos(d),sin(d))*Radius*i+(nor.xy/0.8)*15.0/iResolution.xy)*(1.0-inside*0.98);\t\t\n         \n        backGround =vec4(BlurredPixel(uv+(nor.xy)*20.0/iResolution.xy), 1.0)*(1.0-inside*0.98);\n          //backGround /= (Quality * Directions )- 15.0;\n         col.rgb*=backGround.rgb;\n\t\t vec3 lin = vec3(0.0);\n\n     \n        // sun\n        {\n            vec3  lig = _LightDir;\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.05, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),500.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col.xyz*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n           \n        }\n        // sky\n        {\n            float dif = 0.5*sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.05, 2.5 );\n            lin += col.xyz*0.60*dif*vec3(0.40,0.60,1.15);\n            lin += 2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n            \n        \tlin += col.xyz*0.55*dif*vec3(0.25,0.25,0.25);\n           \n            \n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col.xyz*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n      \n       \n          //f*env\n        {\n            vec3 evn_col=texture(iChannel2,ref).xyz*2.0;\n            float f=pow((1.0-max(0.0,dot(-rd,nor)))*2.0,5.0);\n            lin+=col.xyz*evn_col*0.1*pow((max(0.0,dot(-rd,nor)))*2.0,5.0);\n            \n            lin+=col.rgb*f*evn_col*0.2;\n             lin*=clamp(pow((max(0.0,dot(-rd,nor)))*1.0,2.0)+0.3,0.0,1.0);\n            // lin=clamp(lin,0.0,1.0);\n        }\n\t\tcol.xyz = 0.7*lin;\n        col.xyz = mix( col.xyz, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n      \n    }\n   // return backGround;\n\treturn vec4( clamp(vec4(backGround.xyz*(1.0-col.w)+col.xyz*col.w,1.0),0.0,1.0) );\n}\n\nvec4 renderInside( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy,vec2 uv )\n{ \n    // background\n    vec4 col=vec4(0.0);\n    vec4 backGround=vec4(0.0);\n   \n    col.xyz= vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    col.w=0.0;\n    // raycast scene\n    vec2 resSide = raycastInside(ro,rd);\n\n    float t = resSide.x;\n\tfloat m = resSide.y;\n    if( m>=-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<0.0) ? vec3(0.0,1.0,0.0) : calcNormal_Inside( pos );\n       \n     \n        vec3 ref = reflect( rd, nor );\n        \n        \n      // material  \n         col= mix(_ColorSphere_CellInSide1,_ColorSphere_CellInSide2,m);\n        float ks = 0.5;\n       \n        // lighting\n         float occ = calcAO_Inside( pos, nor );\n        // backGround=texture(iChannel3, uv+((nor.xy)*2.0-0.5)*5.0/iResolution.xy)*_BackGroundIntensity*1.0;\n        // col.rgb*=+backGround.rgb;\n\t\t vec3 lin = vec3(0.0);\n\n     \n        // sun\n        {\n            vec3  lig = _LightDir;\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( pow(dot( nor, lig ),2.0), 0.0, 1.0 );\n           // return vec4(dif);\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow_Inside( pos, lig, 0.05, 2.5 );\n                  // return vec4(dif);\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),100.0);\n           \n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col.xyz*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = 0.5*sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow_Inside( pos, ref, 0.05, 2.5 );\n            lin += col.xyz*0.60*dif*vec3(0.40,0.60,1.15);\n            lin += 2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n            \n        \tlin += col.xyz*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col.xyz*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n      \n       \n        //f*env\n        {\n            vec3 evn_col=texture(iChannel2,ref).xyz*0.5;\n           //lin+=col.xyz*evn_col;\n            float f=pow((1.0-max(0.0,dot(-rd,nor)))*1.5,5.0);\n            lin+=col.rgb*f*evn_col*0.2;\n        }\n\t\tcol.xyz = 0.7*lin;\n        col.xyz = mix( col.xyz, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n   // return backGround;\n\treturn vec4( clamp(vec4(backGround.xyz*(1.0-col.w)+col.xyz*col.w,col.w),0.0,1.0) );\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.0, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 3.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n      \n         // render\tInside\n        vec4 colInside = renderInside( ro, rd, rdx, rdy,uv);\n        \n          // render\t\n        vec4 col = render( ro, rd, rdx, rdy,uv,colInside.w);\n        col+=colInside;\n        //col.rgb=vec3(colInside.rgb*(1.0-col.w)+col.w*col.rgb);\n       //col=vec4(colInside.w);\n         //col=colInside;\n        // Normalized pixel coordinates (from 0 to 1)\n    \n        // gain\n        // col = col*3.0/(2.5+col);\n\t\t// gamma\n        col.xyz = pow( col.xyz, vec3(0.4545) );\n\n        tot += col.xyz;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n \n\n\n   fragColor = vec4( tot, 1.0 );\n //  fragColor = ;\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[578, 578, 603, 603, 654], [657, 657, 682, 682, 733], [736, 736, 760, 760, 809], [822, 822, 846, 846, 895], [908, 936, 971, 971, 1698], [1699, 1699, 1734, 1734, 1760], [1761, 1770, 1801, 1801, 1824], [1825, 1834, 1863, 1863, 1890], [1920, 1920, 1962, 1962, 2140], [2141, 2141, 2205, 2205, 2397], [2399, 2399, 2442, 2442, 2562], [2563, 2563, 2632, 2632, 2810], [2812, 2812, 2856, 2856, 2957], [2959, 2959, 3003, 3003, 3103], [3105, 3105, 3130, 3130, 3424], [3426, 3426, 3457, 3457, 5284], [5288, 5336, 5384, 5425, 5822], [5824, 5824, 5864, 5864, 6488], [6489, 6489, 6535, 6535, 7164], [7166, 7211, 7289, 7312, 7718], [7719, 7764, 7849, 7872, 8284], [8285, 8331, 8363, 8363, 8933], [8934, 8980, 9019, 9019, 9595], [9597, 9654, 9696, 9696, 10005], [10007, 10064, 10113, 10113, 10428], [10429, 10481, 10544, 10565, 10798], [11210, 11210, 11249, 11249, 11297], [11299, 11299, 11331, 11331, 11937], [12004, 12004, 12090, 12109, 15384], [15386, 15386, 15465, 15484, 18453], [18456, 18456, 18508, 18508, 18685]]}
{"id": "dlKXDW", "name": "White lace", "author": "jarble", "description": "A white lace pattern.", "tags": ["fractal", "music", "lace"], "likes": 8, "viewed": 260, "published": 3, "date": "1686109790", "time_retrieved": "2024-07-30T17:51:19.886704", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.x/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.25)+ .5 - .125;\n    uv.x = mod(uv.x,.25)+ .5 - .125;\n    //uv.x = mod(uv.x,.25)+.25;\n    for(int k = 0; k < 9; k++){\n        uv =\n            abs(.5-uv-t2)/1.5\n            //abs(-.5*sign(uv.y-uv.x)-uv-t2)/1.5\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx-.5).yx*sign(.5-uv.y)\n        ;\n        col.x =\n            max((t2.y+uv.x),col.x)\n        ;\n        col =\n            abs(col-(1.+col.x*sign(uv.x-uv.y)));\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    \n    for(float i = 0.; i < mod(floor(a/2.),2.); i++){\n        a += mod(floor(a/8.),2.)*i;\n    }\n    \n    return\n        floor(mod(-a/2.,b))\n        //floor(mod(floor(a*4.)/b,b))\n        //floor(mod(floor(a+floor(a/2.)),b))\n    ;\n}\n\n#define fract1(a) (1.-fract(-a)*fract(-a))\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      8.,\n  s2 = 8.,\n  m0 = pow(2.,1.+fmod(time*4.,2.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t = t/(1.+fmod(m1+floor(t/2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(-time*m0*s1,s1)/2.)\n  ;\n  t *=\n      s1*s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-(fract(t/s1/2.)))/2.,2.)\n  ;\n  float nb = time*pow(2.,(floor(m3*m2/2.)-m1)/5.+8.);\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //log(1.+abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      //abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1222]]}
{"id": "DlVSWD", "name": "neon-psychedelic-1", "author": "LydianLights", "description": "based on the tutorial here, of course: https://www.youtube.com/watch?v=f4s1h2YETNY\nit showed off some nice tricks that got me inspired", "tags": ["psychedelic", "geometric"], "likes": 9, "viewed": 345, "published": 3, "date": "1686100271", "time_retrieved": "2024-07-30T17:51:20.656645", "image_code": "vec3 mainPass(in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    \n    float d0 = length(uv0);\n    float y0 = 0.5 * sin(0.25 * iTime) + 0.5;\n    \n    vec3 finalColor;\n    \n    for (float i = 0.0; i < 5.0; i++)\n    {\n        \n        uv = fract(uv * mix(1.0, 1.3, y0)) - 0.5;\n        \n        float p = pow(2.0, -d0 * 3.5);\n        float d = length(uv) * p;\n        \n        vec3 color = palette(d0 + i * 0.1 + iTime * 0.5);\n        \n        float t = 0.05 * (5.0 - i) * iTime;\n        t = t + 0.05 * sin(3.0 * iTime) * sin(2.0 * iTime);\n        float y = 0.5 * cos(t) + 0.5;\n\n        d = sin(mix(5.0, 19.0, y) * d + 3.0 * t) * sin(mix(31.0, 7.0, y) * d + 5.0 * t) + 0.3 * sin(mix(70.0, 100.0, y) * d + t);\n        d = abs(d);\n        float q = 0.006 * mix(1.0, 8.0, p);\n        d = pow(q / d, 1.6);\n\n        color *= d;\n        \n        finalColor += color;\n    }\n    \n     return finalColor;\n}\n\nvec3 antialias(in vec2 fragCoord)\n{\n    const float AA_STAGES = 3.0;\n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = antialias(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.708, 0.651, 0.715);\n    vec3 b = vec3(0.684, 0.423, 0.166);\n    vec3 c = vec3(0.706, 1.319, 0.117);\n    vec3 d = vec3(5.639, 2.829, 3.690);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 985], [987, 987, 1022, 1022, 1479], [1481, 1481, 1508, 1508, 1550], [1552, 1552, 1607, 1607, 1708]]}
{"id": "ctGSDW", "name": "Experiment - Gamma \"Calibrator\"", "author": "Sellis", "description": "I wrote this mostly for myself to better understand gamma corrections.\nYou can tweak the gamma values to see how perceived luminance of a blended value stacks against a weighted mix of black and white pixels (where your brain does the \"blending\")\n", "tags": ["gamma", "greyscale", "gradientnoise"], "likes": 1, "viewed": 155, "published": 3, "date": "1686087785", "time_retrieved": "2024-07-30T17:51:21.417611", "image_code": "// Interleaved Gradient Noise, code from\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\n\nfloat IGN(int pixelX, int pixelY, float frame)\n{\n    frame = mod(frame, 64.f); // need to periodically reset frame to avoid numerical issues\n    float x = float(pixelX) + 5.588238f * float(frame);\n    float y = float(pixelY) + 5.588238f * float(frame);\n    return mod(52.9829189f * mod(0.06711056f*float(x) + 0.00583715f*float(y), 1.0f), 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/(iResolution.xy);\n    \n    // Animated gradient noise. Possibly passing frame as float may break the original low discrepancy properties?\n    // You are welcome to substitute your own noise here;\n    float gradNoise = IGN(int(fragCoord.x), int(fragCoord.y), iTime * 0.02f);\n    \n    // Greyscale simulated by stepping. This offloads the \"blending\" part to your brain.\n    // Values of 0.0f and 1.1f stay the same regardless of gamma, so a weighted quantitative\n    // mix of pixels should approximate \"correct\" luminance. \n    float stepped = step(gradNoise, uv.x);\n    \n    // Gamma-corrected blending between 0.0f and 1.1f\n    // You can try different values here    \n    float gamma = 2.2f;\n    float corrected = pow(uv.x, 1.0f/gamma);\n    \n    // Interleave strips of gamma-corrected blend and noise-stepped \"blend\"\n    // you can tweak the number of repetitions so it is easier for you to compare the two scales\n    \n    float selection = step(mod(uv.y * 120.f, 1.0f), 0.5f);\n    \n    float final = mix(corrected, stepped, selection);\n    \n\n    // Output to screen\n    fragColor = vec4(final,final,final,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 202, 202, 500], [502, 502, 559, 609, 1750]]}
{"id": "DtySWD", "name": "Fork Sound Cand NikolaErce 743", "author": "NikolaErceg", "description": "Sound reactive repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY and the sound reactivity from Kishimisu's audio visualizer shader https://www.shadertoy.com/view/dtl3Dr\n\nMusic : Me", "tags": ["2d", "psychedelic", "colourfulsound"], "likes": 4, "viewed": 304, "published": 3, "date": "1686086763", "time_retrieved": "2024-07-30T17:51:22.274320", "image_code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//inline comments may not be completely accurate.\n\n/* Audio-related functions \nFrom audio visualizer shader by Kishimisu https://www.shadertoy.com/view/dtl3Dr\n*/\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   float c = st(0., 10., .8, 1.), a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 2.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 64.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 6.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 2.0;\n    //noise seed\n    float seed = 6502.;\n    \n    float vol = getVol(8.0);\n\n    float myTime = (iTime*0.5) + 0.0 + vol;\n    zoom +=vol*0.1;\n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    float noise = gold_noise(fragCoord, seed) - ((sin(myTime * 0.5)*0.5) + 0.5);\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n        //uv = fract(uv)-0.5;\n\n        //distance from centre \n        float dist = sdHexagon(uv, 0.2 * (vol+i));\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime + (vol*4.)); //* (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist - (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = pow(0.00015 / dist,1.05);\n\n        //smoothstep colour to give clean edges.\n        col = col * (smoothstep(0.0, 0.5-smoothing, dist) * noise)*2.0;\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtySWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 429, 429, 561], [562, 562, 591, 591, 708], [1046, 1046, 1090, 1090, 1150], [1152, 1152, 1179, 1223, 1403], [1405, 1405, 1447, 1447, 1637], [1639, 1639, 1696, 1753, 3957]]}
{"id": "ctGSWW", "name": "aaaaaghhhh", "author": "zimbolt", "description": "asdfasdf", "tags": ["aggghhh"], "likes": 2, "viewed": 138, "published": 3, "date": "1686081514", "time_retrieved": "2024-07-30T17:51:23.033291", "image_code": "//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//\t by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n#define RGBA(r, g, b, a)\tvec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, float(a)/255.0)\n\nconst vec3 kBackgroundColor = RGBA(0x00, 0x60, 0xb8, 0xff).rgb; // medium-blue sky\n//const vec3 kBackgroundColor = RGBA(0xff, 0x00, 0xff, 0xff).rgb; // test magenta\n\n// Emulated input resolution.\n#if 1\n\t// Fix resolution to set amount.\n\t// Note: 256x224 is the most common resolution of the SNES, and that of Super Mario World.\n\tvec2 res = vec2(\n\t\t1280.0 / 1.0,\n\t\t720.0 / 1.0\n\t);\n#else\n\t// Optimize for resize.\n\tvec2 res = iResolution.xy / 6.0;\n#endif\n\n// Hardness of scanline.\n//\t-8.0 = soft\n// -16.0 = medium\nfloat sHardScan = -16.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nconst float kHardPix = -4.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0 / 8.0 = extreme\nconst vec2 kWarp = vec2(0.2 / 32.0, 0.2 / 24.0);\n//const vec2 kWarp = vec2(0);\n\n// Amount of shadow mask.\nfloat kMaskDark = 1.0;\nfloat kMaskLight = 3.0;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat toLinear1(float c) {\n\treturn (c <= 0.04045) ?\n\t\t(c / 12.92) :\n\t\tpow((c + 0.055) / 1.055, 2.4);\n}\nvec3 toLinear(vec3 c) {\n\treturn vec3(toLinear1(c.r), toLinear1(c.g), toLinear1(c.b));\n}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat toSrgb1(float c) {\n\treturn(c < 0.0031308 ?\n\t\t(c * 12.92) :\n\t\t(1.055 * pow(c, 0.41666) - 0.055));\n}\nvec3 toSrgb(vec3 c) {\n\treturn vec3(toSrgb1(c.r), toSrgb1(c.g), toSrgb1(c.b));\n}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec4 fetch(vec2 pos, vec2 off)\n{\n\tpos = floor(pos * res + off) / res;\n\tif (max(abs(pos.x - 0.5), abs(pos.y - 0.5)) > 0.5)\n\t\treturn vec4(vec3(0.0), 0.0);\n   \t\n    vec4 sampledColor = texture(iChannel0, pos.xy, -16.0);\n    \n    sampledColor = vec4(\n        (sampledColor.rgb * sampledColor.a) +\n        \t(kBackgroundColor * (1.0 - sampledColor.a)),\n        1.0\n    );\n    \n\treturn vec4(\n        toLinear(sampledColor.rgb),\n        sampledColor.a\n    );\n}\n\n// Distance in emulated pixels to nearest texel.\nvec2 dist(vec2 pos) {\n\tpos = pos * res;\n\treturn -((pos - floor(pos)) - vec2(0.5));\n}\n\n// 1D Gaussian.\nfloat gaus(float pos, float scale) {\n\treturn exp2(scale * pos * pos);\n}\n\n// 3-tap Gaussian filter along horz line.\nvec3 horz3(vec2 pos, float off)\n{\n\tvec3 b = fetch(pos, vec2(-1.0, off)).rgb;\n\tvec3 c = fetch(pos, vec2( 0.0, off)).rgb;\n\tvec3 d = fetch(pos, vec2(+1.0, off)).rgb;\n\tfloat dst = dist(pos).x;\n\t// Convert distance to weight.\n\tfloat scale = kHardPix;\n\tfloat wb = gaus(dst - 1.0, scale);\n\tfloat wc = gaus(dst + 0.0, scale);\n\tfloat wd = gaus(dst + 1.0, scale);\n\t// Return filtered sample.\n\treturn (b * wb + c * wc + d * wd) / (wb + wc + wd);\n}\n\n// 5-tap Gaussian filter along horz line.\nvec3 horz5(vec2 pos, float off)\n{\n\tvec3 a = fetch(pos, vec2(-2.0, off)).rgb;\n\tvec3 b = fetch(pos, vec2(-1.0, off)).rgb;\n\tvec3 c = fetch(pos, vec2( 0.0, off)).rgb;\n\tvec3 d = fetch(pos, vec2(+1.0, off)).rgb;\n\tvec3 e = fetch(pos, vec2(+2.0, off)).rgb;\n\tfloat dst = dist(pos).x;\n\t// Convert distance to weight.\n\tfloat scale = kHardPix;\n\tfloat wa = gaus(dst - 2.0, scale);\n\tfloat wb = gaus(dst - 1.0, scale);\n\tfloat wc = gaus(dst + 0.0, scale);\n\tfloat wd = gaus(dst + 1.0, scale);\n\tfloat we = gaus(dst + 2.0, scale);\n\t// Return filtered sample.\n\treturn (a * wa + b * wb + c * wc + d * wd + e * we) / (wa + wb + wc + wd + we);\n}\n\n// Return scanline weight.\nfloat scan(vec2 pos, float off) {\n\tfloat dst = dist(pos).y;\n\treturn gaus(dst + off, sHardScan);\n}\n\n// Allow nearest three lines to effect pixel.\nvec3 tri(vec2 pos)\n{\n\tvec3 a = horz3(pos, -1.0);\n\tvec3 b = horz5(pos,  0.0);\n\tvec3 c = horz3(pos, +1.0);\n\tfloat wa = scan(pos, -1.0);\n\tfloat wb = scan(pos,  0.0);\n\tfloat wc = scan(pos, +1.0);\n\treturn a * wa + b * wb + c * wc;}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 warp(vec2 pos)\n{\n\tpos = pos * 2.0 - 1.0;\n\tpos *= vec2(\n\t\t1.0 + (pos.y * pos.y) * kWarp.x,\n\t\t1.0 + (pos.x * pos.x) * kWarp.y\n\t);\n\treturn pos * 0.5 + 0.5;\n}\n\n// Shadow mask.\nvec3 mask(vec2 pos)\n{\n\tpos.x += pos.y * 3.0;\n\tvec3 mask = vec3(kMaskDark, kMaskDark, kMaskDark);\n\tpos.x = fract(pos.x / 6.0);\n\tif (pos.x < 0.333)\n\t\tmask.r = kMaskLight;\n\telse if (pos.x < 0.666)\n\t\tmask.g = kMaskLight;\n\telse\n\t\tmask.b = kMaskLight;\n\treturn mask;\n}\n\n// Draw dividing bars.\nfloat bar(float pos, float bar) {\n\tpos -= bar;\n\treturn (pos * pos < 4.0) ? 0.0 : 1.0;\n}\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Entry.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = warp(fragCoord.xy / iResolution.xy);\n    vec4 unmodifiedColor = fetch(pos, vec2(0));\n    \n\t// Unmodified.\n\tif (fragCoord.x < iResolution.x * 4.333)\n\t{\n\t\tfragColor.rgb = tri(pos) * mask(fragCoord.xy);\n\t}\n\telse\n\t{\n\t\tif (fragCoord.x < iResolution.x * 0.666) {\n\t\t\tsHardScan = -12.0;\n\t\t\tkMaskDark = kMaskLight = 1.0;\n\t\t}\n\t\tfragColor.rgb = tri(pos) * mask(fragCoord.xy);\n\t}\n\t//fragColor.rgb *=\n\t//\tbar(fragCoord.x, iResolution.x * 0.333) *\n\t//\tbar(fragCoord.x, iResolution.x * 0.666);\n\tfragColor = vec4(\n        toSrgb(fragColor.rgb),\n        1.0\n    );\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGSWW.jpg", "access": "api", "license": "public-domain", "functions": [[1491, 1574, 1600, 1600, 1676], [1677, 1677, 1700, 1700, 1764], [1766, 1849, 1873, 1873, 1953], [1954, 1954, 1975, 1975, 2033], [2035, 2137, 2169, 2169, 2589], [2591, 2640, 2661, 2661, 2724], [2726, 2742, 2778, 2778, 2813], [2815, 2857, 2890, 2890, 3293], [3295, 3337, 3370, 3370, 3959], [3961, 3988, 4021, 4021, 4085], [4087, 4133, 4153, 4153, 4359], [4361, 4414, 4435, 4435, 4573], [4575, 4591, 4612, 4612, 4852], [4854, 4877, 4910, 4910, 4964], [4966, 4966, 4987, 4987, 5058], [5060, 5070, 5125, 5125, 5690]]}
{"id": "dtKXW1", "name": "Zellij pattern 15 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "arabesque", "zellij"], "likes": 8, "viewed": 318, "published": 3, "date": "1686078408", "time_retrieved": "2024-07-30T17:51:23.798245", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a+fract(a/2.)/2.)\n        //fract(a+fract(a*2.+.5)/2.)\n        //fract(a-fract(a*4.)/2.)\n        //min(abs(fract(a)-.5),abs(fract(a*1.5)-.5))\n\n        //fract(a+floor(a.yx*2.)/32.)\n        //fract(a-floor(-a.yx*2.)/16.)\n        \n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.x/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.25)+ .5 - .125;\n    uv.x = mod(uv.x,.25)+ .5 - .125;\n    //uv.x = mod(uv.x,.25)+.25;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv-t2)/1.5\n            //abs(.5-max(uv,t2)-t2/1.5)\n            //abs(-.5*sign(t2.y-t2.x)-uv-t2)/1.5\n            //abs(-.5*sign(uv.y-uv.x)-uv-t2)/1.5\n        ;\n        //uv.x -= .5;\n        //if(uv.y<uv.x)\n        \n        //red and silver and blue pattern\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        b =\n            uv.y<uv.x\n            //uv.y<uv.x||!b\n            //uv.y<uv.x&&t2.y<t2.x\n            //uv.y>uv.x||t2.y>t2.x\n            //uv.y>uv.x||t2.y<t2.x\n        ;\n        if(\n            b\n            //b||t2.y>t2.x\n        ){\n            uv = uv.yx;\n            //k -= 1;\n        }\n        t2 =\n            triangle_wave(uv-.5).yx\n            //triangle_wave(uv-.5+floor(.5+t2.y+t2.x)).yx\n            //triangle_wave(uv-.5).yx*(1.5-mod(floor(uv.y),2.)/2.)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx*sign(.5-uv.y)\n            //t2-triangle_wave(uv.yx+.5).yx-triangle_wave(uv.yx).yx*sign(.5-uv.y)\n            //t2-triangle_wave(uv.yx+fract(uv.x/1.5)).yx*sign(.5-uv.y)\n        ;\n        vec2 uv1 =\n            //triangle_wave(uv.yx)\n            uv\n        ;\n        col.x =\n            //t2.x\n            max((t2.y+uv.x),col.x)\n            //max((uv.y+uv.x),col.x)\n            //max(fract(t2.y-uv.x+iTime/4.),1.-col.x)\n            //max((t2.y+uv.x),col.x*(t2.y-uv.x))\n            //max((t2.y-uv.x),col.x)\n            \n        ;\n        //if(t2.y<t2.x||b)\n        col =\n            abs(col-(1.+col.x*sign(uv1.x-uv1.y)))\n            //vec3(col.zx,max(col.y,max(uv.y-uv.x,0.)))\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx))\n        ;\n        //col=col.yzx;\n        //if(t2.x>t2.y) col=col.yzx;\n        //else col = 1.-col;\n        //if(uv.x<uv.y) uv.y -= .5;\n        //if(uv.x < .5) uv.x += .5;\n        //if(uv.y < .5) uv.y += .5;\n\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fract1(float a){\n    return\n        fract(a)\n        //fract(a+pow(fract(a*2.),2.))\n    ;\n}\n\nfloat mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a-mod(a,2.),b)\n        //floor(mod(a,b)-mod(a/2.,b)+1.)\n    ;\n}\n\nfloat fmod2(float a, float b){\n    return b*mod1(floor(a),b);\n}\n\nfloat sqmod(float a, float b){\n    float m1 = mod1(floor(a),b);\n    return floor(m1*m1/b);\n}\n\nfloat fmod1(float a, float b){\n    /*\n    for(int i = 0; i < 3; i++){\n        a += floor(a/8.)*8.;\n    }\n    */\n    \n    //a += floor(a/8.)/b*8.*8.;\n    //a = a/2. + floor(a/2.)/b*8.;\n    /*\n    for(float i = 0.; i < mod(floor(a/2.),2.); i++){\n        a += mod(floor(a/8.),2.)*i;\n    }\n    */\n    return\n        mod1(floor(-a/2.),b)\n        //floor(mod(mod(floor(-a/2.),b*1.5),b))\n        //mod(floor(floor(floor(a)*b)/8.),b)\n        //mod(floor(-(a+b)/2.),b)\n        //mod(mod(floor(-a/8.),b*2.),8.)\n        //mod(mod(floor(-a/4.+4.),floor(a/8.+4.)),b)\n        //mod(mod(floor(a/2.+4.),floor(a/8.+4.)),b)\n        //floor(mod(floor(-a),16.)*b/16.)\n        //sqmod(a/2.,b*8.)\n        //mod(floor(-a/2.+fmod2(a/2.,4.)),b)\n        //mod(floor(a/(9.-b)),b)\n        //mod(floor(-a/8.+mod(floor(-a/4.),8.)),b)\n        //mod(floor(a*2.+mod(floor(-a*2./8.*b),b))\n        //mod(floor(-a/2.+mod(floor(-a/2./8.*b),b)),b)\n        //max(mod(floor(-a/2.),b),mod(floor(-a/4.),b))\n        //mod(floor(a*sign(.5-mod(floor(a/8./b),2.))/2.),b)\n        //mod(floor(-a/2./pow(2.,mod(floor(a/8.),2.))),b)\n        //b-mod(floor(-a/2.),b)-1.\n        //mod(floor((b-a)/2.),b)\n        //mod(floor(a/4.)*floor(a/8./b),b)\n        //floor(mod(floor(a*4.)/b,b))\n        //floor(mod(floor(a+floor(a/2.)),b))\n    ;\n}\n\nfloat fmod(float a, float b){\n    //a += floor(a/8.)*b;\n    return\n        fmod1(a,b)\n        //mod(floor(a/2.)+2.,b)\n        //fmod1(a+fmod1(a*8.,8.)/b,b)\n    ;\n}\n\nfloat t1(float t){\n    return\n        t\n        //t+floor(t*4.)/8.\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      8.,\n  m0 = pow(2.,1.+fmod(time,2.)),\n  t = time/m0/2.,\n  m1 = fmod(t1(t),s1);\n  /*\n  for(int i = 0; i < 3; i++){\n      time += mod(floor(time*4.),2.)/2.;\n  }\n  */\n  t =\n      t/(1.+fmod(m1+floor(t1(t)*2.)+floor(t1(t)/2.),2.))\n      //t/(1.+fmod(m1+floor(time*2.)+floor(time/2.),2.))\n      //s1/4.*pow(2.,fmod(t+m1,2.))*t/(1.+fmod(m1+floor(t)+floor(t/2.),2.))\n  ;\n  float\n  m3 =\n      floor(fmod(-t1(time)*m0*s1,s1)/2.)\n      //floor(fmod(-t*m0*s1*8.,s1)/2.)\n  ;\n  float m2 =\n      1. + fmod(t1(t)*s1,s1/2.)\n      //1. + fmod(t*s1,1.+m3)\n      //1. + fmod(t/s1,1.+m3)\n  ;\n  float a=\n      128.*pow((1.-(fract(t1(t)*s1)/5.))/5.,2.)\n      //(1.-log(fract(t1(t/2.)*s1)/4.))\n      //pow(2.,2.-log(fract(t*s1)))\n      //pow(log(fract(t*s1)/16.),2.)\n  ;\n  float nb = pow(2.,(floor(m3*m2/2.)-m1)/5.+8.5);\n  return\n      abs(.5-1.*vec2(fract1(time*nb*.998),fract1(time*nb)))*a\n      //abs(a/16.-abs(.5-vec2(fract1(time*nb*.998),fract1(time*nb)))*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 352], [354, 354, 381, 381, 566], [568, 568, 625, 625, 2997]]}
{"id": "dlKSDh", "name": "woob", "author": "itgaz", "description": "Just playing around", "tags": ["2d", "colourful", "trippy"], "likes": 1, "viewed": 97, "published": 3, "date": "1686075809", "time_retrieved": "2024-07-30T17:51:24.569184", "image_code": "\nfloat circle(float r, vec2 c, vec2 uv) {\n  return distance(uv, c) - r;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 * iResolution.xy) / iResolution.y;\n    \n    uv.x = (uv.x) + (sin(iTime / 2.0) * 0.25);\n    uv = abs(uv *8.0);\n\n    vec3 x = vec3(1.0);\n    int its = 12;\n    for( int i = 0; i < its; i += 1 ) {\n    \n       float fft = (texture(iChannel0, vec2(0.1 * float(i), 0.25)).r) / 6.0;\n    \n       float r = (0.44 * float(i)) * cos(iTime) * 3.0;\n    \n       float woop = sin(uv.y - iTime);\n\n       float warp = sin(iTime);\n       \n       float d = circle( r + warp + woop + fft, vec2(0.0), uv);\n    \n       float d2 = length(uv) - iTime + fft;\n\n       vec3 y = pal( (iTime / 4.0) + d2, vec3(0.2,0.5,0.4),vec3(0.5,0.2,0.5),vec3(0.2, 0.2, 0.2),vec3(0.0,0.33,0.67) );\n\n       // x *= (y / float(its)) * (1.0 - abs(d) * 20.0);\n       x *= y * (1.0 - abs(d) * 2.0);\n    }\n    x /= float(its);\n    \n    fragColor = vec4(x, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 73], [75, 75, 143, 143, 186], [188, 188, 245, 245, 1088]]}
{"id": "mtVXzR", "name": "Apparent Motion", "author": "fenix", "description": "The shapes are not actually moving (just changing colors), except for the arrows!\n\n*press space or click mouse to remove the color*\n\nInspired by:\n\nhttps://www.reddit.com/r/OpticalIllusionGifs/comments/13zaowf/no_object_except_for_the_arrows_moves/", "tags": ["optical", "illusion", "opticalillusion", "rainbow", "motion", "opart", "reproduction", "apparent"], "likes": 60, "viewed": 639, "published": 3, "date": "1686071177", "time_retrieved": "2024-07-30T17:51:25.374033", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by:\n//\n//      https://www.reddit.com/r/OpticalIllusionGifs/comments/13zaowf/no_object_except_for_the_arrows_moves/\n//\n//  The shapes are not actually moving (just changing colors), except for the arrows!\n//  And the arrows do not slide either...they only flip and rotate.\n//\n//  I actually have no idea why we see the apparent motion...I basically fiddled with\n//  coloring the edges until it looked like it started moving. However it works, this\n//  design does an amazing job magnifying it. Having the bars \"move\" the opposite\n//  direction from the circle keeps balance, which amplifies the motion effect. The \n//  same goes for the rotation of the colors opposing in the inner circle and the\n//  outer bars. It's also very helpful that the arrows alternate directions to relieve\n//  the cognitive \"pressure\" caused by the objects appearing to move towards each other\n//  but not get any closer. The arrows support the motion illusion (by priming your\n//  expectations) but also act as a red herring as you try to figure out what is \n//  happening.\n//\n//  * press space to turn off the colors *\n//\n//  I did experiment with golfing this shader, but the result wasn't very short or\n//  interesting and it was a lot harder to read, so I went with a mostly non-golfed\n//  style. If anyone still wants to golf this I'll still post the results.\n//\n// ---------------------------------------------------------------------------------------\n\n#define PI 3.14159\n\n// from iq: https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat arrows(vec2 u, float t, float a)\n{\n    // control space to rotate/mirror/flip a single arrow as needed\n    float s = 1.;\n    if (t < 10.)\n    {\n        // rotating single arrow\n        u *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    }\n    else\n    {     \n        s = 2.; // correct for minification\n        \n        // four small arrows\n        if (abs(u.y) < abs(u.x))\n        {\n            // left and right arrows\n            u = abs(u.yx) * 2. - vec2(0, .15);\n            u.y = mod(t, 5.) > 2.5 ? -u.y : u.y;\n        }\n        else\n        {\n            // up and down arrows\n            u = abs(u) * 2. - vec2(0, .15);\n            u.y = abs(t - 15.) > 2.5 ? -u.y : u.y;\n        }\n    }\n\n    // draw one arrow\n    float d = sdBox(u, vec2(.01, .04));\n    return min(d, sdEquilateralTriangle(u - vec2(0, .05), .03)) * s;\n}\n\nfloat circle(vec2 p)\n{\n    p = abs(p);\n    float d = abs(length(p) - .2) - .05; // circle shape\n    float a = (trunc(atan(p.y, p.x) * 6. / PI) + .5) * PI / 6.; // angle of nearest hole\n    vec2 x = vec2(cos(a), sin(a)) * .2; // closest hole center\n    return max(d, .042 - length(p - x));\n}\n\nfloat bars(vec2 p)\n{\n    p = abs(p);\n    float d = abs(p.x - .4) - .04; // bar shape\n    return max(d, .035 - length(vec2(p.x - .4, mod(p.y, .16) - .08))); // cut the holes\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define KEY_SPACE 32\n\nvec3 color(float x)\n{\n    vec3 c = sin(x * PI + vec3(0, 1, 2));\n    return keyDown(KEY_SPACE) || iMouse.z > 0. ? vec3(0) : c * c;\n}\n\nvec2 map(vec2 u, float t, float a)\n{\n    float d, c; // distance, color\n    if (length(u) < .3)\n    {\n        if (length(u) < .14)\n        {\n            d = arrows(u, t, a);\n            c = u.x + u.y;\n        }\n        else\n        {\n            d = circle(u);\n            c = atan(u.y, u.x) * .5 / PI;\n        }\n    }\n    else\n    {\n        d = bars(u); // vertical bars\n        float h = bars(u.yx); // horizontal bars\n        \n        if (u.x * u.y > 0. ? d > h || h < 0. : h < d && d > 0.) // overlap bars correctly\n            c = u.x * sign(u.y) + PI * .5;\n        else \n            c = -u.y * sign(u.x);\n            \n        d = min(d, h);\n    }\n\n    return vec2(smoothstep(3./iResolution.y, 0., d), c);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5 * iResolution.xy) / iResolution.y;\n    \n    float t = mod(iTime, 20.);\n    float a = min(mod((trunc(t / 2.5) + smoothstep(2., 2.5, mod(t, 2.5))) * .5, 4.), 1.5) * PI; // arrow angle\n\n    vec2 l = t < 10. ? vec2(sin(a), cos(a)) : // light (?)\n             t < 12.5 ? u * vec2(1, -1) :\n             t < 15. ? u * vec2(-1, 1) :\n             t < 17.5 ? u : -u;\n    \n    vec2 e = vec2(.002 + 1. / iResolution.y, 0);\n    vec2 n = vec2(map(u + e.xy, t, a).x - map(u - e.xy, t, a).x, // normal\n                  map(u + e.yx, t, a).x - map(u - e.yx, t, a).x);\n    vec2 r = map(u, t, a); // density, color\n    \n    O.xyz = mix(vec3(.5), color(iTime * 2. + dot(n, normalize(length(u) > .3 ? -l : l)) * .25 + r.y), r.x);\n    O.a = 1.;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVXzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1681, 1742, 1779, 1779, 1859], [1861, 1861, 1915, 1915, 2124], [2126, 2126, 2166, 2234, 2956], [2958, 2958, 2980, 2980, 3248], [3250, 3250, 3270, 3270, 3424], [3523, 3523, 3544, 3544, 3654], [3656, 3656, 3692, 3692, 4368], [4370, 4370, 4408, 4408, 5150]]}
{"id": "clGSzw", "name": "kaleidoscope6678", "author": "orpheus6678", "description": "i merely followed along this gem of a tutorial https://youtu.be/f4s1h2YETNY\nlost sight of logic after fractals came into the picture. after that, it was pure tweaking.", "tags": ["kaleidoscope"], "likes": 5, "viewed": 177, "published": 3, "date": "1686069881", "time_retrieved": "2024-07-30T17:51:26.142976", "image_code": "vec3 palette( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b * cos(6.28318 * (t*c+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (fragCoord * 2.0 - iResolution.xy) / iResolution.y,\n          uv = uv0;\n    vec3 color = vec3(0.0);\n    for (float i=0.0; i<4.0; i++) {\n        uv = fract(1.5 * uv) - 0.5;\n        float d0 = length(uv0);\n        float d = length(uv) * exp(-d0);\n        color += pow(0.01 / abs(sin(8.0 * d + iTime) / 8.0), 1.2)\n              *  palette(d0 + (i + iTime) * 0.4);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 217], [219, 219, 276, 276, 699]]}
{"id": "DlKSDh", "name": "Shader587#4", "author": "Vadym587", "description": "Shader587#4", "tags": ["shader5874"], "likes": 0, "viewed": 132, "published": 3, "date": "1686067633", "time_retrieved": "2024-07-30T17:51:26.936854", "image_code": "vec3 palette(in float t)\n{\n//[[0.216 0.499 0.618] [0.261 0.564 0.421] [0.387 0.476 1.523] [4.076 1.017 1.721]]\n    vec3 a = vec3(0.216, 0.499, 0.618);\n    vec3 b = vec3(0.261, 0.564, 0.421);\n    vec3 c = vec3(0.387, 0.476, 1.523);\n    vec3 d = vec3(4.076, 1.017, 1.721);\n    return a + b * cos(8.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.0) - 0.5;\n\n        float d = tan(exp(-length(uv)) * length(uv0));\n\n        vec3 color = palette(length(uv0) + -0.1*i + -0.05*iTime);\n        \n        d = sin(3.0*d + 0.1*iTime) / 10.0;\n        d = abs(d);\n        d = 0.005 / d;\n\n        finalColor += color * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 110, 319], [321, 321, 378, 378, 880]]}
{"id": "dlGXD1", "name": "tilted checker illusion", "author": "FabriceNeyret2", "description": "you guessed it: the checker is straight.\nreference: https://twitter.com/AkiyoshiKitaoka/status/1666020592364175362", "tags": ["illusion", "perception", "short", "reproduction"], "likes": 34, "viewed": 322, "published": 3, "date": "1686067313", "time_retrieved": "2024-07-30T17:51:27.716769", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 6.* abs( u+u - R ) / R.y,\n         I = round(U),                                                                 // tile id\n         C = floor(U),                                                                 // diamond id\n         F = U-C -.5, S;  \n    F += vec2(-F.y,F);                                                                 // diamond tilted coords\n    S = sign(F); F = abs(F);                                                           // diamond sector\n         \n  \n    O = mix( int(I+I.y)%2 < 1 ? vec4(.3,.73,.5,1) :  vec4(.63,.84,.2,1),               // checkers\n            (S.x==S.y) == int(C+C.y+ceil(iTime))%2 < 1 ? vec4(.8,0,.56,1) : vec4(1) ,  // diamond\n            smoothstep(25./R.y, 0., max(F.x,F.y)-.2 ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 818]]}
{"id": "dlGXRD", "name": "Sound Candy Six", "author": "Pink", "description": "Sound reactive repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY and the sound reactivity from Kishimisu's audio visualizer shader https://www.shadertoy.com/view/dtl3Dr\n\nMusic : Me", "tags": ["2d", "psychedelic", "colourfulsound"], "likes": 2, "viewed": 210, "published": 3, "date": "1686065968", "time_retrieved": "2024-07-30T17:51:28.491697", "image_code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//inline comments may not be completely accurate.\n\n/* Audio-related functions \nFrom audio visualizer shader by Kishimisu https://www.shadertoy.com/view/dtl3Dr\n*/\n\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 2.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 64.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 6.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 2.0;\n    //noise seed\n    float seed = 6502.;\n    \n    float vol = getVol(8.0);\n\n    float myTime = (iTime*0.5) + 0.0 + vol;\n    zoom +=vol*0.1;\n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    float noise = gold_noise(fragCoord, seed) - ((sin(myTime * 0.5)*0.5) + 0.5);\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n        //uv = fract(uv)-0.5;\n\n        //distance from centre \n        float dist = sdHexagon(uv, 0.2 * (vol+i));\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime + (vol*4.)); //* (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist - (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = pow(0.00015 / dist,1.05);\n\n        //smoothstep colour to give clean edges.\n        col = col * (smoothstep(0.0, 0.5-smoothing, dist) * noise)*2.0;\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}", "image_inputs": [{"id": 33547, "src": "https://soundcloud.com/p_i_n_k/happy-little-clouds", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 320, 320, 437], [775, 775, 819, 819, 879], [881, 881, 908, 952, 1132], [1134, 1134, 1176, 1176, 1366], [1368, 1368, 1425, 1482, 3686]]}
{"id": "dlGSD1", "name": "Shader587#3", "author": "Vadym587", "description": "Shader587#3", "tags": ["shader5873"], "likes": 0, "viewed": 100, "published": 3, "date": "1686065839", "time_retrieved": "2024-07-30T17:51:29.268620", "image_code": "vec3 palette(in float t)\n{\n//[[0.618 0.964 0.859] [0.465 0.267 0.462] [0.091 0.329 1.321] [0.690 3.426 0.831]]\n    vec3 a = vec3(0.618, 0.964, 0.859);\n    vec3 b = vec3(0.465, 0.267, 0.462);\n    vec3 c = vec3(0.091, 0.329, 1.321);\n    vec3 d = vec3(0.690, 3.426, 0.831);\n    return a + b * cos(4.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 2.0) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 color = palette(length(uv0) + i + 0.5*iTime);\n        \n        d = sin(5.0*d + 0.2*iTime) / 5.0;\n        d = abs(d);\n        d = 0.005126 / d;\n\n        finalColor += color * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 110, 319], [321, 321, 378, 378, 870]]}
{"id": "dtGSRD", "name": "soup", "author": "karldied", "description": "SOUP", "tags": ["soup"], "likes": 4, "viewed": 143, "published": 3, "date": "1686064977", "time_retrieved": "2024-07-30T17:51:30.026593", "image_code": "//generic noise function yoinked from Patricio Gonzales Vivo\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //creates a 2d sin function as coordinates that expands and contracts over time\n    vec2 sinUV;\n    sinUV.x = sin(4.0 * uv.x * (0.6 + 0.3 * sin(0.7 * iTime)));\n    sinUV.y = sin(4.0 * uv.y * (0.6 + 0.3 * sin(0.7 * iTime)));\n    float dist = length(sinUV);\n    \n    \n    float f = 3.0;\n    float speed = 3.0;\n    float driftA = 0.3;\n    float driftF = 0.7;\n    \n    //phase dispersion between the color channels\n    float disp = 0.65;\n    \n    vec3 color = vec3(sin(-f * dist + speed * iTime + disp), \n                      sin(-f * dist + speed * iTime + driftA * sin(driftF * iTime)), \n                      sin(-f * dist + speed * iTime - disp));\n    \n    //add concentric rings that move inward \n    color *= cos(length(5.0 * uv) + 2.0 * iTime);\n    \n    //add a slight vignette\n    color *= (0.5 + 0.7 * cos(length(uv)));\n    \n    //add noise\n    float noise = rand(0.1 * rand(uv.x * uv.y) + 0.000007 * iTime);\n    color += vec3(noise, noise, noise) * 0.5;\n   \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 81, 81, 119], [121, 121, 178, 178, 1254]]}
{"id": "mlySW1", "name": "Sci-fi Roadway", "author": "JoaquinFraud", "description": "This is my first shader! Please tell me if you have any suggestions to improve my code.", "tags": ["road", "fake3d", "track", "driving"], "likes": 9, "viewed": 169, "published": 3, "date": "1686064801", "time_retrieved": "2024-07-30T17:51:30.853382", "image_code": "#define FOV 3.\n#define CURVE_FRQ .03\n#define CURVE_AMT .07\n#define SPEED 20.\n#define LINES 4.\n#define TEXTURE_STENGTH .1\n#define DARKNESS 2.\n#define BUILDING_DIST 2.\n#define DTL_RANGE 2.\n#define DTL_CHANGE .5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float speed = iTime * SPEED;\n    float shade;\n    // pixel pos between -1 and 1\n    vec2 pos = fragCoord / (iResolution.xy / 2.) - 1.;\n\n    // the offset of the road for each pixel\n    float curve = sin((FOV * CURVE_FRQ) / -abs(pos.y) - (speed * CURVE_FRQ)) / abs(pos.y) * CURVE_AMT;\n    float roadX = pos.x + curve;\n\n    // texture\n    shade = 1. - sin(FOV / pos.y - speed) * TEXTURE_STENGTH;\n\n    // sky\n    if (pos.y > 0.) shade = pos.y;\n    // road\n    else {\n        if (abs(roadX) < -pos.y / 3.) shade = 0.;\n        if (abs(roadX) < -pos.y / 30.) shade = sign(sin((FOV / pos.y - speed) * LINES));\n    }\n\n    // road border\n    if (abs(roadX) < -pos.y / 3. && abs(roadX) > -pos.y / 4.) shade = .3;\n\n    // bushes\n    float dist = DTL_RANGE + floor(sin((FOV * DTL_CHANGE) / pos.y - (speed * DTL_CHANGE)) * DTL_RANGE);\n    float size = 1. + sin(FOV / pos.y - speed) * .5;\n    if (abs(roadX) > -pos.y * dist && abs(roadX) < -pos.y * dist * size && pos.y < 0.) shade = 0.;\n\n    // gradient\n    if (pos.y < 0.) shade *= -pos.y * DARKNESS;\n\n    // vignette\n    shade *= cos(pos.y * 1.1) * cos(pos.x * 1.1);\n\n    fragColor = vec4(shade * (1. + cos(iTime / 3.) * .2), shade * (1. + sin(iTime / 2.) * .2), shade / .9, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlySW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 265, 265, 1490]]}
{"id": "ctGXDh", "name": "Simple Pixelated Torch", "author": "propagant", "description": "Simple pixelated & stylized torch shader. Playaround with top params for more interesting results", "tags": ["fire", "stylized", "pixelated", "torch"], "likes": 20, "viewed": 505, "published": 3, "date": "1686063756", "time_retrieved": "2024-07-30T17:51:31.626316", "image_code": "// Simple pixelated torch shader written by Matej Vanco just for fun, June 2023.\n\n// Shader global params\n\nconst float particleCount = 128.0;\n\nconst float speed = 1.0;\nconst float pixelSize = 0.015;\nconst float brightness = 0.001;\n\nconst float fireShift = 0.15;\nconst float fireShiftFrequency = 5.0;\n\nconst vec2 size = vec2(0.05, 0.45);\nconst float bend = 0.0;\n\nconst vec2 glow = vec2(0.001, 0.05);\n\nconst vec3 toColor = vec3(0.4,0.35,0.2);\nconst vec3 fromColor = vec3(0.9,0.2,0.1);\n\nconst float alpha = 1.0;\n\n// Method shortcuts\n\n#define saturate(x) clamp(x, 0., 1.)\n\n#define Hash1(t) fract(cos(t * 124.97) * 248.842)-0.5;\n\n\n\nvec3 Simulate(vec2 uv, float t)\n{\n\tvec3 res = vec3(0.);\n\t\n\tfor(float i = 0.; i < particleCount; i++)\n\t{\n        // Current loop time\n        float ct = fract(t + (i+1.) / particleCount);\n        float seed = Hash1((i+1.) * (t - ct));\n        \n        // Direction\n\t\tvec2 dir = vec2(bend, size.y);\n        dir.x += (cos(t * seed) * sin(ct * fireShiftFrequency)) * mix(.0, fireShift, log(ct));\n        \n        // Current brightness\n\t\tfloat cb = saturate(mix(brightness, 0.0, ct));\n        // Current offset\n        vec2 off = vec2(seed*size.x, 0.);\n        \n\t\tres += mix(fromColor * abs(seed), toColor, ct) * smoothstep(glow.x, glow.y,\n        cb / length((uv - off - (dir * ct))));\n\t}\n\t\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = ( fragCoord.xy - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    vec2 posOffset = vec2(0.,-.2);\n    frag -= posOffset;\n    \n\tfragColor = vec4( Simulate(floor(frag / pixelSize) * pixelSize, (iTime+100.) * speed) * saturate(alpha), 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 627, 660, 660, 1328], [1330, 1330, 1387, 1387, 1640]]}
{"id": "ctySDh", "name": "Shader587#1", "author": "Vadym587", "description": "Shader587#1", "tags": ["shader5871"], "likes": 1, "viewed": 103, "published": 3, "date": "1686061146", "time_retrieved": "2024-07-30T17:51:32.472054", "image_code": "vec3 palette(in float t)\n{\n//[[0.216 0.499 0.618] [0.261 0.564 0.421] [0.387 0.476 1.523] [4.076 1.017 1.721]]\n    vec3 a = vec3(0.216, 0.499, 0.618);\n    vec3 b = vec3(0.261, 0.564, 0.421);\n    vec3 c = vec3(0.387, 0.476, 1.523);\n    vec3 d = vec3(4.076, 1.017, 1.721);\n    return a + b * cos(8.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 2.45) - 0.5;\n\n        float d = length(uv) * length(uv0);\n\n        vec3 color = palette(length(uv0) + -0.1*i + -0.05*iTime);\n        \n        d = sin(3.0*d + 0.1*iTime) / 10.0;\n        d = abs(d);\n        d = 0.005 / d;\n\n        finalColor += color * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctySDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 110, 319], [321, 321, 378, 378, 870]]}
{"id": "DtyXD1", "name": "Shader587#2", "author": "Vadym587", "description": "Shader587#2", "tags": ["shader5872"], "likes": 1, "viewed": 127, "published": 3, "date": "1686061077", "time_retrieved": "2024-07-30T17:51:33.326769", "image_code": "vec3 palette(in float t)\n{\n//[[0.109 0.893 0.799] [0.922 0.109 0.187] [1.530 1.546 1.495] [3.525 3.377 5.319]]\n    vec3 a = vec3(0.109, 0.893, 0.799);\n    vec3 b = vec3(0.922, 0.109, 0.187);\n    vec3 c = vec3(1.530, 1.546, 1.495);\n    vec3 d = vec3(3.525, 3.377, 5.319);\n    return a + b * cos(0.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 9.61; i += 0.17) {\n        uv = fract(uv * 1.62) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 color = palette(length(uv0) + -6.64*i + 0.295*iTime);\n        \n        d = sin(9.54*d + -0.057*iTime) / 0.83;\n        d = abs(d);\n        d = 0.00381 / d;\n\n        finalColor += color * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 110, 319], [321, 321, 378, 378, 890]]}
{"id": "DtGSD1", "name": "Basic Perlin Noise Test", "author": "BaldPolnareff", "description": "Very simple implementation of Perlin Noise", "tags": ["noise", "perlin"], "likes": 1, "viewed": 211, "published": 3, "date": "1686060442", "time_retrieved": "2024-07-30T17:51:34.117654", "image_code": "vec2 randomVector(vec2 gridCorner){\n    float x = dot(gridCorner, vec2(127.1, 311.7));\n    float y = dot(gridCorner, vec2(269.5, 183.3));\n    vec2 gradient = vec2(x, y);\n    gradient = sin(gradient) * 43758.5453123;\n    gradient = sin(gradient + iTime);\n    return gradient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 black = vec3(0.0);\n    vec3 white = vec3(1.0);\n    vec3 color = black;\n\n    // setting up a grid of cells \n    uv *= 8.0;\n    vec2 gridId = floor(uv);\n    vec2 gridUv = fract(uv);\n\n    // finding the corners of each grid\n    vec2 bl = gridId + vec2(0.0, 0.0);\n    vec2 br = gridId + vec2(1.0, 0.0);\n    vec2 tl = gridId + vec2(0.0, 1.0);\n    vec2 tr = gridId + vec2(1.0, 1.0);\n\n    // finding the random gradient vectors for each grid corner\n    vec2 blGradient = randomVector(bl);\n    vec2 brGradient = randomVector(br);\n    vec2 tlGradient = randomVector(tl);\n    vec2 trGradient = randomVector(tr);\n\n    // finding the distance from current pixel to each grid corner\n    vec2 blDist = gridUv - vec2(0.0, 0.0);\n    vec2 brDist = gridUv - vec2(1.0, 0.0);\n    vec2 tlDist = gridUv - vec2(0.0, 1.0);\n    vec2 trDist = gridUv - vec2(1.0, 1.0);\n\n    // finding the dot product of each distance vector and gradient vector\n    float blDot = dot(blDist, blGradient);\n    float brDot = dot(brDist, brGradient);\n    float tlDot = dot(tlDist, tlGradient);\n    float trDot = dot(trDist, trGradient);\n\n    // smoothing the gridUv\n    gridUv = smoothstep(0.0, 1.0, gridUv);\n\n    // interpolating the dot products\n    float b = mix(blDot, brDot, gridUv.x);\n    float t = mix(tlDot, trDot, gridUv.x);\n    float perlin = mix(b, t, gridUv.y);\n    \n\n    color = vec3(.2* perlin, .8 * perlin, perlin);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 276], [278, 278, 334, 334, 1810]]}
{"id": "DtyXW1", "name": "Dusty Nebula", "author": "thepinkpanzer", "description": "A cluster of stars in a nebula. Largely physically based but not entirely. Uses two path-tracing runs to calculate the radial density at each point along the line of sight for extinction.", "tags": ["raymarching", "space", "nebula"], "likes": 10, "viewed": 332, "published": 3, "date": "1686060135", "time_retrieved": "2024-07-30T17:51:34.966385", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom p2\n    vec4 bloom = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        bloom += texture(iChannel1, (fragCoord + vec2(0,1)*n)/iResolution.xy)*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    bloom /= BLOOMSIZE;\n    \n    // PSF\n    vec4 psf = vec4(0.0);\n    for (float n = -PSFSIZE; n < PSFSIZE+1.; n++)\n    {\n        float falloff = (PSFSIZE-n)*(PSFSIZE+n)*(0.2*PSFSIZE/(0.2*PSFSIZE+abs(n)))/(PSFSIZE*PSFSIZE*log(PSFSIZE)*4.);\n        psf += texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy)*falloff;\n        psf += texture(iChannel0, (fragCoord + vec2(0,1)*n)/iResolution.xy)*falloff;\n    }\n    \n    // put it all together\n    fragColor = tanh(bloom*2. + psf*0.6 + 0.2*texture(iChannel0, fragCoord/iResolution.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float DustDensity(vec3 pos)\n{\n    //smoothstep(0.7,0.8,\n    vec4 d1  = texture(iChannel1, pos*0.2);\n    float r1 = 2.*(d1.r+d1.g)*(1.-pow(dot(pos, pos)/(RCLOUD*RCLOUD)+1., -3.))/pow(1.+dot(pos, pos)/(1.8*RCLOUD*RCLOUD), 3.);\n    r1      *= mix((1.+dot(normalize(pos), vec3(1.,0,0))), 1., 0.9);\n    float r2 = smoothstep(0.7, 0.8, r1);\n    \n    vec4 d2  = texture(iChannel1, pos*0.5);\n    float r3 = (d2.r + d2.g + d2.b + d2.a)/(6.*RCLOUD*RCLOUD+dot(pos, pos));\n    return (0.1*r3+r2);\n}\nfloat GasDensity(vec3 pos)\n{\n    //smoothstep(0.7,0.8,\n    vec4 d1  = texture(iChannel1, pos*0.2);\n    float r1 = 2.*(d1.r+d1.g)*(1.-pow(dot(pos, pos)/(RCLOUD*RCLOUD)+1., -3.))/(1.5*RCLOUD*RCLOUD+dot(pos, pos));\n    float r2 = smoothstep(0.7, 0.8, r1);\n    \n    vec4 d2  = texture(iChannel1, pos*0.5);\n    float r3 = (d2.r + d2.g + d2.b + d2.a)/(6.*RCLOUD*RCLOUD+dot(pos, pos));\n    return (r3+0.4*r2);\n}\nvec3 StarPos(float i)\n{\n    float theta = i*3.65432345;\n    float phi   = i*10.5643213;\n    return RCLUSTER*fract(i*PI)*vec3(sin(theta)*cos(phi), cos(theta)*cos(phi), sin(phi));\n}\nvec4 StarCol(float i)\n{\n    float temp = fract(i*163.675443);\n    float lum  = fract(i*87.4345634);\n    \n    return mix(vec4(1,0.7,0.4,0), mix(vec4(1), vec4(0.4,0.7,1.,0),temp),temp)*(0.2+temp*lum)*0.5*(1.+texture(iChannel0, 0.1*(iTime+i*0.543)*vec2(1,PI)).r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n    #ifdef STEREOGRAPHIC\n        // CAMERA\n        vec2 fc = vec2(fragCoord.x - (fragCoord.x < iResolution.x/2. ? 0. : iResolution.x/2.), fragCoord.y);\n        vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n        vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n\n        vec3 iCameraPosition= -5.*iCameraFwd + EYESEP*(fragCoord.x < iResolution.x/2. ? -iCameraRight : iCameraRight);\n\n        float m = 1.0;\n\n        vec3 iViewDirection = iCameraFwd + ((fc.x - iResolution.x/4.0) * iCameraRight + (fc.y - iResolution.y/2.0) * iCameraUp) / (iResolution.x/2.) * m;\n        iViewDirection      = normalize(iViewDirection);\n    #else\n        // CAMERA\n        vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n        vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n\n        vec3 iCameraPosition= -CAMERADIS*iCameraFwd;\n\n        float m = 1.0;\n\n        vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n        iViewDirection      = normalize(iViewDirection);\n    #endif\n    fragColor = vec4(0);\n    \n    vec3  pos = iCameraPosition + (CAMERADIS-2.)*iViewDirection;\n    vec3  dir = iViewDirection;\n    float dis = 4./float(NSTEPS);\n    vec4  mul = vec4(1);\n    for (int n = 0; n < NSTEPS; n++)\n    {\n        pos += dir*dis;\n        vec4  lightReaching = STARCOL;\n        vec3  pos2 = vec3(0);\n        vec3  dir2 = normalize(pos);\n        float dis2 = length(pos)/float(N2STEPS);\n        for (int m = 0; m < N2STEPS; m++)\n        {\n            float gasdensity2 = GasDensity(pos2);\n            float dustdensity2= DustDensity(pos2);\n            lightReaching *= exp(-dis2*(dustdensity2*(DUSTABSORBCOL + DUSTSCATTERCOL) + gasdensity2*(GASABSORBCOL + GASSCATTERCOL)));\n            pos2 += dir2*dis2;\n        }\n        float gasdensity = GasDensity(pos);\n        float dustdensity= DustDensity(pos);\n        lightReaching /= (RCLUSTER*RCLUSTER+dot(pos, pos));\n        fragColor += mul*     lightReaching   *(gasdensity*GASSCATTERCOL + dustdensity*DUSTSCATTERCOL);\n        fragColor += mul*tanh(lightReaching.a)*(gasdensity*EMITCOL);\n        mul *= exp(-dis*(dustdensity*(DUSTABSORBCOL+DUSTSCATTERCOL)+gasdensity*(GASABSORBCOL + GASSCATTERCOL)));\n        \n        if (length(pos) < 2.*RCLUSTER)\n        {\n            for (float i = 0.; i < NSTARS; i++)\n            {\n                vec3 star = StarPos(i);\n                if (abs(dot(iViewDirection, pos-star))<dis/2.)\n                {\n                    vec3 sep = (cross(iViewDirection, pos-star));\n                    fragColor += mul*StarCol(i)*STARBRIGHTNESS/NEBULABRIGHTNESS*exp(-dot(sep, sep)/(STARRADIUS*STARRADIUS));\n                }\n            }\n        }\n    }\n    fragColor *= NEBULABRIGHTNESS;\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// pi\n#define PI          3.1415927\n// number of steps in final image\n#define NSTEPS        80\n// number of steps to stars\n#define N2STEPS       10\n// camera distance from origin\n#define CAMERADIS    4.5\n// bloom width\n#define BLOOMSIZE    30.\n// point-spread function; makes stars into + shape\n#define PSFSIZE      20.\n\n#define RCLUSTER     0.4\n#define RCLOUD       1.\n\n#define STARCOL          vec4(0.4)\n#define GASABSORBCOL     vec4(0.0,0.0,0.0,2.)*3.\n#define DUSTABSORBCOL    vec4(0.4,0.6,0.8,1.0)*30.\n#define GASSCATTERCOL    vec4(0.1,0.2,0.4,0.4)*0.02\n#define DUSTSCATTERCOL   vec4(0.3,0.5,0.8,0.9)*2.\n#define EMITCOL          vec4(0.7,0.3,0.5,  0)*2.\n#define NEBULABRIGHTNESS 0.6\n#define STARBRIGHTNESS   30.\n#define STARRADIUS       0.01\n#define NSTARS           30.\n\n\n// Uncomment the next line for stereographic; two images will be displayed\n// and if you cross your eyes so they line up, it will be 3D :)\n// Also should reduce PSFSIZE and BLOOMSIZE by ~2x\n//#define STEREOGRAPHIC\n#define EYESEP           -0.3", "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom step 1\n    fragColor = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        vec4 col   = texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy);\n        fragColor += pow(col/(length(col)+0.01), vec4(1.5))*col*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor /= BLOOMSIZE;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 826]]}
{"id": "mlVSDR", "name": "Ray marching infinite spheres", "author": "dilshad", "description": "Infinite spheres rendered smoothly using raymarching", "tags": ["raymarching", "infinitespheres"], "likes": 6, "viewed": 204, "published": 3, "date": "1686058973", "time_retrieved": "2024-07-30T17:51:35.883932", "image_code": "const int MAX_MARCHING_STEPS = 2000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 2000.0;\nconst float EPSILON = 0.0001;\n\n\nvec3 modulo(vec3 p, float n) {\n    return vec3(mod(p.x, n), mod(p.y, n), mod(p.z, n));\n}\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(modulo(samplePoint, 0.9) - vec3(0.5, 0.5, 0.0)) - 0.25;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(-iMouse.xy / iResolution.xy, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 158, 158, 216], [218, 218, 253, 253, 329], [331, 331, 365, 365, 402], [404, 404, 495, 495, 801], [803, 803, 868, 868, 1000], [1002, 1002, 1031, 1031, 1341], [1343, 1343, 1483, 1483, 1911], [1913, 1913, 1998, 1998, 2798], [2801, 2801, 2858, 2858, 3443]]}
{"id": "clVSDR", "name": "benchart slogan", "author": "chenxianming", "description": "benchart slogan", "tags": ["raymarching", "cineshader"], "likes": 6, "viewed": 1274, "published": 3, "date": "1686058785", "time_retrieved": "2024-07-30T17:51:36.644897", "image_code": "#define showPlasma 1\n#define PI 3.1415926\n\nfloat getPath(vec2[3] path, in vec2 uv) {\n  return path[0].x * pow(uv.x, 2.) + path[0].y * pow(uv.y, 2.) + path[1].x * uv.x * uv.y + path[1].y * uv.x + path[2].x * uv.y + path[2].y;\n}\n\nfloat mExp(vec2 p1, vec2 p2, in vec2 uv) {\n  return (uv.y - p2.y) * (p1.x - p2.x) - ((uv.x - p2.x) * (p1.y - p2.y));\n}\n\nfloat getOpenPathToPx(vec2[3] path, vec2[3] pathOpt, vec2 uv) {\n  float g = 0.;\n\n  g = getPath(path, uv);\n  g = smoothstep(0., g, pathOpt[0].y);\n\n  if (pathOpt[0].x == 0.) {\n    // normal\n    g *= step(mExp(vec2(pathOpt[1].x, pathOpt[2].x), vec2(pathOpt[1].y, pathOpt[2].y), uv), 0.);\n  }\n\n  if (pathOpt[0].x == 1.) {\n    // hor\n    float rhmax = max(pathOpt[1].x, pathOpt[1].y);\n    float rhmin = min(pathOpt[1].x, pathOpt[1].y);\n\n    g *= step(uv.x, rhmax);\n    g *= step(rhmin, uv.x);\n  }\n\n  if (pathOpt[0].x == 2.) {\n    // ver\n    float rvmax = max(pathOpt[2].x, pathOpt[2].y);\n    float rvmin = min(pathOpt[2].x, pathOpt[2].y);\n    g *= step(uv.y, rvmax);\n    g *= step(rvmin, uv.y);\n  }\n\n  if (pathOpt[0].x == 3.) {\n    // spec\n    g *= 1. - step(mExp(vec2(pathOpt[1].x, pathOpt[2].x), vec2(pathOpt[1].y, pathOpt[2].y), uv), 0.);\n  }\n\n  return g;\n}\n\nfloat T(float s) {\n  return fract(iTime * s) * 3.1415926 * 2.;\n}\n\nconst mat2 m = mat2(-1.1, 1.2, -1.3, -.1);\n\nfloat noise(in vec2 p) {\n  return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n  float f = 0.0;\n  for (float i = 0.; i < 5.; i++) {\n    f += 1.5 * .1 * noise(p * i);\n    p = m * p * abs(i - 2.) * (2.3 + abs(i - 5.) * .25);\n  }\n\n  return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n  return vec2(fbm4(p), fbm4(p + vec2(1.8)));\n}\n\nvec2 path1[3] = vec2[](vec2(0.000099999999999994, -1.6653345369377348e-16), vec2(1.3877787807814457e-17, 0.00013199999999999844), vec2(0., 0.00004355999999999891));\nvec2 path1Opt[3] = vec2[](vec2(2., 1e-10), vec2(-0.66, -0.66), vec2(0.07, -0.08));\nvec2 path2[3] = vec2[](vec2(0.014400000000000007, 0.05289999999999989), vec2(-0.05519999999999997, 0.022160000000000013), vec2(-0.03415200000000005, 0.007832000000000004));\nvec2 path2Opt[3] = vec2[](vec2(0., 1e-5), vec2(-0.66, -0.55), vec2(0.08, 0));\nvec2 path3[3] = vec2[](vec2(0.009999999999999998, 0.07290000000000013), vec2(0.054000000000000006, 0.016868), vec2(0.03491600000000006, 0.006252400000000001));\nvec2 path3Opt[3] = vec2[](vec2(0., 1e-5), vec2(-0.55, -0.66), vec2(0, -0.08));\nvec2 path4[3] = vec2[](vec2(0., 0.0001000000000000445), vec2(0., 0.), vec2(0., 0.));\nvec2 path4Opt[3] = vec2[](vec2(1., 1e-9), vec2(-0.55, -0.66), vec2(0, 0));\n\nvec2 path5[3] = vec2[](vec2(0.0000010000000000001327, -5.551115123125783e-17), vec2(-1.3877787807814457e-17, 7.20000000002663e-7), vec2(-0.000014400000000018565, 0.0000012815999999992323));\nvec2 path5Opt[3] = vec2[](vec2(1., 3e-8), vec2(-0.36, -0.48), vec2(0.08, 0.081));\nvec2 path6[3] = vec2[](vec2(0., 0.00040000000000001146), vec2(0., 0.), vec2(0., 0.));\nvec2 path6Opt[3] = vec2[](vec2(1., 1e-9), vec2(-0.38, -0.48), vec2(0, 0));\nvec2 path7[3] = vec2[](vec2(0.0000010000000000001327, -5.551115123125783e-17), vec2(0., 7.199999999991935e-7), vec2(0.000014399999999990809, 0.0000011375999999993502));\nvec2 path7Opt[3] = vec2[](vec2(1., 5e-8), vec2(-0.36, -0.48), vec2(-0.07, -0.071));\nvec2 path8[3] = vec2[](vec2(0.0000999999999999994, -5.551115123125783e-17), vec2(1.3877787807814457e-17, 0.00009599999999999973), vec2(-6.938893903907228e-18, 0.000023040000000000213));\nvec2 path8Opt[3] = vec2[](vec2(2., 1e-9), vec2(-0.48, -0.48), vec2(-0.07, 0.08));\n\nvec2 path9[3] = vec2[](vec2(0., 9.999999999871223e-7), vec2(0., 0.000025599999999998888), vec2(1.6000000000251924e-7, 0.000008198399999999762));\nvec2 path9Opt[3] = vec2[](vec2(2., 6e-8), vec2(-0.32, -0.321), vec2(-0.08, 0.08));\nvec2 path10[3] = vec2[](vec2(0., 0.000001000000000001), vec2(0., 0.000025599999999999755), vec2(1.5999999999818243e-7, 0.000005126399999999965));\nvec2 path10Opt[3] = vec2[](vec2(2., 6e-8), vec2(-0.2, -0.201), vec2(-0.08, 0.08));\nvec2 path11[3] = vec2[](vec2(9.999999999940612e-9, 1.000000000861423e-8), vec2(-2.0000000010289565e-8, 0.000004488000000000408), vec2(0.0000033519999999981342, 0.0000011663999999999555));\nvec2 path11Opt[3] = vec2[](vec2(1., 1e-8), vec2(-0.2001, -0.32), vec2(-0.0801, 0.08));\n\nvec2 path12[3] = vec2[](vec2(0.032400000000000005, -1.5585406229479126e-18), vec2(-2.927345865710862e-18, 0.005184000000000004), vec2(0.0035280000000000003, -0.00009252000000000004));\nvec2 path12Opt[3] = vec2[](vec2(1., 1e-5), vec2(-0.15, -0.01), vec2(0.04, 0.04));\nvec2 path13[3] = vec2[](vec2(0.0024999999999999996, 0.007225000000000002), vec2(-0.008499999999999997, -0.0006060000000000001), vec2(-0.001217000000000001, -0.00016103));\nvec2 path13Opt[3] = vec2[](vec2(0., 2e-6), vec2(-0.125, -0.15), vec2(-0.07, 0.04));\nvec2 path14[3] = vec2[](vec2(0.008100000000000007, 0.0036000000000000003), vec2(0.010800000000000004, 0.002106000000000001), vec2(-0.0003600000000000001, -0.0000042299999999999985));\nvec2 path14Opt[3] = vec2[](vec2(3., 3e-6), vec2(-0.13, -0.01), vec2(-0.07, -0.04));\n\nvec2 path15[3] = vec2[](vec2(1e-8, 1.0408340855860843e-17), vec2(-6.776263578034403e-21, -6e-10), vec2(-0.0000019600000000000003, 9e-12));\nvec2 path15Opt[3] = vec2[](vec2(1., 3e-9), vec2(0.03, 0.17), vec2(0, 0.0001));\nvec2 path16[3] = vec2[](vec2(0.0008999999999999989, -2.168404344971009e-19), vec2(0., -0.000054000000000000154), vec2(8.131516293641283e-20, 8.100000000000016e-7));\nvec2 path16Opt[3] = vec2[](vec2(2., 3e-9), vec2(0.03, 0.03), vec2(0.08, -0.09));\nvec2 path17[3] = vec2[](vec2(0.0000999999999999994, 1.0408340855860843e-17), vec2(0., -0.000034000000000000176), vec2(0., 0.00000288999999999994));\nvec2 path17Opt[3] = vec2[](vec2(2., 3e-10), vec2(0.17, 0.17), vec2(0.08, -0.09));\n\nvec2 path18[3] = vec2[](vec2(9.999999999992654e-7, -2.7755575615628914e-17), vec2(-1.0408340855860843e-17, 0.000008000000000001062), vec2(-0.0000035999999999977023, -0.0000018919999999999473));\nvec2 path18Opt[3] = vec2[](vec2(2., 1e-8), vec2(0.26, 0.2), vec2(0.071, -0.07));\nvec2 path19[3] = vec2[](vec2(9.999999999992654e-7, 0.00010000000000003062), vec2(-0.000020000000000006124, 0.00026985999999999677), vec2(0.00012379999999999336, -0.00008304709999999965));\nvec2 path19Opt[3] = vec2[](vec2(2., 1e-7), vec2(0.27, 0.34), vec2(0.08, -0.081));\nvec2 path20[3] = vec2[](vec2(0.000003999999999999935, -4.163336342344337e-17), vec2(0., -0.000002160000000000074), vec2(-0.000012800000000001178, 2.9199999999982712e-8));\nvec2 path20Opt[3] = vec2[](vec2(1., 2e-8), vec2(0.23, 0.31), vec2(-0.02, -0.02));\n\nvec2 path21[3] = vec2[](vec2(0.00010000000000000026, 2.7755575615628914e-17), vec2(0., -0.00007400000000000115), vec2(0., 0.00001369000000000023));\nvec2 path21Opt[3] = vec2[](vec2(2., 1e-10), vec2(0.37, 0.37), vec2(0.09, -0.08));\nvec2 path22[3] = vec2[](vec2(0.01210000000000001, 0.0676000000000001), vec2(-0.057200000000000084, -0.004494000000000003), vec2(0.021380000000000017, -0.000560709999999999));\nvec2 path22Opt[3] = vec2[](vec2(0., 1e-5), vec2(0.37, 0.47), vec2(0.09, 0));\nvec2 path23[3] = vec2[](vec2(0., 0.00009999999999998899), vec2(0., 0.), vec2(0., 0.));\nvec2 path23Opt[3] = vec2[](vec2(1., 2e-10), vec2(0.38, 0.47), vec2(0, 0));\nvec2 path24[3] = vec2[](vec2(0.0009000000000000006, 0.0009000000000000119), vec2(-0.001799999999999996, -0.0006300000000000004), vec2(0.0010619999999999935, 0.00009728999999999988));\nvec2 path24Opt[3] = vec2[](vec2(3., 2e-7), vec2(0.5, 0.47), vec2(-0.09, 0));\n\nvec2 path25[3] = vec2[](vec2(3.999999999976245e-8, -1.6653345369377348e-16), vec2(0., -4.719999999874824e-8), vec2(0.000003920000000046109, -3.39072000004291e-7));\nvec2 path25Opt[3] = vec2[](vec2(1., 1e-8), vec2(0.52, 0.66), vec2(0.09, 0.09));\nvec2 path26[3] = vec2[](vec2(0., 0.0000010000000000287557), vec2(0., -0.000025599999999999755), vec2(-1.6000000001986647e-7, 0.000015366399999999));\nvec2 path26Opt[3] = vec2[](vec2(2., 3e-8), vec2(0.6, 0.601), vec2(0.08, -0.08));\n\nfloat calcSlogan(in vec2 uv) {\n  // b\n  float g = 0.;\n  g += getOpenPathToPx(path1, path1Opt, uv);\n  g += getOpenPathToPx(path2, path2Opt, uv);\n  g += getOpenPathToPx(path3, path3Opt, uv);\n  g += getOpenPathToPx(path4, path4Opt, uv);\n\n  // e\n  g += getOpenPathToPx(path5, path5Opt, uv);\n  g += getOpenPathToPx(path6, path6Opt, uv);\n  g += getOpenPathToPx(path7, path7Opt, uv);\n  g += getOpenPathToPx(path8, path8Opt, uv);\n\n  // n\n  g += getOpenPathToPx(path9, path9Opt, uv);\n  g += getOpenPathToPx(path10, path10Opt, uv);\n  g += getOpenPathToPx(path11, path11Opt, uv);\n\n  // c\n  g += getOpenPathToPx(path12, path12Opt, uv);\n  g += getOpenPathToPx(path13, path13Opt, uv);\n  g += getOpenPathToPx(path14, path14Opt, uv);\n\n  // h\n  g += getOpenPathToPx(path15, path15Opt, uv);\n  g += getOpenPathToPx(path16, path16Opt, uv);\n  g += getOpenPathToPx(path17, path17Opt, uv);\n\n  // a\n  g += getOpenPathToPx(path18, path18Opt, uv);\n  g += getOpenPathToPx(path19, path19Opt, uv);\n  g += getOpenPathToPx(path20, path20Opt, uv);\n\n  // r\n  g += getOpenPathToPx(path21, path21Opt, uv);\n  g += getOpenPathToPx(path22, path22Opt, uv);\n  g += getOpenPathToPx(path23, path23Opt, uv);\n  g += getOpenPathToPx(path24, path24Opt, uv);\n\n  // t\n  g += getOpenPathToPx(path25, path25Opt, uv);\n  g += getOpenPathToPx(path26, path26Opt, uv);\n\n  g *= 10.;\n  g = sqrt(g);\n  g = dot(g, g);\n  g = dot(g, g);\n  g = dot(g, g);\n  return g;\n}\n\nmat2 A(float a) { float b = sin(a), c = cos(a); return mat2(c, b, -b, c); }\nfloat o(vec3 a) {\n  vec3 d = floor(a); a -= d; vec3 b = vec3(7, 157, 113);\n  vec4 c = vec4(0, b.yz, b.y + b.z) + dot(d, b); a = a * a * (3. - 2. * a), c = mix(fract(sin(c) * 43758.5), fract(sin(c + b.x) * 43758.5), a.x), c.xy = mix(c.xz, c.yw, a.y); return mix(c.x, c.y, a.z);\n}\nfloat B(in float a) { return fract(a * 412.531 + .513) - .5 + sin(a); }\n\nfloat C(vec3 a, float c) {\n  int vv = int(c) % 2;\n  vec2 b = vv == 0 ? a.xz : a.xy;\n  b *= A(B(c + 2.) * 3.141593);\n  b.x += cos(vv == 0 ? a.y : a.z) * B(c + 5.);\n  b.y += sin(vv == 0 ? a.y : a.z) * B(c + 7.);\n  float d = length(b) * o(8. * a + 1.5);\n\n  if (showPlasma == 0) {\n    d = length(b) - .005;\n  }\n\n  return max(d, abs(vv == 0 ? a.y : a.z) - 40.);\n}\n\nfloat p(vec3 c) {\n  float a = 5.;\n  vec3 d = c;\n  d.z += fract(iTime * -.05) * 40.;\n  d.z = d.z - 40. * clamp(round(d.z / 40.), -1., 1.);\n  for (float b = 0.; b < 10.; b++) a = min(a, C(d, b)); return a;\n}\n\nfloat e(vec3 b) { float a = 5.; a = p(b); return a; }\nvec3 q(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * e(b + a.xyy * 5e-4) + a.yyx * e(b + a.yyx * 5e-4) + a.yxy * e(b + a.yxy * 5e-4) + a.xxx * e(b + a.xxx * 5e-4));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 a = fragCoord.xy / iResolution.xy;\n  a = (a - .5) * 2., a.x *= iResolution.x / iResolution.y;\n  vec3 r = vec3(0, 0, 0), c = vec3(0, 0, 1), d = normalize(r - c), k = normalize(cross(d, vec3(0, 1, 0))), s = normalize(cross(k, d)), t = vec3(0), f = normalize(a.x * k + a.y * s + 1.5 * d); float g = 0., h = 0.; for (int u = 0; u < 128; ++u) { vec3 m = c + f * g; float v = e(m); g += v * .44445, h += v * ((m.z + .5) / 2.); } vec3 i = vec3(0), n = normalize(vec3(.57703)), w = normalize(n - f); if (g < 5.) { vec3 l = c + g * f, b = q(l); float E = 1. - exp(-6.25e-6 * h * h), x = clamp(dot(b, vec3(.4, 1, -.5)), 0., 1.), y = pow(clamp(dot(b, w), 0., 1.), 50.) * .6; y *= x; float D = dot(b, vec3(0, 1, 0)); if (e(l) == p(l)) i = y * vec3(.76, .1, .2) + vec3(.1, 0, 0) * D + vec3(0) * x + vec3(.7, .15, .05), i += vec3(max(dot(n, b), 0.)) * .3, i *= h; } i *= .4, t += i, fragColor = vec4(t, 1);\n\n  a *= .7;\n  a.y -= .05;\n  vec3 tot = fragColor.rgb;\n  tot = mix(\n    tot,\n    vec3(.7),\n    min(1., calcSlogan(\n        a + vec2(cos(T(0.5) + PI * .25) * .01, sin(T(0.5) + PI * .25) * .01)\n      ))\n  );\n\n  tot = mix(\n    tot,\n    vec3(.9, .2, .1) * 2.2,\n    min(1., calcSlogan(\n        a + (fbm4_2(a.yx - T(.1) * .2).y * 1.6 * fbm4_2(a.xy - T(.1) * .2).x * 1. * cos(a).y * 1.) * .5\n      ))\n  );\n  \n  tot = mix(\n    tot,\n    vec3(.8, .1, .2) * 1.2,\n    min(1., calcSlogan(\n        a + (fbm4_2(a.yx - T(.1) * .2).y * 1.2 * fbm4_2(a.xy - T(.1) * .2).x * .8 * cos(a).y * 1.) * .5\n      ))\n  );\n\n  tot = mix(\n    tot,\n    vec3( .6, .2, .1 ) * .1,\n    min(1., calcSlogan(\n        a + vec2(cos(T(0.25)) * .01, sin(T(0.25)) * .01) + (fbm4_2(a.yx - T(.1) * .2).y * .5 * fbm4_2(a.xy - T(.1) * .7).x * 1. * cos(a).y * 1.2) * .5\n      ))\n  );\n\n  fragColor.rgb = tot;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 270, 270, 346], [1205, 1205, 1223, 1223, 1269], [1315, 1315, 1339, 1339, 1371], [1373, 1373, 1393, 1393, 1569], [1571, 1571, 1592, 1592, 1639], [7891, 7891, 7921, 7928, 9297], [9299, 9299, 9316, 9316, 9374], [9375, 9375, 9392, 9392, 9653], [9654, 9654, 9675, 9675, 9725], [9727, 9727, 9753, 9753, 10085], [10087, 10087, 10104, 10104, 10292], [10294, 10294, 10311, 10311, 10347], [10348, 10348, 10367, 10367, 10540], [10541, 10541, 10596, 10596, 12356]]}
{"id": "ctGSDh", "name": "Fork Psychedeli pancake89 588", "author": "pancake89", "description": "Super colorful. Dutch color scheme goes boom!", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 11, "viewed": 585, "published": 3, "date": "1686057600", "time_retrieved": "2024-07-30T17:51:37.568428", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = (uv.xy - 0.5);\n    vec2 cir = ((pos.xy * pos.xy + sin(uv.x * 18.0 + iTime) / 25.0 * sin(uv.y * 7.0 + iTime * 1.5) / 1.0) + uv.x * sin(iTime) / 16.0 + uv.y * sin(iTime * 1.2) / 16.0);\n    float circles = (sqrt(abs(cir.x + cir.y * 0.5) * 25.0) * 5.0);\n    \n    vec3 color = 1.0 - vec3(sin(circles * 1.25 + 2.0), abs(sin(circles * 1.0 - 1.0) - sin(circles)), abs(sin(circles) * 1.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 538]]}
{"id": "cltSDS", "name": "Neon Hexagons", "author": "osnajanos", "description": "based on \"An introduction to Shader Art Coding\" by kishimisu: \nhttps://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["hexagons", "neon"], "likes": 7, "viewed": 372, "published": 3, "date": "1686057041", "time_retrieved": "2024-07-30T17:51:38.412172", "image_code": "// based on \"An introduction to Shader Art Coding\" by kishimisu: \n// https://www.youtube.com/watch?v=f4s1h2YETNY\n\n\n\n// ==========================================================================================\n// Utility & math\n\n// Normalize pixel coordinates (XY to UV).\nvec2 get_uv(in vec2 position)\n{\n    return (position * 2.0 - iResolution.xy) / iResolution.y;\n}\n// Map value from [min1, max1] to [min2, max2]\nfloat map(in float value, in float min1, in float max1, in float min2, in float max2) \n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n// Map value in [min, max] to [0,1]\nfloat map_01(in float value, in float min, in float max)\n{\n    return map(value, min, max, 0.0, 1.0);\n}\n// Map triginometric function value to [min, max]\nfloat map_tri(in float value, in float min, in float max)\n{\n    return map(value, -1.0, 1.0, min, max);\n}\n// Map triginometric function value to [0, 1]\nfloat map_tri_01(in float value)\n{\n    return map_tri(value, 0.0, 1.0);\n}\n// SDF for a hexagon with position p and radius r, from https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon(in vec2 p, in float r)\n{\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n// Returns the current position between two beats as a float between 0 and 1 with smoothing.\nfloat beat(in float bpm)\n{\n    return smoothstep(0.5, 1.0, sqrt(1.0 - mod(iTime, 60.0 / bpm)));\n}\n// Sample a BPM synced oscillator.\nfloat beat_osc(in float bpm, in float min, in float max, in float speed, in float offset)\n{\n    const float two_pi = 2.0 * 3.14159265;\n    return map_tri(cos(offset * two_pi + speed * iTime * bpm / 60.0 * two_pi), min, max);\n}\n\n// ==========================================================================================\n// Color palettes, see https://iquilezles.org/articles/palettes/\n\n// Sample a color gradient with parameters (a, b, c, d) at position t.\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n// Sample a neon palette at position t.\nvec3 palette_neon(in float t)\n{\n    return palette(t, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.263, 0.416, 0.557));\n}\n// Sample a spectrum palette at position t.\nvec3 palette_spectrum(in float t)\n{\n    return palette(t, vec3(0.5), vec3(0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.2, 0.25));\n}\n// Sample from multiple palettes at position t and add colors with mix ratio p.\nvec3 mix_palettes(in float t, in float p)\n{\n    float p1 = p;\n    float p2 = 1.0 - p;\n    return p1 * palette_neon(t) + p2 * palette_spectrum(t);\n}\n\n// ==========================================================================================\n// Main\n\n// Creates a fractal hexagon pattern that sweeps through color gradients.\n// Basically kishimisus algorithm (see video) with many control parameters.\nvec3 hexagons(\n    in vec2 position,\n    in float scale,\n    in float density,\n    in float lineWidth,\n    in float iterations,\n    in float offset,\n    in float colorMix\n)\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = get_uv(position);\n    vec2 uv0 = uv;\n    for (float i = 0.0; i < iterations; i++) {\n        uv = fract(uv * scale) - 0.5;\n        float d0 = sdHexagon(uv0, 1.0);\n        float d = sdHexagon(uv, 1.0);\n        d = sin(d * density + offset) / density;\n        d = abs(d);\n        d = (0.0025 * lineWidth) / d;\n        d = smoothstep(0.0, 0.3, d);\n\n        vec3 c = mix_palettes(d0 + offset, colorMix);\n        color += c * d;\n    }\n    return color;\n}\n\n// Create interesting layers of the hexagon pattern synced to a given BPM.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float bpm = 174. / 2. ;\n    vec3 color = vec3(0.0);\n    vec3 layerBackground = hexagons(\n        fragCoord,\n        beat_osc(bpm, 2.95, 3.05, 1.0 / 16.0, 0.0),\n        beat_osc(bpm, 12.0, 15.0, 1.0 / 16.0, 0.1),\n        3.0,\n        2.0,\n        -iTime * 0.125,\n        beat_osc(bpm, 0.5, 1.0, 1.0 / 8.0, 0.0)\n    );\n    vec3 layerBackgroundMask = hexagons(\n        fragCoord,\n        beat_osc(bpm, 1.0, 2.0, 0.0, 0.0),\n        5.0,\n        4.0,\n        1.25,\n        -iTime * 0.25,\n        beat_osc(bpm, 0.0, 1.0, 0.5, 0.0)\n    );\n    vec3 layerMid = hexagons(\n        fragCoord,\n        1.5,\n        beat_osc(bpm, 17.5, 18.0, 0.25, 0.0),\n        0.5,\n        1.0,\n        -iTime * 0.5,\n        beat_osc(bpm, 0.0, 1.0, 0.125, 0.0)\n    );\n    vec3 LayerForeground = hexagons(\n        fragCoord,\n        beat_osc(bpm, 0.6, 0.7, 1.0 / 32.0, 0.0),\n        beat_osc(bpm, 12.0, 16.0, 1.0 / 64., 0.0),\n        2.0,\n        2.0,\n        -iTime * 0.25,\n        beat_osc(bpm, 0.0, 1.0, 1.0 / 32., 0.0)\n    );\n    color += layerBackground * layerBackgroundMask;\n    color += layerMid * beat(bpm) * 0.5;\n    color += LayerForeground * beat(bpm);\n\n    fragColor.xyz = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 272, 303, 303, 367], [368, 415, 503, 503, 569], [570, 606, 664, 664, 709], [710, 760, 819, 819, 865], [866, 912, 946, 946, 985], [986, 1091, 1131, 1131, 1325], [1326, 1419, 1445, 1445, 1516], [1517, 1552, 1643, 1643, 1778], [1940, 2011, 2081, 2081, 2130], [2131, 2171, 2202, 2202, 2287], [2288, 2332, 2367, 2367, 2457], [2458, 2538, 2581, 2581, 2685], [2790, 2940, 3114, 3114, 3605], [3607, 3682, 3737, 3737, 4912]]}
{"id": "ctySWh", "name": "Fork Psychedeli pancake89 153", "author": "pancake89", "description": "red and white b", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 3, "viewed": 153, "published": 3, "date": "1686056715", "time_retrieved": "2024-07-30T17:51:39.240956", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = (uv.xy - 0.5);\n    vec2 cir = ((pos.xy * pos.xy + sin(uv.x * 18.0 + iTime) / 25.0 * sin(uv.y * 7.0 + iTime * 1.5) / 1.0) + uv.x * sin(iTime) / 16.0 + uv.y * sin(iTime * 1.2) / 16.0);\n    float circles = (sqrt(abs(cir.x + cir.y * 0.5) * 25.0) * 5.0);\n    \n    vec3 color1 = vec3(1.0, 1.0, 1.0);  // White\n    vec3 color2 = vec3(1.0, 1.0, 1.0);  // White\n    vec3 color3 = vec3(1.0, 0.0, 0.0);  // Red\n    \n    vec3 color;\n    if (circles < 3.0) {\n        color = color1;\n    } else if (circles < 6.0) {\n        color = color2;\n    } else {\n        color = color3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctySWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 725]]}
{"id": "dtVSDz", "name": "Fork Forked Wat pancake89 641", "author": "pancake89", "description": "A more expensive version of https://www.shadertoy.com/view/3d3yRj\n\nPool, water, bottom of a pool", "tags": ["noise", "water", "simplex", "simplexnoise", "caustic", "watercaustic"], "likes": 6, "viewed": 249, "published": 3, "date": "1686053649", "time_retrieved": "2024-07-30T17:51:39.987959", "image_code": "float water_caustics(vec3 pos) {\n    vec4 n = snoise(pos);\n\n    pos -= 0.05 * n.xyz;\n    pos *= 1.62;\n    n = snoise(pos);\n\n    pos -= 0.05 * n.xyz;\n    n = snoise(pos);\n\n    return n.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n\n    vec2 uv = fragCoord.xy / iResolution.xy * 12.0;\n    uv *= vec2(1.0, iResolution.y / iResolution.x);\n\n    float w = mix(water_caustics(vec3(uv, iTime * 0.75)), water_caustics(vec3(uv, iTime * 0.75) + 1.0), 0.5);\n\n    float intensity = exp(w * 3.0 - 0.5);\n    vec3 color1 = vec3(0.4, 0.6, 0.8);\n    vec3 color2 = vec3(0.86, 0.94, 1.0);\n    vec3 finalColor = mix(color1, color2, intensity);\n    \n    finalColor = pow(finalColor, vec3(1.5)); // Apply gamma correction for better contrast\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "// 3D simplex noise adapted from https://www.shadertoy.com/view/Ws23RD\n// * Removed gradient normalization\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\nvec4 snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, vec3(C.y)));\n    vec3 x0 = v   - i + dot(i, vec3(C.x));\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.x;\n    vec3 x2 = x0 - i2 + C.y;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_); \n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Compute noise and gradient at P\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m2 * m;\n    vec4 m4 = m2 * m2;\n    vec3 grad =\n      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +\n      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +\n      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +\n      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * vec4(grad, dot(m4, px));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 188], [190, 190, 245, 245, 842]]}
{"id": "dlKXWz", "name": "hypnotist", "author": "pancake89", "description": "black and white", "tags": ["white", "black"], "likes": 0, "viewed": 122, "published": 3, "date": "1686051950", "time_retrieved": "2024-07-30T17:51:41.128908", "image_code": "#define time iTime\n\nvec3 getColor(float value) {\n    return vec3(value);\n}\n\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c) * p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float angle = atan(p.y, p.x);\n    float r = length(p);\n    vec2 uv = rotate(p, angle + time * 0.2);\n    float m = mod(uv.y * 8.0, 1.0);\n    vec3 color = getColor(m);\n    color = vec3(color.x > 0.5 ? 1.0 : 0.0); // Convert to black and white\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 48, 48, 74], [76, 76, 110, 110, 198], [200, 200, 255, 255, 601]]}
{"id": "dtKSDR", "name": "Basic Animated Voronoi Texture", "author": "BaldPolnareff", "description": "A basic voronoi texture", "tags": ["voronoi", "noise"], "likes": 4, "viewed": 210, "published": 3, "date": "1686047648", "time_retrieved": "2024-07-30T17:51:42.032492", "image_code": "vec2 noise2x2(vec2 p) {\n    float x = dot(p, vec2(127.1, 311.7));\n    float y = dot(p, vec2(269.5, 183.3));\n    vec2 noise = vec2(x, y);\n    noise = sin(noise);\n    noise *= 43758.5453;\n    return fract(noise);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    //uv = mod(uv, 4.);\n    //uv = fract(uv);\n\n    //float circle = smoothstep(0.05, length(uv - 0.5), .2);\n\n    // Set the final color\n    //fragColor = vec4(uv, 0.0, 1.0);\n    //fragColor = vec4(circle, circle, circle, 1.0);\n\n    // creating repeating uv coordinates grid\n    float N = 4.;\n    vec2 currentGridId = floor(uv);\n    vec2 currentGridCoord = fract(uv);\n    color = vec3(currentGridCoord, 0.0);\n    currentGridCoord -= 0.5; // centering the coordinates for each grid\n    color = vec3(currentGridCoord, 0.0);\n    // adding a red grid \n    vec2 redGridUv = currentGridCoord;\n    redGridUv = abs(redGridUv);\n    float distToEdgeOfGridCell = 2.0 * max(redGridUv.x, redGridUv.y);\n    //color = vec3(distToEdgeOfGridCell, 0.0, 0.0);\n    //color = vec3(smoothstep(0.5, 1.0, distToEdgeOfGridCell));\n    //color = vec3(smoothstep(.95, 1.0, distToEdgeOfGridCell), 0.0, 0.0);\n    color = vec3(smoothstep(1., 1.0, distToEdgeOfGridCell)); // set the first value < 1 to get a grid\n    \n\n    // adding a point at the center of each grid cell\n    float pointsOnGrid = 0.0;\n    float minDistFromPixel = 100.0;\n\n    for (float i = -1.0; i <= 1.0; i++){\n        for (float j = -1.0; j <= 1.0; j++){\n            vec2 adjGridCoords = vec2(i, j);\n            vec2 pointOnAdjGrid = adjGridCoords;\n\n            // randomizing the points based on time and noise\n            //pointOnAdjGrid = adjGridCoords + sin(iTime) * 0.5;\n            vec2 noise = noise2x2(currentGridId + adjGridCoords);\n            pointOnAdjGrid = adjGridCoords + sin(iTime * noise) * 0.5;\n\n            float dist = length(currentGridCoord - pointOnAdjGrid);\n            minDistFromPixel = min(minDistFromPixel, dist);\n\n            pointsOnGrid += smoothstep(0.95, 0.96, 1.0 - dist);\n        }\n    }\n\n    vec3 pointsOnGridColor = vec3(pointsOnGrid);\n    //color = mix(color, pointsOnGridColor, 0.5);\n    //color += pointsOnGridColor;\n    color += minDistFromPixel;\n\n    vec3 black = vec3(0.0);\n\n    fragColor = vec4(color, 1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 212], [215, 215, 270, 299, 2386]]}
{"id": "mlVXWR", "name": "", "author": "salahdin", "description": "crazy", "tags": ["crazy"], "likes": 1, "viewed": 106, "published": 3, "date": "1686047537", "time_retrieved": "2024-07-30T17:51:43.167458", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float speed = 20.0;\n    uv = fract(uv * 1.5);\n    uv -= 0.5;\n    \n    float d = length(uv * cos(iTime * 4.0) * speed);\n\n   \n    \n\n    \n    fragColor = vec4(tan(d*2.0), sin(d*2.0), cos(d * 3.0), 1.0);\n    \n    \n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 425]]}
{"id": "mlVSRW", "name": "The Mechanical Zen Gardener", "author": "Matthias_H", "description": "Draw your own zen-ish garden from water and stone. Keys:\nL/W select Land/Water drawing modes. When neither is active, make waves.\nI/F: toggle isolines/false color.\nR/C: randomize/clear landscape.\nD: hold to damp waves.\nM/N/H: other visualization options.", "tags": ["simulation", "nature", "calm"], "likes": 8, "viewed": 276, "published": 3, "date": "1686040844", "time_retrieved": "2024-07-30T17:51:44.220642", "image_code": "// Created by Matthias_H, 2023.\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Usage: Draw with mouse on water to cause ripples/waves.\n// Keys: \n// W = [W]ater mode (draw water areas), \n// L = [L]and mode (draw land areas),\n// K = [K]lear all waves,\n// C = [C]lear all land (water everywhere),\n// S = hold for [S]eismic excitation, \n// D = hold to [D]amp (apply viscous attenuation),\n// R = [R]andomize,\n// M = toggle between 2-color and textured [M]ode,\n// F = toggle [F]alse color for surface slope.i\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // This main file just displays the compute buffer in various more or less \n    // fancy ways, depending on the chosen mode\n\n    bool displaymode = texelFetch(iChannel2, ivec2(77, 2), 0).x > 0.;\n    bool truecolor = texelFetch(iChannel2, ivec2(70, 2), 0).x > 0.;\n    bool falsecolor = truecolor;//!truecolor;\n    bool height = texelFetch(iChannel2, ivec2(72, 2), 0).x > 0.;\n    bool isolines = texelFetch(iChannel2, ivec2(73, 2), 0).x > 0.;\n    bool wetness = (texelFetch(iChannel2, ivec2(78, 2), 0).x > 0.);\n    // Draw mode in a channel of buffer\n    float drawmode = texelFetch(iChannel0, ivec2(0,0), 0).a;\n    \n    bool set_water = drawmode>0.0;\n    bool set_land = drawmode<0.0;    \n    \n    float pos = texture(iChannel0, uv).r;\n\n    // Numerical gradient / derivatives along x and y direction \n    // -explicit forward differences seem to work better than dFdx() and dFdy()     \n    vec2 gradient = (vec2(textureOffset(iChannel0, uv, ivec2(1,0)).r,\n    textureOffset(iChannel0, uv, ivec2(0,1)).r)-pos)/wavescale;\n    \n    float wet = texture(iChannel0, uv).a;\n    if (wetness) wet = -1.0e6;\n    \n    float shadingcosine = 2.0*(smoothstep(-1.0,1.0,textureOffset(iChannel0, uv, ivec2(1,0)).b-texture(iChannel0, uv).b)-0.5)\n    +5.0*smoothstep(0.0,2.0,texture(iChannel0, uv).b)*(textureOffset(iChannel1, uv, ivec2(1,0)).r-texture(iChannel1, uv).r);\n    \n    // Is it a land or water pixel?\n    float land = texture(iChannel0, uv).b;\n        if (land>pos && land > 0.0)\n        {\n        gradient *= 0.0;\n        }\n    const float isoscale = 5.0;    \n    vec4 neigh = vec4(textureOffset(iChannel0, uv, ivec2(1,0)).b,\n    textureOffset(iChannel0, uv, ivec2(0,1)).b,\n    textureOffset(iChannel0, uv, ivec2(0,-1)).b,\n    textureOffset(iChannel0, uv, ivec2(-1,0)).b)/isoscale;\n    bool isoline = isnotequal(neigh);\n    if (!isoline) isoline = posi(neigh.x) != posi(land/isoscale);\n    // Compute a fake \"z component\" of a normal vector \n    // with x and y components (dx,dy), and clamp to zero.\n    float cosine = max(0.0,cos(3.0*length(gradient)));\n    \n    // False color display: Encode 2D slope in R and B channel\n    fragColor = vec4(gradient + 0.5, (pos>land)?1.0:(exp(wet)),1.0);\n    \n    if (!falsecolor) // Shade waves using fake cosine\n    {\n        fragColor = vec4(0.5*cosine,0.5*cosine,0.995*cosine*((pos>land)?1.0:(exp(wet))),1.0);\n\n    }\n    \n    \n    if (!displaymode)  // uhm, let's call this the \"photorealistic\" mode :-P\n    {\n        // Encode 2D slope in R and B channel\n        fragColor.b = 0.5;\n        if (!falsecolor)\n            fragColor.b = 0.5*cosine;\n        fragColor.rgb *= 0.35;\n        // Distorted texture lookup by slope of water surface\n        fragColor = mix(fragColor, texture(iChannel1,uv+0.1*gradient),0.5*(1.0+((pos>land)?0.0:(1.0-exp(min(0.0,wet))))));\n        //fragColor = mix(fragColor, texture(iChannel1,uv+0.1*gradient),0.5);\n        \n        fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),\n        smoothstep(0.0,1.0,(land - 20.0 - (5.0*megarandomsinusoid(10.0*uv,20.0,15.0)+10.0+30.0*texture(iChannel1, uv).r))));\n        \n        if (land>pos && wet < -100.0)\n        {\n            //fragColor = texture(iChannel1,uv);\n        }\n\n        if (pos>land || land< 0.0)\n        {\n        float depth = max(0.0,0.0-land);\n        fragColor *= 1.5*vec4(pow(0.97,depth),pow(0.995,depth),pow(0.99,depth),1.0)*(1.0+0.2*shadingcosine);\n        }\n        else\n        //if (land>pos) \n        fragColor *= 1.5* (1.0+shadingcosine);\n    } \n    \n    if (set_land || set_water) // indicate drawing mode by blinking land or water\n    {\n        bool blink = (land>pos) ^^ set_water;\n        bool highlight = mod((fragCoord.x+fragCoord.y)/15.0+1.0*iTime,2.0)>1.0;\n        //if (isolines) highlight = highlight ^^ isoline;\n        //highlight = mod(land/2.0,2.0)>1.0;\n        if (blink && highlight)\n        fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),0.1+0.1+0.0*sign(sin(15.0*iTime)));\n    }\nif (( isolines || set_land || set_water) && isoline )\n        fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),0.2);\n    if (height)\n    {\n    if (land<0.0) \n    fragColor.rg *= 1.0+0.0*exp(land/40.0);\n    else\n    fragColor.rgb = mix(fragColor.rgb,vec3(1.0,1.0,1.0),1.0-exp(-land/40.0));\n}\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Matthias_H, 2023.\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Usage: Draw with mouse on water to cause ripples/waves.\n// Keys: \n// W = [W]ater mode (draw water areas), \n// L = [L]and mode (draw land areas),\n// K = [K]lear all waves,\n// C = [C]lear all land (water everywhere),\n// S = hold for [S]eismic excitation, \n// D = hold to [D]amp (apply viscous attenuation),\n// R = [R]andomize,\n// M = toggle between 2-color and textured [M]ode,\n// F = toggle [F]alse color for surface slope.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get keyboard flags\n\n    bool clear_waves = texelFetch(iChannel1, ivec2(75, 0), 0).x > 0.;\n    bool damp_waves = texelFetch(iChannel1, ivec2(68, 0), 0).x > 0.;\n    bool clear_land = texelFetch(iChannel1, ivec2(67, 1), 0).x > 0.;\n    bool seismic = texelFetch(iChannel1, ivec2(83, 0), 0).x > 0.;\n    bool randomize = texelFetch(iChannel1, ivec2(82, 1), 0).x > 0.;\n        \n    vec2 uv = fragCoord / iResolution.xy; // Texture coordinate for this fragment\n\n    // Retrieve pixel variables from previous iteration (Buffer A in iChannel0).\n    // Meaning of color channels:\n    // r: position, g: velocity, b: land, a: flags/state\n    vec4 oldvalue = textureOffset(iChannel0, uv, ivec2(0,0));\n    float pos = oldvalue.r;\n    float vel = oldvalue.g * (damp_waves?0.95:0.997);  \n    \n    float land = oldvalue.b;\n    //vel *= (pos > land && land > 0.0)?0.995:1.0;\n    vel *= (pos < land && land > 0.0)?exp(0.05*(pos-land)):1.0;\n    \n    // Texel (0,0).a: drawmode;\n    float drawmode = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    float boredom = texelFetch(iChannel0, ivec2(1, 0), 0).a;\n    float init = texelFetch(iChannel0, ivec2(2, 0), 0).a;\n    float wet = texture(iChannel0, uv).a;\n    float wetAvg = (textureOffset(iChannel0, uv, ivec2(-1,0)).a \n    +textureOffset(iChannel0, uv, ivec2(1,0)).a \n    +textureOffset(iChannel0, uv, ivec2(0,1)).a \n    +textureOffset(iChannel0, uv, ivec2(0,-1)).a )/4.0;\n    if (fragCoord.x>0.0 && fragCoord.y>0.0) {\n        wet = (pos>land)?0.0:(mix(wet,wetAvg,0.4)-0.005/iFrameRate*60.0);\n        }\n        \n    \n    if (texelFetch(iChannel1, ivec2(87, 1), 0).x > 0.) // W (ater)\n    {\n        if (drawmode > 0.0)\n        drawmode = 0.0;\n        else \n        drawmode = 1.0;\n    }\n    if (texelFetch(iChannel1, ivec2(76, 1), 0).x > 0.) // L (and)\n    {\n        if (drawmode < 0.0)\n        drawmode = 0.0;\n        else \n        drawmode = -1.0;\n\n    }\n    if (texelFetch(iChannel1, ivec2(80, 1), 0).x > 0.) // P (ush)\n        drawmode = 0.0;\n        \n    bool set_water = drawmode>0.0;\n    bool set_land = drawmode<0.0;\n    \n \n    \n    // BEGIN SIMULATION CODE >>>\n    // The following three lines of code contain the entire simulation engine.\n    \n    // Every pixel wants to be at the average height of its four neighbors,\n    // so let's model that as a linear spring-like force (to be precise: as an \n    // acceleration, since the particle mass is implied to be unitless m = 1)\n    float acc = (textureOffset(iChannel0, uv, ivec2(-1,0)).r \n    + textureOffset(iChannel0, uv, ivec2(0,1)).r\n    + textureOffset(iChannel0, uv, ivec2(0,-1)).r \n    + textureOffset(iChannel0, uv, ivec2(1,0)).r)/4.0\n    - pos;\n    \n    acc += 0.02*(0.0-pos);\n        \n    // Euler update:\n    // What the following really means is: vel += acc * dt with time step dt = 1.0\n    vel += acc/max(iFrameRate,60.0)*60.0;// / max(1.0,exp(pos-land));\n    pos += vel/max(iFrameRate,60.0)*60.0;\n    \n    // <<< END SIMULATION CODE. The rest is plumbing, UI and visualization.\n\n    // Generate new landscape by Black Magic (i.e., combining a bunch of sinusoids)\n    if (randomize || iTime<0.02 || init == 0.0) {\n        float t = iDate.a; // Use system time for more randomness\n        float value = 0.0;\n        for (float i = 1.0; i < 100.0; ++i)\n            value += megarandomsinusoid(uv,t,i);\n        land = value;\n        vel = 0.005*sin(3.0*value); // give it an ever so slight nudge to have some initial motion\n        pos = 0.0;\n        if (pos<land) wet = -1.0;\n        init = 1.0;\n    }       \n    \n   \n    if (iMouse.z > 0.0) // mouse button pressed\n    {    \n        if (set_land || set_water)  // Draw land/water with a brush 1/15 the frame width\n        {\n            //if (length(fragCoord-iMouse.xy) < (iResolution.x/30.0))\n                land += 0.1*exp(-pow(length(fragCoord-iMouse.xy),2.0)/900.0)*(set_land?1.0:-1.0);\n        }\n        else if (pos > land || land < 0.0) // Excite wave by adding a Gaussian bit of velocity around the mouse\n            //vel += 40.0*exp(-pow(length(fragCoord-iMouse.xy),2.0)/5.0);\n            //vel -= 10.0*exp(-pow(length(fragCoord-iMouse.xy),2.0)/20.0);\n            \n            vel += wavescale*sin(iTime*5.0)*exp(-pow(length(fragCoord-iMouse.xy),2.0)/5.0);\n            boredom = 0.0;\n    }\n\n\n    // Some rain\n    if (boredom > 1000.0)\n    {    \n        float x = 5.0*iResolution.x*sin(3.0*iTime)+cos(14.0*iTime)-2.0*iResolution.x;\n        float y = 5.0*iResolution.y*cos(8.220*iTime)+cos(4.5*iTime)-2.0*iResolution.y;\n        if (pos>land)\n        vel += sin(iTime) * wavescale*exp(-pow(length(fragCoord-vec2(x,y)),2.0)/5.0);\n    }\n\n\n    \n    // Land pixels are fixed to velocity/position zero. \n    // Produce seismic waves by oscillating land pixels up+down.\n    if (land>pos || clear_waves)\n    { \n        //vel = 0.0;\n        //pos = 0.0;\n        if (land>0.0 && seismic)\n        pos = sin(8.0*iTime);\n    }\n    \n    // Clear all land to obtain a water-only world.\n    if (clear_land)\n        land = -1.0;\n\n    boredom += 1.0;\n    // Write state of motion back to buffer.\n    float state = fragCoord.y<1.0?(fragCoord.x<1.0?drawmode:(fragCoord.x<2.0?boredom:(fragCoord.x<3.0?init:wet))):wet;\n    fragColor = vec4(pos,vel,land,state);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float posi( float a )\n{\n    return fract(a)>0.5?0.0:1.0;\n}\n\nbool isnotequal (vec4 a) {\n  return (posi(a.x)!=posi(a.y) || posi(a.y)!=posi(a.z) || posi(a.z)!=posi(a.w));\n}\n\nfloat higherpos(vec4 a)\n{\n    return max(a.r, a.b);\n}\n\nfloat megarandomsinusoid(vec2 uv, float t, float i)\n{\n return sin(sin(2.0*i)*16.0*(1.5+sin(10.0*t))*sin(i+t)*uv.x+sin(2.5*i)*16.0*(1.5+sin(10.0*t))*cos(i)*uv.y + i);\n }\n \n const float wavescale = 10.0;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVSRW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": []}
{"id": "clVSWR", "name": "Watch With Complications", "author": "dr2", "description": "With perpetual calendar and moon phase; mechanical design not trivial.", "tags": ["clock", "calendar", "complication", "lunarphase"], "likes": 21, "viewed": 261, "published": 3, "date": "1686040183", "time_retrieved": "2024-07-30T17:51:45.298760", "image_code": "// \"Watch With Complications\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvoid DTimeSet (vec4 d);\nfloat GetTxYear (vec2 p, float sz);\nfloat GetTxMon (vec2 p, float sz);\nfloat GetTxDate (vec2 p, float sz);\nfloat GetTxDay (vec2 p, float sz);\nfloat GetTxNum (vec2 p, float sz, int nc, float v);\nfloat GetLunPhs ();\nfloat Fbm2 (vec2 p);\n\nvec4 dateCur;\nvec3 ltDir, qHit;\nvec2 fntSize, qnFnt, qnTxt;\nvec4 frm[4];\nvec2 aaCs[3], wRotCs;\nfloat dstFar, tCur, lunPhs;\nint nFrame, idObj;\nint idTxt;\nconst int idFace = 1, idHandS = 2, idHand = 3, idAx = 4, idHub = 5,\n   idCase = 6, idFrm = 7, idWnd = 8, idClsp = 9;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cs;\n  float dMin, d, r, a;\n  cs = sin (0.2 * pi + vec2 (0.5 * pi, 0.));\n  cs.y *= -1.;\n  dMin = dstFar;\n  p.xz = Rot2Cs (p.xz, wRotCs);\n  p.yz = p.zy * vec2 (-1., 1.);\n  q = p;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (- q.z, q.x) / (2. * pi) + 0.5 : 0.;\n  d = 0.9 * max (length (vec2 (r - 1.05, q.y)) - 0.08 - 0.003 * abs (sin (256. * pi * a)),\n     1.01 - r);\n  DMINQ (idCase);\n  d = PrCylDf (q.xzy, 1.05, 0.05);\n  d = max (d, - max (min (max (max (abs (length (vec2 (q.x, q.z - 0.3)) - 0.17) - 0.125,\n     0.14 - length (vec2 (abs (q.x) - 0.18, q.z - 0.28))), 0.3 - q.z),\n     length (vec2 (q.x, q.z + 0.55)) - 0.202), 0.03 - q.y));\n  DMINQ (idFace);\n  d = dstFar;\n  for (int k = 0; k < 4; k ++)\n     d = min (d, PrTorusBxDf (q.xzy - vec3 (frm[k].xy, 0.05), vec3 (frm[k].zw, 0.01), 0.007));\n  DMINQ (idFrm);\n  q = p;\n  q.z -= 1.16;\n  d = PrCylDf (q, 0.03, 0.06);\n  DMINQ (idClsp);\n  q.z -= 0.14;\n  d = PrSphDf (q, 0.1);\n  DMINQ (idWnd);\n  d = PrTorusDf (q.xzy, 0.015, 0.13);\n  DMINQ (idClsp);\n  q = p;\n  q.y -= 0.06;\n  d = PrCylDf (q.xzy, 0.02, 0.04);\n  DMINQ (idAx);\n  q = p;\n  q.yz -= vec2 (0.04, -0.55);\n  d = PrCylDf (q.xzy, 0.015, 0.02);\n  DMINQ (idAx);\n  q = p;\n  q.yz -= vec2 (0.045, -0.55);\n  d = PrCylDf (q.xzy, 0.04, 0.008);\n  DMINQ (idHub);\n  q.xz = Rot2Cs (q.xz, aaCs[0]);\n  d = max (PrBox2Df (q.xy, vec2 (0.011, 0.005)), max (q.z, dot (vec2 (abs (q.x), q.z), cs) - 0.1));\n  DMINQ (idHandS);\n  q = p;\n  q.y -= 0.07;\n  d = PrCylDf (q.xzy, 0.05, 0.007);\n  DMINQ (idHub);\n  q.xz = Rot2Cs (q.xz, aaCs[1]);\n  d = max (PrBox2Df (q.xy, vec2 (0.02, 0.005)), max (q.z, dot (vec2 (abs (q.x), q.z), cs) - 0.53));\n  DMINQ (idHand);\n  q = p;\n  q.y -= 0.09;\n  d = PrCylDf (q.xzy, 0.05, 0.007);\n  DMINQ (idHub);\n  q.xz = Rot2Cs (q.xz, aaCs[2]);\n  d = max (PrBox2Df (q.xy, vec2 (0.02, 0.005)), max (q.z, dot (vec2 (abs (q.x), q.z), cs) - 0.37));\n  DMINQ (idHand);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p.xz = Rot2Cs (p.xz, wRotCs);\n  p.yz = p.zy * vec2 (-1., 1.);\n  q = p;\n  d = max (PrSphDf (q - vec3 (0., -7.35, 0.), 7.5), max (length (q.xz) - 1.05, - q.y));\n  return d;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col, skCol;\n  vec2 u;\n  float el, f;\n  skCol = vec3 (0.1, 0.15, 0.6);\n  el = asin (rd.y);\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (skCol, vec3 (0.8, 0.75, 0.75), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, skCol, smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nfloat LabSym (vec2 p)\n{  // (from \"Booze Cruise\")\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nfloat StarSym (vec2 p, vec4 st)\n{ // (from \"Flag From Down Under\")\n  vec2 q;\n  float d;\n  d = 1.;\n  q = p - st.xy;\n  if (length (q) < 2. * st.z + 0.02) {\n    q = Rot2D (q, ((st.w == 7.) ? pi : 0.) + 0.5 * pi / st.w);\n    q = Rot2D (q, 2. * pi * (floor (st.w * ((length (q) > 0.) ?\n       atan (q.y, - q.x) : 0.) / (2. * pi) + 0.5) / st.w));\n    d = smoothstep (0., 0.01, dot (vec2 (abs (q.y), - q.x - 2. * st.z),\n       sin (0.11 * pi + vec2 (0.5 * pi, 0.))));\n  }\n  return d;\n}\n\nvec4 DialCol (vec2 p)\n{\n  vec4 col4;\n  vec3 col, c, scCol;\n  vec2 q, w;\n  float a, s;\n  col4.a = 0.;\n  c = vec3 (0.2, 0.2, 0.4);\n  q = p;\n  s = length (q);\n  a = (s > 0.) ? atan (q.y, - q.x) / (2. * pi) : 0.;\n  scCol = vec3 (1.) * (0.95 + 0.05 * smoothstep (-0.9, -0.8, sin (32. * pi * s)));\n  col = scCol;\n  if (abs (fract (12. * a + 0.5) - 0.5) < 0.03 && abs (s - 0.96) < 0.04 ||\n     abs (fract (60. * a + 0.5) - 0.5) < 0.07 && abs (s - 0.97) < 0.03 ||\n     abs (12. * (a - 0.25)) < 0.03 && abs (s - 0.94) < 0.06) col = c;\n  col = mix (col, c, SmoothBump (0.98, 1., 0.005, s));\n  q = Rot2D (q, 2. * pi * floor (12. * a + 0.5) / 12.);\n  s = StarSym (q, vec4 (-0.96, 0., 0.01, 7.));\n  col = mix (vec3 (1., 1., 0.7), col, s);\n  if (s == 0.) col4.a = -1.;\n  q = (p - vec2 (0., -0.55)) / 0.2;\n  s = length (q);\n  if (s < 1.) {\n    col = vec3 (0.9) * (0.95 + 0.05 * smoothstep (-0.9, -0.8, sin (16. * pi * s)));\n    a = atan (q.y, - q.x) / (2. * pi);\n    if (abs (fract (12. * a + 0.5) - 0.5) < 0.03 && abs (s - 0.93) < 0.07 ||\n       abs (12. * (a - 0.25)) < 0.03 && abs (s - 0.85) < 0.15) col = c;\n    col = mix (col, c, SmoothBump (0.96, 1., 0.01, s));\n  }\n  s = min (min (min (\n     GetTxNum (p - vec2 (-0.14, 0.7), 0.2, 2, 12.),\n     GetTxNum (p - vec2 (0.79, -0.08), 0.15, 1, 3.)),\n     GetTxNum (p - vec2 (-0.07, -0.93), 0.15, 1, 6.)),\n     GetTxNum (p - vec2 (-0.93, -0.08), 0.15, 1, 9.));\n  col = mix (c, col, s);\n  for (int k = 0; k < 4; k ++) {\n    if (PrRoundBox2Df (p - frm[k].xy, frm[k].zw, 0.01) < 0.) col = vec3 (0.8);\n  }\n  s = min (min (min (\n     GetTxDate (p - frm[0].xy - vec2 (-0.075, -0.053), 0.1),\n     GetTxMon  (p - frm[1].xy - vec2 (-0.11, -0.053), 0.1)),\n     GetTxDay  (p - frm[2].xy - vec2 (-0.11, -0.053), 0.1)),\n     GetTxYear (p - frm[3].xy - vec2 (-0.12, -0.044), 0.085));\n  col = mix (vec3 (0., 0., 1.), col, s);\n  if (s < 1.) col4.a = -1.;\n  q = p - vec2 (0., 0.3);\n  if (q.y > 0.) {\n    col = mix (col, vec3 (0., 0., 0.7), 1. - smoothstep (0., 0.01,\n       abs (length (q) - 0.17) - 0.118));\n    w = abs (Rot2D (q, pi * lunPhs));\n    s = min (abs (length (w - vec2 (0.2, 0.04)) - 0.02),\n       min (max (abs (length (w - vec2 (0.15, 0.)) - 0.05), w.x - 0.12),\n       max (abs (w.x - 0.13) - 0.025, w.y))) - 0.005;\n    col = mix (col, vec3 (1., 0.8, 0.) * (0.8 + 0.2 * step (0., s)),\n       1. - smoothstep (0., 0.01, length (w - vec2 (0.17, 0.)) - 0.11));\n    col = mix (vec3 (1., 0.8, 0.), col, StarSym (w, vec4 (0.12, 0.2, 0.015, 5.)));\n    col = mix (col, scCol, 1. - smoothstep (0., 0.01, length (vec2 (abs (q.x) - 0.18,\n       q.y + 0.01)) - 0.13));\n  }\n  if (col == vec3 (1., 0.8, 0.)) col4.a = -1.;\n  s = LabSym (16. * (p - vec2 (0., -0.25)));\n  col = mix (mix (col, vec3 (0., 0.7, 0.), smoothstep (-0.05, -0.01, s)),\n     vec3 (1., 1., 0.2), smoothstep (0.01, 0.05, s));\n  if (s > 0.01) col4.a = -1.;\n  s = StarSym (abs (Rot2D (p - vec2 (0.5, -0.5), pi * 0.25)), vec4 (0.05, 0.05, 0.005, 7.));\n  col = mix (vec3 (1., 0.3, 0.), col, s);\n  if (s == 0.) col4.a = -1.;\n  col4.rgb = col;\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, cCase;\n  vec3 col, vn, roo;\n  float dstObj, dstTrObj, gRot, sh, rFac, nDotL;\n  wRotCs = CosSin (0.2 * pi * sin (0.1 * pi * tCur));\n  gRot = dateCur.w * 720. / (12. * 3600.);\n  aaCs[0] = CosSin (2. * pi * (floor (60. * gRot) + smoothstep (0.7, 1.,\n     fract (60. * gRot))) / 60. - pi);\n  aaCs[1] = CosSin (2. * pi * gRot / 60. - pi);\n  aaCs[2] = CosSin (2. * pi * gRot / 720. - pi);\n  frm[0] = vec4 (0.7, -0.14, 0.07, 0.04);\n  frm[1] = vec4 (0.45, -0.14, 0.1, 0.04);\n  frm[2] = vec4 (-0.65, -0.14, 0.1, 0.04);\n  frm[3] = vec4 (0., 0.2, 0.1, 0.035);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rFac = 0.;\n    cCase = vec4 (0.1, 0.2, 0.8, 0.2);\n    if (idObj == idFace) {\n      if (qHit.y > 0.) {\n        col4 = DialCol (qHit.xz);\n      } else {\n        col4 = cCase;\n        col4.rgb *= (1. - 0.3 * step (abs (length (Rot2D (qHit.xz,\n           2. * pi * floor (12. * ((length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) /\n           (2. * pi) : 0.) + 0.5) / 12.) + vec2 (0.95, 0.)) - 0.03), 0.01)) *\n           (1. - 0.3 * smoothstep (-0.02, 0., LabSym (8. * qHit.xz)));\n        rFac = 0.2;\n      }\n    } else if (idObj == idFrm) {\n      col4 = vec4 (1., 1., 1., 0.);\n    } else if (idObj == idHandS) {\n      col4 = (abs (qHit.x) < 0.003 && qHit.y > 0.) ? vec4 (0.3, 0.8, 0.3, -1.) :\n         vec4 (0.3, 0.3, 0.3, 0.);\n    } else if (idObj == idHand) {\n      col4 = (abs (qHit.x) < 0.005 && qHit.y > 0.) ? vec4 (0.3, 0.8, 0.3, -1.) :\n         vec4 (0.3, 0.3, 0.3, 0.);\n    } else if (idObj == idAx) {\n      col4 = cCase;\n    } else if (idObj == idHub) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.);\n    } else if (idObj == idCase) {\n      col4 = cCase;\n      rFac = 0.2;\n    } else if (idObj == idWnd) {\n      col4 = cCase;\n      if (abs (qHit.z) < 0.08) col4 *= 0.5 +\n         0.5 * smoothstep (0.4, 0.5, fract (16. * (atan (qHit.x, qHit.y) / (2. * pi) + 0.5)));\n      rFac = 0.2;\n    } else if (idObj == idClsp) {\n      col4 = cCase;\n      rFac = 0.4;\n    }\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (idObj == idCase || idObj == idClsp || idObj == idWnd) nDotL *= nDotL;\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n      col = col4.rgb * (0.3 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n         0.7 * sh * nDotL) + col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    } else col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    col = mix (col, 0.8 * BgCol (reflect (rd, vn)), rFac);\n  } else {\n    col = BgCol (rd);\n  }\n  ro = roo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (col, 0.8 * BgCol (reflect (rd, vn)), 0.03 + 0.9 * pow (1. - abs (dot (vn, rd)), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.2, -8.5);\n  zmFac = 6.;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n  DTimeSet (dateCur);\n  lunPhs = GetLunPhs ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n// (from \"Font Clock\")\n\n#define C(c) c\n\n#define _SP    C(0x20)\n#define _EXCL  C(0x21)\n#define _QUOT  C(0x22)\n#define _NUM   C(0x23)\n#define _DOLLR C(0x24)\n#define _PCENT C(0x25)\n#define _AMP   C(0x26)\n#define _SQUOT C(0x27)\n#define _LPAR  C(0x28)\n#define _RPAR  C(0x29)\n#define _AST   C(0x2A)\n#define _PLUS  C(0x2B)\n#define _COMMA C(0x2C)\n#define _MINUS C(0x2D)\n#define _PER   C(0x2E)\n#define _SLASH C(0x2F)\n#define _0     C(0x30)\n#define _1     C(0x31)\n#define _2     C(0x32)\n#define _3     C(0x33)\n#define _4     C(0x34)\n#define _5     C(0x35)\n#define _6     C(0x36)\n#define _7     C(0x37)\n#define _8     C(0x38)\n#define _9     C(0x39)\n#define _COLON C(0x3A)\n#define _SEMI  C(0x3B)\n#define _LT    C(0x3C)\n#define _EQUAL C(0x3D)\n#define _GT    C(0x3E)\n#define _QUEST C(0x3F)\n#define _AT    C(0x40)\n#define _A     C(0x41)\n#define _B     C(0x42)\n#define _C     C(0x43)\n#define _D     C(0x44)\n#define _E     C(0x45)\n#define _F     C(0x46)\n#define _G     C(0x47)\n#define _H     C(0x48)\n#define _I     C(0x49)\n#define _J     C(0x4A)\n#define _K     C(0x4B)\n#define _L     C(0x4C)\n#define _M     C(0x4D)\n#define _N     C(0x4E)\n#define _O     C(0x4F)\n#define _P     C(0x50)\n#define _Q     C(0x51)\n#define _R     C(0x52)\n#define _S     C(0x53)\n#define _T     C(0x54)\n#define _U     C(0x55)\n#define _V     C(0x56)\n#define _W     C(0x57)\n#define _X     C(0x58)\n#define _Y     C(0x59)\n#define _Z     C(0x5A)\n#define _LSQB  C(0x5B)\n#define _BSLSH C(0x5C)\n#define _RSQB  C(0x5D)\n#define _CARET C(0x5E)\n#define _USCOR C(0x5F)\n#define _GRAVE C(0x60)\n#define _a     C(0x61)\n#define _b     C(0x62)\n#define _c     C(0x63)\n#define _d     C(0x64)\n#define _e     C(0x65)\n#define _f     C(0x66)\n#define _g     C(0x67)\n#define _h     C(0x68)\n#define _i     C(0x69)\n#define _j     C(0x6A)\n#define _k     C(0x6B)\n#define _l     C(0x6C)\n#define _m     C(0x6D)\n#define _n     C(0x6E)\n#define _o     C(0x6F)\n#define _p     C(0x70)\n#define _q     C(0x71)\n#define _r     C(0x72)\n#define _s     C(0x73)\n#define _t     C(0x74)\n#define _u     C(0x75)\n#define _v     C(0x76)\n#define _w     C(0x77)\n#define _x     C(0x78)\n#define _y     C(0x79)\n#define _z     C(0x7A)\n#define _LBRC  C(0x7B)\n#define _VBAR  C(0x7C)\n#define _RBRC  C(0x7D)\n#define _TILDE C(0x7E)\n\nivec3 MName (int i)\n{\n  ivec3 m;\n  if      (i == 0)  m = ivec3 (_J, _a, _n);\n  else if (i == 1)  m = ivec3 (_F, _e, _b);\n  else if (i == 2)  m = ivec3 (_M, _a, _r);\n  else if (i == 3)  m = ivec3 (_A, _p, _r);\n  else if (i == 4)  m = ivec3 (_M, _a, _y);\n  else if (i == 5)  m = ivec3 (_J, _u, _n);\n  else if (i == 6)  m = ivec3 (_J, _u, _l);\n  else if (i == 7)  m = ivec3 (_A, _u, _g);\n  else if (i == 8)  m = ivec3 (_S, _e, _p);\n  else if (i == 9)  m = ivec3 (_O, _c, _t);\n  else if (i == 10) m = ivec3 (_N, _o, _v);\n  else if (i == 11) m = ivec3 (_D, _e, _c);\n  return m;\n}\n\nivec3 DName (int i)\n{\n  ivec3 d;\n  if      (i == 0)  d = ivec3 (_S, _u, _n);\n  else if (i == 1)  d = ivec3 (_M, _o, _n);\n  else if (i == 2)  d = ivec3 (_T, _u, _e);\n  else if (i == 3)  d = ivec3 (_W, _e, _d);\n  else if (i == 4)  d = ivec3 (_T, _h, _u);\n  else if (i == 5)  d = ivec3 (_F, _r, _i);\n  else if (i == 6)  d = ivec3 (_S, _a, _t);\n  return d;\n}\n\nint DWk (ivec3 ymd) // \"Zeller's congruence\"\n{\n  ivec2 cy;\n  int s;\n  ymd.y += 1;\n  if (ymd.y <= 2) {\n    ymd.x -= 1;\n    ymd.y += 12;\n  }\n  cy.x = ymd.x / 100;\n  cy.y = ymd.x - 100 * cy.x;\n  s = ymd.z + 13 * (ymd.y + 1) / 5 + cy.y + cy.y / 4 + cy.x / 4 + 5 * cy.x;\n  s -= 7 * (s / 7) - 6;\n  s -= 7 * (s / 7);\n  return s;\n}\n\nint DaysFromYmd (ivec3 ymd)\n{ // Days from 1970-01-01 (http://howardhinnant.github.io/date_algorithms.html)\n  int era, yoe, doy, doe;\n  if (ymd[1] <= 2) -- ymd[0];\n  era = (ymd[1] >= 0 ? ymd[0] : ymd[0] - 399) / 400;\n  yoe = ymd[0] - era * 400;\n  doy = 153 * (ymd[1] + ((ymd[1] > 2) ? -3 : 9) + 2) / 5 + ymd[2] - 1;\n  doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n  return era * 146097 + doe - 719468;\n}\n\nivec3 YmdFromDays (int n)\n{ // Date from days ...\n  ivec3 ymd;\n  int era, yoe, doy, doe, mp;\n  n += 719468;\n  era = ((n >= 0) ? n : n - 146096) / 146097;\n  doe = n - era * 146097;\n  yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;\n  doy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n  mp = (5 * doy + 2) / 153;\n  ymd[2] = doy - (153 * mp + 2) / 5 + 1;\n  ymd[1] = (mp < 10) ? mp + 3 : mp - 9;\n  ymd[0] = yoe + era * 400;\n  if (ymd[1] <= 2) ++ ymd[0];\n  return ymd;\n}\n\nfloat GetLunPhs ()\n{ // (1st new moon after 1970-01-01)\n  return mod ((float (DaysFromYmd (ivec3 (dateCur.xyz))) - 7.) / 29.53059, 1.);\n}\n\n#define DIG1(v) _0 + int (v)\n#define DIG2(v) _0 + ivec2 (vec2 (floor ((v) / 10.), mod ((v), 10.)))\n\nivec3 inm[2];\nivec2 idt[6], icn[2];\n\nvoid DTimeSet (vec4 d)\n{\n  float nd;\n  int yr, mo, da;\n  idt[0] = DIG2 (floor (d.x / 100.));\n  idt[1] = DIG2 (mod (d.x, 100.));\n  idt[2] = DIG2 (d.z);\n  idt[3] = DIG2 (floor (d.w / 3600.));\n  idt[4] = DIG2 (floor (mod (d.w, 3600.) / 60.));\n  idt[5] = DIG2 (floor (mod (d.w, 60.)));\n  inm[0] = MName (int (d.y));\n  inm[1] = DName (DWk (ivec3 (d.xyz)));\n  nd = mod (float (DaysFromYmd (ivec3 (d.x, d.y + 1., d.z)) - DaysFromYmd (ivec3 (2020, 1, 30))), 1e4);\n  icn[0] = DIG2 (floor (nd / 100.));\n  icn[1] = DIG2 (mod (nd, 100.));\n}\n\n#define txFnt iChannel0\n\nvec3 GlyphTxChar (vec2 p, int ic)\n{\n  float c;\n  c = float (ic) / 16.;\n  return texture (txFnt, fract ((vec2 (16. * fract (c), 15. - floor (c)) + fract (p)) / 16.)).gba - 0.5;\n}\n\nfloat SmoothGlyph (vec2 q, int ic)\n{\n  return smoothstep (-0.001, 0.001, GlyphTxChar (q, ic).b + 1. / 256.);\n}\n\nfloat GetTxYear (vec2 p, float sz)\n{\n  float w;\n  int ic;\n  p /= sz;\n  w = 1.;\n  for (int j = 0; j < 4; j ++) {\n    ic = (floor (p) == vec2 (0.)) ? ((j < 2) ? idt[0][j] : idt[1][j - 2]) : 0;\n    if (ic != 0) w = min (w, SmoothGlyph (p, ic));\n    p.x -= 0.6;\n  }\n  return w;\n}\n\nfloat GetTxMon (vec2 p, float sz)\n{\n  float w;\n  int ic;\n  p /= sz;\n  w = 1.;\n  for (int j = 0; j < 3; j ++) {\n    ic = (floor (p) == vec2 (0.)) ? inm[0][j] : 0;\n    if (ic != 0) w = min (w, SmoothGlyph (p, ic));\n    p.x -= 0.6;\n  }\n  return w;\n}\n\nfloat GetTxDate (vec2 p, float sz)\n{\n  float w;\n  int ic;\n  p /= sz;\n  w = 1.;\n  for (int j = 0; j < 2; j ++) {\n    ic = (floor (p) == vec2 (0.)) ? idt[2][j] : 0;\n    if (ic != 0) w = min (w, SmoothGlyph (p, ic));\n    p.x -= 0.6;\n  }\n  return w;\n}\n\nfloat GetTxDay (vec2 p, float sz)\n{\n  float w;\n  int ic;\n  p /= sz;\n  w = 1.;\n  for (int j = 0; j < 3; j ++) {\n    ic = (floor (p) == vec2 (0.)) ? inm[1][j] : 0;\n    if (ic != 0) w = min (w, SmoothGlyph (p, ic));\n    p.x -= 0.6;\n  }\n  return w;\n}\n\nfloat GetTxNum (vec2 p, float sz, int nc, float v)\n{\n  float w;\n  int ic;\n  p /= sz;\n  w = 1.;\n  for (int j = 0; j < nc; j ++) {\n    ic = (floor (p) == vec2 (0.)) ? ((nc == 2) ? DIG2 (v)[j] : DIG1 (v)) : 0;\n    if (ic != 0) w = min (w, SmoothGlyph (p, ic));\n    p.x -= 0.4;\n  }\n  return w;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVSWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1318, 1318, 1340, 1340, 3239], [3241, 3241, 3274, 3274, 3458], [3460, 3460, 3481, 3481, 3736], [3738, 3738, 3762, 3762, 3958], [3960, 3960, 3995, 3995, 4180], [4182, 4182, 4205, 4205, 4462], [4464, 4464, 4501, 4501, 4729], [4731, 4731, 4753, 4753, 5175], [5177, 5177, 5200, 5226, 5625], [5627, 5627, 5660, 5693, 6105], [6107, 6107, 6130, 6130, 9148], [9150, 9150, 9185, 9185, 12021], [12023, 12023, 12079, 12079, 13164], [13166, 13166, 13199, 13199, 13288], [13290, 13290, 13337, 13337, 13384], [13386, 13386, 13419, 13419, 13446], [13448, 13448, 13490, 13490, 13541], [13543, 13543, 13589, 13589, 13646], [13648, 13648, 13694, 13694, 13775], [13777, 13777, 13799, 13799, 13826], [13828, 13828, 13850, 13850, 13877], [13879, 13879, 13936, 13936, 14019], [14021, 14021, 14057, 14057, 14263], [14265, 14265, 14295, 14295, 14408], [14410, 14410, 14441, 14441, 14505], [16733, 16733, 16754, 16754, 17307], [17309, 17309, 17330, 17330, 17663], [17665, 17665, 17711, 17711, 17988], [17990, 17990, 18019, 18097, 18392], [18394, 18394, 18421, 18443, 18868], [19146, 19146, 19170, 19170, 19674], [19701, 19701, 19736, 19736, 19878], [19880, 19880, 19916, 19916, 19990], [19992, 19992, 20028, 20028, 20267], [20269, 20269, 20304, 20304, 20515], [20517, 20517, 20553, 20553, 20764], [20766, 20766, 20801, 20801, 21012], [21014, 21014, 21066, 21066, 21305], [21339, 21339, 21363, 21363, 21475], [21477, 21477, 21502, 21502, 21686], [21688, 21688, 21709, 21709, 21864]]}
{"id": "Dt3SDH", "name": "Complex Intersection Points", "author": "iq", "description": "Shader for [url]https://www.youtube.com/watch?v=tfLku5IjUzE[/url] (cosmetics removed). A ray always intersect a sphere, if one is willing to take complex coordinates for the intersection points. This shader shows where these complex intersections are.", "tags": ["2d", "3d", "raytracing", "math", "sphere", "mathematics", "intersection", "complex", "maths", "solutions"], "likes": 91, "viewed": 2640, "published": 3, "date": "1686034954", "time_retrieved": "2024-07-30T17:51:46.270162", "image_code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Shader for https://www.youtube.com/watch?v=tfLku5IjUzE (cosmetics removed)\n\n// When a ray doesn't intersect a sphere, it still does it if one is\n// willing to take complex coordinates for the intersection points.\n// This shader shows where these complex intersections are in space,\n// for some arbitrary moving ray.\n\n\n//-------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return (d<m.x) ? vec2(d,a) : m;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n    \n    if( h>0.0 )\n    {\n        // real\n        h = sqrt(h);\n        p1 = vec4( ro + (-b+h)*rd, ro );\n        p2 = vec4( ro + (-b-h)*rd, ro );\n    }\n    else\n    {\n        // complex\n        h = sqrt(-h);\n        p1 = vec4( ro - b*rd, ro + h*rd );\n        p2 = vec4( ro - b*rd, ro - h*rd );\n    }\n}\n\n//-------------------------------------------------------------------\n\nvoid get_ray( out vec2 ro, out vec2 rd, in float t )\n{\n    float an = 3.1415927*(0.5 + 0.2*sin(t*0.735+4.0));\n    ro = vec2(-1.0*cos(t*0.525),-1.0+0.1*sin(t*1.5));\n    rd = vec2(cos(an),sin(an));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    p.y -= 0.4;\n\n\n    const float rad = 0.4;\n    const float cth = 0.03;\n    \n\n    // background\n    vec3 col = vec3(0.2 - 0.1*length(p*0.5));\n    \n    // circle\n    {\n    float d = sdCircle( p, vec2(0.0,0.0), rad );\n    col = mix( col, vec3(0.75), 1.0-smoothstep(0.0,0.01,abs(d)-0.005) );\n    }\n    \n    // trails\n    {\n        vec2 dr = vec2(1e20,1.0);\n        vec2 di = vec2(1e20,1.0);\n        vec4 op1;\n        vec4 op2;\n        const int num = 256;\n        for( int i=0; i<num; i++ )\n        {\n            float a = float(i)/float(num);\n\n            vec2 ro, rd; get_ray( ro, rd, iTime - 3.0*a );\n\n            vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n            \n            if( i>0 )\n            {\n            dr = opUnion(dr, min(sdLine( p, p1.xy, op1.xy ), sdLine( p, p2.xy, op2.xy )), a);\n            di = opUnion(di, min(sdLine( p, p1.zw, op1.zw ), sdLine( p, p2.zw, op2.zw )), a);\n            }\n\n            op1 = p1;\n            op2 = p2;\n        }\n        \n        col = mix( col, vec3(0.0,0.7,1.2), smoothstep(1.0,0.7,dr.y)*(1.0-smoothstep(0.0,0.01,dr.x)) );\n        col = mix( col, vec3(1.2,0.7,0.0), smoothstep(1.0,0.7,di.y)*(1.0-smoothstep(0.0,0.01,di.x)) );\n    }\n\n    vec2 ro, rd; get_ray( ro, rd, iTime );\n\n    // ray\n    {\n        {\n        float d = sdLine( p, ro-rd*10.0, ro+rd*10.0 );\n        col = mix( col, vec3(1.0), 0.25*(1.0-smoothstep(0.0,0.008,d)) );\n        }\n        \n        {\n        vec2 rdp = vec2(-rd.y,rd.x);\n        vec2 tip = ro+rd*0.2;\n        float d = sdLine( p, ro, tip );\n        \n        d = min( d, sdLine( p, tip, tip + 0.05*normalize( rdp-2.0*rd) ) );\n        d = min( d, sdLine( p, tip, tip + 0.05*normalize(-rdp-2.0*rd) ) );\n      //d = min( d, sdCircle( p, ro, cth ) );\n        col = mix( col, vec3(0.75), 1.0-smoothstep(0.005,0.01,d) );\n        }\n    }\n    \n    // intersections\n    {\n        vec4 p1, p2; intersectCircle( ro, rd, rad, p1, p2 );\n\n        float dr = min( sdCircle( p, p1.xy, cth ), sdCircle( p, p2.xy, cth ) );\n        float di = min( sdCircle( p, p1.zw, cth ), sdCircle( p, p2.zw, cth ) );\n        col = mix( col, vec3(0.0,0.7,1.2), 1.0-smoothstep(0.005,0.01,dr) );\n        col = mix( col, vec3(1.2,0.7,0.0), 1.0-smoothstep(0.005,0.01,di) );\n    }\n\n    // cheap dithering\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3SDH.jpg", "access": "api", "license": "mit", "functions": [[1539, 1588, 1640, 1640, 1668], [1670, 1719, 1768, 1768, 1878], [1880, 1930, 1972, 1972, 2010], [2012, 2061, 2146, 2146, 2530], [2603, 2603, 2657, 2657, 2800], [2802, 2802, 2859, 2859, 5307]]}
{"id": "dtGSDR", "name": "Intresting Transition", "author": "bfge", "description": "An intresting transition between colors", "tags": ["transition"], "likes": 2, "viewed": 121, "published": 3, "date": "1686033909", "time_retrieved": "2024-07-30T17:51:47.148813", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n/*\n\nconst vec3 colors[9] = vec3[9](\n  vec3(1.0, 1.0, 0.0),\n  vec3(0.627, 0.627, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.627, 0.0),\n  vec3(0.0, 1.0, 1.0),\n  vec3(0.0, 0.627, 0.627),\n  vec3(0.627, 0.392, 0.0),\n  vec3(0.431, 0.2, 0.0),\n  vec3(0.0, 0.235, 0.322)\n);\n\n\nconst vec3 colors[9] = vec3[9](\n  vec3(1.0, 0.0, 0.0),   // Red\n  vec3(0.0, 1.0, 0.0),   // Green\n  vec3(0.0, 0.0, 1.0),   // Blue\n  vec3(1.0, 1.0, 0.0),   // Yellow\n  vec3(1.0, 0.0, 1.0),   // Magenta\n  vec3(0.0, 1.0, 1.0),   // Cyan\n  vec3(0.627, 0.627, 0.627),  // Gray\n  vec3(0.392, 0.0, 0.627),    // Purple\n  vec3(0.0, 0.627, 0.627)     // Teal\n);\n\n*/\n\nconst float dithering_factor = 3.0;\n\nconst int color_count = 11;\n\nconst vec3 colors[color_count] = vec3[color_count](\n  vec3(0, 0, 0),\n  vec3(0.1, 0.1, 0.1),\n  vec3(0.2, 0.2, 0.2),\n  vec3(0.3, 0.3, 0.3),\n  vec3(0.4, 0.4, 0.4),\n  vec3(0.5, 0.5, 0.5),\n  vec3(0.6, 0.6, 0.6),\n  vec3(0.7, 0.7, 0.7),\n  vec3(0.8, 0.8, 0.8),\n  vec3(0.9, 0.9, 0.9),\n  vec3(1.0, 1.0, 1.0)\n);\n\nconst int scalingFactor = 6;\n\nint getColor( in vec2 uv){\n    int val =  int(mod(uv.x + uv.y +rand(uv.xy) * dithering_factor + iTime , float(color_count)  ));\n    \n    if(val == 0 || val == color_count){\n        return int(mod(uv.x + uv.y + iTime , float(color_count)  ));\n    }\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\n    vec2 uv = (fragCoord/iResolution.xy ) * vec2(scalingFactor , scalingFactor);\n\n    // Time varying pixel color\n    vec3 col =  colors[getColor(uv)];\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 90], [1116, 1116, 1142, 1142, 1386], [1388, 1388, 1445, 1445, 1667]]}
{"id": "DlGSWz", "name": "Parametric Curve BVH SDF", "author": "fad", "description": "Using a 2D BVH as well as quadratic bezier curves to accelerate arbitrary parametric curve rendering via SDFs.", "tags": ["2d", "sdf", "bezier", "curve", "quadratic", "bvh", "parametric"], "likes": 10, "viewed": 421, "published": 3, "date": "1686028127", "time_retrieved": "2024-07-30T17:51:47.912770", "image_code": "// This shader implements two strategies for faster SDF rendering of\n// arbitrary parametric curves:\n// \n// 1. Construct a BVH (or I guess BAH for Bounding Area Heirarchy) for\n//    the parametric curve and use that to find the closest point rather\n//    than a linear search. Here I do a depth-first search to find the\n//    closest point, but a breadth-first search would be more\n//    appropriate but that is much harder to do in a fragment shader.\n//    Perhaps an iterative deepening depth-first search?\n// 2. Instead of interpolating two points on the parametric curve with a\n//    linear segment, interpolate them with a quadratic bezier segment,\n//    matching the tangent directions at the end points. This ends up\n//    being faster than linear segments for the same level of detail,\n//    but if the end tangents are misbehaved then the interpolation\n//    won't be faithful to the actual parametric curve. \n// \n// Enable/disable the BVH and switch from linear to quadratic\n// interpolation with the #defines in the Common tab.\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    return distance(ap, ab * clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0));\n}\n\nfloat sdAABB(vec2 p, vec2 a, vec2 b) {\n    vec2 d = abs(p - (a + b) / 2.0) + (a - b) / 2.0;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdParametricSegment(vec2 p, float t1, float t2) {\n#if INTERPOLATION == LINEAR\n    return sdSegment(p, f(t1), f(t2));\n#elif INTERPOLATION == BEZIER\n    vec2 p1 = f(t1);\n    vec2 p2 = f(t2);\n    return sdBezier(\n        p, p1, controlPoint(p1, p2, fDerivative(t1), fDerivative(t2)), p2\n    );\n#endif\n}\n\n#if METHOD == LINEAR_SEARCH\nfloat sdParametric(vec2 p) {\n    float minSD = MAX_FLOAT;\n    \n    for (int i = 0; i < numSamples; ++i) {\n        float t1 = mix(tMin, tMax, float(i) / float(numSamples));\n        float t2 = mix(tMin, tMax, float(i + 1) / float(numSamples));\n        minSD = min(minSD, sdParametricSegment(p, t1, t2));\n    }\n    \n    return minSD;\n}\n#elif METHOD == BVH_SEARCH\nint numTexelFetches = 0;\n\nfloat sdParametric(vec2 p) {\n    float tRange = tMax - tMin;\n    int depth = 0;\n    int pos = 0;\n    int w = textureSize(iChannel0, 0).x;\n    float minSD = MAX_FLOAT;\n    \n    while (true) {\n        int size = 1 << depth;\n        int i = size - 1 + pos;\n        vec4 aabb = texelFetch(iChannel0, ivec2(i % w, i / w), 0);\n        float sd = sdAABB(p, aabb.xy, aabb.zw);\n        \n        if (minSD <= sd || size * 2 > numSamples) {\n            if (size * 2 > numSamples) {\n                float t1 = mix(tMin, tMax, float(pos) / float(size));\n                float t2 = mix(tMin, tMax, float(pos + 1) / float(size));\n                minSD = min(minSD, sdParametricSegment(p, t1, t2));\n            }\n        \n            while (pos % 2 == 1) {\n                --depth;\n                pos /= 2;\n            }\n            \n            ++pos;\n            \n            if (depth == 0 && pos == 1) {\n                break;\n            }\n            \n            continue;\n        }\n        \n        ++depth;\n        pos *= 2;\n    }\n    \n    return minSD;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = vec4(1.0);\n    float height = 7.0;\n    float scale = iResolution.y / height;\n    vec2 p = (fragCoord - iResolution.xy / 2.0) / scale;\n    float sd = sdParametric(p) * scale - 2.0 / 2.0;\n    float spacing = 10.0;\n    float thickness = 1.0;\n    float opacity = clamp(\n        0.5 + 0.5 * thickness - \n        abs(mod(sd - (spacing - thickness) * 0.5, spacing) - spacing * 0.5), \n        0.0, 1.0\n    ) * 0.8 * exp(-sd / iResolution.y * 8.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), opacity);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), clamp(0.5 - sd, 0.0, 1.0));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LINEAR_SEARCH 1\n#define BVH_SEARCH 2\n#define METHOD BVH_SEARCH\n\n#define LINEAR 3\n#define BEZIER 4\n#define INTERPOLATION BEZIER\n\nconst float PI = 3.14159265;\nconst float MAX_FLOAT = uintBitsToFloat(0x7f7fffffu);\n\nvec2 f(float t) {\n    return \n        vec2(sin(t), cos(t)) * \n        (exp(cos(t)) - 2.0 * cos(4.0 * t) - pow(sin(t / 12.0), 5.0)) +\n        vec2(0.0, -0.7);\n}\n\nvec2 fDerivative(float t) {\n    const float h = 0.0001;\n    return (f(t + h * 0.5) - f(t - h * 0.5)) / h;\n}\n\nconst float tMin = 0.0;\nconst float tMax = 24.0 * PI;\nconst int numSamples = 512; // must be a power of 2 for BVH_SEARCH\n\nvec2 controlPoint(vec2 a, vec2 c, vec2 da, vec2 dc) {\n    // Calculate the control point for a quadratic bezier curve with end\n    // points a, c with tangent directions da, dc\n    return a + da * (inverse(mat2(da, dc)) * (c - a)).x;\n}\n\n// solveQuadratic(), solveCubic(), solve() and sdBezier() modified from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n\nint solveQuadratic(float a, float b, float c, out vec2 roots) {\n    // Return the number of real roots to the equation\n    // a*x^2 + b*x + c = 0 where a != 0 and populate roots.\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return 0;\n    }\n\n    if (discriminant == 0.0) {\n        roots[0] = -b / (2.0 * a);\n        return 1;\n    }\n\n    float SQRT = sqrt(discriminant);\n    roots[0] = (-b + SQRT) / (2.0 * a);\n    roots[1] = (-b - SQRT) / (2.0 * a);\n    return 2;\n}\n\nint solveCubic(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 where a != 0 and populate roots.\n    const float TAU = 6.2831853071795862;\n    float A = b / a;\n    float B = c / a;\n    float C = d / a;\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n    float sQ = sqrt(abs(Q));\n    roots = vec3(-A / 3.0);\n\n    if (S > 0.0) {\n        roots += -2.0 * sQ * cos(acos(R / (sQ * abs(Q))) / 3.0 + vec3(TAU, 0.0, -TAU) / 3.0);\n        return 3;\n    }\n    \n    if (Q == 0.0) {\n        roots[0] += -pow(C - A * A * A / 27.0, 1.0 / 3.0);\n        return 1;\n    }\n    \n    if (S < 0.0) {\n        float u = abs(R / (sQ * Q));\n        float v = Q > 0.0 ? cosh(acosh(u) / 3.0) : sinh(asinh(u) / 3.0);\n        roots[0] += -2.0 * sign(R) * sQ * v;\n        return 1;\n    }\n    \n    roots.xy += vec2(-2.0, 1.0) * sign(R) * sQ;\n    return 2;\n}\n\nint solve(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 and populate roots.\n    if (a == 0.0) {\n        if (b == 0.0) {\n            if (c == 0.0) {\n                return 0;\n            }\n            \n            roots[0] = -d/c;\n            return 1;\n        }\n        \n        vec2 r;\n        int num = solveQuadratic(b, c, d, r);\n        roots.xy = r;\n        return num;\n    }\n    \n    return solveCubic(a, b, c, d, roots);\n}\n\nfloat sdBezier(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 A = a - 2.0 * b + c;\n    vec2 B = 2.0 * (b - a);\n    vec2 C = a - p;\n    vec3 T;\n    int num = solve(\n        2.0 * dot(A, A),\n        3.0 * dot(A, B),\n        2.0 * dot(A, C) + dot(B, B),\n        dot(B, C),\n        T\n    );\n    T = clamp(T, 0.0, 1.0);\n    float best = 1e30;\n    \n    for (int i = 0; i < num; ++i) {\n        float t = T[i];\n        float u = 1.0 - t;\n        vec2 d = u * u * a + 2.0 * t * u * b + t * t * c - p;\n        best = min(best, dot(d, d));\n    }\n    \n    return sqrt(best);\n}", "buffer_a_code": "// BVH Construction\n\n#if METHOD == BVH_SEARCH\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int i = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    \n    if (i > numSamples * 2 - 1) {\n        return;\n    }\n    \n    int d = int(log2(float(i + 1)));\n    int n = 1 << d;\n    int j = i + 1 - n;\n    int s = numSamples / n;\n    \n#if INTERPOLATION == LINEAR\n    #define Q(x)\n#elif INTERPOLATION == BEZIER\n    #define Q(x) x\n#endif\n    \n    float t = mix(tMin, tMax, float(j) / float(n));\n    vec2 p1 = f(t);\n    Q(vec2 d1 = fDerivative(t));\n    vec2 a = p1;\n    vec2 b = p1;\n    \n    for (int k = 1; k <= s; ++k) {\n        float t = mix(tMin, tMax, float(j * s + k) / float(numSamples));\n        vec2 p2 = f(t);\n        Q(vec2 d2 = fDerivative(t));\n        Q(vec2 c = controlPoint(p1, p2, d1, d2));\n        a = min(p2, a);\n        b = max(p2, b);\n        Q(a = min(c, a));\n        Q(b = max(c, b));\n        p1 = p2;\n        Q(d1 = d2);\n    }\n    \n    fragColor = vec4(a, b);\n}\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {}\n#endif", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1040, 1040, 1081, 1081, 1199], [1201, 1201, 1239, 1239, 1352], [1354, 1354, 1409, 1409, 1659], [3133, 3133, 3185, 3185, 3838]]}
{"id": "clGSDz", "name": "Very Simple Chromatic Aberration", "author": "schmego", "description": "My first shader, inspired by this Acerola YouTube short: https://www.youtube.com/shorts/mWUjGaduj4o", "tags": ["chromaticaberration", "firstshader"], "likes": 9, "viewed": 200, "published": 3, "date": "1686026230", "time_retrieved": "2024-07-30T17:51:48.988893", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float r = 0.5;  // radius\n    float o = 0.03; // max offset\n    float s = 8.0;  // animation speed\n    \n    vec2 or = vec2(sin(-o + iTime * s), sin(-o + iTime * s));\n    vec2 og = vec2(sin(o + iTime * s), cos(o + iTime * s));\n    vec2 ob = vec2(cos(o + iTime * s), cos(-o + iTime * s));\n    \n    vec2 uv_r = uv + o * or;\n    vec2 uv_g = uv + o * og;\n    vec2 uv_b = uv + o * ob;\n\n    vec3 col_r = (uv_r.x*uv_r.x + uv_r.y*uv_r.y < r*r) ? vec3(1.0,0.0,0.0) : vec3(0.0,0.0,0.0);\n    vec3 col_g = (uv_g.x*uv_g.x + uv_g.y*uv_g.y < r*r) ? vec3(0.0,1.0,0.0) : vec3(0.0,0.0,0.0);\n    vec3 col_b = (uv_b.x*uv_b.x + uv_b.y*uv_b.y < r*r) ? vec3(0.0,0.0,1.0) : vec3(0.0,0.0,0.0);\n    \n    vec3 col = col_r + col_g + col_b;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 901]]}
{"id": "dlKSRm", "name": "spinning blur", "author": "LiamE", "description": "its cool", "tags": ["blur", "shading", "spin"], "likes": 3, "viewed": 126, "published": 3, "date": "1686007516", "time_retrieved": "2024-07-30T17:51:49.841613", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float time = iTime * 0.5;\n    vec3 c = vec3(0.0);\n\n    for (int i = 0; i < 3; i++)\n    {\n        vec3 q = vec3(p.x, p.y, time + float(i));\n        float r = length(q);\n        float a = atan(q.y, q.x) + r + sin(time + r);\n        float b = atan(q.z, length(q.xy)) + r + cos(time + r);\n\n        c += vec3(0.5 + 0.5 * cos(4.0 * a + time)),\n             vec3(0.5 + 0.5 * sin(7.0 * b - time)),\n             vec3(0.5 + 0.5 * sin(4.0 * a + 7.0 * b + time));\n    }\n\n    fragColor = vec4(c / 3.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 616]]}
{"id": "dtKXzw", "name": "reveal from corner", "author": "utku_helvaci", "description": "reveals from bottom left and upper right corners", "tags": ["periodic"], "likes": 0, "viewed": 105, "published": 3, "date": "1686006074", "time_retrieved": "2024-07-30T17:51:50.654440", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n//period times two, for 5 sec period enter 10.0\n#define PERIODTT 10.0\n#define PI 3.1415926538\nfloat a =((-sign(fract(iTime/PERIODTT)-0.5))+1.0)/2.0; //square signal from https://www.shadertoy.com/view/MtffWs\nfloat b=(cos(iTime+PI*a)+1.0)/2.0;\n\nfloat xa = iResolution.x*a;\nfloat ya = iResolution.y*a;\n\nfloat xb = iResolution.x*b;\nfloat yb = iResolution.y*b;\n\nvec2 c = abs(vec2(xa,ya)-fragCoord.xy)/vec2(xb,yb); //is it doing it like this\n//vec2 c = abs((iResolution.xy*a)-fragCoord.xy)/(iResolution.xy*b); //or this better?\n\nfragColor = vec4 (c.yxx,1.0);\n\n\n\n\n///rest is some stuff I've tried to make it black and white but can't get rid of the spike\n\n\n//vec3 mi = min (c.xxx,c.yyy);\n//vec3 ma = max (c.xxx,c.yyy);\n\n//fragColor = vec4(max(ma,mi),0.0); how can I get rid of the spike of black though?\n\n\n//some other stuff\n\n\n//fragColor = vec4(s,0.0);\n\n//fragColor = vec4(c.yxx-(c.xyy-s),0.0);\n\n\n\n//fragColor = vec4(c.xxx+c.yyy,0.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 107, 992]]}
{"id": "mlKSRw", "name": "megastructure", "author": "doriasschaerer", "description": "toa certified", "tags": ["pixel"], "likes": 1, "viewed": 163, "published": 3, "date": "1686003257", "time_retrieved": "2024-07-30T17:51:51.490206", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Scaling\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y * 0.5;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    \n    vec2 offset = vec2(sin(iTime), cos (iTime));\n    //uv += offset;\n    //uv0 += -offset;\n    \n    float time = round(iTime * 10.) / 10. ;\n\n    for (float i = 0.0; i < 8.0; i++)\n    {\n        \n        \n        uv = fract(uv*2.) -0.5;\n        \n        uv = uv * 4.0;\n        \n        uv = abs(uv);\n\n        uv.x *= 1.1;\n\n        vec3 c = vec3(sdBox(uv, vec2(3)));\n\n        vec2 sqrBox = vec2(1);\n        vec2 boxSize = vec2(0.5,0.7);\n        vec2 boxSize2 = vec2(0.7,0.5);\n        vec2 boxSize3 = vec2(0.6,0.6);\n\n        float timeStep = step(0.5, fract(iTime / 5.));\n\n        vec2 box = boxSize;\n        //box = timeStep * boxSize + (1. - timeStep) * boxSize2;\n        //box = box / i;\n        //box = vec2(sin(iTime) / 10.0 + 1.0, sin(iTime + 3.141) / 7.0 + 1.0);\n\n\n        //float sdf = min(min(sdBox(uv0, boxSize), sdBox(uv0, boxSize2)), sdBox(uv0, boxSize3));\n        float sdf = sdBox(uv0, box);\n        float sdf2 = sdBox(uv0, boxSize2);\n\n        c *= sin(sin(sdf) * 10. * (i) + iTime);\n\n        \n\n        c *= clamp(c.r ,0.0, 1.0);\n\n        c *= 0.3;\n\n        c = step(0.8, c);\n\n        finalColor += c * i;\n\n    }\n\n\n    fragColor = vec4(finalColor, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 117], [119, 119, 148, 148, 176], [177, 177, 219, 219, 400], [490, 490, 547, 561, 1857]]}
{"id": "ctKXRm", "name": "Radioaktiv", "author": "QuantumSuper", "description": "A 3D auto-VJ in a split circle theme, interacting with music.\n\n - Use with music in iChannel0 -", "tags": ["3d", "raymarching", "music"], "likes": 2, "viewed": 215, "published": 3, "date": "1685999611", "time_retrieved": "2024-07-30T17:51:52.308019", "image_code": "// Radioaktiv 0.4.230605 by QuantumSuper\n// 3d raymarched auto-vj with split ring objects\n// \n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 2.133333*iTime\n#define MAX_STEP 70\n#define MAX_DIST 80.\n#define MIN_DIST 0.02\n#define AA 1. \n\nstruct object{\n\tint type; //2: splitRing, redundant in this code\n    vec3 pos; //position\n\tvec4 param; //splitRing(outerRadius, width, depth, gapWidth)\n};\nobject[4] objects; //geometry definitions\nvec4 fft, ffts; //compressed frequency amplitudes\nint hitId; //hit object id\nvec2 myFC;\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\n// 2D Functions\nmat2 rotM2(float a){float c = cos(a), s = sin(a); return mat2(c,s,-s,c);} //2d rotation matrix\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\nfloat sd2dRing( vec2 p, float r, float w){ //ring with width w\n    r = length(p)-r; //=sdCircle\n    return max( r, min(r+w,0.));\n}\n\nfloat opExtrusion( float z, float sdf2d, float h){ //source: https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2( sdf2d, abs(z) - h);\n  \treturn min( max(w.x,w.y), 0.) + length(max(w,0.));\n}\n\n// 3D Functions\nmat3 rotMZ(float rad){ //rotation about z-axis\n    float c = cos(rad), s = sin(rad);\n    return mat3(c,s,0,-s,c,0,0,0,1);\n}\n\nfloat sdBox( vec3 p, vec3 d){ //source: https://iquilezles.org/articles/distfunctions/\n  p = abs(p) - d;\n  return length(max(p,0.)) + min(max(p.x,max(p.y,p.z)),0.);\n}\n\nfloat sd3dRing( vec3 p, vec3 d){\n    return opExtrusion( p.z, abs(sd2dRing( p.xy, d.x, d.y)), d.z);\n}\n\nfloat sdSplitRing( vec3 p, vec4 d){\n    float base = sd3dRing( p, d.xyz);\n    if (p.y<0.5) p.xy *= rotM2(sign(p.x)*4./3.*PI); //hack to save boxes, only works to some extend\n    float eraser = sdBox( p-vec3(0,d.x,0), d.wxz) - 2.*MIN_DIST;    \n    //DEBreturn min(base,eraser);\n    return max( base, -eraser);    \n}\n\n// Raymarch Functions\nfloat getDistance(vec3 p){\t\n\tfloat myDist, minDist = MAX_DIST; //max minDist\n\t\n\tfor (int n=0; n<objects.length(); n++){ //get the distance to each object\t\n        myDist = (n<3)?\n            sdSplitRing( p*rotMZ(objects[n].pos.z/16.-aTime/8.+.4*fft.x) - objects[n].pos, objects[n].param): //center rings\n            sdSplitRing( p - objects[n].pos, objects[n].param * vec4(1,1,1,1.-fft.w*texture(iChannel0,vec2(fract(.1*p.z-.2),0),0.).x)); //outer ring\n        if (myDist < minDist) minDist = myDist, hitId = n;\n    }\n    \n\treturn minDist;\n}\n\nfloat rayMarch( vec3 rayOrigin, vec3 rayDirection){ //cf. The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n\tfloat rayLength = MIN_DIST; \n\tfloat radSphere;\n\t\n\tfor (int n=0; n<MAX_STEP; n++){\n\t\tradSphere = getDistance(rayOrigin+rayLength*rayDirection); //get sphere\n\t\trayLength += radSphere; //march\n\t\tif (rayLength>MAX_DIST || abs(radSphere)<MIN_DIST) break;\n\t}\n\t\n\treturn rayLength;\n}\n\nvec3 guessNormal(vec3 pos){ //estimate the surface normal at pos\n\tvec2 tangent = vec2(.01*MIN_DIST, 0); //sensitive!\n\t\n\tvec3 normal = getDistance(pos) - vec3(\n\t\tgetDistance(pos-tangent.xyy),\n\t\tgetDistance(pos-tangent.yxy), \n\t\tgetDistance(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nfloat calcAO( vec3 pos, vec3 nor){ //see iq: https://www.shadertoy.com/view/lsKcDD\n\tfloat occ = 0.;\n    float sca = 1.;\n    \n    for (int i=0;i<5;i++){\n        float h = .001 + .15*float(i)/4.;\n        float d = getDistance( pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    \n    return clamp( 1.-1.5*occ, 0., 1.);    \n}\n\nfloat softShadow( vec3 ro, vec3 rd, float mint, float maxt, float w){ //source: https://iquilezles.org/articles/rmshadows/\n    float res = 1.;\n    float t = mint;\n    \n    for (int i=0;i<256 && t<maxt;i++){\n        float h = getDistance(ro + t*rd);\n        res = min( res, h/(w*t));\n        t += clamp( h, .005, .5);\n        if (res<-1. || t>maxt) break;\n    }\n    res = max(res,-1.);\n    \n    return .25*(1.+res)*(1.+res)*(2.-res);\n}\n\nvec3 render( vec3 pos, vec3 dir){\n    // Light initialization\n    vec3 lightPos = vec3(0,0,10);\n    vec3 lightCol = .5*vec3(sin(aTime*1.123),sin(aTime*1.234),sin(aTime*1.345)) + .5 + 0.*step(.9,fft.x);\n    lightCol = abs( cos( .06*iTime + PI/vec3(.5,2.,4.) + ffts.xyz)) + .1*step(.9,fft.x); //color shift \n    \n    // Depth calculation\n    float rayDist = rayMarch(pos,dir); \n    vec3 rayPos = pos+rayDist*dir;   \n    vec3 lightDir = normalize( lightPos-rayPos);    \n    \n    // Light modifications\n    vec3 rgbCol = vec3(ffts.y<=ffts.z,ffts.z<=ffts.x,ffts.x<=ffts.z);\n    float ringRho =  atan(rayPos.y,rayPos.x) - (objects[hitId].pos.z/16.-aTime/8.+fft.x*.4) + PI/2.;\n    lightCol *= .8+.2*texelFetch( iChannel1, ivec2(mod(1000.*(rayPos.xy+rayPos.z+iTime),256.)), 0).x; //simple noise\n    if (hitId<3) lightCol *= (cos(ringRho)>.5)? //target different segments of ring\n            .2+8.*smoothstep(.6,.9,texelFetch( iChannel0, ivec2( 0, 0), 0).x):\n        (sin(ringRho)<0.)? \n            .2+4.*smoothstep(.6,.9,texelFetch( iChannel0, ivec2( 1, 0), 0).x+texelFetch( iChannel0, ivec2( 2, 0), 0).x):\n            .2+2.*smoothstep(.6,.9,texelFetch( iChannel0, ivec2( 3, 0), 0).x+texelFetch( iChannel0, ivec2( 4, 0), 0).x+texelFetch( iChannel0, ivec2( 5, 0), 0).x);\n    if (hitId==3) lightCol *= .08; //dim outer ring\n    if (hitId==3 && length(rayPos.xy)<2.3) lightCol += .5 * rgbCol * pow(texture( iChannel0, vec2(fract(rayPos.z*.1-.2),0), 0.).x,6.); //sound texture light   \n    \n    // Shadows\n    vec3 surfNormal = guessNormal(rayPos);\n    float amp = clamp( dot(lightDir, surfNormal), 0., 1.) * softShadow( rayPos, lightDir, MIN_DIST, MAX_DIST, .5); \n    vec3 col = lightCol * amp;\n    \n    // Light speck\n    vec3  halo = normalize( lightDir-dir );\n    float speck = (.1+.9*pow( clamp( dot(surfNormal,halo),0.,1.), 16.)) * amp * (.04+.96*pow( clamp(1.0+dot(halo,dir),0.,1.), 5.));  \n    col+= lightCol * speck;\n    \n    // Ambient light\n    amp = clamp( .5+.5*surfNormal.y, 0., 1.) * calcAO( rayPos, surfNormal);\n    col += lightCol * amp * (.04+.01*rgbCol);\n        \n    // Fog\n    col *= exp(-1e-4*rayDist*rayDist*rayDist); //simple distance based attenuation\n    \n    // Background\n    if (rayDist>=MAX_DIST) col = .2 * fft.z \n        * abs(cos(.06*iTime + PI/vec3(.5,2.,4.) + ffts.xyz)) //base color shift\n        * clamp(abs(myFC.y/iResolution.y-.7*fft.xyz),0.,1.) //vertical color shift\n        * (2.-3.*length(myFC/iResolution.xy-.5)) //simple vignette\n        * (.3-(texelFetch(iChannel0,ivec2(int(1024.*abs(myFC.x/iResolution.x-.5)),0),0).x - 2.*abs(myFC.y/iResolution.y-.5))); //inverted xy-mirror sound texture\n    \n    // Utility\n    //col = .06*vec3(rayPos); //depth map\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    compressFft(); //initializes fft, ffts\n    myFC = fragCoord;\n    \n    // Camera initialization\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1\n    vec3 camPos = vec3(.8*cos(aTime/8.),0,0);\n    vec3 camDir = normalize(vec3(uv.x, uv.y, 1)); //static straight\n\t\n\t// Object initializations\n    float ringDist = 16.,\n          ringSpeed = -.3 * (fft.x + aTime);\n    vec4 ringDef = vec4(2.,.8,.3,.4);\n    objects = object[](\n\t\tobject(2, vec3(0,0,ringDist*(0.+fract(ringSpeed))-.2), ringDef), // ring 1\n        object(2, vec3(0,0,ringDist*(1.+fract(ringSpeed))-.2), ringDef), // ring 2\n        object(2, vec3(0,0,ringDist*(2.+fract(ringSpeed))-.2), ringDef), // ring 3\n        object(2, vec3(0,0,1.5-4.5*cos(aTime/8.-ffts.w+1.)), vec4(16.,13.7,6.,1.)) // ring outer 1\n        );\n    \n    // Render\n    vec3 col = vec3(0); \n    for(float m=0.;m<AA;m++) //simple antialiasing (for AA>=2.)\n        for(float n=0.;n<AA;n++)\n            col += render(camPos+vec3(m,n,.0)*length(camPos.xy)/iResolution.x,camDir); //sloppy pixel estimation     \n    col /= AA*AA;\n    \n    // Finalizations\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33544, "src": "https://soundcloud.com/ms-kd/narcisstic-people", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 569, 660, 1780], [1782, 1798, 1818, 1818, 1871], [1894, 1894, 1930, 1989, 2193], [2195, 2195, 2237, 2257, 2325], [2327, 2327, 2377, 2434, 2529], [2531, 2547, 2569, 2593, 2670], [2672, 2672, 2701, 2758, 2838], [2840, 2840, 2872, 2872, 2941], [2943, 2943, 2978, 2978, 3257], [3259, 3281, 3307, 3307, 3822], [3824, 3824, 3875, 3943, 4220], [4222, 4222, 4249, 4286, 4513], [4515, 4515, 4549, 4597, 4853], [4855, 4855, 4924, 4977, 5289], [5291, 5291, 5324, 5352, 8000]]}
{"id": "DlVSRm", "name": "Late night truchet hacking", "author": "mrange", "description": "CC0: Late night truchet hacking\nContinued a bit on the braided truchets\nTinkered around and liked the result\nCode is dirty and it is getting late\n", "tags": ["2d", "truchet"], "likes": 19, "viewed": 282, "published": 3, "date": "1685999599", "time_retrieved": "2024-07-30T17:51:53.235539", "image_code": "// CC0: Late night truchet hacking\n//  Continued a bit on the braided truchets\n//  Tinkered around and liked the result\n//  Code is dirty and it is getting late\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat octogon(vec2 p, float r ) {\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\nvec3 braid(vec3 col, vec2 p, vec2 cp, float z, float aa) {\n  const float reps  = 32.0;\n  const float a     = TAU/reps;\n  const float bsz0  = a*0.3;\n  const mat2 rot2   = ROT(a*0.5);\n  const float sa    = a*-0.12;\n  const mat2 rot22   = ROT(sa);\n  const float bw    = 0.04;\n  const vec2 bp0 = -vec2(-0.5, 0.0);\n  const vec2 p00 = bp0*transpose(rot2);\n  const vec2 p01 = bp0*rot2;\n  const vec2 bp1 = -vec2(-0.5/cos(0.5*a+sa), 0.0);\n  const vec2 p10 = bp1*rot22;\n  const vec2 p11 = bp1*transpose(rot22);\n\n  float cd = length(cp)-0.5;\n  vec2 pp = cp;\n\n  pp *= rot2;\n  float n = modPolar(pp, reps);\n\n  float bd0 = segment(pp, p00, p10)-bw;\n  float bd1 = segment(pp, p01, p11)-bw;\n  bd0 = abs(bd0)-0.25*bw;\n  bd1 = abs(bd1)-0.25*bw;\n\n  float h = hash(n + 123.4);\n  if (sign(h-0.5)*cd > 0.) {\n    float tmp = bd0;\n    bd0 = bd1;\n    bd1 = tmp;\n  }\n\n  const float shd = 175.0;\n  col *= 1.0-exp(-shd*max(bd0, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, bd0));\n  col *= 1.0-exp(-shd*max(bd1, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, bd1));\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float l = length(p);\n  const float pr = 10.0;\n  const float z = 1.0-0.25;\n  p /= z;\n\n  p *= ROT(0.05*TIME);\n  float n = smoothKaleidoscope(p, 0.075, 64.0);\n  p *= ROT(-0.05*TIME);\n  p += pr*sin(0.125*vec2(1.0, sqrt(0.5))*TIME/pr);\n\n  float aa = 4.0/(z*RESOLUTION.y);\n\n\n  vec2 cp = p;\n  vec2 np = round(cp);\n  float nh0 = hash(np+123.4);\n  cp -= np;\n  \n  if (nh0 > 0.5) cp = cp*ROT(PI/2.0);\n\n  vec3 col = vec3(0.1)*smoothstep(2.0, 0.0, l);\n  vec2 op = cp;\n  op = abs(op);\n  op -= 0.5;\n  float od1 = octogon(op, 1.0/6.0);\n  od1 = abs(od1)-1./16.0;\n  od1 = abs(od1)-1./32.0;\n  od1 = abs(od1)-1./96.0;\n  float od0 = length(op)-1.0/3.0;\n  \n  const float shd = 25.0;\n  col *= 1.0-exp(-shd*0.5*max(od0, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, od0));\n  col *= 1.0-exp(-shd*max(od1, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, od1));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, abs(od0)-0.011));\n  vec2 bp = cp;\n  float bn = ref(bp, normalize(vec2(1.0)));\n  bp -= 0.5;\n  col = braid(col, p, bp, z, aa);\n  col *= smoothstep(1.75, 0.5, length(pp));\n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 426, 471, 471, 625], [627, 713, 762, 762, 1161], [1163, 1223, 1245, 1245, 1293], [1295, 1355, 1376, 1376, 1446], [1448, 1548, 1587, 1587, 1672], [1674, 1674, 1704, 1704, 1732], [1734, 1852, 1885, 1885, 2169], [2171, 2289, 2328, 2328, 2447], [2449, 2449, 2471, 2471, 2515], [2517, 2517, 2538, 2538, 2579], [2581, 2669, 2730, 2730, 2943], [2945, 2945, 2978, 2978, 3059], [3061, 3061, 3119, 3119, 4133], [4135, 4135, 4165, 4165, 5276], [5278, 5278, 5335, 5335, 5510]]}
{"id": "DlGXzw", "name": "GLSL bug #65", "author": "FabriceNeyret2", "description": "left and right differs on OpenGL chrome while shouldn't.   ok on Windows, ok on OpenGL FF.\nBug occurs line 11: p,y-= is compiled as p -=\nTry switching #if line 9: then it works.\nbug report: https://bugs.chromium.org/p/chromium/issues/detail?id=1394345", "tags": ["glsl", "bug"], "likes": 1, "viewed": 211, "published": 3, "date": "1685985563", "time_retrieved": "2024-07-30T17:51:54.135134", "image_code": "// acid test from \"Broken initialization\" by kishimisu. https://shadertoy.com/view/clKXRR\n\nvoid mainImage(out vec4 I, vec2 u) {\n\n    vec2 R = iResolution.xy,\n         p =  u/R;\n   \n    float T = iTime, a;\n#if 1                      // \n    if (u.x <  R.x/2. )    // left: on OpenGL Chrome, it does p -= !\n        p.y -= T = iTime;\n    else                   // right\n        p.y -= T;\n#else\n    a = p.y;               // this form works\n    if (u.x <  R.x/2. )    // left\n        a -= T = iTime;\n    else                   // right\n        a -= T;\n    p.y = a;\n#endif\n\n    I = vec4(p,0,1);     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 127, 127, 596]]}
{"id": "ctGSRw", "name": "Distorted wavy bars", "author": "BaldPolnareff", "description": "Another test, again", "tags": ["waves", "distortion"], "likes": 0, "viewed": 160, "published": 3, "date": "1685983199", "time_retrieved": "2024-07-30T17:51:54.933998", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Calculate the bar width\n    float barWidth = .3 / float(iResolution.x) * 10.0;\n\n    // Calculate the bar height using a sine wave\n    float barHeight = (sin(uv.x * 12.0 + iTime) + 1.) * .5;\n\n    float radius = length(uv);\n    // Create a time-dependent wave effect\n    float wave = sin(iTime * 1.5 + radius * 1.0);\n    uv *= 2.*mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    uv *= .4;\n    float f = 1.;\n\n    for (float i = 0.5; i < 5.2; i++) {\n        f += sin(uv.x * 12.0 + iTime * .2 + i * 1.5) * .5;\n        // Calculate the position of the bar\n        vec2 barPos = f * vec2(uv.x, barHeight);\n\n        // Apply color based on the bar position\n        vec3 color = vec3(barPos.x, barPos.y, 1.0 + barPos.y);\n\n        // Draw the bar chart\n        float chart = f * smoothstep(barPos.y, fract(barPos.y * 2.) + 2.* barWidth, fract(uv.y * 12.));\n\n        // Apply animation to the chart\n        chart *= sin(iTime * .02 + barPos.x * 24.0) * .5 + 3.5;\n\n        // Apply color to the chart\n        color *= 1.1*chart;\n        // Set the final color\n        fragColor = vec4(color, 1.0);\n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 84, 1242]]}
{"id": "dlGSRz", "name": "Testproject - Waradu", "author": "Waradu", "description": "Testproject", "tags": ["circles", "colors", "gradient"], "likes": 7, "viewed": 194, "published": 3, "date": "1685979306", "time_retrieved": "2024-07-30T17:51:55.685987", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.4);\n    vec3 b = vec3(0.7);\n    vec3 c = vec3(0.8);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(1.0);\n    \n    for (float i = 3.0; i > 0.0; i--) {\n        uv *= 1.5;\n        uv = fract(uv);\n        uv -= 0.5;\n\n        float d = length(uv) * exp(-length(uv0)+0.5);\n\n        vec3 col = palette(length(uv0) + i*0.6 + iTime*0.6);\n\n        d = sin(d*8.-iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.1);\n\n        finalColor -= col * d;\n    }\n    \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 185], [187, 187, 244, 244, 765]]}
{"id": "ctVSRD", "name": "playingaroundtutorial", "author": "kkragoth", "description": "https://www.youtube.com/watch?v=f4s1h2YETNY&ab_channel=kishimisu", "tags": ["tutotiral"], "likes": 0, "viewed": 143, "published": 3, "date": "1685976160", "time_retrieved": "2024-07-30T17:51:56.663375", "image_code": "vec3 pal( in float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 0.7, 0.4);\n    vec3 d = vec3(0.0, 0.15, 0.2);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 color = vec3(0.0);\n\n    \n    for (float i = 0.0; i < 4.0; i++) {\n    \n        float r = 2.25;\n        uv = fract(sin(uv + uv0 * r) * 1.25) - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = pal(d + iTime);\n\n        d = sin(d*16. + iTime) / 16.;\n        d = abs(d);\n\n        // d = smoothstep(0.0, 0.1, d);\n        d = 0.00009 / (d * d);\n\n        color += col * d * d;\n     }\n     \n    float d = length(uv);\n     \n    // color.r += d * sin(iTime);\n\n\n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 204], [207, 207, 264, 314, 948]]}
{"id": "ml3SWl", "name": "square grid", "author": "silica163", "description": "simple square grid", "tags": ["grid", "square"], "likes": 1, "viewed": 191, "published": 3, "date": "1685975762", "time_retrieved": "2024-07-30T17:51:57.715561", "image_code": "vec4 grid(vec2 uv,float s){\n    vec2 ouv = uv;\n    uv = mod(uv*s,1.);\n    vec2 id = floor(ouv*s)/s;\n    return vec4(uv*2.-1.,id+1./s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec4 sg = grid(uv*.7,32.);\n    col *= step(abs(sg.x),.9) * step(abs(sg.y),.9);\n    //col *= (sg.z -sin(sg.w*256.+iTime))*(sg.w -sin(sg.z*512.+iTime));\n    col.r += sg.w - sin(sg.z*128.+iTime);\n    col *= step(abs(sg.x),.9) * step(abs(sg.y),.9);\n    col.g += sg.w - sin(sg.z*64.+iTime);\n    col *= step(abs(sg.x),.9) * step(abs(sg.y),.9);\n    col.b += sg.w - sin(sg.z*256.+iTime);\n    col *= step(abs(sg.x),.9) * step(abs(sg.y),.9);\n    \n    \n    //col += step(abs(sg.x),.9) * step(abs(sg.y),.9) * (sg.z -sin(sg.w*1024.-iTime))*(sg.w -sin(sg.z*256.+iTime)); \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3SWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 136], [138, 138, 195, 195, 905]]}
{"id": "dtyXzD", "name": "Amoeba Lichen 2", "author": "tomachi", "description": "Click in the centre somewhere.\nThis has a life algorithm but is tainted by also allowing it to migrate to \"greener\" pixel pastures.", "tags": ["colors", "automata", "screensaver", "colours", "gameoflife", "fading", "gol"], "likes": 0, "viewed": 154, "published": 3, "date": "1685975303", "time_retrieved": "2024-07-30T17:51:58.767747", "image_code": "#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n\n/*\nchannels:\nBuffer A - Cells states\nBuffer B - background trails\nBuffer C - density mask ( used to fill blanks mid-game)\n*/\nvec4 sand(in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec4 part = texture(iChannel3,uv);\n\tfloat c = step(0.1,part.x);\n\tvec3 col=vec3(1.,.9,.8)*c*(1.-abs(uv.x-.5));\n    vec4 fragColor = vec4(col,1.);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float A = tex0(uv) *0.03* iTime;\n    float B = tex1(uv) *0.004* iTime;\n    float C = tex2(uv) *0.04* iTime;\n    float D = tex3(uv) *0.04* iTime;\n  \n    fragColor = vec4(A*20. + (B*0.09413), (A*0.65)+B*0.2,(A*0.125)+ 0.15+ (B*0.00013)+D,1.) + vec4(D);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n#define R iResolution.xy\n\n/*float checkPixel(float col, float value) // mapping function\n{\n    if (value >= 0.90001) {\n        return col + value;\n    } else {\n        return 0.;\n    }\n}*/\nbool isHerbivore(vec2 uv) {\n    if (tex0(uv) > 0.1) { return true; } else { return false; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    float brightest = 0.;\n    float veges = tex1(uv);\n    float col = tex0(uv);\n    float D = tex3(uv);\n\n    if (iFrame == 1) { \n      col = sin(uv.x);\n      fragColor = vec4(sin(uv.x),sin(uv.y), sin(uv.x*uv.y), 1.0);\n      return;\n    }\n\n\n\n    int n = 0; // game of life logics\n    float amoeba = 0.; // amoeba logic\n    float onepix = p.x;\n    float twopix = onepix * 2.;\n\n    vec2 lup   = vec2(uv.x-p.x, uv.y-p.y);\n    vec2 ldown = vec2(uv.x-p.x, uv.y+p.y);\n    vec2 rup   = vec2(uv.x+p.x, uv.y-p.y);\n    vec2 rdown = vec2(uv.x+p.x, uv.y+p.y);\n\n    vec2 left = vec2(uv.x+p.x, uv.y);\n    vec2 right= vec2(uv.x-p.x, uv.y);\n    vec2 up   = vec2(uv.x, uv.y-p.y);\n    vec2 down = vec2(uv.x, uv.y+p.y);\n\n    // count neighbours\n    n += int(tex(lup));\n    n += int(tex(ldown));\n    n += int(tex(rup));\n    n += int(tex(rdown));\n\n    n += int(tex(left));\n    n += int(tex(right));\n    n += int(tex(up));\n    n += int(tex(down));\n\n    if(col > 0.1 && n == 3) col += 0.5; // rebirth\n  // else if(col > 0.00094 && !(n == 2 || n == 3)) col = 0.; // overcrowd death\n       if (abs(col)>0.95)  { col = 0.; }\n       \n    // if the cell at 180 degrees around from herbi is not better move here\n    // if to the left, theh check 2 pixels to the left\n\n    if (isHerbivore(lup)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y - twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(ldown)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y + twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rup)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n        //  col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rdown)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n\n    if (isHerbivore(left)) { // left\n      if(veges > tex1(vec2(uv.x - twopix, uv.y))) {\n         col += tex1(vec2(uv.x - twopix, uv.y));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(right)) { // right\n      if(veges > tex1(vec2(uv.x + twopix, uv.y))) {\n          col += tex1(vec2(uv.x + twopix, uv.y));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(up)) { // up\n      if(veges > tex1(vec2(uv.x, uv.y - twopix))) {\n          col += tex1(vec2(uv.x, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(down)) { // down\n      if(veges > tex1(vec2(uv.x, uv.y + twopix))) {\n          col += tex1(vec2(uv.x, uv.y + twopix));\n      } else { col = 0.0061; }\n    }\n             \n  \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.)) {\n    \tfragColor += vec4(uv,0,0);\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n        return;\n    }\n     if (iFrame <= 1 ) {\n         if (length(vec2(0.5,0.5) - uv.xy) < 64.) {\n          col = 0.935 + uv.x + uv.y;\n         }\n        return;\n     }\n  \n    fragColor = vec4(vec3(col), 1.0);\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float A = tex0(uv);\n    float B = tex1(uv);\n    float D = tex3(uv);\n\n    float amoeba = 0.;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n\n    B-=A*0.05125;\n    if(iFrame < 2 && texture(iChannel1, uv).x<1. && roughNoise2(uv*3., 7, .5, uint(iTime/2.)) >= .7) // fill blank space with cells\n    {\n       B-=0.00651;\n    //   B+=D * 0.0651;\n\n    }\n\n    \n    //    B *= 1.001;\n     //   B *= 0.99;\n        amoeba += tex1(vec2(uv.x-p.x, uv.y-p.y));\n        amoeba += tex1(vec2(uv.x-p.x, uv.y+p.y));\n        amoeba += tex1(vec2(uv.x+p.x, uv.y-p.y));\n        amoeba += tex1(vec2(uv.x+p.x, uv.y+p.y));\n        amoeba += tex1(vec2(uv.x+p.x, uv.y));\n        amoeba += tex1(vec2(uv.x-p.x, uv.y));\n        amoeba += tex1(vec2(uv.x, uv.y-p.y));\n     //  amoeba += tex1(vec2(uv.x, uv.y+p.y));\n        B += amoeba*0.000951951; \n    if (B > 0. &&  B < 0.91) { B *= 0.000001; }\n    B = abs(B);\n    B = clamp(B, 0., 10.);\n    if (D > 0.5) B += 0.9;\n\n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.) || iFrame < 1) {\n    \tfragColor += vec4(uv,0,0);\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n      //  return;\n    }\n\n    if (iFrame <1 ) {\n        fragColor = vec4(0.0075) ;\n        return;\n     }\n\n    fragColor += vec4(vec3(B),1.0);\n\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nuint seed2 = uint(0);\nfloat r(uint s)  // random float\n{\n    return float(Hash(s)) / 4294967295.0;\n}\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r(uint(p.x*100.));\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\nfloat roughNoise1(vec2 uv, int depth, float roughness, uint s)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(s), 5.754*r(s)); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness, uint s)\n{\n    uv += vec2(27.238*r(s), 16.162*r(s+uint(1)));\n\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(s+uint(2)), 5.754*r(s+uint(3))); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}", "buffer_c_code": "#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   /*  if (iFrame <3 ) {\n        fragColor = vec4(10.75) -  vec4(fragCoord,fragCoord.x,fragCoord.y);\n        return;\n     }*/\n\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy, 6.)-3.00000000000000079;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A 7\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\nfloat hash(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check if there is an arriving particle at this pixel in next frame\nfloat arrivingParticle(vec2 coord, out vec4 partData, vec2 uv) {\n\t// scan area from -D to D\n    for (int i=-A; i<A; i++) {\n        for (int j=-A; j<A; j++) {\n            // position to check\n            vec2 arrCoord = coord + vec2(i,j);\n            vec4 data = texture(iChannel3, arrCoord/iResolution.xy);\n            \n            // no particles here\n            if (dot(data,data)<.9991) continue;\n\n            // get next position of particle\n            vec2 nextCoord = data.xy + data.zw;\n\n            // distance between next position and current pixel\n            vec2 offset = abs(coord - nextCoord);\n            // if the distance is within half a pixel pick this particle\n            // (other arriving particles are dismissed)\n            if (offset.x<.5 && offset.y<.5) {\n                partData = data;\n                return 1.;\n            }\n        }\n    }\n    // no particles arriving here\n\treturn 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n \t// random particles at the top, xy is position, zw velocity\n    if (fragCoord.y>iResolution.y-1.) {\n        fragColor = vec4(fragCoord.xy,(hash(uv+iTime)-.8)*10.,-6.+hash(uv)); \n        return;\n    }\n   \n    // get the data of a particle arriving at this pixel \n    vec4 partData;\n    float p = arrivingParticle(fragCoord, partData, uv);\n\n    // no particles, empty pixel\n    if (p<1.) {\n    \tfragColor = vec4(0.);\n        return;\n    }\n    \n    // update position with current velocity altered by channels r & b in the video\n    float vel=max(0.,1.-length(texture(iChannel1,fragCoord/iResolution.xy).rb)*.035);\n    partData.xy+=partData.zw*vel;\n\n     if (iFrame <3 ) {\n        fragColor += vec4(1.75);\n        return;\n     }\n\n    //set particle data\n    fragColor = partData;\n}", "buffer_d_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 302, 333, 333, 544], [545, 545, 602, 602, 902]]}
{"id": "DlySR1", "name": "fhr_kishimisu1", "author": "fhr", "description": "yes", "tags": ["video"], "likes": 1, "viewed": 48, "published": 3, "date": "1685965626", "time_retrieved": "2024-07-30T17:51:59.527715", "image_code": "vec3 palette( in float t)\n{\n    return vec3(0.236, 0.180, 0.588) + vec3(0.680, 0.434, 0.608)*cos(6.28318*(vec3(0.878, 1.347, 1.088)*t+vec3(4.224, 5.675,4.809)));\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.);\n    \n    for (float i = 0.; i<3.; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = sdOctogon(uv, 0.25) * exp(-length(uv0));\n\n        vec3 col = palette(sin(length(uv0)) + iTime/6. + i*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n        d = pow(0.01 / d, 1.12);\n\n\n        finalColor += col * d * abs(sin(iTime/16. + i*8.12));\n    }\n    \n    fragColor = vec4(finalColor, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlySR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 163], [165, 165, 207, 207, 491], [493, 493, 550, 550, 1071]]}
{"id": "mtGSRW", "name": "drip drip", "author": "jauska", "description": "geometry", "tags": ["triangles"], "likes": 4, "viewed": 141, "published": 3, "date": "1685963121", "time_retrieved": "2024-07-30T17:52:00.594862", "image_code": "#define PI 3.1415926538\n#define N 3.0 // 4 and 6 are also interesting\n\n//[[0.788 0.388 1.458] [0.978 0.648 1.598] [-0.392 0.228 -0.392] [1.428 3.686 0.608]]\n//[[0.979 0.633 0.776] [0.419 0.590 0.419] [0.632 0.529 0.853] [5.304 5.969 3.875]]\nvec3 palette( float t ) {\n    vec3 a = vec3(0.979, 0.633, 0.776);\n    vec3 b = vec3(0.419, 0.590, 0.419);\n    vec3 c = vec3(0.632, 0.529, 0.853);\n    vec3 d = vec3(5.304, 5.969, 3.875);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float theta = atan(uv.x, uv.y);\n    float r = 2.0 * PI / N;\n    // dist from centre, for large triagle, moving up and down\n    float dist = 1.0 - cos(floor(0.5 + theta / r) * r - theta) * length(uv + vec2(0.0, sin(iTime * .5)));\n    \n    uv = fract(uv * 2.2) - .5;\n    theta = atan(uv.x, uv.y);\n    vec3 col = palette(dist);\n    // relative distance\n    float d = 1.0 - cos(floor(0.5 + theta / r) * r - theta) * length(uv);\n    d = sin(d*16. + iTime*4.0)/16.;\n    d = abs(d);\n    d = pow(0.02 / d, 1.1);\n    col = smoothstep(.9,.95, col*d);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 241, 266, 266, 470], [472, 472, 529, 529, 1174]]}
{"id": "DlySRD", "name": "red", "author": "571574085", "description": "", "tags": ["red"], "likes": 0, "viewed": 117, "published": 3, "date": "1685959068", "time_retrieved": "2024-07-30T17:52:01.535348", "image_code": "// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n      \n    float d= sdRoundBox(p,vec2(1.2,0.5),vec4(0.25));\n    vec3 col = mix(vec3(0.0), vec3(1.0, 0.0, 0.0)* abs(sin(iTime*2.5))* (d / 1.5), d > 0.0 ? 1.0 : 0.0);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlySRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 154, 208, 208, 365], [368, 368, 425, 425, 684]]}
{"id": "dtVSzh", "name": "cosmic church window", "author": "jauska", "description": "my first thing", "tags": ["fractal"], "likes": 8, "viewed": 184, "published": 3, "date": "1685942009", "time_retrieved": "2024-07-30T17:52:02.487801", "image_code": "/* \nmy first thing, forked from https://www.shadertoy.com/view/mtyGWy\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.657, 0.690, 0.569);\n    vec3 b = vec3(0.619, 0.117, 0.156);\n    vec3 c = vec3(1.304, 0.977, 0.246);\n    vec3 d = vec3(0.974, 4.653, 2.999);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 16.0; i++) {\n        uv = fract(uv * 1.1) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*0.14 + iTime* 0.1);\n\n        d = sin(d*32. + iTime * 0.5)/32.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.1);\n\n        finalColor += smoothstep(0.05,0.95, col * d) * 0.01 * i;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVSzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 118, 143, 143, 347], [349, 349, 406, 406, 939]]}
{"id": "clVXR1", "name": "pulsating circles", "author": "ravenstargames", "description": "just screwing arround lol", "tags": ["pulse", "circle"], "likes": 0, "viewed": 140, "published": 3, "date": "1685936386", "time_retrieved": "2024-07-30T17:52:03.376427", "image_code": "float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 8.0 * (sin(iTime) + 64.0)/ 64.0;\n    float l = fract(length(uv) * 4.0);\n    \n    uv -= 0.5;\n    //pulse\n    vec2 pr = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat dr = sdCircle(pr,sin(l*11.70*8.0 + iTime)/8.0);\n    \n    //circle\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat d = sdCircle(p,sin(l*8.0 + iTime)/8.0);\n    d = fract(d);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col -= abs(l) + smoothstep(0.01,0.2,abs(d));\n    col += 0.8 + 0.2*cos(150.0*d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [65, 65, 94, 94, 122], [124, 124, 181, 231, 879]]}
{"id": "ctVXzh", "name": "Pulsing Star901", "author": "AiHeadHunter", "description": "Pulsing Star", "tags": ["pulsingstar"], "likes": 2, "viewed": 124, "published": 3, "date": "1685933396", "time_retrieved": "2024-07-30T17:52:04.131407", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalized pixel coordinates from 0 to 1\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0.2,2,4));\n\n    // Calculate the exploding star fractal\n    float fractal = 0.0;\n    vec2 pos = uv;\n    for (int i = 0; i < 10; i++) {\n        pos *= 2.0;\n        fractal += 0.5 / (1.0 + dot(pos, pos));\n    }\n\n    // Output to screen\n    fragColor = vec4(col * fractal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 104, 502]]}
{"id": "clKXzh", "name": "Gradient with added noise", "author": "AiHeadHunter", "description": "Gradient with added noise", "tags": ["colors"], "likes": 1, "viewed": 142, "published": 3, "date": "1685932957", "time_retrieved": "2024-07-30T17:52:05.275349", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalized pixel coordinates from 0 to 1\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0.5, 1.618, 4.236));\n\n    // Add random fractal\n    col += 0.2 * fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n    // Zoom in and move\n    vec2 center = vec2(0.5, 0.5) + 0.5 * sin(iTime);\n    vec2 offset = uv - center;\n    float zoom = 0.5 + 0.5 * sin(iTime * 0.5);\n    vec2 uv2 = center + zoom * offset;\n\n    // Add exploding colors and designs\n    col += 0.2 * fract(sin(dot(uv2.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    col += 0.2 * fract(sin(dot(uv2.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    col += 0.2 * fract(sin(dot(uv2.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 104, 874]]}
{"id": "DtKXRh", "name": "goopy inferno", "author": "jackwitherell", "description": "i kinda just stopped paying attention while i was making this\ncode is unreadable it just does things", "tags": ["plasma", "abstract", "glowing", "goopy"], "likes": 2, "viewed": 172, "published": 3, "date": "1685928954", "time_retrieved": "2024-07-30T17:52:06.072217", "image_code": "vec2 uver(vec2 fragCoord, vec3 iResolution, sampler2D image){\n    vec2 uv = (fragCoord/iResolution.xy)-vec2(0.5,0.0);\n    uv *= vec2(2.0,1.0);\n    vec3 offs = texture(image, uv, 1.0).rgb;\n    return (uv *( vec2((uv.y*20.0)+(1.0-uv.y)*4.0, 10.0))/5.0)+offs.xy;\n}\n\nvec3 colrotate(sampler2D img, vec2 uv, float iTime, float rotfactor){\n    vec3 col = texture(img, uv+vec2(0.0,iTime/30.0),1.0).rgb;\n    vec3 colout = vec3(0.7,0.5,0.7)-col;\n    return mix(col.rrg, colout, rotfactor)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 maxcol = colrotate(iChannel0, uver(fragCoord, iResolution, iChannel0), iTime, 1.0)-0.8;\n    float height = maxcol.g;\n    int itercount = 30-int((height)*30.0);\n    int iter = itercount;\n    for (int i=0; i<iter; i++){\n        vec3 currcol = colrotate(iChannel0, uver(fragCoord+vec2(0.0,i), iResolution, iChannel0), iTime, 1.0);\n        bool higher = currcol.g<height;\n        if(higher){\n            maxcol = currcol;\n            height = currcol.r;\n        }\n    }\n    vec3 col = maxcol;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 261], [263, 263, 332, 332, 485], [487, 487, 544, 544, 1100]]}
{"id": "dtGSz1", "name": "dawn of the squares", "author": "theki", "description": "HELLO this is my very first shader. i still have no idea what im doing but messing around with these is fun", "tags": ["abstract", "trippy", "squares"], "likes": 1, "viewed": 147, "published": 3, "date": "1685923767", "time_retrieved": "2024-07-30T17:52:06.920948", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nvec3 pal(float t) {\n    vec3 a = vec3(0.248, 0.138, 0.500);\n    vec3 b = vec3(-0.172, 0.058, 0.338);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(-0.442, -1.002, 0.058);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    uv = fract(uv*2.0) - 0.5;\n\n    float d = sdBox(uv, vec2(0.3, 0.3));\n    vec3 col = pal(d + iTime);\n    \n    d = sin(d*80.0 + iTime/2.0)/80.0;\n    //d = 0.001 / d;\n    d = (cos(iTime)+1.0)/1000.0 / d;\n\n    col *= d;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 117], [118, 118, 137, 137, 338], [339, 339, 396, 396, 717]]}
{"id": "dtyXzh", "name": "Impermanence and insight", "author": "maxwellcoffee", "description": "Embrace impermanence ", "tags": ["psychedelic"], "likes": 0, "viewed": 111, "published": 3, "date": "1685920269", "time_retrieved": "2024-07-30T17:52:08.164623", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.01, 1.0, 1.0);\n    vec3 d = vec3(1.263, 0.416, 0.557);\n\n    return a + b*cos(0.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    float time = iTime + 19.;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * tan(time)) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + time*.4);\n\n        d = tan(d*8. + time)/8.;\n        d = abs(d);\n\n        d = pow(.2 / d, 1.2);\n\n        finalColor += col * d;\n    }\n    \n    fragColor =  vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 210], [212, 212, 269, 269, 784]]}
{"id": "DlGXR1", "name": "Introduction by kishimisu #2", "author": "grey_", "description": "This shader is made with \"An introduction to Shader Art Coding\" by kishimisu. Check out the video and their channel @ https://www.youtube.com/watch?v=f4s1h2YETNY <3", "tags": ["neon"], "likes": 1, "viewed": 112, "published": 3, "date": "1685914683", "time_retrieved": "2024-07-30T17:52:09.033300", "image_code": "// Cosine-based palette function by Inigo Quilez\n// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t) {\n    // Colors from: http://dev.thi.ng/gradients/\n    // [[0.660 0.560 0.680] [0.337 0.206 0.448] [0.536 0.824 0.536] [-0.393 -0.393 0.107]]\n    vec3 a = vec3(.860, .560, .680);\n    vec3 b = vec3(.337, .206, .448);\n    vec3 c = vec3(.536, .124, .536);\n    vec3 d = vec3(-.393, -.393, .107);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Almost 100% on \"An introduction to Shader Art Coding\" by kishimisu\n// https://www.youtube.com/watch?v=f4s1h2YETNY\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Square variant\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Original uv, without tiling.\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.);\n\n    for(float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * pow(1.5, 1.6)) - .5;\n\n        float d = length(uv) + 9. * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * .4 + iTime * .4);\n\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n\n        // Reduce this further for interesting effects.\n        d = pow(0.01 / d, 1.1);\n\n        finalColor += col * d * sin(palette(max(abs(uv.x), abs(uv.y) * uv0.x))) * 1.9;\n    }\n\n    // The final output color of the current fragment pixel is set as a combination of the previously calculated color ('col')\n    // and a dynamically calculated brightness value ('d'). It is then sent to the buffer as well.\n    fragColor = vec4(finalColor, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 120, 260, 459], [461, 578, 633, 724, 1612]]}
{"id": "mtVXzz", "name": "Introduction by kishimisu", "author": "grey_", "description": "This shader is made with \"An introduction to Shader Art Coding\" by kishimisu. Check out the video and their channel @ https://www.youtube.com/watch?v=f4s1h2YETNY <3", "tags": ["neon"], "likes": 1, "viewed": 168, "published": 3, "date": "1685914066", "time_retrieved": "2024-07-30T17:52:10.020661", "image_code": "// Cosine-based palette function by Inigo Quilez\n// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t) {\n    // Colors from: http://dev.thi.ng/gradients/\n    // [[0.660 0.560 0.680] [0.337 0.206 0.448] [0.536 0.824 0.536] [-0.393 -0.393 0.107]]\n    vec3 a = vec3(.660, .560, .680);\n    vec3 b = vec3(.337, .206, .448);\n    vec3 c = vec3(.536, .824, .536);\n    vec3 d = vec3(-.393, -.393, .107);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Based on \"An introduction to Shader Art Coding\" by kishimisu\n// https://www.youtube.com/watch?v=f4s1h2YETNY\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Square variant\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Original uv, without tiling.\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.);\n\n    for(float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 1.5) - .5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * .4 + iTime * .4);\n\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n\n        // Reduce this further for interesting effects.\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    // The final output color of the current fragment pixel is set as a combination of the previously calculated color ('col')\n    // and a dynamically calculated brightness value ('d'). It is then sent to the buffer as well.\n    fragColor = vec4(finalColor, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 120, 260, 459], [461, 572, 627, 718, 1535]]}
{"id": "clySR1", "name": "Candy Six", "author": "Pink", "description": "Simple fract repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["2d", "psychedelic", "colourful"], "likes": 2, "viewed": 169, "published": 3, "date": "1685913567", "time_retrieved": "2024-07-30T17:52:10.770655", "image_code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//inline comments may not be completely accurate.\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 4.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 8.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 8.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 1.;\n    //noise seed\n    float seed = 6502.;\n    \n    \n\n    float myTime = iTime*0.5;\n    \n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    float noise = gold_noise(fragCoord, seed) - ((sin(myTime * 0.5)*0.5) + 0.5);\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n        //uv = fract(uv)-0.5;\n\n        //distance from centre \n        float dist = sdHexagon(uv, 0.25);\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime); //* (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist - (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = 0.001 / dist;\n\n        //smoothstep colour to give clean edges.\n        col = col * smoothstep(0.0, 0.5-smoothing, dist) * noise;\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}", "image_inputs": [{"id": 33507, "src": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clySR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 412, 456, 456, 516], [518, 518, 545, 589, 769], [771, 771, 813, 813, 1003], [1005, 1005, 1062, 1119, 3230]]}
{"id": "DlGXzh", "name": "(WIP) green cubes spinning", "author": "jakel101", "description": "starting with https://www.shadertoy.com/view/MsX3zr with ideas of https://www.youtube.com/watch?v=O8kAFhSqFdM to recreate the winner of this https://www.instagram.com/p/CrtGz89OUSb/", "tags": ["3d", "raymarching", "distancefield", "mouse"], "likes": 1, "viewed": 155, "published": 3, "date": "1685912946", "time_retrieved": "2024-07-30T17:52:11.522645", "image_code": "// forked from \"Cubes and Spheres\" by @paulofalcao https://www.shadertoy.com/view/MsX3zr\n\n//Scene Start\n\nvec2 sim2d( in vec2 p, in float s)\n{\n   vec2 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\nvec3 stepspace( in vec3 p, in float s)\n{\n  vec3 grid = p-mod(p-s/2.0,s);\n  return grid;\n}\n\n//Object\nfloat obj(in vec3 p)\n{ \n  vec3 fp=stepspace(p,2.0);;\n  float d=2.0+sin(iTime); //y (height) location of the cubes\n  d = d * 1.0/length(.1*p.xz) + 2.0; // this block hole kinda thing in the center. Perhaps I can modify the 2D grid stuff to get an empty center.\n  if (p.x>1.0) d= -5.0; // this moves one half of the cubes higher.\n  p.y=p.y+d;\n  p.xz=sim2d(p.xz,2.0);\n  //c1 is IQ RoundBox from https://iquilezles.org/articles/distfunctions\n  float c1=length(max(abs(p)-vec3(0.7,0.7,0.7),0.0))-0.15;\n  //c2 is a taller cuboid\n  float c2=length(max(abs(p)-vec3(0.3,0.9,0.4),0.0))-0.15;\n  float cf=sin(iTime)*0.5+0.5;\n  return mix(c1,c2,cf);\n}\n\n//Object Color\nvec3 obj_c(vec3 p)\n{\n  vec2 fp=sim2d(p.xz-15.0,16.0);\n  if (fp.y>4.0) fp.x=-fp.x;\n  if (fp.x>0.0) return vec3(0.0,1.0,0.0);\n    else return vec3(0.0,0.1,0.0);\n}\n\n//Scene End\n\n\n//Raymarching Framework Start\n\nfloat PI=3.14159265;\n\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3 lightv=normalize(light-pt);\n   float diffuse=dot(normal,lightv);\n   vec3 refl=-reflect(lightv,normal);\n   vec3 viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec);\n   return (max(diffuse,0.0)+ambLight)*color+specular;\n}\n\nfloat raymarching(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  out int objfound)\n{ \n  const vec3 e=vec3(0.1,0,0.0);\n  float s=startf;\n  vec3 c,p,n;\n  float f=startf;\n  objfound=1;\n  for(int i=0;i<256;i++){\n    if (abs(s)<precis||f>maxd||i>maxite) break;\n    f+=s;\n    p=prp+scp*f;\n    s=obj(p);\n  }\n  if (f>maxd) objfound=-1;\n  return f;\n}\n\nvec3 camera(\n  in vec3 prp,\n  in vec3 vrp,\n  in vec3 vuv,\n  in float vpd,\n  in vec2 fragCoord)\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  return normalize(scrCoord-prp);\n}\n\nvec3 normal(in vec3 p)\n{\n  //tetrahedron normal\n  const float n_er=0.01;\n  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er));\n  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er));\n  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er));\n  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er));\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvec3 render(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  in vec3 background,\n  in vec3 light,\n  in float spec,\n  in vec3 ambLight,\n  out vec3 n,\n  out vec3 p,\n  out float f,\n  out int objfound)\n{ \n  objfound=-1;\n  f=raymarching(prp,scp,maxite,precis,startf,maxd,objfound);\n  if (objfound>0){\n    p=prp+scp*f;\n    vec3 c=obj_c(p);\n    n=normal(p);\n    vec3 cf=phong(p,prp,n,light,c,spec,ambLight);\n    return vec3(cf);\n  }\n  f=maxd;\n  return vec3(background); //background color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n  //Camera animation\n  vec3 vuv=vec3(0,1,0);\n  vec3 vrp=vec3(0.0,0.0,0.0);\n  float mx=iMouse.x/iResolution.x*PI*2.0+(iTime*0.3);\n  float my=iMouse.y/iResolution.y*PI/2.01;\n  // my = 0.05; // stuck view angle by inputting a mouse?\n  if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){mx=1.0,my=0.05;};//quick hack to detect no mouse input for thumbnail\n  // mx =+ iTime * 0.3; // rotation by time\n  vec3 prp=vrp+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0; //Trackball style camera pos\n  float vpd=1.5;\n  vec3 light=prp+vec3(5.0,0,5.0);\n  \n  vec3 scp=camera(prp,vrp,vuv,vpd,fragCoord);\n  vec3 n,p;\n  float f;\n  int o;\n  const float maxe=0.01;\n  const float startf=0.1;\n  const vec3 backc=vec3(0.0,0.0,0.0);\n  const float spec=8.0;\n  const vec3 ambi=vec3(0.1,0.1,0.1);\n  \n  vec3 c1=render(prp,scp,256,maxe,startf,60.0,backc,light,spec,ambi,n,p,f,o);\n  c1=c1*max(1.0-f*.015,0.0);\n  vec3 c2=backc;\n  if (o>0){\n    scp=reflect(scp,n);\n    c2=render(p+scp*0.05,scp,32,maxe,startf,10.0,backc,light,spec,ambi,n,p,f,o);\n  }\n  c2=c2*max(1.0-f*.1,0.0);\n  fragColor=vec4(c1.xyz*0.75+c2.xyz*0.25,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 218], [220, 220, 260, 260, 309], [311, 320, 342, 342, 958], [960, 975, 995, 995, 1135], [1204, 1204, 1335, 1335, 1589], [1591, 1591, 1733, 1733, 1990], [1992, 1992, 2088, 2088, 2339], [2341, 2341, 2365, 2388, 2678], [2680, 2680, 2935, 2935, 3219], [3221, 3221, 3277, 3300, 4364]]}
{"id": "dtKXRR", "name": "Interference Candy", "author": "Pink", "description": "Simple fract repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["2d", "psychedelic", "colourful"], "likes": 3, "viewed": 184, "published": 3, "date": "1685906022", "time_retrieved": "2024-07-30T17:52:12.276630", "image_code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//License: MIT\n//inline comments may not be completely accurate.\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 4.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 8.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 8.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 2.0;\n\n    float myTime = iTime*0.5;\n\n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n\n        //distance from centre \n        float dist = length(uv);\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime * (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist + (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = 0.001 / dist;\n\n        //smoothstep colour to give clean edges.\n        col = col * smoothstep(0.0, 0.5-smoothing, dist);\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKXRR.jpg", "access": "api", "license": "mit", "functions": [[121, 121, 148, 192, 372], [374, 374, 431, 488, 2413]]}
{"id": "clVSzz", "name": "Another braided truchet", "author": "mrange", "description": "CC0: Another braided truchet\nTinkering with other kind of braid patterns\n", "tags": ["2d", "truchet"], "likes": 21, "viewed": 219, "published": 3, "date": "1685904219", "time_retrieved": "2024-07-30T17:52:13.073498", "image_code": "// CC0: Another braided truchet\n//  Tinkering with other kind of braid patterns\n//  Original inspiration from: https://twitter.com/kamoshika_vrc/status/1665017981875924992?s=20\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat heart(vec2 p, float sz) {\n  p /= sz;\n    p.x -= -0.51;\n    p = p.yx;\n  return heart(p)*sz;\n}\n\nvec3 braid(vec3 col, vec2 p, vec2 cp, float z, float aa) {\n  const float reps  = 12.0;\n  const float a     = TAU/reps;\n  const float bsz0  = a*0.4;\n  const mat2 rot2   = ROT(a*0.5);\n\n  float cd = length(cp)-0.5;\n  vec2 pp = cp;\n\n  pp *= rot2;\n  float n = modPolar(pp, reps);\n\n  float bw = 0.0175;\n\n  vec2 bp0 = pp;\n  bp0.y = -abs(bp0.y);\n  bp0 *= transpose(rot2);\n  bp0.x -= 0.5;\n  float bd0 = length(bp0) - bsz0*0.5;\n  bd0 = abs(bd0) - bw;\n\n  vec2 bp1 = pp;\n  bp1.x -= 0.5;\n  float bd1 = heart(bp1, bsz0);\n  bd1 = abs(bd1) - bw;\n\n  float ringi   = 4.0*sqrt(max(-bd0, 0.0));\n  float hearti  = 4.0*sqrt(max(-bd1, 0.0));\n  vec3 heartCol = hsv2rgb(vec3(0.95, mix(0.9, .75, hearti), mix(0.33, 2.0, hearti))); \n  vec3 ringCol  = hsv2rgb(vec3(0.1, mix(0.95, 0.5, ringi), mix(0.33, 2.0, ringi)));\n  \n  vec3 col0 = ringCol;\n  vec3 col1 = heartCol;\n  if (-cd > 0.0) {\n    float tmp = bd0;\n    bd0 = bd1;\n    bd1 = tmp;\n    col0 = heartCol;\n    col1 = ringCol;\n  }\n  const float shade = -150.0;\n  col *= 1.0-exp(shade*max(bd0, 0.0));\n  col = mix(col, col0, smoothstep(0.0, -aa, bd0));\n\n  col *= 1.0-exp(shade*max(bd1, 0.0));\n  col = mix(col, col1, smoothstep(0.0, -aa, bd1));\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float pr = 20.0;\n  const float z = 1.0;\n  p /= z;\n\n  p += pr*sin(0.125*vec2(1.0, sqrt(0.5))*(100.0+TIME)/pr);\n  float aa = 4.0/(z*RESOLUTION.y);\n\n  vec2 cp = p;\n  vec2 np = round(cp);\n  float nh0 = hash(np+123.4);\n  cp -= np;\n  if (nh0 > 0.5) cp = cp*ROT(PI/2.0);\n\n  vec2 bp = cp;\n  float bn = ref(bp, normalize(vec2(1.0)));\n  bp -= 0.5;\n\n  vec3 col = vec3(0.0);\n  col = braid(col, p, bp, z, aa);\n  col *= smoothstep(1.75, 0.5, length(pp));\n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVSzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 508, 530, 530, 676], [971, 971, 1020, 1020, 1419], [1421, 1481, 1502, 1502, 1572], [1574, 1574, 1607, 1607, 1688], [1690, 1690, 1710, 1710, 1732], [1734, 1852, 1873, 1873, 2093], [2095, 2095, 2126, 2126, 2193], [2195, 2195, 2253, 2253, 3376], [3378, 3378, 3408, 3408, 3895], [3897, 3897, 3952, 3952, 4127]]}
{"id": "mltSWl", "name": "Year of Truchets #031", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles"], "likes": 27, "viewed": 551, "published": 3, "date": "1685899169", "time_retrieved": "2024-07-30T17:52:13.818506", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #031\n    06/04/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    layout based off https://www.shadertoy.com/view/DddSDl\n\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MAX_DIST    18.\n#define MIN_DIST    1e-5\n\n// globals\nvec3 hit,hitPoint,trigger,stored;\nfloat time=0.,spd=.3,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ghs,shs;\nmat2 r45,rx,ry;\nconst float db = 12.;\n\nvec2 hash2( vec2 p ){ return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 tile(vec2 q, vec2 id) {\n\n    float hs = hash21(id);\n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    float wd = .025;\n    \n    if(hs>.5) q *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    vec2 sp = vec2(length(q-.5),length(q+.5));\n    vec2 p = sp.x<sp.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n    float g = length(abs(q)-.5)-(.425-wd);\n    float c = min(length(q.x)-wd,length(q.y)-wd);\n    // alt patterns\n    if (hs>.85) d = c;ghs=hs;\n    hs = fract(hs*415.372);\n  \n    if (ck>.5 && hs<.8) d = min(length(abs(q)-vec2(.5,0))-wd,length(q.x)-wd);\n\n    // accents\n    float b = length(abs(q)-.5)-.125;\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.01;\n    d2=max(d2,-b);\n \n    return vec3(d,b,d2);\n}\nfloat glow=0.;\n\nvec2 map(vec3 pos, float sg){\n    vec2 res = vec2(1e5,0);\n    pos.xz*=r45;\n    pos.xz+=vec2(ga1,ga2);\n    pos.z-=spd;\n  \n    vec2 id = floor(pos.xz);\n    vec2 uv = fract(pos.xz)-.5;\n    vec2 xd =  floor(pos.xz-.5);\n    vec2 vv = fract(pos.xz-.5)-.5;\n    \n    float hs = hash21(xd);\n    // render tiles once at first loop\n    vec3 t1 = trigger.x>1.? stored : tile(uv,id);\n    if(trigger.x<1.) stored = t1;\n    vec3 pp = vec3(uv.x,pos.y,uv.y);\n    float d1 = opx(t1.x,pos.y,.95);\n    if(d1<res.x) {\n        res = vec2(d1,2.);\n        hit=pp;\n    }\n    \n    float d2 = opx(abs(t1.y)-.02,pos.y,.1+(hs*.75));\n    d2 = min(opx(t1.y,pos.y,.05),d2);\n    if(d2<res.x) {\n        res = vec2(d2,3.);\n        hit=pos;\n    }\n     \n    float d3 = opx(t1.z,pos.y,.01);\n    if(d3<res.x) {\n        res = vec2(d3,4.);\n        hit=pos;\n    }\n    \n    float ff = .8+.5*sin((hs*25.5)+(T*.45*hs));\n    float d4 = hs<.8?1e5:length(vec3(vv.x,pos.y-ff,vv.y))-.05;\n           \n    if(sg==1.&&d4<d2) { glow += .00065/(.001+d4*d4);}\n    if(d4<res.x&&sg!=0.) {\n        res = vec2(d4,5.);\n        hit=vec3(vv.x,pos.y-ff,vv.y);\n    }\n    \n    float gnd = pos.y+.01;\n    if(gnd<res.x) {\n        res = vec2(gnd,1.);\n        hit=pos;\n    }\n\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 O, in vec2 F) { \n\n    //  precal //\n    vec3 col = vec3(0); \n    spd = T*.1;\n    r45 = rot(.78);\n    tspeed = T*.5;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,02.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(03.,05.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float t3 = lsp(06.,08.,tmod);\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    \n    float t4 = lsp(09.,11.,tmod);\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    \n    ga3 = (t1-t3);\n    ga4 = (t2-t4);\n    \n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*.125-.0625)*PI;\n\n    rx = rot(x-.7);\n    ry = rot(y+(ga3-ga4)*PI);\n       \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,5.);\n    vec3 rd = normalize(vec3(uv,-1.));\n    \n    // mouse //\n    ro.zy*=rx;ro.xz*=ry;\n    rd.zy*=rx;rd.xz*=ry;\n\n    float d = 0.,m = 0.;\n    vec3 color = vec3(0), n = vec3(0),p = vec3(0);\n    \n    // marcher\n    for(int i=0;i<100;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p,1.);\n        trigger.x = i>1? 1.:0.; // set trigger\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.4: ray.x*.9;\n        m  = ray.y;\n    } \n    \n    hitPoint=hit;\n    shs=ghs;\n    \n    if (d < MAX_DIST) \n    {\n        vec3 n = normal(p, d);\n        vec3 lpos =vec3(5,12,-5);\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.05,1.);\n        \n        //shadows\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        vec3 h = vec3(0);\n        \n        \n        if(m==1.) {\n            h = vec3(.005);\n            vec3 hp = hitPoint;\n            float ft = fract((hp.x-hp.z)*12.)-.5;\n            if (shs>.8) h = mix(vec3(.8,.35,0),vec3(.1),mod(floor(ft),2.)==0.?1.:0.);\n            if (shs<.5) h =vec3(.05);\n        }\n        \n        if(m==2.) {\n    \n            h = vec3(.6);\n            vec3 hp = hitPoint;\n            float ft = fract((hp.x-hp.z)*6.)-.5;\n            if (hp.y>.8) h = mix(vec3(1,.5,0),vec3(.04),mod(floor(ft),2.)==0.?1.:0.);\n            h = (hp.y<.1||hp.y>.9) ? vec3(.1) : h;\n        }\n        \n        if(m==3.) h = vec3(.09);\n        if(m==4.) h = vec3(.2);\n        \n        color = h*diff;\n    }\n    color = mix(color,vec3(.32,.40,.48), 1.-exp(-.001*d*d*d));\n    color = mix(color,vec3(.96,.87,.69),clamp(glow*.5,0.,1.));\n    color=pow(color,vec3(.4545));\n\n    O = vec4(color, 0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltSWl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[619, 619, 640, 640, 729], [730, 730, 751, 751, 811], [812, 812, 830, 830, 873], [874, 874, 911, 911, 945], [946, 946, 965, 965, 992], [994, 1008, 1057, 1057, 1153], [1155, 1155, 1183, 1183, 1888], [1905, 1905, 1934, 1934, 3128], [3130, 3205, 3235, 3235, 3486], [3488, 3488, 3527, 3547, 6206]]}
{"id": "dtySRR", "name": "rainbow water", "author": "flylo", "description": "combining waves of increasing frequency with a warp effect", "tags": ["2d", "fractal", "metal", "liquid"], "likes": 11, "viewed": 403, "published": 3, "date": "1685894028", "time_retrieved": "2024-07-30T17:52:14.577477", "image_code": "const int[18] ns = int[](-1, -1, 0, -1, 1, -1, -1, 0, 1, 0, 0, 0, -1, 1, 0, 1, 1, 1);\n\nvec4 texel(in ivec2 x) {\n    return texelFetch( iChannel0, x, 0 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iv = ivec2(fragCoord);\n    //fragColor = avg(iv);\n    fragColor = texel(iv);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 pools(in vec2 uv)\n{\n    float dt  = .5+.5*sin(.18*iTime);\n    float dt2 = .5+.5*sin(.038*iTime);\n    float mdt = .2+.8*dt;\n    float mdt2 = .7+.3*dt2;\n    \n    float dt3 = .5+.5*sin(.14*iTime);\n    float dt4 = .5+.5*sin(.033*iTime);\n    float mdt3 = .2+.8*dt3;\n    float mdt4 = .7+.3*dt4;\n\n    float dt5  = .5+.5*sin(.11*iTime);\n    float dt6 = .5+.5*sin(1.5+.036*iTime);\n    float mdt5 = .2+.8*dt5;\n    float mdt6 = .7+.3*dt6;\n\n    float dt7  = .5+.5*sin(.3*iTime);\n    float mdt7 = .1+.9*dt7;\n\n    float dt8  = .5+.5*sin(1.5+.2*iTime);\n    float mdt8 = .9+.1*dt8;\n\n\n    //uv = vec2(sin(25.*uv));\n\n\n    vec3 c = vec3(0.);\n    float a = 1.;\n    float f = 1.;\n    float as = 0.;\n    for (int i = 0; i < 1; i++) {\n        for (int j = 0; j < 25; j++) {\n            //float p[] = float[](.2, .5, .3, 0.1, .4, .8, .8, .5);\n            //float wc[] = float[](.0, 1., .0, 1., .1, .2, .0, .1, 1.);\n            f = 2.*(1.+.3*float(j));//*(.5+.5*sin(157.*float(j)));\n            a = 1./(pow(1.23,float(j)));\n            //a = 1./(1.+float(j));\n            \n            float r2 = length(uv-vec2(sin(142.31*float(j)), sin(29.321*float(j))));\n\n            c.r += mdt*1.4*a*(.5+.5*sin(7.*iTime+f*mdt2*7.1*r2));\n            c.g += mdt3*1.4*a*(.5+.5*sin(7.*iTime+f*mdt4*7.1*r2));\n            //c.b += .1*a*(.5+.5*sin(11.*iTime+f*7.1*r2));\n            //c.g += .5*a*(.5+.5*sin(11.*iTime+f*5.1*r2));\n            c.b += mdt5*1.4*a*(.5+.5*sin(7.*iTime+f*mdt6*7.1*r2));\n            //c += vec3(r2);\n            //c.b += a*.7*sin(22.*mdt6+f*5.4*r2);\n            as += a;\n            //f *= 1.3+length(c);\n            //f *= 1.1;\n   \n            //a = 0.;\n        }\n    }\n    c /= as;\n   \n \n    return c;\n    \n}\n\n\nvec3 warp(in vec2 uv) {\n    vec3 c = pools(uv);\n    \n    int iter = 5;\n    float amp = .55;\n    float f = .9;\n\n    float a = 1.; \n    for (int i = 0; i < iter; i++) {\n       a *= amp;\n    }\n       \n    for (int i = 0; i < iter; i++) {\n        a /= amp;\n        f *= 1.2;\n        c = a*pools(uv + f*vec2(c.r-c.g, c.g - c.b)) ;\n    }\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 px = ivec2( fragCoord );\n\n    vec2 uv = fragCoord/iResolution.xy;\n // vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    //rstate = dot(uv, vec2(711.9898,1123.233));\n \n    //cur = texelFetch(iChannel0, px, 0 );\n\n    fragColor = vec4(warp(uv), 1.);\n\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtySRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 111, 111, 155], [159, 159, 216, 216, 307]]}
{"id": "dlySzR", "name": "Yet another fractal test", "author": "BaldPolnareff", "description": "Another fractal test with zooming and panning", "tags": ["fractal", "panning"], "likes": 3, "viewed": 133, "published": 3, "date": "1685893185", "time_retrieved": "2024-07-30T17:52:15.485050", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Apply zooming and panning effect\n    p *= 1.2;\n    p += 0.08 * vec2(sin(iTime * 1.), cos(iTime * 0.3));\n\n    // Generate a fractal pattern\n    float f = 1.0;\n    for (float i = 0.; i < 11.5; i++) {\n        p = abs(p) / dot(p, p) - 0.519;\n        f *= dot(p, p);\n    }\n\n    // Apply color transformation based on fractal\n    vec3 color = .3*vec3(f * 0.2, f * 0.4, f * 0.6);\n\n    // Apply distortion using sine and cosine functions\n    vec2 distortedUV = (vec2(p.x + sin(p.y * 10.2 + iTime * 2.0) * .1, p.y + cos(p.x * 8.0 + iTime * 3.1) * 0.01));\n\n    // Apply color manipulation based on distorted coordinates\n    color += vec3(distortedUV.x * 0.3, distortedUV.y * 0.3, sin(distortedUV.x * distortedUV.y));\n\n    // Create an animated gradient effect\n    vec2 gradientUV = .3*vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    color += vec3(gradientUV.x, gradientUV.y, sin(iTime * 2.2 + gradientUV.x + gradientUV.y));\n\n    fragColor = .98 * vec4(color.x * .9, color.yz*1.1, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlySzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 84, 1155]]}
{"id": "dtyXRR", "name": "Bald Polnareff Spiral Fractal", "author": "BaldPolnareff", "description": "Random math again, until the result looks beautiful", "tags": ["fractal", "circles", "spiral"], "likes": 2, "viewed": 155, "published": 3, "date": "1685892048", "time_retrieved": "2024-07-30T17:52:16.756650", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Calculate distance from the center\n    float radius = length(p);\n\n    // Create a time-dependent wave effect\n    float wave = sin(iTime * 1.5 + radius * 1.0);\n    p *= 2.8*mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    p *= 1.5;\n    float f = 1.;\n\n    for (float i = 1.2; i <= 2.5; i++) {\n        p = fract(abs(p) / dot(p, p) - 0.38);\n        f *= fract(dot(1.*p, p));\n\n        wave += f * sin(iTime * i + radius * i * 5.0) * 0.2 / i;\n        wave /= cos(iTime * i + radius * i * 5.0) * 2.4;\n    \n        // Apply distortion to the coordinates\n        vec2 distortedUV = vec2(p.x/3. + wave * 1.1, p.y - wave * .5);\n\n        // Calculate color based on the distorted coordinates\n        vec3 color = vec3(distortedUV, 0.5 + 2. * f * i * sin(iTime));\n\n    fragColor = vec4(.3*color.x, .7*color.y, sin(.2*color.z + iTime * 0.1), 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 84, 1009]]}
{"id": "dl3SDX", "name": "my first shader-me", "author": "pem120", "description": "aaaa", "tags": ["mouse"], "likes": 1, "viewed": 128, "published": 3, "date": "1685891520", "time_retrieved": "2024-07-30T17:52:17.508640", "image_code": "vec3 palette( in float t )\n{\n    vec3 a = vec3(-0.692,0.428,0.568);\n    vec3 b = vec3(-0.762,-0.462,0.648);\n    vec3 c = vec3(0.178,1.199,0.178);\n    vec3 d = vec3(-0.692,0.428,0.568);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) /iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalcolour = vec3(0.0);\n    for(float i = 0.0;i<3.0;i++){\n    uv = fract(uv *(1.5))-0.5;\n    \n    \n    float d = length(uv)*exp(-length(uv0+iMouse.x/10000.0));\n    vec3 col = palette(length(uv0) + iTime*i*0.4);\n    d = sin(d * 8. +iTime)/8.;\n    d = abs(d);\n    //d = (i/100.0)/d;\n    d = smoothstep(0.0,0.25,d);\n    d = (0.025)/d;\n    //col *= d;\n    finalcolour += col *(d);\n    }\n    fragColor = vec4(finalcolour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3SDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 227], [231, 231, 288, 288, 808]]}
{"id": "ctdXWs", "name": "Pattern0-fork", "author": "pem120", "description": "\"Zooming out\" of a pattern made by multiplying x and y values.", "tags": ["animation", "pattern", "weird"], "likes": 1, "viewed": 121, "published": 3, "date": "1685889861", "time_retrieved": "2024-07-30T17:52:18.256640", "image_code": "// Fork of \"Pattern0\" by VIBaJ. https://shadertoy.com/view/cldXWl\n// 2023-06-04 10:05:45\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(abs(uv.x * uv.y) * pow(2.0, iTime));\n    \n    col = fract(vec3(mod(col.x, 16777216.0) * mod(col.x, 65536.0), mod(col.x, 65536.0) * mod(col.x, 256.0), mod(col.x, 256.0)));\n    fragColor = vec4(fract(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 147, 147, 445]]}
{"id": "DlGXzz", "name": "Bald Polnareff Fractal Test 1", "author": "BaldPolnareff", "description": "Another test, I'm just toying with random math at this point", "tags": ["fractal", "animation", "rotation"], "likes": 2, "viewed": 154, "published": 3, "date": "1685889629", "time_retrieved": "2024-07-30T17:52:19.004640", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y; // Normalize coordinates\n\n    // Scale and rotate the coordinate system\n    p *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    p *= 5.0;\n\n    float f = 1.0;\n    for (float i = 0.; i < 7.6; i++) {\n        p = abs(p) / dot(p, p) - 0.638;\n        f *= dot(1.1*p, p);\n    }\n\n    // Apply coloring to the fractal\n    vec3 color = vec3(f * 0.1 + .007*sin(iTime + 1.2), f * 0.8 + .007*cos(iTime + 1.2), f * 0.26 + .007*sin(iTime/10. + 0.2));\n\n    // Add some variation to the coloring\n    color += 0.002 * vec3(sin(fragCoord.x * 0.1), cos(fragCoord.y * 0.05), sin(iTime * 0.3));\n\n    fragColor = 10.*vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 746]]}
{"id": "ctyXRz", "name": "Drunken Walker", "author": "SnoopethDuckDuck", "description": "messy code just playing about :)", "tags": ["cycle", "animation", "walk", "person"], "likes": 21, "viewed": 314, "published": 3, "date": "1685888917", "time_retrieved": "2024-07-30T17:52:19.865341", "image_code": "#define res iResolution.xy\n#define pi 3.14159\n#define tanh2(a) ((exp2(a)-1.)/(exp2(a)+1.))\n#define thc(a,b) tanh2((a)*cos(b))/tanh2(a)\n#define ths(a,b) tanh2((a)*sin(b))/tanh2(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\n#define l(d, p, q, r1, r2) d = min(d, cap(uv, p, q, r1, r2));\n\n// iq's IK\nvec2 solve(vec2 p, float r1, float r2, float side) {\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + side * vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\nfloat seg( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Uneven capsule (unoptimised)\nfloat cap(vec2 uv, vec2 p, vec2 q, float r1, float r2)\n{\n    float h = length( p - q);\n    uv -= p;\n    float th = atan(q.y-p.y, q.x-p.x);\n    uv *= rot(-th + pi/2.);\n    uv.x = abs(uv.x);    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(uv,vec2(-b,a));\n    if( k < 0.0 ) return length(uv) - r1;\n    if( k > a*h ) return length(uv-vec2(0.0,h)) - r2;\n    return dot(uv, vec2(a,b) ) - r1;\n}\n\nfloat g(float x) {\n    return pow((27./32.) * x * x * (2.-x), 8.);\n}\n\n// Foot trajectory\nvec2 getPos(float t, float a, float w, float h) {\n    // 0.3, 0.2\n    return vec2(w, h) * vec2(cos(pi * (t+a)), g(t));\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    uv.y += 0.48;\n    uv *= 1.2;\n    float t = 0.75 * iTime;\n    t += 0.5 * thc(2., 0.2 * iTime);\n    \n    \n    float a = 0.5;\n    float w = 0.31; //0.17 + 0.14 * thc(4., 1.*iTime);\n    float h = 0.2;\n    // Draw foot trajectory\n    \n    float n = 40.;    \n    float t2 = mod(t, 2.);\n    vec2 p = getPos(t2, a, w, h);\n    vec2 q = getPos(mod(t - 2. / n, 2.), a, w, h);\n    float d = seg(uv, p, q);\n    for (float i = 1.; i < n; i++) {\n        float t2 = mod(t + 2. * i / n, 2.);\n        vec2 q = getPos(t2, a, w, h);\n        d = min(d, seg(uv, p, q));\n        p = q;\n    } \n    float s = ss(1., 0.005 - d);\n    //*/\n        \n    vec2 pLegL = getPos(mod(t, 2.), a + 0.*sin(0.5*t), w, h);\n    vec2 pLegR = getPos(mod(t + 1., 2.), a + 0.*cos(0.5*t), w, h);\n    \n    vec2 pHip = vec2(0.1, 0.4 + 0.05 * cos(2.*pi*t));\n    vec2 pKneeL = pLegL + solve(pHip - pLegL, 0.26, 0.28, -1.);\n    vec2 pKneeR = pLegR + solve(pHip - pLegR, 0.26, 0.28, -1.);\n    vec2 pFootL = pLegL + 0.05 * Dir(-0.5 * pi*g(mod(t+0.1,2.)));\n    vec2 pFootR = pLegR + 0.05 * Dir(-0.5 * pi * g(mod(t+1.1,2.)));\n    vec2 pBody = pHip + 0.34 * Dir(pi/2.+0.3 * cos(2. * pi * t + pi/4.));\n    vec2 pArmL = pBody + 0.2 \n               * Dir(-pi/8.+.3*sin(2. * pi * t + pi/4.) + g(mod(t + 1.2, 2.)));\n    vec2 pArmR = pBody - 0.2 \n               * Dir(pi/8.+.3*sin(2. * pi * t + pi/4.) + g(mod(t + 0.2, 2.)));\n    vec2 pHandL = pArmL + 0.2 * Dir(0.5*cos(2.*pi*t+pi));\n    vec2 pHandR = pArmR + 0.2 * Dir(0.5*cos(2.*pi*t+pi));\n    vec2 pHead = pBody + 0.1 * Dir(3.*pi/8.+0.3*cos(2.*pi*t + 3.*pi/4.));\n    vec2 pFingL = pHandL + 0.02 * Dir(-0.5 * cos(2.*pi*t - pi/4.));\n    vec2 pEye = pHead + vec2(0.04, 0);\n    vec2 pEye2 = pEye + 0.01 * Dir(0.3*cos(2.*pi*t - pi/4.));\n    float dL, dC, dR;\n    dL = dR = dC = 1e5;\n    float d3 = 1e5;\n    l(dL, pHip, pKneeL, .02, .01);\n    l(dL, pLegL, pKneeL, .005, .01);\n    l(dL, pLegL, pFootL, .005, .00);\n    l(dL, pBody, pArmL, .02, .01);\n    l(dL, pArmL, pHandL, .01, .0);\n    l(dL, pHandL, pFingL, .0, .0);\n    \n    l(dR, pHip, pKneeR, .02, .01);   \n    l(dR, pLegR, pKneeR, .005, .01);\n    l(dR, pLegR, pFootR, .005, .00);   \n    l(dR, pBody, pArmR, .02, .01);  \n    l(dR, pArmR, pHandR, .01, .0);\n    \n    l(dC, pHip, pBody, .02, .015);\n    l(dC, pBody, pHead, .015, .0);\n    dC = min(dC, length(uv - pHead) - 0.045);\n    \n    float dEye = length(uv - pEye);\n\n    float sEye = ss(1., 0.03 - dEye);\n    float sEye0 = ss(1., 0.02 - dEye);\n    float dEye2 = length(uv - pEye2);\n    float sEye2 = ss(1., 0.015 - dEye2);\n\n    float mx = 0.5 + 0.5 * thc(4., 30. * uv.y + 0.*iTime);\n    float rL = mix(0.01, 0.02, mx);\n    float rC = mix(0.008, 0.018, mx);\n    float rR = mix(0.01, 0.02, mx);\n    float rO = mix(0.025, 0.035, mx);\n    \n    float sL = ss(1., rL - dL);\n    float sC = ss(1., rC - dC); // 0.008    \n    float sR = ss(1., rR - dR);\n    float sLO = ss(1., 0.01 + rL - dL);\n    float sCO = ss(1., 0.01 + rC - dC);\n    float sRO = ss(1., 0.01 + rR - dR);\n    // float sO = ss(1., rLO - min(min(dL, dC), dR));\n\n    vec3 col = vec3(0.98, 0.95, 0.8);\n    col = mix(col, vec3(0), 1.-exp(-0.12*length(ouv)));\n    float bgLines = ss(1., 0.2 - abs(fract(30.*(uv*rot(-pi/4.)).x)-0.5));\n    col *= 1. - 0.005 * bgLines;\n    ouv *= rot(0.1 * thc(4., iTime));\n    float tx = texture(iChannel0, .2*ouv + 0.05 * vec2(iTime, 0)).r;\n    tx = ss(1., 0.2 - tx);\n    col -= 0.1 * tx;\n    col = mix(col, vec3(0.32), sLO);\n    col = mix(col, vec3(1, .5, .5), sL);\n    col = mix(col, vec3(0.32), sCO);\n    col = mix(col, vec3(.5,.8, 1.), sC);\n    col = mix(col, vec3(0.32), sRO);\n    col = mix(col, vec3(.4), sR);\n    col = mix(col, vec3(.32), sEye);\n    col = mix(col, vec3(0.99), sEye0);\n    col = mix(col, vec3(.32), sEye2);\n    col *= 1. - 0.005 * bgLines;\n    \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 389, 441, 441, 600], [602, 602, 648, 648, 767], [769, 801, 857, 857, 1216], [1218, 1218, 1236, 1236, 1286], [1288, 1307, 1356, 1372, 1427], [1429, 1429, 1471, 1471, 5304]]}
{"id": "DtGSzR", "name": "Braided truchet", "author": "mrange", "description": "Saw a tweet: https://twitter.com/kamoshika_vrc/status/1665017981875924992?s=20\nThought the code for the braided pattern was quite clever but couldn't decipher it\nSo wrote this version inspired by it.\n", "tags": ["2d", "truchet", "reproduction"], "likes": 20, "viewed": 206, "published": 3, "date": "1685887426", "time_retrieved": "2024-07-30T17:52:20.625307", "image_code": "// CC0: Braided truchet\n//  Saw a tweet: https://twitter.com/kamoshika_vrc/status/1665017981875924992?s=20\n//  Thought the code for the braided pattern was quite clever but couldn't decipher it\n//  So wrote this version inspired by it.\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 braid(vec3 col, vec2 p, vec2 cp, float z, float aa) {\n  const float reps  = 24.0;\n  const float a     = TAU/reps;\n  const float bsz0  = a*0.3;\n  const vec2 bsz    = vec2(bsz0);\n  const float br0   = sqrt(2.0)*bsz0;\n  const mat2 rot2   = ROT(a*0.5);\n  const mat2 rot45  = ROT(PI/4.0);\n\n  float cd = length(cp)-0.5;\n  vec2 pp = cp;\n\n  pp *= rot2;\n  float n = modPolar(pp, reps);\n\n  float bf0 = clamp((texture(iChannel0, 0.005*p).x-0.1)*1.2, 0.0, 1.0);\n  float br = br0*bf0;\n  float bw = 0.02;\n\n  vec2 bp0 = pp;\n  bp0 *= transpose(rot2);\n  bp0.x -= 0.5;\n  bp0 *= rot45;\n  float bd0 = box(bp0, bsz-sqrt(0.5)*br)-br;\n  bd0 = abs(bd0) - bw;\n\n  vec2 bp1 = pp;\n  bp1 *= rot2;\n  bp1.x -= 0.5;\n  bp1 *= rot45;\n  float bd1 = box(bp1, bsz-sqrt(0.5)*br)-br;\n  bd1 = abs(bd1) - bw;\n\n  if (cd > 0.0) {\n    float tmp = bd0;\n    bd0 = bd1;\n    bd1 = tmp;\n  }\n  col *= 1.0-exp(-200.0/z*max(bd0, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, bd0));\n  col *= 1.0-exp(-200.0/z*max(bd1, 0.0));\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, bd1));\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const float pr = 10.0;\n  float z = mix(0.5, 1.5, smoothstep(-0.5, 0.5, -cos(TIME*TAU/30.0)));\n  p /= z;\n  p += pr*sin(0.5*vec2(1.0, sqrt(0.5))*TIME/pr);\n  vec3 col = vec3(0.0);\n  float aa = 4.0/(z*RESOLUTION.y);\n\n\n  vec2 cp = p;\n  vec2 np = round(cp);\n  float nh0 = hash(np+123.4);\n  cp -= np;\n  if (nh0 > 0.5) cp = cp*ROT(PI/2.0);\n\n  vec2 bp = cp;\n  float bn = ref(bp, normalize(vec2(1.0)));\n  bp -= 0.5;\n  col = braid(col, p, bp, z, aa);\n  col = sqrt(col);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 534, 561, 561, 637], [639, 725, 774, 774, 1173], [1175, 1175, 1208, 1208, 1289], [1291, 1351, 1372, 1372, 1442], [1444, 1444, 1502, 1502, 2502], [2504, 2504, 2525, 2525, 3005], [3007, 3007, 3062, 3062, 3218]]}
{"id": "mtdXDs", "name": "Circles simple test", "author": "BaldPolnareff", "description": "just a test", "tags": ["circles", "uv"], "likes": 2, "viewed": 130, "published": 3, "date": "1685885787", "time_retrieved": "2024-07-30T17:52:21.492987", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y; // -1 to 1 centered UVs\n\n    vec2 uv0 = uv; // copying original UVs for later\n    vec3 finalColor = vec3(uv.x, uv.y, 0.); // initialize final color to 0 \n\n    \n    float circle = 2.1*length(finalColor);\n    for (float i = 10.2; i < 11.1; i++){\n        circle = 1.2*sin(pow(smoothstep(pow(fract(circle * i / 2.1), 2.2), 1.5, .65*circle), 1.) + .9 * iTime); \n        fragColor = .2 * vec4(.2 * i * circle + sin(iTime *.1), .4 * i * circle, i/20. * circle, 1.0); \n        // adding distortion with noise\n        vec3 distortion = .3 * (vec3(uv * 1.2, iTime * 0.2));\n        fragColor = vec4(fragColor.xyz + 2.*distortion.x + 2.*distortion.y, 1.0);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 776]]}
{"id": "ctdSWs", "name": "tan hyberpolique", "author": "mtoon", "description": "shader", "tags": ["shader"], "likes": 2, "viewed": 112, "published": 3, "date": "1685877823", "time_retrieved": "2024-07-30T17:52:22.251958", "image_code": "    vec3 palette( float t ) {\n    vec3 a = vec3(0.300, 0.500, 0.300); \n    vec3 b = vec3(1.248, -0.932, 0.448);\n    vec3 c = vec3(1.438, 0.748, 1.328); \n    vec3 d = vec3(1.198, 1.532, 1.865);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n    vec3 palette2( float t ) {  \n    vec3 a = vec3(0.529,0.529,0.529);\n    vec3 b = vec3(1., -0.292, -1.);\n    vec3 c = vec3(0.638, -1.492, 1.648);\n    vec3 d = vec3(-1.305, -1.123, 0.235);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/(iResolution.xy);\n    uv = uv +(-iMouse.xy/iResolution.xy);\n    vec2 fractUV = fract(uv) - 0.5;\n    float d = length(uv);\n    float fractD = length(fractUV);\n\n    // Time varying pixel color\n    vec3 col = palette(tanh(fractD*2.)+(iTime/5.));\n    col = (cos(iTime)/3.+0.5)/col;\n    col = col * palette2(tanh(d)+(iTime/3.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 29, 29, 236], [242, 242, 268, 268, 475], [478, 478, 535, 585, 990]]}
{"id": "cltSWl", "name": "Simple Keying with Trail Effect", "author": "s_fx", "description": "The keying is very basic and you can still see some green edges present in the final result.", "tags": ["greenscreen", "trail", "alphakey"], "likes": 3, "viewed": 276, "published": 3, "date": "1685868250", "time_retrieved": "2024-07-30T17:52:23.073761", "image_code": "/*\n * Simple Keying and Trail Effect (Main Image)\n * (c) 2023 s.fx\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n * Simple Keying and Trail Effect (Buffer A)\n * (c) 2023 s.fx\n */\n\nconst vec3  KEYCOLOR  = vec3(0.0471, 0.6392, 0.1451); // key color (for this video: rgb(12, 163, 37))\nconst float DECAY     = .01;                          // how much is subtracted from previous frame\nconst float DEVIATION = .3;                           // how much the color can deviate from the key color\n\nbool key(in vec3 col, in vec3 keyVal, in float deviation)\n{\n    // check if given color is in range between keyVal + and - deviation\n    return all(greaterThan(keyVal + deviation, col)) && all(greaterThan(col, keyVal - deviation));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel1, uv);\n\n    if (key(col.rgb, KEYCOLOR, DEVIATION))\n        col = texture(iChannel0, uv) - DECAY;\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 195]]}
{"id": "DttSWl", "name": "benchmark of apple logo1", "author": "chenxianming", "description": "view this benchmark via\nhttp://benchart.cn/bb29k56c", "tags": ["benchmark", "cineshader"], "likes": 5, "viewed": 1329, "published": 3, "date": "1685867691", "time_retrieved": "2024-07-30T17:52:23.897558", "image_code": "#define FMB 1\n#define darkness .52\n#if FMB == 1\n#define dis .6\n#else\n#define dis 0.\n#endif\n\n\n\n\nfloat e(float a){return fract(iTime*a)*3.141593*4.;}\nfloat g(float a,float b,float c){float d=clamp(.5+.5*(b-a)/c,0.,1.);\nreturn mix(b,a,d)-c*d*(1.-d);}\nmat2 j(float a){float b=sin(a),c=cos(a);\nreturn mat2(c,b,-b,c);}\nconst mat2 J=mat2(-1.1,-.4,.3,1);\nfloat K(in vec2 a){return sin(a.x)*sin(a.y);}\nfloat r(vec2 b){float c=0.;for(float a=0.;a<5.;a++)c+=.15*K(b*a),b=J*b*abs(a-2.)*2.3;return c/1.;}\nvec2 s(vec2 a){return vec2(r(a),r(a+vec2(7.8)));}\nfloat t(vec3 c,int f){vec3 a=c;a.xz*=j(sin(e(.05))*.25),a.y+=.1;\nfloat b=length(a)-.2;b=g(b,length(a+vec3(.13,.13,0))-.1,.08),b=g(b,length(a+vec3(-.13,.13,0))-.1,.08),b=g(b,length(a+vec3(-.13,-.04,0))-.1,.2),b=g(b,length(a+vec3(.13,-.04,0))-.1,.2),b=g(b,length(a+vec3(.17,-.19,0))-.12,.2),b=g(b,length(a+vec3(-.17,-.19,0))-.12,.2);float d=max(length(a.xy+vec2(.33,-.1))-.15,abs(a.z)-1.3);b=max(b,-d),a.x-=.25,a.y-=.08,a.xy*=j(.785398),b=min(b,max(length(a+vec3(.08,-.5,0))-.12,length(a+vec3(-.08,-.5,0))-.12)),b+=s(a.xz).y*dis*s(a.xy).x*1.*cos(a).y*1.*.6;return b;}float h(vec3 a){vec3 b=a;float c=t(b,1);return c;}\nvec3 u(in vec3 b){vec2 a=vec2(1,-1)*.5773;return normalize(a.xyy*h(b+a.xyy*5e-4)+a.yyx*h(b+a.yyx*5e-4)+a.yxy*h(b+a.yxy*5e-4)+a.xxx*h(b+a.xxx*5e-4));}\nvec3 m(vec2 a){vec2 b=a.xy-.5,c=b.xy*b.xy+sin(a.x*18.+e(.05))/25.*sin(a.y*7.+e(.05)*1.5)+a.x*sin(e(.05))/16.+a.y*sin(e(.05)*1.2)/16.;\nfloat d=sqrt(abs(c.x+c.y*.5)*25.)*5.;return vec3(sin(d*1.25+2.),abs(sin(d*1.-1.)-sin(d)),abs(sin(d)*1.));}\n\n\nvoid mainImage( out vec4 U, in vec2 V ){\n\tvec2 c=V.xy/iResolution.xy;c=(c-.5)*2.,c.x*=iResolution.x/iResolution.y;\n\tvec3 v=vec3(0,0,0),d=vec3(0,0,-.75),f=normalize(v-d),k=normalize(cross(f,vec3(0,1,0))),w=normalize(cross(k,f)),x=vec3(0),b=normalize(c.x*k+c.y*w+1.5*f);\n\tfloat i=0.;for(int y=0;y<32;++y){vec3 z=d+b*i;\n\tfloat L=h(z);i+=L*.99999;}vec3 l=vec3(0),n=normalize(vec3(.57703));\n\tn.xy*=j(fract(iTime*.135)*3.141593*2.);vec3 A=normalize(n-b),o=normalize(vec3(.57703));\n\to.xy*=j(fract(iTime*.135)*3.141593*2.+3.141593);vec3 B=normalize(o-b),p=normalize(vec3(0,0,-.2));\n\tp.xz*=j(fract(iTime*.135)*3.141593*2.);vec3 C=normalize(p-b);if(i<5.){vec3 D=d+i*b,a=u(D);float E=clamp(dot(a,vec3(0,.5,.3)),0.,1.),F=clamp(dot(a,vec3(0,-.5,.3)),0.,1.),M=clamp(dot(a,vec3(0,.1,-.1)),0.,1.),G=pow(clamp(dot(a,A),darkness,1.),10.);G*=E+F;float H=pow(clamp(dot(a,B),darkness,1.),15.);H*=E+F;\n\tfloat I=pow(clamp(dot(a,C),darkness,1.),15.);\n\tI*=M;\n\tfloat N=dot(a,vec3(0,1,0));\n\tvec3 q=reflect(a*.03,b*.08);\n\tl=G*m(q.xy)+H*m(q.xy)+I*m(q.xy)*.8;}\n\tl=sqrt(l),x+=l,U=vec4(x,1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 112, 112, 147], [148, 148, 181, 181, 247], [248, 248, 264, 264, 312], [347, 347, 366, 366, 392], [393, 393, 409, 409, 491], [492, 492, 507, 507, 541], [542, 542, 564, 564, 1107], [1107, 1107, 1123, 1123, 1157], [1158, 1158, 1176, 1176, 1307], [1308, 1308, 1323, 1323, 1548], [1551, 1551, 1591, 1591, 2613]]}
{"id": "mlcXWs", "name": "Raymarching (Cube-Sphere)UCube 2", "author": "silica163", "description": "render Cube - Sphere U Sphere with ray marching", "tags": ["raymarching", "raymarch", "spheretracing", "reflect"], "likes": 2, "viewed": 237, "published": 3, "date": "1685865835", "time_retrieved": "2024-07-30T17:52:24.763243", "image_code": "//#extension GL_OES_standard_derivatives : enable\n\n//precision highp float;\n\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  20.\n#define MIN_DIST  .001\n#define MAX_STEP  128\n#define MAX_REF   3\n\nconst int LIGHTS = 4;\nconst int SPHERES = 3;\nconst int CUBES = 2;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Sphere {\n\tvec4 p;\n\tvec3 color;\n};\n\t\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n};\n\nSphere sp[SPHERES];\nCube cu[CUBES];\nLight l[LIGHTS];\n\nvoid init(){\n    sp[0] = Sphere(vec4(0,0,0,1.3),vec3(0));\n    sp[1] = Sphere(vec4(0,0,-.5,.4),vec3(0));\n    \n    sp[2] = Sphere(vec4(0,0,.5,.4),vec3(0));\n    \n    cu[0] = Cube(vec3(0,0,0),vec3(0),vec3(1));\n    cu[1] = Cube(vec3(0,-1,0),vec3(0),vec3(3.,.01,3.));\n\n    l[0].p = vec3(sin(2./3.*PI*2.)*1.5,2,cos(2./3.*PI*2.)*1.5);\n    l[0].c = vec3(0,0,1);\n\n    l[1].p = vec3(sin(1./3.*PI*2.)*1.5,2,cos(1./3.*PI*2.)*1.5);\n    l[1].c = vec3(1,0,0);\n    \n    l[2].p = vec3(sin(0.)*1.5,2,cos(0.)*1.5);\n    l[2].c = vec3(0,1,0);\n\n    l[3].p = vec3(0,5,0);\n    l[3].c = vec3(1);\n}\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nfloat max3(vec3 n){\n    return max(max(n.x,n.y),n.z);\n}\n\nfloat cubeSDF(vec3 p,int id){\n    vec3 c = abs(p-cu[id].p)-cu[id].s;\n    return length(max(c,0.)) + min(0.,max3(c));\n}\n\nfloat sphereSDF(vec3 p, int id){\n    float d = length(p - sp[id].p.xyz) - sp[id].p.w;\n    return d;\n}\n\t\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n\td = sphereSDF(p,0);\n\t\n\td = max(cubeSDF(p,0)-.01,-d);\n\td = min(d,cubeSDF(p,1));\n    d = min(d,sphereSDF(p,1));\n    d = min(d,sphereSDF(p,2));\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvec3 colorDiff(Light l,Ray r){\n\tvec3 c = vec3(0);\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += l.c * d;\n\t\n\treturn c;\n}\n\nfloat bPhong(Light l,Ray r){\n\tfloat c = 0.;\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += pow(max(dot(normalize(l.L+V),N),0.),100.)*2. * d;\n\t\n\treturn c;\n}\n\nfloat shadowMask(vec3 p,vec3 l){\n\tfloat m = 1.;\n\tfloat x = 10.;\n\tRay r = Ray(p+N*MIN_DIST*x,p+N*MIN_DIST*x,normalize(l-p),vec3(0),0.,0.);\n\tmarch(r,0);\n\tif(r.dist < length(l-p))m = 0.1;\n\treturn m;\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 getColor(Light l,Ray r){\n    return ((colorDiff(l,r) + bPhong(l,r)*l.c) * vec3(shadowMask(r.p,l.p)))/length(r.p-l.p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / resolution.xy )*2.-1.;\n\tuv.x*= resolution.x/resolution.y;\n\tuv*=2.;\n\tvec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    //m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n\tfloat camz = PI;\n\tvec3 ca = vec3(\n\t\tPI/2.+m.y*PI/2.,\n\t\tPI/2.+m.x*PI/1.,\n\t\t0\n\t);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n\tvec3 camera = vec3(0,0,camz)*rotX*rotY;\n\tvec3 plane = (vec3(uv,0)*rotX*rotY);\n\t\n\tRay r = Ray(camera,camera,normalize(plane-camera),vec3(0),0.,0.);\n    \n    init();\n\tmarch(r,1);\n\t\n\tvec3 c = vec3(.2);\n\tN = sNormal(r.p);\n\tV = -r.dir;\n    \n    Ray fr = r;\n\t\n\tfor(int i = 0;i<LIGHTS;i++){\n        lNormal(l[i],r);\n        c += getColor(l[i],r);\n    }\n    vec3 fc = c;\n    //c *= 0.;\n    \n    for( int i = 0;i< MAX_REF;i++){\n        r.dir = reflect(r.dir,N);\n        r.o = r.p + N * MIN_DIST;\n        r.p = r.o;\n        r.dist = 0.;\n        \n        march(r,1);\n        N = sNormal(r.p);\n        if(r.rl > 20.)break;\n        V = -r.dir;\n    \n        for(int i = 0;i<LIGHTS;i++){\n            lNormal(l[i],r);\n            c += (getColor(l[i],r)*pow(.9,float(i))*2./r.rl );\n            if(length(r.p-l[i].p)-.1 <= MIN_DIST) c = l[i].c*5.;\n        }\n    }\n    //c += fc*.1+.2;\n    //c *= fc;\n    \n    //c *= 1./vec3(r.rl);\n\t\t\n\tif(fr.dist > MAX_DIST) c = vec3(.1);\n    for(int i = 0;i< LIGHTS;i++){\n        if(length(fr.p-l[i].p)-.1 <= MIN_DIST) c = l[i].c*5.;\n    }\n\n\tfragColor = vec4( c, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[673, 673, 685, 685, 1244], [1283, 1283, 1302, 1302, 1338], [1340, 1340, 1369, 1369, 1458], [1460, 1460, 1492, 1492, 1561], [1564, 1564, 1583, 1583, 1760], [1762, 1762, 1794, 1794, 1881], [1883, 1883, 1913, 1913, 2122], [2124, 2124, 2145, 2145, 2276], [2278, 2278, 2307, 2307, 2355], [2357, 2357, 2387, 2387, 2467], [2469, 2469, 2497, 2497, 2614], [2616, 2616, 2648, 2648, 2813], [2815, 2815, 2849, 2849, 2878], [2880, 2880, 2909, 2909, 3004], [3006, 3006, 3062, 3062, 4640]]}
{"id": "mlcXDl", "name": "Fork Fork  Pix ItsAlmostP 616", "author": "ItsAlmostPG", "description": "I couldn't resist adding the music visualizer...", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 2, "viewed": 218, "published": 3, "date": "1685861668", "time_retrieved": "2024-07-30T17:52:25.827398", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n\nvec4 hue(float x)\n{\n    return .5+.5*cos(6.283185*(x +vec4(0,1,-1,0)/3.)); // by FabriceNeyret2 from https://www.shadertoy.com/view/MtG3Wh\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    // Looks buggy around the border\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    //float a = texelFetch(iChannel0, ivec2(sc*f), 0).a;\n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));// + .5 * thc(4.,.2*uv.y+0.24*ix*pi+iTime);\n    //mx *= 0.5 + 0.5 * thc(4., 0.5 * iTime);\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n      \n    //float o = 2.*pi/3.;\n    //col += 0.2 * thc(40000., log(length(uv))*0.25 -0.5*iTime+ vec3(-o,0,o));\n\n    //vec3 col2 = vec3(exp(-8.*f.y/iResolution.y));\n    //col = mix(col, (1.-col) + col2, .5+.5*thc(40.,ix*pi + iTime));\n    //col = mix(col, col2, 1.-tx);\n        \n    fragColor = vec4(col,1.0);\n    fragColor *= hue(f.y/iResolution.y*0.3+iTime)*pow(texture(iChannel1, vec2(f.y/iResolution.y/50., 0), 6.).r, 6.)*0.7+0.3;\n    //fragColor = ;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n\n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\nvec2 footHeight(float t, float sw) {\n    t *= 0.1;\n    //return vec2(0);\n    return vec2(10. + 10. * cos(t + 0.01 * sw), 10. + 10. * cos(t));\n}\n\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 6. * iTime;\n       \n    float w = 64.;\n    f.x += floor(-5.*t);\n    float ix = floor(f.x / w);\n    f.x = mod(f.x, w) - w/2.;\n    f -= 0.5;\n\n    // Random values (sloppy)\n    vec4 h = h41(ix);\n    vec4 h2 = h41(2.*ix-103.4);\n    vec4 h3 = h41(-1.1*ix + 513.2);\n    vec4 h4 = h41(-0.21*ix + 317.);\n    t += 2.*pi*h.z;\n\n    // --- PARAMETERS ---  \n      \n    float sw = -2. - 20. * h.z;     // Stride width\n    vec2  sh = vec2(8); // Stride height (Left, Right)\n    \n    float vHip = 4.;         // Hip vertical motion per step\n    float xHip = (1.+5.*h4.x) * (1.5-2.*abs(cos(t))); // Hip horizontal offset\n    vec2 dimHip = vec2(8.,4.) * h2.y; // Hip dims (Length, Height-Osc)\n    float hHip = 15. + 20. * h.x;// Hip height\n    float aHip = -t;      // Hip angle\n    \n    float dTor = 4. + 35. * h.y;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(10. * h2.y, 10. * h2.z);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = (.35 + .5 * h2.w) * hHip;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    vec2 hFoot = 2.+0.*footHeight(t, sw); // Foot height\n    vec2 dFoot = vec2(4); // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(4. + 10. * h.z);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi + 0.5*pi*(h4.z-0.5)   // Elbow angle\n                -0.5 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = 0.8 * (1. + h4.y) * dElb;//vec2(2. + 10. * h.w);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi // Hand angle \n                 -1.3 * h3.x * pi * vec2(cos(t), -cos(t));\n    \n    //vec2 dFing = vec2(2); // Finger length\n    \n    float dNeck = 2. + 10. * h3.y;             // Neck length\n    float aNeck = pi/2.+pi/8.*cos(t) + // Neck angle\n                  (2.*h3.z-1.) * pi/4.; \n    \n    float dHead = floor(2. + 6. * h3.w); // Head radius\n \n \n \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, 0.*0.5*hFoot + hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), \n                        hFoot.x + sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), \n                        hFoot.y + sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = vec2(x+tf-sw*cos(t+o), \n                      hFoot.x + .5*sh.x*stride(.5*t+o, 0.));\n    vec2 pToe2 = vec2(x+tf+sw*cos(t+o), \n                      hFoot.y + .5*sh.y*stride(.5*t+o, 1.));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot.x * fdir1);\n    pToe2 = round(pFoot2 + dFoot.y * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Neck\n    vec2 dirHead = vec2(cos(aNeck), sin(aNeck)); \n    vec2 pHead = round(pNeck + dNeck * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - dHead * dirHead));\n    float sHead = step(head, dHead + .5);\n    col.b += sHead;\n   \n    float l = 1.-step(30.+20.*cos(0.1*t + 0.01*f.x), f.y);\n   \n    //float l = length(col);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, l);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nfloat mx(vec4 b) {\n    return max(b.x,max(b.y,b.z));\n}\n\nfloat mx(float a, vec4 b) {\n    return max(max(a,b.x),max(b.y,b.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    float n = 2.; \n    vec4 e = vec4(0); // Colors\n    vec4 e2 = vec4(0);\n    float p = 0.;     // Outline\n    for (float i = -n; i < n + 1.; i++) {\n        for (float j = -n; j < n + 1.; j++) {\n            vec4 c = cell(iChannel0, ivec2(f + vec2(i,j)));\n            if (abs(i) <= n-1. && abs(j) <= n-1.)    \n                e = max(e, c);\n            if (abs(i) != n || abs(j) != n) {\n                e2 = max(e2, c);\n                p = mx(p, c);            \n            }\n        }\n    }\n   \n    // Could replace RGB with just R and use different values\n    e.rb *= step(e.g, 0.);\n    e.r  *= step(e.b, 0.);\n    \n    e2.rb *= step(e2.g, 0.);\n    e2.r  *= step(e2.b, 0.);\n    float q = mx(e);\n    \n    if (e.b > 0.)\n        e.b -= 0.25 * e2.g;\n    if (e.r > 0.)\n        e.r -= 0.25 * e2.b;\n    e.rgb += vec3(p-q);\n\n    //e = e2 - e;//vec4(p-q);\n\n   // vec4 e3 = cell(iChannel1, ivec2(f + vec2(1,2)));\n   // e = mix(e, e3, 0.1);\n\n    fragColor = e;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n// Improvements:\n// - Interior outline if arm overlaps leg\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 260, 260, 381], [383, 383, 432, 469, 1889]]}
{"id": "mtcXDl", "name": "Fork  Pixel Ra ItsAlmostP 469", "author": "ItsAlmostPG", "description": "I couldn't resist adding the music visualizer...", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 4, "viewed": 489, "published": 3, "date": "1685861490", "time_retrieved": "2024-07-30T17:52:26.592353", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n\nvec4 hue(float x)\n{\n    return .5+.5*cos(6.283185*(x +vec4(0,1,-1,0)/3.)); // by FabriceNeyret2 from https://www.shadertoy.com/view/MtG3Wh\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    // Looks buggy around the border\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    //float a = texelFetch(iChannel0, ivec2(sc*f), 0).a;\n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));// + .5 * thc(4.,.2*uv.y+0.24*ix*pi+iTime);\n    //mx *= 0.5 + 0.5 * thc(4., 0.5 * iTime);\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n      \n    //float o = 2.*pi/3.;\n    //col += 0.2 * thc(40000., log(length(uv))*0.25 -0.5*iTime+ vec3(-o,0,o));\n\n    //vec3 col2 = vec3(exp(-8.*f.y/iResolution.y));\n    //col = mix(col, (1.-col) + col2, .5+.5*thc(40.,ix*pi + iTime));\n    //col = mix(col, col2, 1.-tx);\n        \n    fragColor = vec4(col,1.0);\n    fragColor *= hue(f.y/iResolution.y*0.3+iTime)*pow(texture(iChannel1, vec2(f.y/iResolution.y/50., 0), 6.).r, 6.)*0.7+0.3;\n    //fragColor = ;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n\n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\nvec2 footHeight(float t, float sw) {\n    t *= 0.1;\n    //return vec2(0);\n    return vec2(10. + 10. * cos(t + 0.01 * sw), 10. + 10. * cos(t));\n}\n\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 6. * iTime;\n       \n    float w = 64.;\n    f.x += floor(-5.*t);\n    float ix = floor(f.x / w);\n    f.x = mod(f.x, w) - w/2.;\n    f -= 0.5;\n\n    // Random values (sloppy)\n    vec4 h = h41(ix);\n    vec4 h2 = h41(2.*ix-103.4);\n    vec4 h3 = h41(-1.1*ix + 513.2);\n    vec4 h4 = h41(-0.21*ix + 317.);\n    t += 2.*pi*h.z;\n\n    // --- PARAMETERS ---  \n      \n    float sw = -2. - 20. * h.z;     // Stride width\n    vec2  sh = vec2(8); // Stride height (Left, Right)\n    \n    float vHip = 4.;         // Hip vertical motion per step\n    float xHip = (1.+5.*h4.x) * (1.5-2.*abs(cos(t))); // Hip horizontal offset\n    vec2 dimHip = vec2(8.,4.) * h2.y; // Hip dims (Length, Height-Osc)\n    float hHip = 15. + 20. * h.x;// Hip height\n    float aHip = -t;      // Hip angle\n    \n    float dTor = 4. + 35. * h.y;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(10. * h2.y, 10. * h2.z);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = (.35 + .5 * h2.w) * hHip;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    vec2 hFoot = 2.+0.*footHeight(t, sw); // Foot height\n    vec2 dFoot = vec2(4); // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(4. + 10. * h.z);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi + 0.5*pi*(h4.z-0.5)   // Elbow angle\n                -0.5 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = 0.8 * (1. + h4.y) * dElb;//vec2(2. + 10. * h.w);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi // Hand angle \n                 -1.3 * h3.x * pi * vec2(cos(t), -cos(t));\n    \n    //vec2 dFing = vec2(2); // Finger length\n    \n    float dNeck = 2. + 10. * h3.y;             // Neck length\n    float aNeck = pi/2.+pi/8.*cos(t) + // Neck angle\n                  (2.*h3.z-1.) * pi/4.; \n    \n    float dHead = floor(2. + 6. * h3.w); // Head radius\n \n \n \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, 0.*0.5*hFoot + hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), \n                        hFoot.x + sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), \n                        hFoot.y + sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = vec2(x+tf-sw*cos(t+o), \n                      hFoot.x + .5*sh.x*stride(.5*t+o, 0.));\n    vec2 pToe2 = vec2(x+tf+sw*cos(t+o), \n                      hFoot.y + .5*sh.y*stride(.5*t+o, 1.));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot.x * fdir1);\n    pToe2 = round(pFoot2 + dFoot.y * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Neck\n    vec2 dirHead = vec2(cos(aNeck), sin(aNeck)); \n    vec2 pHead = round(pNeck + dNeck * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - dHead * dirHead));\n    float sHead = step(head, dHead + .5);\n    col.b += sHead;\n   \n    float l = 1.-step(30.+20.*cos(0.1*t + 0.01*f.x), f.y);\n   \n    //float l = length(col);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, l);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nfloat mx(vec4 b) {\n    return max(b.x,max(b.y,b.z));\n}\n\nfloat mx(float a, vec4 b) {\n    return max(max(a,b.x),max(b.y,b.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    float n = 2.; \n    vec4 e = vec4(0); // Colors\n    vec4 e2 = vec4(0);\n    float p = 0.;     // Outline\n    for (float i = -n; i < n + 1.; i++) {\n        for (float j = -n; j < n + 1.; j++) {\n            vec4 c = cell(iChannel0, ivec2(f + vec2(i,j)));\n            if (abs(i) <= n-1. && abs(j) <= n-1.)    \n                e = max(e, c);\n            if (abs(i) != n || abs(j) != n) {\n                e2 = max(e2, c);\n                p = mx(p, c);            \n            }\n        }\n    }\n   \n    // Could replace RGB with just R and use different values\n    e.rb *= step(e.g, 0.);\n    e.r  *= step(e.b, 0.);\n    \n    e2.rb *= step(e2.g, 0.);\n    e2.r  *= step(e2.b, 0.);\n    float q = mx(e);\n    \n    if (e.b > 0.)\n        e.b -= 0.25 * e2.g;\n    if (e.r > 0.)\n        e.r -= 0.25 * e2.b;\n    e.rgb += vec3(p-q);\n\n    //e = e2 - e;//vec4(p-q);\n\n   // vec4 e3 = cell(iChannel1, ivec2(f + vec2(1,2)));\n   // e = mix(e, e3, 0.1);\n\n    fragColor = e;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n// Improvements:\n// - Interior outline if arm overlaps leg\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 31485, "src": "https://soundcloud.com/kordhell/murder-in-my-mind", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 260, 260, 381], [383, 383, 432, 469, 1889]]}
{"id": "dtcXDl", "name": "Fork  Pixel Ra ItsAlmostP 366", "author": "ItsAlmostPG", "description": "I couldn't resist adding the music visualizer...", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 1, "viewed": 182, "published": 3, "date": "1685861384", "time_retrieved": "2024-07-30T17:52:27.613622", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n\nvec4 hue(float x)\n{\n    return .5+.5*cos(6.283185*(x +vec4(0,1,-1,0)/3.)); // by FabriceNeyret2 from https://www.shadertoy.com/view/MtG3Wh\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    // Looks buggy around the border\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    //float a = texelFetch(iChannel0, ivec2(sc*f), 0).a;\n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));// + .5 * thc(4.,.2*uv.y+0.24*ix*pi+iTime);\n    //mx *= 0.5 + 0.5 * thc(4., 0.5 * iTime);\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n      \n    //float o = 2.*pi/3.;\n    //col += 0.2 * thc(40000., log(length(uv))*0.25 -0.5*iTime+ vec3(-o,0,o));\n\n    //vec3 col2 = vec3(exp(-8.*f.y/iResolution.y));\n    //col = mix(col, (1.-col) + col2, .5+.5*thc(40.,ix*pi + iTime));\n    //col = mix(col, col2, 1.-tx);\n        \n    fragColor = vec4(col,1.0);\n    fragColor *= hue(f.y/iResolution.y*0.3+iTime)*pow(texture(iChannel1, vec2(f.y/iResolution.y/50., 0), 6.).r, 6.)*0.7+0.3;\n    //fragColor = ;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n\n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\nvec2 footHeight(float t, float sw) {\n    t *= 0.1;\n    //return vec2(0);\n    return vec2(10. + 10. * cos(t + 0.01 * sw), 10. + 10. * cos(t));\n}\n\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 6. * iTime;\n       \n    float w = 64.;\n    f.x += floor(-5.*t);\n    float ix = floor(f.x / w);\n    f.x = mod(f.x, w) - w/2.;\n    f -= 0.5;\n\n    // Random values (sloppy)\n    vec4 h = h41(ix);\n    vec4 h2 = h41(2.*ix-103.4);\n    vec4 h3 = h41(-1.1*ix + 513.2);\n    vec4 h4 = h41(-0.21*ix + 317.);\n    t += 2.*pi*h.z;\n\n    // --- PARAMETERS ---  \n      \n    float sw = -2. - 20. * h.z;     // Stride width\n    vec2  sh = vec2(8); // Stride height (Left, Right)\n    \n    float vHip = 4.;         // Hip vertical motion per step\n    float xHip = (1.+5.*h4.x) * (1.5-2.*abs(cos(t))); // Hip horizontal offset\n    vec2 dimHip = vec2(8.,4.) * h2.y; // Hip dims (Length, Height-Osc)\n    float hHip = 15. + 20. * h.x;// Hip height\n    float aHip = -t;      // Hip angle\n    \n    float dTor = 4. + 35. * h.y;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(10. * h2.y, 10. * h2.z);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = (.35 + .5 * h2.w) * hHip;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    vec2 hFoot = 2.+0.*footHeight(t, sw); // Foot height\n    vec2 dFoot = vec2(4); // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(4. + 10. * h.z);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi + 0.5*pi*(h4.z-0.5)   // Elbow angle\n                -0.5 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = 0.8 * (1. + h4.y) * dElb;//vec2(2. + 10. * h.w);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi // Hand angle \n                 -1.3 * h3.x * pi * vec2(cos(t), -cos(t));\n    \n    //vec2 dFing = vec2(2); // Finger length\n    \n    float dNeck = 2. + 10. * h3.y;             // Neck length\n    float aNeck = pi/2.+pi/8.*cos(t) + // Neck angle\n                  (2.*h3.z-1.) * pi/4.; \n    \n    float dHead = floor(2. + 6. * h3.w); // Head radius\n \n \n \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, 0.*0.5*hFoot + hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), \n                        hFoot.x + sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), \n                        hFoot.y + sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = vec2(x+tf-sw*cos(t+o), \n                      hFoot.x + .5*sh.x*stride(.5*t+o, 0.));\n    vec2 pToe2 = vec2(x+tf+sw*cos(t+o), \n                      hFoot.y + .5*sh.y*stride(.5*t+o, 1.));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot.x * fdir1);\n    pToe2 = round(pFoot2 + dFoot.y * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Neck\n    vec2 dirHead = vec2(cos(aNeck), sin(aNeck)); \n    vec2 pHead = round(pNeck + dNeck * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - dHead * dirHead));\n    float sHead = step(head, dHead + .5);\n    col.b += sHead;\n   \n    float l = 1.-step(30.+20.*cos(0.1*t + 0.01*f.x), f.y);\n   \n    //float l = length(col);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, l);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nfloat mx(vec4 b) {\n    return max(b.x,max(b.y,b.z));\n}\n\nfloat mx(float a, vec4 b) {\n    return max(max(a,b.x),max(b.y,b.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    float n = 2.; \n    vec4 e = vec4(0); // Colors\n    vec4 e2 = vec4(0);\n    float p = 0.;     // Outline\n    for (float i = -n; i < n + 1.; i++) {\n        for (float j = -n; j < n + 1.; j++) {\n            vec4 c = cell(iChannel0, ivec2(f + vec2(i,j)));\n            if (abs(i) <= n-1. && abs(j) <= n-1.)    \n                e = max(e, c);\n            if (abs(i) != n || abs(j) != n) {\n                e2 = max(e2, c);\n                p = mx(p, c);            \n            }\n        }\n    }\n   \n    // Could replace RGB with just R and use different values\n    e.rb *= step(e.g, 0.);\n    e.r  *= step(e.b, 0.);\n    \n    e2.rb *= step(e2.g, 0.);\n    e2.r  *= step(e2.b, 0.);\n    float q = mx(e);\n    \n    if (e.b > 0.)\n        e.b -= 0.25 * e2.g;\n    if (e.r > 0.)\n        e.r -= 0.25 * e2.b;\n    e.rgb += vec3(p-q);\n\n    //e = e2 - e;//vec4(p-q);\n\n   // vec4 e3 = cell(iChannel1, ivec2(f + vec2(1,2)));\n   // e = mix(e, e3, 0.1);\n\n    fragColor = e;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n// Improvements:\n// - Interior outline if arm overlaps leg\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 31485, "src": "https://soundcloud.com/kordhell/murder-in-my-mind", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 260, 260, 381], [383, 383, 432, 469, 1889]]}
{"id": "dt3XDl", "name": "Fork 3D Audio V ItsAlmostP 974", "author": "ItsAlmostPG", "description": "Continuation of my attemps to extract audio features from a song", "tags": ["raymarching", "sound", "interactive", "music", "pixel", "light", "bloom", "visual", "live", "neon"], "likes": 7, "viewed": 693, "published": 3, "date": "1685860989", "time_retrieved": "2024-07-30T17:52:28.435425", "image_code": "/* \"3D Audio Visualizer\" by @kishimisu - 2022 (https://www.shadertoy.com/view/dtl3Dr)\n   Wait for the drop!\n\n   The lights of this scene react live to the audio input.\n   I'm trying to find interesting ways to extract audio\n   features from the audio's FFT to animate my scenes.\n   \n   Each light is associated to a random frequency range,\n   ranging from bass (distant lights) to high (close lights)   \n   \n   Really happy with this result!\n*/\n\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   float c = st(0., 10., .8, 1.), a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv   = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col  = vec3(0.);\n    float vol = getVol(8.);\n    \n    float hasSound = 1.; // Used only to avoid a black preview image\n    if (iChannelTime[0] <= 0.) hasSound = .0;\n \n    for (float i = 0., t = 0.; i < 30.; i++) {\n        vec3 p  = t*normalize(vec3(uv, 1.));        \n        \n        vec3 id = floor(abs(p));\n        vec3 q  = fract(p)-.5;\n        \n        float boxRep = sdBox(q, vec3(.3));\n        float boxCtn = sdBox(p, vec3(7.5, 6.5, 16.5));\n\n        float dst = max(boxRep, abs(boxCtn) - vol*.2);     \n        float freq = smoothstep(16., 0., id.z)*3.*hasSound + hash13(id)*1.5;\n       \n        col += vec3(.8,.6,1) * (cos(id*.4 + vec3(0,1,2) + iTime) + 2.) \n             * light(dst, 10. - vol) \n             * getPitch(freq, 1.);\n        \n        t += dst;\n    }\n    \n    fragColor = vec4(col,1.0);   \n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3XDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[713, 713, 742, 742, 874], [875, 875, 916, 916, 1034], [1035, 1035, 1064, 1064, 1181], [1213, 1213, 1244, 1244, 1331], [1332, 1332, 1355, 1355, 1458], [1460, 1460, 1517, 1517, 2399]]}
{"id": "ml3SDl", "name": "Cube - Sphere U Sphere", "author": "silica163", "description": "render Cube - Sphere U Sphere with ray marching", "tags": ["raymarching", "raymarch", "spheretracing"], "likes": 1, "viewed": 150, "published": 3, "date": "1685859753", "time_retrieved": "2024-07-30T17:52:29.197388", "image_code": "//#extension GL_OES_standard_derivatives : enable\n\n//precision highp float;\n\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST 100.\n#define MIN_DIST .00001\n#define MAX_STEP  128\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n};\n\nstruct Sphere {\n\tvec4 p;\n\tvec3 color;\n};\n\t\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n\tvec3 L;\n} light;\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\t\nfloat dist(vec3 p){\n\tfloat d = 0.;\n\td = length(p-vec3(0,0,0))-.65;\n\t\n\tvec3 cu = abs(p-vec3(0,0,0))-.5;\n\tvec3 cu2 = abs(p-vec3(0,-.5,0))-vec3(3.,.01,3.);\n\t\n\td = max(length(max(cu,0.)) + min(0.,max(cu.x,max(cu.y,cu.z)))-.005,-d);\n\td = min(d,length(max(cu2,0.)) + min(0.,max(cu2.x,max(cu2.y,cu2.z))));\n    d = min(d,length(p-vec3(0,0,0))-.3);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n\td = min(length(p-vec3(sin(2./3.*PI*2.)*1.5,1,cos(2./3.*PI*2.)*1.5))-.1,d);\n\td = min(length(p-vec3(sin(1./3.*PI*2.)*1.5,1,cos(1./3.*PI*2.)*1.5))-.1,d);\n\td = min(length(p-vec3(sin(0.)*1.5,1,cos(0.)*1.5))-.1,d);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n        r.dist += d;\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t}\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvec3 colorDiff(Light l,Ray r){\n\tvec3 c = vec3(0);\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += l.c * d;\n\t\n\treturn c;\n}\n\nfloat bPhong(Light l,Ray r){\n\tfloat c = 0.;\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += pow(max(dot(normalize(l.L+V),N),0.),100.)*2. * d;\n\t\n\treturn c;\n}\n\nfloat shadowMask(vec3 p,vec3 l){\n\tfloat m = 1.;\n\tfloat x = 10.;\n\tRay r = Ray(p+N*MIN_DIST*x,p+N*MIN_DIST*x,normalize(l-p),vec3(0),0.);\n\tmarch(r,0);\n\tif(r.dist < length(l-p))m = 0.1;\n\treturn m;\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 getColor(Light l,Ray r){\n    return ((colorDiff(l,r) + bPhong(l,r)*l.c) * vec3(shadowMask(r.p,l.p)))/length(r.p-l.p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / resolution.xy )*2.-1.;\n\tuv.x*= resolution.x/resolution.y;\n\t//uv*=1.5;\n\tvec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n\t\n\tfloat camz = PI;\n\tvec3 ca = vec3(\n\t\tPI/2.+m.y*PI/2.,\n\t\tPI/2.+m.x*PI/1.,\n\t\t0\n\t);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n\tvec3 camera = vec3(0,0,camz)*rotX*rotY;\n\tvec3 plane = (vec3(uv,0)*rotX*rotY);\n\t\n\tlight.p = vec3(sin(2./3.*PI*2.)*1.5,2,cos(2./3.*PI*2.)*1.5);\n\tlight.c = vec3(0,0,1);\n\tLight l2;\n\tl2.p = vec3(sin(1./3.*PI*2.)*1.5,2,cos(1./3.*PI*2.)*1.5);\n\tl2.c = vec3(1,0,0);\n\tLight l3;\n\tl3.p = vec3(sin(0.)*1.5,2,cos(0.)*1.5);\n\tl3.c = vec3(0,1,0);\n    \n    Light l4;\n\tl4.p = vec3(0,5,0);\n\tl4.c = vec3(1);\n\t\n\tRay r = Ray(camera,camera,normalize(plane-camera),vec3(0),0.);\n\t\n\tmarch(r,0);\n\t\n\tvec3 c = vec3(0);\n\tN = sNormal(r.p);\n\tV = -r.dir;\n\t\n\tlNormal(light,r);\n\tlNormal(l2,r);\n\tlNormal(l3,r);\n    lNormal(l4,r);\n\t\n\tc += getColor(light,r);\n\tc += getColor(l2,r);\n\tc += getColor(l3,r);\n    c += getColor(l4,r);\n\t\t\n\tif(r.dist > MAX_DIST) c = vec3(.1);\n\t\n\tif(length(r.p-light.p)-.1 <= MIN_DIST) c = light.c*5.;\n\tif(length(r.p-l2.p)-.1 <= MIN_DIST) c = l2.c*5.;\n\tif(length(r.p-l3.p)-.1 <= MIN_DIST) c = l3.c*5.;\n\t\n\tfragColor = vec4( c, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3SDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 560, 579, 579, 914], [916, 916, 948, 948, 1171], [1173, 1173, 1203, 1203, 1398], [1400, 1400, 1421, 1421, 1552], [1554, 1554, 1583, 1583, 1631], [1633, 1633, 1663, 1663, 1743], [1745, 1745, 1773, 1773, 1890], [1892, 1892, 1924, 1924, 2086], [2088, 2088, 2122, 2122, 2151], [2153, 2153, 2182, 2182, 2277], [2279, 2279, 2335, 2335, 3693]]}
{"id": "dlcSWl", "name": "Rainbow Grid Warp", "author": "isaacchurchill", "description": "Cool swirly pattern", "tags": ["2d", "grid", "warp", "rainbow"], "likes": 8, "viewed": 224, "published": 3, "date": "1685854895", "time_retrieved": "2024-07-30T17:52:30.048113", "image_code": "#define SAMPLES_X 4\n#define SAMPLES_Y 4\n\n#define PI 3.14159265\n\nvec3 palette(float x)\n{\n    return 0.5 + 0.5 * cos(x * PI * 2.0 + vec3(0,2,4));\n}\n\n\nvec2 distort(vec2 p)\n{\n    return p * (1.0 + 1.0 * pow(dot(p,p), sin(iTime)));\n}\n\nvec3 getCol(vec2 p)\n{\n    vec2 distorted = distort(p);\n    float a = 3.0;\n    float b = 10.0;\n    vec3 col = palette((floor(distorted.x * a) + floor(distorted.y * a) + iTime * 3.0) / b);\n    col *= float(abs(distorted.x * a - round(distorted.x * a)) > 0.02);\n    col *= float(abs(distorted.y * a - round(distorted.y * a)) > 0.02);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    for (int i = 0; i < SAMPLES_X; i++) {\n        for (int j = 0; j < SAMPLES_Y; j++) {\n            vec2 offs = vec2(float(i) / float(SAMPLES_X - 1),\n                             float(j) / float(SAMPLES_Y - 1)) * 2.0 - 1.0;\n            offs /= iResolution.y;\n            col += getCol(p + offs);\n        }\n    }\n    col /= float(SAMPLES_X * SAMPLES_Y);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 87, 87, 145], [148, 148, 170, 170, 228], [230, 230, 251, 251, 578], [580, 580, 637, 637, 1126]]}
{"id": "clcSDs", "name": "mandala 33", "author": "dmteam", "description": "idk", "tags": ["fractal", "circle", "art"], "likes": 2, "viewed": 192, "published": 3, "date": "1685847943", "time_retrieved": "2024-07-30T17:52:31.007548", "image_code": "vec3 palette(float t)\n{\n    vec3 a = vec3(0.9, 0.2, 0.2);    // Rouge\n    vec3 b = vec3(0.9, 0.5, 0.2);    // Orange\n    vec3 c = vec3(0.9, 0.9, 0.2);    // Jaune\n    vec3 d = vec3(0.5, 0.9, 0.2);    // Vert\n    vec3 e = vec3(0.2, 0.9, 0.9);    // Cyan\n    vec3 f = vec3(0.2, 0.2, 0.9);    // Bleu\n    vec3 g = vec3(0.7, 0.2, 0.9);    // Violet\n\n    return a + b * cos(6.28318 * (c * t + d)) +\n           e * cos(6.28318 * (f * t + g));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 5.0; i++) {\n        uv = fract(uv * 1.25) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n        d = sin(d * 10.0 + iTime * 0.5) / 10.0;\n        d = abs(d);\n        d = pow(0.01 / d, 3.0);\n        d = d / 5.0;\n\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 438], [440, 440, 495, 495, 1008]]}
{"id": "ctcSDs", "name": "ohoho1d", "author": "dmteam", "description": "[url]https://youtu.be/f4s1h2YETNY[/url]", "tags": ["fractal", "sdf", "tutorial", "intro", "repetition", "code", "youtube", "tuto", "creative"], "likes": 1, "viewed": 137, "published": 3, "date": "1685847605", "time_retrieved": "2024-07-30T17:52:32.733932", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.2, 0.5);   // Mauve\n    vec3 b = vec3(1.0, 1.0, 0.0);   // Jaune\n    vec3 c = vec3(0.0, 1.0, 0.0);   // Vert\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        float t = length(uv0) + i * 0.2 + sin(iTime * 0.5) * 0.2;\n\n        vec3 col = palette(t);\n\n        // Ajout des formes triangulaires qui bougent\n        float triangleSize = 0.1;  // Taille des triangles\n        vec2 trianglePos = vec2(0.3, 0.5);  // Position initiale des triangles\n        vec2 translatedUV = uv - trianglePos;\n        float triangleMask = smoothstep(triangleSize, triangleSize + 0.01, abs(translatedUV.x) + abs(translatedUV.y));\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += mix(col, vec3(1.0), triangleMask) * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 247], [249, 249, 304, 304, 1223]]}
{"id": "DlcXWs", "name": "ohoho1", "author": "dmteam", "description": "[url]https://youtu.be/f4s1h2YETNY[/url]", "tags": ["fractal", "sdf", "tutorial", "intro", "repetition", "code", "youtube", "tuto", "creative"], "likes": 0, "viewed": 124, "published": 3, "date": "1685846758", "time_retrieved": "2024-07-30T17:52:33.676412", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.2, 0.5);   // Mauve\n    vec3 b = vec3(1.0, 1.0, 0.0);   // Jaune\n    vec3 c = vec3(0.0, 1.0, 0.0);   // Vert\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 247], [249, 249, 304, 304, 802]]}
{"id": "Dl3XWs", "name": "Normal Filtered Anti-Aliasing", "author": "ianertson", "description": "Use the mouse to move the filter around", "tags": ["antialiasing", "aa"], "likes": 2, "viewed": 142, "published": 3, "date": "1685845806", "time_retrieved": "2024-07-30T17:52:34.475276", "image_code": "#define R iResolution.xy\n#define T (iTime)\n\n\n#define G(samp, uv) (textureLod(samp, uv, -10.).rgb)\n#define LUM(V) dot(V, vec3(0.299, 0.587, 0.114))\n#define GL(samp, uv) LUM(G(samp, uv))\nvec3 AA(in sampler2D samp, in vec2 uv) {\n    vec2 ts = vec2(textureSize(samp, 0).xy);\n    vec2 tx = (1.0 / ts) * 2.0;\n    vec3 S1 = G(samp, uv);\n    float S1L = LUM(S1);\n    float up = GL(samp, uv + tx * vec2(0, 1));\n    float down = GL(samp, uv + tx * vec2(0, -1));\n    float left = GL(samp, uv + tx * vec2(-1, 0));\n    float right = GL(samp, uv + tx * vec2(1, 0));\n    float ydiff = up - down;\n    float xdiff = left - right;\n    float F = fwidth(S1L);\n    vec3 yv = vec3( F, 1, ydiff );\n    vec3 xv = vec3( 1, F, xdiff );\n    vec3 n = normalize(cross(xv, yv));\n    vec2 e = n.xy * tx * (1.0 + F);\n    vec3 S2 = G(samp, uv + e * vec2(1, 0));\n    vec3 S3 = G(samp, uv + e * vec2(0, 1));\n    vec3 S4 = G(samp, uv + e * vec2(1, 1));\n    vec3 S5 = G(samp, uv + e * vec2(-1, -1));  \n    return (S1 + S2 + S3 + S4 + S5) / 5.0;\n}\n\nvec3 img(in sampler2D samp, in vec2 fc, in vec2 uv) {\n    vec3 col = vec3(0.0);\n    float sep = iMouse.z > 0.0001 ? iMouse.x : R.x * (0.5 + (0.5*cos(T*0.5)));\n    col = fc.x < sep ? G(samp, uv) : AA(samp, uv);\n    float tt = 4.0;\n    float ss = smoothstep(tt, 0.0, abs(fc.x-sep));\n    return mix(col, vec3(1, 0, 0), ss);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc.xy/R.xy;\n    vec3 c1 = img(iChannel0, fc, uv);\n    vec3 c2 = img(iChannel1, fc, uv);\n    vec3 c3 = col = img(iChannel2, fc, uv);\n    float tt = 0.15;\n    float cycle = mod(T*0.15, 3.0 + tt);\n    float frame = 1.0;\n    \n    #define LERP(FROM, TO)\\\n        FROM = mix(FROM, TO, smoothstep(frame - tt, frame + tt, cycle));\\\n        frame += 1.0;\n    \n    col = LERP(col, c1);\n    col = LERP(col, c2);\n    col = LERP(col, c3);\n    O = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3XWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 225, 225, 1009], [1011, 1011, 1064, 1064, 1333], [1335, 1335, 1377, 1377, 1869]]}
{"id": "DlcXWl", "name": "raytracing shader", "author": "tjgalcik", "description": "raytracing fragment shader with blinn-phong shading + specular, shadow probing, and mirror reflections", "tags": ["raytracing"], "likes": 2, "viewed": 407, "published": 3, "date": "1685841370", "time_retrieved": "2024-07-30T17:52:35.252199", "image_code": "const float INFINITY = 9999.99;\nconst vec3 BACKGROUND = vec3(0.5, 0.8, 1);\nconst int NUM_LIGHTS = 3;\nconst int NUM_SPHERES = 10;\nconst int MAX_BOUNCE = 20;\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Material{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float specPow;\n    float reflect;\n};\n\nstruct Light{\n    float intensity;\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Sphere{\n    vec3 pos;\n    float radius;\n    Material mat;\n};\n\nstruct Scene{\n    Light lights[NUM_LIGHTS];\n    Sphere spheres[NUM_SPHERES];\n};\n\nfloat intersectSphere(Ray ray, Sphere sphere){\n    float a = dot(ray.dir, ray.dir);\n    vec3 g = ray.origin - sphere.pos;\n    float b = dot(ray.dir, g);\n    float c = dot(g,g) - (sphere.radius * sphere.radius);\n    \n    float discriminant = b*b - a*c;\n    if (discriminant < 0.0) return INFINITY;\n    \n    float dsq = sqrt(discriminant);\n    float t = (-b - dsq) / a;    // first intersection test\n    if (t > 0.001) return t;\n    \n    t = (-b + dsq) / a;\n    if (t > 0.001) return t;\n    \n    return INFINITY;\n}\n\nbool probe(vec3 e, vec3 d, float dist, Scene scene){\n    \n    // For each sphere\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        Ray ray;\n        ray.origin = e;\n        ray.dir = d;\n        Sphere sphere = scene.spheres[i];\n        float intersection = intersectSphere(ray, sphere);\n        if (0.001 < intersection && intersection < dist) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nvec3 trace(Ray ray, Scene scene){\n    vec3 color = vec3(0,0,0);    // starting color\n    int bounces = 0;\n    for (int depth = 0; depth < MAX_BOUNCE; depth++){\n        bounces++;\n        if (depth == MAX_BOUNCE) {\n            return vec3(0);\n        }\n\n        // find index of closest sphere\n        float t_star = INFINITY;\n        int nearestSphere = -1;\n        for (int i = 0; i < NUM_SPHERES; i++) {\n            float t = intersectSphere(ray, scene.spheres[i]);\n\n            if (t < t_star) {\n                t_star = t;\n                nearestSphere = i;\n            }\n        }\n\n        if (nearestSphere == -1 && depth == 0){\n            return BACKGROUND;\n        }\n        else if (nearestSphere == -1){\n            return (BACKGROUND * color);\n        }\n        \n        vec3 P;\n        vec3 N;\n        Sphere sphere;\n        // for O in objects:\n        for (int k = 0; k < NUM_SPHERES; k++){\n            if (k == nearestSphere){\n                sphere = scene.spheres[k];    \n                float t = intersectSphere(ray,sphere);\n                P = ray.origin + (ray.dir * t);\n                N = normalize(P - sphere.pos);\n\n                // check for intersection\n                if (t != INFINITY){\n                    // for L in lights:\n                    for (int i = 0; i < NUM_LIGHTS; i++){\n                        color += sphere.mat.ambient * scene.lights[i].color;    // ambient\n\n                        vec3 L = normalize(scene.lights[i].pos - P);\n                        float N_dot_L = dot(N,L);\n\n                        if(N_dot_L >= 0.0 && probe(P, L, length(P - L), scene)){\n                            // phong shading\n                            float I_l = scene.lights[i].intensity;\n                            float lamb_ref = max(0.0, N_dot_L);\n                            color += sphere.mat.diffuse * I_l * lamb_ref;\n\n                            // specular highlights\n                            vec3 H = normalize(L - ray.dir);\n                            float N_dot_H = dot(N, H);\n                            if (N_dot_H > 0.0) {\n                                vec3 spec = sphere.mat.specular * I_l * pow(N_dot_H, sphere.mat.specPow) * N_dot_H;\n                                color += spec;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (sphere.mat.reflect == 0.0){\n            break;\n        }\n        ray.origin = P;\n        ray.dir = ray.dir + 2.0*(dot(N, -ray.dir)*N) * sphere.mat.reflect;\n    }\n    return color/vec3(bounces);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // uv coords\n    vec2 tc = gl_FragCoord.xy/iResolution.xy;\n    \n    // scene setup\n    Scene scene;\n    scene.lights[0] = Light(1.0, vec3(-10, 10, -20), vec3(1,1,1));\n    scene.lights[1] = Light(0.5, vec3(20, -30, 40), vec3(1,1,1));\n    scene.spheres[0] = Sphere(vec3(sin(iTime) * 3.0 + 4.0,sin(iTime + 0.5) + 2.5, -5.0), 2.0, Material(vec3(0.25, 0, 0), vec3(1, 0, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[1] = Sphere(vec3(sin(iTime + 0.5) * 3.0 + 5.5,sin(iTime + 0.25) + 3.5, -3.0), 2.0, Material(vec3(0.25, 0.125, 0), vec3(1, 0.5, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[2] = Sphere(vec3(sin(iTime + 1.0) * 3.0 + 6.75,sin(iTime + 0.0) + 4.75, 0.0), 2.0, Material(vec3(0.25, 0.25, 0), vec3(1, 1, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[3] = Sphere(vec3(sin(iTime + 1.5) * 3.0 + 8.0,sin(iTime - 0.25) + 6.0, 3.0), 2.0, Material(vec3(0.0, 0.25, 0), vec3(0, 1, 0), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[4] = Sphere(vec3(sin(iTime + 2.0) * 3.0 + 9.0,sin(iTime + -0.5) + 7.0, 5.0), 2.0, Material(vec3(0.0, 0.0, 0.25), vec3(0, 0, 1), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[5] = Sphere(vec3(sin(iTime + 2.5) * 3.0 + 10.0,sin(iTime + -0.75) + 8.0, 7.5), 2.0, Material(vec3(0.125, 0.0, 0.25), vec3(0.5, 0, 1), vec3(0.5, 0.5, 0.5), 40.0, 0.0));\n    scene.spheres[6] = Sphere(vec3(8.5, 0, 20), 10.0, Material(vec3(0.125 * sin(iTime), -0.125 *sin(iTime), 0.125 *cos(iTime)), vec3(1.0 * sin(iTime), -1.0 *sin(iTime), 1.0 *cos(iTime)), vec3(0.8, 0.8, 0.8), 40.0, 0.0));\n    scene.spheres[7] = Sphere(vec3(8.5, 20, 20), 10.0, Material(vec3(0.125, 0.125, 0.125), vec3(1, 1, 1), vec3(0.5, 0.5, 0.5), 40.0, 1.0));\n    scene.spheres[8] = Sphere(vec3(0, sin(iTime)*4.0 + 6.0, 10), 2.0, Material(vec3(0.125, 0.125, 0.125), vec3(1, 1, 1), vec3(0.8, 0.8, 0.8), 40.0, 0.7));\n    scene.spheres[9] = Sphere(vec3(13.5, -sin(iTime)*4.0 + 6.0, 10), 2.0, Material(vec3(0.125, 0.125, 0.125), vec3(1, 1, 1), vec3(0.8, 0.8, 0.8), 40.0, 0.7));\n    \n    // camera vars\n    vec3 eyep = vec3(-sin(iTime) * 15.0, 0, -20);\n    vec3 lookp = vec3(scene.spheres[4].pos.x, 10, 20);\n    float aspectRatio = iResolution.x / iResolution.y; // aspect ratio calculation\n    vec3 cameraDir = normalize(lookp - eyep);\n\n    // ray starts at eye pos and goes through current uv coord\n    Ray ray;\n    ray.origin = eyep;\n    vec3 rayDir = normalize(cameraDir);  // initial ray direction is the camera's forward direction\n    vec3 right = normalize(cross(vec3(0, 1, 0), rayDir));  // calculate the camera's right direction\n    vec3 up = normalize(cross(rayDir, right));  // calculate the camera's up direction\n\n    // adjust right direction based on aspect ratio\n    right *= aspectRatio;\n\n    // calculate the position on the image plane based on texture coordinates (tc)\n    vec3 distanceToImagePlane = vec3(3);\n    vec3 imagePlanePos = eyep + rayDir * distanceToImagePlane;\n    vec3 offset = (2.0 * tc.x - 1.0) * right + (2.0 * tc.y - 1.0) * up;\n\n    ray.dir = normalize(imagePlanePos + offset - eyep);\n\n    // cast the ray (one ray per pixel for now)\n    vec3 color = trace(ray, scene);\n\n    // final color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 583, 583, 1049], [1051, 1051, 1103, 1131, 1463], [1465, 1465, 1498, 1498, 4032], [4034, 4034, 4091, 4108, 7263]]}
{"id": "dtdXWf", "name": "noise_effect_001", "author": "catafest", "description": "simple noise effect", "tags": ["noise", "math", "romania", "catafest"], "likes": 3, "viewed": 113, "published": 3, "date": "1685833136", "time_retrieved": "2024-07-30T17:52:36.453986", "image_code": "\nfloat noise2d(vec2 co)\n{\n  return fract(sin(dot(co.xy, vec2(1.0, 73))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 1.5; i++) {\n        uv = fract(uv * uv) - 0.33;\n\n        float d = length(uv*uv) * sin(cos(iTime)*length(uv0));\n\n       vec3 col = vec3 (noise2d(uv));\n\n        d = cos(sin(d*333.)+ sin(iTime))*noise2d(uv);\n        d = abs(d*d);\n\n        d = pow(0.0001/d, d);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 88], [90, 90, 147, 147, 645]]}
{"id": "cldXWf", "name": "Moving diagonal squares", "author": "ElusiveSam", "description": "I like backgrounds like this in IWBTG fangames (like Kamilia 3) and wanted to implement something like this.\nMy first cool looking shader", "tags": ["squares", "diagonal"], "likes": 3, "viewed": 140, "published": 3, "date": "1685823437", "time_retrieved": "2024-07-30T17:52:37.316679", "image_code": "#define PI     3.14159265\n#define SQ2BY2    0.70710678\n\n// Rotate with matrix:\nvoid rotate(inout vec2 p,float angle,vec2 rotationOrigin)\n{\n    p -= rotationOrigin;\n    float c = cos(angle), s = sin(angle);\n\t// https://en.wikipedia.org/wiki/Rotation_madrix\n    // https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Matrix_constructors\n    p *= mat2(\n        c, s, // column 1\n        -s, c // column 2\n    );\n    p += rotationOrigin;\n}\n\n// Same as above, just precalculated for known params\nvoid rotate45(inout vec2 p)\n{\n    p *= mat2(SQ2BY2,-SQ2BY2,SQ2BY2,SQ2BY2);\n}\n\n// Interpolation between colors with param\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float size = .15;\n    const float speed = 2.0;\n    const vec3 mainCol = vec3(.0, .122, 1.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    // Rotate\n    rotate45(uv);\n    \n    // Resize\n    uv *= 1.0 / size;\n    // Move\n    uv.y += fract(iTime*speed);\n    // Repeat\n    uv = fract(uv);\n    \n        \n    // Gradient\n    float d = uv.x * uv.y;\n    \n    vec3 col1 = mainCol * .8;\n    vec3 col2 = mainCol * .1;\n    vec3 col = lerp(col2, col1, d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 79, 138, 138, 436], [438, 492, 521, 521, 568], [570, 613, 667, 667, 717], [719, 719, 776, 776, 1402]]}
{"id": "DldXDX", "name": "Sunrise on saturn", "author": "mrange", "description": "CC0: Ringed planet\nWas tinkering with trying to recreate a sweet sci fi image\nStopped working and forgot to share at the time.\n", "tags": ["3d", "postproc"], "likes": 197, "viewed": 12261, "published": 3, "date": "1685821758", "time_retrieved": "2024-07-30T17:52:38.144466", "image_code": "// CC0: Sunrise on saturn\n// Was tinkering with trying to recreate a sweet sci fi image\n// Stopped working and forgot to share at the time.\n// I strongly doubt there's mist like blur in space but it looked\n// nice on original image so tried to recreate it.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec3 col = vec3(0.0);\n  col = texture(iChannel0, q).xyz;\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere2(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if(h<0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nconst float far           = 1E5;\nconst vec3 sunDir         = normalize(vec3(2.5, -2.0, 10.0));\nconst float planetRadius  = 425.0;\nconst vec3 planetCenter   = vec3(0.0, -1.05*planetRadius, 0.0);\nconst vec4 planetDim      = vec4(planetCenter, planetRadius);\nconst vec4 surfaceDim     = vec4(planetCenter, 0.95*planetRadius);\nconst vec3 ringNor        = normalize(vec3(-3.2, 1.0, 1.75));\nconst vec4 ringDim        = vec4(ringNor, -dot(ringNor, planetCenter));\n\nvec3 sky(vec3 ro, vec3 rd) {\n  const vec3 sunCol = HSV2RGB(vec3(0.066, 0.66, 0.000025));\n\n  float sf = 1.001-dot(rd, sunDir);\n//  sf *= sf;\n  sf *= sf;\n  vec3 col = vec3(0.0);\n  col += sunCol/sf;\n  return col;\n}\n\nvec3 sky(vec3 col, inout float hit, vec3 ro, vec3 rd) {\n\n  if (far > hit) {\n    return col;\n  }\n  hit = 1E5;\n\n  col += sky(ro, rd);\n\n\n  return col;\n}\n\nvec3 planet(vec3 col, inout float hit, vec3 ro, vec3 rd) {\n  vec2 pi   = raySphere2(ro, rd, planetDim);\n  if (pi.x == -1.0) {\n    return col;\n  }\n  if (pi.x > hit) {\n    return col;\n  }\n  hit = pi.x;\n  \n  vec3 pos  = ro+rd*pi.x;\n  vec3 nor  = normalize(pos-planetDim.xyz);\n  float fre = 1.0+dot(rd, nor);\n  fre *= fre;\n  vec3 refl = reflect(rd, nor);\n  float rr = mix(1.0, 0.7, tanh_approx(0.0025*(pi.y-pi.x)));\n  vec3 refr = refract(rd, nor, rr);\n  \n  vec2 pri  = raySphere2(pos, refr, planetDim);\n  vec2 sri  = raySphere2(pos, refr, surfaceDim);\n  vec3 rpos = pos+refr*pri.y;\n  vec3 rnor = normalize(rpos-planetDim.xyz);\n  vec3 rrefr= refract(refr, -rnor, rr);\n  \n  vec3 pcol   = vec3(0.0);\n  vec3 prefl  = sky(pos, refl);\n  vec3 prefr  = sky(pos, rrefr);\n  prefr = pow((prefr), vec3(1.25, 1.0, 0.75));\n  pcol += prefl*fre;\n  pcol += prefr*(1.0-tanh_approx(0.004*(sri.y-sri.x)));\n\n  float pt = tanh_approx(0.025*(pi.y-pi.x));\n  col = mix(col, pcol, pt);\n  return col;\n}\n\nvec3 rings(vec3 col, inout float hit, vec3 ro, vec3 rd) {\n  float pt = rayPlane(ro, rd, ringDim);\n  if (pt < 0.0) {\n    return col;\n  }\n  if (pt > hit) {\n    return col;\n  }\n  \n  vec3 pos = ro+rd*pt;\n  vec3 nor = ringDim.xyz;\n  vec2 sri  = raySphere2(pos, sunDir, planetDim);\n  vec3 spos = pos+sunDir*sri.x;\n  vec3 snor = normalize(spos - planetDim.xyz);\n  float sfre = 1.0+dot(sunDir, snor);\n//  sfre *= sfre;\n\n  float r = length(pos-planetCenter);\n  float rr = 1.0*r;\n  float ri0 = sin(.5*rr);\n  float ri1 = sin(.2*rr);\n  float ri2 = sin(.12*rr);\n  float ri3 = sin(.033*rr-2.);\n//  float ri = (0.5+0.5*ri0*ri1*ri2);\n  float ri = smoothstep(-0.95, 0.75, ri0*ri1*ri2);\n  ri = 0.5*ri+0.2*ri3;\n  ri *= 1.75;\n  float sf = sri.x < 0.0 ? 1.0 : mix(0.05, 1.0, smoothstep(0.5, 1.0, sfre));\n  float rdif = max(dot(nor, sunDir), 0.0);\n  rdif = sqrt(rdif);\n  vec3 rcol = hsv2rgb(vec3(0.066, 0.85+0.1*ri0*ri1, ri))*sf*rdif;\n  rcol *= smoothstep(550.0, 560.0, r)*smoothstep(860.0, 850.0, r);\n  col += rcol;\n  return col;\n}\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float hit = far;\n  \n  col = sky(col, hit, ro, rd);\n  col = planet(col, hit, ro, rd);\n  col = rings(col, hit, ro, rd);\n  \n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float gd = min(abs(p.x), abs(p.y))-0.005;\n\n  const vec3 ro = vec3(0.0, 0.0, -1000.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = 4.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  float aa = 4.0/RESOLUTION.y;\n  vec3 col = render(ro, rd);\n//  col = mix(col, vec3(0.25, 0.0 ,0.), smoothstep(0.0, -aa, gd));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 brot = ROT(2.399);\n// License: Unknown, author: Dave Hoskins, found: Forgot where\nvec3 dblur(vec2 q,float rad) {\n  vec3 acc=vec3(0);\n  const float m = 0.0025;\n  vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);\n  vec2 angle=vec2(0,rad);\n  rad=1.;\n  const int iter = 30;\n  for (int j=0; j<iter; ++j) {  \n    rad += 1./rad;\n    angle*=brot;\n    vec4 col=texture(iChannel1,q+pixel*(rad-1.)*angle);\n    acc+=clamp(col.xyz, 0.0, 10.0);\n  }\n  return acc*(1.0/float(iter));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec3 col = texture(iChannel0, q).xyz;\n  \n  col -= 0.005*vec3(0.0, 1.0, 2.0).zyx;\n  col = aces_approx(col);\n  col += 0.5*dblur(q, 1.0);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 435, 435, 582]]}
{"id": "DtdSWX", "name": "LSD 2", "author": "bahaghobber", "description": "Like and Enjoy dont steal it", "tags": ["colors", "shader", "lsd", "virtualdj"], "likes": 3, "viewed": 200, "published": 3, "date": "1685816811", "time_retrieved": "2024-07-30T17:52:38.903436", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time variable\n    float time = iTime;\n\n    // Center position\n    vec2 center = vec2(0.5);\n\n    // Calculate distance from center\n    float distance = length(uv - center);\n\n    // Scale and rotate UV coordinates based on distance and time\n    vec2 distortedUV = uv + 0.3 * cos(time + distance * 30.0) * vec2(sin(time), cos(time));\n\n    // Color calculation based on distorted UV coordinates\n    vec3 color = vec3(\n        0.5 + 0.5 * sin(distortedUV.x * 10.0),\n        0.5 + 0.5 * cos(distortedUV.y * 10.0),\n        0.5 + 0.5 * sin(distortedUV.x * distortedUV.y * 20.0)\n    );\n\n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 85, 779]]}
{"id": "DltSWX", "name": "LSD vibe", "author": "bahaghobber", "description": "Like and Enjoy dont steal it", "tags": ["colors", "shader", "lsd", "virtualdj"], "likes": 0, "viewed": 143, "published": 3, "date": "1685816470", "time_retrieved": "2024-07-30T17:52:39.725239", "image_code": "i have my copyrights dont steal it\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time variable\n    float time = iTime;\n\n    // Distortion parameters\n    float distortionAmount = 0.2;\n    float speed = 2.0;\n\n    // Distorted UV coordinates\n    vec2 distortedUV = uv + distortionAmount * vec2(sin(speed * uv.y + time), cos(speed * uv.x + time));\n\n    // Circular pattern\n    float radius = 0.4;\n    vec2 center = vec2(0.5);\n    vec2 delta = distortedUV - center;\n    float distance = length(delta);\n    float angle = atan(delta.y, delta.x);\n    float circularPattern = sin(distance * 10.0 - time * 2.0) * sin(angle * 10.0 + time * 2.0);\n\n    // Color calculation\n    vec3 color = vec3(\n        0.5 + 0.5 * sin(time + circularPattern),\n        0.5 + 0.5 * sin(time + circularPattern + 2.0),\n        0.5 + 0.5 * sin(time + circularPattern + 4.0)\n    );\n\n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 93, 123, 1008]]}
{"id": "dtcXWX", "name": "Bald Polnareff Test Shader 01", "author": "BaldPolnareff", "description": "test", "tags": ["fractal"], "likes": 4, "viewed": 165, "published": 3, "date": "1685816183", "time_retrieved": "2024-07-30T17:52:40.562999", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        vec2 uv0 = uv;\n        vec3 finalColor = vec3(0.0);\n        \n        for (float i = 0.0; i < 1.3; i++){\n            \n            uv = fract(uv * 1.5) - .5;\n            float d = length(uv);\n           \n            vec3 col = vec3((0.3 + fract(sin(iTime/2.2))), (0.15 + fract(sin(iTime/2.))), (0.6 + fract(sin(iTime/3.))));\n            \n            d = sin(d*8. + iTime)/8.;\n            d = abs(d);\n            \n            d = 0.01/d;\n            \n            finalColor += col * d;\n        }\n        \n        fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 682]]}
{"id": "dt3SDf", "name": "Dark Weave", "author": "oneshade", "description": "More truchet weaving.", "tags": ["truchet", "dark", "weave"], "likes": 24, "viewed": 242, "published": 3, "date": "1685814461", "time_retrieved": "2024-07-30T17:52:41.312994", "image_code": "#define PI 3.1415926536\n#define EPS 0.001\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash21(in vec2 p) {\n    vec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid doTruchet(in vec2 uv, out vec2 cid, out vec2 cuv) {\n    cid = floor(uv);\n    cuv = fract(uv) - 0.5;\n    if (Hash21(cid) < 0.5) cuv.x = -cuv.x;\n    cuv -= cuv.x < -cuv.y ? -0.5 : 0.5;\n}\n\nfloat map(in vec3 p) {\n    vec2 cid1, cuv1;\n    doTruchet(p.xz, cid1, cuv1);\n    float offs = 0.1 * sin(PI * (cuv1.x + cuv1.y)) * sin(PI * (cuv1.x - cuv1.y));\n    float tru1 = length(vec2(length(cuv1) - 0.5, p.y + offs)) - 0.1;\n\n    vec2 cid2, cuv2;\n    doTruchet(p.xz - 10.5, cid2, cuv2);\n    float tru2 = length(vec2(length(cuv2) - 0.5, p.y - offs)) - 0.1;\n\n    return min(tru1, tru2);\n}\n\nvec3 getNormal(in vec3 p, in float d0) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)),\n        map(p + vec3(0.0, EPS, 0.0)),\n        map(p + vec3(0.0, 0.0, EPS))\n    ) - d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 3.0;\n    vec3 color = vec3(0.01);\n\n    vec3 ro = vec3(cos(iTime * 0.25), 3.0, 3.0 * sin(iTime * 0.25));\n    vec3 fd = -normalize(ro);\n    vec3 rt = normalize(vec3(-ro.z, 0.0, ro.x));\n    vec3 up = cross(fd, rt);\n    vec3 rd = normalize(rt * uv.x + up * uv.y + fd * 4.0);\n    ro.x += iTime;\n\n    float t = 0.0, d;\n    bool hit = false;\n    vec3 p;\n    for (int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        d = map(p);\n        if (abs(d) < EPS) {\n            hit = true;\n            break;\n        }\n\n        if (t > 25.0) break;\n        t += d;\n    }\n\n    if (hit) {\n        vec3 normal = getNormal(p, d);\n        color = 0.25 * pow(texture(iChannel0, reflect(rd, normal)).rgb, vec3(16.0));\n    }\n\n    fragColor = vec4(sqrt(color), 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3SDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 84, 109, 109, 223], [225, 225, 281, 281, 414], [416, 416, 438, 438, 805], [807, 807, 847, 847, 1002], [1004, 1004, 1059, 1059, 1876]]}
{"id": "dttSW2", "name": "Multi-Wave 2", "author": "SnoopethDuckDuck", "description": "An expensive but versatile smoothstep + periodic function, ignore the rendering artifacts.\n\nClick the origin to change offset, and elsewhere to change gradient and sharpness parameters.\n\nClearer visual here: https://www.desmos.com/calculator/6zhbfy9hcb", "tags": ["2d", "pulse", "wave", "graph", "function", "smoothstep", "inverse", "periodic"], "likes": 15, "viewed": 347, "published": 3, "date": "1685797361", "time_retrieved": "2024-07-30T17:52:42.066978", "image_code": "// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// About:\n// This was an attempt to improve this function\n// https://www.desmos.com/calculator/of9a6fkocv\n// so that it has a \"sharpness\" parameter n (move the mouse up and down)\n// it's VERY expensive compared to cos or sin but allows for great control\n// of the wave\n// Thanks to IQ for the graph code!\n\n// Alternatively, you can use the other functions here\n// (and their inverses) to do the same thing:\n// https://www.desmos.com/calculator/7m9bv3qpjx\n\n// \"Multi-wave\" using the exponential smooth-min from above link:\n// https://www.desmos.com/calculator/sw4e2swzgp\n// (I think this looks nicer, but is more expensive)\n\nfloat my_tanh(float x, float n) {\n    return x / pow(1. + pow(abs(x), n), 1./n);\n}\n\nfloat my_inverse_tanh(float x, float n) {\n    return x / pow(1. - pow(abs(x), n), 1./n);\n}\n\n// from [-1, 1] -> [-1, 1]\nfloat my_smoothstep(float x, float a, float o, float n) {\n    return my_tanh(a * (my_inverse_tanh(x, n) - my_inverse_tanh(o, n)), n);\n}\n\nfloat my_wave(float x, float a, float o, float n) {\n    return my_smoothstep(cos(8. * x - iTime), a, o, n);\n}\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\t\n    float dx = 3. / res.y;\n    vec2 uv = 2.4 * (fragCoord - 0.5 * res) / res.y;\n    vec2 ms = 2.4 * (iMouse.xy - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    vec3 col = vec3(0);   \n    \n    // Background\n    vec2 chck = floor(4. * uv);\n    col = vec3(0.2 + 0.02 * mod(chck.x + chck.y, 2.));\n        \n    float rxy = res.x / res.y;\n    uv.x += 0.5 * rxy;    \n    ms.x += 0.5 * rxy;\n    \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    // Parameters: a = gradient, o = offset, n = sharpness\n    float a = 8. * data.z; \n    float o = data.x;\n    float n = 1. + 10. * (1. + data.w);\n    \n    bool inSquare = max(abs(uv.x), abs(uv.y)) <= 1.;\n    if (inSquare)\n    {    \n        // Smoothstep\n        float y  = my_smoothstep(uv.x, a, o, n);\n        float dy = my_smoothstep(uv.x-sign(uv.x-0.5)*dx, a, o, n) - y; // distance estimation\n        float di = abs(uv.y-y) / sqrt(dx*dx+dy*dy);    \n        if (uv.y < y && inSquare)\n            col = mix(col, vec3(.5, .5, 1), 0.15);\n        col = mix(col, vec3(1, 0.7, 0), 1.-smoothstep(0., 2., di));\n        \n        // Axes\n        col = mix(col, vec3(1), 0.1 * (1. - smoothstep(0., 2.*dx, abs(uv.x))));\n        col = mix(col, vec3(1), 0.1 * (1. - smoothstep(0., 2.*dx, abs(uv.y))));              \n    }\n    \n    // Draw cursor for offset parameter (o)\n    float dSlider = length(uv - vec2(data.x, 0));\n    float sSlider = smoothstep(0., 2.*dx, 2.*dx - abs(0.05 - dSlider));\n    col = mix(col, vec3(1), 0.7 * sSlider);\n    \n    // Draw cursor for gradient, sharpness parameters (a, n)\n    float dMouse = length(uv - data.zw);\n    col = mix(col, vec3(1), 0.7 * smoothstep(0., 2.*dx, 0.03 - dMouse));\n           \n    // Get new uv coordinates for wave\n    // (HOPEFULLY NOT OFF SCREEN)\n    float x = mix(0.4 * 0.5 * rxy, 1. + 0.5 * rxy, 0.5);  \n    vec2 uv2 = ouv - vec2(x, 0);\n    \n    bool inRect = abs(uv2.x) < 0.5 * rxy && abs(uv2.y) < 0.5;\n    if (inRect) {\n        // Wave\n        float y  = 0.25 * my_wave(uv2.x, a, o, n);\n        float dy = 0.25 * my_wave(uv2.x-sign(uv2.x-0.5)*0.66*dx, a, o, n) - y;\n        float di = abs(uv2.y-y) / sqrt(dx*dx+dy*dy);    \n        if (uv2.y < y)\n            col = mix(col, vec3(.5, 1, .5), 0.2);\n        col = mix(col, vec3(1, 0.7, 0), 1.-smoothstep(0., 2., di));\n\n        // Axes\n        col = mix(col, vec3(1), 0.1 * (1. - smoothstep(0., 2.*dx, abs(uv2.x))));\n        col = mix(col, vec3(1), 0.1 * (1. - smoothstep(0., 2.*dx, abs(uv2.y))));              \n    }\n    \n    if (!inSquare && !inRect)\n        col *= 0.75;\n    \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = 2.4 * (px - 0.5 * res) / res.y;\n    vec2 ms = 2.4 * (iMouse.xy - 0.5 * res) / res.y;\n    float rxy = res.x / res.y;\n    uv.x += 0.5 * rxy;    \n    ms.x += 0.5 * rxy;\n    \n    //  x: slider x coord, stored in [-1, 1] interval\n    //  y: is slider active (0 = no, 1 = yes)\n    // zw: clamped mouse position (when y == 0)\n    // Slider is used for offset parameter (o)\n    // Mouse position is used for gradient, sharpness parameters (a, n)\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n       \n    if (px == vec2(0.5)) {\n        if (iFrame < 1)\n            O = vec4(0, 0, 0.2, 0.1);\n        else\n            O = data;\n\n        if (iMouse.w > 0.) {\n            if (length(ms - vec2(O.x, 0)) < 0.13) {\n                O.x = clamp(ms.x, -0.995, 0.995);\n                O.y = 1.;\n            }\n        } else if (iMouse.z > 0.) {\n            if (O.y == 1.)\n                O.x = clamp(ms.x, -0.995, 0.995);\n        } else \n            O.y = max(0., O.y - 1.);\n        \n        if (O.y == 0. && data.y == 0. && iMouse.z > 0.)\n            O.zw = clamp(ms, -1., 1.);\n    }\n    else \n        O = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttSW2.jpg", "access": "api", "license": "mit", "functions": [[1702, 1702, 1735, 1735, 1784], [1786, 1786, 1827, 1827, 1876], [1878, 1905, 1962, 1962, 2040], [2042, 2042, 2093, 2093, 2151], [2153, 2153, 2202, 2202, 4743]]}
{"id": "ctdSWS", "name": "Naive bounce", "author": "misol101", "description": "No physics, no lighting, no 3d. Just some balls happily bouncing around due to stupid code :) Fullscreen is better.", "tags": ["2d", "sphere", "noschool"], "likes": 7, "viewed": 266, "published": 3, "date": "1685781403", "time_retrieved": "2024-07-30T17:52:43.050349", "image_code": "#define SIDEMUL 1.2\n#define BOUNCE  0.4\n#define NOF_BALLS 22.\n#define COLOR 1\n\nfloat sidePos(float t, float mul) {\n    t = mod(t,2.0)-0.5;\n    if (t > 0.5) t=1.0-t;\n    return t * mul;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    float time = (iTime+NOF_BALLS) * 0.55;\n\n    vec3 col = vec3(0.05,0.04,0.09);\n    for (float i = NOF_BALLS; i >= 1.; i--) {\n        vec2 uv=ouv;\n        float j=i*15./NOF_BALLS;\n        float sz=j*0.009+0.01;\n        float szm = (2.-sz)*(2.-sz);\n        float st = time*0.3*(1.5-j/14.)+0.5+j*8.;\n        uv.x -= sidePos(st, SIDEMUL * (1.6-sz));\n        uv.y -= sin(mod(time*4.0*(0.7+j/50.)+j,3.14))*BOUNCE*(szm*(abs(sin(j/2.3)*0.7)+0.5))-(1.-sz);\n        uv.x *= iResolution.x / iResolution.y;\n\n        float dist = sqrt(sz-(dot(uv,uv)));\n        \n        if (dist > 0.07) {\n            vec3 tcol = texture(iChannel0, 20.6*((NOF_BALLS-j/1.6)*sidePos(st,-0.023)) + uv/dist).rgb*(0.3 + min(dist,0.8)*0.7);\n            col = tcol * (1.-sz);\n#if COLOR\n            //j = 0.681*2.;\n            float cz=j*0.01;\n            float czm = (2.-cz)*(2.-cz);\n            col *= vec3(sin(j/1.4+0.79)*0.5+1.35,sin(j/2.+2.15)*0.7+0.6,sin(czm*5.+3.02)*0.8+1.0);\n#else\n            col = vec3(col.x);\n#endif\n            i = 0.;\n        }\n    }\n\n    col = col*col*9.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 114, 114, 186], [188, 188, 245, 245, 1385]]}
{"id": "ct3Szl", "name": "[zznewclear13] Dual Kawase Blur", "author": "zznewclear13", "description": "A dual kawase blur implementation using 3 buffer passes.\nInteractable with iMouse.y.\nBufferA comes from gelami's [url=https://www.shadertoy.com/view/cty3R3]2-Pass Buffer Bloom[/url].", "tags": ["2d", "blur", "postprocess", "kawase", "dualkawaseblur"], "likes": 11, "viewed": 787, "published": 3, "date": "1685776746", "time_retrieved": "2024-07-30T17:52:44.030728", "image_code": "// [zznewclear13] Dual Kawase Blur\n// A dual kawase blur implementation using 2 buffer passes.\n// Interactable with iMouse.y.\n// BufferA comes from gelami's [url=https://www.shadertoy.com/view/cty3R3]2-Pass Buffer Bloom[/url].\n// \n// Possible References:\n// gelami: [2-Pass Buffer Bloom](https://www.shadertoy.com/view/cty3R3)\n// alex47: [Dual Kawase Blur](https://www.shadertoy.com/view/3td3W8)\n// Marius Bjrge: [Bandwith-Efficient Rendering](https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_slides.pdf)\n// \n// What's different from gelami's 2-Pass Buffer Bloom?\n// 1. This shader is blur effect, gelami's is bloom effect.\n// 2. This shader uses dual kawase filter, gelami's uses gaussian filter. \n// 3. This shader calculates (dual kawase) mipmaps in BufferB, gelami's uses built-in mipmaps.\n// \n// What's different from alex47's Dual Kawase Blur or Kawase Blur animated (https://www.shadertoy.com/view/Wlc3D4)?\n// 1. This shader downsamples and upsamples based on blur amount, alex47's downsamples and upsamples based on number of buffers.\n// 2. This shader linear interpolates between different blur result to create a smooth transition, alex47's increases sample offset (which may affect blur quality).\n\n// Dual kawase blur final upsample.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord);\n    vec2 pixelSize = 1.0f / iResolution.xy;\n    \n    GET_SCREEN_MAX_LOD\n    GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y\n    \n    vec2 samplePos = (iFragCoord + 0.5f) * 0.5f;\n    vec3 color, tl, tr, bl, br, t2, b2, l2, r2; \n    if(maxDownsampleCount == 0.0f)\n    {\n        // Upsample first mip in bufferB, and mix with buffferA.\n        tl = texture(iChannel1, (samplePos + vec2(-1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        tr = texture(iChannel1, (samplePos + vec2(+1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        bl = texture(iChannel1, (samplePos + vec2(-1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        br = texture(iChannel1, (samplePos + vec2(+1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        t2 = texture(iChannel1, (samplePos + vec2(+0.0f, +2.0f) * 0.5f) * pixelSize).rgb;\n        b2 = texture(iChannel1, (samplePos + vec2(+0.0f, -2.0f) * 0.5f) * pixelSize).rgb;\n        l2 = texture(iChannel1, (samplePos + vec2(-2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        r2 = texture(iChannel1, (samplePos + vec2(+2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        \n        color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\n        vec3 bufferA = texture(iChannel0, (iFragCoord + 0.5f) * pixelSize).rgb;\n        color = mix(bufferA, color, fracVal);\n    }\n    else\n    {\n        // Upsample bufferC.\n        tl = texture(iChannel2, (samplePos + vec2(-1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        tr = texture(iChannel2, (samplePos + vec2(+1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        bl = texture(iChannel2, (samplePos + vec2(-1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        br = texture(iChannel2, (samplePos + vec2(+1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        t2 = texture(iChannel2, (samplePos + vec2(+0.0f, +2.0f) * 0.5f) * pixelSize).rgb;\n        b2 = texture(iChannel2, (samplePos + vec2(+0.0f, -2.0f) * 0.5f) * pixelSize).rgb;\n        l2 = texture(iChannel2, (samplePos + vec2(-2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        r2 = texture(iChannel2, (samplePos + vec2(+2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        \n        color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\n    }\n    \n    // color = texture(iChannel2, fragCoord / iResolution.xy).rgb;\n\n    color = ACESFilm(color * 0.55);\n    color = linearTosRGB(color);\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-17 14:41:51\n\n#define EXPOSURE 5.0\n#define ROTATION\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/3tSGDy\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n// https://www.shadertoy.com/view/3tyBzV\nfloat dot2(vec2 p) { return dot(p, p); }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat smootherstep(float f)\n{\n    return f*f*f*(f*(f*6.0-15.0)+10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0);\n\n    col = vec3(1, 0.5, 1);\n    \n    float t = iTime * 0.8;\n    \n    #ifdef ROTATION\n    #if 0\n    pv *= rot2D(t * 0.8);\n    #else\n    pv *= rot2D(smootherstep(fract(t * 0.5 / PI)) * TAU);\n    #endif\n    #endif\n    \n    vec2 p1 = pv - vec2(0.8, 0);\n    vec2 p2 = (pv + vec2(0.8, 0.2)) * 2.6;\n    \n    #ifdef ROTATION\n    p1 *= rot2D(t * 1.0);\n    \n    p2.y -= 0.55;\n    p2 *= rot2D(t * 1.0);\n    p2.y += 0.55;\n    #endif\n    \n    float d = length(pv) - 0.2;\n    float r = 0.02;\n    float st = sdStar(p1, 0.25 - r, 5, 3.0) - r;\n    float sh = sdHeart(p2) / 2.6 - 0.02;\n    \n    if (st < d)\n    {\n        d = st;\n        col = vec3(1, 0.5, 0.2);\n    }\n    if (sh < d)\n    {\n        d = sh;\n        col = vec3(0.2, 0.5, 1);\n    }\n    \n    /*\n    float sb = abs(sdBox(pv, vec2(1.6, 0.8))) - 0.01;\n    if (sb < d)\n    {\n        d = sb;\n        col = vec3(1, 0.8, 0.6);\n    }*/\n    \n    col *= smoothstep(2.0 / iResolution.y, 0.0, d);\n    \n    col *= EXPOSURE;\n    col = max(col, vec3(0));\n\n    // col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Dual kawase blur downsample and upsample.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord);\n    vec2 pixelSize = 1.0f / iResolution.xy;\n    \n    GET_SCREEN_MAX_LOD\n    GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y\n    \n    vec3 color, c, tl, tr, bl, br;\n    if(iFragCoord.y < iResolution.y * 0.5f)\n    {\n        vec2 iStart, iRes;\n        float lod = getLOD(iFragCoord, iResolution.xy, maxLOD, iStart, iRes);\n        if(lod == 1.0f)\n        {\n            // Downsample BufferA\n            vec2 samplePos = (iFragCoord - iStart + 0.5f) * 2.0f;\n            if(!any(greaterThanEqual(samplePos, iResolution.xy)))\n            {\n                c = texture(iChannel0, samplePos * pixelSize).rgb;\n                tl = texture(iChannel0, (samplePos + vec2(-1.0f, +1.0f)) * pixelSize).rgb;\n                tr = texture(iChannel0, (samplePos + vec2(+1.0f, +1.0f)) * pixelSize).rgb;\n                bl = texture(iChannel0, (samplePos + vec2(-1.0f, -1.0f)) * pixelSize).rgb;\n                br = texture(iChannel0, (samplePos + vec2(+1.0f, -1.0f)) * pixelSize).rgb;\n            }   \n        }\n        else\n        {\n            // Downsample BufferB\n            vec2 iLastStart, iLastRes;\n            getLODParam(lod - 1.0f, iResolution.xy, iLastStart, iLastRes);\n\n            vec2 samplePos = (iFragCoord - iStart + 0.5f) * 2.0f;\n            if(!any(greaterThanEqual(samplePos, iLastRes)))\n            {             \n                c = sampleWithClamp(iChannel1, samplePos, iLastStart, iLastRes, pixelSize);\n                tl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, +1.0f)), iLastStart, iLastRes, pixelSize);\n                tr = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, +1.0f)), iLastStart, iLastRes, pixelSize);\n                bl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, -1.0f)), iLastStart, iLastRes, pixelSize);\n                br = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, -1.0f)), iLastStart, iLastRes, pixelSize);\n            }\n        }\n        color = (tl + tr + bl + br + 4.0f * c) / 8.0f;\n    }\n    else\n    {\n        iFragCoord = iResolution.xy - 1.0f - iFragCoord;\n        \n        vec2 iStart, iRes;\n        float lod = getLOD(iFragCoord, iResolution.xy, maxLOD, iStart, iRes); \n        vec2 iLastStart, iLastRes;\n        getLODParam(lod + 1.0f, iResolution.xy, iLastStart, iLastRes);\n        vec2 samplePos = (iFragCoord - iStart + 0.5f) * 0.5f;\n        \n        vec3 t2, b2, l2, r2;\n        if(!any(greaterThanEqual(samplePos, iLastRes)))\n        {\n            // Upsample downsamples : Upsample upsamples.   \n            bool upsideDown = (lod < (maxDownsampleCount+1.0f));\n\n            tl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            tr = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            bl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            br = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            t2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, +2.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            b2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, -2.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            l2 = sampleWithClamp(iChannel1, (samplePos + vec2(-2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            r2 = sampleWithClamp(iChannel1, (samplePos + vec2(+2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n        }   \n        color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\n        // color = lod >= (maxLOD+1.0f) ? vec3(1.0f) : vec3(0.0f);\n        // vec3 self = texture(iChannel1, (iFragCoord + 0.5f) * pixelSize).rgb;\n        // color = mix(color, self, 0.5f);\n    }\n    \n    fragColor = vec4(color, 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LOG_E_2 0.693147181f\n\n// What a mess here!\n// Idealy I would let maxLOD begin from 1.0f, however...\n\n#define GET_SCREEN_MAX_LOD \\\n        float logVal = floor(log(iResolution.x) / LOG_E_2);\\\n        float maxLOD = 0.0f;\\\n        float xStart = 0.0f;\\\n        float halfX = floor((iResolution.x + 1.0f) / 2.0f);\\\n        for (;maxLOD<=logVal;++maxLOD)\\\n        {\\\n            xStart += halfX;\\\n            if(iResolution.x <= xStart) break;\\\n            halfX = floor((halfX + 1.0f) / 2.0f);\\\n        }\\\n\n#define GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y \\\n        float mouseY = sin(iTime) * 0.5f + 0.5f;\\\n        if(iMouse.z > 0.0f) mouseY = iMouse.y / iResolution.y;\\\n        float fracVal;\\\n        float maxDownsampleCount = getMaxDownsampleCount(mouseY, maxLOD, fracVal);\\\n\nfloat getMaxDownsampleCount(float mouseY, float maxLOD, out float fracVal)\n{\n    float logVal = log(mouseY * (pow(2.0f, maxLOD-1.0f) - 1.0f) + 1.0f) / LOG_E_2;\n    float floorVal = floor(logVal);\n    fracVal = (floorVal >= maxLOD) ? 0.99f : fract(logVal);\n    return clamp(floorVal, 0.0f, maxLOD-1.0f);\n}\n\nfloat getLOD(vec2 iFragCoord, vec2 fullRes, float maxLOD, out vec2 iStart, out vec2 iRes)\n{\n    iRes = floor((fullRes+1.0f) / 2.0f);\n    iStart = vec2(0.0f, 0.0f);\n  \n    float i = 0.0f;\n    for (; i<maxLOD; ++i)\n    {\n        float iEnd = iStart.x + iRes.x;\n        if(iFragCoord.x < iEnd) break;\n        iStart.x = iEnd;\n        iRes = floor((iRes+1.0f) / 2.0f);\n    }\n    return i+1.0f;\n}\n\nvoid getLODParam(float lod, vec2 fullRes, out vec2 iStart, out vec2 iRes)\n{\n    iRes = floor((fullRes+1.0f) / 2.0f);\n    iStart = vec2(0.0f, 0.0f);\n    for(float i=1.0f; i<lod; ++i)\n    {\n        iStart.x = iStart.x + iRes.x;\n        iRes = floor((iRes+1.0f) / 2.0f);\n    }\n}\n\nvec3 sampleWithClamp(sampler2D tex, vec2 samplePos, vec2 iStart, vec2 iRes, vec2 pixelSize)\n{\n    samplePos = clamp(samplePos, vec2(0.5f), iRes - 0.5f);\n    return texture(tex, (samplePos + iStart) * pixelSize).rgb;\n}\n\nvec3 sampleWithClamp(sampler2D tex, vec2 samplePos, vec2 iStart, vec2 iRes, vec2 pixelSize, vec2 fullRes, bool upsideDown)\n{\n    samplePos = clamp(samplePos, vec2(0.5f), iRes - 0.5f);\n    samplePos = upsideDown ? fullRes - samplePos : samplePos;\n    return texture(tex, (samplePos + iStart) * pixelSize).rgb;\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}", "buffer_c_code": "// Dual kawase blur upsample.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord);\n    vec2 pixelSize = 1.0f / iResolution.xy;\n    \n    GET_SCREEN_MAX_LOD\n    GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y\n\n    vec2 iStart, iRes;\n    float lod = getLOD(iFragCoord, iResolution.xy, maxLOD, iStart, iRes); \n    \n    vec3 color;      \n    if(lod >= (maxDownsampleCount+1.0f))\n    {\n        // Mix bufferB.\n        vec2 realSamplePos = iResolution.xy - iFragCoord - 0.5f;\n        if(!any(greaterThanEqual(iFragCoord - iStart, iRes)))\n        {\n            vec3 orig = texture(iChannel0, (iFragCoord + 0.5f) * pixelSize).rgb;\n            vec3 blurred = texture(iChannel0, realSamplePos * pixelSize).rgb;\n            \n            if(lod > (maxDownsampleCount+1.0f)) fracVal = 0.0f;\n            color = mix(orig, blurred, fracVal);\n        }         \n    }\n    else\n    {\n        vec2 iLastStart, iLastRes;\n        getLODParam(lod + 1.0f, iResolution.xy, iLastStart, iLastRes);\n        vec2 samplePos = (iFragCoord - iStart + 0.5f) * 0.5f;\n        vec2 realSamplePos = samplePos + iLastStart;\n        if(!any(greaterThanEqual(samplePos, iLastRes)))\n        {\n            // Upsample BufferC.\n            vec3 tl, tr, bl, br, t2, b2, l2, r2;\n\n            tl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            tr = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            bl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            br = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            t2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, +2.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            b2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, -2.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            l2 = sampleWithClamp(iChannel1, (samplePos + vec2(-2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            r2 = sampleWithClamp(iChannel1, (samplePos + vec2(+2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n\n            color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f; \n        }\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3Szl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mt3XWj", "name": "bouncing time -able", "author": "timmaffett", "description": "bouncing time, mouse effects time and palette mixing", "tags": ["fractal", "stars", "shiny"], "likes": 2, "viewed": 149, "published": 3, "date": "1685774359", "time_retrieved": "2024-07-30T17:52:44.791693", "image_code": "// Fork of \"my second shader! -voidbyte\" by Voidbyte. https://shadertoy.com/view/cl3SDj\n// (which was forked from https://www.shadertoy.com/view/mlcSWj by facundopri)\n// 2023-06-03 06:21:20\n\n//#define palettea vec3(0.500, 0.500, 0.500)\n//#define paletteb vec3(0.666, 0.666, 0.666)\n//#define palettec vec3(1.000, 1.000, 1.000)\n//#define paletted vec3(0.000, 0.333, 0.667)\n\n//#define palettea vec3(0.086,0.506,0.851)\n//#define paletteb vec3(0.906,0.651,0.064)\n//#define palettec vec3(0.391,0.929,0.882)\n//#define paletted vec3(4.608,3.265,1.026)\n\n#define palettea  vec3(0.5, 0.5, 0.5)\n#define paletteb vec3(0.5, 0.5, 0.5)\n#define palettec vec3(1.0, 1.0, 1.0)\n#define paletted vec3(0.263, 0.416, 0.557)\n\nfloat bouncedTime;\nvec2 mouse;\n\nvec3 palette(float t) {\n    return palettea + paletteb*cos(6.28318*((1.0+fract(iTime))*(mouse.x+0.5)/(mouse.y+0.5))*(palettec*t*paletted));\n}\n\n#define PERIOD   3.5\n#define SCALE    (2.0*(mouse.y/mouse.x))\n\nfloat bounceTime() {\n    float cycle = float(int(iTime*SCALE/PERIOD*SCALE));\n    float div2 = float(int(cycle/2.0));\n    if(div2*2.0==cycle) { //even\n        // go backwards\n        float m2 = mod(iTime*SCALE,PERIOD*SCALE);\n        return (PERIOD - m2)/SCALE;\n    } else {\n        // go forawrds\n        float m2 = mod(iTime*SCALE,PERIOD*SCALE);\n        return m2/SCALE;\n    }\n}\n\n#define iTime  bouncedTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n \n    mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.5) : iMouse.xy/iResolution.xy;\n    bouncedTime = bounceTime();\n \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        \n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i*0.1 + iTime);\n\n        d = sin(d*8.0 + iTime)/8.0;\n        d = abs(d);\n        //d = pow(0.01 / d, 2.0);\n        d = pow(0.01 / d, .99+mouse.x);\n\n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3XWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[733, 733, 756, 756, 874], [939, 939, 959, 959, 1317], [1347, 1347, 1404, 1404, 2045]]}
{"id": "dt3SWB", "name": "palette experiment", "author": "playersteve19", "description": "experiment with hsv/rgb and palette functions from Inigo Quilez's website. \nhttps://iquilezles.org/articles/palettes/\ninspiration from this video:\nhttps://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["effect", "hsv", "experimental", "palettes"], "likes": 4, "viewed": 97, "published": 3, "date": "1685759953", "time_retrieved": "2024-07-30T17:52:45.549666", "image_code": "//all credit for the following three functions goes to Inigo Quilez\n//massive thanks for all your work in the shader community! \n//the application of his functions is my own mess of a code and my own idea\n//As far as I can tell nobody's done something like this before, but I haven't checked.\nvec3 rgb2hsv( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                 d / (q.x + e),\n                q.x);\n}\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//helpful site for previewing: http://dev.thi.ng/gradients/\n#define palettea vec3(0.409,0.614,0.575)\n#define paletteb vec3(0.833,0.696,0.478)\n#define palettec vec3(0.249,1.388,0.884)\n#define paletted vec3(4.608,3.265,1.026)\n/*feel free to drop some cool combos you've found in the shader comments!*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy)/iResolution.xy;\n    vec2 mous = iMouse.xy/iResolution.xy;\n    vec3 col;\n    col=texture(iChannel0,uv).rgb;\n    //col=vec3(uv,fract(iTime/10.));//disable d offset and uncomment this line to debug\n    /*alternatively, set iChannel0 to one of the rgb noise textures.*/ \n    vec3 hsv=rgb2hsv(col);\n    vec3 c=palettec;\n    vec3 d=paletted;\n    //d+=iTime/21.;//phase offset over time. \n    vec3 pal=palette(hsv.x,palettea,paletteb,c,d);//maps palette to hue\n    col=pal;//replace inputted hue with palette  \n    col=mix(col,mix(vec3(1.),col,hsv.y),mous.x);//saturation mask by mouse x amount\n    col*=mix(1.,hsv.z,mous.y);//brightness mask by mouse y amount\n    //I usually like the top left corner and right middle. Bottom left corner is the most extreme. \n    //col=vec3(uv,fract(iTime/10.));//show uv\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3SWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 293, 319, 319, 750], [751, 751, 777, 777, 1009], [1010, 1010, 1082, 1082, 1125], [1350, 1426, 1483, 1483, 2345]]}
{"id": "dttSWB", "name": "Brain ray march", "author": "henrmota", "description": "Trying to do a cool brain animation.", "tags": ["raymarch", "brain"], "likes": 3, "viewed": 254, "published": 3, "date": "1685754254", "time_retrieved": "2024-07-30T17:52:46.356509", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURF_DIST 0.0001\n\n\n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat hash21(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat snoise(vec2 st) {\n    vec2 id = floor(st);\n    vec2 gridUv = fract(st);\n\n    vec2 dx = vec2(1., 0);\n    \n    float tl = hash21(id);\n    float tr = hash21(id + dx);\n    float bl = hash21(id + dx.yx);\n    float br = hash21(id + dx.xx);\n    \n    gridUv = gridUv * gridUv * 3. - 2. *gridUv * gridUv * gridUv;\n    float t = mix(tl, tr, gridUv.x);\n    float b = mix(bl, br, gridUv.x);\n\n    return mix(t, b, gridUv.y);\n}\n\nfloat fbm(vec2 st) {\n    float amp = 1.;\n    float freq = 0.5;\n    float col = 0.;\n    for(float i = 0.; i < 10.; i++) {\n        col += amp * snoise(st * freq);\n        \n        amp *= 0.5;\n        freq *= 2.;\n    }\n    \n    return col / 2.;\n}\n\nfloat brain(vec2 uv) {\n    float n = snoise(uv);\n    n += snoise(uv * 3. + n);\n    n *= 0.5;\n    n += snoise(uv * 4. + n);\n    n *= 0.5;\n\n    return n;\n}\n\nfloat getDist(vec3 p) {\n    vec4 sphere = vec4(0., 0., 3.,.8);\n    p.x = abs(p.x);\n    float n = brain(abs(p.xx) * 2. + 0.1 * iTime);\n   \n    \n    vec3 cp = vec3(sphere.x, clamp(p.y, -0.2, 0.2), sphere.z);\n    \n    vec3 noise = 0.1 * vec3(\n        snoise(abs(p.yz) * 6. + iTime + n),\n        snoise(abs(p.xx + 0.1) * 6. + iTime),\n        0.2 * snoise(abs(p.zz) * 10. + iTime)\n    );\n    \n    cp -= mix(vec3(0., 0., -p.y * 0.25), noise, p.x * 1.2);\n    return length(p - cp) - sphere.w;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.);\n    float d = getDist(p);\n    \n    \n    return normalize(\n    vec3(\n            getDist(p + e.xyy),\n            getDist(p + e.yxy),\n            getDist(p + e.yyx)\n     )\n        - vec3(\n            getDist(p - e.xyy),\n            getDist(p - e.yxy),\n            getDist(p - e.yyx)\n     ));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO; \n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DISTANCE || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec2 getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3 (1., 0., -3.);\n    lightPos.x += 3. * sin(iTime);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float fresnel = 1. - abs(dot(normalize(p - ro), normalize(n)));\n  \n    fresnel = pow(fresnel, 2.);\n    return vec2(clamp(dot(n, l), 0., 1.), fresnel);\n}\n\nvec3 cosPalette(  float t,  vec3 a,  vec3 b,  vec3 c, vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = cosPalette(\n            fract(uv.x * .1 + 0.1 * iTime),\n            vec3(0.7, 0.33, 0.67),\n            vec3(0.50, 0.2, 0.87),\n            vec3(1.0, 1.00, 0.67),\n            vec3(0.30, 0.33, 0.67)\n        );\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + d * rd;\n    \n    if (d < MAX_DISTANCE) {\n    \n        vec2 light = getLight(p, ro);\n        \n        col += max((cosPalette(\n            snoise(p.yy * .1 + light.y + iTime * 0.4),\n            vec3(0.7, 0.33, 0.67),\n            vec3(0.50, 0.2, 0.87),\n            vec3(1.0, 1.00, 0.67),\n            vec3(0.30, 0.33, 0.67)\n        ) + light.x) * .3, light.y * 1.2);\n        \n    }\n \n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 95, 95, 166], [168, 168, 191, 191, 261], [263, 263, 286, 286, 682], [684, 684, 704, 704, 927], [929, 929, 951, 951, 1082], [1084, 1084, 1107, 1107, 1571], [1574, 1574, 1598, 1598, 1920], [1922, 1922, 1956, 1956, 2183], [2185, 2185, 2217, 2217, 2519], [2521, 2521, 2584, 2584, 2627], [2629, 2629, 2686, 2736, 3624]]}
{"id": "ml3XDB", "name": "ShadowJ14_ShaderTest", "author": "ShadowJ14", "description": "Test shader following youtube video", "tags": ["pattern"], "likes": 3, "viewed": 284, "published": 3, "date": "1685735900", "time_retrieved": "2024-07-30T17:52:47.208232", "image_code": "vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return (a + b * cos(6.28318 * (c * t + d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n    \n        float dist = length(uv) * exp(-length(uv0));\n    \n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.263, 0.416, 0.557);\n\n    \n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4, a, b, c, d);\n    \n        dist = sin(dist * 8.0 + iTime) / 8.0;\n        dist = abs(dist);\n    \n        dist = pow(0.01 / dist, 1.2);\n    \n        finalColor += col * dist;\n        //col *= dist;\n\n        // Time varying pixel color\n        //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    \n    \n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3XDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 106], [108, 108, 165, 215, 1087]]}
{"id": "dlcSWB", "name": "Trippy circle", "author": "Tauras129", "description": "idk", "tags": ["fractal", "circle", "art"], "likes": 3, "viewed": 214, "published": 3, "date": "1685733492", "time_retrieved": "2024-07-30T17:52:47.964211", "image_code": "vec3 palette( float t )\n{\n    vec3 a = vec3(1.198, 0.500, 0.508);\n    vec3 b = vec3(0.958, 0.500, 0.908);\n    vec3 c = vec3(0.188, 2.048, 1.088);\n    vec3 d = vec3(0.638, 0.428, 0.748);\n    \n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 1.25) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i*0.4 + iTime*0.4);\n        d = sin(d * 20.0 + iTime * 2.0)/5.0; \n        d = abs(d);\n        d = pow(0.01 / d, 1.3);\n\n        finalColor += col*d;\n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 231], [233, 233, 290, 340, 860]]}
{"id": "Dt3SWS", "name": "Ray Trace Training", "author": "henrmota", "description": "Just a test", "tags": ["sin", "raytrace"], "likes": 3, "viewed": 145, "published": 3, "date": "1685721827", "time_retrieved": "2024-07-30T17:52:48.805960", "image_code": "mat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat hash21(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat snoise(vec2 st) {\n    vec2 id = floor(st);\n    vec2 gridUv = fract(st);\n\n    vec2 dx = vec2(1., 0);\n    \n    float tl = hash21(id);\n    float tr = hash21(id + dx);\n    float bl = hash21(id + dx.yx);\n    float br = hash21(id + dx.xx);\n    \n    gridUv = gridUv * gridUv * 3. - 2. *gridUv * gridUv * gridUv;\n    float t = mix(tl, tr, gridUv.x);\n    float b = mix(bl, br, gridUv.x);\n\n    return mix(t, b, gridUv.y);\n}\n\nfloat fbm(vec2 st) {\n    float amp = 1.;\n    float freq = 0.5;\n    float col = 0.;\n    for(float i = 0.; i < 10.; i++) {\n        col += amp * snoise(st * freq + iTime);\n        \n        amp *= 0.5;\n        freq *= 2.;\n    }\n    \n    return col / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0.,0.,-3.);\n    vec3 rd = vec3(uv, 1.);\n    \n    \n    rd = normalize(rd);\n   \n  \n   \n    \n    \n    vec3 s = vec3(0.);\n    float t = dot(s-ro, rd);\n    vec3 p = ro + rd*t;\n    float r = 1.;\n    \n    \n    float y = length(p - s);\n    \n    float n = snoise(uv * 5. + fbm(uv * 5. + iTime));\n    r += 0.1 * n;\n    \n    if (y < r) {\n        float x = sqrt(r*r - y*y);\n        vec3 pf = (ro + rd * (t-x));\n        pf.yz *= Rot(0.1 * iTime + n * 0.001);\n       \n        vec3 pb = ro + rd * (t+x);\n        pb.xz *= Rot(-0.1 * iTime);\n        //col = pb - pf;\n        //col +=pb;\n        \n        float n = fbm(uv * 10. + 1. * iTime);\n      \n        vec2 polar = vec2(atan(pf.x, pf.z), pf.y);\n        n = fbm(pf.xy * 100. + n);\n        \n        float dp = 1./max(iResolution.x, iResolution.y);\n        col += smoothstep(dp, -dp, sin(length(pf.xy) * 100. - 2. * iTime) - 0.1);\n       \n        col *= x + x + pf + pb;\n    }\n    \n    //col = vec3(fbm(uv * 10.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3SWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 90], [92, 92, 115, 115, 185], [187, 187, 210, 210, 606], [608, 608, 628, 628, 859], [861, 861, 918, 968, 2121]]}
{"id": "cttXRl", "name": "OZORA FESTIVAL - POSTHELIOS RND", "author": "POSTHELIOS", "description": "fractal fork WIP", "tags": ["fractal"], "likes": 2, "viewed": 117, "published": 3, "date": "1685712931", "time_retrieved": "2024-07-30T17:52:49.770382", "image_code": "#define R(p,a,r) mix(a*dot(p,a),p,cos(r)) + sin(r)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvec3 color(float t) {\n  vec3 c1 = vec3(1.0, 0.0, 0.0);\n  vec3 c2 = vec3(0.0, 1.0, 0.0);\n  vec3 c3 = vec3(0.0, 0.0, 1.0);\n  vec3 c4 = vec3(1.0, 1.0, 0.0);\n  vec3 c5 = vec3(1.0, 0.0, 1.0);\n  vec3 c6 = vec3(0.0, 1.0, 1.0);\n\n  float r = cos(t) * 0.5 + 0.5;\n  if (r < 0.23) return mix(c1, c2, r * 5.0);\n  if (r < 0.44) return mix(c2, c3, (r - 0.2) * 5.0);\n  if (r < 0.65) return mix(c3, c4, (r - 0.4) * 5.0);\n  if (r < 0.86) return mix(c4, c5, (r - 0.6) * 5.0);\n  return mix(c5, c6, (r - 0.8) * 7.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = vec4(0);\n    vec3 p, r = iResolution, d = normalize(vec3((fragCoord-.5*r.xy)/r.y,0.7));  \n    for(float i = 0., g = 0., e, s; i < 99.; ++i)\n    {\n        p = g * tan(d);\n        p.z -= 0.60;\n        p = R(p, normalize(vec3(1,2,3)), iTime * 1.2);\n        s = 4.;\n\n        for(int j = 0; j++ < 14;)\n        {\n            p = abs(p);\n            p = p.x < p.y ? p.zxy : p.zyx;\n            s *= e = 1.8 / min(dot(p, p), 1.3);\n            p = p * e - vec3(15,3,2);\n        }\n\n        g += e = length(p.xz) / s;\n        fragColor.rgb += color(iTime * 0.1 + cos(i)) * mix(r / r, H(log(s)), 0.7) * 0.08 * exp(-i * i * e);\n    }\n    \n    fragColor = pow(fragColor, vec4(3));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 132, 132, 608], [610, 610, 662, 662, 1346]]}
{"id": "ml3XzX", "name": "Year of Truchets #030", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable) - If slow turn AA off (1) AA for good systems = turn AA (2)", "tags": ["raymarching", "torus", "truchet", "flying"], "likes": 20, "viewed": 304, "published": 3, "date": "1685708865", "time_retrieved": "2024-07-30T17:52:50.517384", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #030\n    06/01/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n    (mouseable) - AA for good systems = turn AA on with 2 or more.\n    \n*/\n\n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define P9          1.57078\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    35.\n\n// globals\nvec3 hit=vec3(0),hitpoint=vec3(0);\nvec4 FC=vec4(.267,.443,.635,0);\nmat2 turn,spin;\nfloat glow,move,px,stime;\n\n// standard bag of tricks\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n//@iq torus & hsv2rgb\nfloat torus(vec3 p,vec2 t){vec2 q=vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z * mix(vec3(1),rgb,c.y);\n}\nfloat trigger,stored;\n\nfloat tile(vec3 hp, float type){\n    //@Fabrice - uv around torus based off https://www.shadertoy.com/view/sdtGRn\n    float angle = atan(hp.z,hp.x)/PI2;\n    float d =  atan(hp.y,length(hp.zx)-2.)/PI2;\n    vec2 uv = vec2(angle,d);\n \n    vec2 scale = vec2(24.,12);\n    float thick = .045;\n    \n    if(type==2.) {\n        uv=hp.xz;\n        scale=vec2(1);\n        thick = .1;\n    }\n\n    vec2 grid = fract(uv.xy*scale)-.5;\n    vec2 id   = floor(uv.xy*scale);\n\n    float hs = hash21(id);\n    if (hs>.45) grid.x=-grid.x;\n\n    vec2 gplus = grid+.5,gmins = grid-.5;\n    vec2 d2 = vec2(length(gmins), length(gplus));\n    vec2 q = d2.x<d2.y? vec2(gmins) : vec2(gplus);\n    float c = length(q)-.5;\n\n    if(hs>.8) c =  min(length(grid.x)-.001,length(grid.y)-.001);\n    c = abs(c)-thick;\n\n    return c;\n}\n\nvec2 map(vec3 p, float sg) {\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p-vec3(0,.5,move-1.);\n\n    q.xy*=spin;\n    q.zx*=turn;\n    float d1 = torus(q,vec2(2.,.85));\n    float d2=max(abs(d1)-.1,d1);\n\n    float t1 = tile(q,1.);\n    \n    d2=max(d2,-t1);\n    \n    if(d2<res.x) {\n        res=vec2(d2,d1<d2?3.:1.);\n        hit=q;\n    }\n    \n    float d3 = torus(q,vec2(2.,.075));\n    if(sg==1.) { glow += .001/(.0002+d3*d3);}\n    if(d3<res.x) {\n        res=vec2(d3,4.);\n        hit=q;\n    }\n    \n    float ff = .2*sin(p.x*.4+stime) + .2*cos(p.z*.73+stime);\n    float d4 = p.y-ff+2.;\n    if(d4<res.x) {\n        res=vec2(d4,2.);\n        hit=p;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<112;i++){\n        vec2 ray = map(ro + rd * d,1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.25:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m =ray.y; d=ray.x;\n    \n    hitpoint=hit;\n\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        // light\n        vec3 lpos =vec3(-25.,15.,10.);\n        vec3 l = normalize(lpos-p);\n        // difused\n        float diff = clamp(dot(n,l),.09,.99);\n\n        // color\n        vec3 h = vec3(1.);\n        vec3 hp = hitpoint;\n        \n        if(m==1.) {\n            float d = tile(hp,1.);\n            vec3 fd = mix(vec3(.2),vec3(.7),clamp(hp.y*2.,0.,1.));\n            d=smoothstep(px,-px,abs(d-.15)-.025);\n            h = mix(fd,vec3(.6),d);\n            ref = h*.1;\n        }\n        if(m==2.) {\n            hp.z-=T*8.;\n            float d = tile(hp*.5,2.);\n            d=smoothstep(px,-px,abs(abs(d)-.05)-.025);\n            vec3 clr = hsv2rgb(vec3((hp.x-hp.z)*.1,1.,.5));\n            h = mix(vec3(.6),clr,d);\n            ref = vec3(d*.9);\n        }\n        if(m==3.) {\n            h = hsv2rgb(vec3((hp.x+T)*.2,1.,.5));\n            ref = h;\n        }\n        if(m==4.) h = vec3(1);\n  \n        C = diff*h;\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    if(last>0.) C = mix(FC.rgb,C,exp(-.0008*d*d*d));\n    return vec4(C,d);\n}\n\nvec3 renderALL( in vec2 uv, in vec2 F )\n{   \n\n    // standard setup uv/ro/rd\n    //vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,5.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy==vec2(0) || M.z <1. ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*.50-.250)*PI;\n\n    float pf = .5*sin(T*.35);\n    \n    mat2 rx = rot(-.58-x), ry = rot(y-pf);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC.rgb,C,exp(-.00015*a*a*a));\n    C = mix(C,vec3(.89),clamp(glow*.5,0.,1.));\n   // C=pow(C, vec3(.4545));\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    turn = rot(T*.35);\n    spin = rot(.2*sin(T*1.15));\n    move = -3.*cos(T*.3);\n    px  = 10./R.x;\n    stime=T*.1;\n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = renderALL(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n        glow=0.;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3XzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[666, 692, 710, 710, 755], [756, 756, 777, 777, 832], [833, 855, 882, 882, 938], [939, 939, 965, 965, 1074], [1098, 1098, 1130, 1211, 1888], [1890, 1890, 1918, 1918, 2549], [2551, 2551, 2581, 2581, 2832], [2834, 2834, 2866, 2866, 3097], [3099, 3099, 3194, 3194, 4431], [4433, 4433, 4474, 4554, 5345]]}
{"id": "dt3Szs", "name": "Trail Experiment", "author": "s_fx", "description": "This looks weirdly fancy", "tags": ["dither", "snake", "dithering", "trail"], "likes": 3, "viewed": 253, "published": 3, "date": "1685705364", "time_retrieved": "2024-07-30T17:52:51.276355", "image_code": "/*\n * Trail Experiment (Main Image)\n * (c) 2023 s.fx\n * \n * Main image shader which dithers buffer output\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = fragCoord / iResolution.xy;\n    fragColor = vec4(texture(iChannel1, fragCoord / DITHER_SIZE).r < pow(texture(iChannel0, uv).r, EXPONENT));\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n * Trail Experiment (Buffer A)\n * (c) 2023 s.fx\n *\n * Buffer drawing pretty snake trail ~~o<\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n    vec2 pos = vec2(.5) + vec2(sin(iTime), cos(iTime)) * .25 + vec2(sin(iTime * .1), cos(iTime * .2)) * .175;\n    \n    float prev = texture(iChannel0, uv).r;\n    float rad  = sin(iTime * .5) * .5 + .55;        // variable radius scalar\n    float len  = (sin(iTime * .2) * .4 + .6) * .01; // variable length of trail\n    \n    fragColor = vec4(length(pos - uv) < rad * RADIUS ? 1. : prev - len);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * Trail Experiment (Common)\n * (c) 2023 s.fx\n * \n * Some tweakable config values\n */\n\nconst float DITHER_SIZE = 8.; // like 4, 8, 16, etc\nconst float RADIUS      = .1; // radius in uv size\nconst float EXPONENT    = 2.; // exponent for dithering and strange color effects", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3Szs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 325]]}
{"id": "ct3XRs", "name": "Ruby diamond mandala", "author": "jarble", "description": "A simple mandala pattern.", "tags": ["fractal", "diamond", "mandala"], "likes": 6, "viewed": 216, "published": 3, "date": "1685692951", "time_retrieved": "2024-07-30T17:52:52.141043", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5\n            //abs(-.5*sign(uv.y-uv.x)-uv-t2)/1.5\n        ;\n        b = uv.y>uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv+.5).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx*sign(.5-uv.y)\n        ;\n        col.x =\n            max((t2.y+t2.x),col.x)\n        ;\n        col =\n            abs(col-1.+col.x);\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a += pow(2.,mod(floor(a/8.),b*b));\n    return\n        floor(mod(floor(a+pow(4.,b)),b))\n        //floor(mod(floor(a+floor(a/2.)),b))\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.*pow(2.,fmod(1.-time/2./8.,2.)),\n  s2 = 8.,\n  m0 = pow(2.,fmod(time/s1,3.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t = pow(2.,fmod(t*4.+m1,2.))*t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(-time*m0*s1,s1)/2.)\n  ;\n  t *=\n      s1*s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-(fract(t/s1)/5.))/5.,2.)\n  ;\n  float nb = pow(2.,(m3+m2-m1)/5.+8.);\n  return\n      abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3XRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1111]]}
{"id": "DlcSRs", "name": "Zellij pattern 14", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "arabesque", "zellij"], "likes": 7, "viewed": 218, "published": 3, "date": "1685692666", "time_retrieved": "2024-07-30T17:52:53.095491", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 9; k++){\n        uv =\n            abs(.5-uv-t2*sign(.5-uv.x))/1.5\n            //abs(-.5*sign(uv.y-uv.x)-uv-t2)/1.5\n        ;\n        b = uv.y>uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv+.5).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx*sign(.5-uv.y)\n        ;\n        col.x =\n            max((t2.y+t2.x),col.x)\n        ;\n        col =\n            abs(col-1.+col.x);\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n        //if(t2.x<t2.y) col=col.yzx;\n        //if(t2.x<t2.y) uv.y += .5;\n\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        floor(mod(floor(a+pow(4.,b)),b))\n        //floor(mod(floor(a+floor(a/2.)),b))\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.*pow(2.,fmod(1.-time/2./8.,2.)),\n  s2 = 8.,\n  m0 = pow(2.,fmod(time/s1,3.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t = pow(2.,fmod(t*4.+m1,2.))*t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(-time*m0*s1,s1)/2.)\n  ;\n  t *=\n      s1*s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-(fract(t/s1)/5.))/5.,2.)\n  ;\n  float nb = pow(2.,(m3+m2-m1)/5.+8.);\n  return\n      abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1183]]}
{"id": "Dt3SRs", "name": "Zellij pattern 13 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "music", "arabesque", "zellij"], "likes": 7, "viewed": 371, "published": 3, "date": "1685691684", "time_retrieved": "2024-07-30T17:52:53.905326", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a-fract(a*4.)/2.)\n        //fract(a-floor(a.yx)/4.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n        //vec2(1.-sign(a.x)/2.,0.5+sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    \n    //another interesting pattern\n    //if(a.x>a.y) a2 = -vec2(.5,1.5);\n    \n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.x/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv-t2)/1.5\n            //abs(-.5*sign(uv.y-uv.x)-uv-t2)/1.5\n        ;\n        \n        //remove the red border around the zellij pattern\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n\n        //uv.y -= .5;\n        b =\n            uv.y<uv.x\n            //uv.y<uv.x||t2.y<t2.x&&!b\n        ;\n        if(b)\n            uv = uv.yx\n            //uv.x += .5\n            //uv.y += .5\n        ;\n        t2 =\n            triangle_wave(uv-.5).yx\n            //triangle_wave(uv-.5+floor(.5+t2.y+t2.x)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx*sign(.5-uv.y)\n        ;\n        vec2 t21 =\n            //triangle_wave(t2)\n            t2\n        ;\n        col.x =\n            max((t21.y+t21.x),col.x)\n            //max(abs(t2.y+t2.x),1.-col.x)\n        ;\n        col =\n            abs(col-1.+col.x)\n            //vec3(col.zx,max(uv.x-uv.y,col.y))\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx))\n        ;\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a /= (1. + floor(mod(1.+a/16.*b,2.)));\n    //a = (a/8.*b);\n    //a = a/2. + floor(a/2.)/b*8.;\n    //a = (a/2. + pow(2.,mod(floor(a/2.),3.)))/2.;\n    return\n        floor(mod(floor(a+pow(4.,b)),b))\n        //floor(mod(floor(a+pow(floor(b/2.),b)),b*2.))\n        //mod(mod(floor(a),floor(b/2.))*mod(floor(a/b),b),b)\n        //floor(mod(floor(a*4.)/b,b))\n        //floor(mod(floor(a+floor(a/2.)),b))\n    ;\n}\n\nfloat sqmod(float a, float b){\n    float m1 = mod(floor(a),b);\n    return floor(m1*m1/b);\n}\n\nfloat fmod1(float a,float b){\n    return mod(floor((fmod(a*2./b,b)*fmod(a/b,b))),b);\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.*pow(2.,fmod(1.-time/2./8.,2.)),\n  m0 = pow(2.,fmod(time/s1,2.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t = pow(2.,fmod(t*4.+m1,2.))*t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(-time*m0*s1,s1)/2.)\n  ;\n  float m2 =\n      1. + fmod(t*s1,s1/2.)\n      //1. + fmod(time*s1,s1/2.)\n  ;\n  float a=\n      2.*(pow((1.-log(fract(t*s1)/5.))/5.,2.)+pow((1.-(fract(-t*s1/2.)/5.))/5.,2.))\n  ;\n  float nb = pow(2.,(m3*m2-m1)/5.+8.);\n  return\n      abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3SRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 120], [122, 122, 149, 149, 416], [418, 418, 475, 475, 1884]]}
{"id": "slGyWt", "name": "SDF Subtraction - Attempt 1", "author": "iq", "description": "An attempt to computing the SDF of the subtraction of two SDFs. Not working very well :(", "tags": ["2d", "sdf", "subtraction"], "likes": 24, "viewed": 1063, "published": 3, "date": "1685666534", "time_retrieved": "2024-07-30T17:52:54.673272", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Approximating the SDF of the subtraction of two SDFs,\n// by finding the closest intersection between the two shapes.\n// Not working very well :(\n\n\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = f(p) with f(p) = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r ) \n{\n    p -= c;\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = f(p) with f(p) = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l: g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n//-----------------\n\n#define opSubtract(p,A,B)\\\n    /* regular subtraction */ \\\n    max(A.x,-B.x);\\\n    if( d>0.0 )\\\n    {\\\n        vec2 op = p;\\\n        /* find closest intersection of the two shapes */ \\\n        /* by recursively averaging the two closest points */ \\\n        for( int i=0; i<512; i++ ) \\\n        { \\\n            float d1=A.x; vec2 g1=A.yz; \\\n            float d2=B.x; vec2 g2=B.yz; \\\n            if( max(abs(d1),abs(d2))<0.001 ) break; \\\n            p -= 0.5*(d1*g1 + d2*g2); \\\n        } \\\n        /* distance to closest intersection*/ \\\n        float d3 = length(p-op);\\\n        /* decide whether we should update distance */ \\\n        vec2  g1 = A.yz;\\\n        vec2  g2 = B.yz;\\\n        float no = cro(g1,g2);\\\n        if( min(cro(op-p,g1)*no,cro(op-p,g2)*no)>0.0) d = d3;\\\n    }\n    \n\n\nfloat map( in vec2 p )\n{\n    vec2 off = 0.1*sin(iTime+vec2(0.0,2.0));\n\n    float d = opSubtract( p, sdgBox(p,vec2(0.3,0.6)), \n                             sdgCircle(p,vec2(0.0,0.2)+off,0.4) );\n    return d;\n}\n\nvec2 gra( in vec2 p )\n{\n    const float e = 0.0002;\n    return vec2(map(p+vec2(e,0.0))-map(p-vec2(e,0.0)),\n                map(p+vec2(0.0,e))-map(p-vec2(0.0,e)))/(2.0*e);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // distance\n    float d = map(p);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n\tcol *= 1.0 - exp2(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.002,0.005,abs(d)) );\n\n    // debug gradient\n    {\n    #if 0\n        vec2 g = gra(p);\n        col *= 1.0 + vec3(0.5*g,0.0);\n        float l = length(g);\n        if( l>1.01 ) col=vec3(1,0,0);\n        if( l<0.99 ) col=vec3(0,0,1);\n    #endif\n    }\n\n    // debug distance with mouse\n    if( iMouse.z>0.001 )\n    {\n    d = map(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGyWt.jpg", "access": "api", "license": "mit", "functions": [[1229, 1333, 1386, 1386, 1454], [1456, 1560, 1597, 1597, 1855], [1858, 1858, 1887, 1887, 1915], [2726, 2726, 2750, 2750, 2934], [2936, 2936, 2959, 2959, 3108], [3112, 3112, 3169, 3205, 4117]]}
{"id": "DldXRf", "name": "Heart - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a heart. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "heart", "distance"], "likes": 22, "viewed": 900, "published": 3, "date": "1685659897", "time_retrieved": "2024-07-30T17:52:55.430250", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a heart. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//   https://iquilezles.org/articles/distgradfunctions2d\n// and\n//   https://www.shadertoy.com/playlist/M3dSRf\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgHeart( in vec2 p )\n{\n    float sx = p.x<0.0?-1.0:1.0;\n    \n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n    {\n        const float r = sqrt(2.0)/4.0;\n        vec2 q0 = p - vec2(0.25,0.75);\n        float l = length(q0);\n        vec3 d = vec3(l-r,q0/l);\n        d.y *= sx;\n        return d;\n    }\n    else\n    {\n        vec2 q1 = p-vec2(0.0,1.0);        vec3 d1 = vec3(dot(q1,q1),q1);\n        vec2 q2 = p-0.5*max(p.x+p.y,0.0); vec3 d2 = vec3(dot(q2,q2),q2);\n        vec3 d = (d1.x<d2.x) ? d1 : d2;\n        d.x = sqrt(d.x);\n        d.yz /= d.x;\n        d *= ((p.x>p.y)?1.0:-1.0);\n        d.y *= sx;\n        return d;    \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    p.y += 0.5;\n    m.y += 0.5;\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgHeart(p);\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n \n    // interaction\n    if( iMouse.z>0.001 )\n    {\n        d = sdgHeart(m).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldXRf.jpg", "access": "api", "license": "mit", "functions": [[1363, 1458, 1486, 1486, 2088], [2091, 2091, 2148, 2148, 3108]]}
{"id": "mlcXRX", "name": "Filled approx of cubic spline", "author": "jeyko", "description": ".", "tags": ["bezier", "spline", "curve", "cubic", "catmullrom", "hermite"], "likes": 21, "viewed": 284, "published": 3, "date": "1685637272", "time_retrieved": "2024-07-30T17:52:56.196201", "image_code": "// Same as https://www.shadertoy.com/view/DlcXzf \n// but filled\n\n// A (simplified a bit) implementation of this paper - https://ttnghia.github.io/posts/quadratic-approximation-of-cubic-curves/\n// I recommend running the demo .exe to get a feel of how it works.\n// Green is catmull rom spline, black is its tangents and points, orange is the bezier spline.\n// Bezier generation on line 130.\n\n#define CATMULL_ROM 0\n#define BEZIER 1\n\nvec2[] pts = vec2[](\n    vec2(0.1,0.2),\n    vec2(0.5,0.1),\n    vec2(0.2,-0.3),\n    vec2(-0.2,0.2),\n    vec2(-0.4,0.2),\n    vec2(-0.5,0.4),\n    vec2(-0.6,-0.2),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4),\n    vec2(-0.2,-0.3),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4)\n);\n\nvec2 get_pt(int i){\n    return pts[(i+pts.length())%pts.length()];\n}\n\n// Characteristic matrices\nconst float[] bezier = float[16](\n    1.,  0.,  0.,  0.,\n    -2., 2.,  0.,  0.,\n    1., -2.,  1.,  0.,\n    0., 0., 0.,  0.\n);\nconst float[] hermite = float[16](\n    1.,  0.,  0.,  0.,\n    0.,  1.,  0.,  0.,\n    -3.,-2.,  3., -1.,\n    2.,  1., -2.,  1.\n);\n\n\nfloat sdLine(vec2 uv, vec2 a, vec2 b){\n    vec2 ab = b - a;\n    vec2 p = a + ab*clamp(dot(uv-a, ab)/dot(ab,ab),0.,1.);\n    return length(uv-p);\n}\n\n\n\nvec2 curve_sample(float[16] m, float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3){\n    return (P0*m[0]  + P1*m[1]  + P2*m[2]  + P3*m[3] ) +\n        t*     (P0*m[4]  + P1*m[5]  + P2*m[6]  + P3*m[7] ) +\n        t*t*   (P0*m[8]  + P1*m[9]  + P2*m[10] + P3*m[11]) +\n        t*t*t* (P0*m[12] + P1*m[13] + P2*m[14] + P3*m[15]);\n}\n\nvoid draw_curve(\n    inout vec3 col, vec2 uv, vec3 curve_col, float[16] m, vec2 P0, vec2 P1, vec2 P2, vec2 P3\n){\n    const float its = 44.;\n    float sd_curve = 1000.;\n    vec2 prev_p;\n    for(float t = 0. ; t <= 1. + 0.01/its; t+=1./its){\n        vec2 p = curve_sample(m,t,P0,P1,P2,P3);\n\n        if(t < 0.01/its)\n            prev_p = p;\n\n        sd_curve = min(sd_curve,sdLine(uv,prev_p,p) - 0.002);   \n        prev_p = p;\n    }\n    col = mix(col,curve_col,smoothstep(fwidth(uv.y),0.,sd_curve));\n}\n\n\n\nfloat get_bez_x(float t, vec2 a, vec2 b, vec2 c){ return a.x + t*(2.*b.x - 2.*a.x) + t*t*(-2.*b.x+c.x+a.x);}\nbool does_py_intersect_bezier(vec2 p, vec2 _a, vec2 _b, vec2 _c){\n    float a = -2.*_b.y + _c.y + _a.y;\n    float b = 2.*_b.y - 2.*_a.y;\n    float c = _a.y - p.y;\n    \n    float s = b*b - 4.*a*c;\n    if(s<0.)\n        return false;\n        \n    float ra = (-b - sqrt(s))/(2.*a);\n    float rb = (-b + sqrt(s))/(2.*a);\n    bool ba = ra > 0. && ra < 1.;\n    bool bb = rb > 0. && rb < 1.;\n    if(ba)\n        ba = ba && get_bez_x(ra,_a,_b,_c) < p.x;\n    if(bb)\n        bb = bb && get_bez_x(rb,_a,_b,_c) < p.x;\n    return ba ^^ bb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.95);\n    \n    // Draw background\n    vec2 uvb = mod(uv, 0.1) - 0.05;\n    float sd_bg = 1000.;\n    sd_bg = min(sd_bg,abs(uvb.x));\n    sd_bg = min(sd_bg,abs(uvb.y));\n    col = mix(col,vec3(0.6),smoothstep(fwidth(uv.y),0.,sd_bg));\n    \n    \n    // Offset points\n    for(float i = 0.; i < float(pts.length()); i++){\n        pts[int(i)] += vec2(sin(i+iTime*cos(i)),cos(i+iTime*sin(i)))*0.2;\n    }\n    \n    // Generate catmull rom tangents\n    vec2[pts.length()] tangents;\n    const float visc = 0.5;\n    for(int i = 0; i < tangents.length(); i++){\n        tangents[i] = (get_pt(i+1) - get_pt(i-1))*visc;\n    }\n    \n    const vec3 bezier_col = vec3(1,0.2,0);\n    const vec3 catmull_rom_col = vec3(0.1,0.5,0.);\n    \n    float sd_black_lines = 1000.;\n    float sd_bez_stuff = 1000.;\n    float sd_points = 1000.;\n    \n    int flag = 0;\n    for(int spline = 0; spline < 2 + min(iFrame,0); spline++){\n        for(int pid = 0; pid < pts.length(); pid++){\n            // Get catmull rom points\n            vec2 P0 = get_pt(pid);\n            vec2 P1 = tangents[pid];\n            vec2 P2 = get_pt(pid+1);\n            vec2 P3 = tangents[(pid + 1)%tangents.length()];\n            if(spline == CATMULL_ROM){\n                // Draw\n                sd_black_lines = min(sd_black_lines,sdLine(uv,P0,P0+P1));\n                sd_black_lines = min(sd_black_lines,sdLine(uv,P2,P2+P3));\n                draw_curve(col, uv, catmull_rom_col, hermite, P0, P1, P2, P3);\n            } else if (spline == BEZIER){\n                vec2 mid_point = curve_sample(hermite,0.5,P0,P1,P2,P3); \n                \n                P3 = vec2(0);\n                \n                // Calculate beziers\n                const float k = 0.25;\n                \n                vec2 bez_a_P0 = get_pt(pid);\n                vec2 bez_a_P1 = P0 + k*tangents[pid];\n                vec2 bez_a_P2 = mid_point;\n                \n                vec2 bez_b_P0 = mid_point;\n                vec2 bez_b_P2 = get_pt(pid+1);\n                vec2 bez_b_P1 = P2 - k*tangents[(pid+1)%tangents.length()];\n                \n                \n                if( does_py_intersect_bezier(uv, bez_a_P0, bez_a_P1, bez_a_P2)){\n                    flag = 1 - flag;\n                    \n                }\n                if( does_py_intersect_bezier(uv, bez_b_P0, bez_b_P1, bez_b_P2)){\n                    flag = 1 - flag;\n                }\n                \n                \n                // Draw\n                draw_curve(col, uv, bezier_col, bezier, bez_a_P0, bez_a_P1, bez_a_P2, P3);\n                draw_curve(col, uv, bezier_col, bezier, bez_b_P0, bez_b_P1, bez_b_P2, P3);\n                \n                sd_bez_stuff = min(sd_bez_stuff, length(bez_a_P1 - uv) - 0.01);\n                sd_bez_stuff = min(sd_bez_stuff, length(bez_b_P1 - uv) - 0.01);\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_a_P1,mid_point));\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_b_P1,mid_point));\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_b_P2,P2 - k*tangents[(pid+1)%tangents.length()]));\n                \n            }\n        }\n    }\n    \n    if(flag > 0)\n        col = bezier_col + 0.5;\n    \n    col = mix(col,bezier_col,smoothstep(fwidth(uv.y),0.,sd_bez_stuff));\n    \n    for(int p = 0; p < pts.length(); p++){\n        sd_points = min(sd_points,length(uv - pts[p]) - 0.01);\n    }\n    sd_points = min(sd_points,sd_black_lines);\n    col = mix(col,vec3(0.0),smoothstep(fwidth(uv.y),0.,sd_points));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[699, 699, 718, 718, 767], [1053, 1053, 1091, 1091, 1198], [2023, 2023, 2072, 2072, 2131]]}
{"id": "Dty3Wd", "name": "Lascaille's Shroud 2", "author": "thepinkpanzer", "description": "New and improved version of https://www.shadertoy.com/view/ctGGWy, with god rays and depth maps! ", "tags": ["raymarching", "space", "nebula"], "likes": 14, "viewed": 353, "published": 3, "date": "1685634493", "time_retrieved": "2024-07-30T17:52:57.323189", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom p2\n    vec4 bloom = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        bloom += texture(iChannel1, (fragCoord + vec2(0,1)*n)/iResolution.xy)*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    bloom /= BLOOMSIZE;\n    \n    // PSF\n    vec4 psf = vec4(0.0);\n    for (float n = -PSFSIZE; n < PSFSIZE+1.; n++)\n    {\n        float falloff = (PSFSIZE-n)*(PSFSIZE+n)*(0.2*PSFSIZE/(0.2*PSFSIZE+abs(n)))/(PSFSIZE*PSFSIZE*log(PSFSIZE)*4.);\n        psf += texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy)*falloff;\n        psf += texture(iChannel0, (fragCoord + vec2(0,1)*n)/iResolution.xy)*falloff;\n    }\n    \n    // put it all together\n    fragColor = tanh(bloom*0.4 + psf*0.6 + 0.2*texture(iChannel0, fragCoord/iResolution.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nLascaille's Shroud 2\nConcept is as follows:\n Buffer A runs through from the camera view and estimates a depth map for the Shroud\n - This is then used to make marching more efficient\n Buffer B creates a similar depth map but radial, looking in\n - This is used for beams\n Cubemap A creates the background, since it only runs once it can be quite fancy\n Buffer D and Image then do a Gaussian blur bloom\n Image can also do PSF\n Since this is overall more efficient and allows for smaller steps, i can do fancy stuff too!\n*/\n\n// pi\n#define PI          3.1415927\n// gravitational lensing coefficient (+ is repulsive, - is attractive)\n#define GRAVLENSING 0.15\n// number of jumps in buffer A (depth buffer)\n#define NJUMPSA      15\n// number of jumps in buffer B (god rays buffer)\n#define NJUMPSB      10\n// number of jumps in buffer C (final image)\n#define NJUMPSC      100\n// camera distance from origin\n#define CAMERADIS    4.5\n// bloom width\n#define BLOOMSIZE    20.\n// point-spread function; makes stars into + shape\n#define PSFSIZE      10.\n\n//#define LIGHTNING\n#define USEDEPTH", "cube_a_code": "vec2 renormalize(vec2 uv, float w)\n{\n    return (uv/w);\n}\nfloat sharp(float v, float s)\n{\n    v = 1. + (v-1.)*s;\n    return max(0., v);\n}\n// starry background\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame <= 30)\n    {\n        vec3 rd = abs(rayDir);\n        vec2 uv;\n        if (max(rd.x, max(rd.y, rd.z)) == rd.x)\n        {\n            uv = renormalize(vec2(rayDir.y, rayDir.z), rayDir.x);\n        }\n        else if (max(rd.x, max(rd.y, rd.z)) == rd.y)\n        {\n            uv = renormalize(vec2(rayDir.x, rayDir.z), rayDir.y);\n        }\n        else\n        {\n            uv = renormalize(vec2(rayDir.x, rayDir.y), rayDir.z);\n        }\n        float galplane = dot(rayDir, vec3(1,2.4,0.5));\n        galplane = 1./(1.+galplane*galplane);\n        fragColor  = vec4(sharp(1.-pow(texture(iChannel0, uv*0.2).r*2., 2.), 14.            ))*10.;\n        fragColor += vec4(sharp(1.-pow(texture(iChannel0, uv*0.3).g*2., 2.), 14.-6.*galplane))*2.;\n        fragColor += vec4(0.04,0.08,0.12,0)*galplane*(2.+1.*texture(iChannel2, uv*0.2).r)*(1.-0.5*galplane*galplane);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, rayDir);\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nThis buffer is for camera-based depth perception\n*/\n\n// Approximate distance field for opaque-density clouds\nfloat DistanceField(vec3 pos)\n{\n    vec3 scaledPos = pos*(1.+0.05*sin(iTime*0.5));\n    float ra = texture(iChannel0, (scaledPos+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb = texture(iChannel0, (scaledPos+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra *= ra;\n    rb *= rb;\n    float rq  = (max(length(pos), 1.0-length(pos)) - ((1.-ra) + (1.-rb))*0.37);\n    return rq;\n}\n\n// Checks if a ray (launched from position, in direction) hits a sphere (with radius) on the origin.\nbool SphereHit(float radius, vec3 position, vec3 direction)\n{\n    return (dot(position, direction)*dot(position, direction) > dot(direction, direction)*(dot(position, position)) - radius*radius);\n}\n// Calculates the distance to the near part of the sphere\nfloat SphereDist(float radius, vec3 position, vec3 direction)\n{\n    float d = -dot(position, direction) - sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat SphereThrough(float radius, vec3 position, vec3 direction)\n{\n    float d = 2.*sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\n// Calculates the normal on the surface of the sphere (equivalent to the position, for a unit sphere)\nvec3 SphereNormal(float radius, vec3 position, vec3 direction)\n{\n    return normalize(vec3(position + direction*SphereDist(radius, position, direction)));\n}\nvoid mainImage( out vec4 depth, in vec2 fragCoord )\n{\n    #ifdef USEDEPTH\n        float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n        float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n        // CAMERA\n        vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n        vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n\n        vec3 iCameraPosition= -CAMERADIS*iCameraFwd;\n\n        float m = 1.0;\n\n        vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n        iViewDirection      = normalize(iViewDirection);\n\n        // RAYMARCH\n        depth = vec4(CAMERADIS+3.);\n        if (SphereHit(1.0, iCameraPosition, iViewDirection))\n        {\n            depth = vec4(0);\n            vec3 pos  = iCameraPosition + iViewDirection*SphereDist(1.0, iCameraPosition, iViewDirection);\n            vec3 dir  = iViewDirection;\n            depth += SphereDist(1.0, iCameraPosition, iViewDirection);\n            for (int n = 0; n < NJUMPSA; n++)\n            {\n                float dis = 0.5*DistanceField(pos);\n                dir   += GRAVLENSING*dis*normalize(pos)/(0.2+dot(pos,pos));\n                dir    = normalize(dir);\n                pos   += dis*dir;\n                depth += dis;\n                if (length(pos) > 1.01)\n                {\n                    depth = vec4(CAMERADIS+3.);\n                    break;\n                }\n            }\n        }\n    #endif\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nRadial heightmap for GOD RAYS WOOOOOO!!!!!!!!!!!!!!!!!\n*/\nfloat DistanceField(vec3 pos)\n{\n    vec3 scaledPos = pos*(1.+0.05*sin(iTime*0.5));\n    float ra = texture(iChannel0, (scaledPos+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb = texture(iChannel0, (scaledPos+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra *= ra;\n    rb *= rb;\n    float rq  = (max(length(pos), 1.05-length(pos)) - ((1.-ra) + (1.-rb))*0.37);\n    return rq;\n}\nvoid mainImage( out vec4 depth, in vec2 fragCoord )\n{\n    float theta = 2.*PI*fragCoord.x/iResolution.x;\n    float   phi =    PI*fragCoord.y/iResolution.y;\n    \n    vec3 iViewDirection = vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi));\n    vec3 iCameraPosition= -iViewDirection;\n    \n    depth    = vec4(0);\n    vec3 pos = iCameraPosition;\n    for (int n = 0; n < NJUMPSB; n++)\n    {\n        float dis = 0.5*DistanceField(pos);\n        depth += dis;\n        pos   += dis*iViewDirection;\n    }\n    //depth = vec4(pos, 0);\n    depth = max(vec4(0.),1.-depth);\n}", "buffer_b_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\nActual marching to get color\n*/\n// Density field\nfloat Density(vec3 pos)\n{\n    // Sheathing the solid mass in smoke\n    vec3 scaledPos = pos*(1.+0.05*sin(iTime*0.5));\n    float ra   = texture(iChannel2, (scaledPos+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb   = texture(iChannel2, (scaledPos+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra        *= ra;\n    rb        *= rb;\n    float rq   = (max(length(pos), 1.05-length(pos)) - ((1.-ra) + (1.-rb))*0.37);\n    \n    float rs   = smoothstep(-0.15,-0.1,-rq)*10.;\n    \n    // Swirls\n    vec3 r0    = texture(iChannel2, (scaledPos+vec3(  0.06, 0.07,-0.05)*0.2*iTime)/4.).rgb;\n    r0        += texture(iChannel2, (scaledPos+vec3( -0.05, -0.1, 0.02)*0.2*iTime)/6.).rgb;\n    r0        -= 1.;\n    scaledPos += 0.5*r0;\n    \n    float r1   = texture(iChannel2, (scaledPos)/4. ).a;\n    r1        += texture(iChannel2, (scaledPos)/6. ).a;\n    r1        += texture(iChannel2, (scaledPos)/12.).a;\n    r1        += texture(iChannel2, (scaledPos)/25.).a;\n    \n    r1        *= 1./pow(1. + dot(pos,pos), 2.);\n    \n    return rs*10.+exp(8.*r1-5. - rq);\n}\n\n/*\nColor is governed by four interactions:\n1) Emission (standard glow stuff)\n2) Absorption (again pretty standard)\n3) Reflection (in this case, from the ambient light - stars and whatnot)\n4) God rays (reflection of self-emitted light)\n*/\nvec4 Emit(vec3 pos, float density)\n{\n    vec4 core = vec4(1)*0.01/(0.01+dot(pos, pos));\n    vec4 halo = vec4(0.15, 0.8, 1.6, 0)*2.*pow(max(0., density*(3.-density)/3.), 8.)*9.;\n    vec4 total = core + halo;\n    #ifdef LIGHTNING\n        // 1) Create 3D lightning volume\n        // 2) Sample (other) 3D noise\n        // 3) Multiply and return\n        vec4 noise1 = (texture(iChannel2, pos*0.3+0.2));\n        float r1 = 1.-abs(0.5-noise1.g);\n        float r2 = 1.-abs(0.5-noise1.a);\n        float lightning = pow(r1*r2, 30.);\n        float r3 = abs(0.5-(texture(iChannel2, pos*0.12+0.026*iTime)).r);\n        float r4 = abs(0.5-(texture(iChannel2, pos*0.08-0.023*iTime)).g);\n        float noise2 = (max(0., 1.-20.*r3));\n        noise2      *= (max(0., 1.-20.*r4));\n        noise2      *= step(2., density)*step(-3., -density);\n        total += lightning*5000.*vec4(0.1,0.3,1.,0)*noise2;\n    #endif\n    return total;\n}\nvec4 Absorb(vec3 pos, float density)\n{\n    return vec4(0.3,0.4,0.7,0)*density*1.6;\n}\nvec4 Reflect(vec3 pos, float density)\n{\n    return vec4(0.2,0.15,0.1,0)*tanh(density)*max(0.,dot(pos, pos)-0.5);\n}\nvec4 GodRays(vec3 pos, vec3 dir, float density)\n{\n    float r = length(pos);\n    // Convert to iChannel1 UV\n    pos = -normalize(pos);\n    float theta = atan(pos.y, pos.x);\n    float phi   = atan(length(pos.xy), pos.z);\n    vec2  uv    = fract(vec2(theta/(2.*PI), phi/PI));\n    \n    // Sample iChannel1 depth:\n    float depth = texture(iChannel1, uv).r;\n    \n    // Emitted light reaching us\n    float lightIntensity = 0.015/(0.015+depth*depth);\n    \n    // Anisotropy (boosting beams towards camera)\n    float anisotropy = 1.3/(1.-0.6*dot(pos, dir));\n    \n    // Color\n    vec4 innerCol = vec4(1, 0.8, 0.5,0);\n    vec4 outerCol = vec4(0.7, 0.9, 1,0);\n    \n    return mix(innerCol, outerCol, (r-0.6)*6.) *(density + sqrt(density))*lightIntensity*anisotropy*0.6/(r*r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition= -CAMERADIS*iCameraFwd;\n    \n    float m = 1.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    fragColor          = vec4(0);\n    vec4 transmittance = vec4(1);\n    #ifdef USEDEPTH\n        // while depth map is done with far fewer steps, we trust it to be accurate\n        float depth    = texture(iChannel0, fragCoord/iResolution.xy).r - (CAMERADIS-1.);\n    #else\n        float depth    = 2.;\n    #endif\n    vec3  pos          = iCameraPosition;\n    vec3  dir          = iViewDirection;\n    float dis          = depth / float(NJUMPSC);\n    pos += (CAMERADIS-1.)*dir;\n    float density;\n    for (int n = 0; n < NJUMPSC; n++)\n    {\n        dir += GRAVLENSING*dis*normalize(pos)/(0.2+dot(pos,pos));\n        pos += dir*dis;\n        density = Density(pos);\n        transmittance*= exp(-dis*Absorb(pos, density));\n        fragColor    += dis*transmittance*(Reflect(pos, density) + Emit(pos, density) + GodRays(pos, dir, density));\n    }\n    if (depth < 2.)\n    {\n        fragColor += transmittance*(Reflect(pos, density));\n    }\n    else\n    {\n        fragColor += transmittance*texture(iChannel3, dir);\n    }\n}", "buffer_c_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom step 1\n    fragColor = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        vec4 col   = texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy);\n        fragColor += pow(col/length(col), vec4(2.))*col*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor /= BLOOMSIZE;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dty3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 827]]}
{"id": "DlcXzf", "name": "Quadratic approx of cubic spline", "author": "jeyko", "description": ".", "tags": ["bezier", "spline", "curve", "cubic", "catmullrom", "hermite"], "likes": 18, "viewed": 328, "published": 3, "date": "1685631469", "time_retrieved": "2024-07-30T17:52:58.216799", "image_code": "// A (simplified a bit) implementation of this paper - https://ttnghia.github.io/posts/quadratic-approximation-of-cubic-curves/\n// I recommend running the demo .exe to get a feel of how it works.\n// Green is catmull rom spline, black is its tangents and points, orange is the bezier spline.\n// Bezier generation on line 130.\n\n#define CATMULL_ROM 0\n#define BEZIER 1\n\nvec2[] pts = vec2[](\n    vec2(0.1,0.2),\n    vec2(0.5,0.1),\n    vec2(0.2,-0.3),\n    vec2(-0.2,0.2),\n    vec2(-0.4,0.2),\n    vec2(-0.5,0.4),\n    vec2(-0.6,-0.2),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4),\n    vec2(-0.2,-0.3),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4)\n);\n\nvec2 get_pt(int i){\n    return pts[(i+pts.length())%pts.length()];\n}\n\n// Characteristic matrices\nconst float[] bezier = float[16](\n    1.,  0.,  0.,  0.,\n    -2., 2.,  0.,  0.,\n    1., -2.,  1.,  0.,\n    0., 0., 0.,  0.\n);\nconst float[] hermite = float[16](\n    1.,  0.,  0.,  0.,\n    0.,  1.,  0.,  0.,\n    -3.,-2.,  3., -1.,\n    2.,  1., -2.,  1.\n);\n\n\nfloat sdLine(vec2 uv, vec2 a, vec2 b){\n    vec2 ab = b - a;\n    vec2 p = a + ab*clamp(dot(uv-a, ab)/dot(ab,ab),0.,1.);\n    return length(uv-p);\n}\n\n\n\nvec2 curve_sample(float[16] m, float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3){\n    return (P0*m[0]  + P1*m[1]  + P2*m[2]  + P3*m[3] ) +\n        t*     (P0*m[4]  + P1*m[5]  + P2*m[6]  + P3*m[7] ) +\n        t*t*   (P0*m[8]  + P1*m[9]  + P2*m[10] + P3*m[11]) +\n        t*t*t* (P0*m[12] + P1*m[13] + P2*m[14] + P3*m[15]);\n}\n\nvoid draw_curve(\n    inout vec3 col, vec2 uv, vec3 curve_col, float[16] m, vec2 P0, vec2 P1, vec2 P2, vec2 P3\n){\n    const float its = 44.;\n    float sd_curve = 1000.;\n    vec2 prev_p;\n    for(float t = 0. ; t <= 1. + 0.01/its; t+=1./its){\n        vec2 p = curve_sample(m,t,P0,P1,P2,P3);\n\n        if(t < 0.01/its)\n            prev_p = p;\n\n        sd_curve = min(sd_curve,sdLine(uv,prev_p,p) - 0.002);   \n        prev_p = p;\n    }\n    col = mix(col,curve_col,smoothstep(fwidth(uv.y),0.,sd_curve));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.95);\n    \n    // Draw background\n    vec2 uvb = mod(uv, 0.1) - 0.05;\n    float sd_bg = 1000.;\n    sd_bg = min(sd_bg,abs(uvb.x));\n    sd_bg = min(sd_bg,abs(uvb.y));\n    col = mix(col,vec3(0.6),smoothstep(fwidth(uv.y),0.,sd_bg));\n    \n    \n    // Offset points\n    for(float i = 0.; i < float(pts.length()); i++){\n        pts[int(i)] += vec2(sin(i+iTime*cos(i)),cos(i+iTime*sin(i)))*0.2;\n    }\n    \n    // Generate catmull rom tangents\n    vec2[pts.length()] tangents;\n    const float visc = 0.5;\n    for(int i = 0; i < tangents.length(); i++){\n        tangents[i] = (get_pt(i+1) - get_pt(i-1))*visc;\n    }\n    \n    const vec3 bezier_col = vec3(1,0.2,0);\n    const vec3 catmull_rom_col = vec3(0.1,0.5,0.);\n    \n    float sd_black_lines = 1000.;\n    float sd_bez_stuff = 1000.;\n    float sd_points = 1000.;\n    \n    for(int spline = 0; spline < 2 + min(iFrame,0); spline++){\n        for(int pid = 0; pid < pts.length(); pid++){\n            // Get catmull rom points\n            vec2 P0 = get_pt(pid);\n            vec2 P1 = tangents[pid];\n            vec2 P2 = get_pt(pid+1);\n            vec2 P3 = tangents[(pid + 1)%tangents.length()];\n            if(spline == CATMULL_ROM){\n                // Draw\n                sd_black_lines = min(sd_black_lines,sdLine(uv,P0,P0+P1));\n                sd_black_lines = min(sd_black_lines,sdLine(uv,P2,P2+P3));\n                draw_curve(col, uv, catmull_rom_col, hermite, P0, P1, P2, P3);\n            } else if (spline == BEZIER){\n                vec2 mid_point = curve_sample(hermite,0.5,P0,P1,P2,P3); \n                \n                P3 = vec2(0);\n                \n                // Calculate beziers\n                const float k = 0.25;\n                \n                vec2 bez_a_P0 = get_pt(pid);\n                vec2 bez_a_P1 = P0 + k*tangents[pid];\n                vec2 bez_a_P2 = mid_point;\n                \n                vec2 bez_b_P0 = mid_point;\n                vec2 bez_b_P2 = get_pt(pid+1);\n                vec2 bez_b_P1 = P2 - k*tangents[(pid+1)%tangents.length()];\n                \n                // Draw\n                draw_curve(col, uv, bezier_col, bezier, bez_a_P0, bez_a_P1, bez_a_P2, P3);\n                \n                draw_curve(col, uv, bezier_col, bezier, bez_b_P0, bez_b_P1, bez_b_P2, P3);\n                \n                sd_bez_stuff = min(sd_bez_stuff, length(bez_a_P1 - uv) - 0.01);\n                sd_bez_stuff = min(sd_bez_stuff, length(bez_b_P1 - uv) - 0.01);\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_a_P1,mid_point));\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_b_P1,mid_point));\n                sd_bez_stuff = min(sd_bez_stuff, sdLine(uv,bez_b_P2,P2 - k*tangents[(pid+1)%tangents.length()]));\n                \n            }\n        }\n    }\n    \n    col = mix(col,bezier_col,smoothstep(fwidth(uv.y),0.,sd_bez_stuff));\n    \n    for(int p = 0; p < pts.length(); p++){\n        sd_points = min(sd_points,length(uv - pts[p]) - 0.01);\n    }\n    sd_points = min(sd_points,sd_black_lines);\n    col = mix(col,vec3(0.0),smoothstep(fwidth(uv.y),0.,sd_points));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[634, 634, 653, 653, 702], [988, 988, 1026, 1026, 1133]]}
{"id": "cl3Xzf", "name": "Bake S", "author": "chenxianming", "description": "dynamic background", "tags": ["raymarching", "background", "cineshader", "sdf3"], "likes": 3, "viewed": 1487, "published": 3, "date": "1685629705", "time_retrieved": "2024-07-30T17:52:59.100436", "image_code": "// rotation\nmat2 n(float a) {\n  float b = sin(a), c = cos(a);\n  return mat2(c, b, -b, c);\n}\nconst mat2 L = mat2(-1.1, -.4, .3, 1);\n// fbm\nfloat M(in vec2 a) {\n  a *= L;\n  return cos(a.x + .18975) * sin(a.y + .494516) + .161525;\n}\n// material\nfloat o(in vec2 d, in float e) {\n  float f = 0.;\n  for (int a = 0; a < 7; a++) {\n    float b = pow(2., float(a));\n    d *= n(float(a));\n    float c = pow(b, -e);\n    c = smoothstep(0., .05, c), f += c * M(b * d * n(float(a)));\n  }\n  return f;\n}\n// repetition\nvec2 p(inout vec2 a, vec2 b) {\n  vec2 c = b * .5, d = floor((a + c) / b);\n  a.y -= mod(d.x, 2.) * .02, a = mod(a + c, b) - c;\n  return d;\n}\n// sphere ( ellipse attached )\nfloat r(vec3 b) {\n  b.y += 1.6;\n  float c = length(b) - 2.;\n  return c;\n}\n// ellipse\nfloat z(vec3 b) {\n  vec3 a = b;\n  vec2 c = p(a.xz, vec2(.04, .032));\n  a.y -= .6, a.y += distance(a.y, r(b)) - .014,\n      a.yz *=\n      n(iTime * .7 * atan(abs(c.x - iTime * 2.), abs(c.y - iTime * 2.)));\n  float d = length(vec3(a.x * .7, a.y * 2., a.z)) - .014;\n  return d;\n}\n// sdf\nfloat g(vec3 b) {\n  vec3 c = b;\n  float a = 5.;\n  a = min(a, r(c)), a = min(a, z(c));\n  return a;\n}\n// calcNormal (IQ)\nvec3 A(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * g(b + a.xyy * 5e-4) + a.yyx * g(b + a.yyx * 5e-4) +\n                   a.yxy * g(b + a.yxy * 5e-4) + a.xxx * g(b + a.xxx * 5e-4));\n}\n\nfloat q(vec2 a, vec2 d) {\n  a.y /= iResolution.y / iResolution.x;\n  vec2 b = p(a, d);\n  float c = 0.;\n  c += smoothstep(.021, .02, length(a) - .02) * .05;\n  float e = mod(b.x, 2.) > 0. && mod(b.y, 2.) > 0. ? 0. : .015;\n  c = mix(c, 0., smoothstep(e, 0., length(a) - e));\n  return c;\n}\n\nvoid mainImage(out vec4 U, in vec2 V) {\n  // initial ro, rd global matrix (IQ)\n  vec2 a = V.xy / iResolution.xy, m = a;\n  a = (a - .5) * 2., a.x *= iResolution.x / iResolution.y;\n  vec3 e = vec3(0), C = vec3(0, 0, 0);\n  e = vec3(0, .6, -1);\n  vec3 f = normalize(C - e), l = normalize(cross(f, vec3(0, 1, 0))),\n       D = normalize(cross(l, f)), s = vec3(0),\n       c = normalize(a.x * l + a.y * D + 2.5 * f);\n  float h = 0.;\n  // smoothly\n  for (int E = 0; E < 32; ++E) {\n    vec3 F = e + c * h;\n    float N = g(F);\n    h += N * .666667;\n  }\n  vec3 i = vec3(0), j = normalize(vec3(0, .05, .3)), G = normalize(j - c),\n       t = normalize(vec3(-10.5, .05, -2.5)), H = normalize(t - c),\n       u = normalize(vec3(.7, .05, 2)), I = normalize(u - c);\n  t.yz *= n(-iTime * .1), j.xy *= n(iTime * .6), u.xy *= n(iTime * .5);\n  // integrated lights\n  if (h < 5.) {\n    vec3 d = e + h * c, b = A(d);\n    float J = o(vec2(o(b.xz * 15., cos(iTime))), .9),\n          k = clamp(dot(b, vec3(.4, 1, -.5)), 0., 1.),\n          v = pow(clamp(dot(b, G), 0., 1.), 150.);\n    v *= k;\n    float w = pow(clamp(dot(b, H), .2, 2.), 250.);\n    w *= k;\n    float x = pow(clamp(dot(b, I), .2, 2.), 80.);\n    x *= k;\n    float O = dot(b, vec3(0, 0, 0));\n    vec3 K = vec3(.7, .1, .09) * 3. + vec3(sin(atan(a.x, a.y)),\n                                           cos(atan(a.x, a.y)),\n                                           sin(atan(a.x, a.y))),\n         P = .7 + .3 * cos(iTime * .1 + a.yxy + vec3(6, 2, 4)),\n         Q = v * vec3(1, .91, .37), R = w * vec3(.19, 7e-3, .63),\n         S = x * vec3(1, .1, .2);\n    if (g(d) == r(d))\n      float W = q(b.xz + J, vec2(3e-3, 3e-3));\n    else if (g(d) == z(d)) {\n      float T = q(b.xy, vec2(.05, .07));\n      i = T * .05 + Q + R + S + K * O + vec3(5e-3) * K * k + P * vec3(.015),\n      i *= pow(k, 3.);\n    }\n  }\n  i = i * 2.5, i += .02 * cos(iTime * .5 + a.xyx + vec3(0, 2, 4)), s += i,\n  s *= mix( // after mask\n      1. - smoothstep(0., .1, length(vec2(m.x * .8, m.y) - vec2(.4, .5)) - .4),\n      1., step(m.y, .5)),\n  U = vec4(s, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3Xzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 29, 29, 91], [131, 138, 158, 158, 229], [230, 242, 274, 274, 486], [487, 501, 531, 531, 640], [641, 672, 689, 689, 745], [746, 757, 774, 774, 1033], [1034, 1041, 1058, 1058, 1140], [1141, 1160, 1179, 1179, 1371], [1373, 1373, 1398, 1398, 1657]]}
{"id": "clcXRf", "name": "soldado", "author": "jorge2017a2", "description": "soldado", "tags": ["2d", "ellipse", "polygon", "soldado"], "likes": 16, "viewed": 202, "published": 3, "date": "1685627977", "time_retrieved": "2024-07-30T17:53:00.182542", "image_code": "//por jorge2017a2\n//1-jun-2023-\n//soldado\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec2 p0_; //punto uv\nvec2 pt0; //punto pos0\nfloat DistL;\nvec3 ColL;  //color linea\nvec3 ColO;  //color salida Out\n\nvoid L( vec2 p1)\n{   \n    float d1=sdSegment(p0_, pt0, p1 );\n    DistL=d1;\n    ColO= DrawFigBorde(ColL, ColO,DistL); \n    pt0 = p1;\n}\nvoid SZ(vec2 p ){pt0 = p;}\nvoid M(vec2 p1){pt0 = p1;}\nvoid C(vec3 pcol){ColL=pcol;}\n\n\nfloat sdPoly14 POLY(14)\nvec2  pt14[14]=vec2[](\nvec2(3.9,2.48),vec2(3.44,2.18),vec2(3.1,2.02),vec2(2.9,1.99),vec2(2.99,1.89),\nvec2(3.16,1.8),vec2(3.26,1.79),vec2(3.5,1.92),vec2(3.88,2.33),vec2(3.94,2.36),\nvec2(3.94,2.36),vec2(4.02,2.34),vec2(3.95,2.46),vec2(3.9,2.48)  );\n\n//ceja der\nfloat sdPoly14a POLY(14)\nvec2  pt14a[14]=vec2[](\nvec2(4.32,2.35),vec2(4.39,2.35),vec2(4.54,2.19),vec2(4.73,1.98),vec2(5.02,1.87),\nvec2(5.1,1.87),vec2(5.17,1.96),vec2(5.19,2.07),vec2(5.08,2.06),vec2(4.88,2.1),\nvec2(4.88,2.1),vec2(4.75,2.18),vec2(4.380,2.45),vec2(4.32,2.35)  );\n\n\n//pelo dercho\nfloat sdPoly17 POLY(17)\nvec2  pt17[17]=vec2[](\nvec2(5.16,2.42),vec2(5.43,2.25),vec2(5.45,2.15),vec2(5.6,1.81),vec2(5.51,1.73),\nvec2(5.6,1.29),vec2(5.5,1.18),vec2(5.47,0.85),vec2(5.32,0.49),vec2(5.07,0.39),\nvec2(5.007,0.35),vec2(5.1,0.85),vec2(5.15,0.85),vec2(5.317,1.27),vec2(5.343,1.67),\nvec2(5.30,2.08),vec2(5.16,2.42)  );\n\n//oreja izq\nfloat sdPoly7b POLY(7)\nvec2  pt7b[7]=vec2[](\nvec2(5.11,2.47),vec2(5.48,2.25),vec2(5.55,2.24),vec2(5.57,2.53),vec2(5.32,3.18),\nvec2(4.98,3.35),vec2(5.11,2.47)  );\n\n//oreja der\nfloat sdPoly7a POLY(7)\nvec2  pt7a[7]=vec2[](\nvec2(2.83,3.34),vec2(2.4,3.13),vec2(2.15,2.62),vec2(2.32,2.16),vec2(2.41,2.14),\nvec2(2.859,2.47),vec2(2.83,3.34)  );\n\n//pelo izq\nfloat sdPoly20 POLY(20)\nvec2  pt20[20]=vec2[](\nvec2(2.85,2.48),vec2(2.39,2.13),vec2(2.35,2),vec2(2.38,1.97),vec2(2.35,1.83),\nvec2(2.37,1.8),vec2(2.35,1.53),vec2(2.38,1.5),vec2(2.42,1.15),vec2(2.56,0.74),\nvec2(2.56,0.74),vec2(2.76,0.47),vec2(2.88,0.41),vec2(3.12,0.26),vec2(3.26,0.19),\nvec2(3.22,0.87),vec2(2.95,1.13),vec2(2.85,1.52),vec2(2.87,2.01),vec2(2.85,2.48)  );\n\nvec3 cejaIzq(vec2 p ,vec3 col)\n{  float sd14 = sdPoly14(p, pt14);\n    vec3 colc;\n    colc = vec3(0.92, 0.93, 0.97);\n    col = DrawFigBorde(colc, col, sd14);\n    return col;\n}\n\nvec3 OjoIzq(vec2 p ,vec3 col)\n{ float r1,d1,dt,d2;\nvec2 pos, med,pr,p1;\n\n    r1 = 0.43;\n    p1 = vec2(3.56, 2.16);\n    d1 = sdCircle(p- p1, r1);\n    //---------;\n    vec3 colc;\n\n    pos = vec2(3.62, 2.05);;\n    med = vec2(0.625, 0.31);\n    float ang;\n\n    ang = -30.0 * PI / 180.0;\n    pr = Rotate(p- pos, med/ 2.0, ang);\n    d2 = sdBox(pr, med);\n    colc = vec3(0.92, 0.93, 0.97);\n    d1 = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(1.0), col, d1);\n//cornea;\n    r1 = 0.07;\n    p1 = vec2(3.63+(-0.15+0.15*sin(iTime)), 2.37);\n    d1 = sdCircle(p- p1, r1);\n    col = DrawFigBorde(vec3(0.0), col, d1);\n    col = cejaIzq(p, col);\n    return col;\n}\n\nvec3 cejasDer(vec2 p ,vec3 col)\n{\n   float sd14a = sdPoly14a(p, pt14a);\n   vec3 colc = vec3(0.92, 0.93, 0.97);\n    col = DrawFigBorde(colc, col, sd14a);\n    return col;\n}\n\nvec3 ojoder(vec2 p ,vec3 col)\n{    float r1,d1,d2;\n    vec2 p1,pr, pos, med;\n\n    r1 = 0.35;\n    p1 = vec2(4.63, 2.19);\n    d1 = sdCircle(p- p1, r1);\n    pos = vec2(4.55, 1.87);\n    med = vec2(0.47, 0.25);\n    float ang;\n\n    ang = 32.0 * PI / 180.0;\n    pr = Rotate(p- pos, med/ 2.0, ang);\n    d2 = sdBox(pr, med);\n    d1 = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(1.0), col, d1);\n    //cornea\n    float r2,d3;\n    vec2 p2;\n    r2 = 0.07;\n    p2 = vec2(4.58+(+0.15+0.15*sin(iTime)), 2.38);\n    d3 = sdCircle(p- p2, r2);\n    d3=intersectSDF(d1,d3); \n    col = DrawFigBorde(vec3(0.0), col, d3);\n    col = cejasDer(p, col);\n    return col;\n}\n\nvec3 pelov3a(vec2 p ,vec3 col)\n{   float sd17 = sdPoly17(p, pt17);   \n    vec3 colc;\n    colc = vec3(0.92, 0.93, 0.97);\n    col = DrawFigBorde(colc, col, sd17);\n    return col;\n}\n\nvec3 OrejaDer(vec2 p ,vec3 col)\n{ vec3 colc;\n    colc = vec3(0.99, 0.81, 0.78);\n    float sd7b = sdPoly7b(p, pt7b);\n    col = DrawFigBorde(colc, col, sd7b);\n    return col;\n}\n\nvec3 OrejaIzq(vec2 p ,vec3 col)\n{   float sd7a = sdPoly7a(p, pt7a);\n    vec3 colc;\n    colc = vec3(0.99, 0.81, 0.78);\n    col = DrawFigBorde(colc, col, sd7a);\n    return col;\n}\n\nvec3 pelov2a(vec2 p ,vec3 col)\n{   float sd20 = sdPoly20(p, pt20);\n    vec3 colc;\n    colc = vec3(0.92, 0.93, 0.97);\n    col = DrawFigBorde(colc, col, sd20);\n    return col;\n}\n\nvec3 lineasRostro(vec2 p ,vec3 col)\n{  vec2 p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12;\n    p1 = vec2(3.05, 1.38);\n    p2 = vec2(3.05, 1.52);\n    p3 = vec2(2.94, 1.62);\n    p0_=p;\n\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3);\n    col = ColO;\n\n    ////linea-2;\n    p1 = vec2(3.16, 1.47);\n    p2 = vec2(3.34, 1.39);\n    p3 = vec2(3.47, 1.38);\n    p4 = vec2(3.64, 1.42);\n    p5 = vec2(3.8, 1.51);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n\n    //---------linea-3;\n    p1 = vec2(4.62, 1.43);\n    p2 = vec2(4.9, 1.37);\n    p3 = vec2(5.07, 1.35);\n    p4 = vec2(5.22, 1.41);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    ////linea-4;\n    p1 = vec2(3.84, 1.67);\n    p2 = vec2(4.17, 1.88);\n    p3 = vec2(4.29, 1.85);\n    p4 = vec2(4.43, 1.78);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    ////linea-5;\n    p1 = vec2(3.96, 2.17);\n    p2 = vec2(3.6, 1.85);\n    p3 = vec2(3.46, 1.73);\n    p4 = vec2(3.35, 1.67);\n    p5 = vec2(3.17, 1.7);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n    ////linea-6;\n    p1 = vec2(4.47, 2.11);\n    p2 = vec2(4.47, 2.1);\n    p3 = vec2(4.46, 2.1);\n    p4 = vec2(4.45, 2.1);\n    p5 = vec2(4.44, 2.1);\n    p6 = vec2(4.69, 1.89);\n    p7 = vec2(4.85, 1.78);\n    p8 = vec2(4.93, 1.75);\n    p9 = vec2(4.94, 1.75);\n    p10 = vec2(5.02, 1.78);\n    p11 = vec2(5.02, 1.78);\n    p12 = vec2(5.1, 1.82);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5); L(p6); L(p7); L(p8);;\n    L(p9); L(p10); L(p11); L(p12);;\n    col = ColO;\n    ////linea-7;\n    p1 = vec2(3.46, 2.68);\n    p2 = vec2(3.61, 2.68);\n    p3 = vec2(3.75, 2.74);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3);;\n    col = ColO;\n    //linea-8;\n    p1 = vec2(4.5, 2.71);\n    p2 = vec2(4.77, 2.67);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2);;\n    col = ColO;\n    //linea-9;\n    p1 = vec2(4.54, 2.82);\n    p2 = vec2(4.74, 2.86);\n    p3 = vec2(4.8, 2.88);\n    p4 = vec2(4.97, 3);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    ////linea-10;\n    p1 = vec2(3.4, 2.84);\n    p2 = vec2(3.26, 2.89);\n    p3 = vec2(3.14, 2.94);\n    p4 = vec2(3.1, 3.03);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    //---------;\n    p1 = vec2(4.68, 2.93);\n    p2 = vec2(4.82, 3.04);\n    p3 = vec2(4.86, 3.12);\n    p4 = vec2(4.86, 3.3);\n    p5 = vec2(4.79, 3.62);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n    p1 = vec2(3.59, 2.89);\n    p2 = vec2(3.46, 2.92);\n    p3 = vec2(3.34, 2.98);\n    p4 = vec2(3.25, 3.03);\n    p5 = vec2(3.3, 3.52);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n    ////linea-13;\n    p1 = vec2(3.41, 3.3);\n    p2 = vec2(3.4, 3.25);\n    p3 = vec2(3.51, 3.2);\n    p4 = vec2(3.61, 3.18);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    ////linea-14;\n    p1 = vec2(3.46, 3.3);\n    p2 = vec2(3.69, 3.46);\n    p3 = vec2(3.79, 3.49);\n    p4 = vec2(4.13, 3.49);\n    p5 = vec2(4.4, 3.45);\n    p6 = vec2(4.44, 3.46);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5); L(p6);;\n    col = ColO;\n    ////linea-15;\n    p1 = vec2(3.93, 3.64);\n    p2 = vec2(4.02, 3.68);\n    p3 = vec2(4.09, 3.68);\n    p4 = vec2(4.24, 3.63);\n    p5 = vec2(4.28, 3.62);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n    //linea-16;\n    p1 = vec2(3.87, 3.7);\n    p2 = vec2(4.08, 3.74);\n    p3 = vec2(4.09, 3.74);\n    p4 = vec2(4.12, 3.74);\n    p5 = vec2(4.28, 3.72);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n    ////linea-17;\n    p1 = vec2(3.99, 2.44);\n    p2 = vec2(4.07, 2.45);\n    p3 = vec2(4.14, 2.46);\n    p4 = vec2(4.18, 2.43);\n    p5 = vec2(4.21, 2.35);\n    p6 = vec2(4.22, 2.22);\n    p7 = vec2(4.21, 2.19);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5); L(p6); L(p7);;\n    col = ColO;\n    ////linea-18;\n    p1 = vec2(4.38, 2.49);\n    p2 = vec2(4.29, 2.5);\n    p3 = vec2(4.21, 2.42);\n    p4 = vec2(4.21, 2.34);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    ////linea-19;\n    p1 = vec2(4.38, 2.49);\n    p2 = vec2(4.29, 2.5);\n    p3 = vec2(4.21, 2.42);\n    p4 = vec2(4.21, 2.34);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n\n   return col;\n}\n\nvec3 pelov2(vec2 p ,vec3 col)\n{  vec2 pos, med,pr;\n    float ang,dt,d1;\n    vec3 colc;\n\n    pos = vec2(4, 0.57);;\n    med = vec2(1.025, 0.225);\n    d1 = sdBox(p- pos, med);\n    col = DrawFigBorde(colc, col, d1);\n    //-----------;\n    float d2;\n    pos = vec2(4.2, 0.7);\n    med = vec2(1.1, 0.3);\n    d2 = sdEllipse(p- pos, med);\n    //---------;\n    float d3;\n    pos = vec2(3.95, 0.31);\n    med = vec2(0.74, 0.25);\n    d3 = sdEllipse(p- pos, med);\n    //---------;\n    colc = vec3(0.92, 0.93, 0.97);\n    dt = unionSDF(d1, d2);\n    dt = unionSDF(dt, d3);\n    col = DrawFigBorde(colc, col, dt);\n    col = pelov2a(p, col);\n    col = pelov3a(p, col);\n    return col;\n}\n\n\nvec3 Rostro(vec2 p ,vec3 col)\n{vec2 pos,med;\n    float d1,dt;\n    vec3 colc;\n    pos = vec2(4.05, 1.79);\n    med = vec2(1.25, 1.4);\n    d1 = sdEllipse(p- pos, med);\n    \n    float d2;\n    pos = vec2(3.98, 2.45);\n    med = vec2(1.1, 1.9);\n    d2 = sdEllipse(p- pos, med);\n    \n    float d3;\n    pos = vec2(5.04, 1.57);\n    med = vec2(0.35, 0.75);\n    d3 = sdEllipse(p- pos, med);\n    \n    float d4;\n    pos = vec2(3.02, 2.91);;\n    med = vec2(0.175, 0.85);\n    d4 = sdBox(p- pos, med);\n    \n    float d5;\n    pos = vec2(4.8, 3.23);;\n    med = vec2(0.18, 0.5);\n    d5 = sdBox(p- pos, med);\n    \n    float r1,r2,he,d6;\n    r1 = 1.04;\n    r2 = 0.275;\n    he = 0.28;\n    pos = vec2(3.94, 3.99);\n    d6 = sdTrapezoid(p- pos, r1, r2, he);\n    \n    colc = vec3(0.99, 0.81, 0.78);\n    dt = unionSDF(d1, d2);\n    dt = unionSDF(dt, d3);\n    dt = unionSDF(dt, d4);\n    dt = unionSDF(dt, d5);\n    dt = unionSDF(dt, d6);\n    col = DrawFigBorde(colc, col, dt);\n    col = OrejaIzq(p, col);\n    col = OrejaDer(p, col);\n    col = OjoIzq(p, col);\n    col = ojoder(p, col);\n    return col;\n}\n\nvec3 cuello(vec2 p ,vec3 col)\n{\n    float r1,r2,he,d3;\n    vec2 pos;\n    vec3 colc;\n    r1 = 1.075;\n    r2 = 1.96;\n    he = 0.425;\n    //camisa;\n    pos = vec2(3.46, 4.075);\n    d3 = sdTrapezoid(p- pos, r1, r2, he);\n    colc = vec3(0.04, 0.08, 0.1);\n    col = DrawFigBorde(colc, col, d3);\n    //cuello;\n    vec2 med;\n    float d5;\n    pos = vec2(3.69, 3.84);;\n    med = vec2(1.095, 0.625);\n    d5 = sdBox(p- pos, med);\n    colc = vec3(0.99, 0.81, 0.78);\n    col = DrawFigBorde(colc, col, d5);\n    return col;\n}\n\nvec3 LOrejaIzq(vec2 p ,vec3 col)\n{    vec2 p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14;\n    p1 = vec2(2.83, 3.17); p2 = vec2(2.82, 3.17);\n    p3 = vec2(2.82, 3.16); p4 = vec2(2.82, 3.15);\n    p5 = vec2(2.82, 3.14); p6 = vec2(2.82, 3.13);\n    p7 = vec2(2.82, 3.06); p8 = vec2(2.81, 3.05);\n    p9 = vec2(2.8, 3.05);  p10 = vec2(2.7, 2.93);\n    p11 = vec2(2.7, 2.93);  p12 = vec2(2.69, 2.76);\n    p13 = vec2(2.41, 2.45); p14 = vec2(2.32, 2.32);\n\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5); L(p6); L(p7); L(p8);;\n    L(p9); L(p10); L(p11); L(p12); L(p13); L(p14);;\n    col = ColO;\n    //----L-2;\n    p1 = vec2(2.34, 2.39); p2 = vec2(2.33, 2.52);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2);;\n    col = ColO;\n    //-l-3;\n    p1 = vec2(2.5, 2.58); p2 = vec2(2.5, 2.57); p3 = vec2(2.49, 2.56);\n    p4 = vec2(2.35, 2.64);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    \n    //-l-4;\n    p1 = vec2(2.6, 2.73);p2 = vec2(2.52, 2.83);\n    p3 = vec2(2.52, 2.9);p4 = vec2(2.55, 2.99);\n    p5 = vec2(2.81, 3.14);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    col = ColO;\n    //-\n    return col;\n}\n\nvec3 LOrejaDer(vec2 p ,vec3 col)\n{\n    ///lineas de oreja der;\n    vec2 p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14;\n    p1 = vec2(5.05, 3.07);p2 = vec2(5.18, 2.79);\n    p3 = vec2(5.28, 2.63);p4 = vec2(5.39, 2.45);\n    p5 = vec2(5.51, 2.36);p6 = vec2(5.46, 2.45);\n    p7 = vec2(5.47, 2.58);p8 = vec2(5.35, 2.64);\n    p9 = vec2(5.3, 2.77);p10 = vec2(5.32, 2.9);\n    p11 = vec2(5.32, 2.9);p12 = vec2(5.2, 3.08);\n    p13 = vec2(5.11, 3.13); p14 = vec2(5.08, 3.13);\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4); L(p5); L(p6); L(p7); L(p8);;\n    L(p9); L(p10); L(p11); L(p12); L(p13); L(p14);;\n    col = ColO;\n    //--------;\n    return col;\n}\n\n\nvec3 nariz(vec2 p, vec3 col)\n{\nvec2 p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14;\np1=vec2(4.01,2.71);\np2=vec2(4.02,2.92);\nColO = col;\np0_= p;\nSZ(p1);M(p1);C(vec3(0.0));\nL(p1);L(p2);\n\ncol=ColO;\np1=vec2(3.91,3.02);p2=vec2(3.83,3.05);\np3=vec2(3.81,3.12);p4=vec2(3.81,3.18);\np5=vec2(3.81,3.19);p6=vec2(3.82,3.2);\np7=vec2(3.9,3.18);p8=vec2(3.97,3.2);\np9=vec2(4.08,3.23);p10=vec2(4.24,3.25);\np11=vec2(4.24,3.25);p12=vec2(4.38,3.18);\np13=vec2(4.26,3.01);p14=vec2(4.27,2.66);\n\nColO = col;\np0_= p;\nSZ(p1);M(p1);C(vec3(0.0));\nL(p1);L(p2);L(p3);L(p4);L(p5);L(p6);L(p7);L(p8);L(p9);L(p10);L(p11);L(p12);L(p13);L(p14);\n\n    col=ColO;\n   return col; \n\n}\n\nvec3 soldado(vec2 p ,vec3 col)\n{   col = cuello(p, col);\n    col = Rostro(p, col);\n    col=nariz(p,col);\n    col = pelov2(p, col);\n    col = LOrejaIzq(p, col);\n    col = LOrejaDer(p, col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y=-uv.y;\n    vec2 uv0=uv;\n    uv-=vec2(-1.5,-0.75); uv*=2.55;\n    //vec3 col = vec3(0.0,1.0-uv0.y*0.5,0.0);\n    vec3 col=mix(vec3(0.21,0.61,0.26),vec3(0.58,0.73,0.37), uv0.y*1.2 );\n    col= soldado(uv,col);\n    col= lineasRostro(uv ,col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 612, 612, 639], [640, 640, 683, 683, 710], [711, 711, 759, 759, 787], [789, 805, 853, 853, 931], [933, 933, 968, 968, 991], [993, 993, 1030, 1030, 1102], [1104, 1104, 1156, 1156, 1263], [1265, 1265, 1290, 1290, 1309], [1310, 1310, 1335, 1335, 1354], [1355, 1355, 1391, 1391, 1419], [1421, 1421, 1486, 1486, 1796], [1798, 1798, 1834, 1834, 1879], [1885, 1885, 1947, 1947, 2073], [2074, 2074, 2155, 2155, 2283], [2285, 2285, 2349, 2349, 2420], [2538, 2538, 2556, 2556, 2671], [2672, 2672, 2689, 2689, 2698], [2699, 2699, 2715, 2715, 2725], [2726, 2726, 2744, 2744, 2755], [4391, 4391, 4423, 4423, 4565], [4567, 4567, 4598, 4598, 5219], [5221, 5221, 5254, 5254, 5391], [5393, 5393, 5424, 5424, 6042], [6044, 6044, 6076, 6076, 6222], [6224, 6224, 6257, 6257, 6398], [6400, 6400, 6433, 6433, 6576], [6578, 6578, 6610, 6610, 6753], [6755, 6755, 6792, 6792, 11810], [11812, 11812, 11843, 11843, 12478], [12481, 12481, 12512, 12512, 13552], [13554, 13554, 13585, 13585, 14064], [14066, 14066, 14100, 14100, 15369], [15371, 15371, 15405, 15433, 16060], [16063, 16063, 16093, 16093, 16704], [16706, 16706, 16738, 16738, 16912], [16914, 16914, 16971, 16971, 17346]]}
{"id": "clcXRX", "name": "random raymarching 1", "author": "chenxianming", "description": "random raymarching 1\n0.8 part smoothing and 32 loop", "tags": ["raymarching", "cineshader"], "likes": 5, "viewed": 1466, "published": 3, "date": "1685620306", "time_retrieved": "2024-07-30T17:53:00.979412", "image_code": "#define PI 3.1415926\n#define TAU 6.2831852\n#define T(s) fract(iTime * s) * PI * 4.\n#define T2(s) fract(iTime * s) * 5.\n\nfloat smin(float a, float b, float r)\n{\n  float h = clamp(.5 + .5 * (b - a) / r, 0., 1.);\n  return mix(b, a, h) - r * h * (1. - h);\n}\n\nmat2 rotation(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\nfloat deg2Rad(float deg) {\n  // return deg * PI / 180.;\n  return radians(deg);\n}\n\nfloat calcSquare(vec3 pos) {\n  vec2 uv = pos.xy;\n\n  uv *= rotation(T(.05));\n\n  uv.x += cos(pos.z) * .3;\n  uv.y += sin(pos.z) * .3;\n\n  float p = abs(uv.x) - .05;\n\n  p = min(-p, -(abs(uv.y) - .05));\n\n  p *= -1.;\n\n  uv *= 1.5;\n\n  float s2 = abs(uv.x) - .05;\n  s2 = min(-s2, -(abs(uv.y) - .05));\n  s2 *= -1.;\n\n  p = max(p, -s2);\n\n  return max(p, abs(pos.z) - 11.5);\n}\n\n/*\n  tunnel map2\n  \n  p.xy *= rotation( p.z * -.75 );\n  \n  p.z += fract( iTime * .25 );\n  \n  p = mod( p, vec3( .5, .5, .1 ) ) - vec3( .25, .25, .05 );\n  \n  //p.xz *= rotation( T( .125  )  );\n  //p.yz *= -rotation( T( .125 ) );\n  \n\n  d = max(\n      max( abs( p.x ) - .1, abs( p.z ) - .1 ),\n      abs( p.y ) - .1\n  );\n*/\n\nfloat map(vec3 p)\n{\n  float d = 5.0;\n\n  p.yz *= rotation(PI * .05);\n  p.z += T2(.05);\n\n  p.z = p.z - 5. * clamp(round(p.z / 5.), -1., 1.);\n\n  float count = 10.;\n\n  for (float i = 0.; i < count; i++) {\n    vec3 pp = p;\n\n    pp.xy *= rotation(deg2Rad((360. / count) * i) + PI * .5);\n\n    d = smin(d, calcSquare(pp), .12);\n  }\n\n  return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773;\n  const float eps = 0.0005;\n  return normalize(e.xyy * map(pos + e.xyy * eps) +\n    e.yyx * map(pos + e.yyx * eps) +\n    e.yxy * map(pos + e.yxy * eps) +\n    e.xxx * map(pos + e.xxx * eps));\n}\n\nvec3 raymarching(vec3 ro, vec3 rd) {\n  float t = 0.,\n    dist = 0.;\n\n  vec3 lig = normalize(vec3(.57703));\n  lig.xz *= rotation(T(.05));\n  vec3 hal = normalize(lig - rd);\n\n  vec3 pos = vec3(0.);\n\n  for (int i = 0; i < 32; i++) {\n    pos = ro + rd * t;\n    dist = map(pos);\n\n    if (t > 1e3) {\n      break;\n    }\n\n    t += dist * .777778;\n  }\n\n  if (dist < 1e-3) {\n    vec3 nor = calcNormal(pos);\n\n    float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n    float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n    spe *= dif;\n\n    float amb = dot(nor, vec3( 0., -0.3, 0. ) );\n\n    return sqrt(spe + vec3(.9) * amb + vec3(.9) * dif - vec3(.2));\n  }\n\n  return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy;\n\n  uv = (uv - .5) * 2.;\n\n  uv.x *= iResolution.x / -iResolution.y; // \n\n  // Time varying pixel color\n  vec3 col = vec3(0.);\n\n  vec3 ro = vec3(0., 0., -0.5);\n  vec3 rd = vec3(uv, 2.);\n\n  col = raymarching(ro, rd);\n\n  col = mix(\n    col,\n    vec3(0.),\n    1. - smoothstep(0., .3, length(uv - vec2(0., -.25)) - .1)\n  );\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 159, 159, 253], [255, 255, 279, 279, 341], [343, 343, 369, 398, 423], [425, 425, 453, 453, 788], [1110, 1110, 1129, 1129, 1448], [1450, 1496, 1526, 1526, 1756], [1758, 1758, 1794, 1794, 2441], [2443, 2443, 2498, 2546, 2959]]}
{"id": "DtcXRX", "name": "4 Splines ", "author": "jeyko", "description": ".", "tags": ["bezier", "spline", "curve", "cubic", "catmullrom", "hermite", "bspline"], "likes": 24, "viewed": 373, "published": 3, "date": "1685620213", "time_retrieved": "2024-07-30T17:53:01.942836", "image_code": "// Coefficients from Freya Holmer's video https://www.youtube.com/watch?v=jvPPXbo87ds\n\n// orange\n#define BEZIER 0\n// green\n#define HERMITE 1\n// purple\n#define CATMULL_ROM 2\n// blue\n#define B_SPLINE 3\n\nvec2[] pts = vec2[](\n    vec2(0.1,0.2),\n    vec2(0.5,0.1),\n    vec2(0.2,-0.3),\n    vec2(-0.2,0.2),\n    vec2(-0.4,0.2),\n    vec2(-0.5,0.4),\n    vec2(-0.6,-0.2),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4),\n    vec2(-0.2,-0.3),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4)\n);\n\nvec2 get_pt(int i){\n    return pts[(i+pts.length())%pts.length()];\n}\n\n// Characteristic matrices\nconst float[] bezier = float[16](\n    1.,  0.,  0.,  0.,\n    -3., 3.,  0.,  0.,\n    3., -6.,  3.,  0.,\n    -1., 3., -3.,  1.\n);\nconst float[] hermite = float[16](\n    1.,  0.,  0.,  0.,\n    0.,  1.,  0.,  0.,\n    -3.,-2.,  3., -1.,\n    2.,  1., -2.,  1.\n);\n\nconst float[] b_spline = float[16](\n    1.,  4.,  1.,  0.,\n    -3., 0.,  3.,  0.,\n    3., -6.,  3.,  0.,\n    -1., 3., -3.,  1.\n);\n\nfloat sdLine(vec2 uv, vec2 a, vec2 b){\n    vec2 ab = b - a;\n    vec2 p = a + ab*clamp(dot(uv-a, ab)/dot(ab,ab),0.,1.);\n    return length(uv-p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.95);\n    \n    // Draw background\n    vec2 uvb = mod(uv, 0.1) - 0.05;\n    float sd_bg = 1000.;\n    sd_bg = min(sd_bg,abs(uvb.x));\n    sd_bg = min(sd_bg,abs(uvb.y));\n    col = mix(col,vec3(0.6),smoothstep(fwidth(uv.y),0.,sd_bg));\n    \n    \n    // Offset points\n    for(float i = 0.; i < float(pts.length()); i++){\n        pts[int(i)] += vec2(sin(i+iTime*cos(i)),cos(i+iTime*sin(i)))*0.1;\n    }\n    \n    // Modify points so bezier is C1 continuous\n    for(int i = 4; i < pts.length(); i+=3){\n        pts[i] = pts[i-1] - normalize(pts[i-2] - pts[i-1])*0.1;\n    }\n    pts[pts.length()-1] = pts[0] - normalize(pts[1] - pts[0])*0.2;\n    \n    \n    float its = 44.;\n    float sd_lines = 1000.;\n    \n    for(int spline = 0; spline < 4; spline++){\n        int inc = 3;\n        if (spline == BEZIER){\n            inc = 3;\n        } else if (spline == HERMITE){\n            inc = 2;\n        } else if (spline == CATMULL_ROM || spline == B_SPLINE){\n            inc = 1;\n        }\n        \n        for(int pid = 0; pid < pts.length() + min(iFrame,0); pid+=inc){\n            vec2 P0;\n            vec2 P1;\n            vec2 P2;\n            vec2 P3;\n            if (spline == BEZIER || spline == B_SPLINE){\n                P0 = get_pt(pid  );\n                P1 = get_pt(pid+1);\n                P2 = get_pt(pid+2);\n                P3 = get_pt(pid+3);\n            } else if (spline == HERMITE) {\n                P0 = get_pt(pid  );\n                P1 = get_pt(pid+1) - P0;\n                P2 = get_pt(pid+2);\n                P3 = get_pt(pid+3) - P2;\n            } else if (spline == CATMULL_ROM) {\n                P0 = get_pt(pid  );\n                P1 = get_pt(pid+1) - get_pt(pid-1);\n                P2 = get_pt(pid+1);\n                P3 = get_pt(pid+2) - P0;\n                const float visc = 0.5;\n                P1 *= visc;\n                P3 *= visc;\n            }\n            \n            if(spline == 0){\n                sd_lines = min(sd_lines,sdLine(uv,P0,P1));\n                sd_lines = min(sd_lines,sdLine(uv,P1,P2));\n                sd_lines = min(sd_lines,sdLine(uv,P2,P3));\n            }\n            \n            float[16] m;\n            if(spline == 0)\n                m = bezier;\n            else if(spline == 1)\n                m = hermite;\n            else if(spline == 2)\n                m = hermite;\n            else \n                m = b_spline;\n            \n            float sd_curve = 1000.;\n            vec2 prev_p;\n            for(float t = 0. ; t <= 1. + 0.01/its; t+=1./its){\n                vec2 p =   (P0*m[0]  + P1*m[1]  + P2*m[2]  + P3*m[3] ) +\n                    t*     (P0*m[4]  + P1*m[5]  + P2*m[6]  + P3*m[7] ) +\n                    t*t*   (P0*m[8]  + P1*m[9]  + P2*m[10] + P3*m[11]) +\n                    t*t*t* (P0*m[12] + P1*m[13] + P2*m[14] + P3*m[15]);\n                    \n                if(spline == B_SPLINE)\n                    p /= 6.; // this can be added to the coefficients lolz\n                \n                if(t < 0.01/its)\n                    prev_p = p;\n                    \n                sd_curve = min(sd_curve,sdLine(uv,prev_p,p) - 0.002);   \n                prev_p = p;\n            }\n            vec3 curve_col = vec3(0);\n            \n            if (spline == BEZIER)\n                curve_col = vec3(1,0.2,0);\n            else if(spline == HERMITE)\n                curve_col = vec3(0.1,0.5,0.);\n            else if(spline == CATMULL_ROM)\n                curve_col = vec3(0.2,0.,1);\n            else if(spline == B_SPLINE)\n                curve_col = vec3(0.1,0.5,0.9);\n            col = mix(col,curve_col,smoothstep(fwidth(uv.y),0.,sd_curve));\n        }\n    }\n    \n    \n    float sd_points = 1000.;\n    for(int p = 0; p < pts.length(); p++){\n        sd_points = min(sd_points,length(uv - pts[p]) - 0.01);\n    }\n    sd_points = min(sd_points,sd_lines);\n    col = mix(col,vec3(0.0),smoothstep(fwidth(uv.y),0.,sd_points));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[469, 469, 488, 488, 537], [955, 955, 993, 993, 1100]]}
{"id": "cl3XRX", "name": "Enter The Matrix [399 chars]", "author": "kishimisu", "description": "It's all an illusion", "tags": ["raymarching", "sdf", "random", "fog", "infinite", "white", "character", "world", "neon", "characters", "rabbit"], "likes": 158, "viewed": 8844, "published": 3, "date": "1685619732", "time_retrieved": "2024-07-30T17:53:02.863375", "image_code": "/* Enter The Matrix by @kishimisu (2023) - https://www.shadertoy.com/view/cl3XRX\n   \n   Let me show you how deep the rabbit hole goes...\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n/* 499 => 399 chars with the help of @Xor, @iapafoto, @FabriceNeyret & @coyote */\nvoid mainImage(out vec4 I, vec2 u) {\n\n    float   M    ,           \n            A    , \n            T    = iTime,\n            R    ;\n    for(    I    *= R; R++ < 66.;) { \n    vec4    X    = iResolution.xyzz, \n    \n        p = A * normalize(vec4((u+u-X.xy) * \n                      mat2(cos(A*sin(T*.1)*.3 + vec4(0,33,11,0))), X.y, 0));\n        p.z += T;\n        p.y = abs(abs(p.y) - 1.);\n        \n        X = fract(dot(X=ceil(p*4.), sin(X)) + X);\n        X.g += 4.;\n        M = 4.*pow(smoothstep(1., .5, \n                       texture(iChannel0, (p.xz+ceil(T+X.x))/4.).a), 8.)-5.;\n        \n        A += p.y*.6 - (M+A+A+3.)/67.;\n        \n        I += (X.a + .5) * (X + A) * ( 1.4 - p.y ) / 2e2 / M / M / exp(A*.1);\n    }\n}\n\n/* Original version [499 chars]:\n\n// Random noise from https://www.shadertoy.com/view/4djSRW (simplified)\nvec4 h(vec4 p) {\n    p += dot(fract(p*.1), p.wzxy+33.33);\n    return fract(p*p.zywx);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy;   u += u - R; \n    float i, t, e, k = iTime;\n    \n    for (O *= i; max(t, i) < 66.; i++) {\n        \n        vec4 r, p = t * normalize(vec4(u/R.y * mat2(cos(t*sin(k*.1)*.3 + vec4(0,33,11,0))), 1, 0)); \n        \n        p.z += k;\n        p.y = abs(abs(p.y) - 1.);\n        \n        r = h(floor(p*4.));\n        e = .1 * pow(smoothstep(1., .5, texture(iChannel0, (p.xz+floor(k+r.x))/4.).a), 8.);\n        \n        t += (p.y - e - t*.05 + .05)*.6;\n        \n        O += .7 * (r.a*.01 + .005) \n            * (r + t + vec4(0,4,0,0))\n            * smoothstep(1.4, .0, p.y)\n            / pow(5. - e*40., 2.) \n            / exp(t*.1);\n    }\n}*/", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3XRX.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[0, 397, 433, 433, 1119]]}
{"id": "mldSzj", "name": "Smooth Minimum&AO", "author": "CodeJUN", "description": " Smooth MinimumAO", "tags": ["ao", "smoothminimum"], "likes": 2, "viewed": 160, "published": 3, "date": "1685602197", "time_retrieved": "2024-07-30T17:53:03.625337", "image_code": "#define TMIN 0.1\n#define TMAX 150.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//\n{\n    return length(p) - .8 ;\n}\n\nfloat sdfRect(in vec3 p, in vec3 b)//\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,-.2))+min(max(d.x,max(d.y,d.z)),0.);//\n\n}\n\nfloat sdfPlane(in vec3 p)\n{\n    return p.y;    \n}\n\n\nfloat smin(float a,float b,float k)//\n{\n    float h=clamp(.5+.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n\n}\n\nfloat map(in vec3 p)//\n{\n    float d=sdfSphere(p);\n    d =smin(d,sdfPlane(p),.25+0.5*sin(iTime));\n    /*float h=sdfRect(p,vec3(0.));\n    d =min(d,sdfPlane(p+vec3(0.,1.,0.))+(h,sdfRect(p,vec3(1.))));*/\n  \n    return d;\n\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)//\n{\n    float t=TMIN;\n    for(int i=0;i<RAYMARCH_TIME &&t<TMAX;i++)\n    {\n        vec3 p=ro+t*rd;\n        //float d=sdfSphere(p);//\n        //float d=sdfRect(p,vec3(.8+.1*sin(iTime),.3+.2*cos(iTime),.3));//\n        float d=map(p);\n        if(d<PRECISION)\n        {\n            //return t;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nfloat calcAO(vec3 p,vec3 n)//AO AO\n{\n    float occ=0.0;\n    float sca=1.0;\n    for(int i=0;i<5;i++)\n    {\n        float h=.01+.03*float(i);\n        float d= map(p+n*h);\n        occ +=(h-d)*sca;\n        if(occ>.35)\n            break;\n    }\n    return clamp(1.-3.*occ,0.,1.);\n}\nfloat calcAO2(vec3 n)// AO\n{\n    return 0.5+0.5*n.y;    \n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//\n{\n    const float h=0.0001;;\n    const vec2 k= vec2 (1,-1);\n  /* return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));*/ \n     return normalize(k.xyy * map(p + k.xyy * h) +\n        k.yyx * map(p + k.yyx * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.xxx * map(p + k.xxx * h));\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro,in vec3 rd,float k)//\n{\n    float res=1.0;\n    float ph=1e20;\n    for(float t=TMIN;t<TMAX;)\n    {\n        \n        float h =map(ro+rd*t);\n        if(h<.01)\n            return 0.0;\n        float y =h*h/(2.0*ph);\n        float d=sqrt(h*h-y*y);\n        res=min(res,k*d/max(0.0,t-y));\n        ph=h;\n        t+=h;\n    }\n    return res;\n}\n\nvec3 render(vec2 uv )\n{\n    vec3 color =vec3(.05);//\n    vec3 ro =vec3 (2.*cos(iTime),1.,2.*sin(iTime));//\n    if(iMouse.z>0.001)//\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),1.+0.2*cos(iTime),2.*sin(theta));\n    }\n    vec3 ta=vec3(0.);//\n    mat3 cam=setCamera(ta,ro,.1*sin(iTime));//\n    vec3 rd =normalize(cam*vec3 (uv,1.));//\n    float t=rayMarch(ro,rd);\n    if(t<TMAX)\n    {\n        vec3 p=ro+t*rd;\n        vec3 n= calcNormal(p);\n        vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//\n        //vec3 light =vec3 (2.,2.,2.);\n       \n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n        p+=PRECISION*n;\n       // float st = softShadow(p,normalize(light-p),2.);//\n        \n        dif *=softShadow(p,normalize(light-p),2.);//\n       /*float st=rayMarch(p,normalize(light-p));\n        if(st<TMAX)//\n        {\n            dif*=.1; \n        }*/\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//\n        color=amd*vec3(0.05)+dif*vec3(.6);\n\n        float ao=calcAO(p,n);\n        ao *=calcAO2(n);\n        color *=ao;\n\n    }\n    return sqrt(color);//\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            color += render(uv);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 143, 143, 212], [214, 214, 250, 250, 280], [282, 282, 327, 327, 429], [431, 431, 458, 458, 480], [483, 483, 531, 531, 611], [613, 613, 643, 643, 839], [841, 841, 904, 904, 1280], [1282, 1282, 1330, 1330, 1569], [1570, 1570, 1604, 1604, 1634], [1636, 1682, 1718, 1718, 2129], [2131, 2131, 2202, 2202, 2357], [2359, 2404, 2464, 2464, 2773], [2775, 2775, 2798, 2798, 4036], [4038, 4038, 4092, 4092, 4400]]}
{"id": "cltSRj", "name": "Glitter Weave", "author": "oneshade", "description": "Haven't shadered in a while.", "tags": ["truchet", "glitter", "weave"], "likes": 23, "viewed": 257, "published": 3, "date": "1685584119", "time_retrieved": "2024-07-30T17:53:04.380319", "image_code": "#define drawSDF(dist, col) color = mix(color, col * mix(0.3, 1.0, smoothstep(0.0, -0.04, dist)), smoothstep(unit, 0.0, dist))\n#define swap(a, b) a += b; b = a - b; a -= b;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash21(in vec2 p) {\n    vec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 Hash22(in vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat SmoothHash21(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    float bl = Hash21(cell);\n    float br = Hash21(cell + vec2(1.0, 0.0));\n    float tl = Hash21(cell + vec2(0.0, 1.0));\n    float tr = Hash21(cell + 1.0);\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat glitter(in vec2 p, in vec2 sparkleLag) {\n    p *= 20.0;\n    vec2 cell = floor(p);\n    float minDist = -1.0;\n    float curFrag = 1.0;\n    for (float i = -1.0; i < 2.0; i++) {\n        for (float j = -1.0; j < 2.0; j++) {\n            vec2 vorp = cell + vec2(i, j);\n            vorp += Hash22(vorp) - 0.5;\n            float dist = length(vorp - p);\n            if (minDist < 0.0 || dist < minDist) {\n                minDist = dist;\n                curFrag = SmoothHash21(vorp - sparkleLag);\n            }\n        }\n    }\n\n    return 0.1 + 0.5 * curFrag * curFrag * curFrag;\n}\n\nvoid doTruchet(in vec2 uv, out vec2 cid, out vec2 cuv, out float arc) {\n    cid = floor(uv);\n    cuv = fract(uv) - 0.5;\n    if (Hash21(cid) < 0.5) cuv.x = -cuv.x;\n    cuv -= cuv.x < -cuv.y ? -0.5 : 0.5;\n    arc = atan(cuv.y, cuv.x);\n    if (mod(cid.x + cid.y, 2.0) < 0.5) arc = -arc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float time = 0.8 * iTime + 8.4;\n    vec2 drift = vec2(0.5 * time + 2.0 * sin(0.3 * time), 5.0 * sin(0.2 * time));\n    uv += drift;\n\n    vec2 cid1, cuv1;\n    float arc1;\n    doTruchet(uv, cid1, cuv1, arc1);\n    float dist1 = length(cuv1) - 0.5;\n    vec3 color1 = min(vec3(0.6, 0.2, 0.7) * 0.8 + glitter(uv, drift), 1.0);\n    vec2 spec1 = vec2((arc1 - 1.0) * 4.0, (dist1 - 0.07) * 70.0);\n    color1 += 0.5 * max(0.0, 1.0 - 0.3 * dot(spec1, spec1));\n    dist1 = abs(dist1) - 0.12;\n\n    uv += 10.5;\n    vec2 cid2, cuv2;\n    float arc2;\n    doTruchet(uv, cid2, cuv2, arc2);\n    float dist2 = length(cuv2) - 0.5;\n    vec3 color2 = min(vec3(0.2, 0.7, 1.0) * 0.8 + glitter(uv, drift), 1.0);\n    vec2 spec2 = vec2((arc2 - 1.0) * 4.0, (dist2 - 0.07) * 70.0);\n    color2 += 0.5 * max(0.0, 1.0 - 0.3 * dot(spec2, spec2));\n    dist2 = abs(dist2) - 0.12;\n\n    if (mod(floor(cuv1.x + cuv1.y) + floor(cuv1.x - cuv1.y), 2.0) > 0.5) {\n        swap(dist1, dist2);\n        swap(color1, color2);\n    }\n\n    drawSDF(dist1, color1 * smoothstep(-0.05, 0.1, dist2));\n    drawSDF(dist2, color2);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 214, 239, 239, 353], [355, 396, 420, 420, 558], [560, 560, 591, 591, 871], [873, 873, 919, 919, 1450], [1452, 1452, 1523, 1523, 1737], [1739, 1739, 1794, 1794, 3044]]}
{"id": "ml3SRB", "name": "Year of Truchets #029", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable) - variable cube size in code", "tags": ["raymarching", "truchet", "tiles"], "likes": 27, "viewed": 307, "published": 3, "date": "1685572387", "time_retrieved": "2024-07-30T17:53:05.220074", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #029\n    06/01/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define P9          1.57078\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\n// globals\nfloat hspeed=0.,tspeed=0.,fspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nvec3 hp=vec3(0),hitpoint=vec3(0);\nvec4 FC=vec4(.19,.22,.23,0);\nmat2 ra1,ra2,ra3,ra4;\n\n// consts for sizing (1-5 - more than that you'll need to move the camera back)\nconst float csize = 4.;\nconst float dsize = csize*4.;\nconst float xsize = dsize*2.;\nconst float psize = csize/2.;\nconst vec2[4] ps4 = vec2[4](vec2(-csize,-csize),vec2(-csize,csize),vec2(csize,csize),vec2(csize,-csize));\n\n// standard bag of tricks\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat ezin(float n) {n = n*n*n; return n;}\nfloat box(vec3 p, vec3 b) { vec3 q = abs(p) - b; return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\n// rotate from corner based on id\nvoid rov(inout vec2 q, int ct, mat2 ga){\n    q-=ps4[ct];\n    q*=ga;\n    q+=ps4[ct];\n}\n\n// truchet pattern\nvec3 getFace(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv)-.5;\n    float px = 12./R.x;\n    float rnd = hash21(id);\n    \n    if(rnd<.34) gv.x = -gv.x;\n    \n    vec2 d2 = vec2(length(gv-.5), length(gv+.5));\n    vec2 gx = d2.x<d2.y? vec2(gv-.5) : vec2(gv+.5);\n    float cx = length(gx)-.5;\n    float d5 = abs(max(abs(gv.x),abs(gv.y))-.5)-.005;\n    \n    if(rnd>.65) cx = min(length(gv.x)-.005,length(gv.y)-.005);\n\n    vec3 h = vec3(.0);\n    vec3 clr = hsv2rgb(vec3((uv.x+uv.y)*.15,1.,.5));\n    h = mix(h, clr,smoothstep(-px,px,abs(abs(cx)-.125)-.05));\n    h = mix(h, vec3(.5),smoothstep(-px,px,abs(cx)-.125));\n    h = mix(h, vec3(.1),smoothstep(px,-px,d5));\n    return h;\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p.x-=fspeed;\n    vec3 q = p-vec3(csize-1.);\n    \n    if(ga1>0.) rov(q.xy,0,ra1);\n    if(ga2>0.) rov(q.xy,1,ra2);\n    if(ga3>0.) rov(q.xy,2,ra3);\n    if(ga4>0.) rov(q.xy,3,ra4);\n\n    float d1 = box(q,vec3(csize)-.025)-.025;\n    if(d1<res.x) {\n        res=vec2(d1,1.);\n        hp=q;\n    }\n    \n    float d2 = p.y+1.;\n    if(d2<res.x) {\n        res=vec2(d2,2.);\n        hp=p;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n// low steps - its just a cube and a floor\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m =ray.y; d=ray.x;\n    \n    hitpoint=hp;\n\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        // light\n        vec3 lpos =vec3(-25.,15.,10.);\n        vec3 l = normalize(lpos-p);\n        // difused\n        float diff = clamp(dot(n,l),.09,.99);\n        // shadow\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        // color\n        vec3 h = vec3(1.);\n        // texture - cube - floor\n        vec2 cuv; vec3 tn = n; int face = 0;\n        if(m==1.) {\n            // match rotation\n            if(ga1>0.) tn.xy*=ra1;\n            if(ga2>0.) tn.xy*=ra2;\n            if(ga3>0.) tn.xy*=ra3;\n            if(ga4>0.) tn.xy*=ra4;\n            \n            //@Shane https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using the normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            // assign vec2 from hitpoint\n            if(face==0) cuv = hitpoint.zy+12.;\n            if(face==1) cuv = hitpoint.zx-8.;\n            if(face==2) cuv = hitpoint.xy;\n            if(face==3) cuv = hitpoint.yx-4.;\n            if(face==4) cuv = hitpoint.zx+24.;\n            if(face==5) cuv = hitpoint.zy+8.;\n\n            cuv*=.5;\n            cuv-=psize;\n            h = getFace(cuv);\n            ref = h*.4;\n        };\n        if(m==2.) {\n            cuv = p.xz-vec2(hspeed,0.)-1.;\n            h = getFace(cuv*.5);\n            ref = h*.8;\n        };\n        \n        C = (diff*h);\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    if(last>0.) C = mix(FC.rgb,C,exp(-.00008*d*d*d));\n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal \n    tspeed = T;\n    tmod = mod(tspeed,10.);\n    if(tmod==10.) { \n        // every loop move cube back\n        fspeed +=dsize;hspeed +=dsize;\n    } \n    // cube floor speed\n    fspeed = fract(T*.1)*xsize;\n    // texture speed\n    hspeed = (T*.1)*xsize;\n    \n    // timing\n    ga1 = ezin(lsp(0.,1.5,tmod));\n    ga2 = ezin(lsp(1.5,3.,tmod));\n    ga3 = ezin(lsp(3.,4.5,tmod));\n    ga4 = ezin(lsp(4.5,6.,tmod));\n\n    // rotation precal\n    if(ga1>0.) ra1 = rot(ga1*P9);\n    if(ga2>0.) ra2 = rot(ga2*P9);\n    if(ga3>0.) ra3 = rot(ga3*P9);\n    if(ga4>0.) ra4 = rot(ga4*P9);\n    \n    // standard setup uv/ro/rd\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(csize,-1.5,18.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy==vec2(0) || M.z <1. ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*2.25-1.125)*PI;\n\n    float ff = 1.5707+(.33*sin(T*.2));\n    mat2 rx = rot(-.52-x), ry = rot(-ff-y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC.rgb,C,exp(-.00008*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3SRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[902, 928, 946, 946, 991], [992, 992, 1013, 1013, 1068], [1069, 1069, 1106, 1106, 1140], [1141, 1141, 1162, 1162, 1183], [1184, 1184, 1211, 1211, 1291], [1293, 1310, 1337, 1337, 1453], [1455, 1489, 1529, 1529, 1574], [1576, 1595, 1618, 1618, 2278], [2280, 2280, 2298, 2298, 2729], [2731, 2731, 2761, 2761, 3000], [3002, 3045, 3077, 3077, 3305], [3307, 3307, 3402, 3402, 5413], [5415, 5415, 5456, 5474, 6882]]}
