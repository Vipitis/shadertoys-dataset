{"id": "3lKXRG", "name": "Rolling feedback", "author": "hamoid", "description": "Experimenting with feedback for a workshop", "tags": ["feedback"], "likes": 9, "viewed": 442, "published": 3, "date": "1583015042", "time_retrieved": "2024-07-30T21:21:19.803445", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 175]], "test": "untested"}
{"id": "3tKXRG", "name": "Day 72", "author": "jeyko", "description": "Two walls with some modded fbm", "tags": ["mdtmjvm"], "likes": 58, "viewed": 1443, "published": 3, "date": "1583011341", "time_retrieved": "2024-07-30T21:21:20.692069", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,2.7)*0.2;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*5.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*3.; \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.8);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.2;\n}\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define FL_H 0.4\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin(6.28*((c)*(d) + (e))))\n\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\nvec3 glowC = vec3(0);\n\nvec3 reflAtten = vec3(1);\nfloat randomO(vec2 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.625)*225.5235);\n} \n\nfloat random(vec2 u){\n\treturn texture(iChannel0, (u/256.)).x;\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = smoothstep(0.5,1.,fract(p));\n    f = smoothstep(0.7,1.,f);\n    //f = smoothstep(0.2,1.,f);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nvec2 valueNoise(float p){\n\tvec2 a = texture(iChannel0, vec2(floor(p))/256.).xy;\n\tvec2 b = texture(iChannel0, vec2(floor(p) + 1.)/256.).xy;\n    return mix(a,b,smoothstep(0.,1.,fract(p)));\n}\n\nfloat fbm(vec2 p) { \n    p *= 0.6;\n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 5; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .7;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n\nvec3 path (float z){\n    z *= 0.5;\n\treturn vec3(\n    \tsin(z + cos(z*0.7))*0.7,\n    \tcos(z + cos(z*1.2))*0.6,\n        0.\n    )*1.;\n}\n\n#define pmod(p,x) mod(p,x) - x*0.5\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    \n    float n = fbm(p.xz)*1.;\n    float m = pow(abs(sin(p.z*0.03)),10.);\n    n *= 1. + m*2.;\n    n *= 0.5;\n    //n = pow(n*1., 4.)*3.;\n    \n    p.xy *= rot(sin(p.z*0.9 + sin( p.x*2. + p.z*4. + iTime*0.1)*0.9 + p.z*0.1)*0.6);\n    \n    \n    float flTop =(-p.y + FL_H + n*0.7)*0.3;\n    d = dmin(d, vec2(flTop,1.));\n    \n    \n    float flBot =(p.y + FL_H + n*0.7)*0.3;\n    \n    d = dmin(d, vec2(flBot,1.));\n    \n    //d = dmin(d, vec2(length(p) - 0.1, 2.));\n    \n    vec3 z = p;\n    p.xz = pmod(p.xz, 0.6);\n    \n    p.y = abs(p.y);\n    p.y -= FL_H*0.7 + n*0.7;\n    float dBalls = length(p);\n    vec3 q = abs(p) - 0.04;\n    \n    \n    float dPipes = max(q.x,q.y);\n    float dPipesB = max(q.y,q.z);\n    //d = dmin(d, vec2(dPipes, 2.));\n    \n    float atten = pow(abs(sin(z.z*0.2 + iTime*0.2)), 10.);\n    float attenB = pow(abs(sin(z.z*0.02  + sin(z.x + iTime)*0.2 + sin(z.y*3.)*1. + iTime*0.5)), 100.);\n    float attenC = pow(abs(sin(z.z*0.1  + sin(z.x + iTime)*0.2 + sin(z.y*3.)*4. + iTime*0.2)), 200.);\n    \n    vec3 col = pal(0.2,0.6 - attenC,vec3(0.1 + pow(abs(sin(iTime*1.)), 40. )*0.005,2.2,0.3),0.5 + sin(iTime)*0.005,0.5 - attenB*0.6);\n    //vec3 col = pal(0.4,0.6,vec3(0.1 + pow(abs(sin(iTime*1.)), 40.)*0.0,2.2,0.3),0.5 + sin(iTime)*0.01,0.5 );\n    \n    //vec3 col = pal(0.4,0.6,vec3(0.1 + pow(abs(sin(iTime*1.)), 40.)*0.1,2.2,0.3),0.5 + sin(iTime)*0.01,0.5 - attenB*0.6);\n\n    \n    float sc = 60. - atten*55.;\n    glowB += exp(-dPipes*sc)*col*reflAtten;\n    glowB += exp(-dPipesB*sc)*col*reflAtten;\n    //glowC += exp(-dBalls*90.)*colB;\n    //glowB -= 0.002/(0.02 + dPipes*dPipes)*0.4;\n    d.x *= 0.6;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro; t = 0.; hit = false;\n    for (int i = 0; i < 150 ; i++){\n    \td = map(p);\n        //glow += exp(-d.x*20.);\n        if(d.x < 0.002){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;        \n    }\n\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.01,0);\n    return normalize(\n    \tvec3(\n        \tmap(p - t.xyy).x - map(p + t.xyy).x,\n        \tmap(p - t.yxy).x - map(p + t.yxy).x,\n        \tmap(p - t.yyx).x - map(p + t.yyx).x\n        )\n    );\n}\n\n\n#define mx (10.*iMouse.x/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float m = pow(abs(sin(T/2.)), 5.);\n    //uv *= 1. - dot(uv,uv)*(1. - pow(m,2.)*1.)*0.4;\n    \n    \n    \n    //uv.xy *= rot(0.1)\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += mx*2.;\n    ro.xy += valueNoise(iTime*40.)*(0.01)*m; // camshake\n    \n    ro.z += iTime*SPEED - sin(T)*SPEED;\n    \n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 1.);\n    \n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    rd.xy *= rot(sin(iTime)*0.1);\n    \n    \n    \n    //ro += rd*texture(iChannel0, (uv*200. + iTime*9.)).x*2.;\n    \n    bool hit; float t; vec3 p;\n    \n    float bounce;\n    \n    float firstT = 0.;\n    vec2 d;\n    for(int i = 0; i < 2     ; i++){\n        d = march(ro, rd, p, t, hit);\n        vec3 n = getNormal(p);\n        \n        if(i == 0){\n        \tfirstT = t;\n        }\n        reflAtten *= 0.53;\n           \n        rd = reflect(rd, n);\n        ro = p + rd*0.1;\n    }\n    \n\t\n    \n    glowB = max(glowB, 0.);\n    glowB = pow(glowB, vec3(1./0.45));\n    col += glowB*0.0004;\n    \n    col += glowC*0.004;\n    col += glow*0.1;\n    col = mix(col, vec3(0.55,0.25,0.2)*0.01, pow(smoothstep(0.,1., firstT*0.08), 2.) );\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define iTime (iTime + 2.5)\n    #define T iTime\n    \n    #define SPEED 2.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1131]], "test": "untested"}
{"id": "3tVSRG", "name": "Particles on a sphere", "author": "michael0884", "description": "Voronoi particle tracking on a cubemap with geodesic integration.", "tags": ["voronoi", "simulation", "sphere"], "likes": 10, "viewed": 457, "published": 3, "date": "1583008640", "time_retrieved": "2024-07-30T21:21:21.593659", "image_code": "float sphere_intersection(vec3 r, vec3 p, vec4 sphere)\n{\n\tp = p - sphere.xyz;\n\tif(p == vec3(0)) return sphere.w;\n\t\n\tfloat b = dot(p, r);\n\tfloat c = sphere.w*sphere.w - dot(p,p);\n\tfloat d = b*b + c;\n\t\n\tif((d <= 0.)) //if no intersection\n\t{\n\t\treturn 0.;\n\t}\n\telse\n\t{\n\t\treturn -sqrt(d) - b; //use closest solution in the direction of the ray\n\t}\n}\n\nvec3 particle_func(vec3 sph_pos, vec4 particle)\n{\n    //decode particle\n    vec3 pos, vel;\n    decodePosVel(particle, pos, vel);\n    \n    return exp(-0.1*pow(angle_between(pos, sph_pos)/prad,2.))*sin(80.*vec3(1,2,3)*abs(vel)) + exp(-pow(40.*angle_between(pos, sph_pos)/prad,2.));\n}\n\nconst int KEY_UP = 38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n   \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 uv = iMouse.xy/iResolution.xy;\n    vec2 angles = vec2(uv.x*2., uv.y - 0.5)*PI;\n    \n    vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n    vec3 camera_y = -normalize(cross(camera_x,camera_z));\n    \n    vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    vec3 cam_pos = -R*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    \n    vec4 sphere = vec4(0.,0.,0., 1.);\n    \n    float t = sphere_intersection(ray, cam_pos, sphere);\n    \n    if(t != 0.)\n    {\n        //sphere\n        vec3 sph_pos = normalize(cam_pos + ray*t - sphere.xyz);\n        vec4 particle = texture(iChannel1, sph_pos);\n\t\tvec4 p0 = pixel(ch0, particle.xy);\n        fragColor.xyz = 1. - particle_func(sph_pos, p0) + particle.z;\n    }\n    else\n    {    \n        //background\n      \n        vec3 sph_pos = normalize(cam_pos + ray*t - sphere.xyz);\n        vec4 particle = texture(iChannel1,  ray.yzx);\n\t\tvec4 p0 = pixel(ch0, particle.xy);\n        fragColor.xyz = 1. - particle_func( ray.yzx, p0);\n    }\n \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//voronoi particle id tracking\n\nvoid Check(inout vec2 id, vec3 pos, vec2 dx)\n{\n    vec3 phi_axis = normalize(cross(pos, vec3(0,0,1)));\n    vec3 theta_axis = normalize(cross(pos, phi_axis));\n    \n    vec3 pos0 = particlepos(id);\n    vec2 id1 = texture(iChannel1, pos + dx.x*phi_axis + dx.y*theta_axis).xy;\n    vec3 pos1 = particlepos(id1);\n    \n    //check if the stored neighbouring particle is closer to this position \n    if(angle_between(pos, pos1) < angle_between(pos, pos0))\n    {\n        id = id1; //copy the particle info\n    }\n}\n\nvoid CheckP(inout vec2 id,  vec3 pos, vec2 id1)\n{\n    vec3 pos0 = particlepos(id);\n    vec3 pos1 = particlepos(id1);\n    \n    //check if the stored neighbouring particle is closer to this position \n    if(angle_between(pos, pos1) < angle_between(pos, pos0))\n    {\n        id = id1; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec2 id, vec3 pos, float r)\n{\n    Check(id, pos, vec2(-r,0));\n    Check(id, pos, vec2(r,0));\n    Check(id, pos, vec2(0,-r));\n    Check(id, pos, vec2(0,r));\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    //previous value   \n    fragColor = texture(iChannel1, rayDir);\n    \n    for(float i = 0.; i < 6.; i++)\n   \t CheckP(fragColor.xy, rayDir, N*hash23(i*rayDir+iTime)); // check with a random particle\n    CheckRadius(fragColor.xy, rayDir, 1.5/1024.);\n    CheckRadius(fragColor.xy, rayDir, 6./1024.);\n    \n    vec3 pos = particlepos(fragColor.xy);\n    fragColor.z *= 0.99;\n    fragColor.z += exp(-pow(100.*angle_between(pos, normalize(rayDir))/prad,2.));\n    if(isnan( fragColor.z )) fragColor.z = 0.;\n    if(iFrame < 2) fragColor = vec4(0.);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 2.\n#define R 2.0\n#define dt 0.25\n#define prad 0.1\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n\n//sqrt of the paticle num\n#define N 25.\n\nvec2 encode2sphere(vec3 pos)\n{\n    pos = normalize(pos);\n    return vec2(atan(pos.y, pos.x), acos(pos.z));\n}\n\nvec3 decodesphere(vec2 angl)\n{\n    return vec3(cos(angl.x)*sin(angl.y), sin(angl.x)*sin(angl.y), cos(angl.y));\n}\n\nvec4 encodePosVel(vec3 pos, vec3 vel)\n{\n    pos = normalize(pos);\n    //phi theta\n    vec2 angl = encode2sphere(pos);\n    //spherical system axis\n    vec3 phi_axis = normalize(cross(pos, vec3(0,0,1)));\n    vec3 theta_axis = normalize(cross(pos, phi_axis));\n\tfloat v = length(vel);\n    //removing the radial component of velocity\n    vel = normalize(vel - dot(vel,pos)*pos);\n    \n    return vec4(angl, v*dot(phi_axis, vel),  v*dot(theta_axis, vel));\n}\n\nvoid decodePosVel(vec4 i, inout vec3 pos, inout vec3 vel)\n{\n    pos = decodesphere(i.xy);\n    //spherical system axis\n    vec3 phi_axis = normalize(cross(pos, vec3(0,0,1)));\n    vec3 theta_axis = normalize(cross(pos, phi_axis));\n    vel = phi_axis*i.z + theta_axis*i.w;\n}\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat angle_between(vec3 a,vec3 b)\n{\n    return acos(dot(a,b)/(length(a)*length(b)));\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\nuniform sampler2D fake;\n\nvec3 particlepos(vec2 id)\n{\n    vec3 pos, vel;\n    decodePosVel(pixel(fake, id), pos, vel);\n    return pos;\n}\n\n", "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 P, in vec2 id )\n{\n    if(id.x < N && id.y < N)\n    {\n         P = pixel(ch0, id);\n    \n        //integrate the geodesic eq\n        vec2 pv = P.zw;\n        //update angular velocities \n        float s = sin(P.y), c = cos(P.y);\n        P.z += dt*(-2.*pv.x*pv.y*c*s/(s*s + 0.00001)); //make sure no /0\n        P.w += dt*(pv.x*pv.x*s*c);\n        //update position\n\t\tP.x += dt*P.z;\n        P.y += dt*P.w;\n        \n        if(iFrame < 2)\n        {\n            //decode particle\n            vec3 pos = vec3(0), vel = vec3(0);\n            decodePosVel(P, pos, vel);\n\n            pos = normalize(hash32(id)-0.5);\n           \n            vel = 0.005*normalize(hash33(pos)-0.5);\n            //encode particle back\n            P = encodePosVel(pos, vel); \n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 342], [344, 344, 393, 415, 625], [651, 651, 708, 745, 1998]], "test": "untested"}
{"id": "WlySzy", "name": "Volumetric Cubes", "author": "aethelwhat", "description": " volumetric shader following from SebH's improved integration shader, see code for references.", "tags": ["raymarching", "volumetric", "sebhsebh"], "likes": 9, "viewed": 426, "published": 3, "date": "1583006228", "time_retrieved": "2024-07-30T21:21:22.423440", "image_code": "/* \n  raymarching volumes by integration of light sources \n  wrt transmission through the scene, over total distance marched.\n \n  features multiple light sources, volumetric shadows\n  there are no hard surfaces in this scene, but I'll add those in \n  my next shader.\n  \n  What is so interesting about the Volumetric Rendering Equation\n  is that it is essentially a generalization of the rendering equation.\n  a high density cube should be similar to a hard surface cube with a \n  good subsurface scatter approximation.\n  \n  references \n  'Volumetric Integration' by SebH - https://www.shadertoy.com/view/XlBSRz\n  http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n  https://graphics.pixar.com/library/ProductionVolumeRendering/paper.pdf\n */\n\nfloat sdfSphere(vec3 p, float radius){\n    return length(p) - radius;\n}\n\nfloat sdfBoxGrid( vec3 p, vec3 b ) // I removed the positive portion\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// I would like to include hard surfaces in the future which requires a \n// lot of changes:\n// probably a preliminary trace to get the final hit that does not integrate,\n// and then separately integrate over that distance so the integrating\n// ray march distance is not perturbed by tracing close to a surface\n// which I saw when testing this with a fractal sdf.\n// also each light evaluation will check shadows of solids\nfloat map(vec3 p)\n{\n    float minD = 0.05; // restrict max step for better scattering evaluation\n\treturn minD;\n}\n\nvec3 evaluateLight(in vec3 lpos, in vec3 pos)\n{\n    vec3 lightPos = lpos;\n    vec3 L = lightPos-pos;\n    vec3 val = 1.0/dot(L,L) * vec3(1.);\n    return val;\n}\n\n// the map to volumes is actually quite expensive \n// since each march needs to check volumetric shadows\nvoid getParticipatingMedia(out float sigmaS, out float sigmaE, out vec3 mediaColor, in vec3 p, out float dist)\n{\n    float heightFog = -0.6;\n    heightFog = 0.8*clamp((heightFog-p.y)*1.0, 0.0, 1.0);\n    \n    float cubeDensity = pow(1.5, 2.+ p.x );\n    p.xy = mod(p.xy+1.5, vec2(3.))-1.5; // repetition\n    dist = -sdfBoxGrid(p, vec3(1.));\n    dist += heightFog;\n    float boxVol = clamp(dist * cubeDensity, 0., 1.);\n    \n    const float constantFog = 0.0;\n    mediaColor = mix(vec3(1.), vec3(1.,0.,0.), sin(iTime));\n    mediaColor = mix(mediaColor, vec3(0.9,1.1,.8), clamp(heightFog,0.,.1)*10.);\n    \n    sigmaS = constantFog + heightFog*10. + boxVol;\n   \n    float sigmaA = 0.;\n    /* //to showcase absorption vs scattering, with colored absorption which as I understand is more correct.\n    float sigmaAFactor = 0.;\n    if(p.y > .0)\n        sigmaAFactor = 1.;\n    sigmaA = 0.1* sigmaAFactor;\n    mediaColor = mix(vec3(1.), mediaColor, clamp(sigmaAFactor,0.,1.));\n    */\n    \n    sigmaE = max(0.000000001, sigmaA + sigmaS); // to avoid division by zero extinction - sebH\n}\n\nfloat phaseFunction()\n{\n    return 1.0/(4.0*3.14);\n}\n\nfloat volumetricShadow(in vec3 from, in vec3 to)\n{\n    const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    vec3 ro = from;\n    vec3 rd = to - from;\n    float dd = length(rd) / numStep;\n    for(float s=0.5; s<(numStep-0.1); s+=1.0)// start at 0.5 to sample at center of integral part\n    {\n        vec3 p = ro + rd*(s/(numStep));\n        vec3 mediaColor = vec3(1.);\n        float dist = 0.;\n        getParticipatingMedia(sigmaS, sigmaE, mediaColor, p, dist);\n        shadow *= exp(-sigmaE * dd);\n    }\n    return shadow;\n}\n\nvec3 lightContrib(vec3 p){\n    const int NUM_LIGHTS = 3;\n    vec3 lightPositions[NUM_LIGHTS];\n    lightPositions[0] = vec3(3.5* sin(iTime), 1.5*cos(iTime)+ 2.5, 1.);\n    lightPositions[1] = lightPositions[0] * vec3(-1., 1.7, 1.);\n    lightPositions[2] = vec3(-1.5 * cos(iTime*.5), 0., sin(iTime*.5)*3.);\n    vec3 lightColors[NUM_LIGHTS];\n    lightColors[0] = 100.0*vec3( 1.0, 0.9, .5);\n    lightColors[1] = 20.*vec3(0.2, 0.5, 1.);\n    lightColors[2] = 20.*vec3(1., 1.1, 1.1);\n    vec3 col = vec3(0.);\n    // only checking shadow for the first light source for since it is the biggest\n    // which is visually pleasing but improper for the integral\n    // since evaluating a light source implies checking its shadow (but I'm skipping for the smaller lights)\n    // doing all lights will kill performance\n    col += lightColors[0]*evaluateLight(lightPositions[0], p)*volumetricShadow(p,lightPositions[0]);\n    col += lightColors[1]*evaluateLight(lightPositions[1], p);\n    col += lightColors[2]*evaluateLight(lightPositions[2], p);\n    \n    return col;\n}\n\nvoid trace(vec3 ro, vec3 rd, inout vec3 finalPos, inout vec3 normal, inout vec3 albedo, inout vec4 scatTrans)\n{\n\tconst int numIter = 200;\n\t\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    \n    // Initialize volumetric scattering integration (to view)\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n\tfloat t = 0.01; // hack: always have a first step of 1 unit to go further\n\tfloat material = 0.0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n    float dd = 0.0;\n\tfor(int i=0; i<numIter; ++i)\n\t{\n\t\tvec3 p = ro + t*rd;\n        vec3 mediaColor = vec3(1.);\n        float dist = 0.;\n    \tgetParticipatingMedia(sigmaS, sigmaE, mediaColor, p, dist);\n        \n        // following is SebH's improved integration \n        // I've added an absorption color to the media\n        \n        // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n        vec3 S = lightContrib(p) * sigmaS * phaseFunction();// incoming light\n        vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE; // integrate along the current step segment\n        scatteredLight += transmittance * Sint * mediaColor; // accumulate and also take into account the transmittance from previous steps\n        // Evaluate transmittance to view independentely\n        transmittance *= exp(-sigmaE * dd);\n        \n        dd = map(p);\n\n\t\tt += dd;\n\t}\n\t\n    finalPos = ro + t*rd;\n    \n    scatTrans = vec4(scatteredLight, transmittance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    float move = 0.;\n    if(iMouse.z > 0.)\n    \tmove = -.521 + sin(iMouse.x/iResolution.x);\n\t// Camera\n\tvec3 ro = vec3(0., 3.8, -7.); // camera and ray origin\n\tvec3 look = ro + vec3(move, -.1 , .5);  // lookat coordinates.\n    float FOV = 3.14159/3.;\n    vec3 forward = normalize(look-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n\tvec3 finalPos = ro;\n\tvec3 albedo = vec3( 0.0, 0.0, 0.0 );\n\tvec3 normal = vec3( 0.0, 0.0, 0.0 );\n    vec4 scattered = vec4( 0.0, 0.0, 0.0, 0.0 );\n    trace(ro, rd, finalPos, normal, albedo, scattered);\n       \n    // this isn's entirely correct but I wanted a background. \n    // background * transmittance + scattered light\n    vec3 color = .25* mix(vec3(0.5,0.3,0.6),vec3(0.8,0.5,0.4),smoothstep(-1.5, .3, rd.y)) * scattered.w + scattered.rgb;\n    \n\tcolor = pow(color, vec3(1./2.2));\n    \n    //debug: transmission\n    //color = vec3(1.) * scattered.w; \n\n    \n\tfragColor = vec4(color, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[784, 784, 822, 822, 855], [857, 857, 927, 927, 997], [999, 1421, 1440, 1440, 1533], [1535, 1535, 1582, 1582, 1693], [1695, 1800, 1912, 1912, 2873], [2875, 2875, 2898, 2898, 2927], [2929, 2929, 2979, 2979, 3552], [3554, 3554, 3580, 3580, 4606], [4608, 4608, 4719, 4719, 6075], [6077, 6077, 6134, 6134, 7271]], "test": "untested"}
{"id": "ttGXzy", "name": "martian flag", "author": "isk", "description": "the flag of the martian congressional republic", "tags": ["flag", "mars", "expanse", "mcr"], "likes": 1, "viewed": 287, "published": 3, "date": "1583004558", "time_retrieved": "2024-07-30T21:21:23.184405", "image_code": "float EPS;\nconst vec3 CB=vec3(0);\nconst vec3 CO=vec3(1.,.55,.06);\nconst vec3 CR=vec3(.44,.06,0.);\nconst vec3 CC=vec3(.34,.82,1.);\nconst float ROR=.39682539682;\nconst float RIR=.29761904761;\nconst float CRW=.0238095238;\nconst vec3 M1=vec3(-.375,0.37301587301,.08333333333);\nconst vec3 M2=vec3(.40277777777,-.34126984127,.05555555555);\n\nfloat sstep(float x){return smoothstep(-EPS,EPS,x);}\nvec3 csstep(float x,vec3 a,vec3 b){return mix(b,a,sstep(x));}\nvec3 cstep(float x,vec3 a,vec3 b){return mix(b,a,step(0.,x));}\n\nfloat circ(vec2 p,float r){return length(p)-r;}\nfloat ring(vec2 p,float r0,float r1){return max(-circ(p,r0),circ(p,r1));}\nfloat cres(vec2 p,float r,vec2 o){return max(circ(p,r),-circ(p-o,r+EPS));}\n\nvec3 flag(vec2 p){\n    vec3 y0=csstep(circ(p-M1.xy,M1.z),CO,CB);\n    vec3 y1=csstep(circ(p-M2.xy,M2.z),CB,CO);\n    vec3 c=cstep(p.y,y0,y1);\n    c=csstep(ring(p,RIR,ROR),c,CR);\n    c=csstep(cres(p,RIR,vec2(CRW,0.)),c,CC);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    EPS=2./length(iResolution);\n    fragColor=vec4(flag((fragCoord-.5*iResolution.xy)/iResolution.y),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 356, 356, 387], [388, 388, 423, 423, 449], [450, 450, 484, 484, 512], [514, 514, 541, 541, 561], [562, 562, 599, 599, 635], [636, 636, 670, 670, 710], [712, 712, 730, 730, 948], [950, 950, 1004, 1004, 1112]], "test": "untested"}
{"id": "tlyXzG", "name": "Cubemap Face Unwrap", "author": "spalmer", "description": "A debugging tool, visual aid, some helper functions for managing cubemap uvw and face indices.  Hope it's useful.", "tags": ["cubemap", "unwrap"], "likes": 20, "viewed": 1113, "published": 3, "date": "1582991165", "time_retrieved": "2024-07-30T21:21:23.951355", "image_code": "// I expect someone has done this better, faster, cheaper somewhere\n// and I wouldn't mind seeing how, but I didn't see any other\n// examples of such cubemap face debugging tool here on the site,\n// so I took the first thing I got working and made a toy out of it.\n// Hopefully someone will find it useful.  I'd appreciate any tips.\n// heck I probably got the face id's wrong or uv's backward or upside down.\n\n// my http://shadertoy.com/view/wdXBDr is similar\n// Hey!  I did find something related, finally:  http://shadertoy.com/view/3l2SDR\n// Fabrice has some coordinate conversion code:  http://shadertoy.com/view/WdlGRr\n// Wunkolo has some stuff here I hope to grok:   http://shadertoy.com/view/wltXDl\n// see rory618 http://shadertoy.com/view/wdsBRn\n\n#define CUBEMAP iChannel1 // pick a channel\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy\n        , q = (p + p - R)/R.y;\n    c.rgb = Unwrap(CUBEMAP, q * .755).rgb;\n//    c.rgb = pow(c.rgb, vec3(1./2.2)); // gamma (disable for texture cube sources, or fix those on load)\n    c.a = 1.;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// these I just threw together over in http://shadertoy.com/view/wtVSDw\n// but they seem to work, or at least seem to be inverses of each other.\n\nint CubeFaceOfDir(vec3 d) // just the face id\n{\n    vec3 a = abs(d);\n    int f = a.x >= a.y ? (a.x >= a.z ? 0 : 2) : (a.y >= a.z ? 1 : 2);\n    int i = f + f;\n    if (d[f] < 0.) ++i;\n    return i;\n}\n// takes normalized direction vector, returns uv in c.xy and face id in c.z\nvec3 DirToCubeUVFace(vec3 d)\n{\n    int i = CubeFaceOfDir(d),\n        f = i >> 1;\n    vec2 uv;\n    switch (f) {\n        case 0: uv = d.yz; break;\n        case 1: uv = d.xz; break;\n        case 2: uv = d.xy; break;\n    }\n    uv /= abs(d[f]); // project\n    if ((i&1) != 0) // negative faces are odd indices\n        uv.x = -uv.x; // flip u\n    return vec3(uv, float(i));\n}\n// takes uv in c.xy and face id in c.z, returns unnormalized direction vector\nvec3 CubeUVFaceToDir(vec3 c)\n{\n    int i = int(c.z); \n    vec3 d = vec3(c.xy, 1. - 2. * float(i & 1));\n    d.x *= d.z; // only unflip u \n    switch (i >> 1) { // f\n        case 0: d = d.zxy; break;\n        case 1: d = d.xzy; break;\n        case 2: d = d.xyz; break;\n    }\n    return d; // needs normalized probably but texture() doesn't mind.\n}\n\nivec3 DirToCubeTexelFace(vec3 p)\n{\n    return ivec3(DirToCubeUVFace(p) * vec3(512,512,1));\n}\n// function to work with individual texels; takes texel index in xy and face id in z,\n// returns unnormalized direction vector to center of texel in cubemap\n// rory618 http://shadertoy.com/view/wdsBRn\nvec3 CubeTexelFaceToDir(ivec3 p)\n{\n    vec2 q = vec2(p - 512) + .5; vec3 r;\n    switch (p.z) {\n        case 0: r = vec3( 512,-q.y,-q.x); break;\n        case 1: r = vec3( q.x, 512, q.y); break;\n        case 2: r = vec3( q.x,-q.y, 512); break;\n        case 3: r = vec3(-512,-q.y, q.x); break;\n        case 4: r = vec3( q.x,-512,-q.y); break;\n        case 5: r = vec3(-q.x,-q.y,-512); break;\n    }\n    return r;\n}\n\n// just for debugging so probably broken and imprecise.\n// in fact it's a big ol' kludge atm.  what a mess!  I'll try to improve it as I get time.\nvec4 Unwrap(samplerCube ch, vec2 q)\n{\n    vec2 uv = q * .5 + .5;\n    uv *= 4.;\n    uv -= vec2(.0,.5);\n    int i = -1;\n    if (uv.y >= 1. && uv.y < 2.) {\n        int f = int(floor(uv.x));\n        if (f >= 0 && f < 2) i = 3*f + 1;\n     \telse if (f >= 2 && f < 4) i = 5*f - 10;\n        if (f == 2) uv = vec2(uv.y, -uv.x); // maybe rotate, different directions\n        else if (f == 0) uv = vec2(-uv.y, uv.x);\n    } else {\n\t\tif (int(uv.x) == 1) {\n        \tif (uv.y >= 0. && uv.y < 1.) { i = 3; uv.x = 0.-uv.x; }\n        \telse if (uv.y >= 2. && uv.y < 3.) { i = 2; uv.y = 0.-uv.y; }\n    \t}\n    }\n\tif (!(i >= 0)) return vec4(vec3(.7),1);\n    uv = fract(uv);\n    vec3 d = CubeUVFaceToDir(vec3(uv * 2. - 1., float(i)));\n//    d = CubeUVFaceToDir(DirToCubeUVFace(d)); // ensure can convert back&forth flawlessly\n//    d = CubeUVFaceToDir(DirToCubeUVFace(d));\n    vec4 c = textureLod(ch, d, 0.);\n    //c.rgb = pow(c.rgb, vec3(2.2)); // gamma correction - skipping as it cancels out here\n    return c;\n} // result in srgb gamma atm\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[801, 801, 837, 837, 1061]], "test": "untested"}
{"id": "wlGXzG", "name": "Spiraly bars", "author": "Axioplase", "description": "Playing with space.", "tags": ["spiral"], "likes": 1, "viewed": 303, "published": 3, "date": "1582990793", "time_retrieved": "2024-07-30T21:21:24.715312", "image_code": "#define PI 3.141592\n\nvec3 bars(vec2 uv) {\n   if (fract(uv.x*15.) < .5) {\n         return vec3(0.);\n    } else {\n        return vec3(1.);\n    }\n }\n\nvoid wobble(vec2 uv, out vec3 col, float radius, float phase, float amplitude) {\n   if (length(uv) < radius) {\n        float theta = cos(phase + iTime*amplitude) * amplitude* PI * (radius - length(uv));\n        mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n        vec2 uv2 = rot * uv;\n        col = bars(uv2);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = bars(uv);\n\twobble(uv, col, 0.3, 0., 3.5);\n\twobble(uv-vec2(0.6,-0.25), col, 0.25, PI/4., 2.);    \n\twobble(uv-vec2(-0.6,0.25), col, 0.20, 3.*PI/4., 3.);    \n\twobble(uv-vec2(0.6,0.25), col, 0.15, PI/2., 4.);    \n\twobble(uv-vec2(-0.6,-0.25), col, 0.15, 0., 5.);    \n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 41, 41, 145], [147, 147, 227, 227, 485], [487, 487, 544, 544, 919]], "test": "untested"}
{"id": "ttGSRG", "name": "Collision", "author": "avin", "description": "collision visualisation with flashes", "tags": ["collision", "flash"], "likes": 40, "viewed": 1298, "published": 3, "date": "1582974063", "time_retrieved": "2024-07-30T21:21:25.480267", "image_code": "#define COL1 vec3(24, 32, 38) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 2./min(iResolution.x, iResolution.y)\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    float m = 0.;    \n    for (float i = 0.; i < float(SIZE); i += 1.) {\n        vec4 point = FD(i, 0);\n        vec4 colData = FD(i, 1);\n        \n        float colTimeDiff = clamp(iTime - colData.x, 0., .5)*5.;        \n        \n        vec2 pos = point.xy;        \n        \n        float d = length(uv - pos)*.5;        \n        float g = .1/(d*(10. + 20.*colTimeDiff))*FLASH_POWER;        \n\n        m += g;        \n    }\n    \n    vec3 col = mix(COL1, COL2, m);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if(y > 2 || x > SIZE){\n    \tdiscard;\n    }     \n    \n    vec2 rt = vec2(iResolution.x / iResolution.y, 1.);\n    \n    if(iFrame == 1){\n        float ms = sqrt(float(SIZE));\n        float yp = floor(float(x) / ms) - ms*.45;\n        float xp = mod(float(x), ms) - ms*.45;\n        vec2 pos = (vec2(xp,yp)) * (1./ms)*.9;\n                \n        pos *= rt;                       \n                \n        vec2 dir = normalize(vec2(hash12(fragCoord*200.)*2.-1., hash12(fragCoord * 100.)*2.-1.));   \n        \n        if(y==0){\n            fragColor = vec4(pos, dir);                   \n        }\n        if(y==1){\n            fragColor = vec4(-100., 0,0,0);                   \n        }\n        \n    } else {\n        vec4 iPoint = FD(x,0);\n        vec2 pos = iPoint.xy;        \n        vec2 dir = iPoint.zw;\n                \n        \n        bool col = false;\n                                                       \n        \n        if(iPoint.x <= (-.5*rt.x + RADIUS)){\n            dir.x *= -1.;      \n            col = true;\n        }\n        if(iPoint.x >= (.5*rt.x - RADIUS)){\n            dir.x *= -1.; \n            col = true;\n        }\n        if(iPoint.y <= (-.5*rt.y + RADIUS)){\n            dir.y *= -1.;            \n            col = true;\n        }\n        if(iPoint.y >= (.5*rt.y - RADIUS)){\n            dir.y *= -1.;            \n            col = true;\n        }\n        \n        for(int i=0; i<SIZE; i+=1){\n            if(i!=x){\n                vec4 nPoint = FD(i,0);\n                vec2 nPointDir = nPoint.zw;\n                if(distance(nPoint.xy, pos) < (RADIUS*2.)){\n                    vec2 inV = normalize(nPoint.xy - pos);\n                    if(dot(dir, inV) > 0.){                    \t \n                        dir = reflect(dir, inV);                        \n                    }\n                    \n                    col = true;                    \n                }\n            }        \t\n        }\n        \n        dir = normalize(dir);\n        \n        pos += dir * SPEED;\n        \n        pos.x = min(max(pos.x, -.5*rt.x + RADIUS), .5*rt.x - RADIUS);\n        pos.y = min(max(pos.y, -.5*rt.y + RADIUS), .5*rt.y - RADIUS);\n        \n    \n        if(y==0){\n            fragColor = vec4(pos, dir);\n        }\n        if(y==1){\n            if(col){\n                fragColor = vec4(iTime, 0, 0, 0);\n            } else {\n                fragColor = FD(x,1);\n            }\n            \n        }\n        \n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 122\n#define FLASH_POWER .38\n#define RADIUS .01\n#define SPEED .0018\n\n#define FD(x,y) texelFetch(iChannel0, ivec2(x, y), 0)\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 228, 228, 799]], "test": "untested"}
{"id": "3tGSDD", "name": "Swirling cube", "author": "tmst", "description": "- Just having a bit of fun with the voxel setup from my earlier [url=https://www.shadertoy.com/view/wlG3RW]Volumetric 3D fluid[/url].\n- Nothing much to say about this one!", "tags": ["cube", "voxel", "volumetric", "swirling"], "likes": 102, "viewed": 1806, "published": 3, "date": "1582965272", "time_retrieved": "2024-07-30T21:21:26.516496", "image_code": "#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define BOX_MIN vec3(-1.0)\n#define BOX_MAX vec3(1.0)\n#define BOX_CENTER vec3(0.0)\n#define EPS 0.001\n\n#define INV_SQRT_2 0.70710678\n#define VIGNETTE_INTENSITY 0.25\n\n// ================\n// Generic helpers\n// ================\n\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\n// ========================\n// Marching through voxels\n// ========================\n\nvoid boxClip(\n    in vec3 boxMin, in vec3 boxMax,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n){\n    //for each coord, clip tRange to only contain t-values for which p+t*v is in range\n    vec3 tb0 = (boxMin - p) / v;\n    vec3 tb1 = (boxMax - p) / v;\n    vec3 tmin = min(tb0, tb1);\n    vec3 tmax = max(tb0, tb1);\n\n    //t must be > tRange.s and each tmin, so > max of these; similar for t1\n    tRange = vec2(\n        max(max(tmin.x, tmin.y), tmin.z),\n        min(min(tmax.x, tmax.y), tmax.z)\n    );\n\n    //determine whether ray intersects the box\n    didHit = step(tRange.s, tRange.t);\n}\n\nvec3 lmnFromWorldPos(vec3 p) {\n    vec3 uvw = (p - BOX_MIN) / (BOX_MAX - BOX_MIN);\n    return floor(uvw * vec3(BOX_N));\n}\n\nvoid readLMN(vec3 lmn, out vec3 normal, out float density) {\n    vec4 data = texture(iChannel0, vcubeFromLMN(1, lmn));\n    normal = 2.0*(data.xyz - 0.5);\n    density = clamp(unmix(0.0, 3.0, data.a), 0.0, 1.0);\n}\n\nvoid boxFromLMN(in vec3 lmn, out vec3 boxMin, out vec3 boxMax) {\n    vec3 boxSize = (BOX_MAX - BOX_MIN) / BOX_N;\n\n    boxMin = BOX_MIN + (floor(lmn)/BOX_N) * (BOX_MAX - BOX_MIN);\n    boxMax = boxMin + boxSize;\n}\n\nvoid march(\n    in vec3 p, in vec3 nv,\n    out vec4 color\n) {\n    vec2 tRange;\n    float didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n\n    color = vec4(0.0);\n    if (didHitBox < 0.5) {\n        return;\n    }\n\n    float t = tRange.s;\n    for (int i=0; i<500; i++) {\n        // Get voxel data\n        vec3 worldPos = p + (t+EPS)*nv;\n        vec3 lmn = lmnFromWorldPos(worldPos);\n        \n        vec3 nvNormal;\n        float density;\n        readLMN(lmn, nvNormal, density);\n\n        // Determine voxel rgba color (with premultiplied alpha)\n        vec3 lightPos = vec3(0.0, 10.0, 0.0);\n        vec3 nvFragToLight = normalize(lightPos - worldPos);\n        \n        float maxLen = 0.5*distance(BOX_MIN, BOX_MAX);\n        float curLen = length(BOX_CENTER - worldPos);\n        \n        float lamount = 1.0;\n        lamount *= mix( dot(nvNormal, nvFragToLight), 1.0, 0.65);\n        lamount *= smoothstep(0.1*maxLen, 0.6*maxLen, curLen);\n        \n        float calpha = pow(density, 3.0);\n        vec3 cbase = clamp(lamount, 0.0, 1.0) * mix(0.5 + 0.5*nvNormal, vec3(1.0), 0.5);\n        vec4 ci = vec4(cbase, 1.0)*calpha;\n\n        // Determine path to next voxel\n        vec3 curBoxMin, curBoxMax;\n        boxFromLMN(lmn, curBoxMin, curBoxMax);\n\n        vec2 curTRange;\n        float curDidHit;\n        boxClip(curBoxMin, curBoxMax, p, nv, curTRange, curDidHit);\n\n        // Adjust alpha for distance through the voxel\n        ci *= clamp((curTRange.t - curTRange.s)*15.0, 0.0, 1.0);\n\n        // Accumulate color\n        color = vec4(\n            color.rgb + (1.0-color.a)*ci.rgb,\n            color.a + ci.a - color.a*ci.a\n        );\n\n        // Move up to next voxel\n        t = curTRange.t;\n        if (t+EPS > tRange.t || color.a > 1.0) { break; }\n    }\n}\n\n// ================\n// Final rendering\n// ================\n\nvec3 skybox(vec3 nvDir) {\n    return ( mix(0.2, 0.25, smoothstep(-0.2,0.2, nvDir.y)) )*vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    vec2 mouseAng = mix(\n        vec2(0.1*iTime, 0.5*3.14159 + 0.3*cos(iTime*0.5)),\n        3.14159 * iMouse.xy / iResolution.xy,\n        isMousePressed\n    );\n    \n    vec3 camPos = 2.0 * (\n        sin(mouseAng.y) * vec3(cos(2.0*mouseAng.x), 0.0, sin(2.0*mouseAng.x)) +\n        cos(mouseAng.y) * vec3(0.0, 1.0, 0.0)\n    );\n    vec3 lookTarget = vec3(0.0);\n\n\tvec3 nvCamFw = normalize(lookTarget - camPos);\n    mat4 clipToWorld = getClipToWorld(iResolution.x/iResolution.y, nvCamFw);\n\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    vec3 nvCamDir = normalize(vWorld.xyz / vWorld.w);\n\n    vec3 bgColor = skybox(nvCamDir);\n\n    vec4 finalColor;\n    march(camPos, nvCamDir, finalColor);\n    fragColor = vec4(finalColor.rgb + (1.0 - finalColor.a)*bgColor, 1.0);\n    \n    // Vignette\n    vec2 radv = vec2(0.5, 0.5) - uv;\n    float dCorner = length(radv) / INV_SQRT_2;\n    float vignetteFactor = 1.0 - mix(0.0, VIGNETTE_INTENSITY, smoothstep(0.4, 0.9, dCorner));\n\n    fragColor = vignetteFactor * fragColor;\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BOX_N 128.0\n\n// Data is organized into 3 \"pages\" of 128x128x128 voxels.\n// Each \"page\" takes up 2 faces of the 1024x1024 cubemap,\n// each face storing 8x8=64 of the 128x128 slices.\n\nvec3 vcubeFromLMN(in int page, in vec3 lmn)\n{\n    // subtexture within [0,8)^2\n    float l = mod(floor(lmn.x), 128.0);\n    float tm = mod(l, 8.0);\n    float tn = mod((l - tm)/8.0, 8.0);\n    vec2 tmn = vec2(tm, tn);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(floor(lmn.yz), 128.0);\n\n    // pixel position on 1024x1024 face\n    vec2 fragCoord = 128.0*tmn + mn + 0.5;\n    vec2 p = fragCoord*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else {\n        fv = fv = vec3(p, 1.0);\n    }\n\n    if (l < 64.0) {\n        return fv;\n    } else {\n        return -fv;\n    }\n}\n\nvoid lmnFromVCube(in vec3 vcube, out int page, out vec3 lmn)\n{\n    // page and parity, and pixel position on 1024x1024 texture\n    vec2 p;\n    float parity;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        page = 1;\n        p = vcube.yz/vcube.x;\n        parity = vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        page = 2;\n        p = vcube.xz/vcube.y;\n        parity = vcube.y;\n    } else {\n        page = 3;\n        p = vcube.xy/vcube.z;\n        parity = vcube.z;\n    }\n    vec2 fragCoord = floor((0.5 + 0.5*p)*1024.0);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(fragCoord, 128.0);\n\n    // subtexture within [0,8)^2\n    vec2 tmn = floor(fragCoord/128.0);\n\n    float lAdd;\n    if (parity > 0.0) {\n        lAdd = 0.0;\n    } else {\n        lAdd = 64.0;\n    }\n    lmn = vec3(tmn.y*8.0 + tmn.x + lAdd, mn);\n}\n", "cube_a_code": "// --------------------------------------\n// Helpers for accessing volumetric data\n// --------------------------------------\n\nvec4 getDataNearest(vec3 lmn) {\n    return texture(iChannel0, vcubeFromLMN(1, lmn));\n}\n\nfloat getDensityInterp(vec3 lmn) {\n    vec3 flmn = floor(lmn);\n\n    float d000 = getDataNearest( flmn ).a;\n    float d001 = getDataNearest( flmn + vec3(0.0, 0.0, 1.0) ).a;\n    float d010 = getDataNearest( flmn + vec3(0.0, 1.0, 0.0) ).a;\n    float d011 = getDataNearest( flmn + vec3(0.0, 1.0, 1.0) ).a;\n    float d100 = getDataNearest( flmn + vec3(1.0, 0.0, 0.0) ).a;\n    float d101 = getDataNearest( flmn + vec3(1.0, 0.0, 1.0) ).a;\n    float d110 = getDataNearest( flmn + vec3(1.0, 1.0, 0.0) ).a;\n    float d111 = getDataNearest( flmn + vec3(1.0, 1.0, 1.0) ).a;\n\n    vec3 t = lmn - flmn;\n    float dY0Z0 = mix(d000, d100, t.x);\n    float dY1Z0 = mix(d010, d110, t.x);\n    float dY0Z1 = mix(d001, d101, t.x);\n    float dY1Z1 = mix(d011, d111, t.x);\n    float dZ0 = mix(dY0Z0, dY1Z0, t.y);\n    float dZ1 = mix(dY0Z1, dY1Z1, t.y);\n    return mix(dZ0, dZ1, t.z);\n}\n\n// ------------------------------\n// Some noise for the cube faces\n// ------------------------------\n\nfloat rand(in vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    vec2 m = pf*pf*(3.0-2.0*pf);\n    return mix(mix(r00, r10, m.x), mix(r01, r11, m.x), m.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*32.0;\n\n    float v = noise(p);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    return v;\n}\n\n// ----------------------------------------------------------------------\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\n// in matrix form: (1-c)[n*n^T] + cI - s[[0,n3,-n2][-n3,0,n1][n2,-n1,0]]\n// ----------------------------------------------------------------------\n\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 n = normalize(axis);\n    \n    return mat3(\n        (1.0-c)*n.x*n.x + c,\n        (1.0-c)*n.y*n.x + s*n.z,\n        (1.0-c)*n.z*n.x - s*n.y,\n    \n       \t(1.0-c)*n.x*n.y - s*n.z,\n        (1.0-c)*n.y*n.y + c,\n        (1.0-c)*n.z*n.y + s*n.x,\n    \n        (1.0-c)*n.x*n.z + s*n.y,\n        (1.0-c)*n.y*n.z - s*n.x,\n        (1.0-c)*n.z*n.z + c\n    );\n}\n\n// -----------------------\n// Volumetric data update\n// -----------------------\n\n#define GD 3.0\n\nvoid doPage1(out vec4 fragColor, in vec3 lmn)\n{\n    // -----------------------------------\n    // Compute normal from previous frame\n    // -----------------------------------\n    float hLA = getDataNearest( lmn + vec3(-GD,  0.0,  0.0) ).a;\n    float hLB = getDataNearest( lmn + vec3( GD,  0.0,  0.0) ).a;\n    float hMA = getDataNearest( lmn + vec3( 0.0, -GD,  0.0) ).a;\n    float hMB = getDataNearest( lmn + vec3( 0.0,  GD,  0.0) ).a;\n    float hNA = getDataNearest( lmn + vec3( 0.0,  0.0, -GD) ).a;\n    float hNB = getDataNearest( lmn + vec3( 0.0,  0.0,  GD) ).a;\n    \n    vec3 gradA = vec3(hLB-hLA, hMB-hMA, hNB-hNA);\n    vec3 nvNormal = -gradA/( length(gradA) + 1e-5 );\n    \n    // ---------------\n    // Update density\n    // ---------------\n    float iTimeN = float(iFrame)/60.0;\n    \n    vec3 mid = vec3(63.5);\n    vec3 absd = abs(lmn-mid);\n    float dcorner = max(max(absd.x, absd.y), absd.z);\n    \n    float dNext = 0.0;\n    if (dcorner > 62.0) {\n        float noiseVal = 0.0;\n        \n        if (absd.x > 62.0) {\n            noiseVal = fbm(0.02*lmn.yz);\n        } else if (absd.y > 62.0) {\n            noiseVal = fbm(0.02*lmn.xz);\n        } else if (absd.z > 62.0) {\n            noiseVal = fbm(0.02*lmn.xy);\n        }\n        \n        float modTime = mod(iTimeN, 12.0);\n        float dofull = 1.0 - step(0.64, abs(modTime-3.0));\n        float doempty = 1.0 - step(0.45, abs(modTime-9.0));\n\n        dNext = 2.0*pow(noiseVal, 3.0);\n        dNext = mix(dNext, 0.5, mix(0.0, 0.8, dofull));\n        dNext = mix(dNext, 0.0, mix(0.0, 0.8, doempty));\n        \n    } else {\n        vec3 dlmn = lmn - mid;\n            \n        float axisAng = 0.75*iTimeN;\n        vec3 nvAxis = normalize( vec3(cos(axisAng),0.0,sin(axisAng)) );\n        \n        mat3 mr = glRotate(nvAxis, 0.075*cos(iTimeN));\n        vec3 dlmnrot = mr * dlmn;\n        vec3 lmnrot = mid + dlmnrot;\n        \n        float mamt = -0.015;\n        vec3 next = mix(lmnrot, mid, mamt);\n\n    \tdNext = 1.04 * getDensityInterp( next );\n    }\n    \n    fragColor = vec4(0.5*nvNormal + 0.5, dNext);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 lmn;\n    int pageDst;\n    lmnFromVCube(rayDir, pageDst, lmn);\n\n    if (pageDst == 1) {\n        doPage1(fragColor, lmn);\n    } else {\n        discard;\n    }\n}\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 389, 389, 419], [421, 421, 476, 476, 1032], [1118, 1118, 1234, 1321, 1724], [1726, 1726, 1756, 1756, 1847], [1849, 1849, 1909, 1909, 2060], [2062, 2062, 2126, 2126, 2273], [2275, 2275, 2336, 2336, 4047], [4109, 4109, 4134, 4134, 4208], [4210, 4210, 4267, 4267, 5385]], "test": "untested"}
{"id": "WlVXDm", "name": "Day 71", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 27, "viewed": 708, "published": 3, "date": "1582929010", "time_retrieved": "2024-07-30T21:21:27.343286", "image_code": "// Fork of \"Day 48\" by jeyko. https://shadertoy.com/view/WtcSW4\n// 2020-02-28 11:33:26\n\n// HEX FUNCTION FROM BigWIngs !! he has a tutorial on this kind of tiling\n\n// There's too much noise on fullscreen\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 100.;\n    float scale = 0.00 + dot(uvn,uvn)*0.5;\n    float chromAb = dot(uvn,uvn)*13.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.001;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    fragColor = texture(iChannel0, uv)*0.1 + radial*1.5;\n    fragColor *= 0.7;\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\nvec3 glowF = vec3(0);\n    \n#define iTime (iTime + 10.)\n#define mx (iTime*4.9 + 20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n#define dmin(a, b) a.x < b.x ? a : b\n#define pmod(a,x) mod(a,x) - x*0.5\n\n#define pi acos(-1.)\n\n\nvec2 NOISE = vec2(0.);\nvec2 valueNoise(float p){\n\tvec2 a = texture(iChannel0, vec2(floor(p))/256.).xy;\n\tvec2 b = texture(iChannel0, vec2(floor(p) + 1.)/256.).xy;\n    return mix(a,b,smoothstep(0.,1.,fract(p)));\n}\n\nvec3 path(float z){\n    z *= 0.44;\n\treturn vec3(\n    \tsin(z + cos(z)*0.6),\n    \tcos(z + sin(z*0.8)*0.5),\n    \t0.\n    )*0.4;\n}\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1)/k,0.,1.);\n    return mix(d2, d1, h) - k*h*(1. - h);  \n}\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\n\nfloat modu;\nfloat moduB;\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    vec2 n = normalize(p.xy);\n    #define modDist 1.\n    #define tunnW 0.7\n    #define pipeW 0.04\n    \n    vec3 k = p;\n    float id = floor(p.z/modDist);\n    vec3 g = p;\n    p.z = pmod(p.z, modDist);\n    \n    vec3 o = p;\n    //p.xy *= rot(0.4 + p.z*(0.1 + sin(iTime*0.1) )+ iTime*0.3);\n    vec2 pC = vec2(atan(p.y,p.x), length(p.xy));\n    \n    vec3 q = vec3(pC, p.z);\n\n    vec4 hc = HexCoords(vec2(4.*pC.x/pi, p.z*2.)*1.);\n    \n    float dHex = hc.y - 0.02 + sin(o.z*100.)*0.01;\n    dHex = max(dHex, -length(o.xy*1.) + tunnW*0.8);\n    //dHex = max(dHex, length(o.xy*1.) - tunnW*0.97);\n    //d = dmin(d, vec2(dHex, 2.));    \n    \n    k = pmod(k, modDist*10.);\n    \n    float hcy = pmod(hc.y, 0.5);\n    float dThings = max(hcy - 0.06,  -hcy - 0.1);\n    dThings = max(dThings, -length(o.xy*1.1) + tunnW*0.8);\n    \n    dThings = max(dThings, -k.z - 0.25*modDist);\n    dThings = max(dThings, k.z - 0.25*modDist);\n    \n    //dThings = max(pmod());\n    if(mod(floor(4.*pC.x/ pi ), 2.) != 1.)\n    \td = dmin(d, vec2(dThings, 2.)); \n    \n    //hc.y += 0.03;\n    float dThingsB = max(hc.y - 0.03,  -hc.y - 0.1);\n    dThingsB = max(dThingsB, -length(o.xy*1.1) + tunnW*0.8);\n        \n        \n    pC.x += 0.25*pi;\n    if(mod(floor(4.*pC.x/ pi ), 2.) != 1.)\n    \td = dmin(d, vec2(dThingsB, 2.)); \n    \n    \n    // dots\n    \n    \n    // mod\n    float mm = sin(iTime*0.5 + g.z*0.5 + p.z);\n    modu = (mm/sqrt(0.02 + mm*mm ))*0.5 + 0.5;\n    float mmB = sin(iTime*1.25 + g.z*0.25 + p.z*0.8 + p.y);\n    moduB = (mmB/sqrt(0.01 + mmB*mmB ))*0.5 + 0.5;\n    \n    d = dmin(d, vec2(dHex, 2.));\n    glow += exp(-d.x*100.)*pal(1.3,0.7,vec3(1.8+modu*0.5,0.4,0.8), 3.9 +modu*0.2 + sin(p.z)*0.5,2.)*2.;\n    // tunnel\n    float dTunn = -length(o.xy*1.) + tunnW;\n    dTunn = max(length(o.xy*1.) - tunnW - 0.02, dTunn);\n    d = dmin(d, vec2(dTunn, 10.));\n    \n    \n    glowF += exp(-d.x*(10. + NOISE.x*200.9))*pal(1.39,0.7+ exp(-dThingsB*20.)*0.6,vec3(1.1+modu*0.5 ,0.4,0.8), 3.9 +modu*0.1 + sin(p.z)*0.5,2.)*2.;\n    \n    \n    \n    \n    pC.x += pi/3.5;\n    pC.x = pmod(pC.x, pi/1.);\n    pC.y -= 0.6;\n    pC = abs(pC) - vec2(0.05,0.15);\n    //d = dmin(d, vec2( max(pC.x, pC.y), 2.));\n    d.x *= 0.5;\n\treturn d;\n}\n\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\thit = false;\n    p = ro;\n    t = 0.;\n    vec2 d;\n    for(int i = 0; i < 180 ; i++){\n    \td = map(p);\n                    \n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n    float fov = 0.9;\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv,uv)*0.3;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += mx*1. ;\n    ro += path(ro.z);\n    vec3 lookAt = ro + vec3(0,0,4);\n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    ro.xyz += rd * texture(iChannel0, (uv+ iTime)*20.).xyz*0.7;\n    \n    NOISE = valueNoise(iTime*10.);\n    ro.xy += NOISE*0.025;\n    float t; bool hit;\n    vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        float fres = pow(1.0 - max(dot(n, -rd), 0.), 4.);\n        \n        col += fres*1.;\n        \n        \n    \tcol *= glow*(0.021 + sin(iTime*2. + t*0.6)*0.01);\n    }\n    \n    \n    col += glowF*0.1*smoothstep(0.,1., t*0.01);\n        \n    col *= 0.5;\n    //col = mix(col, vec3(0.1,0.4,0.3),pow(smoothstep(0.,1.,t*0.05), 2.)*0.56);\n    col = max(col, 0.);\n    col = pow(col,vec3(0.45));\n    \n    uv *= 0.8;\n    col *= 1. - dot(uv,uv);\n    //col *= 1. - t*0.2;    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 261, 261, 1223]], "test": "untested"}
{"id": "WtyXzG", "name": "Nexus XIII", "author": "quizcanners", "description": "Thanks to The Art of Code for a great tutorial ( https://www.youtube.com/watch?v=rvDo9LvfoVE ). I wanted to add clouds that partially block light from stars behind them. \n", "tags": ["music", "space", "stars", "nebula"], "likes": 43, "viewed": 2898, "published": 3, "date": "1582928112", "time_retrieved": "2024-07-30T21:21:28.184038", "image_code": "\nvoid layer (out vec4 col, in vec3 uv, in float zoom, in float music)\n{\n    \n    vec2 baseUv = uv.xy;\n    \n    uv.xy *= mix(1.2, 0.001, zoom);\n    \n    float deCenter = length(uv);\n    \n    deCenter = min(1., deCenter * deCenter);\n\n    vec2 smokeDin = vec2(-iTime + sin(uv.z*23.)*12.34, iTime + cos(uv.z*11.))*0.02;\n    \n    vec2 smokeUV = uv.xy;\n \n    float texC = texture(iChannel3, smokeUV*13.+ smokeDin.yx*0.5).r\n        \t\t*texture(iChannel3, smokeUV*15.*zoom*uv.y - smokeDin.yx*1.2).r*0.015;\n      \n    \n    float texA = (1.- texture(iChannel3, smokeUV*0.6 - texC * 0.5 + smokeDin*0.2).r);\n    \n    float texB = 1.-texture(iChannel3, smokeUV *  (1.-texA*0.1 + texC * 0.4 * (.5-texA)) + smokeDin*0.1).r;\n        \n   \n    texA *= (0.5 + texB)*0.25;\n\n    texA *= texA * 8.* zoom * zoom * (1.-col.a) * deCenter;\n    \n    \n    vec2 grid = uv.xy*10.;\n    \n     uv.xy = mod(grid,1.0);\n\n     grid -= uv.xy;\n    \n    uv.xy-=0.5;\n     \n    \n    vec4 add = vec4(0,0,0, texA);\n    \n    float depthMod = uv.z*0.123;\n    \n    float iTimeAndZoom = iTime + zoom;\n    \n    float cutMod = col.a * (64.) * music;\n    \n    float upscale =  (music * col.a * 20.);\n    \n    const float cuttingMod = 1.;\n    \n    float distMod =  (1. + texA* 50.  + cutMod)* max(0.1,  zoom - col.a*8.) ;\n        \n    for(int x=-1;x<=1;x++){\n    \tfor(int y=-1;y<=1;y++){\n        \n            vec2 dUv = uv.xy - vec2(x,y);\n            vec2 dGrid = grid + vec2(x,y);\n\n            vec3 vol = texture(iChannel2, vec3(dGrid.xy*0.1+depthMod, (dGrid.x + iTimeAndZoom)*0.003 )).rgb ;\n\n            float big = vol.b*vol.b * upscale;\n            \n            dUv += (vol.xy - .5)*1.5;\n            \n            \n          \n            // CIRCLES\n            // dUv += normalize(-dUv.xy) * 0.2 * music  * vol.b;\n            \n            \n            \n            \n            \n            float len = length(dUv) +0.0001;\n            \n            float dist = big * distMod/len; \n\n            \n            float cut = smoothstep(cuttingMod,.5,len);\n            \n            float ray = max(0., 1.-abs(dUv.x*dUv.y*300.))* cut * big;\n            \n            dist += ray;\n            \n            add.rgb +=  dist * cut * vol;\n    \t}\n     }\n\n   col += add * zoom * (1.-zoom);\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec3 noise =  texture(iChannel2, vec3(uv*123.123+iTime, iTime+uv.x*uv.y*543.21)).rgb;\n    \n    vec4 col = vec4(0,0,0,0);\n    \n     uv -= 0.5;\n    \n    vec2 M = (iMouse.xy - iResolution.xy * .5)/iResolution.y;\n    \n    uv += M;\n    \n    float aspect = iResolution.x/iResolution.y; \n    \n    uv.x*=aspect;\n        \n    \n    const float stepCnt = 5.;\n    const int steCntInt = 5;\n    const float oneStep = 1./stepCnt;\n    const float SPEED = 0.02;\n    \n    float zoom = iTime*SPEED;\n    \n    float index = floor(mod(zoom, 1.)*stepCnt);\n    \n    zoom = mod(zoom, oneStep);\n    \n    float off = 0.;\n    \n    float music = 0.;  \n    \n    for(int i=0;i<steCntInt;i++){\n        \n        float totalZoom = zoom + off;\n        \n        music = texture(iChannel0, vec2(mix(0.01, 0.8, totalZoom),0.05)).x;\n\n        // for Unseen: smoothstep(0.01,.4, music);    \n        music = smoothstep(-.2,1., music);\n        \n    \tlayer(col, vec3(uv.xy,index), totalZoom, music);\n    \toff += oneStep;\n        index = mod(index-1., stepCnt);\n    \t\n    }    \n    \n    col.rgb*=vec3(0.5,0.9,1) * 5. * oneStep;\n    \n    vec3 mixing = col.gbr+col.brg;\n    \n    col.rgb+= mixing * mixing * 0.1;\n    \n    col.rgb += noise*col.rgb*0.15;\n\n    //col = clamp(col,0.,1.);\n    \n    fragColor = vec4(col.rgb,1.0);\n}\n", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 71, 71, 2237], [2239, 2239, 2296, 2296, 3620]], "test": "untested"}
{"id": "WtySzG", "name": "Simple Gaussian Blur", "author": "carnefrisca", "description": "A simple fast gaussian blur", "tags": ["gaussianblur"], "likes": 2, "viewed": 362, "published": 3, "date": "1582921126", "time_retrieved": "2024-07-30T21:21:29.016811", "image_code": "vec4 toGrayscale(in vec4 color)\n{\n   float average = (color.r + color.g + color.b) / 3.0;\n   return vec4(average, average, average, 1.0);\n}\n\nvec4 colorize(in vec4 grayscale, in vec4 color)\n{\n    return (grayscale * color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Change the direction value to modify the blur. Vec2(0,0) disable blur.\n    vec2 direction = vec2(2.0,2.0);\n    \n    vec2 resolution = iResolution.xy;\n\n    vec4 color = vec4(0.0);\n    vec2 offset1 = vec2(1.3846153846) * direction;\n    vec2 offset2 = vec2(3.2307692308) * direction;\n    vec4 colorA = vec4(1.0,1.0,1.0, 1.0);       \n    \n    color += texture(iChannel0, uv) * 0.2270270270;\n    color += texture(iChannel0, uv + (offset1 / resolution)) * 0.3162162162;\n    color += texture(iChannel0, uv - (offset1 / resolution)) * 0.3162162162;\n    color += texture(iChannel0, uv + (offset2 / resolution)) * 0.0702702703;\n    color += texture(iChannel0, uv - (offset2 / resolution)) * 0.0702702703;\n\n    // Convert to grayscale first:\n  \tvec4 grayscale = toGrayscale(color);\n\n    // Then \"colorize\" by simply multiplying the grayscale\n    // with the desired color.\n    vec4 colorizedOutput = colorize(grayscale, colorA);\n    \n    fragColor = colorizedOutput;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 139], [141, 141, 190, 190, 224], [226, 226, 283, 283, 1298]], "test": "untested"}
{"id": "3lGXRG", "name": "knot 3 - macram", "author": "FabriceNeyret2", "description": "base knot made with 3 torus sections * 2 symmetries. Then more symmetries to tile the plane.\n\nmouse controls camera.", "tags": ["raymarching", "sdf", "short", "macrame"], "likes": 14, "viewed": 345, "published": 3, "date": "1582915424", "time_retrieved": "2024-07-30T21:21:29.809691", "image_code": "// variant of https://shadertoy.com/view/3tGXRG\n// variant of https://shadertoy.com/view/ttKSDm\n\nfloat PI = 3.14159,\n       r = .16;                                 // rope radius\n#define FRAME 0\n\n#define T(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r )        // torus\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n\nfloat knot(vec3 p) {                           // --- quarter of knot\n    vec3 q; float t;\n    q = p, q.xz *= R(PI/4.), t = Ts(q,PI/4.,PI/4.),\n    q = p, q.xz *= R(-.75*PI), q.yz *= R(-.2*PI), q-=vec3(0,-.19,-.59), t = min(t,Ts(q,3.*PI/8.,PI/8.)),\n    q = p.yzx, q.xz *= R(.75*PI), q.yz *= R(-PI), q-=vec3(-1,-1,0)+vec3(-.0,-.31,-.8), t = min(t,Ts(q,PI/8.,PI/8.)),\n  //q = p-vec3(-.57,.55,0), t = min(t, max( length(q.xy)-r, -(q.z-1.3)) ); // straight part\n    q = p, q.yz*=R(.1), q-=vec3(-.57,.41,0), t = min(t, max( length(q.xy)-r, -(q.z-1.35)) ); // straight part\n    return t;   \n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9,tx,ty,tz, d=3.15; // 2.25\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)), // ray direction\n          P = 32./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P, \n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        p.y += d/2.*floor((p.z+2.)/9.),\n        p.z = mod(p.z+2.,9.)-2.,               // reverse-duplicate knots along wires\n        p.z = min(p.z,4.5-p.z),\n        p.y = mod(p.y+d/2.,d) - d/2.,           // duplicate parallel wires\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // left-right symmetry\n        t = min(t, knot(p*vec3(1, -1, 1))),\n        p -= vec3(-.4,0,1),\n        p = -p,                                // top-down symmetry\n        t = min(t, knot(p)),\n        t = min(t, knot(p*vec3(1, -1, 1))),\n        P += t*D;                              // step forward = dist to obj\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 511, 531, 580, 1096]], "test": "untested"}
{"id": "3tGXRG", "name": "knot 2", "author": "FabriceNeyret2", "description": "base knot made with 3 torus sections * 2 symmetries. Then more symmetries to tile the plane.\n\nmouse controls camera.", "tags": ["raymarching", "sdf", "short", "macrame"], "likes": 8, "viewed": 326, "published": 3, "date": "1582914770", "time_retrieved": "2024-07-30T21:21:30.588609", "image_code": "// variant of https://shadertoy.com/view/ttKSDm\n\nfloat PI = 3.14159,\n       r = .16;                                // rope radius\n#define FRAME 0\n\n#define T(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r )        // torus\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n\nfloat knot(vec3 p) {                           // --- quarter of knot\n    vec3 q; float t;\n    q = p, q.xz *= R(PI/4.), t = Ts(q,PI/4.,PI/4.),\n    q = p, q.xz *= R(-.75*PI), q.yz *= R(-.2*PI), q-=vec3(0,-.19,-.59), t = min(t,Ts(q,3.*PI/8.,PI/8.)),\n    q = p.yzx, q.xz *= R(.75*PI), q.yz *= R(-PI), q-=vec3(-1,-1,0)+vec3(-.0,-.31,-.8), t = min(t,Ts(q,PI/8.,PI/8.)),\n    q = p-vec3(-.57,.55,0), t = min(t, max( length(q.xy)-r, -(q.z-1.3)) ); // straight part\n    return t;   \n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9,tx,ty,tz, d=3.;\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)), // ray direction\n          P = 32./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P, \n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        p.z = mod(p.z+2.,9.)-2.,               // reverse-duplicate knots along wires\n        p.z = min(p.z,4.5-p.z),\n        mod(p.y/d+.5,2.) > 1. ? p.z = -p.z : t,// reverse side ( NB: cause a glitch )\n        p.y = mod(p.y+d/2.,d) - d/2.,          // duplicate parallel wires\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // left-right symmetry\n        t = min(t, knot(p*vec3(1, -1, 1))),\n        p -= vec3(-.4,0,1),\n        p = -p,                                // top-down symmetry\n        t = min(t, knot(p)),\n        t = min(t, knot(p*vec3(1, -1, 1))),\n        P += t*D;                              // step forward = dist to obj\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 482, 531, 937]], "test": "untested"}
{"id": "ttKSDm", "name": "knot", "author": "FabriceNeyret2", "description": "made with 3 torus sections * 2 symmetries \n\nmouse controls camera.", "tags": ["raymarching", "sdf", "short"], "likes": 10, "viewed": 375, "published": 3, "date": "1582912818", "time_retrieved": "2024-07-30T21:21:31.349574", "image_code": "float PI = 3.14159,\n       r = .16;                                // rope radius\n#define FRAME 0\n\n#define T(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r )        // torus\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n\nfloat knot(vec3 p) {                           // --- quarter of knot\n    vec3 q; float t;\n    q = p, q.xz *= R(PI/4.), t = Ts(q,PI/4.,PI/4.),\n    q = p, q.xz *= R(-.75*PI), q.yz *= R(-.2*PI), q-=vec3(0,-.19,-.59), t = min(t,Ts(q,3.*PI/8.,PI/8.)),\n    q = p.yzx, q.xz *= R(.75*PI), q.yz *= R(-PI), q-=vec3(-1,-1,0)+vec3(-.0,-.31,-.8), t = min(t,Ts(q,PI/8.,PI/8.)),\n  //q = p-vec3(-.57,.55,0), t = min(t, max( length(q.xy)-r, -(q.z-1.3)) ); // straight part\n    q = p, q.yz*=R(.1), q-=vec3(-.57,.41,0), t = min(t, max( length(q.xy)-r, -(q.z-1.35)) ); // straight part with angle\n    return t;   \n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9,tx,ty,tz;\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),     // ray direction\n          P = 10./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P,\n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // left-right symmetry\n        t = min(t, knot(p*vec3(1, -1, 1))),\n        p -= vec3(-.4,0,1),\n        p = -p,                                // top-down symmetry\n        t = min(t, knot(p)),\n        t = min(t, knot(p*vec3(1, -1, 1))),\n        P += t*D;                              // step forward = dist to obj\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 433, 482, 1009]], "test": "untested"}
{"id": "3tGSWh", "name": "Apollonian Zoom III", "author": "mla", "description": "Another Apollonian zoom. Various keys to play with, see code for more info.", "tags": ["zoom", "apollonian"], "likes": 17, "viewed": 469, "published": 3, "date": "1582905542", "time_retrieved": "2024-07-30T21:21:32.169382", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian circles. Iterated inversion in a pattern of circles.\n//\n// Pattern is a K-prism on the Riemann sphere.\n// Generates the dual pattern, a K-bipyramid.\n//\n// <mouse>: centre of inversion\n// <up>/<down>: scale image (when not zooming)\n// c: show circles or iteration steps\n// i: invert image\n// l: show limit set\n// u: invert around mouse position\n// x: show inverting circles\n// z: do zoom\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int K = 5; // 5-prism by default\nconst float AA = 2.0; // Set to 1.0 for better performance.\nconst int NSTEPS = 20;\n\nconst float PI = 3.14159265;\n\nbool check = false;\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_I = 73;\nconst int CHAR_L = 76;\nconst int CHAR_U = 85;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec4 circles2[K+2];\nvec4 circles3[2*K];\n\nvoid initCircles() {\n  // half angle between circle centres\n  float theta = PI/float(K);\n  // d is distance of circle centre from origin\n  float d = 1.0/(1.0+sin(theta));\n  // radius of circle, radius of inner tangent circle\n  float r = 1.0-d, s = d-r;\n  // scale of complementary set of circles\n  float k = d*cos(theta)/(d-r);\n  float r2 = r*r, k2 = k*k, s2 = s*s;\n  circles2[K+1] = vec4(0,0,k2,-1);\n  for (int i = 0; i<K; i++) {\n    float t = 2.0*float(i)*theta+0.0*iTime;\n    circles2[i+1] = vec4(k*d*sin(t+theta),k*d*cos(t+theta),k2*r2,1);\n    circles3[i] = vec4(d*sin(t),d*cos(t),r2,1);\n    circles3[K+i] = vec4(k2*d*sin(t),k2*d*cos(t),k2*k2*r2,1);\n  }\n  circles2[0] = vec4(0,0,k2*s2,1);\n}\n\nfloat length2(vec2 p) {\n  return dot(p,p);\n}\n\n// Note that a circle may be \"inverted\" so the inside is\n// treated as the outside (indicated by c.w < 0.0)\nbool inside(vec2 p, vec4 c) {\n  float r2 = length2(p-c.xy);\n  if (c.w < 0.0) return r2 > c.z;\n  else return r2 <= c.z;\n}\n\n// Invert p in circle c, keeping track of conformal scale factor.\nvec2 invert(vec2 p, vec4 c, inout float scale) {\n  p -= c.xy;\n  float s = c.z/dot(p,p);\n  scale *= abs(s);\n  p *= s;\n  p += c.xy;\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  initCircles();\n  vec2 z0 = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  bool dozoom = !keypress(CHAR_Z);\n  float zoom = !dozoom ? 1.2*exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))) \n      : exp(30.0-mod(iTime,50.0));\n  // Transform to put centre at m, but preserve the unit circle\n  vec2 m = iMouse.x <= 0.0 ? vec2(-0.8,-0.5)\n    : (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  vec4 tcircle;\n  if (m != vec2(0)) {\n    m *= zoom;\n    if (!keypress(CHAR_U)) {\n      m /= dot(m,m); // m inverted in unit circle\n      tcircle = vec4(m,dot(m,m)-1.0,0);\n    } else {\n      // Inversion in unit circle\n      tcircle = vec4(m,1,0);\n    }\n  }\n \n  fragColor = vec4(0);\n\n  float aadelta = 1.0/(AA*iResolution.y);\n\n  for (float p = 0.0; p < AA; p++) {\n    for (float q = 0.0; q < AA; q++) {\n      vec2 z = z0 + aadelta*vec2(p,q);\n      z *= zoom;\n      float scale = zoom;\n      if (!keypress(CHAR_I)) {\n        if (m != vec2(0)) {\n          z = invert(z,tcircle,scale);\n          z.x = -z.x;\n        } else {\n          float t = 1.41*cos(0.2*iTime);\n          z = invert(z,vec4(0,t,1,1),scale);\n          z.x = -z.x;\n        }\n      }\n        \n      int step;\n      for (step = 0; step < NSTEPS; step++) {\n        bool found = false;\n        for (int i = 0; i < 1000; i++) {\n          if (i == K+2) break;\n          vec4 c = circles2[i];\n          if (inside(z,c)) {\n            z = invert(z,c,scale);\n            found = true;\n            break;\n          }\n        }\n        if (!found) break;\n      }\n      vec3 col = vec3(0);\n      {\n        float dmin = 1e10;\n        int imin = -1;\n        for (int i = 0; i < 2*K; i++) {\n          vec4 c = circles3[i];\n          float d = abs(length(z-c.xy) - sqrt(c.z));\n          d /= scale;\n          if (inside(z,c)) {\n            dmin = d;\n            imin = i;\n            break;\n          }\n        }\n        if (imin >= 0) {\n          if (keypress(CHAR_C)) {\n            col = hsv2rgb(vec3(float(2*step)/float(NSTEPS),0.8,0.8));\n          } else {\n            col = hsv2rgb(vec3(0.0*iTime+float(imin)/float(K+1),0.8,0.8));\n          }\n        }\n        if (!keypress(CHAR_L)) col *= smoothstep(0.0,0.003,dmin);\n      }\n\n      float dmin = 1e10;\n      for (int i = 0; i < K+1; i++) {\n        vec4 c = circles2[i];\n        float d = abs(length(z-c.xy) - sqrt(c.z));\n        d /= scale;\n        if (d < dmin) dmin = d;\n      }\n      if (!keypress(CHAR_X)) {\n        float lwidth = max(0.003,2.0/iResolution.y); \n        col = mix(col,vec3(0),0.3*smoothstep(0.0,lwidth,dmin));\n      }\n      fragColor.xyz += col;\n    }\n  }\n  fragColor.xyz /= AA*AA;\n  if (check) fragColor.x = 1.0;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[744, 839, 864, 864, 1040], [1042, 1042, 1067, 1067, 1127], [1129, 1129, 1154, 1154, 1202], [1204, 1204, 1227, 1227, 1259], [1489, 1489, 1509, 1548, 2183], [2185, 2185, 2208, 2208, 2229], [2231, 2339, 2368, 2368, 2459], [2461, 2527, 2575, 2575, 2670], [2672, 2672, 2728, 2728, 5364]], "test": "untested"}
{"id": "WtKXDw", "name": "Business Card Raytracer", "author": "mla", "description": "Just so no one else has to do this...\n\nPort of Andrew Kensler's Business Card Shader, as dissected by Fabien Sanglard: [url]http://fabiensanglard.net/rayTracing_back_of_business_card/index.php[/url]\n\nJust 4 rays cast per pixel.\n", "tags": ["businesscard"], "likes": 13, "viewed": 521, "published": 3, "date": "1582897240", "time_retrieved": "2024-07-30T21:21:33.033073", "image_code": "int[] G=int[](74895,74897,74897,74895,74881,74881,55438,128,128); int s;float R(\n){s*=2654289789; return float(s)/4294967296.0;} int T(vec3 o,vec3 d,out float t, \nout vec3 n){t=1e9;int m=0; float p=-o.z/d.z; if(0.01<p)t=p,n=vec3(0,0,1),m=1;for\n(int k=17;bool(k--);)for(int j=9;bool(j--);)if(bool(G[j]&1<<k)){vec3 p=o+vec3(-k\n,0,-j-4); float b=dot(p,d),c=dot(p,p)-1.0,q=b*b-c; if(q>0.0){ float s=-b-sqrt(q)\n; if(s<t&&s>.01) t=s,n=normalize(p+d*t),m=2;}} return m;} vec3 S(vec3 o,vec3 d){\nvec3 c=vec3(0);float a=1.;for(int k=0;k<3;k++){float t;vec3 n; int m=T(o,d,t,n);\nif(m==0) return vec3(0.7,0.6,1.0)*pow(1.0-d.z,4.); vec3 h=o+d*t,l=normalize(vec3\n(9.0+R(),9.0+R(),16.0)+-h),r=d+n*(dot(n,d)*-2.0); float b=dot(l,n); if(b<0.0||T(\nh,l,t,n)!=0)b=0.0; float p=pow(dot(l,r)*float(b>0.),99.); if(bool(m&1)){h=h*0.2;\nreturn((int(ceil(h.x)+ceil(h.y))&1)!=0?vec3(3,1,1):vec3(3))*(b*0.2+0.1);}c+=vec3\n(p)*a,a*=0.5,o=h,d=r;} return c;}void mainImage(out vec4 O,vec2 C) {vec3 o=15.0*\nvec3(sin(iTime),cos(iTime),0.8+.7*cos(.321*iTime)),g=normalize(vec3(9,0,5)-o),a=\nnormalize(cross(vec3(0,0,1),g))*.002,b=normalize(cross(g,a))*.002,c=(a+b)*-256.+\ng;s=int(1000.*C.x+C.y); vec2 q=vec2(0.6*iResolution.x-C.x,C.y)*512./iResolution.\ny;vec3 p=vec3(13); for(int r=4;bool(r--);){vec3 t=(a*(R()-.5)+b*(R()-.5))*50.0;p\n+=S(o+t,normalize(-t+(a*(R()+q.x)+b*(q.y+R())+c)*16.0))*56.0;}O=vec4(p/255.,0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 83, 83, 128], [129, 129, 175, 175, 463], [925, 925, 960, 960, 1377]], "test": "untested"}
{"id": "tlKXWw", "name": "Irradiance Mapping, SH L1", "author": "4rknova", "description": "L1 Spherical Harmonics evaluation for Grace Cathedral", "tags": ["irradiance", "probe"], "likes": 1, "viewed": 742, "published": 3, "date": "1582893916", "time_retrieved": "2024-07-30T21:21:34.094236", "image_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPSILON\t\t\t\t0.0001\n#define EPSILON_M\t\t\t0.1\n#define PI\t\t\t\t\t3.14159265359\n#define PI2\t\t\t\t\tPI * 0.5\n#define RADIAN\t\t\t\t180.0 / PI\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is Grace Cathedral.\nconst vec3 _SH[4] = vec3[](\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 )\n);\n\n// Implementation from https://patapom.com/blog/SHPortal/\n// Evaluates the irradiance perceived in the provided direction\n// Analytic method from http://www1.cs.columbia.edu/~ravir/papers/envmap/envmap.pdf eq. 13\nvec3 Evaluate(vec3 dir) {\n    const float c1 = 0.42904276540489171563379376569857;\n    const float c2 = 0.51166335397324424423977581244463;\n    const float c3 = 0.24770795610037568833406429782001;\n    const float c4 = 0.88622692545275801364908374167057;\n    \n    return  max(vec3(0.0), \n        +  c4 * _SH[0]                                                                           //   c4  L00 \n        +  c2 * 2.0 * (_SH[3] * dir.x + _SH[1]* dir.y + _SH[2]* dir.z)                           // 2 c2 (L11 x + L1-1 y + L10 z)\n    );\n}\n\nvec3 sph2dir(vec2 p)\n{\n    vec2 s = (p*2.-1.) * vec2(PI,PI * 0.5); // Spherical coords\n    vec4 t = vec4(sin(s), cos(s));       // Precalculated sin/cos values\n    return t.zyx * vec3(t.w, 1, t.w);    // Conversion to direction\n}\n\nvec3 Unwrap(vec2 uv)\n{\n    vec3 d = sph2dir(uv);\n    return Evaluate(d);\n}\n\n// ****************************************************************\n// Ray marching\n// ****************************************************************\n\n#define RMARCH_MAX_STEPS \t64\n#define CLEAR_COLOR\t\t\tvec3(0.2)\n\nfloat des_sphere(vec3 p, float r) { return length(p) - r; }\nvec3  translate (vec3 v, vec3  t) { return v - t; }\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, Camera c, out Ray r)\n{\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\nfloat scene_distance(vec3 p)\n{\n\treturn des_sphere(translate(p, vec3(0)), 1.0);\n}\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z));\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z));\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 p, vec3 n)\n{\n\treturn Evaluate(n);\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos);\n\n\t\tif (d < EPSILON) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\t\n\treturn d < EPSILON;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 nv = (fragCoord.xy / iResolution.xy);\t\n    \n    vec3 col = CLEAR_COLOR;\n    \n    float mode = mod(floor(iTime*.5), 2.0);\n    \n    if (mode == 1.0) {\n        col = Unwrap(nv);\n    }\n    else\n    {\n        vec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n        \t    * vec2(iResolution.x / iResolution.y, 1);\t\n   \n\t\tCamera c;\n\t\tc.p = vec3(cos(iTime) * 4.0, 0, sin(iTime) * 4.0);\n\t\tc.t = vec3(0, 0, 0);\n\t\tc.u = vec3(0, 1, 0); \n   \n\t\n\t\tRay r;\n\t\tgenerate_ray(uv, c, r);\n\t\n\t\tvec3 sp, sn;\n\t\tint iter = RMARCH_MAX_STEPS;\t\n\t\tbool res = rmarch(r, sp, sn, iter);\n\t\n    \n        if (res) {\n            col = scene_shade(sp, sn);    \n        }\n    }\n\t\n \n\tfragColor = vec4(col + Text(iResolution.xy, fragCoord), 1.0);\n}", "image_inputs": [], "common_code": "// Font rendering based on FlyGuy's shader: https://www.shadertoy.com/view/llSGRm\n#define FONTSC_SZ vec2(2.5, 5)     // Font size\n#define SCREEN_SZ vec2(800, 600) // Screen size\n#define CHR       vec4(6,7,6.*FONTSC_SZ.x,9.*FONTSC_SZ.y)  // Character size (xy), spacing(zw)\n#define STR_SZ(c) vec2(c*CHR.zw) // String size\n#define DWN_SC    2.             // Downscale\n\n#define C vec2\nC c_spc = C(      0,      0), c_exc = C( 276705,  32776), c_quo = C(1797408,      0)\n, c_hsh = C(  10738,1134484), c_dol = C( 538883,  19976), c_pct = C(1664033,  68006)\n, c_amp = C( 545090, 174362), c_apo = C( 798848,      0), c_lbr = C( 270466,  66568)\n, c_rbr = C( 528449,  33296), c_ast = C(  10471,1688832), c_crs = C(   4167,1606144)\n, c_per = C(      0,   1560), c_dsh = C(      7,1572864), c_com = C(      0,   1544)\n, c_lsl = C(   1057,  67584), c_0   = C( 935221, 731292), c_1   = C( 274497,  33308)\n, c_2   = C( 934929,1116222), c_3   = C( 934931,1058972), c_4   = C( 137380,1302788)\n, c_5   = C(2048263,1058972), c_6   = C( 401671,1190044), c_7   = C(2032673,  66576)\n, c_8   = C( 935187,1190044), c_9   = C( 935187,1581336), c_col = C(    195,   1560)\n, c_scl = C(    195,   1544), c_les = C( 135300,  66052), c_equ = C(    496,   3968)\n, c_grt = C( 528416, 541200), c_que = C( 934929,1081352), c_ats = C( 935285, 714780)\n, c_A   = C( 935188, 780450), c_B   = C(1983767,1190076), c_C   = C( 935172, 133276)\n, c_D   = C(1983764, 665788), c_E   = C(2048263,1181758), c_F   = C(2048263,1181728)\n, c_G   = C( 935173,1714334), c_H   = C(1131799,1714338), c_I   = C( 921665,  33308)\n, c_J   = C(  66576, 665756), c_K   = C(1132870, 166178), c_L   = C(1065220, 133182)\n, c_M   = C(1142100, 665762), c_N   = C(1140052,1714338), c_O   = C( 935188, 665756)\n, c_P   = C(1983767,1181728), c_Q   = C( 935188, 698650), c_R   = C(1983767,1198242)\n, c_S   = C( 935171,1058972), c_T   = C(2035777,  33288), c_U   = C(1131796, 665756)\n, c_V   = C(1131796, 664840), c_W   = C(1131861, 699028), c_X   = C(1131681,  84130)\n, c_Y   = C(1131794,1081864), c_Z   = C(1968194, 133180), c_lsb = C( 925826,  66588)\n, c_rsl = C(  16513,  16512), c_rsb = C( 919584,1065244), c_pow = C( 272656,      0)\n, c_usc = C(      0,     62), c_a   = C(    224, 649374), c_b   = C(1065444, 665788)\n, c_c   = C(    228, 657564), c_d   = C(  66804, 665758), c_e   = C(    228, 772124)\n, c_f   = C( 401543,1115152), c_g   = C(    244, 665474), c_h   = C(1065444, 665762)\n, c_i   = C( 262209,  33292), c_j   = C( 131168,1066252), c_k   = C(1065253, 199204)\n, c_l   = C( 266305,  33292), c_m   = C(    421, 698530), c_n   = C(    452,1198372)\n, c_o   = C(    228, 665756), c_p   = C(    484, 667424), c_q   = C(    244, 665474)\n, c_r   = C(    354, 590904), c_s   = C(    228, 114844), c_t   = C(   8674,  66824)\n, c_u   = C(    292,1198868), c_v   = C(    276, 664840), c_w   = C(    276, 700308)\n, c_x   = C(    292,1149220), c_y   = C(    292,1163824), c_z   = C(    480,1148988)\n, c_lpa = C( 401542,  66572), c_bar = C( 266304,  33288), c_rpa = C( 788512,1589528)\n, c_tid = C( 675840,      0), c_lar = C(   8387,1147904);\n\nvec2 carret = vec2(0);\n\n// Returns the digit sprite for the given number.\nvec2 digit(float d) {    \n    vec3 r = vec3(0, 0, floor(d));\n         if (r.z == 0.) r.xy = c_0; else if (r.z == 1.) r.xy = c_1;\n    else if (r.z == 2.) r.xy = c_2; else if (r.z == 3.) r.xy = c_3;\n    else if (r.z == 4.) r.xy = c_4; else if (r.z == 5.) r.xy = c_5;\n    else if (r.z == 6.) r.xy = c_6; else if (r.z == 7.) r.xy = c_7;\n    else if (r.z == 8.) r.xy = c_8; else if (r.z == 9.) r.xy = c_9;\n    return r.xy;\n}\n// Extracts bit\nfloat bit(float n, float b) {\n    b = clamp(b,-1.,22.);\n    return floor(mod(floor(n / pow(2.,floor(b))),2.));\n}\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat spr(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv/ FONTSC_SZ);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float b = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? bit(spr.x, b - 21.0) + bit(spr.y, b) : 0.0;\n}\n// Prints a character and moves the carret forward by 1 character width.\nfloat print_char(vec2 ch, vec2 uv) { \n    float px = spr(ch, CHR.xy, uv - carret);\n    carret.x += CHR.z;\n    return px;\n}\n// Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.;\n    \n\tfor(int i = 3; i >= -2; --i) {\n        //Clip off leading zeros.\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0);        \n        float d = mod(number / pow(10., float(i)),10.);\n        \n        if(i == -1) {\n            result += spr(c_per,CHR.xy, uv - dec_pos) * clip;\n            dec_pos.x += CHR.z * clip;\n        }\n        \n        result += spr(digit(d),CHR.xy, uv - dec_pos) * clip;\n        dec_pos.x += CHR.z * clip;\n    }\n    \n    return result;\n}\n\n#define T(x) print_char(x,uv)\nfloat Text(vec2 resolution, vec2 uv)\n{    \n    vec2 res = resolution / DWN_SC,\n         pos = vec2(10,20.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_L) + T(c_1) + T(c_spc) + T(c_S) + T(c_H);\n    \n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[640, 853, 878, 878, 1389], [1391, 1391, 1413, 1413, 1620], [1622, 1622, 1644, 1644, 1696], [1913, 1913, 1948, 1948, 1972], [1973, 1973, 2008, 2008, 2024], [2122, 2122, 2171, 2171, 2509], [2511, 2511, 2541, 2541, 2591], [2593, 2593, 2631, 2631, 2905], [2907, 2907, 2941, 2941, 2964], [2966, 2966, 3024, 3024, 3274], [3276, 3276, 3331, 3331, 4050]], "test": "untested"}
{"id": "WlKXDm", "name": "Slope: GGX Isotropic", "author": "H4w0", "description": "GGX / Trowbridge Reitz : slope distribution function", "tags": ["microfacet", "ggx", "ndf", "isotropic"], "likes": 5, "viewed": 609, "published": 3, "date": "1582887422", "time_retrieved": "2024-07-30T21:21:35.225212", "image_code": "//=======================================================\n//= Slope Distribution Function : GGX Isotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Remapping : \n//== *- roughness \t-> alpha = clamp(0.1+uiSlider(0),0.,0.8 )^2;\n//== *- metallic \t-> 0 or 1\n//== *- reflectance used for non-metallic F0 (Filament)\n//==    -> F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n//=======================================================\n//== Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- NDFs are expressed using the slope distribution functions P22\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Some equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//== *- Checked P22() and D() by numerical integration\n//==    Checked Lambda with the Weak White Furnace Test\n//=======================================================\n//== Using some wonderful ressources on BRDFs/NDFs/Masking :\n//== *- Xavier Chermain's thesis (FR): https://tel.archives-ouvertes.fr/tel-02446425/document\n//== *- Jonathan Dupuy's thesis  (EN): https://hal.archives-ouvertes.fr/tel-01291974v2/document\n//== *- Eric Heitz's thesis \t (FR): https://tel.archives-ouvertes.fr/tel-01073518v2/document\n//== *- Eric Heitz : Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\n//== \t(PDF + SLIDES) : http://jcgt.org/published/0003/02/03/ \n//== *- PBRT (book : http://www.pbr-book.org/ | code : https://github.com/mmp/pbrt-v3/ )\n//== *- Filament documentation : https://google.github.io/filament/Filament.html\n//== *- Self Shadow blog : https://blog.selfshadow.com/\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst bool  USE_DIFFUSE_TERM = true;\n\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_GREY = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- GGX Distribution ---------------------------------------------------------\nfloat p22_ggx_isotropic(float x, float y, float alpha)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float alpha_sqr = alpha*alpha;\n    float denom = ( 1. + (x_sqr/alpha_sqr) + (y_sqr/alpha_sqr) ); \n    return( \n                            1.\n    / //--------------------------------------------------\n           (( m_pi * alpha_sqr) * (denom*denom))\n    );\n}\n\nfloat ndf_ggx_isotropic(vec3 omega_h, float alpha)\n{\n    float slope_x = - omega_h.x / omega_h.z;\n    float slope_y = - omega_h.y / omega_h.z;\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float ggx_p22 = p22_ggx_isotropic(slope_x,slope_y,alpha);\n    return(\n                  ggx_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_ggx_isotropic(vec3 omega, float alpha)\n{\n    float a = 1. / (alpha * tan_theta(omega));  \n    return( (-1. + sqrt(1.+1./(a*a))) * 0.5 ); \n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_GREY; }\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        mat3 TBN    = orthonormal_basis(N);\n        mat3 TBN_t  = transpose(TBN);\n        vec3 wo = normalize(TBN_t * V);\n        vec3 wi = normalize(TBN_t * L);\n        vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n        vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n        \n        float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n        float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n                     \n        //-- Filament BRDF parametrization\n        //-- Single scattering\n        //-- diffuse lambertian term + specular term\n        float reflectance \t= clamp(uiSlider(1),0.35,1.); \t// [0.35;1]\n        float metallic \t\t= float(uiSlider(2)>0.5); \t\t// 0. or 1.\n        float roughness \t= clamp( 0.1 + uiSlider(0), 0., 0.8);\n    \tfloat alpha \t\t= roughness*roughness;\n        vec3  base_color    = uiColor(0);\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n              \n        //-- NDF + G + F\n        float lambda_wo = lambda_ggx_isotropic(wo,alpha);\n        float lambda_wi = lambda_ggx_isotropic(wi,alpha);\n        float D = ndf_ggx_isotropic(wh,alpha);\n        float G = 1. / (1. + lambda_wo + lambda_wi);\n        \n     \n\t\tvec3 F  = fresnel_schlick(wi_dot_wh,F0);\n        \n        //-- Lighting\n        vec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;\n        vec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n        vec3 diffuse_factor  = vec3(1.)-F; \n        if(!USE_DIFFUSE_TERM){diffuse_lambert = vec3(0.);}\n        \n        color = wg_dot_wi * get_light_intensity() * (diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n\n    fragColor = vec4( render(ro,rd) , 1.);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n    \n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */\nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;            \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n", "buffer_a_code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(20,30) _G _G _X _spc _I _s _o _t _r _o _p _i _c\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.2) _R _o _u _g _h _n _e _s _s \n    _box(vec2(15,iResolution.y-70.),vec2(150,3),vec4(1.))\n        \n    _slider(24,95, 1, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,125, 2, 1.0) _M _e _t _a _l \n        \n    _color(24,155, 0, vec3(1.000,0.782,0.344)) _C _o _l _o _r\n        \n    _box(vec2(10,iResolution.y-165.),vec2(160,155),vec4(vec3(0.2),.25))\n        \n    fragColor = min(col.rgba,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3686, 3846, 3902, 3902, 4211], [4213, 4213, 4265, 4265, 4668], [4670, 4670, 4723, 4723, 4822], [4825, 4985, 5039, 5039, 5094], [5096, 5256, 5297, 5297, 5323], [5324, 5324, 5364, 5364, 5390], [5391, 5391, 5431, 5431, 5457], [5459, 5754, 5779, 5779, 5847], [5848, 5848, 5872, 5872, 5942], [5944, 6106, 6143, 6143, 8179], [8181, 8341, 8398, 8398, 9034]], "test": "untested"}
{"id": "3tKXWm", "name": "Surface Forces", "author": "wyatt", "description": "Finally!!!!!! YAYAYYAY This was never conservative in past attempts! ", "tags": ["fluid"], "likes": 28, "viewed": 633, "published": 3, "date": "1582863619", "time_retrieved": "2024-07-30T21:21:36.160711", "image_code": "// Fork of \"Last Fluid\" by wyatt. https://shadertoy.com/view/3tcSDj\n// 2020-02-28 04:10:38\n\nfloat ln (vec3 p, vec3 a, vec3 b) {return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));}\nMain {\n    vec4 b = B(U);\n    Neighborhood;\n    vec3 no = normalize(vec3(grd,.01)),\n        re = reflect(no,vec3(0,0,1));\n    Q = atan(max(vec4(b.x,0.3*abs(b.x),-b.x,1),0.)*5.);//0.5+0.5*sin(min(10.*b.x,1.)/3.+vec4(1,2,3,4));\n\n    Q *= 0.25+exp(-.01*ln(0.5*R.xyy,vec3(U,b.x),vec3(U,b.x)+re));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fluid step 1 : d/dt V = d/dx P\n\nMain {\n    \n    float f = A(U).x;\n\tQ = B(U-B(U).xy);\n    Neighborhood;\n    Q.xy -= grd/(-f*0.5+2.);  \n    Neighborhood3;\n    Q.xy += sign(U.x-0.5*R.x)*f*(grd);\n    Q.xy *= 0.999;\n   Border Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fluid step 2 : d/dt P = d/dx V\n\nMain {\n\tQ = B(U-A(U).xy);\n    Neighborhood;\n    Q.w  -= div;\n    Neighborhood2;\n    Q.xyz -= 0.25*(N*n.y-S*s.y+E*e.x-W*w.x).xyz;\n    if (iFrame < 1) Q.x = -1.;\n    Input\n        Q.x = 1.;\n    Border Q.x = -1.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood2 vec4 N = B(U+vec2(0,1)), E = B(U+vec2(1,0)), S = B(U-vec2(0,1)), W = B(U-vec2(1,0)), M = 0.25*(n+e+s+w);\n#define Neighborhood3 n = D(U+vec2(0,1)), e = D(U+vec2(1,0)), s = D(U-vec2(0,1)), w = D(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.w-w.w,n.w-s.w)\n#define grd2 0.25*vec2(E.x-W.x,N.x-S.x)\n#define div 0.25*(e.x-w.x+n.y-s.y)\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define I 10.\n#define loop for (float i = -I; i <= I; i++)\n#define std vec4(4,1,1,1)\n#define gau(x) 0.3989422804/std*exp(-x*x/std/std)\n#define Input if ((iMouse.z>0.&&length(U-iMouse.xy)<10.)||(iFrame<1&&length(U-0.5*R)<26.))\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.||abs(U.x-0.5*R.x)<1.)", "buffer_c_code": "// gaussian blur pass 1\nMain {\n\tQ = vec4(0);\n\tloop Q += gau(i) * B(U+vec2(i,0)).x;\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur pas2\nMain {\n\tQ = 0.1*D(U);\n\tloop Q += gau(i) * C(U+vec2(0,i));\n    Q.w = 0.1*(Q.x);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 127, 127, 179]], "test": "untested"}
{"id": "WtVXWw", "name": "test texture", "author": "mattz", "description": "prototyping some stuff for my command-line Shadertoy emulator...", "tags": ["test"], "likes": 3, "viewed": 531, "published": 3, "date": "1582848415", "time_retrieved": "2024-07-30T21:21:37.024401", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    ivec2 b = (ivec2(fragCoord)/2) % 2;\n\n    col *= float(b.x ^ b.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 121]], "test": "untested"}
{"id": "wtKSzD", "name": "Underwater world", "author": "maksy", "description": "Underwater world", "tags": ["voronoi", "terrain", "caustics", "underwater", "godray"], "likes": 8, "viewed": 715, "published": 3, "date": "1582846567", "time_retrieved": "2024-07-30T21:21:37.796337", "image_code": "/* Resources:\n * https://www.shadertoy.com/view/4ljXWh\n * https://www.youtube.com/watch?v=l-07BXzNdPw\n */\n#define PI 3.141592\n#define MAX_STEPS 250\n#define MAX_DIST 100.0\n#define SURF_DIST .001\n\n#define GROUND 0\n#define WATER 1\n\nstruct Obj {\n\tint type;\n    float dist;\n    vec3 hitPos;\n};\n\n//2D signed hash function:\nvec2 Hash2(vec2 P) {\n\treturn 1.-2.*fract(cos(P.x*vec2(91.52,-74.27)+P.y*vec2(-39.07,09.78))*939.24);\n}\n\n//2D Simplex gradient noise.\nfloat Simplex(vec2 P) {\n    //Skewing and \"unskewing\" constants as decribed here: https://en.wikipedia.org/wiki/Simplex_noise\n    #define S (sqrt(.75)-.5)\n\t#define G (.5-inversesqrt(12.))\n   \n    //Calculate simplex cells.\n    vec2 N = P+S*(P.x+P.y);\n    vec2 F = floor(N);\n    vec2 T = vec2(1,0)+vec2(-1,1)*step(N.x-F.x,N.y-F.y);\n    \n    //Distance to the nearest cells.\n    vec2 A = F   -G*(F.x+F.y)-P;\n    vec2 B = F+T -G*(F.x+F.y)-G-P;\n    vec2 C = F+1.-G*(F.x+F.y)-G-G-P;\n    \n    //Calculate weights and apply quintic smoothing.\n    vec3 I = max(.5-vec3(dot(A,A),dot(B,B),dot(C,C)),0.);\n    I = I*I*I*(6.*I*I,-15.*I+10.);\n    I /= dot(I,vec3(1));\n    \n    //Add up the gradients.\n    return .5+(dot(Hash2(F),A)*I.x+\n        \t   dot(Hash2(F+T),B)*I.y+\n        \t   dot(Hash2(F+1.),C)*I.z);\n}\n\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves, float octaveWeight) {\n    \n    float h = 0.; // height\n    float m = 0.4; // octave multiplier\n    \n    for (int i = 0; i < octaves; i++) {\n\t\th += octaveWeight * Simplex(uv * m);\n        octaveWeight *= .4;\n        m *= 2.0;\t         \n    }\n    return h;\n}\n\nObj getDist(vec3 p) {\t\n       \n    // distance to the ground\n    float height = fbm(vec2(p.x, p.z), 2, 0.4); \n    height = fbm(vec2(p.x, p.z), 6, 1.5);\n    float planeDist = p.y - height-3.;\n   \n    Obj obj = Obj(GROUND, planeDist, p);\n\n    return obj;\n}\n\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.0;\n    \n    Obj hitObj = Obj(WATER, t, ro + rd);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        hitObj = getDist(p);      \n        t += hitObj.dist;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(WATER, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.dist) < SURF_DIST * (1.0+t)) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.dist = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = getDist(p).dist;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(.01, 0.);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).dist,\n        getDist(p-e.yxy).dist,\n        getDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    \n    // compute the light vector and its normal   \n    lightPos.xz += vec2(sin(iTime*0.5), cos(iTime*0.5))*1.4;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    // calculate diffuse lightning\n    // dot product gives values between -1 to 1 hence the range\n    // is clamped to 0 to 1\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    return dif;\n}\n\n// calculates the intersection of the given plane and ray\nvec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {\n    \n    vec3 planeNormal = vec3(0, 1, 0);\n    \n\tfloat a = dot(dir, planeNormal);\n   \n    float distToPlane = dot(ori-planePos, planeNormal);\n    vec3 intersectPt = ori + dir*abs(distToPlane/a);\n    \n    return intersectPt;\n}\n\n// ############################\n// # CAUSTICS \n// ############################\nvec2 N22(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);\n}\n\nfloat voronoi(vec2 p) {\n\n    // divide the screen into a grid\n    p *= 3.;\n    // this is the id of a grid cell. X and y go from -3 to 3.\n    vec2 id = floor(p);     \n    // Coordinates inside a grid cell\n    vec2 gv = fract(p);\n    \n    float minDist = 9.;\n    \n    // loop through 9 grid cells around the point and check \n    // which is the closest cell\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            // multiply because gv goes from -0.5 to .0.5\n            vec2 p = .5+0.5*sin(n*iTime*4.);\n      \n            vec2 r = offset + p - gv;\n            float d = dot(r, r);\n            \n            if (d < minDist) {\n            \tminDist = d;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\n// creates fake caustics with voronoi patterns and fBMs\nfloat caustics(vec2 p) {\n    float v = 0.0;\n    float a = 0.4;\n    for (int i = 0; i<3; i++) {\n        v += voronoi(p)*a;\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nfloat godRays(vec3 rayDir) {\n \t\n    vec3 col = vec3(0.);\n    float y = rayDir.y * 0.5 + 0.5;\n    \n    float a = atan(rayDir.x, rayDir.z);\n    \n    float rays = sin(a*28.+iTime) * sin(a*27.-iTime) * sin(a*22.);\n    rays = max(0., rays);\n    // cut the lower part of the rays\n    rays *= smoothstep(0.2, 1., y);\n    // decrease brightness\n    rays *= smoothstep(.7, 0., y);\n    \n    return rays+0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 GROUND_COLOR = vec3(0.25);\n    vec3 HORIZON_COLOR = vec3(0.0, 0.05, 0.2);\n    vec3 LIGHT_DIR = vec3(1, 5, -4);\n    \n    // camera\n    vec3 camPos = vec3(3.0*sin(iTime*0.25), 7.0, -1.*iTime);\n    camPos = vec3(10.0*sin(iTime*0.2), 7., -9.);\n    //camPos = vec3(3., 6., -9.);\n    \n    vec3 camTarg = vec3(1., 4., 4.);\n    mat3 camMat = lookAt(camPos, camTarg, 0.0);\n    vec3 rayDir = normalize(camMat * vec3(uv.xy, 1.0));\n   \n    vec3 col = vec3(1.0);\n    \n    Obj hitObj = rayMarch(camPos, rayDir);\n   \t\n    if (hitObj.type == WATER) {\n    \n      col = mix(vec3(1.), HORIZON_COLOR, pow(1.0 - pow(rayDir.y, 4.), 50.0));\n    \n    } else if (hitObj.type == GROUND) {\n      \n        float dif = getLight(hitObj.hitPos, LIGHT_DIR) * hitObj.hitPos.y * 0.26;\n        col = vec3(dif);\n                     \n        float caust = caustics(uv)*3.5;       \n        col *= clamp(caust, 0.5, 1.);       \n        \n        // Use Beer's law for calculating attenuation\n\t\tvec3 attenuation = exp(-vec3(0.3, 0.15, 0.08)*hitObj.dist);\n        col = mix(HORIZON_COLOR, col, attenuation);\n    }\n    \n    float godRay = godRays(rayDir);\n  \n    vec3 lightColor = mix(vec3(1.), col, 1.0 - uv.y);\n    vec3 finalColor = mix(col, lightColor, godRay);\n    \n    col = pow(finalColor,vec3(.454545));\n \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 317, 337, 337, 419], [421, 450, 473, 575, 1246], [1249, 1485, 1541, 1541, 1776], [1778, 1778, 1799, 1838, 2032], [2034, 2034, 2066, 2066, 2736], [2738, 2738, 2763, 2763, 3021], [3023, 3023, 3062, 3117, 3440], [3442, 3500, 3556, 3556, 3782], [3784, 3863, 3881, 3881, 3979], [3981, 3981, 4004, 4042, 4804], [4806, 4862, 4886, 4886, 5041], [5043, 5043, 5094, 5094, 5298], [5300, 5300, 5328, 5328, 5699], [5701, 5701, 5758, 5838, 7213]], "test": "untested"}
{"id": "3lVSWw", "name": "Nautilus: The Book", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\".\nSource explains how to view all the scenes, but the compile time will be longer.", "tags": ["submarine", "sciencefiction", "verne"], "likes": 12, "viewed": 367, "published": 3, "date": "1582846163", "time_retrieved": "2024-07-30T21:21:38.925319", "image_code": "// \"Nautilus: The Book\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"\n\n// For complete book, change ALL_PG from 0 to 1 -- probably longer compile time.\n// Mouse-x overrides autopaging, mouse-y vertical view direction.\n\n#define ALL_PG   0    // = 0/1 for short/full version\n#define ISBOOK   1    // = 1 for book format\n\n#if ! ALL_PG      // single page selection for faster compilation (not with book)\n#define IPAGE  1  // (for short book set = 1, else 1...6)\n#if IPAGE == 4 || IPAGE == 5\n#define UNWAT  1\n#else\n#define UNWAT  0\n#endif\n#if IPAGE == 5 || IPAGE == 6\n#define INCAVE 1\n#else\n#define INCAVE 0\n#endif\n#endif\n#if ! ALL_PG && IPAGE == 3\n#define ISDARK 1\n#else\n#define ISDARK 0\n#endif\n#if ! ALL_PG && IPAGE == 1\n#define INENV 0\n#else\n#define INENV 1\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, sunDir, sbPos, ltDirEx, qHit, pgSize;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage;\nint idObj;\nconst int nPage = 6;\nbool inCave, unWat, isDark, bmOn, inEnv;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14, idGrnd = 15;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\n#if ALL_PG || INCAVE\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\n#endif\n\n#if ALL_PG || UNWAT\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\n#endif\n\n#if ALL_PG || ! (UNWAT || INCAVE)\n\nfloat WaveHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, ht;\n  wFreq = 0.4;\n  wAmp = 0.1;\n  t4o.xz = tCur * vec2 (1., -1.);\n  q2 = p;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v4 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (8.));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;\n    wFreq *= 2.;\n    wAmp *= 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyHrzCol (vec3 rd)\n{\n  vec3 col, clCol, mDir, vn;\n  vec2 q;\n  float a, f, fd, ff, smd, mRad, ts;\n  a = atan (rd.z, rd.x);\n  if (rd.y < 0.02 * Fbm1 (32. * a) - 0.02) {\n    col = vec3 (0.22, 0.3, 0.33) * (0.8 + 0.2 * Fbm2 (64. * vec2 (a, rd.y)));\n    if (isDark) col *= 0.5;\n  } else {\n    if (isDark) {\n      mDir = normalize (vec3 (0.6, 0.05, 1.));\n      mRad = 0.015;\n      col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n      smd = dot (rd, mDir);\n      ts = smd * smd - 1. + mRad * mRad;\n      if (ts > 0.) {\n        ts = smd - sqrt (ts);\n        if (ts > 0.) {\n          vn = normalize ((ts * rd - mDir) / mRad);\n          col += vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, -0.4, 0.5), vn) *\n             (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.);\n        }\n      } else col += StarPat (rd, 6.);\n    } else {\n      smd = max (dot (rd, sunDir), 0.);\n      q = vec2 (0.05 * tCur + 2. * rd.xz / rd.y);\n      ff = Fbm2 (q);\n      f = smoothstep (0.2, 0.8, ff);\n      fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n      clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n         smoothstep (0., 0.05, abs (fd)));\n      col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n      col += 0.1 * pow (smd, 16.) + 0.2 * pow (smd, 256.);\n    }\n  }\n  return col;\n}\n\n#endif\n\n#if ALL_PG || ! UNWAT\n\nfloat WakeFac (vec3 p)\n{\n  vec2 tw;\n  tw = Rot2D (p.xz - sbPos.xz, sbRot);\n  tw.y += 6.5;\n  return (1. - smoothstep (0.3, 0.6, abs (tw.x) + 0.1 * tw.y)) * clamp (1. - 2. * tw.y, 0., 0.2) *\n     smoothstep (-5., -2., tw.y);\n}\n\n#endif\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = (isDark || unWat || inCave) ? vec4 (0.5, 0.4, 0.3, -1.) : vec4 (0.4, 0.4, 0.5, 0.1);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n    if (isDark) col4.rgb *= 0.5;\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[2], rdb[2], bgCol, ltVec, roo, row, vnw;\n  vec2 lbDist, ws;\n  float dstObj, dstObjO, dstCave, dstGrnd, dstWat, sh, atten, wkFac, s;\n  bool waterRefl;\n  dstObj = ObjRay (ro, rd);\n#if ALL_PG || INCAVE\n  if (inEnv && inCave) {\n    dstCave = CaveRay (ro, rd);\n    if (dstCave < min (dstObj, dstFar)) {\n      dstObj = dstCave;\n      idObj = idCav;\n    }\n  }\n#endif\n#if ALL_PG || UNWAT  \n  if (inEnv && unWat) {\n    dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n    if (dstGrnd < min (dstObj, dstFar)) {\n      dstObj = dstGrnd;\n      idObj = idGrnd;\n    }\n  }\n#endif\n  sh = 1.;\n  atten = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (inEnv && unWat) {\n#if ALL_PG || UNWAT  \n    if (dstObj < dstFar) {\n      if (idObj == idGrnd) {\n        ro += dstObj * rd;\n        col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n           0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n           0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n        vn = GrndNf (ro);\n        vno = vec3 (0., 1., 0.);\n        if (vn.y > 0.85) {\n          vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n          vn = vn4.xyz;\n          col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n        }\n        vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n        ws = ro.xz - sbPos.xz;\n        ws = Rot2D (ws, sbRot);\n        sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n           vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n           1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n           (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n#if ALL_PG || INCAVE\n        if (inCave) sh = min (sh, min (CaveSShadow (ro, vec3 (0., 1., 0.)), \n           0.5 + 0.5 * CaveAO (ro, vec3 (0., 1., 0.))));\n#endif\n        col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n      } else if (idObj == idCav) {\n#if ALL_PG || INCAVE\n        ro += dstObj * rd;\n        vn = CaveNf (ro);\n        vno = vn;\n        col = vec3 (0.4, 0.4, 0.4);\n        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (-4. * dstObj / dstFar));\n        vn = VaryNf (ro, vn, 12.);\n        col *= (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n           0.5 * pow (max (dot (reflect (sunDir, vn), rd), 0.0), 128.));\n        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n#endif\n      } else {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        vno = vn;\n        col4 = NautColN (ro, vn);\n        sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n        if (col4.a >= 0.) {\n          col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n          col *= vec3 (0.7, 0.9, 1.);\n        } else {\n          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        }\n      }\n      col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n    } else {\n      col = UnwCol (rd) + WatShd (rd);\n    }\n#endif\n  } else if (! inEnv || inEnv && ! unWat) {\n#if ALL_PG || ! UNWAT\n    roo = ro;\n    dstObjO = dstObj;\n    bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);\n    waterRefl = false;\n    if (inEnv && inCave) {\n#if ALL_PG || INCAVE\n      if (rd.y < 0. && ro.y + rd.y * dstObj < 0.) {\n        dstWat = - ro.y / rd.y;\n        waterRefl = (dstWat < min (dstObj, dstFar) && ro.y + rd.y * dstWat < 0.001);\n      } else {\n        dstWat = dstFar;\n      }\n#endif\n    } else if (inEnv && ! inCave) {\n#if ALL_PG || ! INCAVE\n      dstWat = WaveRay (ro, rd);\n      waterRefl = (dstWat < min (dstFar, dstObj));\n#endif\n    }\n    if (waterRefl) {\n      ro += dstWat * rd;\n      row = ro;\n#if ALL_PG || INCAVE\n      if (inCave) vnw = VaryNf (0.2 * ro, vec3 (0., 1., 0.), 0.1);\n#endif\n#if ALL_PG || ! INCAVE\n      if (! inCave) vnw = WaveNf (ro, dstWat);\n#endif\n      wkFac = WakeFac (row);\n      if (wkFac > 0.) vnw = VaryNf (8. * row, vnw, 16. * wkFac);\n      rd = reflect (rd, vnw);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n#if ALL_PG || INCAVE\n      if (inCave) {\n        dstCave = CaveRay (ro, rd);\n        if (dstCave < min (dstObj, dstFar)) {\n          dstObj = dstCave;\n          idObj = idCav;\n        }\n      }\n#endif\n      if (bmOn) {\n        rob[1] = ro;\n        rdb[1] = rd;\n      }\n    }\n    if (inEnv && inCave) {\n#if ALL_PG || INCAVE\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        ltVec = roo + ltPos - ro;\n        s = length (ltVec);\n        atten = (1. - smoothstep (0.1, 0.6, s / dstFar)) / (1. + 0.002 * pow (s, 1.5));\n        ltVec /= s;\n        if (idObj == idCav) {\n          vn = CaveNf (ro);\n          col4 = vec4 (mix (vec3 (0.55, 0.5, 0.5), vec3 (0.3, 0.4, 0.2),\n             smoothstep (0.5, 0.8, vn.y)), 0.5);\n          sh = min (CaveSShadow (ro, ltVec), CaveAO (ro, vn));\n          vn = VaryNf (ro, vn, 12.);\n        } else {\n          vn = ObjNf (ro);\n          col4 = NautColN (ro, vn);\n          sh = ObjSShadow (ro, ltVec);\n        }\n        if (col4.a >= 0.) col = col4.rgb * sh * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n        else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        col = mix (col, bgCol, smoothstep (0.45, 0.99, dstObj / dstFar)) * atten;\n      } else col = bgCol;\n      if (waterRefl) col = mix (vec3 (0.1, 0.2, 0.3) * (0.2 + 0.8 * atten), col, 0.5);\n#endif\n    } else if (inEnv && ! inCave) {\n#if ALL_PG || ! INCAVE\n      if (dstObj < min (dstWat, dstFar)) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = NautColN (ro, vn);\n        sh = isDark ? 1. : ObjSShadow (ro, sunDir);\n        if (col4.a >= 0.) {\n          col = col4.rgb * (0.3 + 0.2 * max (- dot (vn, sunDir), 0.) +\n             0.7 * sh * max (dot (vn, sunDir), 0.)) +\n             col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n        } else {\n          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        }\n      } else {\n        col = SkyHrzCol (rd);\n      }\n      if (waterRefl) col *= 0.6;\n      if (isDark) col *= 0.8;\n#endif\n    } else if (! inEnv) {\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = NautColN (ro, vn);\n        col4.rgb = vec3 (1.) * pow (Maxv3 (col4.rgb), 0.7);\n#if ISBOOK\n        col4.rgb *= vec3 (0.8, 0.8, 0.85);\n#else\n        col4.rgb *= mix (vec3 (0.8, 1., 1.), vec3 (1., 1., 0.8), - dot (vn, rd));\n#endif\n      if (col4.a < 0.) col4.a = 0.2;\n        s = max (dot (vn, sunDir), 0.);\n        col = col4.rgb * (0.2 + 0.8 * s * s) +\n           2. * col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      } else {\n        col = vec3 (0., 0., 0.5);\n      }\n    }\n#if ALL_PG || ! UNWAT\n    if (inEnv && waterRefl && wkFac > 0.) {\n      s = Fbm3 (16. * row);\n      if (inCave) col = mix (col, vec3 (0.7), 4. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n      else col = mix (col, vec3 (0.9), 8. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n    }\n#endif\n#if ALL_PG || ! UNWAT && ! INCAVE\n    if (inEnv && waterRefl && ! inCave) {\n      col = mix (col, vec3 (0.7), pow (clamp (2.8 * WaveHt (row.xz) +\n         0.5 * Fbm3 (32. * row), 0., 1.), 8.));\n    }\n#endif\n#endif\n  }\n  if (inEnv && bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    if (unWat) {\n#if ALL_PG || UNWAT\n      vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n      if (lbDist.x < min (dstObj, dstFar))\n         col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n#endif\n    }\n    if (! unWat) {\n#if ALL_PG || ! UNWAT\n      if (lbDist.x < min (min (dstObjO, dstWat), dstFar))\n         col = mix (col, vec3 (1., 1., 0.7), 0.7 * (1. - lbDist.y));\n      if (waterRefl) {\n        lbDist = LBeamRay (rob[1], rdb[1]);\n        if (lbDist.x < min (min (dstObj, dstWat), dstFar))\n           col = mix (col, vec3 (0.8, 1., 0.7), 0.4 * (1. - lbDist.y));\n      }\n#endif\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, s, dVu, tVuCyc;\n  uv = fCoord;\n#if ISBOOK\n  tCur += 30. * idPage;\n#endif\n#if ALL_PG\n#if ! ISBOOK\n  tVuCyc = 20.;\n  idPage = floor (mod (tCur / tVuCyc, 6.)) + 1.;\n#endif\n  unWat = (idPage == 4. || idPage == 5.);\n  inCave = (idPage == 5. || idPage == 6.);\n  isDark = (idPage == 3.);\n  inEnv = (idPage >= 2.);\n#elif ISBOOK && ! ALL_PG\n  unWat = false;\n  inCave = false;\n  isDark = (idPage == 3. || idPage == 5.);\n  inEnv = (idPage >= 2.);\n#else\n  unWat = (UNWAT == 1);\n  inCave = (INCAVE == 1);\n  isDark = (ISDARK == 1);\n  inEnv = (INENV == 1);\n#endif\n  cvSize = 7.;\n  if (inEnv) {\n    bmOn = isDark || unWat || inCave;\n  } else {\n    bmOn = false;\n    isDark = false;\n  }\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  if (inEnv && inCave) {\n    fpF = TrackPathCv (t + 0.1);\n    fpB = TrackPathCv (t - 0.1);\n    sbPos = 0.5 * (fpF + fpB);\n    sbPos.y = 0.09;\n    vd = fpF - fpB;\n    sbRot = atan (vd.x, vd.z);\n  } else if (inEnv && ! inCave) {\n    sbPos = vec3 (0., 0.09, t);\n    if (! unWat) sbPos.y = 0.1 - 0.5 * (1. + sin (0.1 * 2. * pi * tCur));\n    sbRot = 0.;\n  } else if (! inEnv) {\n    sbPos = vec3 (0.);\n    sbRot = -0.25 * pi;\n  }\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  s = unWat ? 1. : -1.;\n  if (inEnv && inCave) {\n    dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n    t += 20. * dVu;\n    fpF = TrackPathCv (t + 0.1 * sign (dVu));\n    fpB = TrackPathCv (t - 0.1 * sign (dVu));\n    ro = 0.5 * (fpF + fpB);\n    ro.x += 2. * s * (1. - abs (dVu));\n    ro.y = 2. + 2. * (1. - abs (dVu));\n    vd = sbPos - ro;\n    vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n    dstFar = 50. * cvSize;\n    zmFac = 1.4;\n  } else if (inEnv && ! inCave) {\n    ro.xz = sbPos.xz + 24. * sin (0.01 * s * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    ro.y = unWat ? -2. : 2.;\n    vd = sbPos - ro;\n    vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n    dstFar = 100.;\n    zmFac = unWat ? 2. : 4.;\n  } else if (! inEnv) {\n#if ISBOOK\n    ro = vec3 (0., 8., 24.);\n    vd = sbPos + vec3 (-1., 0., 0.) - ro;\n    vuMat = StdVuMat (atan (vd.y, length (vd.xz)), atan (vd.x, vd.z));\n    dstFar = 100.;\n    zmFac = 6.;\n#else\n    az += 0.05 * pi * tCur;\n    el -= 0.1 * pi * sin (0.04 * pi * tCur);\n    vuMat = StdVuMat (el, az);\n    dstFar = 60.;\n    zmFac = 5.;\n    ro = vuMat * vec3 (0., 0., -24.);\n#endif\n  }\n  ltPos = vuMat * vec3 (0., 1., 1.);\n  if (inEnv) {\n    sunDir = normalize (vec3 (1., 3., -1.));\n  } else {\n#if ISBOOK\n    sunDir = normalize (vec3 (-0.1, 0.4, 1.));\n#else\n    sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#endif\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  if (inEnv && unWat) {\n#if ISBOOK\n    uv *= vec2 (pgSize.z  / pgSize.x, 1.);\n#else\n    uv *= vec2 (9./16., 1./0.85);\n#endif\n    col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  }\n  fCol = col;\n}\n\n#if ISBOOK\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = (idPage > 1.) ? vec3 (0.8, 0.8, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz)) :\n         vec3 (0.1, 0.1, 0.6);\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (idPage > 1. && min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n#if ISBOOK\n  tpBook = max (0.35 * tCur - 1., 0.);\n  az = 0.;\n  el = -0.5 * pi;\n#endif\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n#if ISBOOK\n    tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n    msEl = 0.5 * pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n#else\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n#endif\n  }\n#if ISBOOK\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (3.2, 0., -20.);\n  zmFac = 9.5;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ExShowScene (ro, rd);\n#else\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2153, 2153, 2181, 2181, 2280], [10076, 10076, 10099, 10099, 12980], [12982, 12982, 13004, 13004, 13164], [13166, 13166, 13199, 13199, 13382], [13384, 13384, 13405, 13405, 13660], [13662, 13662, 13699, 13699, 13940], [13942, 13942, 13965, 13965, 14301], [14303, 14303, 14337, 14337, 14559], [14561, 14561, 14584, 14584, 14843], [14845, 14845, 14884, 14884, 17613], [17615, 17615, 17650, 17650, 25915], [25917, 25917, 25962, 25962, 29008], [32338, 32338, 32394, 32394, 33343], [33345, 33345, 33378, 33378, 33467], [33469, 33469, 33515, 33515, 33562], [33564, 33564, 33597, 33597, 33624], [33626, 33626, 33668, 33668, 33719], [33721, 33721, 33780, 33780, 33911], [33913, 33913, 33966, 33966, 34027], [34029, 34029, 34075, 34075, 34132], [34134, 34134, 34156, 34156, 34194], [34196, 34196, 34232, 34232, 34438], [34440, 34440, 34485, 34485, 34588], [34590, 34590, 34647, 34647, 34730], [34732, 34732, 34762, 34762, 34875], [34909, 34909, 34933, 34933, 34986], [34988, 34988, 35012, 35012, 35124], [35126, 35126, 35150, 35150, 35213], [35215, 35215, 35239, 35239, 35358], [35360, 35360, 35385, 35385, 35571], [35573, 35573, 35598, 35598, 35823], [35825, 35825, 35850, 35850, 36171], [36173, 36173, 36198, 36198, 36344], [36346, 36346, 36368, 36368, 36522], [36524, 36524, 36545, 36545, 36700], [36702, 36702, 36723, 36723, 36878], [36880, 36880, 36909, 36909, 37121], [37123, 37123, 37162, 37162, 37347]], "test": "untested"}
{"id": "tldGD7", "name": "iPhone 11", "author": "BigWIngs", "description": "Uncomment the solo define to see the phone by itself.", "tags": ["iphone", "apple"], "likes": 35, "viewed": 1069, "published": 3, "date": "1582842601", "time_retrieved": "2024-07-30T21:21:39.881762", "image_code": "// \"iPhone 11\" by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define MAX_STEPS 300\n#define MIN_DIST .5\n#define MAX_DIST 2400.\n#define SURF_DIST .1\n\n//#define SOLO_MODE\n\n#define PURPLE (vec3(209,205,218)/255.)\n#define YELLOW (vec3(255,230,129)/255.)\n#define GREEN (vec3(174,225,205)/255.)\n#define BLACK (vec3(31,32,32)/255.)\n#define WHITE (vec3(249,246,239)/255.)\n#define RED (vec3(186,12,46)/255.)\n\nvec3 baseCol = BLACK;\n    \nmat2 Rot(float a) {\n    float s = sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\nvec2 sabs(vec2 x,float k) { return vec2(sabs(x.x, k), sabs(x.y,k)); }\nvec3 sabs(vec3 x,float k) { return vec3(sabs(x.x, k), sabs(x.y,k), sabs(x.z,k)); }\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdApple(vec2 p) {    \n    float d;\n    \n    float A = length(p-vec2(-.078,.02))-.52;\n    float B = length(p-vec2(.118,.045))-.552;\n    float sides = max(A, B);\n    \n    float C = length(p-vec2(-.181,.108))-.245;\n    float D = length(p-vec2(.178,.108))-.245;\n    float top = min(C, D);\n    \n    float E = length(p-vec2(-.153,-.29))-.115;\n    float F = length(p-vec2(.176,-.3))-.107;\n    float bottom = min(E, F);\n    \n    d = mix(\n        min(top, bottom),\n        sides,\n        S(.05, -.05, p.y-.188)*S(-.05,.01, p.y+.382)\n    );\n    \n    float G = length(p-vec2(.01, -.608))-.247;\n    d = smin(d, -G, -.03);\n    float H = length(p-vec2(.487, .06))-.222;\n    d = max(d, -H);\n    \n    float I = length(p-vec2(0,.417))-.113;\n    float J = length(p-vec2(0,.17))-.163;\n    d = min(d, max(-I, J));\n    \n    float K = length(p-vec2(.207, .365))-.222;\n    float L = length(p-vec2(-.02, .567))-.222;\n    d = min(d, max(K, L));\n    \n    return d;\n}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(max(d.x,d.y), d.z),0.0) + length(max(d,0.0));\n}\nfloat sdBox2D( vec2 p, vec2 b ){\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCyl(vec3 p, float h, float r, float b) {\n\tfloat d = length(p.xy)-r+b;\n    return length(max(vec2(d, abs(p.z)-h), 0.))-b;\n}\n\nfloat sdCameras(vec3 p) {\n\t// cameras\n    float r2 = 14.7;\n\tvec2 size = vec2(26.2, 29.2);\n    \n    float d = sdBox2D(p.xy, size-r2)-r2;\n    \n    d = max(d, p.z);\t// cut back\n    \n    vec3 h = vec3(size.x, size.y, r2)-r2;\n    vec3 q = p - clamp( p, -h, h );\t\t\t// IQs elongation\n    float t = length(vec2(length(q.xy)-r2, q.z+1.))-1.; // torus\n    d = max(d, -t);\t// cut bevel\n    d = smin(d, -(p.z+1.), -.5); // cut front\n    \n    d = max(d, -sdCyl(p-vec3(11.6,0,-3.8), 1.5, 5.6, 2.));\t// flash\n    d = max(d, -sdCyl(p-vec3(11.6,14.5,-3.), 1.5, 2.8, 1.));\t// mike\n\n    // lenses\n    vec3 lp = vec3(p.x+11.5, abs(p.y)-14.6, p.z);\n    d = min(d, sdCyl(lp, 1.5, 12., .4)); // ring\n    d = min(d, sdCyl(lp, 1.8, 10., .3)); // lens cap\n    \n    d = max(d, (8.-length(lp*vec3(1,1,4)+vec3(0,0,7)))/4.); // hole\n    d = min(d, (length(lp*vec3(1,1,2))-4.)/2.);\n    \n    return d;\n}\n\nvec4 TransformPos(vec3 p) {\n\tfloat id = 0.;\n    #ifndef SOLO_MODE\n    vec3 s = sign(p);\n    vec3 size = vec3(400, 400, 800);\n    \n    float t = mod(iTime, 200.)*.5;\n    \n    p.z -= t*400.;\n    \n    id = floor(p.z/size.z);\n    p.z = mod(p.z, size.z)-size.z*.5;\n    \n    p.xy *= Rot(t*.3+id);\t\t\t// rotate wheel\n    s = sign(p);\n    float flip = s.x==s.y?1.:-1.;\n    p.xy = abs(p.xy)-size.xy*.5;\t// 4-fold \n    p.x *= flip;\n    \n    p.xy *= Rot(3.1415*.25*flip);\t\t// point to center\n    p.xz *= Rot(t+id);\t\t\t\t// spin on axis\n    \n    #endif\n    return vec4(p,id);\n}\n\nfloat GetDist(vec3 p) {\n    p = TransformPos(p).xyz;\n    \n    vec3 size = vec3(75.7, 150.9, 8.3);\n    float r1 = 24.3;\n    \n\tfloat front = sdBox2D(p.xy, size.xy-r1)-r1;\n    float side = sdBox2D(p.yz, vec2(144, 8.1)-8.)-8.;\n    float top = sdBox2D(p.xz, vec2(71.4, 8.1)-8.)-8.;\n   \n    float d = sdBox(p, size-size.z)-size.z;\n    d = smin(d, front, -4.);\n    \n    // front cam and speaker\n    d = smin(d, 1.-sdBox(p-vec3(0,137.8,size.z), vec3(7.95,0, .0)), -.5);\n    \n    vec3 h = size-r1;\n    vec3 q = p-clamp(p, -h, h);\n    float groove = length(q.xy*1.35)-r1-1.;\n    d += S(.5,-.5,groove)*.4;\n    \n    // buttons\n    side = step(0., p.x);\n    \n    float lb = sdBox2D(p.zy-vec2(0, 65.1), vec2(0,16))-3.;\n    lb = S(.3, -1., lb)-S(-.5, -2., lb)*1.5;\n    \n    float rb = sdBox2D(p.zy-vec2(0, 104.1), vec2(.5,6))-2.;\n    rb = S(.3, -1., rb);\n    d += rb * side;\n    rb = sdBox2D(p.zy-vec2(1, 104.1), vec2(0,6))-2.;\n    rb = S(.3, -1., rb);\n    d -= rb * side;\n    \n    vec2 bp = vec2(p.z, abs(p.y-65.1));\n    \n    rb = sdBox2D(bp-vec2(0, 13), vec2(0,9))-3.;\n    rb = S(.3, -1., rb)-S(-.5, -2., rb)*1.5;\n    \n    d += mix(lb, rb, side);\n    \n    // bottom\n    vec3 pb = vec3(abs(p.x), p.y+size.y, p.z); \n    float bb = sdBox(pb, vec3(8, 4, 0))-2.;\n    bb = min(bb, sdCyl((pb-vec3(15, 0, .6)).zxy, 1., 1.76, .5));\n    \n    pb.x = mod(pb.x-2.35, 4.7)-2.35;\n    float mh = sdCyl(pb.zxy, 4., 1.47, .2);\n    mh = max(mh, abs(abs(p.x)-35.4)-13.2);\n    bb = min(bb, mh);\n    \n    d = smin(d, -bb, -1.);\n    \n    // cameras\n    d = min(d, sdCameras(p-vec3(-39.6, 111.4, -size.z)));\n    \n    return d*.7;\n}\n\nfloat AO( in vec3 p, in vec3 n, in float maxDist, in float falloff ) {\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = fract(sin((float(i))*maxDist));\n        vec3 rd = n*l;\n        \n        ao += (l - max(GetDist( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec3(dO, abs(dS), matId);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(1e-2, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Pixelize(sampler2D sampler, vec2 uv, vec2 resolution) {\n   // resolution *= .1;\n    uv *= resolution;\n    \n    vec2 c = fwidth(uv)*100.;\n    \n    vec2 gv = fract(uv)-.5; \n    vec2 id = floor(uv);\n    \n    float rbPixel = length(gv);\n    float gPixel = length(abs(gv)-.5);\n    \n    float checker = mod(id.x+id.y, 2.);\n    vec3 colorMask = vec3(checker, 0., 1.-checker);\n    \n    float rgbShift = smoothstep(.4, .2, gPixel);\n    colorMask = mix(colorMask, vec3(0,1,0), rgbShift);\n    \n    id += rgbShift*.5*sign(gv);\n    vec3 col = texture(sampler, id/resolution).rgb;\n    \n\tfloat pixelMask = smoothstep(.5, .2, rbPixel) + smoothstep(.3, .2, gPixel);\n    \n    float fade = clamp(dot(c,c)/1e4, 0., 1.);\n    col *= mix(pixelMask*colorMask*2., vec3(1.), fade);\n    //col = vec3(fade);\n    \n    return col;\n}\n\nvoid SetBaseCol(float id) {\n     if(id==0.)\n    \tbaseCol = YELLOW;\n    else if(id==1.)\n        baseCol = GREEN;\n    else if(id==2.)\n        baseCol = PURPLE;\n    else if(id==3.)\n        baseCol = BLACK;\n    else if(id==4.)\n        baseCol = RED;\n    else\n        baseCol = WHITE;\n}\n\nvec3 Material(vec3 p, vec3 n, vec3 rd) {    \n    float ao = AO(p, n, .5, .5);\n    \n    vec3 s = sign(p);\n    vec4 P = TransformPos(p);\n    \n    p = P.xyz;\n    \n    float id = mod(P.w, 6.);\n    SetBaseCol(id);\n      \n    vec3 col;\n    \n    vec3 r = reflect(rd, n);\n    float f = 1.+dot(n, rd);\n    float fresnel = pow(max(f, 0.), 2.);\n    \n    vec3 blurRef = texture(iChannel0, r).rgb;\n    vec3 sharpRef = texture(iChannel1, r).rgb;\n    \n    float w = .2;\n    \n    float side = step(0., -p.z);\t// which side 0=front 1=back\n    float bandDist = sdBox2D(p.xy, vec2(51.3, 126.6))-18.7;\n    float band = S(-w, w, bandDist);\n    \n    if(side<.5) {\t// screen side\n        float screenDist = sdBox2D(p.xy, vec2(51.3, 126.6)-1.)-15.;\n        screenDist = smin(screenDist, 10.-sdBox2D(p.xy-vec2(0,139.5), vec2(37, 10.5)-10.), -3.);\n        float screen = S(w, -w, screenDist)*(1.-side);\n        \n        vec2 uv = p.xy/vec2(-150*2, 300) +.5;\n        vec3 scrCol = texture(iChannel2, uv).rgb;\n        scrCol = Pixelize(iChannel2, uv, vec2(828,1792));\n        col = scrCol*screen;\n        col += .002*(1.-screen);\n        vec2 lp = p.xy-vec2(-14.6, 137.8);\n        float d = length(lp)-2.6;\n        if(d<0.) {\n            float z = 1.-rd.y;\n            z = 0.;\n            \n            vec3 ref = vec3(.3, .2, .8)*S(.3, -.3, d+1.)*d*d*.5;\n            ref *= ref;\n            ref *= pow(1.-f, 12.)*.25;\n            \n            col = ref;\n        }\n        \n        col += sharpRef*.05;\n        \n    } else {\t\t\t// back side\n        float logo = S(.01, -.01, sdApple(p.xy*.04));\n    \t\n        col = baseCol*baseCol*ao;\n        col += mix(blurRef, sharpRef, logo)*.5;\n        \n        // camera area \n        vec2 cp = p.xy-vec2(-39.6, 111.4);\n        vec2 lp = vec2(cp.x+11.5, abs(cp.y)-14.6);\n        float d = length(lp);\n        \n        if(d<10.) {\n            col = vec3(col.r*0.1);\n            vec3 ref = sharpRef*vec3(.3, .2, .8)*2.;\n            col += ref*ref*sqrt(f)*S(4., 3., d);\n            ref = texture(iChannel1, reflect(rd,vec3(0,0,-1))).rgb;\n            //col *= ao;\n            col += ref*rd.y;   \n        } else if(d<12.) {\n            band = 1.;\n        }\n        \n        // flash\n        vec2 fp = cp-vec2(11.5,0);\n        d = length(fp);\n        if(d<4.5) {\n            float fd = length(fp+rd.xy);\n            float sep = 2.;\n            float w1d = length(fp-vec2(0, sep));\n            float w2d = length(fp+vec2(0, sep));\n            float freq = 15.;\n            float waves = (sin(w1d*freq)+sin(w2d*freq))*S(.0, -.5, fd-4.3); \n            vec3 flashCol = mix(vec3(1., .5, .2), vec3(.8), fd*.3);\n           \tflashCol += S(3., 1., length(fp-vec2(0.,sep)))*.2;\n            flashCol += waves*.05;\n            col = mix(col, flashCol, S(.3, -.0, d-4.2));\n            col *= S(1., -1., d-4.5);\n        }\n        \n        // mike\n        fp = cp-vec2(11.5,14.5);\n        float fd = length(fp);\n        if(fd<2.2) {\n            float m = S(2.2, 2., fd);\n            fp *= 10.;\n            m *= max(0., sin(fp.x+fp.y))+max(0., sin(fp.x-fp.y));\n        \tfloat distFade = min(1., fwidth(length(p))*3.);\n            col = mix(vec3(m), vec3(.5), distFade);\n            //col = vec3(distFade);\n        }\n    }\n    \n    float gaps = S(w, -w, abs(abs(p.y)-120.)-1.4);\n    gaps *= S(71.7, 72.1, abs(p.x));\n    vec3 bandCol = pow(blurRef, vec3(.4))*baseCol;\n    bandCol *= 1.-gaps*.3;\n    \n    float shadow = clamp(74.2-abs(p.x), 0., 1.);\n    shadow *= clamp(4.-abs(p.z), 0., 1.); \n    float s1 = shadow;\n    shadow *= clamp(115.-abs(p.y), 0., 1.);\n    shadow += S(-149., -146., p.y)*s1*S(52., 50., length(p.xy+vec2(0,150)));\n    bandCol -= shadow;\n    \n    col = mix(col, bandCol, band);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    float t = iTime;\n    \n    vec2 p = uv;\n    float zoom = mix(1., 15., (sin(iTime)*.5+.5)*0.);\n    \n    #ifdef SOLO_MODE\n    vec3 ro = vec3(0,0,-300);\n    if(uv.x>0.) {\n    \tuv.x -= .5;\n    } else {\n    \tuv.x += .3;\n        uv *= .25;\n    }\n    #else\n    vec3 ro = vec3(0,0,-600);\n    #endif\n    \n    ro.xz *= Rot(-M.x*6.2831-3.1415);\n    //ro.yx *= -Rot(M.y*3.1415);\n    ro.y -= M.y*800.;\n    vec3 lookat = vec3(0, ro.y*.3, 0);\n    //lookat = vec3(-39.6, 111.4, 10);\n   // lookat = vec3(-59.6*0., 136.4, 10);\n   // lookat = vec3(0, -140,0);\n    \n    mat2 rot = Rot(iTime);\n    vec3 rd = R(uv, ro, lookat, zoom);\n\tvec3 bg = WHITE;\n    #ifdef SOLO_MODE\n    float f = .01/dot(uv,uv);\n    bg *= 0.;\n    #endif\n    \n    vec3 col = bg;\n    \n    //ro.xz *= rot; rd.xz*=rot;\n    vec3 info = RayMarch(ro, rd);\n    \n    if(info.y<SURF_DIST) {\n        vec3 p = ro + rd*info.x;\n        vec3 n = GetNormal(p);\n        col = Material(p, n, rd);\n    }\n    \n    float fade = min(1., info.x/2400.);\n    col = mix(col, bg, fade*fade*fade);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 20765, "src": "https://soundcloud.com/mrsuicidesheep/novo-amor-anchor", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Into You - by Martijn Steinrucken aka BigWings - 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// You can change the focal plane by moving the mouse up and down.\n\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=lrMiME82Cuk\n\n// Making of video part1:\n// https://www.youtube.com/watch?v=dXyPOLf2MbU\n\n// Android Phone Wallpaper:\n// https://play.google.com/store/apps/details?id=com.TheArtOfCode.FallingHearts\n\n// Music - Novo Amor - Anchor\n// https://soundcloud.com/mrsuicidesheep/novo-amor-anchor\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n#define HEARTCOL vec3(1., .01, .01)\n#define NUM_HEARTS 100.\n#define LIGHT_DIR vec3(.577, -.577, -.577)\n\n// Polynomial smooth max from IQ\nfloat smax( float a, float b, float k ) {\n\tfloat h = sat( .5 + .5*(b-a)/k );\n\treturn mix( a, b, h ) + k*h*(1.-h);\n}\n\n// Quaternion rotation functions from Ollj\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n\nvec2 RaySphere(vec3 rd, vec3 p) {\n    float l = dot(rd, p);\n    float det = l*l - dot(p, p) + 1.;\n    if (det < 0.) return vec2(-1);\n\n    float sd = sqrt(det);\n    return vec2(l - sd, l+sd);\n}\n\nstruct sphereInfo {\n\tvec3 p1, p2, n1, n2;\n    vec2 uv1, uv2;\n};\n\nsphereInfo GetSphereUvs(vec3 rd, vec2 i, vec2 rot, vec3 s) {\n\tsphereInfo res;\n    rot *= 6.2831;\n    vec4 q = aa2q(vec3(cos(rot.x),sin(rot.x),0), rot.y);\n    vec3 o = qmulv(q, -s)+s;\n    vec3 d = qmulv(q, rd);\n    \n    res.p1 = rd*i.x;\n    vec3 p = o+d*i.x-s;\n    res.uv1 = vec2(atan(p.x, p.z), p.y);\n    res.n1 = res.p1-s;\n    \n    res.p2 = rd*i.y;\n    p = o+d*i.y-s;\n    res.uv2 = vec2(atan(p.x, p.z), p.y);\n    res.n2 = s-res.p2;\n        \n    return res;\n}\n\nfloat Heart(vec2 uv, float b) {\n\tuv.x*=.5;\n    float shape = smax(sqrt(abs(uv.x)), b, .3*b)*.5;\n    uv.y -= shape*(1.-b);\n\n    return S(b, -b, length(uv)-.5);\n}\n\nvec4 HeartBall(vec3 rd, vec3 p, vec2 rot, float t, float blur) {\n    vec2 d = RaySphere(rd, p);\n    \n   \tvec4 col = vec4(0);\n    if(d.x>0.) {\n    \tsphereInfo info = GetSphereUvs(rd, d, rot, p);\n    \t\n        float sd = length(cross(p, rd));\n        float edge =  S(1., mix(1., 0.1, blur), sd);\n        \n        float backMask = Heart(info.uv2, blur)*edge; \n        float frontMask = Heart(info.uv1, blur)*edge; \n        float frontLight = sat(dot(LIGHT_DIR, info.n1)*.8+.2);\n        float backLight = sat(dot(LIGHT_DIR, info.n2)*.8+.2)*.9;\n\n        col = mix(vec4(backLight*HEARTCOL, backMask), \n                  vec4(frontLight*HEARTCOL, frontMask), \n                  frontMask);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.3;\n  \n    vec3 rd = normalize(vec3(uv, 1));\n    \n    m.y = iMouse.z>0. ? 1.-m.y : .4;\n\n    vec2 rot = t*vec2(.12, .18);\n    vec4 col = vec4(0);\n        \n    for(float i=0.; i<1.; i+=(1./NUM_HEARTS)) {\n        float x = (fract(cos(i*536.3)*7464.4)-.5)*15.;\n        float y = (fract(-t*.2+i*7.64)-.5)*15.;\n        float z = mix(14., 2., i);\n        \n        float blur = mix(.03, .35, S(.0, .4, abs(m.y-i)));\n        \n        rot += (fract(sin(i*vec2(536.3, 23.4))*vec2(764.4, 987.3))-.5);\n        vec4 heart = HeartBall(rd, vec3(x, y, z), rot, t, blur);\n        \n        col = mix(col, heart, heart.a);\n    }\n\t\n    fragColor = col;\n}\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldGD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[719, 719, 738, 738, 799], [801, 801, 830, 830, 909], [910, 910, 937, 937, 979], [980, 980, 1007, 1007, 1062], [1063, 1063, 1104, 1104, 1195], [1196, 1196, 1219, 1219, 2142], [2143, 2143, 2173, 2173, 2265], [2266, 2266, 2298, 2298, 2380], [2381, 2381, 2429, 2429, 2511], [2513, 2513, 2538, 2550, 3384], [3386, 3386, 3413, 3413, 3948], [3950, 3950, 3973, 3973, 5544], [5546, 5546, 5616, 5616, 5900], [5902, 5902, 5935, 5935, 6202], [6204, 6204, 6228, 6228, 6418], [6420, 6420, 6462, 6462, 6657], [6659, 6659, 6719, 6743, 7466], [7468, 7468, 7495, 7495, 7749], [7751, 7751, 7791, 7791, 11457], [11461, 11461, 11518, 11518, 12712]], "test": "untested"}
{"id": "WsjXWm", "name": "Hexagonal Symmetry Wallpaper", "author": "mla", "description": "The 5 hexagonal symmetry wallpaper groups.\n\n<mouse>: offset into texture\n<up>,<down>: zoom in/out\na,b,c: enable symmetry ops\nx,y,z: show lines of symmetry\ni: invert at mouse\nf: position dependency", "tags": ["patterns", "hexagonal", "wallpaper"], "likes": 17, "viewed": 540, "published": 3, "date": "1582837268", "time_retrieved": "2024-07-30T21:21:40.824746", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hexagonal symmetry wallpaper patterns.\n// Matthew Arcus, 2020\n//\n// Map to repeated region of two equilateral triangles\n// Apply various symmetry operations to triangles to get 5 basic groups.\n// See: https://en.wikipedia.org/wiki/Wallpaper_group for more details.\n//\n// Controls:\n// mouse: change offset of texture map\n// a,b,c: apply different symmetry operations\n// x,y,z: show lines of symmetry\n// i: invert at mouse position\n// r: show fundamental region in blue\n// f: vary texture offset by position\n//\n// The \"repeated unit\" for hexagonally symmetric wallpaper is a rhombus,\n// composed of two equilateral triangles, let's call them A and B, and we\n// want to arrange them so A points up, B points down, their bases are on\n// the x-axis and they are centred around the y-axis.\n//\n// For the whole pattern to be rotationally symmetric, A and B must also be,\n// so we first map the plane into A and B with a skew and modulus operation,\n// then map B into A with a rotation (but remember if we did so). Dividing A\n// up into 6 sectors, rotate the top 4 into the bottom 2, then rotate points\n// that came from B back again. Now all points are mapped to a rhomboidal\n// \"basic fundamental region\", centred on the the origin, that by itself\n// gives tiling p3.\n//\n// This region may also itself have symmetry operations applied - rotating\n// points in B back into A gives p6 (key 'a'), reflecting in x-axis gives\n// p3m1 (key 'b'), reflecting in y-axis gives p31m (key 'c'), and combining \n// both reflections gives p6m.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float X = 1.732050808; // sqrt(3)\nconst float Y = 0.577350269; // 1/sqrt(3)\n\nbool alert = false;\nvoid assert(bool x) {\n  if (!x) alert = true;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec3 getcolor(vec2 z0, vec2 z) {\n  vec2 offset = vec2(0.5);\n  if (iMouse.x > 0.0) {\n    offset += 4.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  z = rotate(z,0.1*iTime);\n  z -= offset;\n  if (keypress(CHAR_F)) z += 0.1*z0;\n  vec3 col = textureLod(iChannel2,z,1.0).xyz;\n  col *= 2.0;\n  col.xyz = col.yzx;\n  return col;\n}\n\n// M maps a square grid to a grid of equilateral triangles\nconst mat2 M = 0.5*mat2(1,-X,1,X);\nconst mat2 Minv = Y*mat2(X,X,-1,1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float scale = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n\n  if (keypress(CHAR_I)) {\n    vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    z -= m;\n    z /= dot(z,z);\n    z += m;\n  }\n  \n  vec2 z0 = z; // Save the initial position\n  z.x += 0.5;\n  z = Minv*z; // Convert to square grid\n  ivec2 index = ivec2(floor(z)); // Remember cell in grid\n  z -= floor(z);\n  z = M*z; // Back to triangles\n\n  // Map to equilateral triangles [(0,0),(1,0),(0.5,0.866)],[(0,0),(1,0),(0.5,-0.866)]\n  z.x -= 0.5;\n  bool inlower = z.y < 0.0; // Point is in lower triangle,\n  if (inlower) z = -z;      // so rotate to upper triangle\n\n  // All patterns have rotational symmetry about triangle centre, so:\n  // map centre of triangle to origin...\n  z.y -= 0.5*Y;\n\n  // ...and reflect in planes of symmetry of triangle\n  const vec2 A = 0.5*(vec2(1,X));  // normalized\n  const vec2 B = 0.5*(vec2(-1,X)); // normalized\n  float ta = dot(z,A);\n  z -= 2.0*max(ta,0.0)*A;\n  float tb = dot(z,B);\n  z -= 2.0*max(tb,0.0)*B;\n  // If we have done just one reflection, reflect\n  // in y-axis so we always have just a rotation.\n  bool parity = (ta > 0.0) != (tb > 0.0);\n  if (parity) z.x = -z.x;\n\n  vec2 z1 = z; // Save position relative to centre of triangle\n\n  z.y += 0.5*Y;        // Shift origin back to region centre,\n  if (inlower) z = -z; // and rotate bottom half back\n\n  // Now we are in a basic rhomboidal region, centred on the origin.\n  // Apply extra symmetries to basic region\n  if (keypress(CHAR_A) && inlower) z = -z; // Rotate about origin\n  if (keypress(CHAR_B)) z.x = abs(z.x);  // Left-right mirror\n  if (keypress(CHAR_C)) z.y = abs(z.y);  // Up-down mirror - no effect after rotation\n  \n  vec3 col = getcolor(z0,z);\n\n  if (keypress(CHAR_R)) {\n    // If the point hasn't moved (much) we are in the fundamental region\n    bool inregion = length(z-z0) < 1e-4;\n    if (inregion) col.b = 1.0;\n  }\n\n  vec3 linecol = vec3(0.1);\n  if (!keypress(CHAR_X)) {\n    col = mix(linecol,col,smoothstep(0.0,0.02,abs(dot(z1,B))));\n    col = mix(linecol,col,smoothstep(0.0,0.02,abs(dot(z1,A))));\n  }\n  if (keypress(CHAR_Y)) col = mix(linecol,col,smoothstep(0.0,0.02,abs(z.x)));\n  if (keypress(CHAR_Z)) col = mix(linecol,col,smoothstep(0.0,0.02,abs(z.y)));\n\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1797, 1797, 1818, 1818, 1844], [1846, 1846, 1876, 1876, 1926], [1928, 1928, 1953, 1953, 2013], [2015, 2015, 2040, 2040, 2088], [2089, 2089, 2112, 2112, 2144], [2402, 2402, 2434, 2434, 2729], [2862, 2862, 2919, 2919, 5286]], "test": "untested"}
{"id": "wlySDm", "name": "Astral Projection (Modern)", "author": "vikitux", "description": "Just tune ", "tags": ["projection", "animationcpu"], "likes": 5, "viewed": 400, "published": 3, "date": "1582833939", "time_retrieved": "2024-07-30T21:21:41.674474", "image_code": "// based on https://www.shadertoy.com/view/WtKSWD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 2019 Created by Animation CPU Experiments https://twitter.com/animationcpu\n\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p,a,b);\nfloat m =smoothstep(0.04,0.007,distLine(p,a,b));\n\nfloat d2 = length(a-b);\n  m *= smoothstep(0.6- .1/(length(p)), .3 , d2)*.2 + smoothstep(.0122,.00121,abs(d2-.75)) ;//* (.25/length((p-a)+(p-b)));\n  return m;\n}\nfloat n21(vec2 p){\n  p = fract(p*vec2(123.213,853.4264));\n  p += dot(p,p+6.65);\n  return fract(p.x*p.y);\n\n}\nvec2 n22(vec2 p){\n    float n = n21(p);\n    return vec2(n, n21(p+n));\n}\n\nvec2 getPos(vec2 id, vec2 offset) {\n    vec2 n = n22(id+offset)*iTime;\n    return offset+sin(n)*.4;\n}\nmat2 r(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat layer(vec2 uv, out vec3 attr){\n\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    vec2 gridPos[9];\n    int ppos = 0;\n    for(int y = -1; y<=1; y++) {\n        for(int x = -1; x<=1; x++) {\n            gridPos[ppos++] = getPos(id,vec2(x,y));\n            \n           \n        }\n    }\n    attr = vec3(0.);\n    for(int i=0;i<9;i++){\n        float l0 = line(gv,gridPos[4],gridPos[i]);\n//        m+=line(gv,gridPos[4],gridPos[i]);\n        \n        vec2 jj = (gridPos[i] - gv)*12.;\n        float sparkle = 1./length(dot(jj,jj));\n        m+=sparkle*(sin(iTime+ fract(gridPos[i].x) *10.)*.5+.5);\n        m += l0;\n        attr.x = float(i)/8.*(l0*10.)*(gridPos[i].x-gridPos[i].y+1.);\n\n\n    }\n     m+=line(gv,gridPos[1],gridPos[3]);\n     m+=line(gv,gridPos[1],gridPos[5]);\n     m+=line(gv,gridPos[7],gridPos[3]);\n     m+=line(gv,gridPos[7],gridPos[5]);\n     return m ;\n}\n\n\n#define ttime floor(iTime*.5) + pow(fract(iTime*.5),.5)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) -.5;\n \n      \n     float m = 0.;\n      //uv*=exp(length(uv)*.2);\n      uv*=.75;\n      uv*=r(atan(uv.x,uv.y)*2.*1.5);\n      uv*=r(cos(length(uv)*3.1415));\n      uv*=r(-iTime*.1);\n      uv=-abs(uv);\n\n     uv*=2.;\n  \n      //uv.x+=-iTime*.0001;   \n      float t = iTime*.0025;\n    \n      vec3 col = vec3(0.);\n     for( float i=0.; i<1.; i+= (1./5.) ) {\n          float z = fract(i+t);\n  \n          float size = mix(8.+sin(i*3.1415*(sin(iTime)*.5+1.5)+ttime)*8.,2.,z);\n          float fade = smoothstep(.0,.4,z) * smoothstep(1.,.6,z);\n         uv*=r(t*sin(i*10.));\n\n          vec3 col1;\n\n          m += layer(uv*size+i*20., col1) * fade ;\n          \n          col1 = col1.xxx*pal( col1.x+iTime*0.1, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n\n          vec3 base = mix(vec3(.75+sin(ttime+length(uv*4.))*.1,.2,.6),vec3(.1,.2,.6),vec3(sin(i*4.5)*.5+.5,0.+m*1.,i*2.));\n          col += vec3(m)*base;\n//          col += vec3(m)*base + col1*fade;//*base*0.1;\n          col += col1; //*base*fade*0.1;\n\n//          col.b=0.;\n//          col.g=0.;\n     }\n \n\n    //if(gv.x>.47 || gv.y >.47) col.r = 1.;\n    fragColor = vec4(col,1.0);\n\n//    fragColor.rgb = fragColor.bbr;\n//    fragColor.rgb = fragColor.rgb;\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[216, 216, 256, 256, 374], [375, 375, 410, 410, 647], [648, 648, 666, 666, 755], [756, 756, 773, 773, 827], [829, 829, 864, 864, 930], [931, 931, 947, 947, 1006], [1008, 1008, 1076, 1076, 1119], [1121, 1121, 1157, 1157, 2010], [2069, 2069, 2124, 2124, 3475]], "test": "untested"}
{"id": "WtGSWW", "name": "Snake game prototype", "author": "avin", "description": ">>> Focus on preview and press W to start! <<<", "tags": ["game", "snake"], "likes": 16, "viewed": 609, "published": 3, "date": "1582828033", "time_retrieved": "2024-07-30T21:21:42.441424", "image_code": "#define BLACK vec3(32, 43, 51) / 255.0\n#define DARK_GRAY vec3(57, 75, 89) / 255.0\n#define GRAY vec3(138, 155, 168) / 255.0\n#define WHITE vec3(225, 232, 237) / 255.0\n#define RED vec3(255, 115, 115) / 255.0\n\n// Smooth factor\n#define SF 1./min(iResolution.x, iResolution.y)\n#define SS(l, s, sf) smoothstep(sf, -sf, l - s)\n// Clamp value [0 - 1]\n#define C(v) clamp(v, 0., 1.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 gData = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float lastEatTime = gData.y;\n    float ltDiff = C((iTime - lastEatTime)*2.);\n    float ltDiffS = sqrt(ltDiff);\n    float ltDiffHS = C(sqrt(ltDiff*2.0));\n    float ltDiffJump = (1. - cos(ltDiffHS*PI2))*.015;\n    float ltDiffJump2x = (1. - cos(ltDiffHS*PI2*2.))*.015;\n    \n    vec2 ruv = fragCoord / iResolution.xy;\n    vec2 ouv = (fragCoord - iResolution.xy * .5) / iResolution.y * (1. - ltDiffJump);\n    float rFactor = hash11(gData.z);\n    ouv *= rot(ltDiffJump2x * (rFactor > .5 ? 1. : -1.));\n    \n    float fSize = SIZE + 2.;\n    vec2 id = floor(ouv * fSize);\n    vec2 buv = ouv * fSize;\n    vec2 uv = fract(buv);                  \n    \n    // Final color\n    vec3 col;\n    \n    // Grid\n    float sf = SF * fSize*.5 * (1. - ltDiffJump);    \n    float g = C(step(abs(uv.x - sf), sf) + step(abs(uv.y - sf), sf));        \n    col = mix(BLACK, GRAY, g);\n    \n    // Snake           \n    for(int i=(int(gData.z)+1); i>=0; i-=1){\n        vec2 mPos = texelFetch(iChannel0, ivec2(i, 1), 0).xy;    \n        vec3 pCol = WHITE * (1. - (float(i) / (gData.z+1.))*.5);\n    \tcol = mix(col, pCol, B2F(mPos.x == id.x && mPos.y == id.y));   \n    }\n    \n    // Outer space\n    float outx = step(buv.x, SIZE*.5+sf*2.) * step(-SIZE*.5, buv.x);\n    float outy = step(buv.y, SIZE*.5+sf*2.) * step(-SIZE*.5, buv.y);       \n    float str = 2. - ltDiffHS;\n    float l = length(ouv);\n    vec3 backCol = mix(BLACK, DARK_GRAY, smoothstep(str, 0., l)*.5);\n    col = mix(backCol, col, outx * outy);\n    \n    // Fruit\n    vec2 fPos = texelFetch(iChannel0, ivec2(1, 0), 0).xy;        \n    float fill = B2F(fPos.x == id.x && fPos.y == id.y)\n        * step(abs(uv.x - .5), ltDiffS)\n        * step(abs(uv.y - .5), ltDiffS);\n    col = mix(col, RED, fill);      \n    \n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fetch data\n#define FD(x,y) texelFetch(iChannel1, ivec2(x, y), 0)\n// Read key toggle\n#define RKT(v) texelFetch(iChannel0, ivec2(v, 1), 0).x == 1.\n// Read key press\n#define RKP(v) texelFetch(iChannel0, ivec2(v, 1), 1).x == 1.\n// Read key click\n#define RKC(v) texelFetch(iChannel0, ivec2(v, 1), 2).x == 1.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if(y>2){\n    \tdiscard;\n\t}\n    \n    bool isUp = (RKT(87) || RKT(38));\n\tbool isRight = (RKT(68) || RKT(39));\n\tbool isDown = (RKT(83) || RKT(40));\n\tbool isLeft = (RKT(65) || RKT(37));    \n\n    // --------------\n    // Read data\n    // --------------\n\n    // Move data\n    vec4 mData = FD(0, 0);\n\n    vec2 mPos = mData.xy;\n    float mDir = mData.z;\n    if(iFrame == 1){\n        mDir = -1.;\n    }\n    float lastGameTick = mData.w;\n    \n    // Neighbor data\n    vec2 nPointPos = FD(1, 1).xy;\n\n    // Fruit data\n    vec4 fData = FD(1, 0);\n\n    float fFactor = fData.z;\n    float fX = floor((hash11(fFactor)-.5)*SIZE);\n    float fY = floor((hash11(fFactor + 100.)-.5)*SIZE);\n    vec2 fPos = vec2(fX, fY);\n\n    // Game data\n    vec4 gData = FD(2, 0);\n\n    float speed = gData.x;\n    if(iFrame == 1){\n        speed = 10.;\n    }\n    float lastEatTime = gData.y;\n    if(iFrame == 1){\n        lastEatTime = -100.;\n    }\n    float score = gData.z;\n\n    // --------------\n    // Process game logic\n    // --------------\n\n    float gameTick = floor(iTime*speed);\n\n    // Move position\n    bool shouldMove = lastGameTick != gameTick;\n    if(shouldMove){\n        if(mDir == 0.){\n            mPos.y += 1.;\n        }\n        if(mDir == 1.){\n            mPos.x += 1.;\n        }\n        if(mDir == 2.){\n            mPos.y -= 1.;\n        }\n        if(mDir == 3.){\n            mPos.x -= 1.;\n        }\n        lastGameTick = gameTick;\n    }\n\n\n    // Set direction\n    if(isUp){    \t\n        if(mPos + vec2(0., 1.) != nPointPos){\n        \tmDir = 0.;\n        }\n    }\n    if(isRight){\n        if(mPos + vec2(1., 0.) != nPointPos){\n            mDir = 1.;\n        }\n    \t\n    }\n    if(isDown){\n        if(mPos + vec2(0., -1.) != nPointPos){\n            mDir = 2.;\n        }    \t\n    }\n    if(isLeft){\n        if(mPos + vec2(-1., 0.) != nPointPos){\n            mDir = 3.;\n        }\n    \t\n    }\n\n    // Normalize position\n    if(mPos.x >= SIZE*.5){\n        mPos.x = -SIZE*.5;\n    }\n    if(mPos.x < -SIZE*.5){\n        mPos.x = SIZE*.5 - 1.;\n    }\n    if(mPos.y >= SIZE*.5){\n        mPos.y = -SIZE*.5;\n    }\n    if(mPos.y < -SIZE*.5){\n        mPos.y = SIZE*.5 - 1.;\n    }\n\n    bool fruitEaten = mPos == fPos;\n    if(fruitEaten){\n    \tfFactor += .1;\n        lastEatTime = iTime;\n        score+=1.;\n    }\n\n    // Write data\n    if(x == 0 && y == 0){\n    \tfragColor = vec4(mPos, mDir, lastGameTick);\n    }\n    if(x == 1 && y == 0){\n    \tfragColor = vec4(fPos, fFactor, 0);\n    }\n    if(x == 2 && y == 0){\n    \tfragColor = vec4(speed, lastEatTime, score, 0);\n    }\n\n    // iPoints\n    if(y == 1){\n        if(x == 0){\n            fragColor = vec4(mPos, 0, 0);\n        } else {\n            if(shouldMove){\n                for(int i=int(score+1.); i>=1; i-=1){\n                    if(x == i){\n                        // Neighbor point to exist\n                        vec2 nPointPos = FD(i-1, 1).xy;\n                        fragColor = vec4(nPointPos, 0, 0);\n                    }\n                }\n            } else {\n            \tfor(int i=1; i<=int(score+1.); i+=1){\n                    if(x == i){\n                        // Same point to exist\n                        vec2 iPointPos = FD(i, 1).xy;\n                        fragColor = vec4(iPointPos, 0, 0);\n                    }\n                }\n\n            }\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 16.\n\n#define PI2 6.2831852\n#define PI 3.1415926\n#define PI_2 1.5707963\n#define PI_4 0.78539815\n\n#define B2F(v) (v ? 1.: 0.)\n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nmat2 rot (float a){\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlyXDw", "name": "Mipmap, Texture & TextureLod", "author": "mla", "description": "Mipmapped textures use implicit differentiation to select a mipmap level. If uv changes a lot between adjacent pixels we get artefacts at the join (lower right - zoom in with xmag or similar). To fix use textureLod, or use linear or nearest filters.", "tags": ["texture", "mipmap", "texturelod"], "likes": 2, "viewed": 706, "published": 3, "date": "1582825023", "time_retrieved": "2024-07-30T21:21:43.207376", "image_code": "mat2 rot(float a) {\n  return mat2(sin(a), cos(a), -cos(a), sin(a));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 p = (fragCoord - .5*iResolution.xy )/iResolution.y;\n\n  float lod = log2(iChannelResolution[0].y/iResolution.y),\n    d = 55./6.283,\n    l = d* length(p) - 5.,\n    s = - (iTime+30.) * .01,\n    l0 = s * floor(l-.5) ,\n    l1 = s * floor (l+.5) ;\n\n  if (fragCoord.x < 0.5*iResolution.x) {\n    if (fragCoord.y < 0.5*iResolution.y) {\n      fragColor = texture(iChannel0, p*rot(l0));\n    } else \n      fragColor = textureLod(iChannel0, p*rot(l0),lod);\n  } else {\n    float k = smoothstep(-.8,.8, iResolution.y/d*(fract(l-.5)-.5)); \n    if (fragCoord.y < 0.5*iResolution.y) {\n      fragColor = mix( texture(iChannel0, p*rot(l0)),\n                       texture(iChannel0, p*rot(l1)),\n                       k);\n    } else {\n      fragColor = mix( textureLod(iChannel0, p*rot(l0), lod),\n                       textureLod(iChannel0, p*rot(l1), lod),\n                       k);\n    }\n  }\n}\n", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 69], [71, 71, 123, 123, 1008]], "test": "untested"}
{"id": "ttGXDw", "name": "CJA Kaleidoscope", "author": "pedroatma", "description": "Kaleidoscope shader by Maria Adelaide (mariaadelaide.com) for CJA project (https://cornelljournalofarchitecture.cornell.edu).", "tags": ["kaleidoscope"], "likes": 0, "viewed": 75, "published": 3, "date": "1582822219", "time_retrieved": "2024-07-30T21:21:43.974325", "image_code": "const float ANIMATION_DURATION = 20.0;\nconst float MOSAICS_NUM = 2.0;\n\nvec2 kaleidoCoords(vec2 coords)\n{\n    vec2 v;\n    \n    v = vec2(\n    \tcoords.x - 2.0 * mod(iTime / ANIMATION_DURATION, 1.0),\n        coords.y + 2.0 * mod(iTime / ANIMATION_DURATION, 1.0)\n    );\n    \n    if(v.x < -1.0)\n        v.x = 2.0 + v.x;\n    \n    if(v.x < 0.0)\n\t\tv.x = -v.x;\n    \n    if(v.y > 2.0)\n        v.y = v.y - 2.0;\n    \n   \tif(v.y > 1.0)\n        v.y = 2.0 - v.y;\n\n        \n    return v;\n}\n\nvec2 mirroredSetCoords(vec2 coords) {\n  \tvec2 v;\n    \n    if(coords.x < 0.5 && coords.y >= 0.5)\n    {\n        v = vec2(coords.x * 2.0, (coords.y - 0.5) * 2.0);\n    }\n    else if(coords.x >= 0.5 && coords.y >= 0.5)\n    {\n        v = vec2((1.0 - coords.x) * 2.0, (coords.y - 0.5) * 2.0);\n    }\n    else if(coords.x < 0.5 && coords.y < 0.5)\n    {\n        v = vec2(coords.x * 2.0, (0.5 - coords.y) * 2.0);\n    }\n    else\n    {\n        v = vec2((1.0 - coords.x) * 2.0, (0.5 - coords.y) * 2.0);\n    }\n    \n\treturn v;\n}\n\nvec2 mosaicCoords(vec2 coords)\n{\n    vec2 v;    \n    \n    v = mod(coords, vec2(1.0 / MOSAICS_NUM, 1.0 / MOSAICS_NUM)) * MOSAICS_NUM;\n        \n    return v;\n}\n\nvec2 transform(vec2 coords)\n{\n    vec2 v;\n    \n    v = kaleidoCoords(mirroredSetCoords(mosaicCoords(coords)));\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, transform(uv));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 104, 104, 472], [474, 474, 511, 511, 986], [988, 988, 1020, 1020, 1145], [1147, 1147, 1176, 1176, 1278], [1280, 1280, 1337, 1387, 1505]], "test": "untested"}
{"id": "wlS3W3", "name": "Reacty Diffusy", "author": "sixstring982", "description": "Gray Scott Reaction Diffusion", "tags": ["reactiondiffusiongrayscott"], "likes": 1, "viewed": 399, "published": 3, "date": "1582818802", "time_retrieved": "2024-07-30T21:21:44.737285", "image_code": "// If defined, only renders normals.\n// #define VIEW_NORMALS\n\n// Intensity of specular lighting.\n#define SHININESS 20.\n\n// How tall each RD cell appears to be.\n#define HEIGHT_COEFF 3.\n\n\nvec2 uvFromPx(in vec2 px) {\n    return px / iResolution.xy;\n}\n\nvec3 normal(in vec2 px) {\n    vec2 p1 = vec2(px.x     , px.y - 1.);\n    vec2 p2 = vec2(px.x - 1., px.y + 1.);\n    vec2 p3 = vec2(px.x + 1., px.y + 1.);\n    \n    float h1 = texture(iChannel0, uvFromPx(p1)).y * HEIGHT_COEFF;\n    float h2 = texture(iChannel0, uvFromPx(p2)).y * HEIGHT_COEFF;\n    float h3 = texture(iChannel0, uvFromPx(p3)).y * HEIGHT_COEFF;\n    \n    vec3 a = normalize(vec3(normalize(p1 - p2), h2 - h1));\n    vec3 b = normalize(vec3(normalize(p3 - p2), h2 - h3));\n    \n    return cross(a, b);\n}\n\nvec3 lighting(in vec3 ro, in vec3 normal, vec2 ab) {\n    vec3 light = vec3(10.5, 10.5, -40.5);\n    vec3 N = normal;\n    vec3 L = normalize(light - ro);\n    vec3 V = vec3(0., 0., -1.);\n    vec3 R = normalize(reflect(-L, N));\n\n    vec3 ambient = \n        vec3(0.1, 0.0, 0.2) * ab.y +\n        vec3(0.9, 0.9, 0.9) * ab.x;\n\tfloat diffuse = max(0.0, dot(N, L));\n    float spec = pow(max(0.0, dot(R, V)), 0.3 * SHININESS);\n    \n    return ambient * vec3(diffuse + spec);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ab = texture(iChannel0, uv).xy;\n    \n    #ifdef VIEW_NORMALS\n    fragColor = vec4(normal(fragCoord), 1.);\n    #else\n    fragColor = vec4(\n        lighting(vec3(uv, ab.y), normal(fragCoord), ab),\n        1.0); \n    #endif\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DA  1.\n#define DB   .5\n#define DT  1.\n#define FEED .055\n#define KILL .062\n\n#define DRES vec2(1.0) / iResolution\n\n#define OZ vec2(1.0, 0.0)\n\n\nvec2 uvFromPx(in vec2 px) {\n    return px / iResolution.xy;\n}\n\nfloat feed(in vec2 px) {\n    // return 0.01;\n    // return uvFromPx(px).y * 0.09 + 0.01;\n    return uvFromPx(iMouse.xy).y * 0.09 + 0.01;\n}\n\nfloat kill(in vec2 px) {\n    // return 0.03;\n    // return uvFromPx(px).x * 0.025 + 0.045;\n    return uvFromPx(iMouse.xy).x * 0.025 + 0.045;\n}\n\nvec2 laplacian(in vec2 p) {\n    return \n        texture(iChannel0, uvFromPx(vec2(p.x - 1., p.y - 1.))).xy * vec2(0.05) +\n        texture(iChannel0, uvFromPx(vec2(p.x     , p.y - 1.))).xy * vec2(0.2 ) +\n        texture(iChannel0, uvFromPx(vec2(p.x + 1., p.y - 1.))).xy * vec2(0.05) +\n        \n        texture(iChannel0, uvFromPx(vec2(p.x - 1., p.y     ))).xy * vec2(0.2 ) +\n        texture(iChannel0, uvFromPx(vec2(p.x     , p.y     ))).xy * vec2(-1. ) +\n        texture(iChannel0, uvFromPx(vec2(p.x + 1., p.y     ))).xy * vec2(0.2 ) +\n        \n        texture(iChannel0, uvFromPx(vec2(p.x - 1., p.y + 1.))).xy * vec2(0.05) +\n        texture(iChannel0, uvFromPx(vec2(p.x     , p.y + 1.))).xy * vec2(0.2 ) +\n        texture(iChannel0, uvFromPx(vec2(p.x + 1., p.y + 1.))).xy * vec2(0.05);\n}\n\nvec2 initialState(in vec2 p) {\n    vec2 uv = (p / iResolution.xy) - vec2(0.5);\n    return mix(OZ, OZ.yx, step(0.2, length(uv)));\n}\n\nvec2 nextState(in vec2 p) {\n    vec2 oldState = texture(iChannel0, uvFromPx(p)).xy;\n    float a = oldState.x;\n    float b = oldState.y;\n    vec2 lp = laplacian(p);\n    return vec2(\n        a + (DA * lp.x - a * b * b + feed(p) * (1. - a)) * DT,\n        b + (DB * lp.y + a * b * b - (kill(p) + feed(p)) * b) * DT);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float initMix = step(0.1, iTime);\n    // fragColor = vec4(initialState(fragCoord), 0.0, 0.0);\n    fragColor = vec4(mix(initialState(fragCoord), nextState(fragCoord), initMix), 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlS3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 213, 213, 247], [249, 249, 274, 274, 757], [759, 759, 811, 811, 1224], [1226, 1226, 1281, 1281, 1556]], "test": "untested"}
{"id": "tlGXWW", "name": "Quantum Confined Particle", "author": "Txoka", "description": "you can also use this as example of many other quantum phenomenon, for example tunneling\n\nmouse = move potential\nupper right corner = static potential\nspace = reset\n\nlook at my first comment (speed script)\n\n", "tags": ["wave", "physics", "quantum", "particle", "atom", "potential", "differential", "schrodinger", "confinement", "coldatom", "tunneling"], "likes": 4, "viewed": 454, "published": 3, "date": "1582818333", "time_retrieved": "2024-07-30T21:21:45.531163", "image_code": "/*\nACCELERATE THE SHADER:\n(function(){if(Effect.prototype.Paint.toString().length>1000){_Paint=Effect.prototype.Paint;} Effect.prototype.Paint = function(...args){for(var i=0; i<50;i++){_Paint.apply(this,args);}}})()\n*/\n\nconst float gamma=1.8;\nconst float inv_gamma=1./gamma;\n\nfloat intensity(float x){return pow(x,gamma);}\nvec3 intensity(vec3 x){return pow(x,vec3(gamma));}\nfloat color(float x){return pow(x,inv_gamma);}\nvec3 color(vec3 x){return pow(x,vec3(inv_gamma));}\n\nvoid mainImage(out vec4 Q,in vec2 U){\n    vec2 uv=(U*2.-R.xy)/R.y;\n    vec4 v=tf(ivec2(U.x,0));\n    float energy=texelFetch(iChannel1,ivec2(0),0).r;\n    \n    float line0=v.x-uv.y;\n    line0/=fwidth(line0);\n    \n    float line1=v.w+v.z-uv.y;\n    line1/=fwidth(line1);\n    \n    float line2=v.y-uv.y;\n    line2/=fwidth(line2);\n    \n    float line3=v.z-uv.y;\n    line3/=fwidth(line3);\n    \n    vec3 light=vec3(0);\n    light.r+=intensity(smoothstep(1.,0.,abs(line0)))*0.4;\n    light.rg+=intensity(smoothstep(1.,0.,abs(line1)));\n    light.b+=intensity(smoothstep(1.,0.,abs(line2)))*0.5;\n    light.g+=intensity(smoothstep(1.,0.,abs(line3)));\n    \n    vec3 col=color(light);\n    \n    Q=vec4(col,0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 Q,in vec2 U){\n    if(int(U.y)==0){\n        ivec2 id=ivec2(U.x,0);\n        \n        //WAVE STUFF\n        vec3 point_value=tf(id).xyz;\n        vec3 local_media=\n            tf(id+ivec2( 1,0)).xyz+\n            tf(id+ivec2(-1,0)).xyz;\n        local_media*=.5;\n        \n        \n        vec3 grad=local_media-point_value;\n        \n        Q.xy=point_value.xy;\n        \n        //SCHRODINGER WAVE\n       \tQ.z=-Q.x;\n        Q.x+=Q.y+grad.x-Q.x*point_value.z*FORCE_MULTIPLYER/R.y;\n        Q.y=Q.z;\n        \n        //Q.xy=grad.x*vec2(1,0)+Q.xy*mat2(1,1,-1,0);\n        \n\n        //INITIALIZATION\n        float x=(U.x*2.-R.x)/R.y;\n        if(iFrame==0||key(kSpace))Q.xy=init(x,U.x);\n        \n        Q.z=0.;\n        //MOUSE\n        vec2 m=(M.xy*2.-R.xy)/R.y;\n        if(M.z>0.){\n            float k=x-m.x;\n            Q.z=m.y*exp(-k*k*30.);\n        }\n        if(all(equal(M.xyz,vec3(0)))||dot2(M.xy-R.xy)<400.){\n            #ifdef MOVE\n            x-=cos(float(iFrame)/60./40.*2.)*0.5-0.5;\n            #endif\n            Q.z=-.5*exp(-x*x*30.);\n        }\n        if(id.x==0||id.x==int(R.x)-1)Q.x=0.;\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n#define M iMouse\n#define tf(id) texelFetch(iChannel0,id,0)\n\nfloat SMOOTHNESS=0.9;\nfloat FORCE_MULTIPLYER=45.;\n\nfloat dot2(vec2 x){return dot(x,x);}\nconst float pi=atan(1.)*4.;\n\n\n#define key(id) texelFetch(iChannel2,ivec2(id,0),0).x>0.\nint kSpace=32;\n\n//#define MOVE\n\nvec2 init(float x, float X){\n    //x+=1.;\n    vec2 W=vec2(0);\n\t//W.x=cos(50.*x)*exp(-100.*x*x)*0.2;\n    //W.y=sin(50.*x)*exp(-100.*x*x)*0.2;\n    \n \t//W.x=cos(X*pi/2.)*exp(-100.*x*x)*0.2;\n    //W.y=sin(X*pi/2.)*exp(-100.*x*x)*0.2;\n    \n   \t//W.x=sin(X*pi/2.)*exp(-190.*x*x)*0.6;\n   \t//W.y=0.;\n    \n    W.x=exp(-190.*x*x)*0.3;\n    W.y=0.;\n    \n    //W.x=-0.5;\n    //W.y=0.5;\n    \n    return W;\n}", "buffer_c_code": "void mainImage(out vec4 Q, in vec2 U){\n    if(int(U.y)==0){\n        ivec2 id=ivec2(U.x,0);\n        vec3 v=texelFetch(iChannel0,id,0).xyz;\n        \n        Q.xyz=v;\n        Q.w=mix(\n            length(v.xy),\n            texelFetch(iChannel1,id,0).w,\n            SMOOTHNESS\n        );\n    \tif(iFrame==0||key(kSpace)){\n            float x=(U.x*2.-R.x)/R.y;\n        \tQ.xy=init(x,U.x);\n            Q.w=length(Q.xy);\n        }\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 302, 302, 323], [324, 324, 347, 347, 374], [375, 375, 396, 396, 421], [422, 422, 441, 441, 472], [474, 474, 511, 511, 1166]], "test": "untested"}
{"id": "WtyXWm", "name": "Day 70", "author": "jeyko", "description": "Two walls with some modded fbm", "tags": ["mdtmjvm"], "likes": 23, "viewed": 663, "published": 3, "date": "1582815914", "time_retrieved": "2024-07-30T21:21:46.413803", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 100.;\n    float scale = 0.00 + dot(uvn,uvn)*2.;\n    scale *= pow(abs(sin(T/2.)), 10.);\n    float chromAb = dot(uvn,uvn)*0.01;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.001;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial += texture(iChannel0, target)*(1.) ;\n    }\n    \n    radial /= steps;\n    \n    fragColor = texture(iChannel0, uv)*0.6 + radial*1.;\n    fragColor *= 0.7;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define FL_H 0.1\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin(6.28*((c)*(d) + (e))))\n\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\nvec3 glowC = vec3(0);\n\nfloat randomO(vec2 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.625)*225.5235);\n} \n\nfloat random(vec2 u){\n\treturn texture(iChannel0, (u/256.)).y;\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = smoothstep(0.5,1.,fract(p));\n    f = smoothstep(0.7,1.,f);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nvec2 valueNoise(float p){\n\tvec2 a = texture(iChannel0, vec2(floor(p))/256.).xy;\n\tvec2 b = texture(iChannel0, vec2(floor(p) + 1.)/256.).xy;\n    return mix(a,b,smoothstep(0.,1.,fract(p)));\n}\n\nfloat fbm(vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 5; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n\n#define pmod(p,x) mod(p,x) - x*0.5\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    \n    float n = fbm(p.xz)*1.;\n    float m = pow(abs(sin(p.z*0.03)),10.);\n    n *= 1. + m*2.;\n    //n = pow(n*1., 4.)*3.;\n    \n    p.xy *= rot(sin(p.z*0.9 + sin( p.x*2. + p.z + iTime*0.1)*0.2)*0.1);\n    \n    \n    float flTop =(-p.y + FL_H + n*0.7)*0.3;\n    d = dmin(d, vec2(flTop,1.));\n    \n    \n    float flBot =(p.y + FL_H + n*0.7)*0.3;\n    \n    d = dmin(d, vec2(flBot,1.));\n    \n    //d = dmin(d, vec2(length(p) - 0.1, 2.));\n    \n    vec3 z = p;\n    p.xz = pmod(p.xz, 0.6);\n    \n    p.y = abs(p.y);\n    p.y -= FL_H*0.7 + n*0.7;\n    float dBalls = length(p);\n    vec3 q = abs(p) - 0.04;\n    \n    \n    float dPipes = max(q.x,q.y);\n    float dPipesB = max(q.y,q.z);\n    //d = dmin(d, vec2(dPipes, 2.));\n    \n    float atten = pow(abs(sin(z.z*0.2 + iTime*0.2)), 20.);\n    float attenB = pow(abs(sin(z.z*0.02  + sin(z.x + iTime)*0.4 + sin(z.y*3.)*1. + iTime*0.5)), 100.);\n    float attenC = pow(abs(sin(z.z*0.1  + sin(z.x + iTime)*0.4 + sin(z.y*3.)*4. + iTime*0.2)), 200.);\n    \n    vec3 col = pal(0.4,0.6 - attenC,vec3(0.1 + pow(abs(sin(iTime*1.)), 40. )*0.005,2.2,0.3),0.5 + sin(iTime)*0.005,0.5 - attenB*0.6);\n    //vec3 col = pal(0.4,0.6,vec3(0.1 + pow(abs(sin(iTime*1.)), 40.)*0.0,2.2,0.3),0.5 + sin(iTime)*0.01,0.5 );\n    \n    //vec3 col = pal(0.4,0.6,vec3(0.1 + pow(abs(sin(iTime*1.)), 40.)*0.1,2.2,0.3),0.5 + sin(iTime)*0.01,0.5 - attenB*0.6);\n\n    vec3 colB = pal(0.4,0.6,vec3(0.1 ,2.2,0.3),0.5 ,2.)*30.5;\n    \n    float sc = 60. - atten*55.;\n    glowB += exp(-dPipes*sc)*col;\n    glowB += exp(-dPipesB*sc)*col;\n    //glowC += exp(-dBalls*90.)*colB;\n    //glowB += 0.1/(0.9 + dPipes*dPipes);\n    d.x *= 0.7;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro; t = 0.; hit = false;\n    for (int i = 0; i < 190; i++){\n    \td = map(p);\n        glow += exp(-d.x*20.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;        \n    }\n\n    return d;\n}\n\n\n#define mx (10.*iMouse.x/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float m = pow(abs(sin(T/2.)), 5.);\n    uv *= 1. + dot(uv,uv)*(1. - pow(m,2.)*1.);\n    \n    \n    \n    //uv.xy *= rot(0.1)\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += mx*2.;\n    ro.xy += valueNoise(iTime*40.)*(0.04)*m; // camshake\n    \n    ro.z += iTime*SPEED - sin(T)*SPEED;\n    \n    \n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    rd.xy *= rot(sin(iTime)*0.04);\n    \n    //ro += rd*texture(iChannel0, (uv*200. + iTime*9.)).x*2.;\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if (hit){\n    \t\n        \n    }\n\t\n    \n    glowB = max(glowB, 0.);\n    glowB = pow(glowB, vec3(1./0.45));\n    col += glowB*0.0004;\n    \n    col += glowC*0.004;\n    col += glow*0.0001;\n    col = mix(col, vec3(0.55,0.25,0.2), smoothstep(0.,1., t*0.02) );\n    \n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define iTime (iTime + 2.5)\n    #define T iTime\n    \n    #define SPEED 4.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 896]], "test": "untested"}
{"id": "WlGXDm", "name": "Everything ends where it started", "author": "hamoid", "description": "Two set of rings rotating in opposing directions, at different speeds.\n\nThe rotation breaks the antialias. Any suggestions?", "tags": ["circles", "rings"], "likes": 4, "viewed": 348, "published": 3, "date": "1582815522", "time_retrieved": "2024-07-30T21:21:47.280485", "image_code": "mat2 rot(float a) {\n    return mat2(sin(a), cos(a), -cos(a), sin(a));\n}\nvoid mainImage( out vec4 fragColor, in vec2 pos ) {\n    vec2 uv = (pos-0.5*iResolution.xy)/iResolution.y;\n    float l = 55.*length(uv);\n    vec3 ring = vec3(smoothstep(-0.1, 0.1, sin(l)));\n    \n    float l2 = l / 6.2831855 - 5.;\n    l2 = iTime * floor(l2) * .01;\n    \n    fragColor = vec4( \n        mix(\n            texture(iChannel0, uv*rot(-l2)).rgb * vec3(0.98, 0.72, 0.49), \n            texture(iChannel1, uv*rot( l2)).rgb * vec3(0.36, 0.62, 0.63), \n            ring),1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [72, 72, 123, 123, 551]], "test": "untested"}
{"id": "WtGXWm", "name": "Echeveria II", "author": "tdhooper", "description": "This time I'm distributing leaves on a hemisphere. Using brute-force AO as the usual approach looks bad with this model; it's slow so you can toggle it with the define\n\n[url=https://media.giphy.com/media/Y0mfLzgzBIfgmCqyqF/source.gif]GIF version[/url]", "tags": ["plant", "succulent"], "likes": 205, "viewed": 8145, "published": 3, "date": "1582809862", "time_retrieved": "2024-07-30T21:21:48.271835", "image_code": "//#define AA 3\n#define AO\n//#define GIF\n\n// voronoi - adapted from iq https://www.shadertoy.com/view/ldl3W8\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi( in vec2 x )\n{\n    vec2 cell = floor(x);\n\n    float d = 1e12;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 offset = vec2(float(i),float(j));\n        vec2 pos = hash2( cell + offset );\n        vec2 r = cell + offset + pos;\n        d = min(d, length(x - r));\n    }\n\n    return d;\n}\n\n// HG_SDF \n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n\n// Modelling\n\nfloat time;\nbool lightingPass;\nmat3 modelMat;\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n};\n\nModel leaf(vec3 p, vec3 cellData) {\n    //cellData = vec3(0,0,.1);\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    //cell.x = 0.;\n    //cell.y = .1;\n    //cellTime = .2;\n\n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    // orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n    len = pow(len, .33);\n    float llen = len;\n\n\n    if (cellTime > 0.) {\n\n        // wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        // wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,.4));\n        float wedge2 = -dot(p, n);\n        wedge2 = max(wedge2, dot(p, n * vec3(1,1,-1)));\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len / 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - .05;\n        d2 = max(d2, top);\n        \n        float d3 = smax(d2, wedge, .05);\n        float d4 = smax(d2, wedge2, .05);\n        wedges = smin(wedge, wedge2, .01);\n        d3 = smin(d3, d4, .01);\n        d = d3;\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz / len;\n        return Model(d, p, uv, cell, wedges, slice, len);\n    }\n\n\treturn Model(d, p, vec2(0), vec2(0), 0., 0., 0.);\n}\n\nvec3 calcAlbedo(Model model) {    \n    vec3 col = vec3(.15,.15,.4);\n\n\tvec3 p = model.p;\n    float len = model.len;\n    vec2 cell = model.cell;\n    float wedges = model.wedges;\n    float slice = model.slice;\n    vec2 uv = model.uv;\n    \n    float v = voronoi((uv+4.)*30.);\n    float v2 = voronoi((uv+4.)*4.+cell.x);\n\n    col = mix(col, vec3(.125,.2,.4), 1.-v2);\n    float tip = length(p - vec3(0,.2,len*.9));\n\n    tip = smoothstep(.5, .0, tip);\n    tip *= smoothstep(.07, .0, abs(slice+.01));\n    tip *= smoothstep(-.2, .0, wedges);\n    tip = pow(tip, 1.5);\n    col = mix(col, vec3(1,.2,.5), tip);\n\n    float vs = 1.-uv.y*1.;\n    vs *= smoothstep(.0, -.1, wedges);\n    vs *= smoothstep(.0, .05, abs(slice));\n    v = smoothstep(vs + .1, vs - .5, v*1.5);\n    col = mix(col, vec3(.05,.05,.2), v*v2);\n\n    col *= mix(vec3(1), vec3(.5,5.,1.8), smoothstep(.2, 1.8, cell.y) * .75);\n  \n    return col;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t\n) {\n\n    float sz = maxBloomOffset + PI / 2.;\n\n    cell = transform * cell;\n\n    // Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    // Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch / sz / stretchStart;\n    cell.y = max(cell.y, .5/stretchStart); // clamp, not sure why this magic number\n    cell.y /= stretch / sz / stretchStart;\n    cell = transform * cell;\n\n    // Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    // calculate cell time\n    float y = cell.y * (stretch / sz);\n    float cellAppearTime = (stretchStart - y) / (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x / cc.y);\n    float scale = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1./scale,0,0,1./scale);\n\tphyllotaxis = mRot * mScale;\n}\n\nModel bloom(vec3 p, float t) {\n\n    p.y -= .05;\n\n    vec2 move = vec2(0, t);\n    float stretchStart = .25;\n    float stretchEnd = 1.;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI / 2.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n\n\tModel res = Model(1e12, p, vec2(0), vec2(0), 0., 0., 0.);\n    //res.d = length(p) - 1.; return res;\n\n    // compile speed optim from IQ\n    for( int m=min(iFrame,0); m<3; m++ )\n    for( int n=min(iFrame,0); n<3; n++ )\n    {\n    \tres = opU(res, leaf(p, calcCellData(cell, vec2(m, n) - 1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t)));\n    }\n\n    return res;\n}\n\nModel map(vec3 p) {\n    p *= modelMat;\n    float t;\n    \n    float bound = length(p) - 1.3;\n    if (bound > .01 && ! lightingPass) {\n\t\treturn Model(bound, p, vec2(0), vec2(0), 0., 0., 0.);\n    }\n\n    pR(p.xy, time * -PI);\n\n    vec3 pp = p;\n    \n    float side = sign(p.y);\n    p.y = abs(p.y);\n\tp.z *= side;\n\n    t = time + .5 * side;\n    t = sin(t * PI - PI/2.) * .5 + .5;\n    pR(p.xz, time * PI);\n    Model model = bloom(p, t);\n    \n    if (abs(p.y) < .34) {\n        p = pp;\n    \tside *= -1.;\n        p.yz *= side;\n        t = time + .5 * side;\n    \tt = sin(t * PI - PI/2.) * .5 + .5;\n        pR(p.xz, time * PI);\n        Model model2 = bloom(p, t);\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/3dyXzD\nvec3 randDir( vec3 n, vec2 seed ) {\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n    vec3  vv = cross( uu, n );\n    \n    float ra = sqrt(seed.y);\n    float rx = ra*cos(6.2831*seed.x); \n    float ry = ra*sin(6.2831*seed.x);\n    float rz = sqrt( 1.0-seed.y );\n    vec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nfloat hitLength(vec3 pos, vec3 dir, float maxDist) {\n    float len = 0.;\n    const int steps = 15;\n    float dist = maxDist / float(steps);\n    vec3 rayPos;\n    for (int i = 0; i < steps; i++) {\n        len += dist;\n        dist = map(pos + dir * len).d;\n        if (abs(dist) < .001) {\n            break;\n        }\n        if (len > maxDist) {\n            len = maxDist;\n            break;\n        }\n    }\n    return len / maxDist;\n}\n\nfloat calcAO(vec3 pos, vec3 nor, vec2 seed, float maxDist) {\n    float len = 0.;\n    const float SAMPLES = 3.;\n    for (float x = 0.; x < SAMPLES; x++)\n    for (float y = 0.; y < SAMPLES; y++)\n    {\n        vec2 s = seed + vec2(x, y) / SAMPLES;\n        s = hash2(s);\n        vec3 dir = randDir(nor, s);\n        len += hitLength(pos, dir, maxDist);\n    }\n\n    len /= SAMPLES * SAMPLES;\n    return len;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nmat3 rotX(float a) {\n    return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));\n}\n\nmat3 rotY(float a) {\n    return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));\n}\n\nmat3 rotZ(float a) {\n    return mat3(cos(a),-sin(a),0, sin(a),cos(a),0, 0,0,1);\n}\n\nfloat pat(vec2 uv) {\n    vec2 p = vec2(atan(uv.x/uv.y), log(length(uv)));\n   \n   \tp *= phyllotaxis;\n    p = p * 4.;\n    \n    p -= vec2(0,8) * time;\n\n    p = mod(p, 1.);\n    float d = length(p - .5) - .1;\n    float fw = fwidth(d);\n\n    d = abs(d) - .01;\n    d /= fw;\n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime / 4., 1.) + .35;\n    time = mTime;\n    \n    calcPhyllotaxis();\n    modelMat = rotZ(-.9) * rotX(.05) * rotY(-1.1);\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    // time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 camPos = vec3(0,0,-2.6);\n        #ifdef GIF\n        \tcamPos.z = -2.8;\n       \t#endif\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-.05,0), 0.);\n        vec3 rayDirection = normalize( camMat * vec3(p.xy,1.8) );\n\n        vec3 rayPosition = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        Model model;\n\n        lightingPass = false;\n        \n        for (int i = 0; i < 300; i++) {\n            rayLength += dist;\n            rayPosition = camPos + rayDirection * rayLength;\n            model = map(rayPosition);\n            dist = model.d;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 5.) {\n                bg = true;\n                break;\n            }\n        }\n        \n        lightingPass = true;\n        \n        col = vec3(.4,.4,1);\n        #ifndef GIF\n        \tcol = mix(col, vec3(.0,1.5,1.5)*1.5, (1.-pat(p))*.5);\n        \tcol = mix(col, vec3(.63,.7,1), smoothstep(2.5, .5, length(p)));\n        #else\n        \tcol = mix(col, vec3(.63,.7,1), .95);\n        #endif\n        col *= vec3(.9,1.,1.);\n        col += .1;\n        \n        //bg = true;\n        \n        if ( ! bg) {\n\n            vec3 pos = rayPosition;\n            vec3 rd = rayDirection;\n            vec2 seed = hash2(p + time);\n            \n            #ifndef AA\n            \tseed *= .0000001;\n            #endif\n            \n            vec3  nor = calcNormal(pos);\n            \n            float occ = 1.;\n            #ifdef AO\n            \tocc = calcAO(pos, nor, seed, .85);\n            \tocc = clamp(pow(occ*1.25, 1.5), 0., 1.);\n            #endif\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            vec3 lin = vec3(0);\n            lin += 1.70 * amb * vec3(1.30,1.00,0.70) * occ;\n            lin += 0.90 * amb * vec3(0.30,0.80,1.30);\n            lin += 1.00 * fre * vec3(1.00,1.00,1.00) * occ;\n\n\n            vec3 albedo = calcAlbedo(model);\n            col = albedo * lin;\n            \n            //col *= mix(vec3(1), vec3(.0,.5,.7)*.5, 1.-occ);\n\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    col = tot;\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 131, 131, 224], [226, 226, 254, 254, 555], [636, 636, 668, 668, 713], [715, 715, 753, 753, 864], [866, 866, 905, 905, 936], [938, 938, 988, 988, 1031], [1033, 1033, 1074, 1074, 1118], [1301, 1301, 1336, 1367, 3061], [3063, 3063, 3093, 3093, 3957], [3959, 3959, 4157, 4157, 4906], [4908, 4908, 4937, 4937, 5009], [5029, 5029, 5053, 5053, 5310], [5312, 5312, 5342, 5342, 6162], [6164, 6164, 6183, 6183, 6877], [6879, 6948, 6974, 6974, 7175], [7177, 7218, 7253, 7253, 7565], [7567, 7567, 7619, 7619, 8001], [8003, 8003, 8063, 8063, 8405], [8407, 8407, 8471, 8471, 8649], [8651, 8651, 8671, 8671, 8732], [8734, 8734, 8754, 8754, 8815], [8817, 8817, 8837, 8837, 8898], [8900, 8900, 8920, 8920, 9212]], "test": "untested"}
{"id": "3tGXWm", "name": "bug: cond can't return struct", "author": "FabriceNeyret2", "description": "conditional ?: can't return struct.\nTurn #if 0 into 1 ", "tags": ["glsl", "bug"], "likes": 0, "viewed": 289, "published": 3, "date": "1582809837", "time_retrieved": "2024-07-30T21:21:49.032800", "image_code": "struct S { int a; };\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    S c,  c0 = S(0), c1 = S(1);\n\n#if 0\n    c = U.x > 10. ? c0 : c1 ;    // does not compile\n  //c = U.x > 10. ? S(0) : S(1); // does not compile\n#else\n    U.x > 10. ? c = S(0), 0 : ( c = S(1) , 1 );\n#endif\n\n    O = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 60, 60, 286]], "test": "untested"}
{"id": "WtySWm", "name": "Cellular Automata Technicol (459", "author": "FabriceNeyret2", "description": "simplified from [url]https://shadertoy.com/view/tlKSWD[/url] (1823 chars)\n\ncould it be shorter ? :-)", "tags": ["automata", "cellular", "short", "technicolor", "golf"], "likes": 4, "viewed": 324, "published": 3, "date": "1582808269", "time_retrieved": "2024-07-30T21:21:49.796758", "image_code": "// simplified from https://shadertoy.com/view/tlKSWD (1823 chars)\nvoid mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define L(t) L[ ( t + iFrame / int(max(R.x,R.y)) ) % L.length() ]                  //\n#define V(s) int( texelFetch(iChannel0, ivec2( C+R -D + s vec2(-D.y,D) ),0).a > 0.)//\nint[] L = int[]( 22, 30, 45, 54, 57, 60, 62, 73, 75, 86, 89, 110);                 //\n#define mi                                              \\\n    vec2  R = iResolution.xy/2., D = O.wx,              \\\n          C = U-R, A = abs(C);                          \\\n    int   r =   C.x >  A.y ?           L( )             \\\n              : C.y >  A.x ? D = D.yx, L(1)             \\\n              : C.x < -A.y ? D =-D,    L(2)             \\\n              :            ( D =-D.yx, L(3) ),          \\\n          k = V(-) *4 + V(0.*) *2 + V();                \\\n    float l = length( C -= 5.*D ),                      \\\n          d = dot(C,D);                                 \\\n    O =   d*d < 1.  ? vec4( l > 1.)                     \\\n        : d/l < .707 || (r >> k) % 2 < 1 ? O-O          \\\n        : .6 + .6 * cos( .78*vec4(k)  + vec4(0,23,21,0) );", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlKSWD", "name": "Cellular Automata in Technicolor", "author": "mla", "description": "Added some colour to [url]https://www.shadertoy.com/view/3tGXDD[/url] by lucastakejame - set pixel colour according to which rule element fired for that pixel, so eight different colours altogether.", "tags": ["automata", "cellular", "technicolor"], "likes": 12, "viewed": 475, "published": 3, "date": "1582794207", "time_retrieved": "2024-07-30T21:21:50.559718", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.14159265359;\n\nvec4 t(vec2 fragCoord) {\n    return texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n\n// Rotate by 90 degrees\nvec2 zRot(vec2 p)\n{\n    return vec2(-p.y, p.x);\n}\n\nstruct CA\n{\n\tvec2 center;\n    // time direction\n    vec2 dir;\n    uint rule;\n};\n\n// interesting rules\nint[] RLS = int[](22, 30, 45, 54, 57, 60, 62, 73, 75, 86, 89, 110);\n\nfloat next(vec2 idxCenter, CA c)\n{\n    uint id = 0U;\n    \n    // perpendicular to time direction\n    vec2 dirRot = zRot(c.dir);\n    \n    for (int i = -1; i <= 1; i++) {\n        vec2 offset = dirRot*float(i);\n        id <<= 1;\n        id += uint(t(idxCenter + offset - c.dir).a);\n    }\n    \n   \t// 111 110 101 100 011 010 001 000 ids\n    // 0x00011110 rule 30 in binary\n    \n    // rule tour\n    // ruleN = int(mod(iTime/10., exp2(exp2(float(INPUT_COUNT)))));\n    \n    // tip from FabriceNeyret2 \n    return float(((c.rule >> id) & 1U)*(id + 1U));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 runCA(CA c, vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 dist = fragCoord - c.center;\n    float d = dot(dist, c.dir);\n    \n\t// draw horizontal line with 1 black dot\n    if( abs(d) < 1.0)\n    {\n       \t// initial condition\n        float val = (length( fragCoord - c.center) < 1.)?0.:1.;\n        fragColor = vec4(val);\n    }\n\t// 0 whats behind the line and out of a 45 degree cone\n    else if( d < 0. || dot(normalize(dist), c.dir) < cos(PI/4.))\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        float c = next(fragCoord,c);\n        fragColor = c == 0.0 ? vec4(0) : vec4(hsv2rgb(vec3((c-1.0)/8.0,1,1)),1);\n    }\n    return fragColor;\n}\n\nuint getrule(int t) {\n\treturn uint(RLS[t%RLS.length()]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CA c;\n    vec2 p = fragCoord - vec2(iResolution.xy/2.);\n    \n    // Set 4 CA growing in perpendicular directions\n    int t = 2*iFrame/int(max(iResolution.x,iResolution.y));\n    if(p.x >  abs(p.y)){\n    \tc.rule = getrule(t);\n        c.dir = vec2(1, 0);\n    } else if(p.y >  abs(p.x)){\n    \tc.rule = getrule(t+1); \n        c.dir = vec2(0, 1);\n    } else if(p.x < -abs(p.y)) {\n        c.rule = getrule(t+2);\n        c.dir = vec2(-1, 0);\n    } else {\n        c.rule = getrule(t+3);\n        c.dir = vec2(0, -1);\n    }\n\n    c.center = vec2(iResolution.xy/2.0) + 5.0*c.dir;\n\n    fragColor = runCA(c, fragCoord);\n \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 118]], "test": "untested"}
{"id": "wtKXDW", "name": "Square to Cubemap", "author": "iq", "description": "Through Octahedron projection.", "tags": ["3d"], "likes": 9, "viewed": 734, "published": 3, "date": "1582783173", "time_retrieved": "2024-07-30T21:21:51.348609", "image_code": "vec3 square_to_cube( in vec2 v )\n{\n    // Rune Stubbe's version, much faster than original\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    float t = max(-nor.z,0.0);\n    nor.x += (nor.x>0.0)?-t:t;\n    nor.y += (nor.y>0.0)?-t:t;\n    return nor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // unit square \n    vec2 uv = fragCoord/iResolution.xy;\n\n    // to cube\n    vec3 dir = square_to_cube(2.0*uv-1.0);\n    \n    // sample cube (do max axis division internally)\n    vec3 col = texture( iChannel0, dir ).xyz;\n    \n    // mark octahedron faces\n    col *= 1.0 + 0.4*sign(dir)*smoothstep(-0.1,0.1,sin(2.0*iTime));\n        \n    // output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 90, 252], [254, 254, 311, 331, 692]], "test": "untested"}
{"id": "ttVSDW", "name": "Mandelbrot - perturbation", "author": "iq", "description": "My take on a perturbation method for the Mandelbrot set, which provides great precision benefits without any precomputation or use of double precision numbers", "tags": ["2d", "mandelbrot", "iteration", "perturbation"], "likes": 54, "viewed": 4114, "published": 3, "date": "1582782121", "time_retrieved": "2024-07-30T21:21:52.202326", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is my own take on the orbit perturbation idea, but\n// using a more direct method than most implementations.\n//\n// The trick is that if the reference orbit is in the interior\n// of the M-set, it won't diverge and numbers will stay sane.\n// Then, the nearby points of the plane will produce orbits that\n// will deviate from the reference orbit just a little, little\n// enough that the difference can be expressed with single\n// precision floating point numbers. So this code iterates the\n// reference orbit Zn and also the current orbit Wn in delta form:\n//\n// Given\n//\n// Zn and Wn = Zn + Zn\n// \n// Then\n//\n// Zn+1 = f(Zn) = Zn + C\n// Wn+1 = f(Wn) = f(Zn+Zn) = (Zn+Zn) + C + C = \n//              = Zn + Zn + 2ZnZn + C+C = \n//              = Zn+1 + Zn(Zn + 2Zn) + C = \n//              = Zn+1 + Zn+1\n//\n// So, what we need to iterate is\n//\n// Zn+1 = Zn(Zn + 2Zn) + C\n// Zn+1 = (Zn + C) + 2ZnZn  --> delta-orbit (Wn-Zn)\n//  Zn+1 = ( Zn +  C)             --> periodic orbit, doesn't diverge\n\n\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n\nfloat mandelbrot(vec2 c)\n{\n    float n = -1.0;\n    vec2 z = vec2(0.0);\n    for( int i=0; i<6000; i++ )\n    {\n        z = cmul(z,z) + c;\n        if( dot(z,z)>4.0 ) { n=float(i); break; }\n    }\n    return n;\n}\n\nfloat mandelbrot_perturbation( vec2 c, vec2 dc )\n{\n    vec2 z  = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    float n = -1.0;\n    for( int i=0; i<6000; i++ )\n    {\n        dz = cmul(2.0*z+dz,dz) + dc;  // dz = cmul(dz,dz)+dc + 2.0*cmul(z,dz);\n        \n        z  = cmul(z,z)+c; // this could be precomputed since it's constant for the whole image\n        \n        // instead of checking for Wn to escape...\n        // if( dot(z+dz,z+dz)>4.0 ) { n=float(i); break; }\n        // ... we only check Zn, since Zn is periodic and can't escape\n        if( dot(dz,dz)>4.0 ) { n=float(i); break; }\n    }\n    return n;\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input\n    float time = iTime+0.2;\n    \n    float s = (iMouse.z<0.001) ? -cos(time*2.0)*1.8 : (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA))-iResolution.xy)/iResolution.y;\n    #else\n        vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    #endif\n    \n        // viewport\n        float zoom; vec2 c;\n        if( sin(time)>0.0 ) { zoom=1.5e-6; c=vec2(-1.1900443,0.3043895); }\n        else                { zoom=1.0e-6; c=vec2(-0.7436441,0.1318255); }\n\n        // mandelbrot\t\n        vec2 dc = p*zoom;\n        float l = (p.x<s) ? mandelbrot_perturbation(c, dc) : \n                            mandelbrot(c + dc);\n        // color\n        col += (l<0.0) ? vec3(0.0) : 0.5 + 0.5*cos( pow(zoom,0.22)*l*0.05 + vec3(3.0,3.5,4.0));\n\n        // reference orbit\n        if( length(p)<0.02 ) col += vec3(1.0,0.0,0.0);\n\n        // separator\n        if( abs(p.x-s)<2.0/iResolution.y) col += vec3(1.0);\n    #if AA>1\n    }\n    col /= float(AA*AA);\n    #endif\n    \n    // output    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVSDW.jpg", "access": "api", "license": "mit", "functions": [[2140, 2140, 2167, 2167, 2216], [2218, 2218, 2244, 2244, 2425], [2427, 2427, 2477, 2477, 3034]], "test": "untested"}
{"id": "wtKSWW", "name": "Mandelbrot, Fixed vs Float", "author": "ockiller", "description": "Left : computed with 32 bit fixed point arithmetic\nRight : computed with 32 bit floating point arithmetic", "tags": ["mandelbrot", "fixedpoint"], "likes": 9, "viewed": 547, "published": 3, "date": "1582755521", "time_retrieved": "2024-07-30T21:21:52.972267", "image_code": "// Number of bits reserved for the fractional part\n#define SHIFT 28u\n\nint   initFixed(float x) {return int(x * float(1u << SHIFT));}\nivec2 initFixed(vec2  v) {return ivec2(initFixed(v.x), initFixed(v.y));}\n\n// Fixed point squaring\nint squareFixed(int a) {\n    uint ua = uint(abs(a));\n    uint ah = ua >> 16u;\n    uint al = ua & 0xFFFFu;\n    return int((ah * ah << 32u - SHIFT) + (ah * al >> SHIFT - 17u) + (al * al >> SHIFT));\n}\nivec2 squareFixed(ivec2 v) {return ivec2(squareFixed(v.x), squareFixed(v.y));}\n\nvoid mainImage(out vec4 O, in vec2 u) {\n    float whiteLine = (0.5 * sin(iTime) + 0.5) * iResolution.x;\n    vec2 U = (2.0 * u - iResolution.xy) / iResolution.y;\n    float zoom = 8e-7;\n    vec2 Coord = vec2(-0.743644, 0.1318255);\n    float maxIters = 3072.0, nbIters = 0.0;\n    \n    if (u.x < whiteLine) {\n        // Fixed point version\n\t    ivec2 C = initFixed(U * zoom) + initFixed(Coord); // more precise doing that way\n        ivec2 Z = C;\n\n        // Check divergence against a square (not circle) of size 4\n        // Numbers can be kept smaller and we can be more aggressive with SHIFT, before getting overflows\n        while (nbIters < maxIters && all(lessThan(abs(Z), initFixed(vec2(2))))) {\n            ivec2 Z2 = squareFixed(Z);\n            Z = ivec2(Z2.x, squareFixed(Z.x + Z.y) - Z2.x) - Z2.yy + C;\n            nbIters++;\n        }\n    } else {\n        // Floating point version\n\t    vec2 C = U * zoom + Coord;\n        vec2 Z = C;\n\n        while (nbIters < maxIters && all(lessThan(abs(Z), vec2(2)))) {\n            Z = vec2(Z.x * Z.x - Z.y * Z.y, 2.0 * Z.x * Z.y) + C;\n            nbIters++;\n        }\n    }\n\n    // Coloring\n    float t = nbIters / maxIters;\n    O.rgb = nbIters < maxIters ? 0.5 - 0.5 * cos(6.2831853 * (t + vec3(-0.1, 0.0, 0.1))) : vec3(0.0);\n        \n    if (abs(u.x - whiteLine) < 1.0)\n    \tO.rgb = vec3(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 96, 96, 132], [133, 133, 159, 159, 205], [207, 231, 255, 255, 428], [429, 429, 457, 457, 507], [509, 509, 548, 548, 1852]], "test": "untested"}
{"id": "wtGSDD", "name": "Day 69", "author": "jeyko", "description": "fork of my last sound shader", "tags": ["mdtmjvm"], "likes": 9, "viewed": 438, "published": 3, "date": "1582744288", "time_retrieved": "2024-07-30T21:21:53.918737", "image_code": "// Fork of \"Day 32 - Fruit Salad\" by jeyko. https://shadertoy.com/view/wlKGR3\n// 2020-02-26 13:03:10\n\n// so\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n\n}   ", "image_inputs": [], "sound_code": "\n// i_____ = instrument\n// g_____ = generator\n// e_____ = effect\n// c_____ = channel\n\n// toolchain goes i > g > e > c\n\n#define Y true\n#define N false\nfloat tGlobal;              \n\nbool[16] pattA = bool[](Y,N,N,N,Y,N,Y,N,N,N,Y,N,Y,N,Y,N);\n\nconst float base = 12.;           \nvec2[] scaleA = vec2[8](\n\tvec2(base,0),\n\tvec2(base + 2.,0),      \n\tvec2(base + 3.,0),\n\tvec2(base + 5.,0),                  \n\tvec2(base + 7.,0),\n\tvec2(base + 7.,0),   \n\tvec2(base + 10.,0),\n\tvec2(base + 12.,0)\n);\n\nvec4[4] chords = vec4[](\n    vec4(f(12. - 0.), f(12. + 10.), f(12. + 7.) , f(24. + 3.) ),\n    vec4(f(24. - 3.), f(12. + 10. - 3.), f(12. + 7. - 3.) , f(24. + 3. - 3.) ),\n    vec4(f(26. + 5.), f(12. + 10. + 5.), f(12. + 7. + 5.) , f(12. + 3. + 5.) ),\n    vec4(f(24. - 5.), f(12. + 10. - 5.), f(12. + 7. - 5.) , f(24. + 3. - 5.) )\n);\n\nfloat arpA(float t,vec2[8] scale, float period, float rep, float seed){\n\tfloat n = 0. ;\n    float r = r11( mod( floor(t/period), rep) + seed);\n    r *= 7.  ;\n    r = floor(r)   ;\n    n = note(scaleA[int(r)].x, scaleA[int(r)].y);\n    return n;\n}\n\n\n\nfloat arpC(float t,vec4[8] scale, float period, float rep, float seed){\n\tfloat n = 0. ;\n    float r = r11( mod( floor(t/period), rep) + seed);\n    r *= 7.  ;\n    r = floor(r)   ;\n    n = note(scaleA[int(r)].x, scaleA[int(r)].y);\n    return n;\n}\n\n// ------------ GENERATORS ------------ //\n  \nvec2 gKick(float t){\n    vec2 s = vec2(0);\n\tt = mod(t, hbeat);\n    vec2 introK = iKick(t);\n    s += iKick(t);\n\treturn s;\n}\n\n\nvec2 gCymbal(float t){\n\tvec2 s = vec2(0);\n    \n    t -= hbeat*0.5;\n    t = mod(t, beat);\n    float env = exp(-t*1.);\n    s += iCymbal(t, 0. )*env;\n        \n    //t = step(t, hbeat);\n    \n    \n    return s;\n}\nvec2 gCymbalB(float time){\n    //if (time < measure*2.) return vec2(0);\n    \n    time = mod(time, qbeat);\n    if (mod(time, hmsr) < 0.25){\n//    \ttime = mod(time, qbeat*8.) - hbeat/2.;\n    } else {\n//    \ttime = mod(time, qbeat*4.) - hbeat/2.;\n    }\n\t\n\tfloat s;\n    \n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate);\n        \n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*noise(time * mod(time, 0.1)*1.))*3.*exp(-time));\n    \ts *= exp(-time*20.);\n        s *= 3.;\n    \n    s = clamp(s, -1., 1.);\n\treturn vec2(s);\n}\n\n\nvec2 gHats(float t){\n\tvec2 s;\n    float currentMeasure = floor(t/(measure));\n    \n    s += iHatsA(mod(t, qbeat))*0.4;\n    //s += iHatsB(mod(t + 0.08, qbeat))*0.4;\n    Q(measure*4.){\n        Q(measure*2.){\n            //s += iHatsC(mod(t , bar) + 0.001);\n            QL(measure*1.){\n                //s += iHatsC(mod(t + hbar*0.99, bar) + 0.001)*0.6;\n            }\n        } else {\n            //s += iHatsC(mod(t, hbar)*2. + 0.001)*2.;\n            QL(measure*3.){\n            \t//s += iHatsC(mod(t + hbar*0.5, hbar)*2. + 0.001)*2.;\n            }\n        }\n        \n    }else {\n        \n    }\n    return s;\n}\n\n\nvec2 gPads(float t){\n    vec2 s = vec2(0);\n    \n    #define padInstr iTriFMPad\n    \n    float repLen = bar;\n    t= mod(t,repLen*4.);\n    float lT = mod(t, repLen);\n    float env = exp(-mod(t, repLen)*0.4);  \n\t//if()    \n    Q(repLen){\n        playChordVec(chords[0],padInstr, env, mod(t,repLen),s, -12.);   \n    } else Q(repLen*2.){\n    \tplayChordVec(chords[1],padInstr, env, mod(t,repLen),s,-12.);   \n    } else Q(repLen*3.){\n    \tplayChordVec(chords[2],padInstr, env, mod(t,repLen),s,-12.);   \n    } else Q(repLen*4.){\n    \tplayChordVec(chords[3],padInstr, env, mod(t,repLen),s,-12.);   \n    }\n    s *= 0.9;\n    \n\treturn s;\n}\n\n\nvec2 gBass(float t){\n\tsInit;\n \n    int idx = int(floor(t/(bar)));\n    //s += sin(200.*tau*t);\n    \n    float mult = 2.;\n    \n    QL(measure){\n        t = mod(t, measure);\n            Q(bar){\n                t = mod(t, beat);\n                //s += sin(TT*chords[1].x*2.);\n                s += iBassFM(t,note(0.,1.))*1.;\n                //s += iSawLP(t,chords[1].x*2., 0.7 + exp(-t*14.)*1., 0.)*4.;\n            } else Q(bar*2.){   \n                t = mod(t, beat);\t\n                s += iBassFM(t,chords[0].x*4.)*1.;\n            } else Q(bar*3.){\n                t = mod(t, beat);\n                s += iBassFM(t,chords[0].y*2.)*1.;\n                //s += iSawLP(t,chords[idx].y*2., 0.4 + exp(-t*05.)*3., 0.)*4.;\n            } else Q(bar*4.){\n                t = mod(t, beat);\n                s += iBassFM(t,note(12. - 7.,0.))*1.;\n                //s += iSawLP(t,chords[3].x*2., 0. + exp(-t*01.)*3., 20.)*2.;\n            }\n        Q(measure){\n\n        }\n    \n    }\n    //s = sat(s, 1.);\n    s *= 4.;\n\n    //s += iSawLP(400.,200., 200., 2.);\n    return s;\n}\n\nvec2 gLead(float t){\n\tsInit;\n    float tB = t;\n    float rep = beat;\n    float freq = arpA(t, scaleA,hbeat, 14., 19.);\n    \n    if(pattA[int( mod(floor(16.*t/bar), 16.))] == true){\n    \tt = mod(t, qbeat);\n    \tfreq *= 2.;\n        s += iPlucky(t,freq);\n    \t//eChorus(t, iPlucky,freq, 10.,20., s, 1.);\n    }\n    \n    t = mod(t,rep);\n    \n\n    //s = eLofi(s, 4.);\n    s *= 0.5;\n\treturn s;\n} \n\n\nvec2 gIntroDrone(float t, float i){\n\tsInit;\n\n    QL(measure*2.) return vec2(0);\n    \n    float freqA = note(12., 0.);\n    float freqB = note(3., 1.);\n    float freqC = note(12. + 7., 1.);\n    float scale = 0.1;\n    float iters = 6.;\n    for (float i = 0.; i < iters; i++) {\n    \n        s.x += sin(tau*t*freqA    )*scale * 0.5;\n        s.x += sin(tau*t*freqB    )*scale * 0.5;\n        s.x += sin(tau*t*freqC  + smoothstep(0.,1.,sin(t) * noise(vec2(t))*0.5)  )*scale * 0.4;\n    \tfreqA *= 2.002 +noise(i)*0.3 + sin(t + i)*0.002;\n    \tfreqC *= 2.002 +noise(i)*0.3 + sin(t + i)*0.002;\n    \tfreqB *= 1.501;\n        scale *= 0.2 + smoothstep(0.,1., t*0.2)*0.3 + cos(t * 0.2)*0.1;\n    }\n    s.y = s.x;\n    \n    return s;\n}\n\n\nvec2 gSnare(float t){\n\tvec2 s = vec2(0);\n    vec2 s1 = iSnareGhidra(mod(t + beat, beat));\n    QL(measure){\n        s += s1;\n    }\n    \n    return s;\n}\n// ------------ CHANNELS ------------ //\n\nvec2 cSpringReverb(float t){\n\tsInit;\n    float iters = 10.;\n    float st = 7./iSampleRate;\n    for(float i = 0.; i < iters; i++){\n        float offs = r11(i)*0.02; // electronic\n    \ts += gPads(t - st*i - offs)*(1. - i/iters);\n    \ts += gHats(t - st*i - offs*0.2)*(1. - i/iters)*2.;\n    }\n\n    s /= iters;\n    s *= 2.;\n    //s = sat(s, 2.);\n    //s = clamp(s, -1., 1.);\n    //s /= 2.;\n    return s;\n}\n\nvec2 cEchoInput(float t){\n\treturn gLead(t);\n}\nvec2 cEcho(float t) {\n\tsInit;\n    float fb = 0.34, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += cEchoInput(t) * cf; cf *= fb; \n    // tap 2\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    //s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\n\n// ------------ MAIN ------------ //\n\n\n\nvec2 wavetable( float freq, float time, float speed, float offset ) {\n  if ( time < 0.0 ) { return vec2( 0.0 ); }\n  float p = iTri(time,freq ).x;\n  return vec2(noise( p * speed + offset ));\n}\n\nvec2 clap( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  float amp = exp( -14.0 * _phase );\n  amp *= mix(\n    smoothstep( 0.5, 0.4, sin( 500.0 * _phase ) ),\n    1.0,\n    smoothstep( 0.04, 0.05, _phase )\n  );\n  vec2 wave = wavetable( 1.2, _phase, 1.0, 0.0 );\n  return lofir( amp * wave, 0.25 );\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    #ifdef tOffset\n    t += tOffset;\n    #endif\n\tsInit;\n    tGlobal = t;\n    \n    // drums\n    vec2 kick = gKick(t);\n    vec2 bass = gBass(t);\n    vec2 snare = gSnare(t);\n    //vec2 iirKick; eIIR(t, gKick, 6., 10., iirKick); \n    //vec2 cym1bal = gCymbal(t);\n    //vec2 cymbalB = gCymbalB(t);\n    vec2 kickR = gKickR(t + measure);\n    vec2 hats = gHats(t);\n    vec2 clap = clap(t);\n    \n    // synths\n    vec2 pads = gPads(t);\n    //vec2 introDrone = gIntroDrone(t,0.)/3.;\n    vec2 lead = gLead(t);   \n    vec2 reverb = cSpringReverb(t);\n    vec2 echo = cEcho(t);\n   \t        \n    \n    // mixer\n\t//pads *= sideChain(t);\t\n    //reverb *= sideChain(t);\t\n    s += kickR*0.9;\n    s += snare*0.28;\n    //s += clap*0.1;\n    s += bass*0.12;\n    s += pads*1.1;   \n    //s += lead*0.8;   \n    //s += gBass( t)*0.3;\n    //s += introDrone*2.;\n\n    s += reverb*0.2;\n    s += hats*0.1;\n    s += echo*0.5;\n\n    s *= 0.4;\n    //s = clamp(s, -1., 1.);\n    //s = sat(s, 1.7);\n    return s;\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define tOffset 0. + measure*1.75\n\n\n#define sInit vec2 s = vec2(0)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT tau*t\n  \n#define tempo 124.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (beat*4.*4.)\n#define hmsr  (measure*0.5)\n#define bar (0.5*hmsr)\n#define hbar (0.5*bar)\n\n#define P(x) t/measure < x\n#define PL(x) t/measure > x\n   \n#define E else\n#define sStep (1./iSampleRate)\n\n#define f(x) float(x)\n#define sat(x, amt) clamp(x*amt, -1., 1.)\n#define Q(period)  \\\n\tif (t < period)\n#define QL(period)  \\\n\tif (t > period)\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat r11(float i){\n\treturn fract(sin(i*742.62412)*1535.52156);\n}\n\n#define rT(i) texture(iChannel0, vec2(i)).x\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noise(float t){\n    float n = 0.;\n    n = fract(r11(t)*r11(t*2.41));\n    vec2 p = vec2(fract(r11(t*14.11)),fract(r11(t*124.1)*r11(t*3.15)));\n    vec2 q = vec2(fract(r11(t*14.124)*r11(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n\treturn n;\n}   \n\nfloat lpNoise(float t){\n\tfloat a = floor(t);\n\tfloat b = floor(t) + 1.;\n    return mix(noise(a), noise(b),fract(t));\n}\nfloat notVeryRandom(float st){\n    return fract(sin(st*451.5524));\n}\n\n// ------------ EFFECTS ------------ //\n\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+0.5)*(m))\n\n#define eIIR(t, instr, stSz, iters, varName) \\\n\t{\t\t\t\t\t\t\t\t\t\t \\\n    \tvarName = vec2(0);\t\t\t\t     \\\n        float st = stSz/iSampleRate;\t\t     \\\n        for(float i = 0.; i < iters; i++){\t \\\n            varName += instr(t - st*i);      \\\n        }\t\t\t\t\t\t\t\t     \\\n        varName /= iters;        \t\t\t \\\n    }\n\n#define eChorus(t, instr,freq, iters,stepSz, varName, outAmp) \\\n\t{\t\t\t\t\t\t\t\t\t\t \t\t  \\\n    \tvarName = vec2(0);\t\t\t\t     \t\t  \\\n        float st = stepSz/iSampleRate;\t\t \t\t  \\\n        float n = noise(t); \t\t\t\t          \\\n        for(float i = 0.; i < iters; i++){\t   \t\t  \\\n            varName += instr(t - st*i*sign(mod(i, 3.) - 1.), freq)*outAmp;      \\\n        }\t\t\t\t\t\t\t\t     \t\t  \\\n        varName /= iters;        \t\t\t          \\\n    }\n\n// ------------ DRUMS ------------ //\n\nvec2 iKick(float t){\n    vec2 s = vec2(0);\n    float envA = exp(-t*20.);\n    float envB = exp(-t*50.);\n    s += sin(tau*t*(40. + sin(t*90.)*1. +envB*1000.))*envA;\n    return s;\n}\nvec2 iKickB(float t){\n    vec2 s = vec2(0);\n    float envA = exp(-t*20.);\n    float envB = exp(-t*50.);\n    s += sin(tau*t*(10. + sin(t*90.)*1. +envB*400.))*envA;\n    s = sat(s, 2.);\n    return s;\n}\nvec2 iKickA(float t){\n    vec2 s = vec2(0);\n    float env = exp(-t*10.);\n    s.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n    s.y = s.x;\n\treturn s;\n}\nvec2 iSnareA(float t){\n\tvec2 s = vec2(0);\n\n    float envA = exp(-t*30.);\n    float envB = exp(-t*37.);\n    float envC = exp(-t*90.);\n    //float envC = exp(smoothstep(1.,0.,(t - 1.)) );\n    s += sin( t*tau*(200. + envA * 190.) + noise(t)*(1. - envC))*envB;\n    \n    \n    s = sat(s, 1.3);\n    return s;\n}\nvec2 iSnareGhidra(float t){\n    vec2 s = vec2(0);\n    float hit = mod(t + beat/2.,beat);\n\n    float n = 15.; \n    s += sin(tau*note(n+ 1.6*exp(-hit*46.) ,2.))*exp(-hit*20.)*0.2;    \t\n    s += sin(tau*note(n+ 1.6*exp(-hit*46.) ,1.))*exp(-hit*20.)*0.8;    \t\n\n    float satAmt = 0.2;\n    s = s*(1.-satAmt) +  (s / (0.99 -abs(s)))*satAmt;\n    //s *= 0.7;\n    s = (s + noise(t + noise(t))*s*8.)/2.; \n\treturn s*1.;\n}\n\nvec2 iHatsA (float t) {\n\tvec2 s = vec2(0);;\n    float env = exp(-t*20.);\n    float r = r11(t);\n    //float r = lpNoise(t*4000.);\n    s.x = sin(770.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*200.*env ) * env;\n    s.y = s.x;\n    s *= 0.2;\n    return s;\n}\nvec2 iHatsB (float t) {\n\tvec2 s = vec2(0);\n    float env = exp(-t*50.);\n    float r = r11(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    s *= 0.5;\n    return s;\n}\nvec2 iHatsC(float time){\n\tfloat s;\n    \n    //time = mod(time, beat*2.);\n    //time = mod(time, beat);\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate*2.);\n    t = t % ((t >>3) % t*4);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-time), 1.);\n    s = (s + (s*noise(time * mod(time, 0.001)*300.))*2.*exp(-time));\n    s *= 3.;\n    return vec2(float(s));\n}\n\nvec2 iCymbal(float t, float freq){\n\tvec2 s = vec2(0);\n    \n    float n = noise(t)*clamp(exp( (t- 1.)*1.), 0., 1.);\n    //s += n;\n    float fund = 1000.;\n    //s += sin(fund*t*tau + sin(t*tau*fund*12.)*5.* exp(-t*5.) + n*600.) * exp(-t*10.);\n    s += sin(fund*t*tau + sin(t*tau*fund*49.001)*5.* exp(-t*5.) ) * exp(-t*16.);\n    \n    \n    s = abs(s);\n    \n    s = clamp(s, -1., 1.);\n    \n\treturn s;\n}\nvec2 hats (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat);\n    float env = exp(-t*20.);\n    float r = r11(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*7.*env ) * env;\n    s.y = s.x;\n    return s;\n}\n\nvec2 hatsTwo (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat/2.);\n    float env = exp(-t*50.);\n    \n    float r = r11(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    \n    return s;\n\n}\n\n\n// ------------ INSTRUMENTS ------------ //\n\n\nvec2 iSineWide(float t, float freq){\n\tvec2 s = vec2(0);\n    t += noise(t)*0.00004;\n    s.x = sin(freq*tau*t);\n    s.y = sin(freq*tau*t + 5.);\n    return s;\n}\nvec2 iPiano(float t, float freq){\n\tvec2 s = vec2(0);\n    t += noise(t)*0.00004;\n    float envA = exp(-t*3.);\n    s.x = sin(freq*tau*t + sin(freq*tau*t*1.)*envA*1.);\n    s.y = sin(freq*tau*t + sin(freq*tau*t*1.)*envA*1.+ 5.);\n    return s;\n}\nvec2 iOrganLead(float t, float freq){\n    vec2 s = vec2(0);\n    float env = exp(-t*9.);\n    freq *= 4.;\n    float iterations = 3.;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = r11(i)*10.;\n    \ts.x += sin((freq + r)*tau*t )*env*scale;\n    \ts.x += sin(freq*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*freq*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        freq *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\nvec2 iPlucky(float t, float freq){\n\tvec2 s = vec2(0);\n    freq *= 2.;\n\tfloat r = r11(t)*0.01;\n    float envA = exp(-t*6.);\n    float envB = exp(-t*20.);\n\ts.x += sin((freq + r)*tau*t + sin((4.*freq + r)*tau*t )*envB*0.5 + lpNoise(t*1000.)*1. )*envA;\n    t += 0.02;\n\ts.y += sin((freq + r)*tau*t + sin((4.*freq + r)*tau*t )*envB*0.5 + lpNoise(t*1000.)*1. )*envA;\n\t//s.x -= sin((freq + r)*tau*t + sin((8.*freq + r)*tau*t )*envB*0.5  )*envA*0.4;\n    //s.y = s.x;\n    return s;\n}\n\nvec2 iSawLP(float t, float freq, float cutoff, float res){\n\tsInit;\n    for(float i = 1.; i < 20.; i++){\n    \ts += sin(freq*tau*t*i) / (i) * smoothstep(0.,1.,length(i/32. - cutoff)) * (1. + exp(-length(i/32. - cutoff)*4.) *res);\n    }\n    s *= 0.1;\n    s = sat(s, 2.);\n    s *= 2.;\n    return s;\n}\nvec2 iBassFM(float t, float freq){\n\treturn vec2(sin(TT*freq + exp(-t*7.)*sin(TT*freq*4.)*1.));\n}\n\nvec2 iSawAChorused(float t, float freq){\n\tvec2 s = vec2(0);\n    eChorus(t, iPiano,freq*2.,10., 1., s, 1.);\n    //s *= exp(-t);\n    //s.x /= 6.;\n    return s;\n}\nvec2 iSawA(float t, float freq){\n\tvec2 s = vec2(0);\n    s.x = fract(freq*tau*t + sin(t)*9. + r11(t)*0.1*exp(-t*200.))*0.2;\n    s.y = s.x;\n    return s;\n}\nvec2 iTri(float t, float freq){\n\tvec2 s = vec2(0);\n    s.x = abs(fract(freq*tau*t) - 0.5)*0.2;\n    s.y = s.x;\n    return s;\n}\nvec2 iTriFMPad(float t, float freq){\n\tvec2 s = vec2(0);\n    \n    \n    for(float j = 1.; j < 3.; j++){\n        for(float i = 0.; i< 4.; i++){\n            t += i *0.09;\n            //s += sin(4.*freq*tau*t + sin(8.*freq*tau*t)*0.8*exp(-t*4.) + lpNoise(t*20.)*5.7)*0.3;\n            s += sin(4.*freq*TT\n                     + sin(4.*freq*TT)*0.8*exp(-t*20.) \n                     + sin(2.*freq*TT + sin(2.*freq*TT))*0.8*exp(-TT*2.) \n                     + sin(t*15.)*0.5 )*0.07/j;\n            //s += sin(6.*freq*tau*t )*0.1;\n\n        }\n    \tfreq *= 2.;\n    }\n    //s = iTri(t, freq);\n    return s;\n}\nvec2 iSuperSaw(float t,float freq){\n\tvec2 s = vec2(0);\n    //float n = noise(t);\n    t += r11(t)*0.00009;\n    float detuneAmt = 1.;\n    //t += noise(t)*0.0004;\n    s += iSawA(t, freq);\n    s += iSawA(t, freq*(1. - 0.02*detuneAmt));\n    s += iSawA(t, freq*(1. + 0.015*detuneAmt));\n    s /= 3.;\n    return s;\n}\nvec2 iAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    freq *= 3.;\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    \n    float n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n*0.4 -tMod + tMod2  ));\n\n    s /= 8.;\n    \n    return s;\n}\n\n\n// ------------ GENERATORS ------------ //\n\nvec2 gKickR(float t) {\n    vec2 s = vec2(0);\n    \n    vec2 k = iKick(t);\n    \n        s += k;\n    Q(measure*4.){\n        //return vec2(0);\n    } else QL (measure*4.){\n    }\n    float period = hbeat;\n    t = mod(t + beat*4.,beat*8.);\n\tfloat r = noise(floor(t/period) + 1.);\n\tfloat rB = noise(floor(t/period) + 2.);\n    \n    if (rB < 0.1){\n    \tr = floor(r* 3.99);\n    \tfloat offs = (period/1.)*r;\n        float mT = mod(t, period) - offs;\n        if (mT > 0.){\n            eIIR(mT, iKickB, 6., 10., s);\n        }\n    }\n    s = sat(s, 1.2);\n    //s.y = s.x;\n\treturn s;\n}\n\n// ------------ OTHER STUFF ------------ //\n\n\n#define addChord(array,arraysize,arrayname) \t\t\t\t\\\n\t{arrayname = float[]array;\t\t\t\t\t\t\t\t\\\n    }\n#define playChord(array, arraysize, synth,env,t,sound)  \t\\\n        for (int i = 0; i < int(arraysize); i++){\t\t\t\\\n            sound += vec2( synth(t, note(chord[i],0.)) )*env;\\\n        }\n#define playChordVec(chord, synth,env,t,sound,offs)  \t\\\n        {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            sound += vec2( synth(t, note(chord.x+offs,0.)) )*env;\\\n            sound += vec2( synth(t, note(chord.y+offs,0.)) )*env;\\\n            sound += vec2( synth(t, note(chord.z+offs,0.)) )*env;\\\n            sound += vec2( synth(t, note(chord.w+offs,0.)) )*env;\\\n        }\t\t\t\t\t\t\t\t\t\t\t\t\t\n\nfloat sideChain(float t){\n    float s;\n\n    t = mod(t, hbeat);\n    //s = exp(pow( (t*1.- 1.)*0.5, 2.));\n    s = pow(sqrt(t ), 0.8);\n    \n    return s;\n}\n\nvec2 eLofi(vec2 s, float amt){\n    float st = (1./(pow(2.,amt)));\n    s = st * floor( s/st + 0.5 );\n    return s;\n}\n\n// ------------ VAULT ------------ //\n\n/*\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.85, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += lead(t) * cf; cf *= fb; \n    \n    s += lead(t) * cf; cf *= fb; \n    // tap 2\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}*/\n\n/*\n#define eReverb(t, instr, iters, stSz, varName)\n{\n    vec2 ls = vec2(0);\n    float st = stSz/iSampleRate;\n    st = 0.008;\n    for(float i = 0.; i < iters; i++){\n        float offs = noise(i)*0.8;\n    \tls += instr(t - st*i - offs)*1.*(1. - i/iters);\n    }\n\n    ls /= iters;\n    ls = clamp(s, -1., 1.);\n    varName += ls;\n}*/\n\n\n\n\n/*\nvec2 cHipass(float t){\n    float f = 900.4;\n    float r = 0.9; // 0.1 to sqrt(2)\n\n    float c = tan(pi * f / iSampleRate);\n\n    float a1 = 1.0 / ( 1.0 + r * c + c * c);\n    float a2 = -2.*a1;\n    float a3 = a1;\n    float b1 = 2.0 * ( c*c - 1.0) * a1;\n    float b2 = ( 1.0 - r * c + c * c) * a1;\n    \n    //vec2 s = a1 * gKick(t) + a2 * gKick(t - sStep) + a3 * gKick(t - sStep*2.) - b1*out(n-1) - b2*out(n-2);\n    vec2 sC = a1 * gKick(t) + a2 * gKick(t - sStep) + a3 * gKick(t - sStep*2.);\n    vec2 sB = a1 * gKick(t - sStep*1.) + a2 * gKick(t - sStep*2.) + a3 * gKick(t - sStep*3.);\n    vec2 sBB = a1 * gKick(t - sStep*2.) + a2 * gKick(t - sStep*3.) + a3 * gKick(t - sStep*4.);\n    vec2 s = sC - b1*sB - b2*sBB;\n    //vec2 s = a1 * gKick(t - sStep*2.) + a2 * gKick(t - sStep*3.) + a3 * gKick(t - sStep*4.);\t    \n  //out(n) = \n\treturn s;\n}*/\n\n\n/*\nvec2 cReverb(float t){\n\tvec2 s = vec2(0);\n    float iters = 100.;\n    float st = 1./iSampleRate;\n    st = 0.008;\n    for(float i = 0.; i < iters; i++){\n        float offs = noise(i)*0.8;\n    \ts += gSawA(t - st*i - offs)*3.*(1. - i/iters);\n        //s += gCymbal(t - st*i + offs*0.4)*0.1*(1. - i/iters) ;\n        \n        //s += gCymbalB(t - st*i + offs*0.06)*0.3*(1. - i/iters) ;\n    }\n\n    s /= iters;\n    s = clamp(s, -1., 1.);\n    //s /= 2.;\n    return s;\n}*/\n// The awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//we can use jitter for analog driftness\nfloat genSaw(float time, float freq, bool useJitter)\n{\n    float jitter1 = 0.0;\n    float jitter2 = 0.0;\n/*\n    if(useJitter)\n    {\n      jitter1 = texture(iChannel0, vec2(time,0.2)*0.01).x;\n      jitter2 = texture(iChannel0, vec2(time-0.01,0.2)*0.01).x;\n    }*/\n    \n    float val = fract(time*(freq + (jitter1+jitter2)*0.2));\n    return val;\n}\n\nfloat genNiceSaw(float time, float freq, bool useJitter)\n{\n    return (genSaw(time,freq,useJitter) - 0.5) * 2.0;\n}\n#define maxTaps 20\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSaw(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.2;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSaw(t,freq,false);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n/*\nvec2 gBass(float t){\n    vec2 s = vec2(0);\n    float tB = t;\n    float freq = arpA(t, scaleA,qnote, 4., 9.);\n    t = mod(t,qnote);\n    float env = exp(-t*2.);\n    float scale = 0.7;\n    s += resoLpSaw(t, freq, 0.2) * env * scale ;\n\treturn s;\n} */\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 133, 157, 559], [569, 569, 626, 687, 888]], "test": "untested"}
{"id": "3tVSWD", "name": "fix point Mandelbrot", "author": "FabriceNeyret2", "description": "Right: computed with floating points\nLeft: Computed with fix points: see #FIX to test 4 methods. (#4 is best, thanks rory618 ! ) \n\nHow to zoom deeper in Mandelbrot (without implementing longints / longfloats) ?", "tags": ["mandelbrot", "int", "fixpoint"], "likes": 9, "viewed": 527, "published": 3, "date": "1582739767", "time_retrieved": "2024-07-30T21:21:54.685686", "image_code": "int FPP(int a, int b){    // used by FIX=4 (thanks rory618 !)\n    int aH = a>>16,  aL = a & 0xFFFF,\n        bH = b>>16,  bL = b & 0xFFFF,\n       ppH = aH * bH,\n       ppL = aH * bL + aL * bH;\n    return (ppH<<7) + (ppL>>9);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = (2.*u-R) / R.y,\n         C = vec2(-.74502,.1860105) + U / exp2(iTime);\n    \n    float i = 0.;\n    if (u.x < R.x/2.) {    // --- left: fix point version\n#define FIX 4              //   <- choose method 0-3\n        \n#if FIX==1                 //   method 1\n        #define M 0x2000   // unit: 0x2000 (better) - 0x5800 (deeper)\n        ivec2 z = ivec2(0),\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {  // post-reduce by M = scale\n            z = ( ivec2( z.x*z.x - z.y*z.y, 2*z.x*z.y) +M/2) / M + c;\n            if ( z.x*z.x + z.y*z.y > 4*M*M ) break; \n        }\n#elif FIX==2               //   method 2\n        #define S 0x2000   // sqrt(unit)\n        #define M (S*S)    // unit\n        ivec2 z = ivec2(0), s,\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            z = (z + S/2 ) / S;  // pre-reduce by S = sqrt(scale)\n            z = ivec2( z.x*z.x - z.y*z.y, 2*z.x*z.y) + c;\n            s = (z + S/2 ) / S;\n           if ( s.x*s.x + s.y*s.y > 4*M ) break; \n        }\n#elif FIX==3               //   method 3\n        #define S 0x300    // sqrt(unit)   \n        #define M (S*S)    // unit \n        ivec2 z = ivec2(0), s,\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            s = (z + S/2 ) / S;  // pre/pos-reduce by S = sqrt(scale)\n            z = (ivec2( s.x*z.x - s.y*z.y, s.x*z.y+s.y*z.x) +S/2)/S + c;\n            s = (z + S/2 ) / S;\n           if ( s.x*s.x + s.y*s.y > 4*M ) break; \n        }\n#else // FIX==4            //   method 4\n        #define M 0x02000000 // unit\n        ivec2 z = ivec2(0),\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            z = ivec2( FPP(z.x,z.x) - FPP(z.y,z.y), 2*FPP(z.x,z.y) ) + c;\n           if ( FPP(z.x,z.x) + FPP(z.y,z.y) > 4*M ) break; \n        }\n#endif\n    }\n    else {                  // --- right: floating point version\n        vec2 z = vec2(0),\n             c = vec2(C);\n        for (; i < 150.; i++) {\n            z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n            if ( z.x*z.x + z.y*z.y > 4. ) break; \n        }\n    }\n    \n                            // --- coloring  scheme\n  //O = vec4(.5+.5*sin(i/4.));\n    O =  (1.-i/150.)\n        *( .6 + .6 * cos( 6.3*i/25.  + vec4(0,23,21,0)  )); // hue https://www.shadertoy.com/view/ll2cDc\n\n    if (int(u-R/2.)==0) O++; // O=vec4(1,0,0,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 61, 225], [227, 227, 265, 265, 2656]], "test": "untested"}
{"id": "WtKSWD", "name": " - Astral Projection", "author": "totetmatt", "description": "What is the dot product for astral projection ?", "tags": ["instagram", "quicky"], "likes": 24, "viewed": 907, "published": 3, "date": "1582737622", "time_retrieved": "2024-07-30T21:21:55.472583", "image_code": "\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p,a,b);\nfloat m =smoothstep(0.04,0.007,distLine(p,a,b));\n\nfloat d2 = length(a-b);\n  m *= smoothstep(0.6- .1/(length(p)), .3 , d2)*.2 + smoothstep(.0122,.00121,abs(d2-.75)) ;//* (.25/length((p-a)+(p-b)));\n  return m;\n}\nfloat n21(vec2 p){\n  p = fract(p*vec2(123.213,853.4264));\n  p += dot(p,p+6.65);\n  return fract(p.x*p.y);\n\n}\nvec2 n22(vec2 p){\n    float n = n21(p);\n    return vec2(n, n21(p+n));\n}\n\nvec2 getPos(vec2 id, vec2 offset) {\n    vec2 n = n22(id+offset)*iTime;\n    return offset+sin(n)*.4;\n}\nmat2 r(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat layer(vec2 uv){\n\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    vec2 gridPos[9];\n    int ppos = 0;\n    for(int y = -1; y<=1; y++) {\n        for(int x = -1; x<=1; x++) {\n            gridPos[ppos++] = getPos(id,vec2(x,y));\n            \n           \n        }\n    }\n    for(int i=0;i<9;i++){\n        m+=line(gv,gridPos[4],gridPos[i]);\n        \n        vec2 jj = (gridPos[i] - gv)*12.;\n        float sparkle = 1./length(dot(jj,jj));\n        m+=sparkle*(sin(iTime+ fract(gridPos[i].x) *10.)*.5+.5);\n    }\n     m+=line(gv,gridPos[1],gridPos[3]);\n     m+=line(gv,gridPos[1],gridPos[5]);\n     m+=line(gv,gridPos[7],gridPos[3]);\n     m+=line(gv,gridPos[7],gridPos[5]);\n     return m ;\n}\n#define ttime floor(iTime*.5) + pow(fract(iTime*.5),.5)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) -.5;\n \n      \n     float m = 0.;\n      //uv*=exp(length(uv)*.2);\n      uv*=.75;\n      uv*=r(atan(uv.x,uv.y)*2.*1.5);\n      uv*=r(cos(length(uv)*3.1415));\n      uv*=r(-iTime*.1);\n      uv=-abs(uv);\n\n     uv*=2.;\n  \n      //uv.x+=-iTime*.0001;   \n      float t = iTime*.0025;\n    \n      vec3 col = vec3(0.);\n     for( float i=0.; i<1.; i+= (1./5.) ) {\n          float z = fract(i+t);\n  \n          float size = mix(8.+sin(i*3.1415*(sin(iTime)*.5+1.5)+ttime)*8.,2.,z);\n          float fade = smoothstep(.0,.4,z) * smoothstep(1.,.6,z);\n         uv*=r(t*sin(i*10.));\n                             \n          m += layer(uv*size+i*20.) * fade ;\n          vec3 base = mix(vec3(.75+sin(ttime+length(uv*4.))*.1,.2,.6),vec3(.1,.2,.6),vec3(sin(i*4.5)*.5+.5,0.+m*1.,i*2.));\n          col += vec3(m)*base;\n     }\n \n\n    //if(gv.x>.47 || gv.y >.47) col.r = 1.;\n    fragColor = vec4(col,1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 159], [160, 160, 195, 195, 432], [433, 433, 451, 451, 540], [541, 541, 558, 558, 612], [614, 614, 649, 649, 715], [716, 716, 732, 732, 791], [792, 792, 813, 813, 1503], [1560, 1560, 1615, 1615, 2611]], "test": "untested"}
{"id": "WlVXDW", "name": "moving holes 1b", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 4, "viewed": 278, "published": 3, "date": "1582736790", "time_retrieved": "2024-07-30T21:21:56.246513", "image_code": "// variant of https://shadertoy.com/view/WtVXDW\n\n#define C(q) t = max(t, 2.-length(mod(q.xy+4.,6.)-4.))\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime;\n    mat2  R = mat2( sin(1.1+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),     // ray direction\n          p = 23./q, a;                        // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                  // rotation\n        t-=t,\n        a = abs(q),  \n        t = max(t, max(max(a.x,a.y),a.z) -4. ),// cube \n        t = max(t, 3. - max(a.x,a.z)  ),       // negative cube \n        q.y -= iTime,\n        C(q.xy),\n        C(q.zy-vec2(0,3)),\n        p += t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 810]], "test": "untested"}
{"id": "WtVXDW", "name": "moving holes", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 3, "viewed": 373, "published": 3, "date": "1582736761", "time_retrieved": "2024-07-30T21:21:57.008476", "image_code": "#define C(q) t = max(t, 2.-length(mod(q.xy+4.,6.)-4.))\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime;\n    mat2  R = mat2( sin(1.1+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),     // ray direction\n          p = 23./q, a;                        // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                  // rotation\n        t-=t,\n        a = abs(q),  \n        t = max(t, max(max(a.x,a.y),a.z) -4. ),// cube \n        q.y -= iTime,\n        C(q.xy),\n        C(q.zy-vec2(0,3)),\n        p += t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 92, 92, 696]], "test": "untested"}
{"id": "ttGSDD", "name": "The One Ring Revisited", "author": "k_kondrak", "description": "Lord of the Rings - One Ring to rule them all.\nRevisiting https://www.shadertoy.com/view/4tfBRf with proper Elvish inscription, thanks to user Dave (https://www.shadertoy.com/user/Dave) and his excellent font: https://www.shadertoy.com/view/MtS3RK", "tags": ["sdf", "hell", "ring", "sauron", "fonts", "lotr", "gold"], "likes": 15, "viewed": 802, "published": 3, "date": "1582731731", "time_retrieved": "2024-07-30T21:21:58.175356", "image_code": "// ----------------------------------------------------\n//  \"The One Ring Revisited\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------\n\n// enable/disable AA\n#define ANTIALIASING 1\n#define AA_SAMPLES 2\n#define AA_WIDTH .8\n\n#define FOV 5.5\n#define RING_RADIUS 1.5\n\n// raymarching constants\n#define MIN_DIST  .001\n#define MAX_DIST  30.\n#define NUM_STEPS 100\n#define BACKGROUND_ID 0\n#define RING_ID       1\n\n// Gold color: https://www.shadertoy.com/view/XdVSRV\nconst vec3 GOLD1 = vec3(1.1,  0.91, 0.52);\nconst vec3 GOLD2 = vec3(1.1,  1.07, 0.88);\nconst vec3 GOLD3 = vec3(1.02, 0.82, 0.55);\n\n// texture mapping parameters for text positioning\nconst float vMin = -0.45;\nconst float vMax = 0.45;\n\n// initial eye/camera position\nvec3 EYE = vec3(7.5, 0., 0.);\n\n// helper struct to collect raymarching data\nstruct RMInfo\n{\n  \tvec3 pos;\n  \tvec3 normal;\n  \tint  objId;\n};\n\n// ------------------\n//  1D hash function\n// ------------------\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// ----------------------------------------------\n//  noise: https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\t\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n// -----------------\n//  vector rotation\n// -----------------\nvec2 rotate(vec2 v, float a)\n{\n    return vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\n\n// ----------------------------------------------------------\n//  Elvish characters: https://www.shadertoy.com/view/MtS3RK\n// ----------------------------------------------------------\nstruct EL\n{\n    float x, y, rx, ry, dx, dy;\n};\n\nmat3 myInverse( mat3 m )\n{\n    mat3 res;\n    res[0][0] = m[0][0];\n    res[0][1] = m[1][0];\n    res[1][0] = m[0][1];\n    res[1][1] = m[1][1];\n    vec2 t = mat2( res ) * vec2( -m[2][0], -m[2][1] );\n    res[2] = vec3( t, 1.0 );\n    return res;\n}\n\nfloat toEL( in vec2 v, in EL el )\n{\n    mat3 m = mat3(\n        el.dx, el.dy, 0.0,\n        -el.dy, el.dx, 0.0,\n        el.x, el.y, 1.0 );\n    mat3 mi = myInverse( m );\n\n    vec2 t = ( mi * vec3( v, 1.0 ) ).xy;\n    return t.x * t.x / ( el.rx * el.rx ) + t.y * t.y / ( el.ry * el.ry ) - 1.0;\n}\n\nfloat toDash1( vec2 uv )\n{\n\tEL ael[12];\n\tael[0] = EL( 110.0, 117.0, 8.8, 200.3, 0.966, -0.259 );\n\tael[1] = EL( 90.0, 39.0, 72.2, 242.6, 0.966, -0.259 );\n\tael[2] = EL( 161.0, 306.0, 5.0, 11.0, 0.966, -0.259 );\n\tael[3] = EL( 152.0, 278.0, 4.0, 6.0, 1.000, 0.000 );\n\tael[4] = EL( 32.0, 276.0, 112.0, 118.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n    return d;\n}\n\nfloat toDash3( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 32.0, 276.0, 112.0, 118.0, 1.000, 0.000 );\n\tael[1] = EL( -17.0, 250.0, 159.0, 163.0, 1.000, 0.000 );\n\tael[2] = EL( 65.0, 362.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[3] = EL( 138.0, 296.0, 4.3, 12.3, 0.966, 0.259 );\n\tael[4] = EL( 243.0, 207.0, 100.0, 126.5, 0.940, -0.342 );\n\tael[5] = EL( 238.0, 140.0, 125.4, 193.2, 0.951, -0.309 );\n\tael[6] = EL( 278.0, 295.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[7] = EL( 180.0, 283.0, 5.7, 9.8, 0.866, -0.500 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\td = min( d, toEL( uv, ael[7] ) );\n    d = min( d, toDash1( uv ) );\n\treturn d;    \n}\n\nfloat toCharC( vec2 uv )\n{\n    float d = toEL( uv, EL( 106.0, 102.0, 76.0, 100.0, 0.96, -0.25 ) );\n    d = max( d, -toEL( uv, EL( 118.0, 105.0, 71.0, 90.0, 0.97, -0.20 ) ) );\n    d = min( d, toEL( uv, EL( 151.0, 177.0, 10.4, 15.8, -0.788, -0.615 ) ) );\n    return d;\n}\n\nfloat toCharC1( vec2 uv )\n{\n\tfloat d = toEL( uv, EL( 98.0, 100.0, 78.8, 105.5, 0.866, -0.500 ) );\n\td = max( d, -toEL( uv, EL( 88.0, 94.0, 70.0, 95.4, 0.858, -0.513 ) ) );\n\td = min( d, toEL( uv, EL( 46.0, 22.0, 12.0, 19.8, 0.755, 0.656 ) ) );\n\treturn d;\n}\n\nfloat toCharp( vec2 uv )\n{\n    float d = toEL( uv, EL( -303.0, 201.0, 357.0, 379.0, 1.0, 0.0 ) );\n    d = max( d, -toEL( uv, EL( -353.0, 218.0, 410.0, 408.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 389.0, 21.0, 359.0, 351.0, 1.0, 0.0 ) ) );\n    d = max( d, -toEL( uv, EL( 435.0, -16.0, 411.0, 404.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 145.0, 100.0, 100.0, 100.0, 1.0, 0.0 ) ) );\n    d = max( d, -toEL( uv, EL( 182.0, 90.0, 139.0, 112.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 95.0, 68.0, 49.0, 141.0, 0.92, -0.39 ) ) );\n    d = max( d, -toEL( uv, EL( 71.0, 28.0, 51.5, 180.2, 0.92, -0.39 ) ) );\n    return d;\n}\n\nfloat toCharZ( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 100.0, 86.0, 87.4, 123.6, 0.799, -0.602 );\n\tael[1] = EL( 67.0, 66.0, 81.6, 147.1, 0.719, -0.695 );\n\tael[2] = EL( 65.0, -174.0, 100.0, 194.2, 0.819, -0.574 );\n\tael[3] = EL( 41.0, -173.0, 104.4, 194.5, 0.739, -0.674 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\treturn d;\n}\n\nfloat toCharw( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 120.0, -80.0, 74.8, 359.8, 0.875, -0.485 );\n\tael[1] = EL( 117.0, -50.0, 81.7, 390.5, 0.883, -0.469 );\n\tael[2] = EL( 95.0, 101.0, 66.5, 103.5, 0.940, -0.342 );\n\tael[3] = EL( 109.0, 117.0, 52.8, 95.3, 0.914, -0.407 );\n\tael[4] = EL( 215.0, 101.0, 66.8, 103.1, 0.940, -0.342 );\n\tael[5] = EL( 224.0, 116.0, 52.6, 95.7, 0.914, -0.407 );\n\tael[6] = EL( 385.0, 136.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[7] = EL( 388.0, 108.0, 100.0, 146.7, 0.966, -0.259 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n\treturn d;\n}\n\nfloat toCharTilda( vec2 uv )\n{\n\tEL ael[3];\n\tael[0] = EL( 255.0, -7.0, 619.0, 209.0, 1.000, 0.000 );\n\tael[1] = EL( 116.0, -43.0, 1030.2, 229.2, 0.999, 0.052 );\n\tael[2] = EL( 301.0, 125.0, 371.9, 66.7, 0.974, 0.225 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\treturn d;\n}\n\nfloat toCharj( vec2 uv )\n{\n\tEL ael[2];\n\tael[0] = EL( -63.0, -82.0, 83.0, 329.0, 0.848, -0.530 );\n\tael[1] = EL( -98.0, -106.0, 88.7, 340.7, 0.829, -0.559 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\treturn d;\n}\n\nfloat toCurl( vec2 uv )\n{\n\tEL ael[7];\n\tael[0] = EL( 204.0, 181.0, 100.0, 271.1, 0.904, -0.428 );\n\tael[1] = EL( 191.0, 148.0, 92.6, 277.2, 0.912, -0.409 );\n\tael[2] = EL( 284.0, 301.0, 60.0, 60.0, 1.000, 0.000 );\n\tael[3] = EL( 391.0, 38.0, 146.0, 302.2, 0.978, -0.208 );\n\tael[4] = EL( 288.0, 317.0, 45.0, 67.3, 0.996, -0.087 );\n\tael[5] = EL( 256.0, 335.0, 17.0, 16.0, 1.000, 0.000 );\n\tael[6] = EL( 110.0, 99.0, 100.0, 100.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\treturn d;\n}\n\nfloat toCurl2( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 193.0, 89.0, 100.0, 355.7, 0.919, -0.394 );\n\tael[1] = EL( 198.0, 77.0, 100.0, 375.2, 0.914, -0.405 );\n\tael[2] = EL( 112.0, 14.0, 385.0, 187.0, 1.000, 0.000 );\n\tael[3] = EL( 321.0, 408.0, 11.0, 19.1, 0.164, 0.986 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n\treturn d;\n}\n\nfloat toCharh( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 9.0, 14.0, 81.4, 220.5, 0.821, -0.571 );\n\tael[1] = EL( -7.0, -3.0, 78.9, 214.6, 0.839, -0.545 );\n\tael[2] = EL( -57.0, 182.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[3] = EL( 104.0, -100.0, 196.0, 99.9, 0.970, 0.242 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n    d = min( d, toCharC1( uv + vec2( -110.0, 0.0 ) ) );\n    d = min( d, toCurl( uv + vec2( -20.0, 0.0 ) ) );\n\treturn d;\n}\n\nfloat toCharpm( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 273.0, -7.0, 100.0, 224.2, 0.875, -0.485 );\n\tael[1] = EL( 264.0, -20.0, 88.4, 225.2, 0.866, -0.500 );\n\tael[2] = EL( 139.0, -3.0, 100.0, 227.4, 0.875, -0.485 );\n\tael[3] = EL( 131.0, -16.0, 85.9, 229.6, 0.875, -0.485 );\n\tael[4] = EL( 305.0, -126.0, 417.0, 130.0, 1.000, 0.000 );\n\tael[5] = EL( -21.0, -86.0, 100.0, 313.6, 0.906, -0.423 );\n\tael[6] = EL( -38.0, -105.0, 88.2, 323.4, 0.899, -0.438 );\n\tael[7] = EL( -99.0, 58.0, 100.0, 261.7, 0.899, -0.438 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n    d = min( d, toCharTilda( vec2( uv + vec2( -135.0, 190.0 ) ) ) );\n\treturn d;\n}\n\nfloat toTilda2( vec2 uv )\n{\n    EL ael[4];\n\tael[0] = EL( 148.0, 43.0, 224.0, 158.0, 1.000, 0.000 );\n\tael[1] = EL( 156.0, 35.0, 266.0, 151.0, 1.000, 0.000 );\n\tael[2] = EL( 293.0, 267.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[3] = EL( 290.0, 287.0, 118.0, 113.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n    return d;\n}\n\nfloat toCharE1( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 172.0, 51.0, 132.0, 146.0, 1.000, 0.000 );\n\tael[1] = EL( 189.0, 57.0, 126.7, 133.2, 1.000, 0.017 );\n\tael[2] = EL( 271.0, 92.0, 146.8, 79.4, 0.755, 0.656 );\n\tael[3] = EL( 261.0, 110.0, 158.9, 89.5, 0.766, 0.643 );\n\tael[4] = EL( 223.0, -5.0, 59.6, 68.0, 0.999, 0.052 );\n\tael[5] = EL( 209.0, -8.0, 54.0, 65.0, 1.000, 0.000 );\n\tael[6] = EL( 212.0, 20.0, 62.2, 41.6, 0.982, 0.191 );\n\tael[7] = EL( 210.0, 20.0, 44.1, 34.5, 0.956, 0.292 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n    d = min( d, toTilda2( uv ) );\n    d = min( d, toCurl( uv ) );\n\treturn d;\n}\n\nfloat toCharE2( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 172.0, 51.0, 132.0, 146.0, 1.000, 0.000 );\n\tael[1] = EL( 189.0, 57.0, 126.7, 133.2, 1.000, 0.017 );\n\tael[2] = EL( 271.0, 92.0, 146.8, 79.4, 0.755, 0.656 );\n\tael[3] = EL( 261.0, 110.0, 158.9, 89.5, 0.766, 0.643 );\n\tael[4] = EL( 223.0, -5.0, 59.6, 68.0, 0.999, 0.052 );\n\tael[5] = EL( 209.0, -8.0, 54.0, 65.0, 1.000, 0.000 );\n\tael[6] = EL( 212.0, 20.0, 62.2, 41.6, 0.982, 0.191 );\n\tael[7] = EL( 210.0, 20.0, 44.1, 34.5, 0.956, 0.292 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n    d = min( d, toTilda2( uv ) );\n    d = min( d, toCurl( uv ) );\n\treturn d;\n}\n\nfloat toCharY2( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 120.0, -80.0, 74.8, 359.8, 0.875, -0.485 );\n\tael[1] = EL( 117.0, -50.0, 81.7, 390.5, 0.883, -0.469 );\n\tael[2] = EL( 95.0, 101.0, 66.5, 103.5, 0.940, -0.342 );\n\tael[3] = EL( 109.0, 117.0, 52.8, 95.3, 0.914, -0.407 );\n\tael[4] = EL( 215.0, 101.0, 66.8, 103.1, 0.940, -0.342 );\n\tael[5] = EL( 224.0, 116.0, 52.6, 95.7, 0.914, -0.407 );\n\tael[6] = EL( 385.0, 136.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[7] = EL( 388.0, 108.0, 100.0, 146.7, 0.966, -0.259 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n    d = min( d, toTilda2( uv + vec2( -100.0, -15.0 ) ) );\n    d = min( d, toCurl( uv + vec2( -170.0, 0.0 ) ) );\n    d = min( d, toCurl2( uv + vec2( -80.0, 0.0 ) ) );\n\treturn d;\n}\n\nfloat toPeriod( vec2 uv )\n{\n\tEL ael[1];\n\tael[0] = EL( 40.0, 23.0, 21.0, 22.0, 1.000, 0.000 );\n    float d = toEL( uv, ael[0] );\n\treturn d;\n}\n\nfloat toCharC2( vec2 uv )\n{\n\tEL ael[6];\n\tael[0] = EL( 88.0, 80.0, 81.9, 278.4, 0.914, -0.407 );\n\tael[1] = EL( 89.0, 59.0, 87.8, 292.0, 0.914, -0.407 );\n\tael[2] = EL( -51.0, 15.0, 40.0, 124.9, 0.945, -0.328 );\n\tael[3] = EL( 98.0, 100.0, 78.4, 105.8, 0.866, -0.500 );\n\tael[4] = EL( 88.0, 94.0, 70.9, 95.2, 0.866, -0.500 );\n\tael[5] = EL( 46.0, 22.0, 11.6, 16.4, 0.755, 0.656 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\treturn d;\n}\n\nfloat toCharY3( vec2 uv )\n{\n\tEL ael[6];\n\tael[0] = EL( 23.0, -51.0, 77.6, 268.1, 0.934, -0.358 );\n\tael[1] = EL( 6.0, -62.0, 77.5, 273.0, 0.921, -0.391 );\n\tael[2] = EL( 75.0, 77.0, 60.5, 74.5, 0.993, -0.121 );\n\tael[3] = EL( 78.0, 95.0, 55.8, 82.7, 0.993, -0.122 );\n\tael[4] = EL( -27.0, 82.0, 44.2, 126.6, 0.951, -0.309 );\n\tael[5] = EL( -37.0, 57.0, 49.4, 138.5, 0.968, -0.253 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\treturn d;\n}\n\nfloat toSmallTilda( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 168.0, 126.0, 178.0, 84.0, 1.000, 0.000 );\n\tael[1] = EL( 196.0, 84.0, 302.9, 120.3, 1.000, 0.017 );\n\tael[2] = EL( 177.0, 295.0, 189.0, 95.0, 1.000, 0.000 );\n\tael[3] = EL( 106.0, 310.0, 337.2, 104.9, 1.000, -0.017 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\treturn d;\n}\n\nfloat toCharE3( vec2 uv )\n{\n\tEL ael[7];\n\tael[0] = EL( 170.0, 229.0, 100.0, 244.3, 0.909, -0.418 );\n\tael[1] = EL( 201.0, 253.0, 102.4, 268.7, 0.887, -0.462 );\n\tael[2] = EL( 66.0, -136.0, 100.0, 153.6, 0.921, -0.391 );\n\tael[3] = EL( 79.0, -126.0, 87.3, 142.4, 0.921, -0.391 );\n\tael[4] = EL( 118.0, -126.0, 54.0, 69.8, 0.891, -0.454 );\n\tael[5] = EL( 116.0, -142.0, 47.9, 61.1, 0.866, -0.500 );\n\tael[6] = EL( 75.0, -157.0, 12.8, 11.8, 0.946, -0.326 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\treturn d;\n}\n\nfloat toCharq( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 120.0, -80.0, 74.8, 359.8, 0.875, -0.485 );\n\tael[1] = EL( 117.0, -50.0, 81.7, 390.5, 0.883, -0.469 );\n\tael[2] = EL( 215.0, 101.0, 66.8, 103.1, 0.940, -0.342 );\n\tael[3] = EL( 224.0, 116.0, 52.6, 95.7, 0.914, -0.407 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n    d = min( d, toSmallTilda( uv + vec2( -50.0, 0.0 ) ) );\n\treturn d;\n}\n\nfloat toCharm( vec2 uv )\n{\n\tEL ael[9];\n\tael[0] = EL( 273.0, -7.0, 100.0, 224.2, 0.875, -0.485 );\n\tael[1] = EL( 264.0, -20.0, 88.4, 225.2, 0.866, -0.500 );\n\tael[2] = EL( 139.0, -3.0, 100.0, 227.4, 0.875, -0.485 );\n\tael[3] = EL( 131.0, -16.0, 85.9, 229.6, 0.875, -0.485 );\n\tael[4] = EL( 305.0, -126.0, 417.0, 130.0, 1.000, 0.000 );\n\tael[5] = EL( -21.0, -86.0, 100.0, 313.6, 0.906, -0.423 );\n\tael[6] = EL( -38.0, -105.0, 88.2, 323.4, 0.899, -0.438 );\n\tael[7] = EL( -99.0, 58.0, 100.0, 261.7, 0.899, -0.438 );\n\tael[8] = EL( 95.0, -110.0, 195.0, 101.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n\td = max( d, -toEL( uv, ael[8] ) );\n    d = min( d, toCharTilda( vec2( uv + vec2( -135.0, 190.0 ) ) ) );\n\treturn d;\n}\n\nfloat toCharp2( vec2 uv )\n{\n\tfloat d = toEL( uv, EL( 145.0, 100.0, 100.0, 100.0, 1.0, 0.0 ) );\n    d = max( d, -toEL( uv, EL( 182.0, 90.0, 139.0, 112.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 95.0, 68.0, 49.0, 141.0, 0.92, -0.39 ) ) );\n    d = max( d, -toEL( uv, EL( 71.0, 28.0, 51.5, 180.2, 0.92, -0.39 ) ) );\n    d = min( d, toCharj( uv + vec2( 70.0, 0.0 ) ) );\n    return d;\n}\n\nfloat toQuotes( vec2 uv )\n{\n\tEL ael[11];\n\tael[0] = EL( -61.0, 222.0, 153.0, 95.1, 0.643, -0.766 );\n\tael[1] = EL( -34.0, 239.0, 175.2, 119.3, 0.755, -0.656 );\n\tael[2] = EL( -185.0, 208.0, 128.7, 48.4, 0.500, -0.866 );\n\tael[3] = EL( -175.0, 152.0, 52.9, 170.0, 0.899, 0.438 );\n\tael[4] = EL( -250.0, 295.0, 13.0, 11.0, 1.000, 0.000 );\n\tael[5] = EL( 4.0, 98.0, 10.0, 8.0, 1.000, 0.000 );\n\tael[6] = EL( -77.0, 68.0, 87.3, 25.0, 1.000, 0.000 );\n\tael[7] = EL( -82.0, 75.0, 96.0, 22.0, 0.999, -0.052 );\n\tael[8] = EL( -180.0, 84.0, 44.7, 7.5, 0.777, -0.629 );\n\tael[9] = EL( -216.0, 103.0, 11.0, 11.0, 1.000, 0.000 );\n\tael[10] = EL( -5.0, 61.0, 12.0, 9.8, 0.914, 0.407 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n\td = min( d, toEL( uv, ael[8] ) );\n\td = min( d, toEL( uv, ael[9] ) );\n\td = min( d, toEL( uv, ael[10] ) );\n\treturn d;\n}\n\n// -------------------------------------------------------\n//  Text rendering: https://www.shadertoy.com/view/MtS3RK\n// -------------------------------------------------------\nfloat texScriptF( vec2 uv )\n{\n    uv.x -= uv.y * 0.15;\n    float d = toQuotes( uv + vec2( -180.0, 0.0 ) );\n    d = min( d, toCharC( uv + vec2( -200.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -200.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -340.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -480.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -630.0, 0.0 ) ) );\n    d = min( d, toCharZ( uv + vec2( -760.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -760.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -960.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -960.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -1230.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -1320.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -1470.0, 0.0 ) ) );\n    d = min( d, toCharh( uv + vec2( -1590.0, 0.0 ) ) );\n    d = min( d, toCharpm( uv + vec2( -1820.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -2190.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -2280.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -2280.0, 0.0 ) ) );\n    d = min( d, toCharE1( uv + vec2( -2450.0, 0.0 ) ) );\n    d = min( d, toCharY2( uv + vec2( -2670.0, 0.0 ) ) );\n    d = min( d, toPeriod( uv + vec2( -3000.0, 0.0 ) ) );\n    \n    d = min( d, toCharC( uv + vec2( -3400.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -3400.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -3540.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -3680.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -3830.0, 0.0 ) ) );\n    d = min( d, toCharZ( uv + vec2( -3960.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -3960.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -4160.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -4160.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -4510.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -4510.0, 0.0 ) ) );\n    d = min( d, toCharpm( uv + vec2( -4770.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -4920.0, -70.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -4920.0, -50.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -5140.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -5230.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -5230.0, 0.0 ) ) );\n    d = min( d, toCharE2( uv + vec2( -5420.0, 0.0 ) ) );\n    d = min( d, toQuotes( vec2( -uv.x, uv.y ) + vec2( 5760.0, 0.0 ) ) );\n\n\n    d = min( d, toCharC( uv + vec2( -6200.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -6200.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -6340.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -6480.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -6630.0, 0.0 ) ) );\n    d = min( d, toCharZ( uv + vec2( -6760.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -6760.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -6960.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -6960.0, 0.0 ) ) );\n    d = min( d, toCharC2( uv + vec2( -7260.0, 0.0 ) ) );\n    d = min( d, toCharY3( uv + vec2( -7440.0, 0.0 ) ) );\n    d = min( d, toCharq( uv + vec2( -7460.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -7590.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -7740.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -7830.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -7800.0, 0.0 ) ) );\n    d = min( d, toCharE1( uv + vec2( -8000, 0.0 ) ) );\n    d = min( d, toCharY2( uv + vec2( -8220.0, 0.0 ) ) );\n    d = min( d, toPeriod( uv + vec2( -8550.0, 0.0 ) ) );\n    \n    d = min( d, toCharw( uv + vec2( -9000.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -9000.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -9050.0, 0.0 ) ) );\n    d = min( d, toCurl2( uv + vec2( -9180.0, 0.0 ) ) );\n    d = min( d, toCharpm( uv + vec2( -9260.0, 0.0 ) ) );\n    d = min( d, toCharh( uv + vec2( -9630.0, 0.0 ) ) );\n\td = min( d, toCharE3( uv + vec2( -9920.0, 0.0 ) ) );\n    d = min( d, toCharm( uv + vec2( -10030.0, 0.0 ) ) );\n    d = min( d, toCurl( uv + vec2( -10150.0, 0.0 ) ) );\n    d = min( d, toCharC( uv + vec2( -10430.0, 0.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -10430.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -10560.0, 0.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -10650.0, 0.0 ) ) );\n    d = min( d, toCharq( uv + vec2( -10620.0, 0.0 ) ) );\n    d = min( d, toCharY3( uv + vec2( -10940.0, 0.0 ) ) );\n    d = min( d, toCharp2( uv + vec2( -11130.0, 0.0 ) ) );\n    d = min( d, toSmallTilda( uv + vec2( -11080.0, 200.0 ) ) );\n    d = min( d, toSmallTilda( uv + vec2( -11080.0, -50.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -11100.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -11310.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -11400.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -11380.0, 0.0 ) ) );\n    d = min( d, toCharE1( uv + vec2( -11600.0, 0.0 ) ) );\n    \n    if ( d <= 0.0 ) return 1.0;\n    else return 0.0;\n}\n\n// --------------------\n//  \"noisy\" gold color\n// --------------------\nvec3 Gold(vec3 p, float fade)\n{\n    p += .4 * noise(p * 24.);\n    float t = noise(p * 30.);\n\n    vec3 gold = mix(GOLD1, GOLD2, smoothstep(.55, .95, t));\n    // darker gold tint if the inscription is visible\n    gold = mix(gold, GOLD3, smoothstep(.45, .25, t)) * (1. - 0.666 * fade);\n\n    return gold;\n}\n\n// ----------------------------------------\n//  calculate ray direction for eye/camera\n// ----------------------------------------\nvec3 EyeRay(vec2 fragCoord, vec3 eyeDir)\n{\n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv * 2.0 - 1.0;\n  \tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 forward = normalize(eyeDir);\n\tvec3 right   = normalize(cross(vec3(.0, 1., .0), forward));\n\tvec3 up      = normalize(cross(forward, right));    \n\n\treturn normalize(uv.x * right + uv.y * up + forward * FOV);\n}\n\n// ----------------------------------------------\n//  SDF for the ring - a slightly deformed torus\n// ----------------------------------------------\nfloat Ring(vec3 pos)\n{\n    vec2 t = vec2(RING_RADIUS, RING_RADIUS * .2);\n    vec2 q = vec2(clamp(2. * (length(pos.xz) - t.x), -5., 5.),pos.y);\n\n    return length(q) - t.y;\n}\n\n// -------------------------------\n//  flickering hellish background\n// -------------------------------\nvec3 Background(vec3 ray)\n{ \n    return texture(iChannel2, ray).rgb * vec3(.7, .15, .0) * (1. + texture(iChannel1, vec2(0., 0.)).r);\n}\n\n// ----------------\n//  surface normal\n// ----------------\nvec3 SurfaceNormal(in vec3 pos)\n{\n    vec3 eps = vec3( MIN_DIST, 0., 0. );\n    return normalize(-vec3(Ring(pos + eps.xyy) - Ring(pos - eps.xyy),\n                           Ring(pos + eps.yxy) - Ring(pos - eps.yxy),\n                           Ring(pos + eps.yyx) - Ring(pos - eps.yyx)));\n}\n\n// ------------------\n//  scene raymarcher\n// ------------------\nRMInfo Raymarch(vec3 from, vec3 to)\n{\n    float t = 0.;\n    int objId = BACKGROUND_ID;\n    vec3 pos;\n    vec3 normal;\n    float dist;\n    \n  \tfor (int i = 0; i < NUM_STEPS; ++i)\n    {\n    \tpos = from + to * t;\n        dist = Ring(pos);\n\n        if (dist > MAX_DIST || abs(dist) < MIN_DIST)\n            break;\n\n        t += dist * 0.43;\n        objId = RING_ID;\n  \t}\n    \n    if (t < MAX_DIST)\n    {\n        normal = SurfaceNormal(pos);\n    }\n    else\n    {\n        objId = BACKGROUND_ID;\n    }\n\n    return RMInfo(pos, normal, objId);\n}\n\n\n// -------------------------\n//  here be scene rendering\n// -------------------------\nvec4 Draw(vec2 fragCoord)\n{   \n    vec3   col = vec3(0.);\n  \tvec3   ray = EyeRay(fragCoord, -EYE);\n  \tRMInfo rmi = Raymarch(EYE, ray);\n\n    if (rmi.objId == RING_ID)\n    {\n        vec2 uv;\n        float fade = max(0., sin(iTime * .3));\n        col = mix(col, Gold(rmi.pos, fade) * texture(iChannel0, reflect(ray, rmi.normal)).rgb, .99);            \n        rmi = Raymarch(rmi.pos, reflect(ray, rmi.normal));\n\n        // render the inscription!\n        uv.x = atan( rmi.pos.z, rmi.pos.x ) / 3.14159;\n        uv.y = 2.0 * rmi.pos.y;\n\n        if ( uv.y > vMin && uv.y < vMax )\n        {\n            uv.x = ( uv.x + 1.0 ) * 0.5;\n            uv.y = 1.0 - ( uv.y - vMin ) / ( vMax - vMin );\n            float s = texScriptF( uv * vec2( 12500.0, -800.0 ) + vec2( 0.0, 450.0 ));\n\n            // text is flickering depending on current audio value\n            col += vec3( 0.9, 0.9, 0.5 ) * 1.5 * fade * vec3(1., .3, 0.) * (1. + 10. * texture(iChannel1, vec2(50., 0.)).r) * s;\n        }\n    }\n    else if(rmi.objId == BACKGROUND_ID)\n    {\n        col += Background(ray);\n    }\n\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    EYE.xy = rotate(EYE.xy, iTime * .03 + .015);\n    EYE.yz = rotate(EYE.yz, iTime * .03 + .015);\n\n    // Antialiasing: https://www.shadertoy.com/view/XdVSRV\n#if ANTIALIASING\n    vec4 vs = vec4(0.);\n    for (int j = 0; j < AA_SAMPLES ;j++)\n    {\n        float oy = float(j) * AA_WIDTH / max(float(AA_SAMPLES - 1), 1.);\n        for (int i = 0; i < AA_SAMPLES; i++)\n        {\n            float ox = float(i) * AA_WIDTH / max(float(AA_SAMPLES - 1), 1.);\n            vs += Draw(fragCoord + vec2(ox, oy));\n        }\n    }\n\n    fragColor = vs/vec4(AA_SAMPLES * AA_SAMPLES);\n#else\n    fragColor = Draw(fragCoord);\n#endif\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21348, "src": "https://soundcloud.com/dnd-music-444515068/sauron-voice-black-speech", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[899, 964, 985, 985, 1025], [1027, 1176, 1197, 1197, 1597], [1599, 1661, 1691, 1691, 1768], [2004, 2004, 2030, 2030, 2246], [2248, 2248, 2283, 2283, 2538], [2540, 2540, 2566, 2566, 3012], [3014, 3014, 3040, 3040, 3840], [3842, 3842, 3868, 3868, 4110], [4112, 4112, 4139, 4139, 4366], [4368, 4368, 4394, 4394, 5002], [5004, 5004, 5030, 5030, 5424], [5426, 5426, 5452, 5452, 6219], [6221, 6221, 6251, 6251, 6552], [6554, 6554, 6580, 6580, 6789], [6791, 6791, 6816, 6816, 7487], [7489, 7489, 7515, 7515, 7907], [7909, 7909, 7935, 7935, 8435], [8437, 8437, 8464, 8464, 9306], [9308, 9308, 9335, 9335, 9734], [9736, 9736, 9763, 9763, 10581], [10583, 10583, 10610, 10610, 11357], [11359, 11359, 11386, 11386, 12177], [12179, 12179, 12206, 12206, 12319], [12321, 12321, 12348, 12348, 12917], [12919, 12919, 12946, 12946, 13517], [13519, 13519, 13550, 13550, 13943], [13945, 13945, 13972, 13972, 14649], [14651, 14651, 14677, 14677, 15130], [15132, 15132, 15158, 15158, 16094], [16096, 16096, 16123, 16123, 16482], [16484, 16484, 16511, 16511, 17543], [17545, 17721, 17750, 17750, 22523], [22525, 22596, 22627, 22627, 22898], [22900, 23031, 23073, 23073, 23402], [23404, 23553, 23575, 23575, 23726], [23728, 23832, 23859, 23859, 23966], [23968, 24027, 24060, 24060, 24315], [24317, 24382, 24419, 24419, 24917], [24920, 25006, 25033, 25033, 26102], [26104, 26104, 26159, 26159, 26775]], "test": "untested"}
{"id": "tlGXDD", "name": "Dawn Tree", "author": "clepirelli", "description": "Small test of a tree with dawn-colored leaves", "tags": ["sdf", "npr"], "likes": 2, "viewed": 338, "published": 3, "date": "1582727125", "time_retrieved": "2024-07-30T21:21:58.992172", "image_code": "vec3 bodyStart = vec3(.0,-.5,.0), bodyEnd = vec3(.0,.2,.0);\n#define branchEnd bodyEnd + vec3(.4,.2,.0)\n#define otherBranchEnd bodyEnd + vec3(-.2,.3,.0)\n#define thirdBranchEnd bodyEnd + vec3(.0,.2,.2)\nbox boundingBox = box(vec3(-.5,-.4,-.5), vec3(.8, 1.0, .6));\n\n//#define DEBUG_BOX\n\nsdfRet tree(vec3 point)\n{\n    sdfRet returnVal;\n    \n    float body = lineSegment(\n            point,\n            bodyEnd,\n            bodyStart,\n            .04\n        );\n    \n    float branch = lineSegment(\n    \tpoint,\n        branchEnd,\n        bodyEnd,\n        .03\n    );\n    \n    float otherBranch = lineSegment(\n    \tpoint,\n        otherBranchEnd,\n        bodyEnd,\n        .02\n    );\n    \n    float thirdBranch = lineSegment(\n    \tpoint,\n        thirdBranchEnd,\n        bodyEnd,\n        .02\n    );\n    \n    float smoothing = .05;\n    float ret = opSmoothUnion(branch, body, smoothing);\n    ret = opSmoothUnion(otherBranch, ret, smoothing);\n    ret = opSmoothUnion(thirdBranch, ret, smoothing);\n    returnVal.dist = ret;\n    \n    return returnVal;\n}\n\nsdfRet leaves(vec3 point)\n{\n\t sdfRet returnVal;\n    \n    float body = sphere(\n            point,\n            bodyEnd,\n            .2\n    );\n    \n    float branch = sphere(\n            point,\n            branchEnd,\n            .4\n    );\n    \n    float otherBranch = sphere(\n            point,\n            otherBranchEnd,\n            .3\n    );\n    \n    float thirdBranch = sphere(\n    \tpoint,\n        thirdBranchEnd,\n        .3\n    );\n    \n    float smoothing = .1;\n    float ret = opSmoothUnion(branch, body, smoothing);\n    ret = opSmoothUnion(otherBranch, ret, smoothing);\n    ret = opSmoothUnion(thirdBranch, ret, smoothing);\n    returnVal.dist = ret;\n    \n    return returnVal;\n}\n\nray getCurrentRay(vec2 uv)\n{\n\tfloat mousex = 9.0*iMouse.x/iResolution.x;\n    \n       //camera calculations\n    vec3 target = bodyEnd;\n    float mousey = 2.0;\n    vec3 rayOrigin = target + vec3(1.5*sin(mousex),.2,1.5*cos(mousex))*mousey;\n    vec3 front = normalize(target - rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \n    return ray(rayOrigin, rayDir);\n}\n\nvec3 sky(ray currentRay)\n{\n    return mix(WHITE, BLUE, .5*(currentRay.direction.y+1.0));\n}\n\nvec3 marchLeaves(ray currentRay)\n{\n    vec3 col = vec3(.0);\n    float currentDistance = .0;\n    float closestDistance = 1000000.0;\n    bool hit = false;\n\tfor(int i = 0; i < 100; i++)\n    {\n        vec3 samplePoint = currentRay.origin + currentRay.direction*currentDistance;\n        sdfRet ret = leaves(samplePoint);\n        closestDistance = min(closestDistance, ret.dist);\n        if(ret.dist < CLOSE_ENOUGH)\n        {\n            hit = true;\n            col = mix(vec3(1.0, .5, .5), BLUE, currentRay.direction.y * 4.5);\n            break;\n        }\n        currentDistance += ret.dist;\n    }\n    \n    if(!hit)\n    {\n        \n        col = mix(sky(currentRay), vec3(.0), step(closestDistance, .01));\n    }\n    \n    return col;\n}\n\nvec3 march(ray currentRay)\n{\n    #ifdef DEBUG_BOX\n    if(inBox(currentRay, boundingBox)) return vec3(.0);\n    #endif\n    if(!inBox(currentRay, boundingBox)) return sky(currentRay);\n        \n    vec3 col = vec3(.0);\n\tfloat currentDistance = .0;\n    float closestDistance = 1000000.0;\n    bool hit = false;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 samplePoint = currentRay.origin + currentRay.direction*currentDistance;\n        sdfRet ret = tree(samplePoint);\n        closestDistance = min(closestDistance, ret.dist);\n        if(ret.dist < CLOSE_ENOUGH)\n        {\n            hit = true;\n            col = BROWN;\n            break;\n        }\n        currentDistance += ret.dist;\n    }\n    \n    if(!hit)\n    {\n        if(closestDistance > .01)\n        \tcol = marchLeaves(currentRay);\n    }\n    \n    return col;\n}\n\nconst int aa = 2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(.0);\n    //MSAA\n    for(int i = 0; i <aa;i++)\n    for(int j = 0; j <aa;j++)\n    {\n    \t//offset the uv for MSAA\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\n    \tuv.x *= iResolution.x/iResolution.y;\n\n    \tray currentRay = getCurrentRay(uv);\n    \n    \ttotal += march(currentRay);\n    }\n\ttotal /= float(aa*aa);\n    fragColor = vec4(pow(total, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "#define CLOSE_ENOUGH 0.001\n#define WHITE vec3(1.0,1.0,1.0)\n#define BLUE vec3(.5,.7,1.0)\n#define BROWN vec3(139.,69.,19.)/255.0\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct sdfRet\n{\n    float dist;\n};\n    \nfloat lineSegment(vec3 samplePoint, vec3 pointA, vec3 pointB, float radius)\n{\n    vec3 baDifference = pointB-pointA;\n    float h = min(1.0, max(.0, dot(samplePoint-pointA, baDifference)/dot(baDifference, baDifference)));\n    \n    return length(samplePoint - pointA-(baDifference)*h)-radius;\n}\n\nfloat sphere(vec3 samplePoint, vec3 origin, float radius)\n{\n\treturn distance(samplePoint,origin)-radius;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nstruct box\n{\n    vec3 leftBottom, rightTop;\n};\n\nbool inBox(ray currentRay, box givenBox){\n\n    vec3 dirfrac = vec3(\n    \t1.0 / currentRay.direction.x,\n\t\t1.0 / currentRay.direction.y,\n\t\t1.0 / currentRay.direction.z\n    );\n    \n    vec3 lb = givenBox.leftBottom;\n    vec3 rt = givenBox.rightTop;\n    \n\t// lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n\t// r.org is origin of ray\n\tfloat t1 = (lb.x - currentRay.origin.x)*dirfrac.x;\n\tfloat t2 = (rt.x - currentRay.origin.x)*dirfrac.x;\n\tfloat t3 = (lb.y - currentRay.origin.y)*dirfrac.y;\n\tfloat t4 = (rt.y - currentRay.origin.y)*dirfrac.y;\n\tfloat t5 = (lb.z - currentRay.origin.z)*dirfrac.z;\n\tfloat t6 = (rt.z - currentRay.origin.z)*dirfrac.z;\n\t\n\tfloat tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n\tfloat tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\t\n\treturn (tmax > 0.) && (tmin < tmax);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 308, 308, 1038], [1040, 1040, 1067, 1067, 1722], [1724, 1724, 1752, 1752, 2213], [2215, 2215, 2241, 2241, 2305], [2307, 2307, 2341, 2341, 3036], [3038, 3038, 3066, 3066, 3858], [3878, 3878, 3935, 3935, 4366]], "test": "untested"}
{"id": "wlGXWW", "name": "1d celular automata (156 chars)", "author": "FabriceNeyret2", "description": "golfing and rescaling [url]https://www.shadertoy.com/view/3tGXDD[/url] ( 899 chars )\n\ncould it be smaller ? :-)", "tags": ["2d", "automata", "2tweets", "short", "golf", "seashell"], "likes": 4, "viewed": 397, "published": 3, "date": "1582705325", "time_retrieved": "2024-07-30T21:21:59.759121", "image_code": "void mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// golfing and rescaling lucastakejame's https://www.shadertoy.com/view/3tGXDD ( 899 chars )\n\n#define mi                                               \\\n    vec2 R = iResolution.xy;                             \\\n    for( int b = 30, i = 0;   ++i < 4;                   \\\n   \t     O = vec4( U.y > R.y-1. ? int(U-R/2.) : b & 1 )  \\\n       ) texture( iChannel0, ( U + vec2(i-2,1 ) )/R ) != O-O ? b >>= 8>>i : 0; /*\n\n\n\n\n\n\n// --- 158 chars variant\n\n#define mainImage(O,U)                                   \\\n    vec2 R = iResolution.xy;                             \\\n    for( int b = 30, i = -1;   ++i < 3;                  \\\n   \t     O = vec4( U.y > R.y-1. ? int(U-R/2.) : b & 1 )  \\\n       ) texture( iChannel0, ( U + vec2(i-1,1 ) )/R ).x != 0. ? b >>= 4>>i : 0  /*\n\n\n\n\n\n\n// --- 163 chars variant\n\n#define S(i) ( texture( iChannel0, ( U + vec2(i-1,1 ) )/R ) .x != 0. ? 4>>i : 0)//\n#define mainImage(O,u)                                                           \\\n    vec2 R = iResolution.xy, U=u;                                                \\\n   \tO = vec4( U.y > R.y-1. ? int(U-R/2.) :  30 >> S(0)+S(1)+S(2) & 1 )          /*\n\n\n\n\n\n\n// --- 163 chars\n\n#define mainImage(O,U)                           \\\n    vec2 R = iResolution.xy;                     \\\n    int  b = 30;                                 \\\n    for( int i = 0; i < 3; i++  )                \\\n        texture( iChannel0, ( U + vec2(i-1,1 ) )/R ).x != 0. ? b >>= 4>>i : 0; \\\n   \tO = vec4( U.y > R.y-1. ? int(U-R/2.) : b & 1 )                             /*\n\n\n\n\n\n\n// --- 167 chars\n\n#define mainImage(O,U)                           \\\n    vec2 R = iResolution.xy;                     \\\n    int  b = 30;                                 \\\n    for( int i = 0; i < 3; i++  )                \\\n        texture( iChannel0, ( U + vec2(i-1,1 ) )/R ).x > 0. ? b >>= 4>>i : 0; \\\n   \tO = vec4( U.y > R.y-1. ? abs(int(U-R/2.)) : b & 1 )                       /*\n\n\n\n\n\n\n// --- 174 chars\n            \n#define mainImage(O,U)                          \\\n    vec2 R = iResolution.xy;                    \\\n    int  b = 0;                                 \\\n    for( int i = 0; i < 3; i++  )               \\\n        texture( iChannel0, ( U + vec2(i-1,1 ) )/R ).x > 0. ? b += 4>>i : 0; \\\n   \tO = U.y > R.y-1.                            \\\n            ? vec4( int(U-R/2.) == 0  )         \\\n            : vec4(  (30 >> b) & 1 )           /*\n\n/**/", "buffer_a_code": "void mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtGXDD", "name": "RayMarching starting point", "author": "BigWIngs", "description": "Start your raymarching shader with this template", "tags": ["raymarching", "template", "artofcode"], "likes": 120, "viewed": 12070, "published": 3, "date": "1582685766", "time_retrieved": "2024-07-30T21:22:00.633783", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXDD.jpg", "access": "api", "license": "mit", "functions": [[1515, 1515, 1534, 1534, 1596], [1598, 1598, 1627, 1627, 1708], [1711, 1711, 1734, 1734, 1788], [1790, 1790, 1824, 1824, 2035], [2037, 2037, 2061, 2061, 2215], [2217, 2217, 2267, 2267, 2452], [2454, 2454, 2511, 2511, 3113]], "test": "untested"}
{"id": "3tyXDW", "name": "Warping Fur", "author": "oddlama", "description": "Warping lines based on fbm", "tags": ["procedural", "2d", "fbm", "warp"], "likes": 11, "viewed": 502, "published": 3, "date": "1582673074", "time_retrieved": "2024-07-30T21:22:01.393751", "image_code": "/*\nMIT License\n\nCopyright (c) 2020 oddlama\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n\n\n// SETTINGS\n\n// Adjusts the animation speed\nconst float time_speed = 0.3;\n// grid pixel dimensions\nconst vec2 grid_size = vec2(30.0);\n// length of line (CAREFUL DONT go > 6, this is O(n^2) !! )\nconst float line_len_factor = 4.0;\n// Thickness of lines\nconst float line_width = 4.6;\n\n// PRE-COMPUTED CONSTANTS, DON'T CHANGE\n\nconst ivec2 grid_neighborhood = ivec2(int(line_len_factor) - 1);\nconst float line_width_antialias = 1.0;\nconst float line_bounding_width = line_width + line_width_antialias;\n\n\n\n////////////////////////////////////////////////// NOISE FUNCTIONS\n\nfloat random (in vec2 x) {\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\nfloat fbm(in vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\n////////////////////////////////////////////////// Helpers\n\nvec2 nearest_grid_pos(vec2 frag_coord) {\n    return round(frag_coord / grid_size) * grid_size;\n}\n\nvec2 screenToUniform(vec2 x) {\n    return x * vec2(1. / iResolution.x);\n}\n\nfloat fbm_warp(vec2 x, out vec2 q, out vec2 r) {\n    q = vec2(fbm(x + vec2(0.0, 0.0)),\n             fbm(x + vec2(5.2, 1.3)));\n\n   \tfloat t = (iTime + 29.) * time_speed;\n    r = vec2(fbm(x + 4.0 * q + vec2(1.7, 9.2) + .15 * t),\n             fbm(x + 4.0 * q + vec2(8.3, 2.8) + .12 * t));\n    return fbm(x + 4.0 * r);\n}\n\n\n////////////////////////////////////////////////// VECTOR FIELDS\n// f = vectorfield at screen pos, f_color = color at screen pos\n\nfloat f(vec2 x, out vec2 y) {\n    x = screenToUniform(x);\n    vec2 q, r;\n    float k = fbm_warp(x, q, r);\n    r = (r + vec2(-.5)) * 2.;\n    y = grid_size * line_len_factor * r;\n    return k;\n}\n\nvec3 f_color(vec2 x) {\n    x = screenToUniform(x);\n    vec2 q, r;\n    float f = fbm_warp(x * 2., q, r);\n    \n    vec3 col = vec3(0.0);\n    col = mix( vec3(0.4,0.2,0.2), vec3(1.5,0.4,0.1), f );\n    col = mix( col, vec3(0.1,0.6,0.9), dot(r,r) );\n    col = mix( col, vec3(0.2,1.19,1.09), 0.5*q.y*q.y );\n    col *= (1. + q.x * q.x * q.x);\n    col = mix( col, vec3(0.0,1.39,1.49), 0.3*smoothstep(1.2,1.3,abs(r.y)+abs(r.x)) );\n    col *= f * 2.0;\n    return col;\n}\n\n\n////////////////////////////////////////////////// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 frag_coord) {    \n    vec3 col = vec3(0.0);\n    \n    // Any pixel can be occluded by multiple lines. Only lines from neighboring\n    // grid anchors will be considered.\n    float active_lines = 0.0;\n    for (int i = -grid_neighborhood.x; i <= grid_neighborhood.x; ++i) {\n        for (int j = -grid_neighborhood.y; j <= grid_neighborhood.y; ++j) {\n    \t\t// Beginning of the line is at the nearest grid anchor\n\t    \tvec2 line_a = nearest_grid_pos(frag_coord + grid_size * vec2(i, j));\n            // End of the line is the beginning but offset by the value of\n            // our vector field at that position\n            vec2 x;\n            float k = f(line_a, x);\n            vec2 line_b = line_a + x;\n            \n            vec2 line_dir = normalize(x);\n            // Project pixel coord to the line\n            float px_proj = dot(line_dir, frag_coord);\n            // la will always be <= lb. (To proof simply replace line_b with line_a + line_dir, solve inequality)\n            // Informal: The projected point x on d is always <= the projected point (x + d) on d.\n            float la_proj = dot(line_dir, line_a);\n            float lb_proj = dot(line_dir, line_b);\n            // We account for the line width by subtracting from la and adding to lb.\n            float la_proj_w = la_proj - line_width;\n            float lb_proj_w = lb_proj + line_width;\n            \n            // Check if projected point is on line\n            if (la_proj_w < px_proj && px_proj < lb_proj_w) {\n                // Calculate distance to line segment on this local axis\n                float dx = distance(px_proj, clamp(px_proj, la_proj, lb_proj));\n                \n                // Now do the projection on the perpendicular axis to get the distance on\n                // the axis perpendicular to the line\n                vec2 perp = line_dir.yx * vec2(1, -1);\n                float px_proj_perp = dot(perp, frag_coord);\n                float la_proj_perp = dot(perp, line_a);\n                \n                // Distance is easier here, as the line is infinitely small, so we don't need clamping.\n                float dy = distance(la_proj_perp, px_proj_perp);\n\n                // Calculate distance from line segment given distances on local axis\n                float dist = length(vec2(dx, dy));\n                if (dist < line_bounding_width) {\n                    // alpha is the relative position of px in the line\n                    float alpha = smoothstep(la_proj, lb_proj, px_proj);\n                    \n                    //vec3 c = mix(col_a, col_b, alpha);\n                    vec3 c = f_color(frag_coord);\n                    \n                    // Line gets lighter at the very end (alpha), but influenced by vector field (k).\n                    // Also add antialiasing to the line edge\n                    float blend = alpha * (.2 + k * 2.) * (1. - smoothstep(line_width, line_bounding_width, dist));\n                    // Blend with previously calculated factor, also make shorter darker everywhere\n                    float len_f = length(x) / (length(grid_size) * line_len_factor);\n                    c *= blend * 1.3 * len_f * (.7 + len_f);\n                    \n                    // Blend color with max\n                    col = max(col, c);\n                }\n            }\n    \t}\n    }\n\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXDW.jpg", "access": "api", "license": "mit", "functions": [[1641, 1641, 1667, 1667, 1742], [1744, 1744, 1769, 1769, 2108], [2132, 2132, 2154, 2154, 2451], [2514, 2514, 2554, 2554, 2610], [2612, 2612, 2642, 2642, 2685], [2687, 2687, 2735, 2735, 3003], [3136, 3136, 3165, 3165, 3328], [3330, 3330, 3352, 3352, 3788], [3848, 3848, 3904, 3904, 7271]], "test": "untested"}
{"id": "3lGXWW", "name": "Irradiance Mapping, SH L2", "author": "4rknova", "description": "L2 Spherical Harmonics evaluation for Grace Cathedral", "tags": ["irradiance", "probe"], "likes": 5, "viewed": 864, "published": 3, "date": "1582665258", "time_retrieved": "2024-07-30T21:22:02.173666", "image_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPSILON\t\t\t\t0.0001\n#define EPSILON_M\t\t\t0.1\n#define PI\t\t\t\t\t3.14159265359\n#define PI2\t\t\t\t\tPI * 0.5\n#define RADIAN\t\t\t\t180.0 / PI\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is Grace Cathedral.\nconst vec3 _SH[9] = vec3[](\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\n// Implementation from https://patapom.com/blog/SHPortal/\n// Evaluates the irradiance perceived in the provided direction\n// Analytic method from http://www1.cs.columbia.edu/~ravir/papers/envmap/envmap.pdf eq. 13\nvec3 Evaluate(vec3 dir) {\n    const float c1 = 0.42904276540489171563379376569857;\n    const float c2 = 0.51166335397324424423977581244463;\n    const float c3 = 0.24770795610037568833406429782001;\n    const float c4 = 0.88622692545275801364908374167057;\n    \n    return  max(vec3(0.0), \n        +  c4 * _SH[0]                                                                           //   c4  L00 \n        +  c2 * 2.0 * (_SH[3] * dir.x + _SH[1]* dir.y + _SH[2]* dir.z)                           // 2 c2 (L11 x + L1-1 y + L10 z)\n        +  c1 * 2.0 * (_SH[4] * dir.x * dir.y + _SH[7] * dir.x * dir.z + _SH[5] * dir.y * dir.z) // 2 c1 (L2-2 xy + L21 xz + L2-1 yz)\n        + (c1 * (dir.x * dir.x - dir.y * dir.y)) * _SH[8]                                        //   c1 L22 (x-y)\n        + (c3 * (3.0 * dir.z * dir.z - 1.0)) * _SH[6]                                            //   c3 L20 (3.z - 1)\n    );\n}\n\nvec3 sph2dir(vec2 p)\n{\n    vec2 s = (p*2.-1.) * vec2(PI,PI * 0.5); // Spherical coords\n    vec4 t = vec4(sin(s), cos(s));       // Precalculated sin/cos values\n    return t.zyx * vec3(t.w, 1, t.w);    // Conversion to direction\n}\n\nvec3 Unwrap(vec2 uv)\n{\n    vec3 d = sph2dir(uv);\n    return Evaluate(d);\n}\n\n// ****************************************************************\n// Ray marching\n// ****************************************************************\n\n#define RMARCH_MAX_STEPS \t64\n#define CLEAR_COLOR\t\t\tvec3(0.2)\n\nfloat des_sphere(vec3 p, float r) { return length(p) - r; }\nvec3  translate (vec3 v, vec3  t) { return v - t; }\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, Camera c, out Ray r)\n{\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\nfloat scene_distance(vec3 p)\n{\n\treturn des_sphere(translate(p, vec3(0)), 1.0);\n}\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z));\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z));\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 p, vec3 n)\n{\n\treturn Evaluate(n);\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos);\n\n\t\tif (d < EPSILON) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\t\n\treturn d < EPSILON;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 nv = (fragCoord.xy / iResolution.xy);\t\n    \n    vec3 col = CLEAR_COLOR;\n    \n    float mode = mod(floor(iTime*.5), 2.0);\n    \n    if (mode == 1.0) {\n        col = Unwrap(nv);\n    }\n    else\n    {\n        vec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n        \t    * vec2(iResolution.x / iResolution.y, 1);\t\n   \n\t\tCamera c;\n\t\tc.p = vec3(cos(iTime) * 4.0, 0, sin(iTime) * 4.0);\n\t\tc.t = vec3(0, 0, 0);\n\t\tc.u = vec3(0, 1, 0); \n   \n\t\n\t\tRay r;\n\t\tgenerate_ray(uv, c, r);\n\t\n\t\tvec3 sp, sn;\n\t\tint iter = RMARCH_MAX_STEPS;\t\n\t\tbool res = rmarch(r, sp, sn, iter);\n\t\n    \n        if (res) {\n            col = scene_shade(sp, sn);    \n        }\n    }\n\t\n\n\tfragColor = vec4(col + Text(iResolution.xy, fragCoord), 1.0);\n}", "image_inputs": [], "common_code": "// Font rendering based on FlyGuy's shader: https://www.shadertoy.com/view/llSGRm\n#define FONTSC_SZ vec2(2.5, 5)     // Font size\n#define SCREEN_SZ vec2(800, 600) // Screen size\n#define CHR       vec4(6,7,6.*FONTSC_SZ.x,9.*FONTSC_SZ.y)  // Character size (xy), spacing(zw)\n#define STR_SZ(c) vec2(c*CHR.zw) // String size\n#define DWN_SC    2.             // Downscale\n\n#define C vec2\nC c_spc = C(      0,      0), c_exc = C( 276705,  32776), c_quo = C(1797408,      0)\n, c_hsh = C(  10738,1134484), c_dol = C( 538883,  19976), c_pct = C(1664033,  68006)\n, c_amp = C( 545090, 174362), c_apo = C( 798848,      0), c_lbr = C( 270466,  66568)\n, c_rbr = C( 528449,  33296), c_ast = C(  10471,1688832), c_crs = C(   4167,1606144)\n, c_per = C(      0,   1560), c_dsh = C(      7,1572864), c_com = C(      0,   1544)\n, c_lsl = C(   1057,  67584), c_0   = C( 935221, 731292), c_1   = C( 274497,  33308)\n, c_2   = C( 934929,1116222), c_3   = C( 934931,1058972), c_4   = C( 137380,1302788)\n, c_5   = C(2048263,1058972), c_6   = C( 401671,1190044), c_7   = C(2032673,  66576)\n, c_8   = C( 935187,1190044), c_9   = C( 935187,1581336), c_col = C(    195,   1560)\n, c_scl = C(    195,   1544), c_les = C( 135300,  66052), c_equ = C(    496,   3968)\n, c_grt = C( 528416, 541200), c_que = C( 934929,1081352), c_ats = C( 935285, 714780)\n, c_A   = C( 935188, 780450), c_B   = C(1983767,1190076), c_C   = C( 935172, 133276)\n, c_D   = C(1983764, 665788), c_E   = C(2048263,1181758), c_F   = C(2048263,1181728)\n, c_G   = C( 935173,1714334), c_H   = C(1131799,1714338), c_I   = C( 921665,  33308)\n, c_J   = C(  66576, 665756), c_K   = C(1132870, 166178), c_L   = C(1065220, 133182)\n, c_M   = C(1142100, 665762), c_N   = C(1140052,1714338), c_O   = C( 935188, 665756)\n, c_P   = C(1983767,1181728), c_Q   = C( 935188, 698650), c_R   = C(1983767,1198242)\n, c_S   = C( 935171,1058972), c_T   = C(2035777,  33288), c_U   = C(1131796, 665756)\n, c_V   = C(1131796, 664840), c_W   = C(1131861, 699028), c_X   = C(1131681,  84130)\n, c_Y   = C(1131794,1081864), c_Z   = C(1968194, 133180), c_lsb = C( 925826,  66588)\n, c_rsl = C(  16513,  16512), c_rsb = C( 919584,1065244), c_pow = C( 272656,      0)\n, c_usc = C(      0,     62), c_a   = C(    224, 649374), c_b   = C(1065444, 665788)\n, c_c   = C(    228, 657564), c_d   = C(  66804, 665758), c_e   = C(    228, 772124)\n, c_f   = C( 401543,1115152), c_g   = C(    244, 665474), c_h   = C(1065444, 665762)\n, c_i   = C( 262209,  33292), c_j   = C( 131168,1066252), c_k   = C(1065253, 199204)\n, c_l   = C( 266305,  33292), c_m   = C(    421, 698530), c_n   = C(    452,1198372)\n, c_o   = C(    228, 665756), c_p   = C(    484, 667424), c_q   = C(    244, 665474)\n, c_r   = C(    354, 590904), c_s   = C(    228, 114844), c_t   = C(   8674,  66824)\n, c_u   = C(    292,1198868), c_v   = C(    276, 664840), c_w   = C(    276, 700308)\n, c_x   = C(    292,1149220), c_y   = C(    292,1163824), c_z   = C(    480,1148988)\n, c_lpa = C( 401542,  66572), c_bar = C( 266304,  33288), c_rpa = C( 788512,1589528)\n, c_tid = C( 675840,      0), c_lar = C(   8387,1147904);\n\nvec2 carret = vec2(0);\n\n// Returns the digit sprite for the given number.\nvec2 digit(float d) {    \n    vec3 r = vec3(0, 0, floor(d));\n         if (r.z == 0.) r.xy = c_0; else if (r.z == 1.) r.xy = c_1;\n    else if (r.z == 2.) r.xy = c_2; else if (r.z == 3.) r.xy = c_3;\n    else if (r.z == 4.) r.xy = c_4; else if (r.z == 5.) r.xy = c_5;\n    else if (r.z == 6.) r.xy = c_6; else if (r.z == 7.) r.xy = c_7;\n    else if (r.z == 8.) r.xy = c_8; else if (r.z == 9.) r.xy = c_9;\n    return r.xy;\n}\n// Extracts bit\nfloat bit(float n, float b) {\n    b = clamp(b,-1.,22.);\n    return floor(mod(floor(n / pow(2.,floor(b))),2.));\n}\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat spr(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv/ FONTSC_SZ);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float b = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? bit(spr.x, b - 21.0) + bit(spr.y, b) : 0.0;\n}\n// Prints a character and moves the carret forward by 1 character width.\nfloat print_char(vec2 ch, vec2 uv) { \n    float px = spr(ch, CHR.xy, uv - carret);\n    carret.x += CHR.z;\n    return px;\n}\n// Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.;\n    \n\tfor(int i = 3; i >= -2; --i) {\n        //Clip off leading zeros.\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0);        \n        float d = mod(number / pow(10., float(i)),10.);\n        \n        if(i == -1) {\n            result += spr(c_per,CHR.xy, uv - dec_pos) * clip;\n            dec_pos.x += CHR.z * clip;\n        }\n        \n        result += spr(digit(d),CHR.xy, uv - dec_pos) * clip;\n        dec_pos.x += CHR.z * clip;\n    }\n    \n    return result;\n}\n\n#define T(x) print_char(x,uv)\nfloat Text(vec2 resolution, vec2 uv)\n{    \n    vec2 res = resolution / DWN_SC,\n         pos = vec2(10,20.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_L) + T(c_2) + T(c_spc) + T(c_S) + T(c_H);\n    \n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[875, 1088, 1113, 1113, 1998], [2000, 2000, 2022, 2022, 2229], [2231, 2231, 2253, 2253, 2305], [2522, 2522, 2557, 2557, 2581], [2582, 2582, 2617, 2617, 2633], [2731, 2731, 2780, 2780, 3118], [3120, 3120, 3150, 3150, 3200], [3202, 3202, 3240, 3240, 3514], [3516, 3516, 3550, 3550, 3573], [3575, 3575, 3633, 3633, 3883], [3885, 3885, 3940, 3940, 4658]], "test": "untested"}
{"id": "3tGSDW", "name": "testetst", "author": "lukeacret", "description": "testets", "tags": ["cine"], "likes": 4, "viewed": 289, "published": 3, "date": "1582665007", "time_retrieved": "2024-07-30T21:22:02.960562", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Luke Acret\",\n\t\"description\": \"Creative Director\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]], "test": "untested"}
{"id": "WtGXWW", "name": "Motion Loop #004", "author": "lsdlive", "description": "Small exercise with fake 3D.", "tags": ["2d", "loop", "motion", "ease"], "likes": 5, "viewed": 379, "published": 3, "date": "1582661257", "time_retrieved": "2024-07-30T21:22:03.726514", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #004\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_004.fs\n\nWith the help of https://thebookofshaders.com/examples/?chapter=motionToolKit\n\n*/\n\n#define bpm 120.\n#define speed .5\n/*\n#define samples_dx .1\n#define position_x .1\n#define position_y .5\n*/\n#define samples_dx .05\n#define position_x .4\n#define position_y 1.\n\n#define AA 5.\n\n#define pi 3.141592\n#define pi_half 1.570796\n#define time (speed*(bpm/60.)*iTime)\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064320\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float t = fract(time * .25);\n    float t_pi = t * 2. * pi;\n    float t_pi_ease =  2. * pi * easeInOutQuad(t);\n        \n    // Construct a sphere with ellipses:\n    // ellipse pos.y = sin(a) * sphere_radius\n    // ellipse radius = cos(a) * sphere_radius\n    // then, animate some values\n    float sphere_radius = .3;\n    vec2 ellipse_scale = vec2(1., 2.);\n    float mask;\n    for (float a = -pi_half; a < pi_half; a += samples_dx) {\n        vec2 pos = vec2(\n            cos(pi * .25 + 2. * a + t_pi) * position_x,\n            sphere_radius * sin(a) * cos(position_y * a * a + t_pi_ease));// y\n\n        pos.y *= 1.2; // y scaling adjustement\n        float radius = sphere_radius * cos(a) + .1 * cos(t_pi) * sin(t_pi);// x\n        float sdf = circle((uv - pos) * ellipse_scale, radius);\n\n        mask += stroke(sdf, .005);\n    }\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXWW.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[631, 764, 800, 800, 872], [874, 874, 910, 910, 941], [943, 1001, 1031, 1031, 1154], [1156, 1156, 1213, 1213, 2226]], "test": "untested"}
{"id": "tlKXDh", "name": "usual V/V bug", "author": "FabriceNeyret2", "description": "again and again: x/x is not 1 in GLSL. same for vec/vec.\nMaybe I post an illustration each time I fall in the pit in order to learn ;-) .\n", "tags": ["glsl", "bug"], "likes": 0, "viewed": 292, "published": 3, "date": "1582642440", "time_retrieved": "2024-07-30T21:22:04.488477", "image_code": "\nvoid mainImage(out vec4 O, vec2 u) {\n    \n    vec2 U = u / iResolution.xy;\n    O = U.x < .5 \n        ? vec4( fract( dot( ceil(U), U/U ) )  )    // left\n        : vec4( fract(U/U),0,0) ;                  // right\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 214]], "test": "untested"}
{"id": "WlKSD1", "name": "thebookofshaders-patterns (89ch)", "author": "FabriceNeyret2", "description": "could it be shorter ? ;-)", "tags": ["2d", "pattern", "short", "onetweet", "golf"], "likes": 4, "viewed": 391, "published": 3, "date": "1582633641", "time_retrieved": "2024-07-30T21:22:05.264402", "image_code": "// -1 by Xor, -1 by Fab\n\nvoid mainImage(out vec4 O, vec2 U) { O = vec4(0,0,0,1);\nO += mod( dot( ceil( U* mat4x2(O.wxxw,.5-O) *6./iResolution.y ), O.wwww), 2.);\n} /*\n\n\n\n\n\n// -1 by s23b\n\n#define mainImage(O,U)                    \\\n    O += mod( dot( ceil( (U.xyxy + vec4( U , U.y,-U )) *3./iResolution.y ), \\\n                   O.wwww), 2. )          /*\n\n\n\n\n  \n// --- 92 chars \n\n#define mainImage(O,U)                    \\\n    O += mod( dot( ceil( vec4( U+U , U+vec2(U.y,-U) ) *3./iResolution.y ), \\\n                   O.wwww), 2. )          /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 61, 61, 161]], "test": "untested"}
{"id": "wl2Xzt", "name": "asddfsadfsdfsa", "author": "lennyjpg", "description": "adsdsfdsfdfs", "tags": ["asddfsdsfdfsa"], "likes": 3, "viewed": 297, "published": 3, "date": "1582583669", "time_retrieved": "2024-07-30T21:22:06.036338", "image_code": "#define PI 3.14159265359\n\n//  Function from Iigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvec3 colors[8] = vec3[]( \n    vec3( 1.0, 0.2, 0.0 ),\n    vec3( 0.1, 0.2, 0.3 ),\n    vec3( 0.1, 0.1, 0.0 ),\n    vec3( 0.4, 0.9, 0.8 ),\n    vec3( 1.0, 1.0, 0.9 ),\n    vec3( 0.4, 0.2, 1.0 ),\n    vec3( 0.6, 1.0, 0.9 ),\n    vec3( 1.0, 0.1, 0.2 ));\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rot = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    \n    \nrot += iTime*0.1;\n    \n    float z = sin(iTime*0.2)+1.5;\n    uv*=z;\n    \n    uv -= vec2(0.5);\n//    uv = rotate2d( sin(iTime*0.1)*PI ) * uv;\n    uv = rotate2d( rot ) * uv;\n uv += vec2(0.5);\n    \n \tuv+= 999.999;\n      //  uv.y+=sin(uv.x*5.3)*0.5;\n\n    \n    uv.x+=iTime*0.1;\n    float t = 9999. + iTime * 0.2;\n   //t += 0.1*(sin(t*11.5)+1.0);\n    vec2 foo = uv;\n    \n   // foo.y+=sin(foo.x*4.0);\n    foo.x += sin(t+5.73+foo.x*1.1)*2.13;\n    foo.x -= cos(t-8.73-foo.x*5.1)*.14;\n\n        //t+= sin(foo.x*61.6)*.2;\n\n    float res = 17.0;\n    foo.x = floor(foo.x*res) / (res-1.0);\n    \n   // foo.y += sin(foo.x*32.156) * t;\n    t*= sin(foo.x*1.6)* 2.2;\n    foo.y += t;\n    \n    float n = rand(vec2(112.5,floor(foo.y*.1)))*43.01;\n    float m = rand(vec2(24.2,floor(foo.y)))*0.28;\n  \n    if(m>0.03) m+= n;\n   // n = min(n,m);\n//    foo.y = floor(fract(foo.y*n)+0.5);\n    foo.y = mod(foo.y+m,0.43);\n   // vec3 cc = colors[int(foo.y*8.0 )];\n    vec3 aa = colors[int(foo.y*6.0 )];\n    vec3 bb = colors[int(foo.y*6.0+.9 )];\n    vec3 cc = mix(aa,bb,foo.y*9.);\n\n    \n    /*\n    float e = rand(foo);\n    vec2 p = uv;\n\n    p.y+=uv.y;\n    \n    float a = fract(p.y*20.0*e);\n    a= floor(a+0.5);\n    \n    vec2 u = fract(p *20.0);\n    float k = length(u-0.5);\n    k = smoothstep(0.0,0.2,k);\n    \n    float s = sin(uv.x);\n    */\n    vec3 ca= vec3(1.0,0.3,0.1);\n    vec3 cb= vec3(1,1,0.4);\n    vec3 c = mix(ca, cb, foo.y);\n    \n    vec3 rgb = hsb2rgb(vec3(foo.y,1.0,1.0));\n    \n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2Xzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 100, 126, 126, 358], [606, 606, 634, 634, 720], [722, 722, 742, 742, 814], [834, 834, 891, 891, 2433]], "test": "untested"}
{"id": "WlKSRh", "name": "Rounded_rectangle", "author": "Arseny", "description": "rounded rectangle", "tags": ["2d"], "likes": 1, "viewed": 285, "published": 3, "date": "1582583173", "time_retrieved": "2024-07-30T21:22:06.903021", "image_code": "vec4 brick(vec4 lrud, vec2 uv){\n    float force = 0.;\n    /*force += 1 / max((uv.x - lrud.l) / (lrud.r - lrud.l), 0.001);\n    force += 1 / max(-(uv.x - lrud.r) / (lrud.r - lrud.l), 0.001);\n    force += 1 / max((uv.y - lrud.d) / (lrud.u - lrud.d), 0.001);\n    force += 1 / max(-(uv.y - lrud.u) / (lrud.u - lrud.d), 0.001);*/\n    force += 1. / max((uv.x - lrud.x) / (lrud.y - lrud.x), 0.001);\n    force += 1. / max(-(uv.x - lrud.y) / (lrud.y - lrud.x), 0.001);\n    force += 1. / max((uv.y - lrud.w) / (lrud.z - lrud.w), 0.001);\n    force += 1. / max(-(uv.y - lrud.z) / (lrud.z - lrud.w), 0.001);\n    return vec4(vec3(sign(force - 20.)), 1.);\n}\n\nfloat rand(float x){\n    x += 0.0007;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat rand_func(float x, float seed){ // from 0 to 1\n    const float freq = 20.;\n    float block = floor(x * freq);\n    float A = rand(block + seed);\n    float B = rand(block + 1. + seed);\n    return mix(A, B, x * freq - block);\n}\n\nvec2 rand(vec2 uv, float seed){\n    seed += 0.01313;\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y * seed)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y * seed)  * 561.5453);\n    return uv;\n}\n\nvec2 cont_rand(vec2 uv, float seed){ // continueous\n    uv += vec2(0.141, 0.123);\n    return vec2(rand_func(seed, rand(uv.x * uv.y * uv.x)), rand_func(seed, rand(uv.x * uv.y * uv.y)));\n}\n\nvec2 uvtransform(vec2 uv, float strength, float seed){ // continueous\n    float clsz = 0.1; // cellsize\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    //vec2 A = mix(rand(nwuv + vec2(0., 0.)  , seed), rand(nwuv + vec2(clsz, 0.)  , seed), (uv - nwuv).x / clsz);\n    //vec2 B = mix(rand(nwuv + vec2(0., clsz), seed), rand(nwuv + vec2(clsz, clsz), seed), (uv - nwuv).x / clsz);\n    //vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    vec2 A = nwuv + vec2(0., 0.) * clsz;\n    A = cont_rand(A, seed);\n    vec2 B = nwuv + vec2(1., 0.) * clsz;\n    B = cont_rand(B, seed);\n    vec2 C = nwuv + vec2(0., 1.) * clsz;\n    C = cont_rand(C, seed);\n    vec2 D = nwuv + vec2(1., 1.) * clsz;\n    D = cont_rand(D, seed);\n    vec2 AB = mix(A, B, (uv - nwuv).x / clsz);\n    vec2 CD = mix(C, D, (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 ans = mix(AB, CD, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nvec2 distortion(vec2 uv, float strength, int power, float seed){\n    for (int i = 0; i < power; i++){\n        uv = uvtransform(uv, strength, seed);\n    }\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = distortion(uv, 0.01, 10, iTime / 20.);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = brick(vec4(0.3, 0.7, 0.3, 0.7), uv);//vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 641], [643, 643, 663, 663, 755], [757, 757, 794, 809, 987], [989, 989, 1020, 1020, 1340], [1342, 1342, 1378, 1393, 1528], [1530, 1530, 1584, 1599, 2637], [2639, 2639, 2703, 2703, 2809], [2811, 2811, 2868, 2918, 3191]], "test": "untested"}
{"id": "WlySWh", "name": "ghost fractal", "author": "loicvdb", "description": "Simple volume scattering, originally just a test but I decided to animate it.", "tags": ["fractal", "volume", "cloud", "volumetric", "fog", "scattering", "atmosphere", "atmospheric"], "likes": 86, "viewed": 2486, "published": 3, "date": "1582579991", "time_retrieved": "2024-07-30T21:22:07.810594", "image_code": "#define Log2BlurRadius 1.5\n#define NoiseStrength .4\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, Log2BlurRadius);\n    \n    // yes the noise is added afterwards\n    float random = texture(iChannel1, (fragCoord+vec2(iFrame*50))/iChannelResolution[1].xy).x;\n    float noise = exp((random*.5-.5)*NoiseStrength);\n    fragColor = vec4(ACESFilm(fragColor.rgb*noise), 1.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Pi 3.14159265359\n\n//set to 1 for a higher quality version\n#define HD 0\n\n#if HD\n    #define FogSteps 128\n    #define ShadowSteps 8\n#else\n    #define FogSteps 64\n    #define ShadowSteps 4\n#endif\n\n#define FogRange 5.\n#define ShadowRange 2.\n\n#define ShadowSampleBias 2.\n#define FogSampleBias 2.\n\n#define MaxIterations 50\n\n#define Anisotropy .4\n\nvec3 VolumeColor;\nvec3 CamPos = vec3(0., 0., -2.2);\nvec3 CamRot = vec3(-.2, 0., 0.);\nfloat CamFocalLength = .7;\nvec3 LightRot = vec3(1., 0., 0.);\nvec3 LightCol = vec3(5.);\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    return rz * rx * ry;\n}\n\nfloat henyeyGreenstein(vec3 dirI, vec3 dirO){\n \treturn Pi/4.*(1.-Anisotropy*Anisotropy) / pow(1.+Anisotropy*(Anisotropy-2.*dot(dirI, dirO)), 1.5);\n}\n\nint julia(vec2 z, vec2 c){\n    for(int i = 0; i < 12; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        if(z.x*z.x+z.y*z.y > 4.) return i;\n    }\n    return MaxIterations;\n}\n\nfloat density(vec3 pos){\n    float angle = iTime*.3;\n    vec2 c = vec2(pos.x*cos(angle)+pos.y*sin(angle),\n             \t  pos.y*cos(angle)-pos.x*sin(angle));\n    return float(julia(pos.xz, c))*.2+.1;\n}\n\nvec3 directLight(vec3 pos, vec3 dir, float headStart){\n    vec3 lightDir = vec3(0., 0., 1.) * rotationMatrix(LightRot);\n    vec3 pos0 = pos, oldPos, volAbs = vec3(1.);\n    float stepDist;\n    for(int i = 0; i < ShadowSteps; i++){\n        oldPos = pos;\n        pos = pos0 - lightDir * pow((float(i)+headStart) / float(ShadowSteps), ShadowSampleBias) * ShadowRange;\n        volAbs *= vec3(exp(-density(pos)*length(pos-oldPos)*VolumeColor));\n    }\n    return LightCol * volAbs * henyeyGreenstein(-lightDir, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    \n    VolumeColor = vec3(cos(iTime*.5), sin(iTime*.4), sin(iTime*.3))*.35+.5;\n    CamRot.y += iTime*.3;\n    LightRot.y -= iTime*.25;\n    \n    CamPos *= rotationMatrix(CamRot);\n    vec3 dir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n    \n    float headStartCam = texture(iChannel0, (fragCoord+vec2(iFrame*50))/iChannelResolution[0].xy).a;\n    float headStartShadow = texture(iChannel0, (fragCoord+vec2(5+iFrame*50))/iChannelResolution[0].xy).a;\n    \n    vec3 volCol = vec3(0.), volAbs = vec3(1.), pos = CamPos, oldPos, stepAbs, stepCol;\n    for(int i = 0; i < FogSteps; i++){\n        oldPos = pos;\n        pos = CamPos + dir * pow((float(i)+headStartCam) / float(FogSteps), FogSampleBias) * FogRange;\n        stepAbs = exp(-density(pos)*length(pos-oldPos)*VolumeColor);\n        stepCol = vec3(1.)-stepAbs;\n        volCol += stepCol*volAbs*directLight(pos, dir, headStartShadow);\n        volAbs *= stepAbs;\n    }\n    fragColor = vec4(volCol, 1.);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 75, 75, 215], [217, 217, 271, 271, 607]], "test": "untested"}
{"id": "3tyXWh", "name": "Day 67", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 13, "viewed": 602, "published": 3, "date": "1582571530", "time_retrieved": "2024-07-30T21:22:08.731133", "image_code": "\n\n// LOG SPHERICAL MAPPING FROM THIS AWESOME ARTICLE\n// https://www.osar.fr/notes/logspherical/\n// ^^ $$ ^^ $$ ^^\n\n// it's super easy to use to as a tool\n// and very interesting to read about\n\n// code and comments in map function also from the author\n\n// shadows from inigo quilez\n\n// color scheme stolen from evvvvil's https://www.shadertoy.com/view/wt33RN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor; \n    // fragColor = vec4(0);\n    \n    float t = texture(iChannel0, fragCoord/R).w;\n    float st = 40.;\n    \n    vec2 uv = (fragCoord - 0.5*R)/R.y;\n    float chromAbAmt = smoothstep(0.,1., dot(uv,uv))*1.4;\n    \n    fragColor += vec4(\n        texture(iChannel0, (fragCoord + vec2(1)*chromAbAmt)/R).x,\n        texture(iChannel0, (fragCoord - vec2(1,0)*chromAbAmt)/R ).y,\n        texture(iChannel0, (fragCoord - vec2(1)*chromAbAmt)/R ).z,\n        0.\n    );\n    \n    \n    \n    vec4 bloom = texture(iChannel1, fragCoord/R, 0.);\n    //fragColor = mix(fragColor, bloom, length(bloom.xyz));\n    fragColor += bloom*0.6;\n    \n    \n    fragColor *= 1. - dot(uv,uv);\n    fragColor.r *= 1.06;\n    fragColor.b *= 1.04;\n    fragColor.b *= 0.95;\n    fragColor.xyz *= 1.9;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\n#define pi acos(-1.)\n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nfloat lpscale = 4.;\n\nfloat random(vec2 u){\n\treturn fract(sin(u.y*4125.1 + u.x *125.625)*225.5235);\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define dmin(a,b) a.x < b.x ? a : b\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n    vec3 q = p;\n\tfloat r = length(p);\n\tp = vec3(log(r), acos(p.z / length(p)), atan(p.y, p.x));\n\n\t// Get a scaling factor to compensate for pinching at the poles\n\t// (there's probably a better way of doing this)\n\tfloat xshrink = 1./(abs(p.y-pi)) + 1.0/(abs(p.y)) - 1.0/pi;\n\n\t// Scale to fit in the ]-pi,pi] interval\n\tp *= lpscale;\n\t// Apply rho-translation, which yields zooming\n\tp.x -= 0. + iTime;\n\t\n    \n\t// Turn tiled coordinates into single-tile coordinates\n\tp = fract(p*0.5) * 2.0 - 1.0;\n\tp.x *= xshrink;\n    \n    \n    // \n    p = abs(p);\t\n    p.xz *= rot(0.2*pi);\n    float thickness = 0.1 ;\n    \n\n    \n\t// Get cylinder distance\n\tfloat ret = max(abs(p.x)- thickness, abs(p.z)- thickness) ;\n    \n\tret = min(ret, max(abs(p.x)- thickness, abs(p.y)- thickness) );\n    \n\td.x = ret;\n\td.y = 0.;\n    \n    vec2 dB =vec2(\n\t\tret = min(\n            max(abs(p.x)- thickness*1.3, abs(p.z)- thickness*0.3), \n            max(abs(p.x)- thickness*1.3, abs(p.y)- thickness*0.3) )\n        , 1.);\n\td = dmin(d, dB);\n    \n    \n    glowB += exp(-dB.x*100.);\n\t// Compensate for all the scaling that's been applied so far\n\tfloat mul = r/lpscale/xshrink;\n\td.x = d.x * mul ;\n    \n    \n    d.x *= 0.5;\n\treturn d;\n}\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n\thit = false; t = 0.; p = ro;\n    \n    for(int i = 0; i < 160; i++){\n    \td = map(p);\n        glow += exp(-d.x*900.);\n        if(d.x < 0.00001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\treturn d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.00001,0);\n    return normalize(\n    \tvec3(\n        \tmap(p+t.xyy).x - map(p-t.xyy).x,\n        \tmap(p+t.yxy).x - map(p-t.yxy).x,\n        \tmap(p+t.yyx).x - map(p-t.yyx).x\n        )\n    );\n}\n\nvec3 getNormalO(vec3 p){\n\tvec2 t = vec2(0.00005,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<52; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.01 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0., 1.0 );\n}\n\n#define T (iTime*0.25)\n#define mx (10.*iMouse.x/iResolution.x)\n#define my (10.*iMouse.y/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv,uv)*(0.56); // squish coords\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    ro.z -= 1.5;\n    ro.x -= sin(2.*T/pi)*(0.9);\n    ro.y -= cos(2.*T/pi)*(0.9);\n    \n    vec3 lookAt = vec3(0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xz *= rot(sin(iTime*0.5)*0.1);\n    rd.xy *= rot(sin(iTime*0.5)*0.1);\n    //rd.xz *= rot(0.5);\n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t,hit);\n    #define ao(d) clamp(map(p+n*d).x/d,0.,1.)\n\n    vec3 lightColA = vec3(0.1,0.4,0.9);\n    vec3 lightColB = vec3(0.25,0.2,0.20)*0.1;\n    if(hit){\n        // do lighting from two light sources\n        vec3 l = normalize(-p);\n        \n        l.xz *= rot(sin(iTime*0.12 + 0.2)*0.1 + 0.3);\n        l.xy *= rot(sin(iTime*0.08 + 0.4)*0.1);\n        \n        float shad = calcSoftshadow( p,l, 0.1, 100., 1 );\n        \n        shad = pow(smoothstep(0.,1.,shad*20. ), 2.);\n\n    \tvec3 n = getNormal(p);\n        vec3 h = normalize(l - rd);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float fres = pow(max(1. - dot(n, -rd),0.), 5.);\n\t\t\n        vec3 lightCol = lightColA;\n        vec3 albedo = vec3(0.5,0.5,0.7)*1.;\n        if(d.y == 1.){\n        \talbedo = vec3(1.5,1.,1.)*1.;\n        }\n        \n        col += albedo*diff*lightCol + spec*lightCol + fres*lightCol;\n        \n        col += albedo*0.02*lightCol;\n        \n        //l = normalize(vec3(-0.4,0.1,-1));\n        l = normalize(p);\n        h = normalize(l - rd);\n        \n        diff = max(dot(n, l),0.);\n        spec = pow(max(dot(n, h),0.), 20.);\n        fres = pow(max(1. - dot(n, -rd),0.), 5.);\n\t\t\n        lightCol = lightColB;\n        \n        col += (albedo*diff*lightCol + spec*lightCol + fres*lightCol)*0.9;\n        \n        col += albedo*0.01*lightCol;\n        \n        col = col*shad;\n    }\n    col = mix(col, col + glow*0.03*vec3(0.1,0.4,0.9),\n              pow( smoothstep(0.,1.,exp(-length(p)*1.5)), 4.)\n             ); \n    col = mix(col,lightColB, smoothstep(0.,1.,t*0.1 ));\n    \n    col = clamp(col,0., 20.);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,t);\n}", "buffer_a_inputs": [], "common_code": "#define MIPLVL 1.\n\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define R iResolution.xy\n#define t(uv) texture(iChannel0, (uv)/R)\n\nvec4 gaussian(sampler2D chan, vec2 uv, vec2 iResolution, float mip){\n    float st = 4.;\n    vec3 t = vec3(st, 0., -st);\n    vec4 C = vec4(0);\n\t#define TC(uv) texture(chan, (uv)/R, mip) \n    // don't do defines like this lol\n    C += 4.*TC(uv);\n    C += 2.*TC(uv - t.xy) + 2.*TC(uv + t.xy) + 2.*TC(uv - t.yx) + 2.*TC(uv - t.yx);\n    C += 1.*TC(uv - t.xx) + 1.*TC(uv + t.xx) + 2.*TC(uv - t.xz) + 2.*TC(uv - t.xz);\n\n    return C / 16.;\n}\n", "buffer_b_code": "\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0);\n    \n    C += gaussian(iChannel0, fragCoord,R,MIPLVL);\n    //C += T(fragCoord);\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0);\n    \n    C += gaussian(iChannel0, fragCoord,R,MIPLVL);\n    //C += T(fragCoord);\n    \n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0);\n    \n    C += gaussian(iChannel0, fragCoord,R,MIPLVL);\n    //C += T(fragCoord);\n    \n    C *= smoothstep(0.,1., pow(length(C.xyz)*1., 2.));\n    \n    \n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 416, 416, 1201]], "test": "untested"}
{"id": "tlKSDz", "name": "Chaosflux Background", "author": "NinjaKoala", "description": "Background video for Chaosflux Infobeamer  (www.chaosflux.de/en/) (info-beamer.com/)\nIn the rendered version gaussian blur is added with an ffmpeg filter\nLoops in 60 seconds", "tags": ["2d", "bezier", "svg", "chaosflux"], "likes": 2, "viewed": 284, "published": 3, "date": "1582556959", "time_retrieved": "2024-07-30T21:22:09.824212", "image_code": "//The logo is generated with a script from svg (see https://www.shadertoy.com/view/Wtt3Wl)\n\n#define ZERO min(0,iFrame)\n\nfloat border;\n\n//hash functions from https://www.shadertoy.com/view/4djSRW\n\nvec2 hash21(float p)\n{\n\tvec2 p2  = fract(p * vec2(5.3983, 5.4427));\n\tp2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tfor(int i=ZERO;i<3;i++){\n\t\tt=params[i];\n\t\tfor(int j=ZERO;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n\telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[26] p=vec2[](vec2(-0.10513741178015773,0.18225451483640648),\n\t                  vec2(-0.11508189293211292,0.16479023569220425),\n\t                  vec2(-0.11508189293211292,0.16479023569220425),\n\t                  vec2(-0.05226020912336337,0.1277696341578051),\n\t                  vec2(-0.03668564162604742,0.07191650538101095),\n\t                  vec2(-0.020574983549088138,0.014140812609831214),\n\t                  vec2(-0.03874981615009546,-0.05058622819157852),\n\t                  vec2(-0.005903441805151979,-0.12697315364094866),\n\t                  vec2(0.011146458769719193,-0.16662410194662905),\n\t                  vec2(0.04289724510756864,-0.18487622572225562),\n\t                  vec2(0.06947080013727487,-0.19243802290398837),\n\t                  vec2(0.09604435516698105,-0.2000000000000005),\n\t                  vec2(0.1185958365136935,-0.19763880499136252),\n\t                  vec2(0.1185958365136935,-0.19763880499136252),\n\t                  vec2(0.11652259430994151,-0.17764439132975135),\n\t                  vec2(0.11652259430994151,-0.17764439132975135),\n\t                  vec2(0.09767716721368143,-0.1795680348098153),\n\t                  vec2(0.07498770960575862,-0.17311127113486824),\n\t                  vec2(0.05229823400640781,-0.16665468737420056),\n\t                  vec2(0.026955562522236406,-0.15254508989192175),\n\t                  vec2(0.012544806526930286,-0.11903173732874979),\n\t                  vec2(-0.017530186242764697,-0.04908970121185751),\n\t                  vec2(0.0007400549008424999,0.01254785157611735),\n\t                  vec2(-0.017323788580930685,0.07732796709008026),\n\t                  vec2(-0.03592372264234721,0.14403064659842876),\n\t                  vec2(-0.10513741178015773,0.18225451483640648));\n\n\tivec2[2] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(13,14));\n\n\tivec4[8] c_bez=ivec4[](ivec4(1,2,3,4),\n\t                       ivec4(4,5,6,7),\n\t                       ivec4(7,8,9,10),\n\t                       ivec4(10,11,12,13),\n\t                       ivec4(14,15,16,17),\n\t                       ivec4(17,18,19,20),\n\t                       ivec4(20,21,22,23),\n\t                       ivec4(23,24,25,0));\n\n\tif(all(lessThan(uv,vec2(0.1185958365136935,0.18225451483640648)+border/2.)) && all(greaterThan(uv,vec2(-0.11508189293211292,-0.2000000000000005)-border/2.))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path1_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[20] p=vec2[](vec2(0.1157846758911721,0.10522871377931982),\n\t                  vec2(0.1157846758911721,0.10522871377931982),\n\t                  vec2(0.07492137521078111,0.09615221827560297),\n\t                  vec2(0.0326445959822444,0.07536006469717456),\n\t                  vec2(-0.009632165254864348,0.05456791111874716),\n\t                  vec2(-0.055505466920286024,0.021423562743529884),\n\t                  vec2(-0.06061566216776037,-0.029355623513178133),\n\t                  vec2(-0.0700863318671821,-0.12346428544120289),\n\t                  vec2(-0.019045622213296524,-0.18474254941233453),\n\t                  vec2(-0.019045622213296524,-0.18474254941233453),\n\t                  vec2(-0.0036545133071348183,-0.1718462938333055),\n\t                  vec2(-0.0036545133071348183,-0.1718462938333055),\n\t                  vec2(-0.04929437619446233,-0.11754204709166494),\n\t                  vec2(-0.040621266497577364,-0.0313586091906533),\n\t                  vec2(-0.03665957204689839,0.008008254467156873),\n\t                  vec2(0.0017859865667003067,0.037784607523743366),\n\t                  vec2(0.041534898197753835,0.05733355342846704),\n\t                  vec2(0.08128379183737937,0.07688249933319072),\n\t                  vec2(0.12017710311921934,0.0856207559908058),\n\t                  vec2(0.12017712111064728,0.0856207559908058));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(19,0));\n\n\tivec4[6] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(3,4,5,6),\n\t                       ivec4(6,7,8,9),\n\t                       ivec4(10,11,12,13),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19));\n\n\tif(all(lessThan(uv,vec2(0.12017712111064728,0.10522871377931982)+border/2.)) && all(greaterThan(uv,vec2(-0.0700863318671821,-0.18474254941233453)-border/2.))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path2_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[32] p=vec2[](vec2(0.10956498526277197,0.19999999999999948),\n\t                  vec2(0.10956498526277197,0.19999999999999948),\n\t                  vec2(0.037350325937207385,0.17016751368810307),\n\t                  vec2(0.017323779585216685,0.09714660450028534),\n\t                  vec2(0.007738234618116232,0.06219573684118168),\n\t                  vec2(0.007829828977983476,0.038356375105080734),\n\t                  vec2(0.007906382504055958,0.01646638459106055),\n\t                  vec2(0.007983745644387759,-0.005423785837239025),\n\t                  vec2(0.008066506213114787,-0.02529927615987463),\n\t                  vec2(-0.0010893314880125555,-0.05669413807791444),\n\t                  vec2(-0.009436958261236469,-0.08531688077215802),\n\t                  vec2(-0.03893978763817994,-0.11694311245407363),\n\t                  vec2(-0.0668002155373075,-0.14029112829192678),\n\t                  vec2(-0.0946606254450071,-0.16363896421550156),\n\t                  vec2(-0.12017712111064728,-0.17901479839930393),\n\t                  vec2(-0.12017712111064728,-0.17901479839930393),\n\t                  vec2(-0.10981096586531387,-0.19623313472296214),\n\t                  vec2(-0.10981096586531387,-0.19623313472296214),\n\t                  vec2(-0.08302986891895385,-0.18012001182036896),\n\t                  vec2(-0.05386887667370899,-0.1556820752752355),\n\t                  vec2(-0.02470786643703615,-0.13124431864438244),\n\t                  vec2(0.0075665963951476066,-0.09878454410396154),\n\t                  vec2(0.018202265030826132,-0.06231645932295521),\n\t                  vec2(0.028029452867181538,-0.028620673680024494),\n\t                  vec2(0.02804769617515748,-0.005384744438511793),\n\t                  vec2(0.02797105269194502,0.016536551160200502),\n\t                  vec2(0.027893689551613216,0.0384578467589128),\n\t                  vec2(0.027741482070867428,0.059099771913672515),\n\t                  vec2(0.03672078788061441,0.09184057255920483),\n\t                  vec2(0.053824069022314486,0.15420264015210025),\n\t                  vec2(0.11736594249669793,0.18144633989136022),\n\t                  vec2(0.11736596048812586,0.18144633989136022));\n\n\tivec2[2] seg=ivec2[](ivec2(15,16),\n\t                     ivec2(31,0));\n\n\tivec4[10] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31));\n\n\tif(all(lessThan(uv,vec2(0.11736596048812586,0.19999999999999948)+border/2.)) && all(greaterThan(uv,vec2(-0.12017712111064728,-0.19623313472296214)-border/2.))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<10;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat logo_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tif(all(lessThan(uv,vec2(0.12017712111064728,0.2)+border/2.)) && all(greaterThan(uv,vec2(-0.12017712111064728,-0.2)-border/2.))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path1_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path2_dis_sq(uv));\n\t}\n\n\treturn dis_sq;\n}\n\nfloat logo_dis(vec2 uv){\n\tfloat dis_sq=logo_dis_sq(uv);\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n\n\treturn dis;\n}\n\nmat2 rot(float t){\n\treturn mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.x*=iResolution.x/iResolution.y;\n\n\tborder=2./iResolution.y;\n\n\tconst vec3 bg_col=vec3(0);\n\n\tvec3 color=bg_col;\n\n\tconst float pi=3.14159265358979;\n\n\tconst vec3 logo_color_dark=vec3(.185);\n\tconst vec3 logo_color_light=vec3(1);\n\n\tfloat dis_sq=1e38;\n\n\tconst vec2 grid_size=vec2(.2,.2);\n\n\tconst float loop_time=60.;\n\n\tfloat t0 = iTime;\n\tfloat t1 = mod(t0/loop_time*2.*pi,2.*pi);\n\tfloat t2 = .4*cos(t1);\n\n\tfloat zoom1=4.*exp(-1.3+.3*sin(t1));\n\tfloat z_val=(1.-(1.+.2*cos(t1))*uv.y+.2*sin(t1)*uv.x);\n\tzoom1/=z_val;\n\n\tconst float zoom2=4.;\n\n\tuv*=rot(t2);\n\n\tuv*=zoom1;\n\tborder*=zoom1;\n\n\tfloat veil=.875+.125*sin(mod(32.*uv.y+8.*uv.x,2.*pi));\n\tveil*=.875+.125*cos(mod(2.*uv.x+1.*uv.y,2.*pi));\n\n\tvec2 cell_index=floor(uv/grid_size+.5);\n\tvec2 cur_midpoint=cell_index*grid_size;\n\tuv-=cur_midpoint;\n\n\tif( mod(cell_index.x+cell_index.y,2.) == 0.){\n\t\tuv*=rot(pi/2.);\n\t}\n\n\tconst float light_speed=.1;\n\tconst int num_lights=7;\n\n\tvec3 logo_color=logo_color_dark;\n\tfor(int i=0;i<num_lights;i++){\n\t\tif(floor(.5+(hash21(1.4+floor(mod(t0*light_speed+float(i)/float(num_lights),loop_time*light_speed))+hash11(float(i)))*vec2(20.,11.)-vec2(11.,2.))) == cell_index){\n\t\t\t//fade in and out\n\t\t\t//float fade_param=smoothstep(0.,1.,1.-2.*abs(fract(t0*light_speed)-.5));\n\t\t\t//only fade in\n\t\t\tfloat fade_param=smoothstep(0.,.25,fract(t0*light_speed+float(i)/float(num_lights)));\n\t\t\tlogo_color=mix(logo_color_dark,logo_color_light,fade_param);\n\t\t}\n\t}\n\n\tuv*=zoom2;\n\tborder*=zoom2;\n\n\tfloat dis=logo_dis(uv);\n\n\tcolor=mix(logo_color,color,smoothstep(-border/2.,border/2., dis));\n\tcolor*=veil;\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 218, 218, 383], [385, 385, 408, 408, 493], [495, 616, 665, 700, 880], [882, 967, 1010, 1010, 2019], [2021, 2021, 2102, 2121, 2296], [2298, 2298, 2376, 2376, 2806], [2808, 2831, 2856, 2856, 2875], [2877, 2877, 2924, 2924, 3035], [3037, 3037, 3085, 3085, 3355], [3357, 3357, 3428, 3428, 4292], [12933, 12933, 12960, 12960, 13250], [13252, 13252, 13276, 13276, 13366], [13368, 13368, 13386, 13386, 13432], [13434, 13434, 13490, 13490, 15125]], "test": "untested"}
{"id": "WlVXDz", "name": "GridCircs", "author": "Arseny", "description": "2d", "tags": ["2d"], "likes": 3, "viewed": 376, "published": 3, "date": "1582554073", "time_retrieved": "2024-07-30T21:22:11.040957", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n\nfloat circDist(vec2 cent, float r, vec2 pxpos){\n    return length(cent - pxpos) - r;\n}\n\nvec3 makeLine(vec2 A, vec2 B){\n    vec3 ans;\n    ans.x = A.y - B.y;\n    ans.y = B.x - A.x;\n    ans.z = -(ans.x * A.x + ans.y * A.y);\n    return ans;\n}\n\nvec2 lineIntersection(vec3 A, vec3 B){\n    return \n        vec2(\n            (B.z * A.y - A.z * B.y) / (A.x * B.y - B.x * A.y), \n            (B.z * A.x - A.z * B.x) / -(A.x * B.y - B.x * A.y) \n        );\n}\n\nfloat lineDist(vec3 L, vec2 A){\n    return (L.x * A.x + L.y * A.y + L.z) / sqrt(L.x * L.x + L.y * L.y);\n}\n\nvec2 circCent(vec2 A, vec2 B, vec2 C){\n    float dst = lineDist(makeLine(A, B), C);\n    dst = floor(dst / 0.0001) * 0.0001;\n    if (abs(dst + 0.0001) < 0.001){\n        dst += 0.0001;\n        return (A + B) / 2. + normalize((B - A)) * rot(pi / 2.) * sign(dst) * 100.;\n    }\n    return lineIntersection(\n        makeLine((A + B) / 2., (A + B) / 2. + (B - A) * rot(pi / 2.)), \n        makeLine((C + B) / 2., (C + B) / 2. + (B - C) * rot(pi / 2.))\n    );\n}\n\nfloat circDist(vec2 A, vec2 B, vec2 C, vec2 pxpos){\n   \tvec2 cen = circCent(A, B, C);\n    return circDist(cen, length(A - cen), pxpos) * sign(lineDist(makeLine(A, B), C));\n}\n\nfloat rand(float x){\n    x += 0.0007;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.553);\n}\n\nfloat rand_func(float x, float seed){ // from 0 to 1\n    const float freq = 20.;\n    float block = floor(x * freq);\n    float A = rand(block + seed);\n    float B = rand(block + 1. + seed);\n    return mix(A, B, x * freq - block);\n}\n\nfloat thisrand(vec2 v, float seed){\n    return rand_func(rand_func(v.x, v.y), seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\n    // Time varying pixel color\n    col.xy = uv.xy;\n    float cellsz = 0.1;\n    vec2 gv = (fract(uv / cellsz) - 0.5) * 2.;\n    vec2 fv = floor(uv / cellsz);\n    col.xy = gv;\n    col.xy = vec2(0.);\n    if ((fv.x + fv.y) / 2. - floor((fv.x + fv.y) / 2.) < 0.01){\n        float sgn = 1.;\n        float lastsgn = 1.;\n        vec2 lastcent = vec2(1., -1.);\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime)) < 2.){\n        if (thisrand(fv, floor(iTime)) < 0.5){\n            //cent = vec2(-1., 1.);\n            sgn = -1.;\n        }\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime - 1.)) < 2.){\n        if (thisrand(fv, floor(iTime - 1.)) < 0.5){\n            //cent = vec2(-1., 1.);\n            lastsgn = -1.;\n        }\n        float num = 2. * inversesqrt(2.) - 1.;\n        float nowsgn = mix(lastsgn, sgn, fract(iTime));\n        col.r = 1. - smoothstep(\n            -0.1,\n            0.1,\n           \t\t\n                circDist(\n                    vec2(1., 1.), \n                    vec2(-num * nowsgn, num * nowsgn), \n                    vec2(-1., -1.),\n                    //vec2(1., -1.),\n                    //cent,\n                    //2.,\n                    gv\n                )\n            \n        );\n        float anothermul = (mod(fv.x, 2.) - 0.5) * 2.;\n        if (anothermul > 0.){\n            col.r = 1. - col.r;\n        }\n        //col.b = 1.;\n        //col.rg = gv+1.;\n    } else {\n        float sgn = 1.;\n        float lastsgn = 1.;\n        vec2 lastcent = vec2(1., -1.);\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime)) < 2.){\n        if (thisrand(fv, floor(iTime)) < 0.5){\n            //cent = vec2(-1., 1.);\n            sgn = -1.;\n        }\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime - 1.)) < 2.){\n        if (thisrand(fv, floor(iTime - 1.)) < 0.5){\n            //cent = vec2(-1., 1.);\n            lastsgn = -1.;\n        }\n        float num = 2. * inversesqrt(2.) - 1.;\n        float nowsgn = mix(lastsgn, sgn, fract(iTime));\n        col.r = 1. - smoothstep(\n            -0.1,\n            0.1,\n           \t\n                circDist(\n                    vec2(-1., 1.), \n                    vec2(num * nowsgn, num * nowsgn), \n                    vec2(1., -1.),\n                    //vec2(1., -1.),\n                    //cent,\n                    //2.,\n                    gv\n                )\n            \n        );\n        float anothermul = (mod(fv.x, 2.) - 0.5) * 2.;\n        if (anothermul > 0.){\n            col.r = 1. - col.r;\n        }\n        //col.g = 1.;\n    }\n    /*if (length(uv) < 0.01){\n        col = vec3(1.);\n    }*/\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 119, 119, 158], [160, 160, 190, 190, 310], [312, 312, 350, 350, 517], [519, 519, 550, 550, 624], [626, 626, 664, 664, 1078], [1080, 1080, 1131, 1131, 1253], [1255, 1255, 1275, 1275, 1366], [1368, 1368, 1405, 1420, 1598], [1600, 1600, 1635, 1635, 1686], [1688, 1688, 1745, 1795, 4561]], "test": "untested"}
{"id": "ttdXRf", "name": "Interactive fluid with caustics", "author": "tmst", "description": "- A simple scene to test rendering of water with caustics (see Cube A for paper reference).\n- Drag mouse to add waves.  Hold 'space' to freeze the water.", "tags": ["wave", "water", "fluid", "abstract", "caustics"], "likes": 82, "viewed": 1905, "published": 3, "date": "1582531981", "time_retrieved": "2024-07-30T21:22:12.307570", "image_code": "//#define DEBUG_OUTPUT\n\n#define W_0 0.05675675675\n#define W_1 0.1581081081\n#define W_2 0.03513513515\n\n#define BLUR_MAX_PCT 0.004\n\n#define VIGNETTE_INTENSITY 0.4\n\nvec3 blurSample(sampler2D tex, vec2 uv, float blurAmount) {\n    float pct = blurAmount*BLUR_MAX_PCT;\n    vec2 sampleRBase = vec2(1.0, iResolution.y/iResolution.x);\n    vec3 finalColor = vec3(0.0);\n\n    vec2 sampleR = pct * sampleRBase;\n    float ra = rand(uv)*PI_OVER_4;\n    float rs = sin(ra);\n    float rc = cos(ra);\n    finalColor += W_0 * textureLod(tex, uv + vec2( rc, rs)*sampleR, 0.0).rgb;\n    finalColor += W_0 * textureLod(tex, uv + vec2(-rs, rc)*sampleR, 0.0).rgb;\n    finalColor += W_0 * textureLod(tex, uv + vec2(-rc,-rs)*sampleR, 0.0).rgb;\n    finalColor += W_0 * textureLod(tex, uv + vec2( rs,-rc)*sampleR, 0.0).rgb;\n\n    sampleR = 2.0 * pct * sampleRBase;\n    ra += PI_OVER_4;\n    rs = sin(ra);\n    rc = cos(ra);\n    finalColor += W_1 * textureLod(tex, uv + vec2( rc, rs)*sampleR, 0.0).rgb;\n    finalColor += W_1 * textureLod(tex, uv + vec2(-rs, rc)*sampleR, 0.0).rgb;\n    finalColor += W_1 * textureLod(tex, uv + vec2(-rc,-rs)*sampleR, 0.0).rgb;\n    finalColor += W_1 * textureLod(tex, uv + vec2( rs,-rc)*sampleR, 0.0).rgb;\n\n    sampleR = 3.0 * pct * sampleRBase;\n    ra += PI_OVER_4;\n    rs = sin(ra);\n    rc = cos(ra);\n    finalColor += W_2 * textureLod(tex, uv + vec2( rc, rs)*sampleR, 0.0).rgb;\n    finalColor += W_2 * textureLod(tex, uv + vec2(-rs, rc)*sampleR, 0.0).rgb;\n    finalColor += W_2 * textureLod(tex, uv + vec2(-rc,-rs)*sampleR, 0.0).rgb;\n    finalColor += W_2 * textureLod(tex, uv + vec2( rs,-rc)*sampleR, 0.0).rgb;\n\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float blurAmount = textureLod(iChannel0, uv, 0.0).a;\n    vec3 blurColor = blurSample(iChannel0, uv, blurAmount);\n\n    float dCorner = length(uv - vec2(0.5)) * 1.414214;\n    float vignetteFactor = 1.0 - mix(0.0, VIGNETTE_INTENSITY, smoothstep(0.3, 0.9, dCorner));\n\n    fragColor = vec4(vignetteFactor*blurColor, 1.0);\n\n    #ifdef DEBUG_OUTPUT\n        vec2 r = uv * vec2(3.0, 2.0);\n        int page = 1 + int(floor(r.y))*3 + int(floor(r.x));\n        vec2 fragCoordDebug = fract(r) * vec2(1024.0);\n\n        vec4 debugColor = texture(iChannel1, vcubeFromFragCoord(page, fragCoordDebug));\n        float debugAlpha = 0.6;\n        fragColor = mix(fragColor, debugColor, debugAlpha);\n    #endif\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ================\n// Generic helpers\n// ================\n\n#define PI_OVER_2 1.570796326794896\n#define PI_OVER_4 0.7853981633974483\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat isInInterval(float a, float b, float x) {\n    return step(a, x) * (1.0 - step(b, x));\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat lensq(vec3 v) {\n    return dot(v, v);\n}\n\nfloat distsq(vec3 p, vec3 q) {\n    vec3 pq = q - p;\n    return dot(pq, pq);\n}\n\nfloat sdBox(vec3 boxCenter, vec3 boxRadii, vec3 p) {\n    vec3 q = boxRadii - abs(p - boxCenter);\n    return length(min(q, 0.0)) - max( min(min(q.x, q.y), q.z), 0.0 );\n}\n\nvec2 cpSeg2(vec2 q0, vec2 q1, vec2 p) {\n    vec2 vEdge = q1 - q0;\n    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);\n    return q0 + clamp(t, 0.0, 1.0)*vEdge;\n}\n\nfloat sdSeg2(vec2 q0, vec2 q1, vec2 p) {\n    vec2 x = cpSeg2(q0,q1, p);\n    return distance(x, p);\n}\n\nvoid materialShader(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 diffuseContribution,\n    out vec3 specularContribution\n) {\n    //compute diffuse intensity\n    float intensityDiffuse = clamp(dot(nvNormal, nvFragToLight), 0.0, 1.0);\n    intensityDiffuse *= diffuseCoefficient;\n\n    //compute specular intensity\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float intensitySpecular = pow(clamp(dot(nvNormal, blinnH), 0.0, 1.0), specularExponent);\n    intensitySpecular *= specularCoefficient;\n\n    //output diffuse and specular values\n    diffuseContribution = intensityDiffuse * texColor * lightColor;\n    specularContribution = intensitySpecular * lightColor;\n}\n\n// Mouse input\n//---------------------------------------\n// Not a very good method but it's fine for this purpose\n\nvec2 packUVWithBool(vec2 uv, bool b) {\n    return vec2(uv.s, 0.4*uv.t + (b ? 0.5 : 0.0));\n}\n\nvoid unpackUVWithBool(in vec2 pack, out vec2 uv, out bool b) {\n    b = pack.t > 0.45;\n    uv = vec2(pack.s, 2.5*(pack.t - (b ? 0.5 : 0.0)));\n}\n//---------------------------------------\n\n// ========================\n// Scene helpers/constants\n// ========================\n\n#define POOL_SURFACE_WORLD_MIN vec3(-0.8, 0.0, -0.8)\n#define POOL_SURFACE_WORLD_MAX vec3( 0.8, 0.0,  0.8)\n#define POOL_SURFACE_CENTER (0.5*(POOL_SURFACE_WORLD_MIN+POOL_SURFACE_WORLD_MAX))\n#define POOL_BUMP_HEIGHT_WORLD 0.04\n#define POOL_DEPTH_WORLD 0.1\n\n#define IR_LIQUID 1.333\n#define IR_AIR 1.000\n\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\nmat4 getClipToWorld(vec3 iResolution, vec3 nvCamFw, vec3 nvCamFixedUp) {\n    float ratio = iResolution.x / iResolution.y;\n    mat4 clipToEye = mat4(\n        ratio * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR) / (2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR) / (2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, nvCamFixedUp));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid sceneCamera(\n    in vec3 iResolution,\n    in vec2 fragCoord,\n    in float iTime,\n    out vec3 camPos,\n    out vec3 nvCamDir\n) {\n    float t = mod(iTime, 16.0);\n    float angS = smoothstep(1.,3.,t) + smoothstep(5.,7.,t) + smoothstep(9.,11.,t) + smoothstep(13.,15.,t);\n    float ang = 0.2 + angS*PI_OVER_2;\n    float radS = smoothstep(1.,3.,t) - smoothstep(9.,11.,t);\n    float rad = mix(0.6, 0.9, radS);\n    camPos = (rad+0.05*cos(iTime*0.5))*vec3(sin(ang), 0.5+0.05*sin(iTime*0.5), cos(ang));\n\n    vec3 camTarget = vec3(0.0);\n    vec3 nvCamFw = normalize(camTarget - camPos);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 clip = vec4(uv * 2.0 - 1.0, 1.0, 1.0);\n\n    vec3 nvCamFixedUp = vec3(0.0, 1.0, 0.0);\n    vec4 world = getClipToWorld(iResolution, nvCamFw, nvCamFixedUp) * clip;\n    nvCamDir = normalize(world.xyz / world.w);\n}\n\nvec3 sceneLight(in float iTime) {\n    return vec3(6.0, 7.8, -6.0);\n}\n\n// ================================================\n// Cubemap helpers (treat as 6x1024x1024 textures)\n// ================================================\n\nvec2 wrapFragCoord(vec2 fragCoord) {\n    // Simulate wrap: mirror\n    return abs(1023.0 - mod(fragCoord + 1023.0, 2046.0));\n}\n\nvec3 vcubeFromFragCoord(int page, vec2 fragCoord)\n{\n    vec2 p = (wrapFragCoord(fragCoord) + 0.5)*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = -vec3(1.0, p);\n    } else if (page == 3) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else if (page == 4) {\n        fv = -vec3(p.x, 1.0, p.y);\n    } else if (page == 5) {\n        fv = vec3(p, 1.0);\n    } else if (page == 6) {\n        fv = -vec3(p, 1.0);\n    }\n    return fv;\n}\n\nvoid fragCoordFromVCube(in vec3 vcube, out int page, out vec2 fragCoord)\n{\n    vec2 p;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        if (vcube.x > 0.0) { page = 1; } else { page = 2; }\n        p = vcube.yz/vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        if (vcube.y > 0.0) { page = 3; } else { page = 4; }\n        p = vcube.xz/vcube.y;\n    } else {\n        if (vcube.z > 0.0) { page = 5; } else { page = 6; }\n        p = vcube.xy/vcube.z;\n    }\n\n    fragCoord = floor((0.5 + 0.5*p)*1024.0);\n}\n", "cube_a_code": "// Description and references:\n// -------------------------------------------------------------------------------\n// This shader implements the method for rendering caustics described in [1].\n// Multiple render targets are replaced by writing to multiple cube faces.\n// - [1] \"Fast Real-time Caustics from height Fields\" (Yuksel, Keyser)\n// -------------------------------------------------------------------------------\n\n// Keyboard input description: https://www.shadertoy.com/view/lsXGzf\n#define KEY_SPACE 32\n\n// ================\n// Generic helpers\n// ================\n\nvec4 read(int page, vec2 fragCoord) {\n    return textureLod(iChannel0, vcubeFromFragCoord(page, fragCoord), 0.0);\n}\n\nvec2 getHeightData(vec2 fragCoord) {\n    return read(1, fragCoord).rg;\n}\n\nvec3 getSurfaceNormal(vec2 fragCoord) {\n    return 2.0*( read(2, fragCoord).xyz - 0.5 );\n}\n\n// ==============\n// Shallow water\n// ==============\n\n// Helpers for initial/reset value\n// ---------------------------------------\nfloat noise(in vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    vec2 m = pf*pf*(3.0-2.0*pf);\n    return mix(mix(r00, r10, m.x), mix(r01, r11, m.x), m.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*32.0;\n\n    float v = noise(p);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    return v;\n}\n// ---------------------------------------\n\nvoid writePage1(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data0 = read(1, fragCoord);\n\n    vec2 h0 = data0.rg;\n    vec2 hXB = getHeightData( fragCoord + vec2(1.0,0.0) );\n    vec2 hXA = getHeightData( fragCoord - vec2(1.0,0.0) );\n    vec2 hZB = getHeightData( fragCoord - vec2(0.0,1.0) );\n    vec2 hZA = getHeightData( fragCoord + vec2(0.0,1.0) );\n\n    float hAvg = 0.25 * (hXB.s + hXA.s + hZB.s + hZA.s);\n    float hNew = mix(h0.t, hAvg, 2.0);\n\n    vec2 uv = fragCoord/vec2(1024.0);\n\n    // Mouse input\n    //---------------------------------------\n    vec2 packMouse0 = textureLod(iChannel2, vec2(0.0), 0.0).rg;\n    vec2 packMouse1 = data0.ba;\n\n    vec2 uvMouse0;\n    bool isMousePressed0;\n    unpackUVWithBool(packMouse0, uvMouse0, isMousePressed0);\n\n    vec2 uvMouse1;\n    bool isMousePressed1;\n    unpackUVWithBool(packMouse1, uvMouse1, isMousePressed1);\n\n    if (isMousePressed0 && isMousePressed1) {\n        float targetDistUV = sdSeg2(uvMouse0, uvMouse1, uv);\n\n        float bumpHeight = smoothstep(0.0, 0.03, targetDistUV);\n        hNew = max(hNew, 1.0-bumpHeight);\n    }\n    //---------------------------------------\n\n    // Damping\n    hNew = mix(hNew, 0.5, 0.003);\n\n    // Initial/reset value\n    if (iTime < 0.1) {\n        float a = fbm(uv*0.25)*6.28;\n        hNew = fbm( uv +  0.25*vec2(cos(a), sin(a)) );\n        hNew = smoothstep(0.4, 0.6, hNew);\n    }\n\n    // Clamp\n    hNew = clamp(hNew, 0.0, 1.0);\n\n    bool isSpacePressed = texelFetch(iChannel1, ivec2(KEY_SPACE,0), 0).x > 0.5;\n    fragColor = isSpacePressed ? data0 : vec4(hNew, h0.s, packMouse0);\n}\n\n// ====================\n// Pool surface normal\n// ====================\n\nvoid writePage2(out vec4 fragColor, in vec2 fragCoord)\n{\n    float hXB = getHeightData( fragCoord + vec2(1.0,0.0) ).r;\n    float hXA = getHeightData( fragCoord - vec2(1.0,0.0) ).r;\n    float hZB = getHeightData( fragCoord - vec2(0.0,1.0) ).r;\n    float hZA = getHeightData( fragCoord + vec2(0.0,1.0) ).r;\n\n    vec2 pixelWorldSize = (POOL_SURFACE_WORLD_MAX.xz - POOL_SURFACE_WORLD_MIN.xz) / 1024.0;\n    vec2 gradh = vec2(hXB-hXA, hZB-hZA) * POOL_BUMP_HEIGHT_WORLD / (2.0 * pixelWorldSize);\n    vec3 surfaceNormal = normalize(vec3(-gradh.s, 1.0, -gradh.t));\n\n    fragColor = vec4(0.5 + 0.5*surfaceNormal, 0.0);\n}\n\n// =================\n// Caustics Pass 1A\n// =================\n\nvec3 surfaceUVToWorld(vec2 uv) {\n    return vec3(\n        mix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, uv.s),\n        mix(POOL_SURFACE_WORLD_MIN.y, POOL_SURFACE_WORLD_MAX.y, 0.5),\n        mix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, uv.t)\n    );\n}\n\nvec2 surfaceWorldToUV(vec3 p) {\n    return vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, p.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, p.z)\n    );\n}\n\nvoid causticPass1(out vec4 fragColor, in vec2 fragCoord, float yOffset)\n{\n    vec2 uv = fragCoord / vec2(1024.0);\n\n    vec3 poolWorldPos = surfaceUVToWorld(uv);\n    vec3 baseWorldPos = poolWorldPos - vec3(0.0, POOL_DEPTH_WORLD, 0.0);\n    vec3 lightWorldPos = sceneLight(iTime);\n\n    // \"Un-refract\" to compute the \"illumination center\" on the pool surface\n    // --------------------------------------------------------------------\n    // We want the surface point refracting lightWorldPos onto baseWorldPos.\n    // For IR ratios 0 and 1, easy to find--correct point is somewhere between.\n    // So we do a binary search between those two points.\n\n    vec3 eta0 = poolWorldPos;\n    vec3 eta1 = mix(baseWorldPos, lightWorldPos, unmix(baseWorldPos.y, lightWorldPos.y, POOL_SURFACE_CENTER.y));\n\n    vec3 vecOut0 = refract(normalize(eta0-lightWorldPos), vec3(0.0,1.0,0.0), IR_AIR/IR_LIQUID);\n    vec3 vecOutBase0 = eta0 - (POOL_DEPTH_WORLD/vecOut0.y)*vecOut0;\n    float dsq0 = 0.0;\n\n    vec3 vecOut1 = refract(normalize(eta1-lightWorldPos), vec3(0.0,1.0,0.0), IR_AIR/IR_LIQUID);\n    vec3 vecOutBase1 = eta1 - (POOL_DEPTH_WORLD/vecOut1.y)*vecOut1;\n    float dsq1 = lensq(vecOutBase0-vecOutBase1);\n\n    float dsqTarget = lensq(vecOutBase0-baseWorldPos);\n\n    float b0 = 0.0;\n    float b1 = 1.0;\n    for (int k=0; k<10; k++) {\n        float bStep = mix(b0, b1, 0.5);\n        vec3 test = mix(eta0, eta1, bStep);\n\n        vec3 vecOutTest = refract(normalize(test-lightWorldPos), vec3(0.0,1.0,0.0), IR_AIR/IR_LIQUID);\n        vec3 vecOutBaseTest = test - (POOL_DEPTH_WORLD/vecOutTest.y)*vecOutTest;\n        float dsqTest = lensq(vecOutBase0-vecOutBaseTest);\n\n        if (dsqTest < dsqTarget) {\n            b0 = bStep;\n        } else {\n            b1 = bStep;\n        }\n    }\n\n    vec3 icWorld = mix(eta0, eta1, mix(b0, b1, 0.5));\n    vec2 icUV = surfaceWorldToUV(icWorld);\n    vec2 icFragCoord = icUV * 1024.0;\n    // --------------------------------------------------------------------\n\n    vec4 finalResult = vec4(0.0);\n\n    vec2 pixelWorldSize = (POOL_SURFACE_WORLD_MAX.xz - POOL_SURFACE_WORLD_MIN.xz) / 1024.0;\n    for (int i=-3; i<=3; i++) {\n        vec2 sampleFragCoord = icFragCoord + vec2(float(i), 0.0);\n\n        // \"Straighten\" normal to make caustics less sensitive to gradients\n        vec3 nSurface = getSurfaceNormal(sampleFragCoord);\n        nSurface = normalize( mix(vec3(0.0,1.0,0.0), nSurface, 0.25) );\n\n        vec3 sampleWorld = icWorld + vec3(float(i)*pixelWorldSize.x, 0.0, 0.0);\n\n        vec3 vecOut = refract(normalize(sampleWorld-lightWorldPos), nSurface, IR_AIR/IR_LIQUID);\n        vec3 vecOutBase = sampleWorld - (POOL_DEPTH_WORLD/vecOut.y)*vecOut;\n\n        vec2 hitFragCoord = surfaceWorldToUV(vecOutBase) * 1024.0;\n        float ax = max(0.0, 1.0 - abs( fragCoord.x - hitFragCoord.x ));\n        finalResult += ax * vec4(\n            max(0.0, 1.0 - abs( fragCoord.y+( 0.0+yOffset) - hitFragCoord.y )),\n            max(0.0, 1.0 - abs( fragCoord.y+( 1.0+yOffset) - hitFragCoord.y )),\n            max(0.0, 1.0 - abs( fragCoord.y+( 2.0+yOffset) - hitFragCoord.y )),\n            max(0.0, 1.0 - abs( fragCoord.y+( 3.0+yOffset) - hitFragCoord.y ))\n        );\n    }\n\n    fragColor = finalResult;\n}\n\nvoid writePage3(out vec4 fragColor, in vec2 fragCoord) {\n    causticPass1(fragColor, fragCoord, 0.0);\n}\n\n// =================\n// Caustics Pass 1B\n// =================\n\nvoid writePage4(out vec4 fragColor, in vec2 fragCoord) {\n    causticPass1(fragColor, fragCoord, -3.0);\n}\n\n// ================\n// Caustics Pass 2\n// ================\n\nvoid writePage5(out vec4 fragColor, in vec2 fragCoord) {\n    float intensity = (\n        read(3, fragCoord                ).r +\n        read(3, fragCoord - vec2(0.0,1.0)).g +\n        read(3, fragCoord - vec2(0.0,2.0)).b +\n        read(3, fragCoord - vec2(0.0,3.0)).a +\n        read(4, fragCoord + vec2(0.0,3.0)).r +\n        read(4, fragCoord + vec2(0.0,2.0)).g +\n        read(4, fragCoord + vec2(0.0,1.0)).b\n    );\n    fragColor = vec4(clamp(0.5*intensity, 0.0, 1.0));\n}\n\n// =========================\n// Output depends on \"page\"\n// =========================\n\nvoid mainCubemap( out vec4 fragColor, in vec2 _fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int page;\n    vec2 fragCoord;\n    fragCoordFromVCube(rayDir, page, fragCoord);\n\n    if (page == 1) {\n        writePage1(fragColor, fragCoord);\n    } else if (page == 2) {\n        writePage2(fragColor, fragCoord);\n    } else if (page == 3) {\n        writePage3(fragColor, fragCoord);\n    } else if (page == 4) {\n        writePage4(fragColor, fragCoord);\n    } else if (page == 5) {\n        writePage5(fragColor, fragCoord);\n    } else {\n        discard;\n    }\n}\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MIN_DIST 0.005\n#define MAX_DIST 50.0\n#define RAY_STEPS 40\n#define RAY_STEPS_SHADOW 20\n\n#define CAUSTICS_INTENSITY 0.5\n#define LIGHT_COLOR vec3(1.0)\n#define GEOMETRY_COLOR_ABOVE vec3(0.2)\n#define GEOMETRY_COLOR_BELOW vec3(0.7, 0.7, 0.7)\n#define LIQUID_COLOR vec3(0.3, 0.45, 0.375)\n#define VOLUMETRIC_MAX_DIST 0.35\n\n#define ID_NONE 0\n#define ID_POOL 1\n#define ID_GEOMETRY 2\n\n// ================\n// General helpers\n// ================\n\nfloat getHeight(vec2 uv) {\n    return texture(iChannel0, vcubeFromFragCoord(1, uv*1024.0)).g;\n}\n\nvec3 getNormal(vec2 uv) {\n    return 2.0 * (texture(iChannel0, vcubeFromFragCoord(2, uv*1024.0)).xyz - 0.5);\n}\n\nfloat getCaustic(vec2 uv) {\n    return texture(iChannel0, vcubeFromFragCoord(5, uv*1024.0)).x;\n}\n\nvoid getParallaxMaxOffsets(\n    in vec3 tangentS,\n    in vec3 tangentT,\n    in vec3 nvNormal,\n    in vec3 camToFrag,\n    in float depthMax,\n    out vec2 maxTexOffset,\n    out vec3 maxPosOffset\n){\n    // Scale camToFrag so that its depth into the surface == depthMax\n    float camDist = -dot(camToFrag, nvNormal);\n    maxPosOffset = (depthMax / camDist) * camToFrag;\n\n    // maxPosOffset = a*tangentS + b*tangentT + N <=> maxTexOffset = [a,b]\n    float dss = dot(tangentS, tangentS);\n    float dst = dot(tangentS, tangentT);\n    float dtt = dot(tangentT, tangentT);\n    float dcs = dot(maxPosOffset, tangentS);\n    float dct = dot(maxPosOffset, tangentT);\n    float invDet = 1.0 / (dss * dtt - dst * dst);\n    maxTexOffset = invDet * vec2(dtt*dcs - dst*dct, -dst*dcs + dss*dct);\n}\n\nfloat getParallaxDepthFactor(vec2 uvInitial, vec2 maxTexOffset, int steps) {\n    vec2 uvMax = uvInitial + maxTexOffset;\n    float dt = 1.0 / float(steps);\n\n    float tOld = 0.0, depthOld = 0.0;\n    float tCur = 0.0, depthCur = 0.0;\n\n    for(int i=0; i<=steps; ++i){\n        tOld = tCur;\n        tCur = float(i)*dt;\n\n        depthOld = depthCur;\n        depthCur = 1.0 - getHeight(mix(uvInitial, uvMax, tCur));\n\n        if(tCur > depthCur){\n            tCur = mix(tOld, tCur, unmix(depthOld-tOld, depthCur-tCur, 0.0));\n            break;\n        }\n    }\n\n    return tCur;\n}\n\n// ===========================\n// Scene geometry and shadows\n// ===========================\n\nvoid sdGeometry(in vec3 p, out float sd) {\n    float sdA = sdBox( vec3(0.0, -2.0*POOL_DEPTH_WORLD, 0.0), vec3(1.0, 2.0*POOL_DEPTH_WORLD + 0.01, 1.0), p );\n    float sdB1 = sdBox( vec3(0.0), vec3(0.8,     POOL_DEPTH_WORLD, 0.8), p );\n    float sdB2 = sdBox( vec3(0.0), vec3(0.3, 2.0*POOL_DEPTH_WORLD, 0.3), p );\n    sd = max(-min(sdB1, sdB2),sdA);\n}\n\nvec3 nvGeometryNormal(in vec3 p) {\n    float sdXA, sdXB, sdYA, sdYB, sdZA, sdZB;\n\n    const float eps = 1e-2;\n    sdGeometry(p - vec3(eps, 0.0, 0.0), sdXA);\n    sdGeometry(p + vec3(eps, 0.0, 0.0), sdXB);\n    sdGeometry(p - vec3(0.0, eps, 0.0), sdYA);\n    sdGeometry(p + vec3(0.0, eps, 0.0), sdYB);\n    sdGeometry(p - vec3(0.0, 0.0, eps), sdZA);\n    sdGeometry(p + vec3(0.0, 0.0, eps), sdZB);\n\n    return normalize(vec3(sdXB-sdXA, sdYB-sdYA, sdZB-sdZA));\n}\n\nvoid hitPool(in vec3 p, in vec3 nv, out int idHit, out vec3 pHit, out vec2 uvHit) {\n    float poolSurfaceY = mix(POOL_SURFACE_WORLD_MIN.y, POOL_SURFACE_WORLD_MAX.y, 0.5);\n\n    float t = (poolSurfaceY - p.y) / nv.y;\n    if (t < MIN_DIST) {\n        idHit = ID_NONE;\n        return;\n    }\n\n    pHit = p + t*nv;\n    uvHit = vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, pHit.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, pHit.z)\n    );\n\n    float didHit = isInInterval(0.0, 1.0, uvHit.s) * isInInterval(0.0, 1.0, uvHit.t);\n    idHit = didHit < 0.5 ? ID_NONE : ID_POOL;\n}\n\nvoid hitScene(in vec3 p, in vec3 nv, out int idHit, out vec3 pHit) {\n    float travel = 0.0;\n    vec3 curPos = p;\n\n    for (int k = 0; k < RAY_STEPS; k++) {\n        float sdStep;\n        sdGeometry(curPos, sdStep);\n\n        if (abs(sdStep) < MIN_DIST) {\n            idHit = ID_GEOMETRY;\n            pHit = curPos;\n            return;\n        }\n\n        curPos += sdStep * nv;\n        travel += sdStep;\n        if (travel > MAX_DIST) {\n            break;\n        }\n    }\n\n    idHit = ID_NONE;\n    pHit = curPos;\n}\n\nfloat getShadowCoeff(in vec3 p, in vec3 nv) {\n    float tHit = 0.0;\n    vec3 curPos = p;\n    float shadowCoeff = 0.0;\n\n    for (int k = 0; k < RAY_STEPS_SHADOW; k++) {\n        float sdStep;\n        sdGeometry(curPos, sdStep);\n\n        float curLightPercent = abs(sdStep)/(0.1*tHit);\n        shadowCoeff = max(shadowCoeff, 1.0-curLightPercent);\n\n        if (abs(sdStep) < MIN_DIST) {\n            shadowCoeff = 1.0;\n            break;\n        }\n\n        curPos += sdStep * nv;\n        tHit += sdStep;\n        if (tHit > MAX_DIST) {\n            break;\n        }\n    }\n\n    return clamp(shadowCoeff, 0.0, 1.0);\n}\n\n// =========\n// Textures\n// =========\n\nvec3 skybox(in vec3 nv) {\n    return mix(0.5+0.5*normalize(nv), vec3(0.8, 0.7, 1.0), 0.7);\n}\n\nvoid texPool(\n    in vec3 camPos, in vec3 lightPos, in vec3 p,\n    out vec3 pBump, out float didHit,\n    out vec3 c, out vec3 nvRefl, out float coeffRefl, out vec3 nvRefract, out float coeffRefract\n) {\n    vec2 uv = vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, p.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, p.z)\n    );\n\n    vec3 tangentS = vec3(POOL_SURFACE_WORLD_MAX.x-POOL_SURFACE_WORLD_MIN.x, 0.0, 0.0);\n    vec3 tangentT = vec3(0.0, 0.0, POOL_SURFACE_WORLD_MIN.z-POOL_SURFACE_WORLD_MAX.z);\n\n    // Parallax occlusion mapping: hit surface\n    vec2 maxTexOffset;\n    vec3 maxPosOffset;\n    getParallaxMaxOffsets(\n        tangentS,\n        tangentT,\n        vec3(0.0, 1.0, 0.0),\n        p - camPos,\n        POOL_BUMP_HEIGHT_WORLD,\n        maxTexOffset,\n        maxPosOffset\n    );\n\n    float depthPct = getParallaxDepthFactor(uv, maxTexOffset, 16);\n\n    vec2 uvBump = uv + depthPct*maxTexOffset;\n    vec3 posBump = p + depthPct*maxPosOffset;\n    vec3 nvBumpNormal = getNormal(uvBump);\n\n    // Output where (and if) the bumped surface got hit\n    pBump = posBump;\n    didHit = isInInterval(0.0, 1.0, uvBump.s) * isInInterval(0.0, 1.0, uvBump.t);\n\n    // Material for surface\n    vec3 nvBumpPosToCam = normalize(camPos - posBump);\n    vec3 nvBumpPosToLight = normalize(lightPos - posBump);\n\n    vec3 matSurface = vec3(1.0);\n    vec3 diffuse;\n    vec3 specular;\n    materialShader(\n        0.25, 0.75, 80.0,\n        LIGHT_COLOR, matSurface, nvBumpNormal,\n        nvBumpPosToLight,\n        nvBumpPosToCam,\n        diffuse,\n        specular\n    );\n    float shadowCoeff = getShadowCoeff(posBump + 0.005*nvBumpNormal, nvBumpPosToLight);\n    diffuse *= (1.0 - shadowCoeff);\n    specular *= (1.0 - shadowCoeff);\n\n    // Reflection data (Schlick approximation)\n    nvRefl = normalize(reflect(posBump-camPos, nvBumpNormal));\n\n    float r0 = pow((IR_LIQUID-IR_AIR)/(IR_LIQUID+IR_AIR), 2.0);\n    float cosHitAngle = dot(nvBumpNormal, nvBumpPosToCam);\n    coeffRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 5.0));\n\n    // Refraction data\n    nvRefract = refract(-nvBumpPosToCam, nvBumpNormal, IR_AIR/IR_LIQUID);\n    coeffRefract = 0.9*(1.0 - coeffRefl);\n\n    // Base color to be blended with reflection/refraction\n    c = specular + (1.0 - (coeffRefl+coeffRefract))*diffuse;\n}\n\nvoid texGeometryBase(\n    in vec3 camPos, in vec3 lightPos, in vec3 matColor, in vec3 p,\n    out vec3 color, out float shadowCoeff\n) {\n    vec3 nvNormal = nvGeometryNormal(p);\n\n    vec3 nvPosToCam = normalize(camPos - p);\n    vec3 nvPosToLight = normalize(lightPos - p);\n\n    vec3 diffuse;\n    vec3 specular;\n    materialShader(\n        0.6, 0.9, 25.0,\n        LIGHT_COLOR, matColor, nvNormal,\n        nvPosToLight,\n        nvPosToCam,\n        diffuse,\n        specular\n    );\n    color = diffuse + specular;\n    shadowCoeff = getShadowCoeff(p + 0.005*nvNormal, nvPosToLight);\n}\n\nvec3 texGeometry(vec3 camPos, vec3 lightPos, vec3 p) {\n    vec3 c;\n    float shadowCoeff;\n    texGeometryBase(camPos, lightPos, GEOMETRY_COLOR_ABOVE, p, c, shadowCoeff);\n\n    return mix(c, vec3(0.0), shadowCoeff);\n}\n\nvec3 texGeometryUnderwater(vec3 camPos, vec3 lightPos, vec3 p) {\n    vec3 c;\n    float shadowCoeff;\n    texGeometryBase(camPos, lightPos, GEOMETRY_COLOR_BELOW, p, c, shadowCoeff);\n\n    // The caustics map assumes that p is POOL_DEPTH_WORLD below poolSurfaceY.\n    // In general, we need to shift it based on depth.\n    // --------------------------------------------------\n    float poolSurfaceY = mix(POOL_SURFACE_WORLD_MIN.y, POOL_SURFACE_WORLD_MAX.y, 0.5);\n\n    vec3 posToLight = lightPos - p;\n    float targetY = poolSurfaceY - POOL_DEPTH_WORLD;\n    vec3 pCorrected = p + ((targetY - p.y) / posToLight.y)*posToLight;\n\n    vec2 uvCaustic = vec2(\n        unmix(POOL_SURFACE_WORLD_MIN.x, POOL_SURFACE_WORLD_MAX.x, pCorrected.x),\n        unmix(POOL_SURFACE_WORLD_MAX.z, POOL_SURFACE_WORLD_MIN.z, pCorrected.z)\n    );\n    // --------------------------------------------------\n\n    float caustic = getCaustic(uvCaustic);\n    float causticShadow = CAUSTICS_INTENSITY*clamp(unmix(0.5, 0.0, caustic), 0.0, 1.0);\n    float causticHighlight = CAUSTICS_INTENSITY*clamp(unmix(0.5, 1.0, caustic), 0.0, 1.0);\n\n    c = mix(c, LIGHT_COLOR, causticHighlight);\n    c = mix(c, vec3(0.0), clamp(causticShadow + shadowCoeff, 0.0, 1.0));\n    return c;\n}\n\n// ====================================================\n// Final image\n// ====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 camPos;\n    vec3 nvCamDir;\n    sceneCamera(iResolution, fragCoord, iTime, camPos, nvCamDir);\n    vec3 lightPos = sceneLight(iTime);\n\n    // Hit scene with signed distance field; hit pool exactly\n    // ----------------------------------------------------------\n    int idHitScene;\n    vec3 pHitScene;\n    hitScene(camPos, nvCamDir, idHitScene, pHitScene);\n\n    int idHitPool;\n    vec3 pHitPool;\n    vec2 uvHitPool;\n    hitPool(camPos, nvCamDir, idHitPool, pHitPool, uvHitPool);\n\n    // Combine the hit data for scene and flat pool surface\n    int idHit = idHitScene;\n    vec3 p = pHitScene;\n    if (idHitPool != ID_NONE && (idHit == ID_NONE || distsq(pHitPool, camPos) < distsq(p, camPos))) {\n        idHit = ID_POOL;\n        p = pHitPool;\n    }\n    // ----------------------------------------------------------\n\n    vec3 c = vec3(0.0);\n    if (idHit == ID_NONE) {\n        c = skybox(nvCamDir);\n    } else if (idHit == ID_GEOMETRY) {\n        c = texGeometry(camPos, lightPos, p);\n    } else if (idHit == ID_POOL) {\n        vec3 pBump;\n        float didHit;\n\n        vec3 cConst;\n\n        vec3 nvRefl;\n        float coeffRefl;\n\n        vec3 nvRefract;\n        float coeffRefract;\n\n        texPool(\n            camPos, lightPos, p,\n            pBump, didHit,\n            cConst, nvRefl, coeffRefl, nvRefract, coeffRefract\n        );\n\n        // Total miss (e.g. ray hitting surface near edge, with water low)\n        if (didHit < 0.5) {\n\n            if (idHitScene == ID_GEOMETRY) {\n                c = texGeometry(camPos, lightPos, pHitScene);\n            }\n\n        // Did actually hit the surface; blend refraction and reflection colors\n        } else {\n            // Refraction (just do geometry)\n            int idHit1;\n            vec3 p1;\n            hitScene(pBump, nvRefract, idHit1, p1);\n            vec3 cRefract = vec3(0.0);\n            if (idHit1 == ID_GEOMETRY) {\n                float volumetricAmount = clamp(unmix(0.0, VOLUMETRIC_MAX_DIST, distance(pBump, p1)), 0.0, 1.0);\n                cRefract = mix(\n                    texGeometryUnderwater(camPos, lightPos, p1),\n                    LIQUID_COLOR*LIGHT_COLOR,\n                    volumetricAmount\n                );\n            }\n\n            // Reflection (just do skybox)\n            vec3 cRefl = skybox(nvRefl);\n            c = clamp(cConst + coeffRefract*cRefract + coeffRefl*cRefl, 0.0, 1.0);\n        }\n    }\n\n    // Mouse input\n    //---------------------------------------\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        vec2 packMouse = packUVWithBool(vec2(0.5), false);\n        if (iMouse.z > 0.0) {\n            vec3 camPosMouse;\n            vec3 nvCamDirMouse;\n            sceneCamera(iResolution, iMouse.xy, iTime, camPosMouse, nvCamDirMouse);\n\n            hitPool(camPosMouse, nvCamDirMouse, idHitPool, pHitPool, uvHitPool);\n            packMouse = packUVWithBool(clamp(uvHitPool, 0.0, 1.0), true);\n\n        }\n        c.rg = packMouse;\n    }\n    //---------------------------------------\n\n    vec3 focusPoint = POOL_SURFACE_CENTER;\n    float distFromFocus = distance(camPos, focusPoint);\n    float distFromFrag = distance(camPos, p);\n    float blurAmount = clamp(1.0*abs(distFromFocus-distFromFrag), 0.0, 1.0);\n\n    fragColor = vec4(c, blurAmount);\n}\n", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 221, 221, 1636], [1638, 1638, 1695, 1695, 2429]], "test": "untested"}
{"id": "3tX3RH", "name": "Anpanman.", "author": "nodo", "description": "This is Anpanman.", "tags": ["raymarching"], "likes": 4, "viewed": 337, "published": 3, "date": "1582525134", "time_retrieved": "2024-07-30T21:22:13.426579", "image_code": "#define MAT_BALL 1.0\n#define MAT_BALL2 2.0\n#define MAT_BALL3 3.0\n#define MAT_A_EYE 4.0\n#define MAT_A_EYEBLOW 5.0\n#define MAT_A_HEAD 6.0\n#define MAT_A_NOSE 7.0\n#define MAT_A_MOUTH 8.0\n#define MAT_S_HEAD 9.0\n#define MAT_K_HEAD 11.0\n#define MAT_K_TOOTH 12.0\n#define MAT_K_MOUTH 13.0\n#define MAT_K_NOSE 14.0\n\n\n\n\n#define MAT_FLOOR 10.0\n#define MAT_SKY 100.0\n\n\n\n\nprecision mediump float;\n\n\nconst float PI = 3.14159265;\nconst vec3 lightDir = normalize(vec3(0.5, 0.5, 0.5));\nvec3 RayOrigin, Target;\n\n// rotate\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0))\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (d1.x<-d2.x) ? vec2(-d2.x,d2.y) : d1;\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? vec2(d2.x,-d2.y) : d1;\n}\n\n\n\n// anpanman\nvec2 anpanHead(vec3 p, float size){\n    return vec2(sdEllipsoid(p, vec3(size,size*0.95,size*0.8)),MAT_A_HEAD);\n}\n\n\nvec2 anpanEye(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-0.3*size,-0.75*size), vec3(size/12.0,size*0.95/10.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-0.3*size,-0.75*size), vec3(size/12.0,size*0.95/10.0,size*0.5/10.0));\n    return vec2(min(d1,d2),MAT_A_EYE);\n}\n\nvec2 anpanNose(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.0,0.0,-0.8 *size), vec3(size/4.8,size*0.95/5.0,size*0.5/5.0));\n    float d2 = sdEllipsoid(p+vec3(0.33*size,0.03*size,-0.73*size), vec3(size/5.5,size*0.95/5.5,size*0.5/5.5));\n    float d3 = sdEllipsoid(p+vec3(-0.33*size,0.03*size,-0.73*size), vec3(size/5.5,size*0.95/5.5,size*0.5/5.5));\n    return vec2(min(d1,min(d2,d3)),MAT_A_NOSE);\n}\n\n\nvec2 anpanMouth(vec3 p, float size){\n    float d1 = sdRoundedCylinder(rotate(p+vec3(0.0,0.15*size,-0.8*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.15*size, 0.2*size, 0.1*size );\n    float d2 = sdBox(p, vec3(0.3*size,0.2*size,1.0*size));\n    return vec2(max(d1,-d2),MAT_A_MOUTH);\n}\n\nvec2 anpanEyeblowLeft(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 anpanEyeblowRight(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(-0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 anpanman(vec3 p, float size){\n    vec2 d = opU(anpanEyeblowLeft(p,size),anpanEyeblowRight(p, size));\n    d = opU(d,anpanHead(p,size));\n    d = opU(d,anpanEye(p,size));\n    d = opS(d,anpanMouth(p,size));\n    d = opU(d,anpanNose(p,size));\n    return d;\n}\n\n//syokupanman\nvec2 syokupanHead(vec3 p, float size){\n    float d1 = sdRoundBox(p+vec3(0.0,0.0,0.0)*size,vec3(0.5,0.5,0.5)*size, 0.2 *size);\n    float d2 = sdEllipsoid(p+vec3(0.0*size,-0.75*size,0.0*size), vec3(size* 0.9,size*0.4,size*0.8));\n    float d3 = sdBox(p,vec3(2.0*size,2.0*size,0.2*size));\n    return vec2(max(min(d1,d2),d3),MAT_S_HEAD);\n}\n\nvec2 syokupanEye(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.25*size,-0.55*size,-0.2*size), vec3(size/13.0,size*0.95/9.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.25*size,-0.55*size,-0.2*size), vec3(size/13.0,size*0.95/9.0,size*0.5/10.0));\n    return vec2(min(d1,d2),MAT_A_EYE);\n}\n\nvec2 syokupanEyeblowLeft(vec3 p, float size){\n    p += vec3(0.05,-0.3,0.55);\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 syokupanEyeblowRight(vec3 p, float size){\n    p += vec3(-0.05,-0.3,0.55);\n    float d1 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(-0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 syokupanMouth(vec3 p, float size){\n    p.y -= 0.1;\n    size*=1.2;\n    float d1 = sdRoundedCylinder(rotate(p+vec3(0.0,0.15*size,-0.2*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.15*size, 0.2*size, 0.1*size );\n    float d2 = sdBox(p, vec3(0.3*size,0.2*size,1.0*size));\n    return vec2(max(d1,-d2),MAT_A_HEAD);\n}\n\nvec2 syokupanNose(vec3 p, float size){\n    p += vec3(0.0,-0.2,-0.2);\n    p = rotate(p, radians(20.0), vec3(1.0, 0.0, 0.0));\n    return vec2(sdBox(p,vec3(0.05,0.09,0.05)),MAT_S_HEAD);\n}\n\nvec2 syokupanman(vec3 p, float size){\n    return opU(opI(syokupanHead(p,size),-syokupanMouth(p,size)),opU(opU(syokupanEye(p,size),syokupanNose(p, size)),opU(syokupanEyeblowLeft(p,size),syokupanEyeblowRight(p, size))));\n}\n\nfloat smin( float a, float b)\n{\n    float k = 1.3;\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float tmp = mix( b, a, h );\n    return tmp - k*h*(1.0-h);\n}\n\n//kabao\n\nvec2 kabaoHead(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.0*size,0.2*size,0.0*size), vec3(size/1.0,size/1.2,size/1.0));\n    float d2 = sdEllipsoid(p+vec3(0.0*size,-1.2*size,0.0*size), vec3(size/1.5,size/2.0,size/1.5));    \n\treturn vec2(smin(d1,d2),MAT_K_HEAD);\n}\n\nvec2 kabaoEye(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-1.2*size,-0.75*size), vec3(size/15.0,size*1.05/10.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-1.2*size,-0.75*size), vec3(size/15.0,size*1.05/10.0,size*0.5/10.0));\n    return vec2(min(d1,d2),MAT_A_EYE);\n}\n\nvec2 kabaoEyeblow(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-1.35*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.5/7.0));\n    float d2 = sdEllipsoid(p+vec3(0.2*size,-1.33*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.8/7.0));\n\td1 = max(d1,-d2);\n    \n    float d3 = sdEllipsoid(p+vec3(-0.2*size,-1.35*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.5/7.0));\n    float d4 = sdEllipsoid(p+vec3(-0.2*size,-1.33*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.8/7.0));\n\td3 = max(d3,-d4);\n    return vec2(min(d1,d3),MAT_A_EYEBLOW);\n}\n\nvec2 kabaoMouth(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.45*size,0.1*size,-0.8*size), vec3(size/3.2,size/3.2,size/3.2));\n    float d2 = sdEllipsoid(p+vec3(-0.45*size,0.1*size,-0.8*size), vec3(size/3.2,size/3.2,size/3.2));\n\treturn vec2(smin(d1,d2),MAT_K_MOUTH);\n}\n\nvec2 kabaoEar(vec3 p, float size){\n    float d1 = sdRoundedCylinder(rotate(p + vec3(0.40*size,-1.7*size,-0.2*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.07/size, 0.07/size,0.03/size );\n    float d2 = sdRoundedCylinder(rotate(p + vec3(-0.40*size,-1.7*size,-0.2*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.07/size, 0.07/size,0.03/size );\n\td1 = min(d1,d2);\n    return vec2(d1,MAT_K_HEAD);\n}\n\nvec2 kabaoTooth(vec3 p, float size){\n    float d1 = sdRoundBox(p +vec3(0.3*size,0.43*size,-0.68*size), vec3(0.025/size,0.005/size,0.005/size), 0.15 /size);\n    float d2 = sdRoundBox(p +vec3(-0.3*size,0.43*size,-0.68*size), vec3(0.03/size,0.005/size,0.005/size), 0.15 /size);\n    float d3 = sdRoundBox(p +vec3(0.4*size,-0.15*size,-0.64*size), vec3(0.03/size,0.005/size,0.005/size), 0.15 /size);\n    float d4 = sdRoundBox(p +vec3(-0.4*size,-0.15*size,-0.64*size), vec3(0.03/size,0.005/size,0.005/size), 0.15 /size);\n\td1 = min(d1,d2);\n    d1 = min(d1,d3);\n    d1 = min(d1,d4);\n    return vec2(d1,MAT_K_TOOTH);\n}\n\nvec2 kabaoNose(vec3 p, float size){\n    float d1 =  sdRoundedCylinder(rotate(p + vec3(0.35*size,-0.53*size,-0.73*size),radians(90.0),vec3(0.9,0.3,0.0)), 0.09/size, 0.09/size,0.01/size );\n    float d2 =  sdRoundedCylinder(rotate(p + vec3(-0.35*size,-0.53*size,-0.73*size),radians(90.0),vec3(0.9,-0.3,0.0)), 0.09/size, 0.09/size,0.01/size );\n\td1 = min(d1,d2);\n    return vec2(d1,MAT_K_NOSE);\n}\n\n\n\nvec2 kabao(vec3 p, float size){\n    vec2 d = opI(kabaoHead(p,size),-kabaoMouth(p,size));\n    d = opU(d,kabaoEye(p,size));\n    d = opU(d,kabaoEyeblow(p,size));\n    d = opU(d,kabaoEar(p,size));\n    d = opU(d,kabaoTooth(p,size));\n    d = opU(d,kabaoNose(p,size));\n    return d;   \n}\n\n\n\n\n\nvec2 distFunc(vec3 p){\n    \n    vec2 d = anpanman(p+vec3(0.0,-2.0,1.5),1.0);\n    vec2 d2 = vec2(sdBox(p+vec3(0.0,2.0,1.5),vec3(5.0,3.0,2.0)),MAT_FLOOR);\n    vec2 d3 = syokupanman(p+vec3(2.5,-2.0,1.5),1.0);\n    vec2 d4 = kabao(p+vec3(-2.5,-2.0,1.5),1.0);\n\n    d = opU(d,d3);\n    d = opU(d,d4);\n    \n    return opU(d,d2);\n}\n\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)).x - distFunc(p + vec3( -d, 0.0, 0.0)).x,\n        distFunc(p + vec3(0.0,   d, 0.0)).x - distFunc(p + vec3(0.0,  -d, 0.0)).x,\n        distFunc(p + vec3(0.0, 0.0,   d)).x - distFunc(p + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = distFunc(p + t*l).x;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n//V:-ray L:lightdir\nvec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    float shadow = shadow(pos, L);\n    //shadow =1.0;\n\tvec3 diffuseBRDF = kd * albedo / PI;\n   // return diffuseBRDF* Lradiance * NdotL * shadow;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n//return specularBRDF;\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n\nvec4 genAmbientOcclusion(vec3 ro, vec3 rd)\n{\n    vec4 totao = vec4(0.0);\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++)\n    {\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = distFunc(aopos).x;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca * vec4(1.0, 1.0, 1.0, 1.0);\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n    totao.w = 1.0 - clamp(aoCoef * totao.w, 0.0, 1.0);\n\n    return totao;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 materialize(vec3 p, vec3 ray, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 sky = vec3(0.1, 0.3, 0.5) * 1.5;\n    vec4 cube = texture(iChannel0, ray);\n\n\n    float roughness = 0.0, metalness = 0.0;\n    vec3 albedo = vec3(0.0), normal = vec3(0.0), emissive = vec3(0.0);\n    float h = mat.y;\n    float specular = 0.0;\n    vec3 ambient = vec3(0.1);\n    normal = getNormal(p);\n\n\n\tif (mat.y == MAT_SKY) {\n\n        col = cube.xyz;\n        return col;\n    } else if (mat.y == MAT_BALL) {\n        col = pow(vec3(102.0 / 255.0, 69.0 / 255.0, 0.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_BALL2) {\n        col = vec3(0.8,0.8,0.5);\n        col = pow(vec3(59.0 / 255.0, 59.0 / 255.0, 123.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_BALL3) {\n        col = vec3(0.0,1.0,1.0);\n        col = pow(vec3(20.0 / 255.0, 120.0 / 255.0, 102.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_HEAD) {\n        col = pow(vec3(235.0/255.0,151.0/255.0, 98.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.4;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_EYE) {\n        col = pow(vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_EYEBLOW) {\n        col = pow(vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_NOSE) {\n        col = pow(vec3(0.8,0.0,0.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_MOUTH) {\n        col = pow(vec3(143.0/255.0, 54.0/255.0, 67.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_S_HEAD) {\n        if(dot(normal,vec3(0.0,0.0,1.0)) > 0.5 ){\n        \tcol = pow(vec3(240.0/255.0, 240.0/255.0, 240.0/255.0), vec3(2.2)) * 0.6;\n        }else{\n        \tcol = pow(vec3(235.0/255.0,151.0/255.0, 98.0/255.0), vec3(2.2)) * 0.6;\n        }\n\n        roughness = 0.7;\n        metalness = 0.8;\n    }else if (mat.y == MAT_K_HEAD) {\n        col = pow(vec3(170.0/255.0,88.0/255.0, 67.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.4;\n        metalness = 0.8;\n    }else if (mat.y == MAT_K_TOOTH) {\n        col = pow(vec3(240.0/255.0, 240.0/255.0, 240.0/255.0), vec3(2.2)) * 0.6;\n        \n        roughness = 0.9;\n        metalness = 0.9;\n    }else if (mat.y == MAT_K_MOUTH) {\n        col = pow(vec3(197.0/255.0,102.0/255.0,110.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    }else if (mat.y == MAT_K_NOSE) {\n        col = pow(vec3(117.0/255.0,64.0/255.0,58.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    }else if (mat.y == MAT_FLOOR) {\n        col = vec3(1.0);\n        // generate tile pattern\n        float u = 1.0 - floor(mod(p.x, 2.0));\n        float v = 1.0 - floor(mod(p.z, 2.0));\n        vec2 uv = vec2(0.0);\n        if(dot(normal,vec3(0.0,1.0,0.0)) < 0.5 ){\n        \tfloat u = 1.0 - mod(p.x*0.2, 1.0);\n        \tfloat v = 1.0 - mod(p.y*0.2, 1.0);\n            uv = vec2(u,v);\n        }else{\n            float u = 1.0 - mod(p.x*0.2, 1.0);\n        \tfloat v = 1.0 - mod(p.z*0.2, 1.0);   \n            uv = vec2(u,v);\n        }\n        if((u == 1.0 && v < 1.0) || (u < 1.0 && v == 1.0)){\n            col *= 0.7;\n        }\n        \n        col = pow(col, vec3(2.2)) * 0.1;\n        \n        roughness = 0.5;\n        metalness = 0.0;\n    }else {\n        col = vec3(1.0,0.0,1.0);\n    }\n    \n    vec4 ao = genAmbientOcclusion(p, normal);    \n    \n    vec3 result = vec3(0.);\n    result += shade(p, col, metalness, roughness, normal, -ray, lightDir, vec3(1.0, 0.98, 0.95) * 100.);\n    col = result-(ao.xyz*ao.w);\n    \n \n    return col;    \n}\n\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n           \n    RayOrigin =  vec3(0.0,  4.0,  6.0);\n    RayOrigin.xz *= rot(iTime*0.3);\n    Target = vec3(0.0, 2.0, 0.0);\n\n    mat3 c = camera(RayOrigin, Target, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.0));\n\n    vec3  rPos = RayOrigin;\n    float alpha = 1.0;\n\tvec3 color=vec3(0.0);\n\n\n    for(int i = 0; i < 3; i++) {\n\n\n    // marching loop\n    float rLen = 0.0;\n    vec2 mat;\n    bool isSky = true;\n\n    for(int i = 0; i < 128; i++){\n        mat = distFunc(rPos);\n        if (mat.x < 0.001) {\n            isSky = false;\n            break;\n        }\n        \n        if(rLen > 50.0){\n        \tisSky = true;\n        \tbreak;\n    \t}\n        rLen += mat.x;\n        rPos = RayOrigin + ray * rLen;\n    }\n\n  //  mat.x < 0.00001 ? mat.y += 0.0:mat.y =100.0;\n        \n    if(isSky){\n    \tmat.y = 100.0;                 \n    }\n        \n    color += alpha * materialize(rPos,ray,mat);\n    alpha *= 0.3;\n    \n    vec3 normal = getNormal(rPos);\n    \n    ray = normalize(reflect(ray, normal));\n    rPos = rPos + normal * 0.001;\n\n    if (mat.y == 100.0) {\n      break;\n    }\n  }\n\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tX3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 502, 546, 546, 975], [977, 977, 995, 995, 1057], [1059, 1059, 1094, 1094, 1120], [1123, 1123, 1154, 1154, 1306], [1309, 1309, 1354, 1354, 1510], [1512, 1512, 1555, 1555, 1644], [1646, 1646, 1710, 1710, 1831], [1835, 1835, 1863, 1863, 1899], [1901, 1901, 1929, 1929, 1980], [1982, 1982, 2010, 2010, 2060], [2064, 2076, 2111, 2111, 2188], [2191, 2191, 2225, 2225, 2493], [2495, 2495, 2530, 2530, 2902], [2905, 2905, 2941, 2941, 3183], [3185, 3185, 3227, 3227, 3582], [3584, 3584, 3627, 3627, 3985], [3987, 3987, 4021, 4021, 4244], [4246, 4260, 4298, 4298, 4594], [4596, 4596, 4633, 4633, 4901], [4903, 4903, 4948, 4948, 5334], [5336, 5336, 5382, 5382, 5772], [5774, 5774, 5813, 5813, 6085], [6087, 6087, 6125, 6125, 6271], [6273, 6273, 6310, 6310, 6493], [6495, 6495, 6526, 6526, 6661], [6672, 6672, 6707, 6707, 6948], [6950, 6950, 6984, 6984, 7252], [7254, 7254, 7292, 7292, 7822], [7824, 7824, 7860, 7860, 8102], [8104, 8104, 8138, 8138, 8487], [8489, 8489, 8525, 8525, 9097], [9099, 9099, 9134, 9134, 9490], [9494, 9494, 9525, 9525, 9773], [9779, 9779, 9801, 9801, 10100], [10103, 10103, 10126, 10126, 10433], [10435, 10435, 10479, 10479, 10650], [10652, 10652, 10693, 10693, 10736], [10738, 10738, 10801, 10801, 10912], [10914, 10914, 10987, 10987, 11071], [11074, 11074, 11110, 11110, 11445], [11447, 11467, 11576, 11576, 12285], [12288, 12288, 12332, 12332, 12786], [12788, 12788, 12808, 12808, 12880], [12882, 12882, 12928, 12928, 16768], [16771, 16771, 16813, 16813, 17003], [17006, 17006, 17063, 17063, 18257]], "test": "untested"}
{"id": "WlVSR1", "name": "Marching of Boxes", "author": "nodo", "description": "Practice timeline control", "tags": ["raymarch"], "likes": 6, "viewed": 419, "published": 3, "date": "1582511972", "time_retrieved": "2024-07-30T21:22:14.200509", "image_code": "precision highp float;\n\nconst float pi = acos(-1.);\nfloat sum = 0.0;\nfloat modid;\n\n///parameter\nfloat ss;\nfloat distotion;\nfloat diff;\nfloat speed;\nfloat proliferation;\nfloat scanning;\nfloat ly;\nvec3 ro, target;\nfloat fov;\nfloat concentrationline;\nfloat waveintensity;\n///\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*pi/2.0 : atan(y, x);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeline(float time){\n    \n\tfloat t = 0.0;\n\n    speed = 50.0;\n\n    \n    t = tl(time,1.0,1.0);\n    ly = mix(0.0,50.0,eio(t));\n    \n    t = tl(time,0.5,1.0);\n    diff = mix(0.0,1.0,eio(t));\n    \n    t = tl(time,0.5,1.0);\n    proliferation = mix(28.0,0.0,eio(t));\n    waveintensity = mix(0.0,10.0,eio(t));\n    \n    t = tl(time,0.5,4.0);\n    ro.x += sin(-2.0*pi*t)*70.0;\n    ro.z += sin(1.0*pi*t)*140.0;\n    \n    t = tl(time,1.0,0.5);\n    fov = mix(1.0,3.0,eio(t));\n    concentrationline = mix(0.0,1.0,eio(t));\n    \n    t = tl(time,1.0,0.5);\n    fov = mix(fov,1.0,eio(t));\n    concentrationline = mix(concentrationline,0.0,eio(t));\n\n    t = tl(time,1.0,1.0);\n    diff = mix(diff,0.0,eio(t));\n\tproliferation = mix(proliferation,28.0,eio(t));\n\tly = mix(ly,0.0,eio(t));\n    waveintensity = mix(waveintensity,0.0,eio(t));\n\n\n   \n    \n    ro.z  += iTime*speed;\n    target = vec3(0.0,0.0,60.0+iTime*speed);\n}\n\n\n\nfloat map(vec3 p){\n\n    if(abs(p.z-iTime*speed-70.0) < 30.0 - proliferation && abs(p.x) < 30.0 - proliferation){\n        modid = floor(((p.x)/3.0))*floor(((p.z)/3.0));\n\t\tp.y -= 35.*diff - texture(iChannel0,vec2(modid/100.0)).r*70.0*diff;\n\t\tp.xz = mod(p.xz,3.0) - 1.5;\n    }  \n    \n    return sdBox(p,vec3(2.0));\n}\n\n//https://qiita.com/edo_m18/items/37d8773a5295bc6aba3d\nfloat hexDist(vec2 p)\n{\n    p = abs(p);\n    \n    float c = dot(p, normalize(vec2(1., 1.73)));\n    \n    return max(c, p.x);\n}\n\nvec4 hex2d(vec2 uv)\n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - r * 0.5, r) - h;\n    vec2 gv = length(a) < length(b) ? a : b;\n    \n    vec2 id = gv - uv;\n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.5 - hexDist(gv);\n    \n    return vec4(x, y, id);\n}\n\nfloat wallmap(vec3 p){   \n    p = -abs(p);\n    p.y += 250.5;\n    return sdPlane(p, vec4(0, 1, 0, 1));\n}\n\n\nvec4 tracewall(vec3 ro,vec3 rd){\n    vec3 rPos = ro;\n    float depth=0.0;\n    vec3 col = vec3(.0);\n    float d;\n    \n\tfor(int i = 0 ; i < 99;i++){\n        d = wallmap(rPos);\n        if(d < 0.001){\n            col = vec3(float(i)/9.0);\n            col = vec3(0.1-hex2d(rPos.xz*0.02).g);\n            col *= exp(col.r*5.0)*5.0;\n            \n            break;\n     \t} \n        \n        depth += d;\n        rPos = ro + rd * depth;\n    }\n    \n    \n    float time = iTime * 2.5;\n    float wavy = pow(sin(length(rPos.xz - target.xz)*0.004 - time), 5.0) + 0.1;\n    //waveintensity = 10.0;\n    wavy *= waveintensity;\n    \n    col = vec3(col *wavy)*vec3(0.0,0.6,0.3);\n    \n    return vec4(col,depth);\n }\n\n\nvec3 getNormal(vec3 p){\n    float d = 0.01;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)) - map(p + vec3( -d, 0.0, 0.0)),\n        map(p + vec3(0.0,   d, 0.0)) - map(p + vec3(0.0,  -d, 0.0)),\n        map(p + vec3(0.0, 0.0,   d)) - map(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nfloat exp2Fog(float d, float density) {\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeline(mod(iTime,17.0));\n    \n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    \n    mat3 c = camera(ro, target, 0.0);\n    vec3 rd = c * normalize(vec3(uv, fov));\n    \n\n    vec3 lightPos = target;\n    vec3 lightPos2 = target;\n    vec3 lightPos3 = target;\n    \n    \n    vec3 an = vec3(0.0,ly,0.0);\n    an.xy *= rot(iTime*2.0);\n\n    lightPos2 += an;\n    lightPos3 -= an;\n  \n\n    vec3 col = vec3(0.0);\n    vec3 rPos = ro;\n    float depth = 0.0;\n    float mat;\n    float l2min = 99.0;\n    float l3min = 99.0;\n\n    for(int i = 0 ; i < 225;i++){\n        mat = map(rPos);\n        \n        if(mat < 0.001){\n            col = vec3(1.0-float(i)/250.);\n            break;\n        }\n        \n        if(depth > 500.0){\n            depth = 400.0;\n            break;\n        }\n        \n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        depth += min(min((step(0.0,rd.x)-fract(rPos.x))/rd.x, (step(0.0,rd.z)-fract(rPos.z))/rd.z)+0.01,mat);\n        rPos = ro + rd * depth;\n        \n        l2min = min(l2min,length(lightPos2 - rPos)/3.5);\n        l3min = min(l3min,length(lightPos3 - rPos)/3.5);\n\n    }\n    \n    l2min *= step(0.5,l2min);\n    l3min *= step(0.5,l3min);\n\n    vec4 backcol = tracewall(ro,rd);\n    \n    vec3 n = getNormal(rPos);\n    vec3 r = normalize(reflect(rd,n));\n        \n    ///light1\n    vec3 lv = lightPos - rPos;\n    vec3 ld = normalize(lv);\n    //ld = normalize(vec3(0.2,0.6,0.3));\n\n    float a = max(1.0-(length(lv)/20.5),0.0)*1.5;\n    float d = max(dot(ld,n),0.);\n    float s = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    ///light2\n    lv = lightPos2 - rPos;\n    ld = normalize(lv);\n    //ld = normalize(vec3(0.2,0.6,0.3));\n\n    float a2 = max(1.0-(length(lv)/25.5),0.0)*3.5;\n    float d2 = max(dot(ld,n),0.);\n    float s2 = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    vec3 lc2 = vec3(a2+d2+s2)*vec3(1.0,0.0,0.0);\n    \n    \n    ///light3\n    lv = lightPos3 - rPos;\n    ld = normalize(lv);\n\n    float a3 = max(1.0-(length(lv)/25.5),0.0)*1.5;\n    float d3 = max(dot(ld,n),0.);\n    float s3 = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    vec3 lc3 = vec3(a3+d3+s3)*vec3(0.0,1.0,0.0);\n  \n    \n    \n    float _Threshold = 0.1;\n    vec3 glow = max(abs(dot(rd, n)-_Threshold), 0.0)*vec3(0.1,0.5,0.6);\n    vec3 grid = vec3(step(2.9,mod(rPos,3.0)));\n    float k = 10.;\n    vec3 gridd = max(grid.x,max(grid.y,grid.z))*vec3(0.1,0.5,0.8);\n        \n    col = vec3(d+s+a)+lc2+lc3;\n\n    col *= glow;\n    gridd *= exp(k*sin(length(rPos)))/exp(k);\n    col += 5.0*gridd;\n        \n    depth *= 10.0;\n    \n    vec3 bgc = vec3(0.0,0.3,0.3);\n    //bgc = vec3(1.0);\n    if(depth > 1000.){\n        col = vec3(bgc);\n    }\n    \n    \n    //https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\n    float f = exp2Fog(backcol.a, 0.0014);\n    //backcol.rgb = mix(vec3(0.2,0.5,0.8), backcol.rgb, f);\n    backcol.rgb = mix(bgc, backcol.rgb, f);\n\n\n    if(depth > backcol.a){\n        col = backcol.rgb;\n    }\n    //  col = backcol.rgb;\n    col += max((1.0 - l2min)*vec3(1.0,0.0,0.0),0.0);\n    col += max((1.0 - l3min)*vec3(0.0,0.0,1.0),0.0);\n\n    \n    ////\n    //col = vec3(1.0) - col;\n    \n    \n    // zoom line  http://sayachang-bot.hateblo.jp/entry/2019/02/09/200303    \n    float t = length(uv)*0.07 - 0.05;\n    \n    float rr = length(uv);\n    rr = 0.8 * rr - 0.8;\n\n    a = atan2(uv.y, uv.x);\n    a = abs(cos(70. * a) + sin(30. * a));\n\n    d = a - rr;\n    float nn = smoothstep(0.1, 0.4, clamp(d, 0.0, 1.0));\n    \n    col += max((.5 - nn)*t*concentrationline,0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 292, 292, 354], [356, 356, 393, 393, 446], [449, 449, 480, 480, 567], [569, 569, 600, 600, 634], [637, 637, 685, 685, 822], [824, 824, 844, 844, 978], [980, 980, 1006, 1006, 1882], [1886, 1886, 1904, 1904, 2199], [2201, 2256, 2279, 2279, 2380], [2382, 2382, 2403, 2403, 2699], [2701, 2701, 2723, 2723, 2804], [2807, 2807, 2839, 2839, 3500], [3503, 3503, 3526, 3526, 3789], [3791, 3791, 3830, 3830, 3886], [3888, 3888, 3930, 3930, 4120], [4122, 4122, 4179, 4179, 7757]], "test": "untested"}
{"id": "ttGSWR", "name": "Pulsating iridescent spheres", "author": "jarble", "description": "This is another edit of the \"Fly Quaternion City\" shader.\n\nUse the mouse and arrow keys to move. The original shader is here: https://www.shadertoy.com/view/4tSyRz", "tags": ["fractal"], "likes": 4, "viewed": 466, "published": 3, "date": "1582508096", "time_retrieved": "2024-07-30T21:22:15.163933", "image_code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#define steps 100\n#define maxdistance 4.0\n#define epsilon 0.003\n\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-0.1667,0.0))+min(max(q.x,q.y)-0.1667,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(max(abs(q2.yz-vec2(0.0,0.5)),0.0))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = inside;\n    } else if (type == 1) {\n        //\n        len = -outside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        len = squarering(p.xyz-vec3(0,0,0.5));\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    }\n    \n    \n    return len;\n}\n\nfloat mapOcreeeTruchet(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    float size = 1.0;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p*exp2(i));\n    \n    int type = int(hash13((fp+exp2(-i-1.0))*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*exp2(-i);\n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p*exp2(i));\n        //check for the overlapping black dots\n        vec3 p2 = p*exp2(i);\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*exp2(-i);\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*exp2(-i),len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    //len *= size;\n    return len;\n    \n    /*vec3 q = abs(p-0.5);\n    \n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n    \n    float inside = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    if (floor(p) == vec3(0)) {\n    \tlen = -outside;\n    } else {\n        len = inside;\n    }\n    return len;*/\n    //return outside;\n\n}\n\n\n/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n\n\n//cut off half of the distance field along a plane that that the .y axis as its normal.\n#define cutY\n\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .00001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 256\n\n\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n#define doFog\n\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n\n//do specular light, fake reflectio of sunlight\n#define doSpec\n\n//max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n#define iterDfFractal 4.\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 8.\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n#define THRUST 0.02*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define sat(a) clamp(a,.0,1.)\n\n//load and save, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n//quaterion math\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n/*\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nvec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\nvec4 qslerp(vec4 q1, vec4 q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*/\n\n//hash\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n//quaterion math, just to be different\n\n//shape:\nvec3 Tile(vec3 p\n){\n ;vec3 a=vec3(8.0)\n ;//return p\n ;return abs(mod(p,a)-a*0.5)-a*0.25\n ;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n//colors\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//return signed distane of[p] to a surface.\nfloat gd(vec3 u//gradient differential, signed distance field:\n){\n ;//u.z+=1.\n // #define DareOctree  //toggle\n ;vec3 p=u \n  #ifndef DareOctree\n ;p=Tile(p)\n  #endif\n ;vec4 z=vec4(p*(1.0+sin(iTime)/20.0),1.0)*sin(length(p)-1.0+sin(p.x+p.y)/(sin(iTime)*5.0+10.0))\n ;float dG=1e3\n #ifdef DareOctree\n     //slow octree truchet (without octree traversal)\n;dG=mapOcreeeTruchet(u*.01)   //scale big to make navigable (woth collision detection scaling)\n     //https://www.shadertoy.com/view/MlcfRl\n #else    \n ;for(float n=.0;n<iterDfFractal;n++ //fractal\n ){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==2.)dG=DERect(z,rcL)\n ;}\n #endif\n //;dG=min(dG,DERect(z,rc))\n #ifdef cutY\n //;dG=max(dG,u.y);\n #endif\n ;return dG;\n ;}\n\n\n//a variant of gd(), that is HERE used to get a color and tto derive a surface normal.\n//the inout vec4 mcol is a big difference.\nfloat gd1(vec3 p,inout vec4 mcol\n){p=Tile(p)\n ;vec4 z=vec4(p,1)\n ;float dG=1e3\n ;vec4 mc=vec4(0)\n ;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n ){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n  ;else if(n==2.)dG=DERect(z,rcL);\n }float ds=DERect(z,rc)\n ;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n ;else mcol+=mc\n ;return min(dG,ds);}\n\nvec3 fog(float ts,vec3 spc,vec3 fcol){\n //;float fog=min(pow(ts*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n ;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n //must be reciprocal log() ?\n ;return mix(spc,fcol,fog);}\n\nfloat AO(in vec3 o,in vec3 d,float s){//origin, direction, scatterHash\n ;float t=.0,a=1.,f,n=.01+.04*s\n ;for(float i=.0;i<iterAO;i++ \n ){f=max(gd(o+d*t)*1.5,n)\n  ;a=min(a,f/t+t*0.5)\n  ;t+=f;\n }return a;}//soft shadow with \"noisy lens\".\n\n\n//return occluded specular.\nvec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 so,vec3 o,float s,vec4 mcol){\n;float l=dot(N,sunDir)//sundir must be normalized\n#ifdef doAO\n,shad=AO(so+N*.001,sunDir,s)//shadow\n#else\n,shad=.5\n#endif\n#ifdef doSpec\n;float v=dot(-d,N)\n;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n;float cd=exp(-distance(o,so))\n;vec3 R=reflect(d,N)\n;float spcl=pow(sat(dot(R,sunDir)),10.)\n,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n#endif\n;r=sat(r)\n;return r;}\n\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qmulv(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u\n){vec4 p,qrot\n ;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n }else{//next frame\n  ;p=load(0);qrot=load(1)//load state from previous frame\n  ;vec3 fw=vec3(0,0,1)\n  ;fw=qmulv(qrot,fw) //this can be done simpler\n  ;vec3 newp=p.xyz+fw*p.w*.2\n  ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n  ;else{\n   ;if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n   ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n   ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n  ;}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-iMouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 113]], "test": "untested"}
{"id": "3lyXDz", "name": "Step and smoothstep", "author": "luluco250", "description": "Testing both functions. Mouse X is the center point, Y is the smoothness.", "tags": ["2d", "test"], "likes": 6, "viewed": 1053, "published": 3, "date": "1582505515", "time_retrieved": "2024-07-30T21:22:16.009672", "image_code": "void mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec2 mouse = mix(vec2(0.5), iMouse.xy * ps, step(0.01, iMouse.z));\n    float center = mouse.x;\n    float start = center - mouse.y;\n    float end = center + mouse.y;\n    \n    color.r = (uv.y < 0.5)\n        ? mix(0.0, 1.0, step(center, uv.x))\n        : mix(0.0, 1.0, smoothstep(start, end, uv.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 457]], "test": "untested"}
{"id": "WlGSDR", "name": "Day 66", "author": "jeyko", "description": "code is messy. ", "tags": ["mdtmjvm"], "likes": 12, "viewed": 369, "published": 3, "date": "1582488129", "time_retrieved": "2024-07-30T21:22:16.963123", "image_code": "// code pretty messy\n// PBR from learnopengl.com\n// Inigo quilez volcanic(?) noise and shadows\n\n#define mx (2.*iMouse.x/iResolution.x)\n#define my (2.*iMouse.y/iResolution.x)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(p, x) mod(p,x) - 0.5*x\n#define dmin(a, b) a.x < b.x ? a : b\n#define T (iTime*1. + mx)\n\nvec3 glow = vec3(0);\nfloat tt = 0.;\nfloat planeOffs = 0.;\n\n#define modD 1.\n#define ballW 0.3\n#define pathFront 0.7\n#define curve smoothstep(0.,1., exp(-p.x)*0.3)\n#define curveB smoothstep(0.,1., exp(-tt)*0.3)\nvec3 ballP(float id){\n    vec3 p = vec3(0);\n    tt += 0.06;\n    p -= mix(\n        vec3(-tt,0,0), \n        vec3(\n            0. - sqrt(abs(tt*1.975))*1.4,\n            tt*(smoothstep(0.,1.,tt*0.9))*1.8,\n            0),\n        smoothstep(0.,1.,tt));\n    \n\n\treturn p;\n}\n// Noise (from iq)\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel2,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel2,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel2,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel2,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel2,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat noiseB (vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel2, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    \n\tvec3 u = p;\n    // balls\n    float id = floor(p.z/modD);\n    p.z = pmod(p.z,modD);\n    vec3 q = p;\n    q = p;\n    q.y -= curve;\n    q = abs(q);\n    \n    q.zy -= exp(-abs(p.x - 0.7)*20.)*0.1;\n    q.zy -= ballW*0.75;\n    \n    float path = length(q.zy) - 0.02;\n    \n    \n    path = max(path, p.x - pathFront);\n    \n    d = dmin(d, vec2(path, 1.));\n    \n    q = p;\n    \n    planeOffs = sin((u.z - T)*0.5 + 0.9)*0.1 + 0.1;\n    float planeOffsBall = sin((floor(u.z + 0.) - T )*0.5 + 0.9)*0.06 + 0.1;\n    u = p;\n    \n    vec3 n = p;\n    q.y -= planeOffs;\n    u.y -= planeOffs;\n    q.y += 0.33;\n    float dCatcher = q.y + 1.;\n    q.y += 1.;\n    q.x -= 1.7;\n    \n    q.z += 0.03;\n    dCatcher = max(dCatcher, - length(q) + ballW);\n    \n    float dcn = noise(u*20.);\n    dCatcher = max(dCatcher, q.x  - ballW*1.2);\n    dCatcher = max(dCatcher, -q.x - 0.7 + ballW*1.2);\n    \n    dCatcher += dcn*0.01;\n    d = dmin(d,vec2( dCatcher, 3.));\n    \n    tt = -id + T;\n    p.y -= curveB;\n    \n    \n    if(tt < +0.75){\n    \tp -= ballP(id);\t\n        //p.y += 0.06;\n    } else {\n        p.y += 1.36 - planeOffsBall;\n        p.x -= 1.7;\n        //p.z += 0.05;\n    }\n    \n    p -=  vec3(0.,-0.08,0.0);\n    d = dmin(d,vec2( length(p) - ballW*0.95, 2.));\n    \n        \n    d = dmin(d,vec2(\n        max(length(p) - ballW*1.,\n        length(p.xy) - 0.1)\n        , 1.));\n    \n    n = u;\n    n.y += 1.4;\n    n.x -= 1.7;\n    n = abs(n);\n    n.xz -= 0.36;\n    p = n;\n    \n    \n    \n    u.y += 1.33;\n    u.z -= modD*0.5;\n    //u.y -= 0.04;\n    \n    n = abs(n);\n    n.yz *= rot(-0.2*PI);\n    \n    d = dmin(d,vec2( length(n.xz) - ballW*0.02, 5.));\n    \n    d = dmin(d,vec2( max(length(p.xz) - ballW*0.02, u.y + 1.41), 5.));\n    \n    \n    p.y += (p.x)*0.001;\n    d = dmin(d,vec2( length(p.zy) - ballW*0.02, 5.));\n    \n    \n    d.x *= 0.5;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e5);\n\tt = 0.; hit = false; p = ro;\n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        glow += exp(-d.x*20.);\n        if (d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\nvec3 getRd(vec3 ro,vec3 lookAt,vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x + up*uv.y)*0.4);\n}\nvec3 getRdIso(inout vec3 ro,vec3 lookAt,vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro += (right*uv.x + up*uv.y)*3.;\n    ro.y += 0.2;\n    ro.x += 0.5;\n    //dir.yz *= rot(0.3);\n    //dir.xz *= rot(0.17);\n    return dir;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0., 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv,uv)*0.1;\n    \n    vec3 col = mix(\n        vec3(0.001,0.001,0.001),\n        vec3(0.001,0.01,0.01),\n        dot(uv,uv)*0.5\n    )*0.02;\n    \n    vec3 ro = vec3(0);\n    //ro.z -= 2. + sin(my)*20.;\n    ro.z += T - 5.;\n    ro.y += 1.2;\n    //ro.y += sin(iTime)*0.2 + 1.2;\n    ro.x += 5.;\n    \n    vec3 lookAt = ro + vec3(-2.,-0.8,2);\n    vec3 rd = getRd(ro, lookAt,uv);\n     rd = getRdIso(ro, lookAt,uv);\n    ro -= normalize(lookAt - ro)*0.19;\n    //rd.xz *= rot(sin(mx));\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n        vec3 albedo = vec3(1.);\n        \n        vec3 lightCol = vec3(1.2,1.1,1.1)*2.;\n\n        //vec3 L = normalize(l - p);\n        vec3 L= normalize(vec3(0.004,0.3,-0.4)); vec3 l = L;\n        \n        vec3 n = getNormal(p);\n        vec3 H = normalize(L - rd);\n\n\n        float metalness = 0.9;\n        float roughness = 0.4 ;\n        \n        \n            float f = fbm(p*2.);\n        if(d.y == 3.){\n            \n    \t\tn.xy += f*0.43;\n            n = normalize(n);\n            metalness = 0.9;\n\n            roughness = 0.5;\n            roughness += f*0.7;\n            \n        \talbedo = vec3(0.3,0. ,0.01)*0.4;\n        }\n        if(d.y == 1.){\n            metalness = 0.9;\n            roughness = 0.4 ;\n            albedo = vec3(0.99,0.9,0.2)*1.;\n        \n        }\n        if(d.y == 2.){\n            metalness = 0.5;\n            roughness = 0.4 + f *0.4 ;\n            albedo = vec3(0.,0.,0.);\n        \n        }\n        if(d.y == 5.){\n            metalness = 0.;\n            roughness = 0.4 + f *0.4 ;\n            albedo = vec3(2.);\n        \n        }\n        \n        vec3 F0 = vec3(0.03);\n        vec3 N = n;\n        vec3 V = normalize(ro - p);\n\n        F0 = mix(F0, albedo, metalness);\n\n        // calculate per-light radiance\n        float distL    = length(l - p)*1.;\n        float attenuation = 1. / (distL * distL);\n        \n        //attenuation = clamp(attenuation, 0., 1.);\n        attenuation = 1.;\n        vec3 radiance     = lightCol * attenuation;        \n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, roughness);   \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metalness;\t  \n\n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0); \n        \n        col = (kD * albedo / PI + specular) * radiance * NdotL * attenuation; \n        \n        col *=  calcSoftshadow( p,l, 0.04, 10., 0 );\n        \n    }\n    \n    \n    col *= 1. - dot(uv*0.5,uv*0.5)*4.;\n    col *= 1.5;\n    \n    col = mix(col, smoothstep(0.,1., col), 0.4);\n    col.r *= 1.;\n    col.b *= 1.0;\n    col = pow(col, vec3(0.45));\n    \n    //col += glow*0.01;\n    \n    \n    fragColor = vec4(col,t);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define MIPLVL 1.\n\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define R iResolution.xy\n\nvec4 gaussian(sampler2D chan, vec2 uv, vec2 iResolution, float mip){\n    float st = 4.;\n    vec3 t = vec3(st, 0., -st);\n    vec4 C = vec4(0);\n\t#define TC(uv) texture(chan, (uv)/R, mip) \n    // don't do defines like this lol\n    C += 4.*TC(uv);\n    C += 2.*TC(uv - t.xy) + 2.*TC(uv + t.xy) + 2.*TC(uv - t.yx) + 2.*TC(uv - t.yx);\n    C += 1.*TC(uv - t.xx) + 1.*TC(uv + t.xx) + 2.*TC(uv - t.xz) + 2.*TC(uv - t.xz);\n\n    return C / 16.;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat random(vec2 u){\n\treturn fract(sin(u.y*4125.1 + u.x *125.625)*225.5235);\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.125 + u.z*525.5215)*115.125235);\n} \nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec3 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 6; i++) {\n\t\ts += a * valueNoise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 554, 554, 799], [800, 819, 845, 845, 1400], [1402, 1402, 1425, 1425, 1626], [1629, 1629, 1646, 1646, 3493], [3495, 3495, 3569, 3569, 3842], [3844, 3844, 3867, 3867, 3999], [4001, 4001, 4041, 4041, 4235], [4236, 4236, 4285, 4285, 4563], [4565, 4565, 4658, 4658, 5475], [5477, 5477, 5534, 5534, 8654]], "test": "untested"}
{"id": "tlKXzm", "name": "my first raymarched scene", "author": "maksy", "description": "My first raymarched scene", "tags": ["raymarching"], "likes": 2, "viewed": 365, "published": 3, "date": "1582485268", "time_retrieved": "2024-07-30T21:22:17.819833", "image_code": "struct Obj {\n\tint type;\n    float d;\n};\n\nstruct Ray {\n\tObj hitObj;\n    vec3 hitPos;\n    // travelled distance along the ray\n    float t;\n};\n    \nfloat sdSphere(vec3 p, float r) {\n\treturn length(p)-r;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y + 1.95;\n}\n\nObj SDF(vec3 pos) {\n\n    float d0 = sdPlane(pos);\n    float d1 = sdSphere(pos-vec3(1, .2, 1), 2.2);\n\n    Obj obj = Obj(1, d1);\n\n    if (d0 < d1) {\n      obj = Obj(0, d0);\n    }\n\n    return obj;\n  }\n\n// Raymarching loop\nRay castRay(vec3 rayOrigin, vec3 rayDir) {\n\n    float tmax = 180.0;\n    float t = 0.0;\n\n    Obj hitObj = Obj(-1, t);\n    vec3 hitPos = vec3(0);\n\n    for (int i = 0; i < 500; i++) {\n\n      vec3 p = rayOrigin + t*rayDir;\n      Obj res = SDF(p);\n\n      if (res.d < 0.01) {\n        hitObj = res;\n        hitPos = p;\n        break;\n      } else if (res.d > tmax) {\n        break;\n      }\n      t += res.d;\n    }\n\n\treturn Ray(hitObj, hitPos, t);\n}\n\nvec3 calcNormal(vec3 pos) {\n\n\t// Center sample\n    float c = SDF(pos).d;\n\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.01, 0.0);\n    return normalize(vec3(SDF(pos + eps_zero.xyy).d, SDF(pos + eps_zero.yxy).d,\n                          SDF(pos + eps_zero.yyx).d) - c);\n}\n\n// Calculates Lambertian reflection\nvec3 calculateLightning(vec3 pos, vec3 lightDir, vec3 surfaceColor) {\n\n\t// L is vector from surface point to light, N is surface normal. N and L must be normalized!\n    vec3 L = normalize(lightDir);\n\n    vec3 N = calcNormal(pos);\n\n    float NoL = max(dot(N, L), 0.0);\n    vec3 directional = vec3(1.80,1.27,0.99) * NoL;\n\n    vec3 diffuse = surfaceColor * directional;\n\n    return diffuse;\n}\n\n// Analytically box-filtered checkerboard by iq\nfloat checkersTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {\n\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n\n    // xor pattern\n\treturn 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 texCoords(in vec3 pos) {\n\n    const vec4 sc0 = vec4(1.0, 1.3, 1.0, 0.5);\n    vec3 q = normalize(pos - sc0.xyz);\n    vec2 matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n\n    return 12.0*matuv;\n}\n\nvec3 floorColor(in vec3 p) {\n   \n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n    return f * vec3(.8)+0.03;\n}\n\nvec3 fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering) {\n\t\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0.001, 0.001, 0.001), vec3(0.6, 0.6, 0.6), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\n// Value noise from the Art of Code\nfloat generateNoise(vec2 p) {\n\treturn fract(sin(p.x*100.+p.y*6574.)*5647. );\n}\n\nfloat smoothNoise(vec2 uv) {\n \n    vec2 lv = fract(uv*1.0);\n    vec2 id = floor(uv*1.0);\n\n    lv = lv*lv*(3.-2.*lv);\n\n    float bl = generateNoise(id);\n    float br = generateNoise(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = generateNoise(id + vec2(0,1));\n    float tr = generateNoise(id + vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nfloat turbulence(vec2 uv) {\n\n    float c = smoothNoise(uv*4.0);\n    c += smoothNoise(uv*8.0) * 0.5;\n    c += smoothNoise(uv*16.0) * 0.25;\n    c += smoothNoise(uv*32.0) * 0.125;\n    c += smoothNoise(uv*65.0) * 0.0625;\n\n    return c / 5.0;\n}\n\nvec3 render(in vec3 camPos, in vec3 rayDir, out bool rayHitObj, in vec2 uv, in mat3 camMat) {\n\n    vec3 col;\n\n    vec3 lightDir = vec3(0.8, 0.4, -0.5);\n    vec3 sunDir = camMat * lightDir;\n\t    \n    rayHitObj = false;\n \n    Ray ray = castRay(camPos, rayDir);\n \n    // no objects were hit by the ray -> skydome\n    if (ray.hitObj.type == -1) {\n\n        //Sun\n        vec3 sun1 = vec3(1, 0.0, 0.0);\n        vec3 sun2 = vec3(0.268, 0.243, 0.007);\n\n        float sun_weight = smoothstep(0.0, .9, sin(uv.y)*1.1);\n        vec3 sunCol = mix(sun1, sun2, sun_weight);\n\n        // the sun is rendered only if the light is coming from the visible sky\n        if (sunDir.z > 0.0) {\n\n          \tif ((uv.x - sunDir.x*2.2) * (uv.x - sunDir.x*2.2) +\n                (uv.y - sunDir.y+0.2) * (uv.y - sunDir.y+0.2) <= 0.1) {\n\n            \tsunCol *= turbulence(uv)*1.9;\n            \treturn sunCol;\n        \t}\n       \t}\n\n\t\tvec3 sky_col = vec3(rayDir.y*0.5+0.01);\n\t\tcol = vec3(rayDir.y*0.5+0.01);\n       \t// add clouds\n       \tcol *= turbulence(uv);\n       \treturn col;\n    }\n\n    // ray hit the floor plane\n    else if (ray.hitObj.type == 0) {\n    \tcol = floorColor(ray.hitPos);\n\n    \t//vec3 lightDir = vec3(0.8, 0.4, -.5);\n    \tcol = calculateLightning(ray.hitPos, lightDir, col)*0.3;\n\n    \t// Add shadows\n    \tfloat shadow = 0.0;\n    \tvec3 L = normalize(lightDir);\n    \tvec3 N = calcNormal(ray.hitPos);\n    \tvec3 shadowRayOrigin = ray.hitPos + N * 0.01;\n    \tvec3 shadowRayDir = L;\n\n    \tRay shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n    \tif (shadowRayIntersection.hitObj.type == 1) {\n            col *= 0.01;\n        } else {\n        \n      \t// Add fog for floor attenuation\n      \tfloat fogExtintion = 0.035;\n     \tfloat fogInscattering = .1;\n        lightDir *= 0.8;\n      \tcol = fog(col, ray.t, rayDir, lightDir, fogExtintion, fogInscattering);\n        }\n    }\n\n    // sphere\n    else if (ray.hitObj.type == 1) {\n\n      vec2 uvw = texCoords(ray.hitPos) - uv;\n\n      vec2 ddx_uv = dFdx( uvw );\n      vec2 ddy_uv = dFdy( uvw );\n      col = vec3(checkersTextureGradBox(uvw, ddx_uv, ddy_uv));\n\n      // apply anti alias only to the sphere \n      rayHitObj = true;\n\n      // add lightning\n      vec3 surfaceCol = vec3(0.6, 0.0, 0.0);\n      vec3 lightDir = vec3(0.8, 0.4, -1.0);\n      col += calculateLightning(ray.hitPos, lightDir, surfaceCol);\n\n      // add small amount of light to the backside of the sphere\n      col += surfaceCol*0.4;\n    }\n\n     return col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec3 camPos = vec3(30.0*sin(iTime*0.5), 2.0, 30.0*cos(iTime*0.5));\n    vec3 camTar = vec3(-0.2, 2.0, -0.2);\n\n    mat3 camMat = lookAt(camPos, camTar, 0.0);\n\n    vec3 col = vec3(0.0);\n    \n    // MSAA anti aliasing\n    bool msaa = true;\n\n    bool rayHitObj = false;\n    if (msaa) {\n    \tconst float AA_size = 2.0;\n    \tfloat count = 0.0;\n      \tfor (float aaY = 0.0; aaY < AA_size; aaY++) {\n        \tfor (float aaX = 0.0; aaX < AA_size; aaX++) {\n\n\t\t\t\tvec2 offset = ((fragCoord.xy + vec2(aaX, aaY) / AA_size) - iResolution.xy*0.5)/iResolution.y;\n          \t\tvec3 rayDir = normalize(camMat * vec3(offset.xy, 2.0));\n\n          \t\tcol += render(camPos, rayDir, rayHitObj, offset, camMat);\n\n          \t\t\n          \t\tcount += 1.0;\n          \t\tif (!rayHitObj) {\n            \t\tbreak;\n          \t\t}\n        \t}\n      \t}\n      col /= count;\n   \n    } else {\n\t\tbool rayHitObj = false;\n    \tvec3 rayDir = normalize(camMat * vec3(uv.xy, 2.0));\n    \tcol = render(camPos, rayDir, rayHitObj, uv, camMat);\n    }\n    \n    // gamma\n\tcol = pow(col,vec3(.454545));\n\tfragColor = vec4(col, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 178, 178, 201], [203, 203, 226, 226, 248], [250, 250, 269, 269, 447], [449, 469, 511, 511, 910], [912, 912, 939, 958, 1218], [1220, 1256, 1325, 1420, 1645], [1647, 1695, 1762, 1784, 2001], [2003, 2003, 2032, 2032, 2203], [2205, 2205, 2233, 2233, 2330], [2332, 2332, 2426, 2426, 2665], [2667, 2703, 2732, 2732, 2781], [2783, 2783, 2811, 2811, 3170], [3172, 3172, 3199, 3199, 3411], [3413, 3413, 3506, 3506, 5880], [5882, 5882, 5933, 5933, 6137], [6139, 6139, 6194, 6194, 7334]], "test": "untested"}
{"id": "3tGSDR", "name": "Glow kifs tunnel", "author": "rodgzilla", "description": "Ray marching tunnel kifs", "tags": ["raymarching", "tunnel", "kifs"], "likes": 6, "viewed": 395, "published": 3, "date": "1582480002", "time_retrieved": "2024-07-30T21:22:18.581795", "image_code": "#define time .5 * iTime\n#define ZPOS -50. + 300. * (floor(time * .5) + smoothstep(.0, .1, fract(time * .5)))\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nvec3 kifs(vec3 p, float s, float r, float it, float tmin, float tmax, float shift) {\n    float t = shift + floor(time * .5) + smoothstep(tmin, tmax, fract(time * .5));\n    \n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .7);\n        p.yz *= rot2d(t * .8 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n\n\treturn p;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    float basez = p.z / 50.;\n    p.xy *= rot2d(p.z / 30.);\n    p = rep(p, vec3(40.));\n\tp = kifs(p, 3., .7, 3., .8, 1., basez);\n\tp = kifs(p, 3., .7, 2., .6, .8, basez);\n    float d = 1000.;\n  \tfloat obj = 3000.;\n    vec3 base = vec3(1, 0, 0);\n    float ttube = floor(time * .5) + smoothstep(.2, .4, fract(time * .5));\n    float tshift = floor(time * .5) + smoothstep(.4, .6, fract(time * .5));\n    float ntube = 6. + 3. * sin(ttube);\n    for (float i = 0.; i < ntube; i++) {\n        float angle = i * 2. * PI / ntube;\n        vec3 shift = vec3(1., 0, 0);\n        shift.xy *= rot2d(tshift * PI);\n        vec3 a = vec3(0) + shift;\n        vec3 b = vec3(2. * cos(angle), 2. * sin(angle), 0);\n        obj = min(obj, tube(p, a, b, .3));\n    }\n    d = min(d, obj);\n    \n    \n    at += .1 / (.1 + d);\n  \n    return d;\n}\n\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .02 * at * vec3(0, 1., 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(0, 0, ZPOS);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n\n//    float dif = light(p);\n//  \tvec3 col = vec3(dif);\n    \n \tvec3 col = .2 * glow;\n   \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 154, 154, 219], [221, 221, 249, 249, 275], [277, 277, 322, 322, 479], [481, 481, 507, 507, 555], [557, 557, 641, 641, 905], [922, 922, 941, 941, 1753], [1783, 1783, 1811, 1811, 2055], [2057, 2057, 2078, 2078, 2225], [2227, 2227, 2248, 2248, 2474], [2477, 2477, 2534, 2534, 2918]], "test": "untested"}
{"id": "WtGSWR", "name": "RefractionTest_honorfil", "author": "Honorfil", "description": "fun with raymarching + reflections/refractions", "tags": ["refractionreflectioncubemapraymarch"], "likes": 11, "viewed": 433, "published": 3, "date": "1582477138", "time_retrieved": "2024-07-30T21:22:19.573145", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n#define baseColor vec3(0.6, 0.9, 0.9)\n\nmat2 GetRot(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p)\n{\n    float disturbance = (sin(iTime * 2.) * .5 + .5) * .1 + .05;\n    float pOffset = noise(p * 2.5 + iTime) * disturbance;\n\n    p += pOffset;\n    return (length(p) - 1.) * (1. - 0.35);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, .0);\n    \n    vec3 n = d - vec3(\n    \tGetDist(p - e.xyy),\n    \tGetDist(p - e.yxy),\n    \tGetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = abs(GetDist(p));\n        d0 += ds;\n        \n        if (d0 > MAX_DIST)\n        {\n            return -1.;\n        }\n        \n        if (ds < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return min(d0, MAX_DIST);\n}\n\nvec3 decodeGamma(vec3 value)\n{\n    vec3 result;\n    result.x = sqrt(value.x);\n    result.y = sqrt(value.y);\n    result.z = sqrt(value.z);\n    \n    return result;\n}\n\nvec3 encodeGamma(vec3 value)\n{\n    vec3 result;\n    result.x = value.x * value.x;\n    result.y = value.y * value.y;\n    result.z = value.z * value.z;\n    \n    return result;\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec3 p)\n{   \n    vec3 lightPos = ro + rd * 3.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n, l)*.5+.5, 0., 1.) * .9;\n\n    vec3 refractedVec = refract(rd, n, .2);\n    vec3 reflectedVec = reflect(rd, n);\n    \n    vec3 refractedCol = decodeGamma(texture(iChannel0, refractedVec).rgb);\n    \n    reflectedVec.y *= -1.;\n    vec3 reflectedCol = decodeGamma(texture(iChannel0, reflectedVec).rgb);\n    \n    float nDotV = 1. - clamp01(dot(n, -rd));\n    nDotV = pow(nDotV, 2.4) * .4;\n    \n    return baseColor * diff + refractedCol * .2 + reflectedCol * .4 + nDotV;\n}\n\nvec3 SetupCamera(vec2 uv, vec3 camPos, vec3 lookAt)\n{\n    const float zoom = 0.77;\n    \n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = cross(vec3(0., 1., 0.), forward);\n    vec3 up = cross(forward, right);\n    \n    vec3 center = camPos + forward * zoom;\n    vec3 intersectionPoint = center + uv.x * right + uv.y * up;\n    \n    return normalize(intersectionPoint - camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(cos(iTime* .1) , sin(iTime* .1), sin(iTime* .1)) * 2.;  \n    vec3 rd = SetupCamera(uv, ro, vec3(0., 0., 0.));\n\n    float d = RayMarch(ro, rd);\n    if (d < 0.)\n    {\n        float l = 1.3 - length(uv);\n        col = decodeGamma(texture(iChannel0, rd).rgb) * l;\n    }\n    else\n    {\n        vec3 p = ro + rd * d;\n    \tcol = Render(ro, rd, p);\n    }\n    \n\n    fragColor = vec4(encodeGamma(col),1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define clamp01(x) clamp(x, 0.0, 1.0)\n\n\nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 133, 133, 222], [224, 224, 247, 247, 433], [435, 435, 459, 459, 650], [652, 652, 686, 686, 1035], [1037, 1037, 1067, 1067, 1200], [1202, 1202, 1232, 1232, 1377], [1379, 1379, 1418, 1418, 2019], [2021, 2021, 2074, 2074, 2412], [2414, 2414, 2471, 2471, 2980]], "test": "untested"}
{"id": "3tGSWR", "name": "G is for goals", "author": "indigoabstract", "description": "G is for goals(not Google :))", "tags": ["glow", "neon", "goals", "gtd"], "likes": 26, "viewed": 1543, "published": 3, "date": "1582473334", "time_retrieved": "2024-07-30T21:22:20.343086", "image_code": "// adapted from the beautiful shader \"NEON LOVE\" by alro\n// https://www.shadertoy.com/view/WdK3Dz\n#ifdef GL_ES\n\tprecision highp float;\n#endif\n\nconst int i1_point_count = 50;\nvec2 v2_points[i1_point_count];\n\nconst float v1_folded_duration_secs = 2.0;\nconst float v1_unfolding_duration_secs = 4.5;\nconst float v1_unfolding_start_secs = v1_folded_duration_secs;\nconst float v1_blink_duration_secs = 0.7;\nconst float v1_blink_start_secs = v1_unfolding_start_secs + v1_unfolding_duration_secs;\nconst float v1_unfolded_duration_secs = 4.5;\nconst float v1_unfolded_start_secs = v1_blink_start_secs + v1_blink_duration_secs;\nconst float v1_folding_duration_secs = v1_unfolding_duration_secs;\nconst float v1_folding_start_secs = v1_unfolded_start_secs + v1_unfolded_duration_secs;\nconst float v1_cycle_duration_secs = v1_folding_start_secs + v1_folding_duration_secs;\n\nconst float v1_pi_rad = 3.14159265;\nconst float v1_two_pi_rad = 6.28318531;\nconst float v1_cirle_start_offset_rad = v1_pi_rad / 4.;\nconst float v1_circle_scale = 16.0;\nconst float v1_seg_length = 0.1455;\nconst float v1_scale = 0.012;\n\n\n// https://www.shadertoy.com/view/MlKcDD\n// Signed distance to a quadratic bezier\nfloat sd_bezier(vec2 v2_pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - v2_pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0)\n\t{ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n\telse\n\t{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nvec2 get_obj_pos(float i_v1_pos, float i_curve_length)\n{\n\tif(i_curve_length > v1_two_pi_rad - v1_cirle_start_offset_rad)\n\t{\n\t\treturn -v1_circle_scale * vec2(cos(i_v1_pos), 0.);\n\t}\n\t\n    return -v1_circle_scale * vec2(cos(i_v1_pos), sin(i_v1_pos));\n}\n\nfloat get_segment(int i1_crt_point_count, float i_v1_mixf, vec2 v2_pos, float i_v1_offset)\n{\n\tfor(int i = 0; i < i1_crt_point_count; i++)\n\t{\n\t\tfloat v1_curve_length = float(i) * v1_seg_length;\n\t\tfloat v1_pos = i_v1_offset + v1_curve_length;\n        v2_points[i] = get_obj_pos(v1_pos, v1_curve_length);\n    }\n    \n    vec2 c = (v2_points[0] + v2_points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n\tfloat prev_dist = dist;\n    \n    for(int i = 0; i < i1_crt_point_count - 1; i++)\n\t{\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n\t\tprev_dist = dist;\n        c = (v2_points[i] + v2_points[i + 1]) / 2.;\n        dist = min(dist, sd_bezier(v2_pos, v1_scale * c_prev, v1_scale * v2_points[i], v1_scale * c));\n    }\n\t\n\tif(i1_crt_point_count > 1)\n\t{\n        c = mix(v2_points[i1_crt_point_count - 2], v2_points[i1_crt_point_count - 1], i_v1_mixf);\n        dist = min(prev_dist, sd_bezier(v2_pos, v1_scale * c_prev, v1_scale * v2_points[i1_crt_point_count - 2], v1_scale * c));\n\t}\n\t\n    return max(0.0, dist);\n}\n\nvec3 get_color(int i1_crt_point_count, float i_v1_mixf, vec2 i_v2_pos)\n{\n\tfloat dist = get_segment(i1_crt_point_count, i_v1_mixf, i_v2_pos, v1_cirle_start_offset_rad);\n\tfloat intensity = 0.9;\n\tfloat radius = 0.025;\n\t// https://www.shadertoy.com/view/3s3GDn\n\tfloat v1_glow = pow(radius / dist, intensity);\n\t//float v1_glow_2 = pow(0.004525 / dist, 1.9);\n\tvec3 v3_color = vec3(0.0);\n\t// white core\n\tv3_color += 10.0 * vec3(smoothstep(0.006, 0.003, dist * 7.));\n\t// glow\n\tv3_color += v1_glow * vec3(0.05, 0.35, 1.0);\n\t//v3_color += v1_glow_2 * vec3(0.05, 0.135, 1.0);\n\t\t\n\t// tone mapping\n\tv3_color = 1.0 - exp(-v3_color);\n\t\n\treturn v3_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 v2_uv = fragCoord/iResolution.xy;\n    float v1_aspect_ratio = iResolution.x/iResolution.y;\n    vec2 v2_origin = vec2(0.5);\n    vec2 v2_pos = v2_origin - v2_uv;\n    v2_pos.y /= v1_aspect_ratio;\n    float v1_time_secs = mod(iTime, v1_cycle_duration_secs);\n\tvec3 v3_color = vec3(0.0);\n    \n\t//v3_color = get_color(i1_point_count, 0.5, v2_pos); if(false)\n\tif(true)\n\t{\n\t\t// folded phase\n\t\tif(v1_time_secs < v1_unfolding_start_secs)\n\t\t{\n\t\t}\n\t\t// unfolding phase\n\t\telse if(v1_time_secs < v1_blink_start_secs)\n\t\t{\n\t\t\tfloat v1_t = v1_time_secs - v1_folded_duration_secs;\n\t\t\tfloat v1_pc = (float(i1_point_count) * v1_t) / v1_unfolding_duration_secs;\n\t\t\tfloat v1_mixf = fract(v1_pc);\n\t\t\tint i1_crt_point_count = int(min(floor(v1_pc), float(i1_point_count)));\n\t\t\t\n\t\t\tv3_color = get_color(i1_crt_point_count, v1_mixf, v2_pos);\n\t\t}\n\t\t// blink phase\n\t\telse if(v1_time_secs < v1_unfolded_start_secs)\n\t\t{\n\t\t\tfloat v1_delta = v1_time_secs - v1_blink_start_secs;\n\t\t\t\n\t\t\tif(v1_delta < 2.0 * v1_blink_duration_secs / 4.0)\n\t\t\t{\n\t\t\t\tv3_color = get_color(i1_point_count, 0.5, v2_pos);\n\t\t\t}\n\t\t\telse if(v1_delta < 2.5 * v1_blink_duration_secs / 4.0)\n\t\t\t{\n\t\t\t}\n\t\t\telse if(v1_delta < 3.5 * v1_blink_duration_secs / 4.0)\n\t\t\t{\n\t\t\t\tv3_color = get_color(i1_point_count, 0.5, v2_pos);\n\t\t\t}\n\t\t}\n\t\t// unfolded phase\n\t\telse if(v1_time_secs < v1_folding_start_secs)\n\t\t{\n\t\t\tv3_color = get_color(i1_point_count, 0.5, v2_pos);\n\t\t}\n\t\t// folding phase\n\t\telse if(v1_time_secs < v1_cycle_duration_secs)\n\t\t{\n\t\t\tfloat v1_t = v1_cycle_duration_secs - v1_time_secs;\n\t\t\tfloat v1_pc = (float(i1_point_count) * v1_t) / v1_folding_duration_secs;\n\t\t\tfloat v1_mixf = fract(v1_pc);\n\t\t\tint i1_crt_point_count = int(min(floor(v1_pc), float(i1_point_count)));\n\t\t\t\n\t\t\tv3_color = get_color(i1_crt_point_count, v1_mixf, v2_pos);\n\t\t}\n\t}\n\n    fragColor = vec4(v3_color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1096, 1178, 1232, 1232, 2517], [2519, 2519, 2575, 2575, 2768], [2770, 2770, 2862, 2862, 3791], [3793, 3793, 3865, 3865, 4433]], "test": "untested"}
{"id": "wtVSzm", "name": "Imminent Doom (SS8)", "author": "angelo12", "description": "IMO the asteroid is the good guy in Armageddon.", "tags": ["sdf", "shadersundays"], "likes": 20, "viewed": 765, "published": 3, "date": "1582468013", "time_retrieved": "2024-07-30T21:22:21.108041", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 20.0\n#define MIN_DIST 0.001\n#define AA 2\n\n/*\n\tShader Sundays! (8/52) \n\t\"Imminent Doom\"\n\t\n\tThis week I picked up an old shader I never published on shadertoy and polished it a bit.\n\tReally like how the soft shadow spreads slowly over the surface giving it a very spooky\n\tfeel. The noisy surface kinda works nicely for the moon/asteroid surface I was going for\n\tbut there are definitely some things that could be improved.\n\t\n\t- The end transition is too harsh.\n\t- The ambient blue light doesn't quite work.\t\n\t- The stars lack variance. (Rotating stars coulda worked?)\n\t- The sphere lacks some details & contrast.\n\t- Distinct lack of Aerosmith soundtrack\n*/\n\nfloat\nhash(vec2 n){\n    return fract(sin(dot(n,vec2(12.9898, 4.1414)))*43758.5453);\n}\n\nfloat _doom = 0.0;\n\nfloat\nSmoothNoise(vec2 uv){\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n\n    lv = lv*lv*(3.0 - 2.0*lv);\n    float bl = hash(id);\n    float br = hash(id + vec2(1.0, 0.0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = hash(id + vec2(0.0, 1.0));\n    float tr = hash(id + vec2(1.0, 1.0));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nfloat\nValueNoise(vec2 uv, int octaves){\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float noise = 0.0;\n    float totalAmp = 0.0;\n\n    for(int i = 0; i < octaves; ++i){\n        noise += SmoothNoise(uv * frequency) * amplitude;\n        totalAmp += amplitude;\n        amplitude /= 2.0;\n        frequency *= 2.0;\n    }\n\n    return noise / totalAmp ;\n}\n\nfloat\nsdTerrain(vec3 pos){\n    return pos.y - ValueNoise(pos.xz, 8);\n}\n\nvec2\nMap(vec3 pos){\n    vec2 res = vec2(1e10, -1.0);\n\n    res = uop(res, vec2(sdTerrain(pos), 1.0));\n    res = uop(res, vec2(sdSphere(pos - vec3(0.0, 5.0, 0.0), 3.5 * (1.0 - _doom) + 0.7), 0.0));\n\n    return res;\n}\n\nvec2\nRayMarch(vec3 ro, vec3 rd){\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i){\n        vec2 hit = Map(ro + t*rd);\n\n        if(hit.x < MIN_DIST){\n            res = vec2(t, hit.y);\n            break;\n        }\n\n        t += hit.x;\n    }\n\n\n    return res;\n}\n\nvec3 \nCalcNormals(vec3 p){\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x\n    ));\n}\n\nfloat\nCalcSoftShadows(vec3 ro, vec3 rd){\n    float k = 4.0;\n    float n = 1.0;\n    for(float t = 0.02; t < MAX_DIST;){\n        float h = Map(ro + t*rd).x;\n        \n        if(h < MIN_DIST){\n            return 0.0;\n        }\n        n = min(n, h*k/t);\n        t += h;\n    }\n\n    return n;\n}\n\nvec3\nRender(vec3 ro, vec3 rd, vec2 uv){\n    vec2 res = RayMarch(ro, rd);\n    float t = res.x;\n    float id = res.y;\n\n    //Sky\n    vec3 col = vec3(0.0);\n    col += vec3(1.0) * pow(hash(uv * vec2(13.0, 2.2)), 703.58);\n    col *= 100.0* (_doom*_doom*_doom);\n\n    if(id >= 0.0){\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormals(P);\n\n        //Material\n        float fresnel = 0.0;\n        vec3 planetCol = vec3(0.1, 0.3, 0.7);\n        if (id == 0.0){\n            col = planetCol;\n            fresnel = 0.04 + (1.0 - 0.04)*pow(1.0 - dot(N,-rd), 5.0);\n        }\n        else{\n            col = vec3(1.0)*N.y;\n            fresnel = 0.0;\n        }\n\n        //Lighting\n        vec3 L = normalize(vec3(0.0, _doom, 1.2));\n        vec3 lin = vec3(0.0);\n        float dif = clamp(dot(N, L), 0.0, 1.0);\n\n        //Shadowing\n        dif *= CalcSoftShadows(P, L);\n\n        //Shading\n        lin += 1.0 * dif * vec3(1.1, 0.9, 0.78);\n        lin += (0.8 - _doom*_doom)* 20.0 * fresnel * vec3(1.0)* 0.01;\n        lin += (0.8 - _doom)* 0.01 * planetCol;\n        col *= lin *(pow(_doom, 0.7));\n    }\n\n    return saturate(col);\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos){\n    float time  = mod(iTime, 45.45);\n    _doom = (sin(time/ 16.0 - 1.4 *M_PI) + 1.0)/ 2.0 ;\n    vec3 tot = vec3(0.0);\n    //Camera setup\n    float near = 1.0;\n    float roll = 0.0;\n    vec3 ro = vec3(0.0, 2.0, -20.0);\n    vec3 tar = vec3(0.0);\n    mat3 cam = SetCamera(ro, tar, roll);\n#if AA > 1\n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j){\n        vec2 offset = vec2(float(i), float(j))/ float(AA) - 0.5;\n        vec2 uv = ((fragPos+offset) - 0.5*iResolution.xy)/ iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy)/ iResolution.y;\n#endif\n\n        vec3 rd = cam * normalize(vec3(uv, near));\n\n        vec3 col = Render(ro, rd, uv);\n\n        col = pow(col, vec3(INV_GAMMA));\n\n        tot += col;\n    #if AA > 1\n    }\n    tot /= float(AA * AA);\n    #endif\n    \n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(vol) clamp(col, 0.0, 1.0)\n#endif\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 695, 714, 714, 780], [802, 802, 829, 829, 1160], [1162, 1162, 1201, 1201, 1523], [1525, 1525, 1551, 1551, 1595], [1597, 1597, 1616, 1616, 1811], [1813, 1813, 1845, 1845, 2130], [2132, 2132, 2158, 2158, 2387], [2389, 2389, 2429, 2429, 2678], [2680, 2680, 2719, 2719, 3815]], "test": "untested"}
{"id": "wtGXRw", "name": "ShaderDojo 045", "author": "antonOTI", "description": "Reproduction of \nhttps://twitter.com/antonkudin/status/1231193061738328069", "tags": ["raymarch", "remix", "reproduction"], "likes": 10, "viewed": 476, "published": 3, "date": "1582461109", "time_retrieved": "2024-07-30T21:22:22.118339", "image_code": "// ShaderDojo045 By Anton\n// cc by\n\n// source inspiration : twitter.com/antonkudin/status/1231193061738328069\n// by @antonkudin\n\n// ------------------------------------------------------- //\n// Sea distance function taken from Seascape shader by TDM\n// shadertoy.com/view/Ms2SD1\n// sea\nconst int ITER_GEOMETRY = 5;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 3.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\n#define SEA_TIME (1.25 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    \n    // Faking an horizon.\n    p.y += pow(length(p.xz) * .05, 2.);\n    \n    return p.y - h;\n}\n\n// ---------------- End of Seascape part ----------------- //\n// ------------------------------------------------------- //\n\nvec3 normal(vec3 p)\n{\n    // Intentionally skewing the normals so the sea reflection appear smoother than the sea.\n    vec2 e = vec2(1.2,.0);\n    return normalize(vec3(\n    \tmap(p + e.xyy) - map(p - e.xyy),\n    \tmap(p + e.yxy) - map(p - e.yxy),\n    \tmap(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid ray(inout vec3 cp,in vec3 rd,out float st,out float cd,out float d)\n{\n    for(st = 0.; st < 1.; st += 1. / 256.)\n    {\n        cd = map(cp);\n        if(abs(cd) < .01 || cd > 10.)\n        {\n           break;\n        }\n        \n        d += cd;\n        cp += rd * cd ;\n    }\n}\n\nvec3 lookAt(vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 fd = normalize(ta - ro);\n    vec3 up = cross(fd, vec3(1.,0.,0.));\n   \tvec3 ri = cross(fd, up);\n    \n   return normalize(fd - ri * uv.x + up * uv.y); \n}\n\nvec3 blueSky = vec3(.0001, .00002, .005) ;\nvec3 sunCol = vec3(.006,.002,.2);\nvec3 darkBlue = vec3(.00005,.00001,.00015);\nvec3 riseUp = vec3(.15,.12,.3);\nvec3 starCol = vec3(.15,.025,.5) * 1.5;\nvec3 seaCol = vec3(.004,.012,.032);\n\nvec3 sunDir = normalize(vec3(0.,.4,1.));\nfloat sunRadius = .01;\n\nfloat rotSpeed = .0002;\nfloat starWidth = .005; // overriden at the start of mainImage.\n\nvec3 skyCol(vec3 rd)\n{\n    float sky = dot(rd, sunDir);\n    \n    vec3 up = cross(-sunDir, vec3(0.,1.,0.));\n    vec3 ri = cross(up, -sunDir);\n    vec2 dp = vec2(dot(rd, ri), dot(rd,up));\n    \n    float sunRim = sky - 1. + sunRadius;\n    float circle = 1. - smoothstep(.0005,.0014, abs(sunRim));\n    \n    float innerFactor = smoothstep(sky-1.01,sky-1., -sunRadius);\n    vec3 col = sunCol * pow(sky, 16.) * innerFactor;\n    circle *= circle;\n    sky = pow(sky, 19.);\n    sky = clamp(sky *2.2, 0.,1.);\n    col = mix(col, blueSky, 1. - sky);\n    float t = -.4;\n    float d = .5;\n    col = mix(riseUp, col, smoothstep(t, t + d, rd.y));\n    \n    col += circle + pow(1. - abs(sunRim), 512.) * innerFactor;\n    \n    return col;\n}\n\nvec3 skyStars(vec3 rd)\n{\n    \n    float sky = dot(rd, sunDir);\n    \n    \n    vec3 up = cross(-sunDir, vec3(0.,1.,0.));\n    vec3 ri = cross(up, -sunDir);\n    vec2 dp = vec2(dot(rd, ri), dot(rd,up));\n    float a = atan(-dp.y, dp.x) / TAU + .5;\n\n\tfloat starSpace = length(vec2(dot(up,rd),dot(ri,rd)));\n    float starId = floor(starSpace / starWidth);\n   \tfloat starY = abs(mod(starSpace, starWidth)/starWidth - .5) * 2.;\n    float hashedId = hash11(starId);\n    a = fract(a + hashedId * 100. + (iTime * starId * (1. + hashedId * .2)) * -rotSpeed);\n    float star = length(vec2((max(a- .5,.0)) / starWidth, starY));\n    star = (1.-smoothstep(.0,2.,star)) * smoothstep(.05,.25,a) * (hashedId * .2 + .8);\n    \n    float circle = 1. - step(.0025,abs(sky - 1. + sunRadius));\n    \n    circle *= circle;\n    star *= max(step(sky -1., -sunRadius) - circle, 0.);\n    \n    return starCol * pow(star, 8.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\tvec3 col = vec3(0.);\n    \n    float len = length(uv - vec2(0.,.2));\n    float a = (atan(uv.y, uv.x) + PI) / TAU;\n    \n    \n    starWidth = 2.5 / iResolution.y;\n    float bobAmp = .5;\n    float bobTime = iTime * .125;\n    vec3 cp = vec3(0. + cos(bobTime) * bobAmp,2. + sin(bobTime * 2.) * bobAmp,-8. + sin(bobTime * .33));\n    vec3 ta = vec3(0.,2.5,0.);\n    vec3 rd = lookAt(cp,ta,uv);\n    \n    float st, cd, dist;\n    ray(cp, rd, st, cd, dist);\n    \n    col = skyCol(rd) + skyStars(rd);\n        \n    if(cd < .01)\n    {\n        vec3 norm = normal(cp);\n        float si = clamp(dot(norm, -rd), 0.,1.);\n        \n        float skyUpI = clamp(dot(norm, vec3(0.,1.,0.)),0.,1.);\n        col = mix(seaCol, darkBlue, pow(skyUpI, 3.));\n        \n        vec3 refl = reflect(rd, norm);\n        \n        float skyFdI = dot(refl, normalize(vec3(0.,1.,1.)));\n        \n        vec3 skyFdCol = skyCol(refl);\n        col += skyFdCol * pow(skyFdI, 16.) * .95;\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159\n#define TAU  6.28319\n\n// Hashes from https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGXRw.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[553, 553, 575, 575, 655], [656, 656, 682, 682, 983], [984, 991, 1032, 1032, 1203], [1205, 1205, 1224, 1224, 1744], [1871, 1871, 1892, 1985, 2162], [2164, 2164, 2238, 2238, 2443], [2445, 2445, 2485, 2485, 2646], [3032, 3032, 3054, 3054, 3752], [3754, 3754, 3778, 3778, 4652], [4654, 4654, 4711, 4711, 5798]], "test": "untested"}
{"id": "wlKXzw", "name": "noname", "author": "zhangwei199807", "description": "describe", "tags": ["1", "1"], "likes": 3, "viewed": 249, "published": 3, "date": "1582458742", "time_retrieved": "2024-07-30T21:22:23.049849", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n    float t = iTime*3.;\n    \n    \n    float circle = length(uv) - 0.23;\n    float rect =  max(abs(uv.x),abs(uv.y)) - 0.1;\n    \n    //interpolate weight (0,1) 0: circle, 1: rect\n    float w = -sin(t+sin(t+sin(t)))*0.5+0.5; \n\n    float f = circle*(1.-w)+ w*rect; //linear lerp\n    \n    \n    f = smoothstep(0.0,-0.01,f) - smoothstep(-0.01,-0.02,f);    \n    vec3 col = vec3(f);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 579]], "test": "untested"}
{"id": "wtKSRw", "name": "Inflating bubbles", "author": "avin", "description": "experiment with buffers", "tags": ["2d", "circles", "vector", "buffers"], "likes": 20, "viewed": 726, "published": 3, "date": "1582456020", "time_retrieved": "2024-07-30T21:22:23.919523", "image_code": "#define COL1 vec3(32, 43, 51) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 2./min(iResolution.x, iResolution.y)\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    float m = 0.;\n    vec3 col = COL1;\n    for (float i = 0.; i < float(SIZE); i += 1.) {\n        vec4 point = texelFetch(iChannel0, ivec2(i, 0.), 0);\n        vec4 color = texelFetch(iChannel0, ivec2(i, 1.), 0);\n        vec2 pos = point.xy;\n        float radius = point.z;\n\n        float ll = 0.005; // + radius*.1;\n        float g = SS(abs(length(uv - pos) - radius + ll * .5) * 2., ll);\n\n        if (g > m) {\n            col += color.rgb * g;\n            m = g;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(fragCoord.y > 2. || fragCoord.x > SIZE){\n    \tdiscard;\n    }\n    \n    if (mod(fragCoord.y, 2.) > 0.5) {\n        fragColor = hue(hash12(fragCoord * 3.));\n    } else {\n        float factor = texelFetch(iChannel0, ivec2(fragCoord.x, 0.), 0).w;\n\n        vec2 pos = vec2(hash12(fragCoord + factor) - .5, hash12(fragCoord * 100. + factor) - .5);\n        pos *= vec2(iResolution.x / iResolution.y, 1.);\n        float radius = texelFetch(iChannel0, ivec2(fragCoord.x, 0.), 0).z;\n\n        float isOk = 0.;\n\n        for (float i = 0.; i < float(SIZE); i += 1.) {            \n            vec4 point = texelFetch(iChannel0, ivec2(i, 0.), 0);\n\n            if (point.z > 0.) {\n                if (distance(point.xy, pos) < (point.z + radius)) {\n                    isOk += 1.;\n                }\n            }\n        }\n\n        if (isOk < 2.) {\n            radius += .0005;\n        } else {\n            radius = 0.;\n            factor += .01;\n        }\n\n        fragColor = vec4(pos, radius, factor);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 50.\n\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec4(0,23,21,0) ) )\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 228, 228, 817]], "test": "untested"}
{"id": "3tVSRm", "name": "Diffraction Grating", "author": "ttg", "description": "Simulates diffraction of light through a grating.\n\nControls:\nA/S zoom in/out\nD/F change number of slits\nC/V change spacing between slits\n\nNumber keys:\n1 - 532 nm, show phases\n2 - 532 nm, show color\n3 - RGB source\n4 - full spectrum\n\n1&2: Mouse: show waves!", "tags": ["simulation", "interactive", "demo", "diffraction"], "likes": 21, "viewed": 981, "published": 3, "date": "1582424610", "time_retrieved": "2024-07-30T21:22:24.928825", "image_code": "/*\n\nDiffraction Grating Simulation\nCopyright 2020 Theron Tarigo\n\nSimulates diffraction of light through a grating.\n\nControls:\nA/S zoom in/out\nD/F change number of slits\nC/V change spacing between slits\n\nNumber keys:\n1 - 532 nm, show phases\n2 - 532 nm, show color\n3 - RGB source\n4 - full spectrum\n\nModes 1&2: Mouse: show waves!  Z to toggle showing superposition.\n\n*/\n\nCOMMONDEF\n\nconst float pi = 3.1415927;\nvec2 compsin (float x) { return vec2(cos(x),sin(x)); }\nfloat sinc (float x) { return abs(x)<1e-4?1.:sin(x)/x; }\nfloat square (float a) { return a*a; }\n\nint getFrame() { return iFrame; }\nvec4 readctl (int ch, int n) { return readctlch(iChannel3, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(iChannel2, ivec2(keycode,evt), 0).r>.5;\n}\n\nvec3 complex_color (vec2 v) {\n  vec2 vn = normalize(v);\n  vec3 cb = vec3(1.) + vec3(1,-.5,-.5)*vn.x + vec3(0.,.866,-.866)*vn.y;\n  return cb/dot(cb,vec3(.213,.715,.072))*dot(v,v);\n}\n\nvec2 gfc = vec2(0.);\nfloat cvis = 0.;\n\nvec2 diffraction_pattern(vec2 uv, int nslits, float spacing, float lambda) {\n  float xprop = cvis*iTime;\n  vec2 v = vec2(0.);\n  if (uv.x<0.) {\n    float d = max(1.,abs(uv.y)/(spacing*float(nslits)/2.))-1.;\n    float a = 1./(1.+10.*d*d);\n    v = a*compsin(2.*pi*fract((uv.x-xprop)/lambda))*1e6;\n  }\n  else\n  for (int i=-(nslits/2); i<((nslits+1)/2); i++) {\n    float h = spacing*(float(i)+.5*float((nslits+1)%2));\n    vec2 r = uv-vec2(0.,h);\n    float a = 1./length(r)*(r.x*r.x)/dot(r,r);\n    v+= a*compsin(2.*pi*fract((length(r)-xprop)/lambda));\n  }\n  return v;\n}\n\nvoid diffraction_wavevis(inout vec3 color, vec2 uv, vec2 p, float gscale, int nslits, float spacing, float lambda) {\n  vec4 rnd = paramdither(vec2(uvec2(gfc)/2u), 28841);\n  float xprop = cvis*iTime;\n  for (int i=-(nslits/2); i<((nslits+1)/2); i++) {\n    float h = spacing*(float(i)+.5*float((nslits+1)%2));\n    vec2 s = vec2(0.,h);\n    vec2 r = p-s;\n    vec2 rn = normalize(r);\n    vec2 uvw = mat2(rn.x,-rn.y,rn.y,rn.x)*(uv-p);\n    uvw.x+=length(r);\n    uvw.x-=uvw.y*r.y/r.x;\n    vec2 uvwh = vec2(uvw.x,abs(uvw.y));\n    mat2 window = mat2(0., -gscale, length(r)+2.*gscale*10., 2.*gscale);\n    mat2 domain = mat2(window[0][0], -2., window[0][0]+window[1][0], 2.);\n    float vscale = 1./sqrt(float(nslits));\n    float gsm = smoothstep(.05,.2,fwidth(uv.x)/lambda);\n    float gin = 1.-gsm;\n    vec3 col_single = vec3(0.,.5,1.)*4.;\n    vec3 col_sum = vec3(1.,.5,0.)*4.;\n    gsm*=.02;\n    PLOT_CONTINUOUS(color, uvw, window, domain,  gin*col_single, 0, 1, .02*gscale, cos(2.*pi*fract((x-xprop)/lambda))*vscale );\n    PLOT_CONTINUOUS(color, uvw, window, domain,  gsm*col_single, 1, 1, .02*gscale, 1.*vscale );\n    PLOT_CONTINUOUS(color, uvw, window, domain, -gsm*col_single, 1, 1, .02*gscale, -1.*vscale );\n    #define acompensate (4./x*(r.x*r.x)/dot(r,r))\n    float falloff = 5.*exp(-square((uvw.x-length(r))/gscale)/mix(1.,10.,gin));\n    window[0][1]*=4.; window[1][1]*=4.; domain = mat2(window[0][0], -2., window[0][0]+window[1][0], 2.);\n    if (!KEYBOARD(Z,TOGGLE)) {\n      PLOT_CONTINUOUS(color, uvw, window, domain,  gin*falloff*col_sum, 0, 1, .02*gscale, \n        diffraction_pattern( s + rn*x, nslits, spacing, lambda ).x/acompensate*vscale );\n      PLOT_CONTINUOUS(color, uvw, window, domain,  gsm*falloff*col_sum, 1, 1, .02*gscale, \n        length(diffraction_pattern( s + rn*x, nslits, spacing, lambda ))/acompensate*vscale );\n      PLOT_CONTINUOUS(color, uvw, window, domain, -gsm*falloff*col_sum, 1, 1, .02*gscale, \n        -length(diffraction_pattern( s + rn*x, nslits, spacing, lambda ))/acompensate*vscale );\n    }\n    #undef acompensate\n  }\n}\n\nvoid demo_waves(inout vec3 color, vec2 uv, int nslits, float spacing, vec2 mouse, float gscale) {\n  float lambda = readctl(CTL_LAMBDA).x;\n  diffraction_wavevis(color, uv, mouse, gscale, nslits, spacing, lambda);\n}\n\nvec3 demo_phase(vec2 uv, int nslits, float spacing) {\n  vec3 color = vec3(0.);\n  float lambda = readctl(CTL_LAMBDA).x;\n  vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n  vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n  return mix(complex_color(v),vec3(1.,.7,1.)*dot(v,v),\n    smoothstep(.2,.4,fwidth(uv.x)/lambda));\n}\n\nvec3 demo_single(vec2 uv, int nslits, float spacing) {\n  vec3 color = vec3(0.);\n  float lambda = readctl(CTL_LAMBDA).x;\n  vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n  vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n  return wcol*dot(v,v);\n}\n\nvec3 demo_rgb(vec2 uv, int nslits, float spacing) {\n  vec3 color = vec3(0.);\n  for (int c=0; c<3; c++) {\n    float lambda = 1e-9*float[](650.,532.,450.)[c];\n    float intens = float[](2.17,.94,.57)[c]*2.;\n    vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n    vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n    color+=wcol*dot(v,v)*intens;\n  }\n  return color;\n}\n\nvec3 demo_spectrum(vec2 uv, int nslits, float spacing) {\n  vec4 rnd = paramdither(gfc, 28431);\n  vec3 color = vec3(0.);\n  for (int nw=370; nw<780; nw+=20) { \n    float lambda = (float(nw)+.5*20.*rnd.x)*1e-9;\n    vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n    vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n    color+=wcol*dot(v,v);\n  }\n  return color*.4;\n}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n  vec2 mouse = iMouse.xy/iResolution.xy;  \n  vec2 R = iResolution.xy;\n  vec2 uvr = fragCoord/R;\n  gfc = fragCoord;\n  C_iFrame = iFrame;\n  \n  fragData = vec4(0.);\n\n  vec3 color = vec3(0.);\n\n  vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.x;\n  vec2 muv = (2.*iMouse.xy - iResolution.xy) / iResolution.x;\n  uv.x+=.95; muv.x+=.95;\n  float scale = readctl(CTL_SCALE).x;\n  uv/=scale; muv/=scale;\n  uv.x-=5e-6; muv.x-=5e-6;\n  \n  float spacing = readctl(CTL_SLITSPACING).x;\n  float dsize = spacing*readctl(CTL_NSLITS).x;\n  int nslits = int(ceil(dsize/spacing));\n  nslits = clamp(nslits,0,256);\n  \n  int demo = readctli(CTL_WHICHDEMO).x;\n  \n  if (demo==1 || demo==2) {\n    cvis = KEYBOARD(X,TOGGLE) ? 0. : 3e8/1e15;\n  }\n  \n  float isc = 1./pow(scale*20.,2.);\n  isc /= max(float(nslits),32.)/32.;\n\n  if (demo==1) color += demo_phase(uv, nslits, spacing) * isc;\n  if (demo==2) color += demo_single(uv, nslits, spacing) * isc;\n  if (demo==1 || demo==2) {\n    color *= 1. - .8*readctl(CTL_MOUSEEASE).x;\n    if (iMouse.z>0.) demo_waves(color, uv, nslits, spacing, muv, .04/scale);\n  }\n  if (demo==3) color += demo_rgb(uv, nslits, spacing) * isc;\n  if (demo==4) color += demo_spectrum(uv, nslits, spacing) * isc;\n\n  color += .004;\n \n  color = tonemap(color);\n  fragData.rgb = srgbl_to_srgb(color);\n  fragData.rgb += dither(fragCoord);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Collection of utilities from old shaders\n\nconst float C_pi = 3.1415927;\n\n// Expression Plotter by ttg https://www.shadertoy.com/view/3t3XWf\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n    } \\\n  }\n\n\n/*\nhttps://www.shadertoy.com/view/wtGXzm\n\nSpectral tonemap (closest sRGB approximation without banding)\n\nTrying to render spectral colors into screen space with as little desaturation\nas possible given the white-level, and no color banding.\n\n\nMouse: plot R,G,B and Luminance at a horizontal slice through the image.\nHorizontal lines: limits (0 and 1)\n\nTop: Just enough white added so that color-matching RGB values are nonnegative.\nBottom: No white added, negative values get handled by tonemap.\nIn-between: gradient of white.\n\n\n*/\n\n// srgbl - linear srgb\nvec3 wavelength_to_srgbl (float l_nm ) {\n    if (l_nm<370.||l_nm>780.) return vec3(0.);\n    vec4 l = vec4(1.065, 1.014, 1.839, 0.366);\n    vec4 c = vec4(593.,556.3,449.8, 446.);\n    vec4 s = vec4(.056,.075,.051, .043);\n    if (l_nm<446.) s.a = 0.05; // fix creep from violet back to blue\n    if (l_nm>593.) s.r = 0.062; // fix creep from red back to green\n    vec4 v = (log(l_nm)-log(c))/s;\n    vec4 xyzx = l*exp(-.5*v*v);\n    vec3 xyz = xyzx.xyz+vec3(1,0,0)*xyzx.a;\n    const mat3 xyz_to_rgb = \n      mat3(3.240,-.969,.056, -1.537,1.876,-.204, -0.499,0.042,1.057);\n    vec3 rgb = xyz_to_rgb*xyz;\n    return rgb;\n}\n\nfloat rgb_to_lum (vec3 v) {\n  vec3 w = vec3(.213,.715,.072);\n  return dot(w,v);\n}\n\nvec3 rgb_to_hue (vec3 v) {\n  vec2 hv = mat3x2( 1., 0., -.5, .866, -.5,-.866) * v;\n  float h = atan(hv.y,hv.x);\n  v = .5+.5*cos(h-vec3(0,1,2)/3.*2.*C_pi);\n  v -= -log(dot(vec3(1.),exp(-v*10.)))/10.;\n  v/=rgb_to_lum(v);\n  return v;\n}\n\nfloat rgb_to_sat (vec3 v) {\n  v/=rgb_to_lum(v);\n  vec3 h = rgb_to_hue(v);\n  if (any(isnan(h))) return 0.;\n  // doesn't matter which component of (1-v)/(1-h) is used!\n  return dot(vec3(1./3.), (1.-v)/(1.-h) );\n}\n\nvec3 tonemap (vec3 color) {\n  vec3  hue = rgb_to_hue(color);\n  float sat = rgb_to_sat(color);\n  float lum = rgb_to_lum(color);\n\n  // smooth-clamp\n  sat = -log(exp(-sat*10.)+exp(-10.))/10.;\n\n  /* tonemapping options:\n       - desaturate when very bright\n       - smooth-clamp brightness to a maximum that still\n          allows some color variation                              */\n  sat = sat*(exp(-lum*lum*2.));\n  lum = .8*(1.-exp(-lum));\n\n  color = lum*mix(vec3(1.),hue,sat);\n  return color;\n}\n\nvec3 srgbl_to_srgb(vec3 linearRGB) {\n  // https://www.shadertoy.com/view/4tXcWr\n  // By https://www.shadertoy.com/user/Tynach\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nuint triple32(uint x) {\n    // https://www.shadertoy.com/view/WttXWX\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nint C_iFrame;\n\nvec3 dither (vec2 fc) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec3 h = (uvec3(z)>>uvec3(0,8,16))&0xFFu;\n  return vec3(ivec3(h)-128)/128./256.;\n}\n\nvec4 paramdither (vec2 fc, int seed) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(uint(seed)+c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec4 h = (uvec4(z)>>uvec4(0,8,16,24))&0xFFu;\n  return vec4(ivec4(h)-128)/128.;\n}\n\nvec4 boxmuller (vec4 r) {\n  vec4 v;\n  v.xy = sqrt(abs(2.*log(r.x+1e-4)))*vec2(cos(2.*C_pi*r.y),sin(2.*C_pi*r.y));\n  v.zw = sqrt(abs(2.*log(r.z+1e-4)))*vec2(cos(2.*C_pi*r.w),sin(2.*C_pi*r.w));\n  return v;\n}\n\nconst struct KEYCODES_T {\n  int A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\n  _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,\n  end;\n} KEYCODES = KEYCODES_T(\n 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,\n 48,49,50,51,52,53,54,55,56,57,\n -1\n);\nconst struct KEYSTATES_T { int DOWN,PRESS,TOGGLE; }\n  KEYSTATES = KEYSTATES_T( 0, 1, 2 );\n\n#define KEYBOARD(NAME,STATE) keyboard(KEYCODES.NAME,KEYSTATES.STATE)\n\nivec4 decodeInteger (vec4 e) {\n    return floatBitsToInt(e)&0x3FFFFFFF;\n}\n\nvec4 encodeInteger (ivec4 d) {\n    return intBitsToFloat((d&0x3FFFFFFF)|0x40000000);\n}\n\nconst ivec2 ctlbuf_size = ivec2(256);\n\nvoid ctlbuf_pack (ivec2 pix, out int ch, out int n) {\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = pix/ivec2(bw,bh);\n  ivec2 bpix  = pix%ivec2(bw,bh);\n  n = bpix.y+bh*bpix.x;\n  ch = block.x+nbx*block.y;\n}\n\nivec2 ctlbuf_unpack(int ch, int n) {\n  if (n<0||n>=ctlbuf_size.x) return ivec2(-1);\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = ivec2(ch%nbx, ch/nbx);\n  ivec2 bpix = ivec2(n/bh, n%bh);\n  return ivec2(bw,bh)*block+bpix;\n}\n\nvec4 readctlch (sampler2D samp, int ch, int n) {\n  ivec2 pix = ctlbuf_unpack(ch,n);\n  if (pix==ivec2(-1)) return vec4(0.);\n  return texelFetch(samp, pix, 0);\n}\n\n#define COMMONDEF \\\nvec4 readctl (int ch, int n); \\\nivec4 readctli (int ch, int n) { return decodeInteger(readctl(ch,n)); }\n\n#define CTL_MOUSETIME 8,0\n#define CTL_MOUSEEASE 8,1\n\n#define CTL_WHICHDEMO 10,0\n#define CTL_SCALE 11,0\n#define CTL_SLITSPACING 11,2\n#define CTL_NSLITS 11,1\n#define CTL_LAMBDA 11,3\n\n", "buffer_a_code": "\n#define CH_SELF iChannel3\n#define CH_KEYB iChannel2\n\nvec4 readctl (int ch, int n) { return readctlch(CH_SELF, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(CH_KEYB, ivec2(keycode,evt), 0).r>.5;\n}\n\nvoid mainImage ( out vec4 f, in vec2 fc ) {\n  int ch, n;\n  ctlbuf_pack(ivec2(fc), ch, n);\n  ivec2 chn = ivec2(ch,n);\n  bool init = (iFrame<2);\n  vec4 forig = texelFetch(CH_SELF, ivec2(fc), 0);\n  f = forig;\n  ivec4 d = decodeInteger(forig);\n  // Keyboard\n  if (ch<3) { f = texelFetch(CH_KEYB, ivec2(n,ch), 0); return; }\n  \n  if (chn==ivec2(CTL_MOUSETIME)) {\n    // x: last down, y: last up\n    if (f.x<f.y && iMouse.z>0.) f.x = iTime;\n    if (f.y<f.x && iMouse.z<0.) f.y = iTime;\n  }\n  \n  if (chn==ivec2(CTL_MOUSEEASE)) {\n    float rate = 4.;\n    f.x = mix(f.x, float(iMouse.z>1.), rate*iTimeDelta);\n  }\n  \n  if (chn==ivec2(CTL_WHICHDEMO)) {\n    for (int i=1; i<9; i++) {\n      if (keyboard(48+i,1)) {\n        d.x = i;\n      }\n    }\n    if (init) d.x = 3;\n  }\n  \n  if (chn==ivec2(CTL_SCALE)) {\n    float rate = 2.;\n    if (KEYBOARD(A,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (KEYBOARD(S,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (init) f.x = 8e3;\n    f.x = clamp(f.x, 1e2, 1e5);\n  }\n\n  if (chn==ivec2(CTL_NSLITS)) {\n    float rate = 2.;\n    if (KEYBOARD(D,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (KEYBOARD(F,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (init) f.x = 14.;\n    f.x = clamp(f.x, 1., 100.);\n  }\n\n  if (chn==ivec2(CTL_SLITSPACING)) {\n    float rate = 2.;\n    if (KEYBOARD(C,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (KEYBOARD(V,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (init) f.x = 1.3e-6;\n    f.x = clamp(f.x, 4e-7, 1e-5);\n  }\n\n  if (chn==ivec2(CTL_LAMBDA)) {\n    float rate = .15;\n    if (KEYBOARD(G,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (KEYBOARD(H,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (init) f.x = 532e-9;\n    f.x = clamp(f.x, 370e-9, 780e-9);\n  }\n  \n  if (d!=decodeInteger(forig)) f = encodeInteger(d);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 431, 431, 461], [462, 462, 484, 484, 518], [519, 519, 543, 543, 557], [559, 559, 575, 575, 592], [593, 593, 623, 623, 661], [662, 662, 700, 700, 762], [764, 764, 793, 793, 944], [3604, 3604, 3701, 3701, 3817], [3819, 3819, 3872, 3872, 4146], [4148, 4148, 4202, 4202, 4401], [5148, 5148, 5204, 5204, 6536]], "test": "untested"}
{"id": "3tKXzw", "name": " - Quicky#023", "author": "totetmatt", "description": "I don't know why I need to go far in time to get the effect.", "tags": ["instagram", "quicky"], "likes": 17, "viewed": 533, "published": 3, "date": "1582418147", "time_retrieved": "2024-07-30T21:22:25.851358", "image_code": "mat2 r(float a) {\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat xor(float a,float b) {\n    return a*(1.-b) +b*(1.-a);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float realTime = iTime + 5500.; // Yeah, effect works far in time\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 uuv = uv;\n    uv *=length(cos(uv*2.8));\n    float z= (cos(realTime*.1)*.5+1.);\n    uv*=r(cos(realTime)*.1)*z;\n    \n    \n    float aid = atan(uv.x,uv.y)*4.;\n    uv=12.*abs(uv*r(aid+fract(length(uv*4.)+aid*.25) ));\n    uv.x = sin(floor(uv.x)+-realTime*.5*cos(realTime*.25)*.005)*.5+.5;\n    uv.x = xor(uv.x,cos(floor(uv.y)+realTime*.5*sin(realTime*.25)*.005)*.5+.5);\n    vec3 col = vec3(uv.x);\n   \n    float flash = smoothstep(.5,1.,col).r;\n     col =col* 0.10/(length(uuv)-(.03*z+floor(cos(aid*4.+flash))*.005)) ;\n    col = mix(vec3(.1,.0,.1),vec3(.1 , .1 +flash*.5,1.-(1.-flash)*.5 ),col);\n    //col = ;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 75], [76, 76, 104, 104, 137], [138, 138, 193, 193, 972]], "test": "untested"}
{"id": "WlKSzw", "name": "Funky light experiments", "author": "rodgzilla", "description": "Adding some kind of glow at each step of the ray marching with a direct path to a light source. I am not sure it's the correct way to do this effect. Could someone tell me what algorithm to look for ?", "tags": ["raymarching", "light"], "likes": 2, "viewed": 346, "published": 3, "date": "1582414809", "time_retrieved": "2024-07-30T21:22:26.821764", "image_code": "#define time iTime\n#define ZPOS -30.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat wave(float t, float a) {\n    return a * (.5 * sin(time) + .5);\n}\n\nvec3 kifs(vec3 p, float r, float s, float tf, float it) {\n    float t = tf * time;\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .6);\n        p.yz *= rot2d(t * .7 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p, 1.3, .7, 1., 4.);\n//    p.xz *= rot2d(time);\n//\tfloat d = p.y + 1.;\n  \tfloat d = 500.;  \n    float obj = sph(p, 1.);\n\tobj = max(obj, -tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), .5));\n    d = min(d, obj);\n    \n    at += .2 / (.1 + pow(d, 3.));\n    \n    return d;\n}\n\nfloat secondary_light(vec3 p) {\n    vec3 lp = vec3(0, 0, 0);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n\n    float d = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p_rm = p + d * tln;\n        float ds = map(p_rm);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds;\n    }\n    \n    if (d < length(tl)) {\n        return 0.;\n    }\n    \n    \n    return 1.;\n}\n\nvec3 glow = vec3(0, 0, 0);\nvec3 glow2 = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .0002 * at * vec3(.5, 0., 0.);\n      \n    float sec_light = secondary_light(p);\n    glow2 += (.05 + wave(2.3, .1)) * sec_light * vec3(0., 0., 1.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(2, 5, ZPOS);\n//  lp.xz *= rot2d(time);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n//    uv *= sin(time);\n//    uv *= rot2d(sin(time) * PI);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n    \n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n//  \tfloat dif = light(p);\n  \t\n//    vec3 col = .2 * dif * glow;\n//  \tvec3 col = vec3(dif) + glow2 + glow;\n  \tvec3 col = glow2 + glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 82, 82, 147], [149, 149, 177, 177, 203], [205, 205, 235, 235, 275], [277, 277, 334, 334, 542], [544, 544, 589, 589, 746], [748, 748, 774, 774, 822], [839, 839, 858, 858, 1134], [1136, 1136, 1167, 1167, 1556], [1613, 1613, 1641, 1641, 2004], [2006, 2006, 2027, 2027, 2174], [2176, 2176, 2197, 2197, 2449], [2452, 2452, 2509, 2509, 3006]], "test": "untested"}
{"id": "wtyXzm", "name": "velocity brush (click to paint)", "author": "aethelwhat", "description": "click to paint a velocity field that moves the default ShaderToy iTime colors. Inspired by pixelpa (andrew benson). Not a fluid dynamics sim but I'll do one eventually. try painting circles.", "tags": ["interactive", "paint", "velocityfield"], "likes": 5, "viewed": 640, "published": 3, "date": "1582413382", "time_retrieved": "2024-07-30T21:22:27.596692", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    col = texture(iChannel1, uv);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Velocity channel\n\nconst float speedScale = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 p = texture(iChannel0, uv);\n    vec4 mousePrev = texture(iChannel1, uv);\n    \n    vec2 velocity = (iMouse.xy - mousePrev.xy) / speedScale;\n    velocity = (clamp(velocity, -1., 1.) + 1.) / 2.;\n    \n    // Click to paint velocity\n    if (iMouse.z>0. && length(iMouse.xy-fragCoord)<45.) {\n        p = vec4(velocity, 0., 1.);\n    }\n    \n    if ( iFrame < 1 )\n        p = texture(iChannel2, uv); // initial velocity field, towards bottom left if vec4(0.).\n    \n    fragColor = p;\n}", "buffer_a_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Stores previous mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Stores color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 vel = texture(iChannel0, uv).xy;\n    vel = (vel - .5) * 2.;\n\tvec4 p = texture(iChannel1, uv - vel/iResolution.x);\n    \n    // Click to paint in color\n    if (iMouse.z>0. && length(iMouse.xy-fragCoord)<45.) {\n        p = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)),1.);\n    }\n    \n    if ( iFrame < 2 ){\n        p = texture(iChannel2, uv);\n    }\n\n    fragColor = p;\n}", "buffer_c_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 273]], "test": "untested"}
{"id": "tlySzm", "name": "Chromatic Resonance", "author": "PixelPhil", "description": "A quick experiment with colors and music.\n\nMusic : Lightning Moment - DJ Okawari (feat. fox capture plan)", "tags": ["spectrum", "visualization", "music", "colors", "vj", "sines"], "likes": 85, "viewed": 4955, "published": 3, "date": "1582412922", "time_retrieved": "2024-07-30T21:22:28.371621", "image_code": "//\n// Chromatic Resonance by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MUSIC_REACTION 0.2\n\n#define S(a, b, c) smoothstep(a, b, c)\n#define sat(a) clamp(a, 0.0, 1.0)\n\n#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat CosineInterpolate(float y1, float y2, float t)\n{\n   float mu = (1.0 -cos(t * pi)) * 0.5;\n   return (y1 * (1.0 - mu) + y2 * mu);\n}\n\n// A 2d Noise (Cosine interpolation is more plasing for this effect)\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    return CosineInterpolate(CosineInterpolate(c00, c10, diff.x), CosineInterpolate(c01, c11, diff.x), diff.y);\n}\n\nfloat LineNoise(float x, float t)\n{\n    float n = Noise2(vec2(x * 0.6, t * 0.2));\n    //n += Noise2(vec2(x * 0.8, t * 0.2 + 34.8)) * 0.5;\n    //n += Noise2(vec2(x * 1.2, t * 0.3 + 56.8)) * 0.25;\n    \n    return n - (1.0) * 0.5;\n}\n\n\nfloat line(vec2 uv, float t, float scroll)\n{\n    \n    float ax = abs(uv.x);\n    uv.y *= 0.5 + ax * ax * 0.3; \n    \n        \n    uv.x += iTime * scroll;\n    \n    float n1 = LineNoise(uv.x, t);\n    \n    \n    float n2 = LineNoise(uv.x + 0.5, t + 10.0) * 2.0;\n    \n    float ay = abs(uv.y - n1);\n    float lum = S(0.02, 0.00, ay) * 1.5;\n    lum += S(1.5, 0.00, ay) * 0.1;\n    \n   \n    float r = (uv.y - n1) / (n2 - n1);\n    float h = sat(1.0 - r);\n    if (r > 0.0) lum = max(lum, h * h * 0.7);\n    \n    return lum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    float xWave = fragCoord.x / iResolution.x;\n    \n    float wave = texture(iChannel0, vec2(xWave * 0.2, 1.0)).r * sin(iTime * 0.2 ) * MUSIC_REACTION;\n    float wave1 = texture(iChannel0, vec2(xWave * 0.2 + 0.2, 1.0)).r * sin(iTime * 0.2 + 0.5) * MUSIC_REACTION;\n    float wave2 = texture(iChannel0, vec2(xWave * 0.2 + 0.4, 1.0)).r * sin(iTime * 0.2 + 1.0) * MUSIC_REACTION;\n    float wave3 = texture(iChannel0, vec2(xWave * 0.2 + 0.6, 1.0)).r * sin(iTime * 0.2 + 1.5) * MUSIC_REACTION;\n    float wave4 = texture(iChannel0, vec2(xWave * 0.2 + 0.8, 1.0)).r * sin(iTime * 0.2 + 2.0) * MUSIC_REACTION;\n    \n  //  fragColor = vec4(lum, lum, lum, 1.0); return;\n    \n\n    float lum = line(uv * vec2(2.0, 1.0)+  vec2(0.0, wave), iTime * 0.3, 0.1) * 0.6;\n    lum += line(uv * vec2(1.5, 0.9) +  vec2(0.33, wave1), iTime * 0.5 + 45.0, 0.15) * 0.5;\n    lum += line(uv * vec2(1.3, 1.2) +  vec2(0.66, wave2), iTime * 0.4 + 67.3, 0.2) * 0.3;\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave3), iTime * 0.77 + 1235.45, 0.23) * 0.43;\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave4), iTime * 0.77 + 456.45, 0.3) * 0.25;\n  \n    \n    float ax = abs(uv.x);\n    \n    lum += ax * ax * 0.05;\n  \n\n    vec3 col;\n    \n    float x = uv.x * 1.2 + iTime * 0.2;\n    \n    vec3 hue = (sin(vec3(x, x + pi2 * 0.33, x + pi2 * 0.66)) + vec3(1.0)) * 0.7;\n    \n\n    // overlay mix\n    float thres = 0.7;\n    if (lum < thres)\n        col = hue * lum / thres;\n    else\n        col = vec3(1.0) - (vec3(1.0 - (lum - thres)) * (vec3(1.0) - hue));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 21248, "src": "https://soundcloud.com/brella-n-i/lightning-moment-feat-fox", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySzm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[358, 385, 403, 459, 635], [638, 638, 692, 692, 773], [775, 844, 867, 867, 1215], [1217, 1217, 1252, 1252, 1446], [1449, 1449, 1493, 1493, 1961], [1963, 1963, 2020, 2070, 3723]], "test": "untested"}
{"id": "WtVXRw", "name": "bad cathode", "author": "isk", "description": "i'm sure it's fine", "tags": ["distortion", "glitch"], "likes": 9, "viewed": 495, "published": 3, "date": "1582410533", "time_retrieved": "2024-07-30T21:22:29.229327", "image_code": "vec2 freak(vec2 uv) {\n    float f = sin(3. * iTime + uv.y * 9.0122);\n    f *= sin(uv.y * 11.96124) * 1.122;\n    f *= sin(uv.y * 17.514) * 1.113;\n    f *= sin(uv.y * 23.7345) * 1.76252;\n    f *= .1 + sin(f + iTime * 122.) * .04123;\n    f *= 0.084;\n    return vec2(uv.x + f, uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv += .1 * length(uv - .5);\n    uv = freak(uv);\n    vec3 c = texture(iChannel0, uv).rgb;\n    c = (.8 + .2 * abs(sin(uv.y * 256.))) * vec3(c.g * 0.9, c.g * 1.1, pow(abs(sin(-4. * iTime + uv.y * 13.)), 6.) * c.g);\n    c *= pow(length(c), 3.);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 281], [283, 283, 338, 338, 656]], "test": "untested"}
{"id": "wtGXzm", "name": "Spectral color tonemap", "author": "ttg", "description": "Trying to render spectral colors into screen space with as little desaturation as possible given the white-level, and no color banding.\nMouse and Top/bottom: see description in source.\nHow best to fix the banding that shows up for violet?", "tags": ["spectrum", "light", "color", "perception", "tonemap"], "likes": 17, "viewed": 954, "published": 3, "date": "1582404486", "time_retrieved": "2024-07-30T21:22:30.156847", "image_code": "/*\nhttps://www.shadertoy.com/view/wtGXzm\n\nSpectral tonemap (closest sRGB approximation without banding)\n\nTrying to render spectral colors into screen space with as little desaturation\nas possible given the white-level, and no color banding.\n\n\nMouse: plot R,G,B and Luminance at a horizontal slice through the image.\nHorizontal lines: limits (0 and 1)\n\nTop: Just enough white added so that color-matching RGB values are nonnegative.\nBottom: No white added, negative values get handled by tonemap.\nIn-between: gradient of white.\n\n\n*/\n\n// srgbl - linear srgb\nvec3 wavelength_to_srgbl (float l_nm ) {\n    if (l_nm<370.||l_nm>780.) return vec3(0.);\n    vec4 l = vec4(1.065, 1.014, 1.839, 0.366);\n    vec4 c = vec4(593.,556.3,449.8, 446.);\n    vec4 s = vec4(.056,.075,.051, .043);\n    if (l_nm<446.) s.a = 0.05; // fix creep from violet back to blue\n    vec4 v = (log(l_nm)-log(c))/s;\n    vec4 xyzx = l*exp(-.5*v*v);\n    vec3 xyz = xyzx.xyz+vec3(1,0,0)*xyzx.a;\n    const mat3 xyz_to_rgb = \n      mat3(3.240,-.969,.056, -1.537,1.876,-.204, -0.499,0.042,1.057);\n    vec3 rgb = xyz_to_rgb*xyz;\n    return rgb;\n}\n\nfloat rgb_to_lum (vec3 v) {\n  vec3 w = vec3(.213,.715,.072);\n  return dot(w,v);\n}\n\nvec3 rgb_to_hue (vec3 v) {\n  vec2 hv = mat3x2( 1., 0., -.5, .866, -.5,-.866) * v;\n  float h = atan(hv.y,hv.x);\n  v = .5+.5*cos(h-vec3(0,1,2)/3.*2.*pi);\n  v -= -log(dot(vec3(1.),exp(-v*10.)))/10.;\n  v/=rgb_to_lum(v);\n  return v;\n}\n\nfloat rgb_to_sat (vec3 v) {\n  v/=rgb_to_lum(v);\n  vec3 h = rgb_to_hue(v);\n  if (any(isnan(h))) return 0.;\n  // doesn't matter which component of (1-v)/(1-h) is used!\n  return dot(vec3(1./3.), (1.-v)/(1.-h) );\n}\n\nvec3 tonemap (vec3 color) {\n  vec3  hue = rgb_to_hue(color);\n  float sat = rgb_to_sat(color);\n  float lum = rgb_to_lum(color);\n\n  // smooth-clamp\n  sat = -log(exp(-sat*10.)+exp(-10.))/10.;\n\n  /* tonemapping options:\n       - desaturate when very bright\n       - smooth-clamp brightness to a maximum that still\n          allows some color variation                              */\n  // sat = sat*(exp(-lum*lum*2.));\n  // lum = .8*(1.-exp(-lum));\n\n  color = lum*mix(vec3(1.),hue,sat);\n  return color;\n}\n\nvec3 testcolor(float x, float l_nm) {\n  vec3 color1 = (wavelength_to_srgbl(l_nm)+.85)*.3; // no negative values\n  vec3 color2 = wavelength_to_srgbl(l_nm)*.3;       // no white background\n  vec3 color = mix(color2,color1,x*x*x*x);\n\n  color = tonemap(color);\n#if 0\n  // hack - closer to appearance of desired result (still not ideal)\n  color1 = tonemap(color1);\n  color2 = tonemap(color2);\n  color = mix(color2,color1,x*x*x*x);\n#endif\n  return color;\n}\n\nvec3 srgbl_to_srgb (vec3 linearRGB);\nvec3 dither (vec2 fc);\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n  vec2 mouse = iMouse.xy/iResolution.xy;  \n  vec2 R = iResolution.xy;\n  vec2 uvr = fragCoord/R;\n  \n  // Always initialize all variables.\n  fragData = vec4(0.);\n  // Start all black\n  vec3 color = vec3(0.);\n  \n  float l_nm = fragCoord.x/iResolution.x*500.+300.;\n  color = testcolor(uvr.y,l_nm);\n  \nif (iMouse.z>0.) {\n  mat2 window = mat2(0,0,iResolution.xy);\n  mat2 domain = mat2(300, -.1,800, 1.1);\n  float slice = iMouse.y/iResolution.y;\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, vec3(0.1), 0, 0, 1., 0. );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, vec3(0.0), 0, 0, 1., 1. );\n  \n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(1,0,0), 0, 0, 1., testcolor(slice,x).x );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(0,1,0), 0, 0, 1., testcolor(slice,x).y );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(0,0,1), 0, 0, 1., testcolor(slice,x).z );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(1,1,1), 0, 0, 1., rgb_to_lum(testcolor(slice,x)) );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*(.5+.5*cos(uvr.x*4e2+vec3(0,2,4))), 0, 0, 1., rgb_to_sat(testcolor(slice,x)) );\n    \n}\n  \n  // demonstrate that there isn't clipping\n  if (any(lessThan(color,vec3(-1e-5)))) color = vec3(1);\n  if (any(greaterThan(color,vec3(1.+1e-5))) ) color = vec3(0);\n\n  fragData.rgb = srgbl_to_srgb(color);\n  fragData.rgb += dither(fragCoord);\n}\n\nvec3 srgbl_to_srgb(vec3 linearRGB) {\n  // https://www.shadertoy.com/view/4tXcWr\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nuint triple32(uint x) {\n    // https://www.shadertoy.com/view/WttXWX\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec3 dither (vec2 fc) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(c.x+(c.y<<10)+(uint(iFrame)<<20));\n  uvec3 h = (uvec3(z)>>uvec3(0,8,16))&0xFFu;\n  return vec3(ivec3(h)-128)/128./256.;\n}\n", "image_inputs": [], "common_code": "// Expression Plotter by ttg https://www.shadertoy.com/view/3t3XWf\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\nconst float pi = 3.1415927;\n\nvec2 compsin (float x) { return vec2(cos(x),sin(x)); }\nfloat sinc (float x) { return abs(x)<1e-4?1.:sin(x)/x; }\n\nfloat minv (vec3 v) { return min(min(v.x,v.y),v.z); }\nfloat maxv (vec3 v) { return max(max(v.x,v.y),v.z); }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 556, 596, 596, 1102], [1104, 1104, 1131, 1131, 1185], [1187, 1187, 1213, 1213, 1416], [1418, 1418, 1445, 1445, 1628], [1630, 1630, 1657, 1657, 2130], [2132, 2132, 2169, 2169, 2582], [2645, 2645, 2701, 2701, 4106], [4108, 4108, 4144, 4187, 4391], [4393, 4393, 4416, 4461, 4615], [4617, 4617, 4640, 4640, 4804]], "test": "untested"}
{"id": "wtGSRm", "name": "Vegan honey", "author": "rodgzilla", "description": "Recursive KIFS with glow", "tags": ["kifs", "recursion"], "likes": 6, "viewed": 382, "published": 3, "date": "1582394193", "time_retrieved": "2024-07-30T21:22:31.048463", "image_code": "#define time iTime\n#define ZPOS -130.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat wave(float t, float a) {\n    return a * (.5 * sin(time) + .5);\n}\n\nvec3 kifs(vec3 p, float r, float s, float tf, float it) {\n    float t = tf * time;\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .6);\n        p.yz *= rot2d(t * .7 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p, .8, 3., .5, 2.);\n    p = kifs(p, .5, 2. + length(p) * .3, .5, 4.);\n    float d = 5000.;\n    \n    float obj = tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), 1.);\n\tobj = min(obj, tube(p, vec3(0, -2, 0), vec3(0, 2, 0), 1.));\n\tobj = min(obj, tube(p, vec3(0, 0, -2), vec3(0, 0, 2), 1.));\n    obj = max(obj, sph(p, 2.));\n    obj = mix(obj, sph(p, 1.), wave(1., 1.));\n    d = min(d, obj);\n    \n    at += .05 / (.2 + d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * .8;\n    glow += .002 * at * vec3(.5, .3 + wave(.5, .4), 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(2, 5, ZPOS);\n//  lp.xz *= rot2d(time);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    uv *= .5 + wave(1., .5);\n//    uv *= sin(time);\n//    uv *= rot2d(sin(time) * PI);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n    \n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n  \tfloat dif = light(p);\n  \t\n//    vec3 col = .2 * dif * glow;\n  \tvec3 col = glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 83, 83, 148], [150, 150, 178, 178, 204], [206, 206, 236, 236, 276], [278, 278, 335, 335, 543], [545, 545, 590, 590, 747], [749, 749, 775, 775, 823], [840, 840, 859, 859, 1301], [1330, 1330, 1358, 1358, 1619], [1621, 1621, 1642, 1642, 1789], [1791, 1791, 1812, 1812, 2064], [2067, 2067, 2124, 2124, 2598]], "test": "untested"}
{"id": "wlyXRw", "name": "Capsule repetition camera rot", "author": "rodgzilla", "description": "Capsule rep with smooth camera rotations.", "tags": ["rm"], "likes": 2, "viewed": 320, "published": 3, "date": "1582390754", "time_retrieved": "2024-07-30T21:22:32.103642", "image_code": "#define time .4 * iTime\n#define ZPOS -30. + 20. * time\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n  p.xy *= rot2d(sin(1. * time) * sin(p.z / 15.));\n  p.x += 20. * sin(p.z / 100.);\n  p.x += 15. * cos(p.z / 50.);\n  p.xz *= rot2d(sin(.0001 * time) * PI);\n  p = rep(p, vec3(5, 5, 5));\n  float d = 5000.;\n  vec3 a1 = vec3(-2, 0, 0);\n  vec3 b1 = vec3(2, 0, 0);\n  vec3 a2 = vec3(0, -2, 0);\n  vec3 b2 = vec3(0, 2, 0);\n  vec3 a3 = vec3(0, 0, -3.);\n  vec3 b3 = vec3(0, 0, 3.);\n  float t = floor(time * .5) + smoothstep(.3, .6, fract(time * .5));\n  a1.xy *= rot2d(t);\n  b1.xy *= rot2d(t);\n  a2.xy *= rot2d(t);\n  b2.xy *= rot2d(t);\n  d = min(d, tube(p, a1, b1, .5));\n  d = min(d, tube(p, a2, b2, .5));\n  d = min(d, tube(p, a3, b3, .5));\n  \n  float t_wave = floor(time) + fract(time);\n  float wave = .5 * sin(t_wave) + .5;\n  vec3 shift = vec3(.2 * sin(time), 0, 0);\n  d = min(d, sph(p + shift, 1.));\n  \n  at += .1 / (.1 + d);\n  \n  return d;\n}\n\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .02 * at * vec3(0, 1., 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(0, 0, ZPOS);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .001 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n\tfloat t = floor(time / 2.) + smoothstep(0., .5, fract(time / 2.));\n    rd.xz *= rot2d(t * PI / 2.);\n    t = floor(time / 4.) + smoothstep(.5, .7, fract(time / 4.));\n    rd.yz *= rot2d(t * PI / 2.);\n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n//  \tfloat dif = light(p);\n  \n    vec3 col = .2 * glow;\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 100, 100, 165], [167, 167, 195, 195, 221], [223, 223, 268, 268, 425], [427, 427, 453, 453, 501], [518, 518, 537, 537, 1369], [1399, 1399, 1427, 1427, 1671], [1673, 1673, 1694, 1694, 1841], [1843, 1843, 1864, 1864, 2091], [2094, 2094, 2151, 2151, 2704]], "test": "untested"}
{"id": "tlKSRW", "name": "Day 65", "author": "jeyko", "description": "code is messy. ", "tags": ["mdtmjvm"], "likes": 7, "viewed": 405, "published": 3, "date": "1582390313", "time_retrieved": "2024-07-30T21:22:33.096986", "image_code": "// a 2d apollonian-ish fractal used as displacement\n// PBR from learnopengl.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor; // Wondering if this will glitch out for anyone. if it does, please leave a comment.\n    // fragColor = vec4(0);\n    \n    float t = texture(iChannel0, fragCoord/R).w;\n    float st = 20.;\n    \n    vec2 uv = (fragCoord - 0.5*R)/R.y;\n    float chromAbAmt = smoothstep(0.,1., dot(uv,uv))*0.5;\n    // DOF and chromatic abberation\n    for(float i = 0.; i < st; i++){\n        float sz = 0.00;\n        sz += smoothstep(0.,1.,abs(t)*0.02 - 0.01);\n        \n        //sz += 0.1;\n        vec2 c = vec2(\n        \tsin(tau*i/st)*sz,\n        \tcos(tau*i/st)*sz\n        );\n        \n        c *= 1. + texture(iChannel2, (fragCoord + i )/R).x*sz*100.;\n        \n        \n    \tfragColor += vec4(\n            texture(iChannel0, (fragCoord + vec2(1)*chromAbAmt)/R + c).x,\n            texture(iChannel0, (fragCoord - vec2(1,0)*chromAbAmt)/R + c).y,\n            texture(iChannel0, (fragCoord - vec2(1)*chromAbAmt)/R + c).z,\n            0.\n        );\n    }\n    fragColor /= st;\n    \n    vec4 bloom = texture(iChannel1, fragCoord/R, 0.);\n    //fragColor = mix(fragColor, bloom, length(bloom.xyz));\n    fragColor += bloom*0.5;\n    \n    fragColor.r *= 1.06;\n    fragColor.b *= 1.04;\n    fragColor.b *= 0.95;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define MIPLVL 1.\n\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define R iResolution.xy\n#define T(uv) texture(iChannel0, (uv)/R)\n\nvec4 gaussian(sampler2D chan, vec2 uv, vec2 iResolution, float mip){\n    float st = 4.;\n    vec3 t = vec3(st, 0., -st);\n    vec4 C = vec4(0);\n\t#define TC(uv) texture(chan, (uv)/R, mip) \n    // don't do defines like this lol\n    C += 4.*TC(uv);\n    C += 2.*TC(uv - t.xy) + 2.*TC(uv + t.xy) + 2.*TC(uv - t.yx) + 2.*TC(uv - t.yx);\n    C += 1.*TC(uv - t.xx) + 1.*TC(uv + t.xx) + 2.*TC(uv - t.xz) + 2.*TC(uv - t.xz);\n\n    return C / 16.;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat random(vec2 u){\n\treturn fract(sin(u.y*4125.1 + u.x *125.625)*225.5235);\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.125 + u.z*525.5215)*115.125235);\n} \nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 6; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n", "buffer_a_code": "\n#define mx (20.*iMouse.x/iResolution.x)\n#define iTime (iTime + mx)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define mx (20.*iMouse.x/iResolution.x)\n\n#define dmin(a,b) a.x < b.x ? a : b \n#define pmod(p, x) mod(p,x) - 0.5*x\n\nvec3 getWallpaper( vec2 fragCoord )\n{\n    vec2 p = mod(fragCoord,1.) - 0.5;\n\tp *= 1.4;\n    vec3 col = vec3(0);\n\n\tfloat d = 10e6;\n    \n    float s = 1.;\n    float scale = 1.;\n    \n    for(int i = 0; i < 5; i++){\n        p = -1.0 + 2.0*fract(0.5*p+0.5);\n        float dpp = dot(p,p);\n\n        p = abs(p);\n        p += vec2(0.06,0.02);\n        dpp = clamp(dpp,0.3,0.45);\n    \t//p /= dpp; \n    \t//p = sin(p + t);\n    \n        float k = s/dpp;\n        k = clamp(k,0.,4.);\n        \n        \n\t\tp     *= k;\n\t\tscale *= k;\n        \n    }\n    p = abs(p) - 0.1;\n    p = abs(p);\n   \td = min(p.x, p.y)/scale; \n    \n    col += smoothstep(0.01,0.,d);\n    \n    col = pow(col, vec3(4.));\n    \n    return col;\n}\n\n#define wallW 0.2\n#define wallH 0.5\n\n\nfloat wp = 0.;\nfloat fw = 0.;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6, 1.);\n    \n    \n    //p.x -= mix(0.,exp(abs(p.y)),smoothstep(0.,1.,abs(p.y)*4.))*0.1;\n    float lWall = p.x + wallW;\n    \n    wp = getWallpaper(p.yz*0.25).x;\n    \n    wp = clamp(wp, 0., 1.);\n    \n    lWall += wp*0.01;\n    \n    fw = fbm(p.yz*7.);\n    \n    lWall += fw *0.01*(1. - pow(wp,40.));\n    d.x = min(d.x, lWall);\n\n    lWall = -p.x + wallW;\n    \n    \n    lWall += fw *0.01*(1. - pow(wp,40.));\n    lWall += wp*0.01;\n\n    \n    d.x = min(d.x,lWall );\n    //d.x = min(d.x, -p.y - 0.4);\n    \n    p = pmod(p,2.);\n    \n    //d = dmin(d, vec2(length(p.yz) - 0.02,2.));\n    \n    //d.x = min(d.x, -p.y + wallW);\n    d.x *= 0.5;\n\treturn d;\n}\n\nvec3 glow = vec3(0);\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro;\n    hit = false; t = 0.;\n    \n    for(int i = 0; i < 150 ; i++){\n    \td = map(p);\n        glow += exp(-d.x*100.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p,float sens){\n\tvec2 t = vec2(sens,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\t\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    uv *= 0.8;\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv,uv)*0.3;\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    ro.y -= 0. + sin(iTime*0.10)*0.9;\n    ro.x += 0.14;\n    //ro.z += sin(mx)*4.;\n    ro.z += iTime*0.2;\n    vec3 lookAt = vec3(0,0,ro.z + 9.);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy*= rot(-0.9 + sin(iTime*0.24)*0.5);\n    rd.xz *= rot(0.5 + sin(iTime*0.3)*0.25);\n    \n    \n    \n    float t; bool hit; vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if (hit){\n        \n        float wpsc = smoothstep(0.,1.,wp*1.);\n        wpsc = smoothstep(0.,1.,wp*1. + 0.83);\n        wpsc = pow(wpsc, 95.);\n        \n        vec3 albedo = mix(vec3(0.3,0.0 ,0.+ pow(fw,4.)*0.4), vec3(0.99,0.9,0.2), wpsc);\n        \n        \n        vec3 lightCol = vec3(1.2,1.,1.);\n\n        //vec3 L = normalize(l - p);\n        vec3 L= normalize(vec3(0.01,0.2,0.7)); vec3 l = L;\n        \n        vec3 n = getNormal(p, clamp(0.001 + wp*0.008, 0., 1.));\n        vec3 H = normalize(L - rd);\n\n\n        int id = int(d.y);\n        float METALNESS = 0.0;\n        METALNESS += wp*0.9 + wpsc*0.2;\n        float ROUGHNESS = 0.4 + clamp((1. - wpsc)*0.4*fw*2., 0., 0.6);\n        \n        \n        vec3 F0 = vec3(0.03);\n        vec3 N = n;\n        vec3 V = normalize(ro - p);\n\n        F0 = mix(F0, albedo, METALNESS);\n\n        // calculate per-light radiance\n        float distL    = length(l - p)*1.;\n        float attenuation = 1. / (distL * distL);\n        \n        //attenuation = clamp(attenuation, 0., 1.);\n        attenuation = 1.;\n        vec3 radiance     = lightCol * attenuation;        \n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, ROUGHNESS);   \n        float G   = GeometrySmith(N, V, L, ROUGHNESS);      \n        vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - METALNESS;\t  \n\n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0); \n        \n        col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation; \n        \n    }\n    \n    col = mix(col, vec3(0.3,0.14,0.1)*2., smoothstep(0.,1.,t*0.01));\n    \n    \n    uv.y *= 1.5;\n    col *= 1. - (1. - vec3(0.1,0.6,0.1))*smoothstep(0.,1.,dot(uv,uv)*0.9)*0.4;\n\n    col = max(col, 0.);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,t);\n}\n\n", "buffer_a_inputs": [], "buffer_b_code": "\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0);\n    \n    C += gaussian(iChannel0, fragCoord,R,MIPLVL);\n    //C += T(fragCoord);\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0);\n    \n    C += gaussian(iChannel0, fragCoord,R,MIPLVL);\n    //C += T(fragCoord);\n    \n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0);\n    \n    C += gaussian(iChannel0, fragCoord,R,MIPLVL);\n    //C += T(fragCoord);\n    \n    C *= smoothstep(0.,1., pow(length(C.xyz)*3.4, 2.));\n    \n    \n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 138, 138, 1346]], "test": "untested"}
{"id": "ttyXRw", "name": "Capsule tunnel", "author": "rodgzilla", "description": "Travel through capsule land.", "tags": ["glow", "capsule"], "likes": 3, "viewed": 345, "published": 3, "date": "1582389752", "time_retrieved": "2024-07-30T21:22:33.862939", "image_code": "#define time .4 * iTime\n#define ZPOS -30. + 20. * time\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n  p.xy *= rot2d(sin(3. * time) * sin(p.z / 15.));\n  p.xz *= rot2d(sin(.01 * time) * PI);\n  p = rep(p, vec3(5, 5, 5));\n  float d = 5000.;\n  vec3 a1 = vec3(-2, 0, 0);\n  vec3 b1 = vec3(2, 0, 0);\n  vec3 a2 = vec3(0, -2, 0);\n  vec3 b2 = vec3(0, 2, 0);\n  vec3 a3 = vec3(0, 0, -3.);\n  vec3 b3 = vec3(0, 0, 3.);\n  float t = floor(time * .5) + smoothstep(.3, .6, fract(time * .5));\n  a1.xy *= rot2d(t);\n  b1.xy *= rot2d(t);\n  a2.xy *= rot2d(t);\n  b2.xy *= rot2d(t);\n  d = min(d, tube(p, a1, b1, .5));\n  d = min(d, tube(p, a2, b2, .5));\n  d = min(d, tube(p, a3, b3, .5));\n  \n  float t_wave = floor(time) + fract(time);\n  float wave = .5 * sin(t_wave) + .5;\n  vec3 shift = vec3(.2 * sin(time), 0, 0);\n  d = min(d, sph(p + shift, 1.));\n  \n  at += .1 / (.1 + d);\n  \n  return d;\n}\n\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .02 * at * vec3(0, 1., 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(0, 0, ZPOS);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + 2. * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n//  \tfloat dif = light(p);\n  \n//    vec3 col = .2 * dif * glow;\n    vec3 col = .2 * glow;\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 100, 100, 165], [167, 167, 195, 195, 221], [223, 223, 268, 268, 425], [427, 427, 453, 453, 501], [518, 518, 537, 537, 1304], [1334, 1334, 1362, 1362, 1606], [1608, 1608, 1629, 1629, 1776], [1778, 1778, 1799, 1799, 2024], [2027, 2027, 2084, 2084, 2472]], "test": "untested"}
{"id": "3tGSzm", "name": "MyDistortionv2", "author": "Arseny", "description": "2d", "tags": ["2d"], "likes": 4, "viewed": 339, "published": 3, "date": "1582387110", "time_retrieved": "2024-07-30T21:22:34.714660", "image_code": "float rand(float x){\n    x += 0.0007;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat rand_func(float x, float seed){ // from 0 to 1\n    const float freq = 20.;\n    float block = floor(x * freq);\n    float A = rand(block + seed);\n    float B = rand(block + 1. + seed);\n    return mix(A, B, x * freq - block);\n}\n\nvec2 rand(vec2 uv, float seed){\n    seed += 0.01313;\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y * seed)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y * seed)  * 561.5453);\n    return uv;\n}\n\nvec2 cont_rand(vec2 uv, float seed){ // continueous\n    uv += vec2(0.141, 0.123);\n    return vec2(rand_func(seed, rand(uv.x * uv.y * uv.x)), rand_func(seed, rand(uv.x * uv.y * uv.y)));\n}\n\nvec2 uvtransform(vec2 uv, float strength, float seed){ // continueous\n    float clsz = 0.2; // cellsize\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    //vec2 A = mix(rand(nwuv + vec2(0., 0.)  , seed), rand(nwuv + vec2(clsz, 0.)  , seed), (uv - nwuv).x / clsz);\n    //vec2 B = mix(rand(nwuv + vec2(0., clsz), seed), rand(nwuv + vec2(clsz, clsz), seed), (uv - nwuv).x / clsz);\n    //vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    vec2 A = nwuv + vec2(0., 0.) * clsz;\n    A = cont_rand(A, seed);\n    vec2 B = nwuv + vec2(1., 0.) * clsz;\n    B = cont_rand(B, seed);\n    vec2 C = nwuv + vec2(0., 1.) * clsz;\n    C = cont_rand(C, seed);\n    vec2 D = nwuv + vec2(1., 1.) * clsz;\n    D = cont_rand(D, seed);\n    vec2 AB = mix(A, B, (uv - nwuv).x / clsz);\n    vec2 CD = mix(C, D, (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 ans = mix(AB, CD, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nvec2 distortion(vec2 uv, float strength, int power, float seed){\n    for (int i = 0; i < power; i++){\n        uv = uvtransform(uv, strength, seed);\n    }\n    return uv;\n}\n\nvec4 something(vec2 uv){\n    vec2 ans = uvtransform(uv + vec2(0., iTime / 20.), 0.7, iTime);\n    if (abs(ans.y - 0.5 - iTime / 20.) < 0.1){\n        float f = 1. - smoothstep(0., 0.2, abs(ans.y - 0.5 - iTime / 20.));\n        return vec4(f);\n        //return vec4(1.);\n    }\n    return vec4(0.);\n    //ans = (uv - nwuv) / clsz;\n    return vec4(ans, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(rand(uv), .0, .1);\n    fragColor = vec4((distortion(uv, 0.1, 5, iTime / 50.) - uv) / 0.2 + vec2(0.5), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 112], [114, 114, 151, 166, 344], [346, 346, 377, 377, 697], [699, 699, 735, 750, 885], [887, 887, 941, 956, 1994], [1996, 1996, 2060, 2060, 2166], [2168, 2168, 2192, 2192, 2525], [2527, 2527, 2584, 2634, 2940]], "test": "untested"}
{"id": "wtKXzR", "name": "Alien Fuel", "author": "Arseny", "description": "Provide distorded electrycity field", "tags": ["2d", "plasma", "glow"], "likes": 5, "viewed": 424, "published": 3, "date": "1582365425", "time_retrieved": "2024-07-30T21:22:35.742911", "image_code": "#define pi acos(-1.)\n\nvec2 rand(vec2 uv){\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y)  * 561.5453);\n    return uv;\n}\n\nvec2 uvtransform(vec2 uv, float strength){\n    float clsz = 0.01; // cellsize\n    //vec2 nwuv = float(int(uv / clsz)) * clsz;\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    vec2 A = mix(rand(nwuv + vec2(0., 0.)  ), rand(nwuv + vec2(clsz, 0.)  ), (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 B = mix(rand(nwuv + vec2(0., clsz)), rand(nwuv + vec2(clsz, clsz)), (uv - nwuv).x / clsz);\n    vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nconst float freq = 120.;\n\nfloat rand(float x){\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat f(float x){\n    x *= 100.;\n    return (2. + sin(x / 10.)) / (2. + cos(x / 10.)) / 20.;\n}\n\nfloat g(float x){\n    x *= 80.;\n    return pow(\n        (2. + sin(x / 10.)) / (2. + cos(x / 20.))\n    \t, 2.) /\n        2. / 40.;\n}\n\nfloat strange_func(float x){\n    float maxx = pow((exp(1.) - 1.), 0.1);\n    x *= maxx;\n    return (exp(1.) * log(pow(x, 10.) + 1.) / (pow(x, 10.) + 1.)) / \n           (exp(1.) * log(pow(maxx, 10.) + 1.) / (pow(maxx, 10.) + 1.));\n}\n\nfloat res(float x, float t){\n    //x /= iResolution.x;\n    return mix(f(x - 20. * t) + g(x + 30. * t), f(-20. * t) + g(30. * t), strange_func(abs(x - 0.5) * 2.));\n}\n\nvec4 grad(float x){\n    //vec3 col = vec3(200., 0., 200.) / 256.;\n    vec3 col = vec3(68., 27., 85.) / 256.;\n    float cntrblur = 0.005;\n    float bordblur = 0.05;\n    if (abs(x) < cntrblur){\n    \treturn vec4(mix(vec3(1.), col, abs(x) / cntrblur), 1.);\n    } else {\n        return vec4(mix(col, vec3(0.), (abs(x) - cntrblur) / bordblur), 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uvtransform(uv, 0.01);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float t = iTime / 100.;\n    \n    /*fragColor = vec4(\n    \tvec3(sign(mix(A, B, uv.x * 20. - floor(uv.x * 20.)) / 5. - uv.y)),\n        1.\n    );*/\n    \n    vec2 cent = vec2(iResolution.x / iResolution.y / 2., 0.5);\n    float r = 0.1;\n    vec2 cn = uv - cent;\n    float ag = (atan(cn.y, cn.x) + pi) / pi / 2.;// + iTime / 1000.;\n    float y = length(cn) - r;\n    \n    float outr = 0.3;\n    \n    float block = floor(ag * freq);\n    float timeShift = floor(iTime * 8.) * 0.3;\n    float A = rand(block + timeShift);\n    float B = rand(mod(block + 1., freq) + timeShift);\n    \n    if (length(cn) < outr){\n        fragColor = vec4(vec3(\n            1. - smoothstep(-0.01, 0.01, y - res(ag, t))\n        ), 1.);\n    } else {\n        if (res(ag, t) > 0.1){\n            fragColor = grad(mix(A, B, ag * freq - block) / 20. - y + outr);\n        }\n    }\n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    /*fragColor = vec4(vec3(\n        smoothstep(-0.01, 0.01, uv.y - res(uv.x, t))\n    ), 1.);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 41, 41, 326], [328, 328, 370, 370, 1007], [1035, 1035, 1055, 1055, 1096], [1098, 1098, 1115, 1115, 1192], [1194, 1194, 1211, 1211, 1324], [1326, 1326, 1354, 1354, 1556], [1558, 1558, 1586, 1612, 1722], [1724, 1724, 1743, 1789, 2074], [2076, 2076, 2133, 2183, 3348]], "test": "untested"}
{"id": "WtGXRw", "name": "Vector waves", "author": "avin", "description": "visual experiment", "tags": ["2d", "wave", "simplex", "vector"], "likes": 32, "viewed": 666, "published": 3, "date": "1582363105", "time_retrieved": "2024-07-30T21:22:36.982597", "image_code": "#define SIZE 50.\n#define COL1 vec3(32, 43, 51) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 1. / min(iResolution.x, iResolution.y) * SIZE\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n\n    uv.y = uv.y * SIZE;\n    float yid = floor(uv.y);\n    uv.y = fract(uv.y) - .5;\n\n    float mask = 0.;\n\n    for (float ofs = -1.; ofs <= 1.; ofs += 1.) {\n        vec2 iuv = uv + vec2(0., ofs);\n\n        float iid = yid - ofs;\n\n        float fx = snoise(vec3(uv.x * 10. + iid * 100., iid, iTime));\n        float fx2 = snoise(vec3(uv.x * 10. + (iid - 1.) * 100., (iid - 1.), iTime));\n\n        float m = SS(abs(iuv.y + fx), .35);\n        mask = max(mask, m * (fx2 + iuv.y + .5));\n    }\n\n    mask = smoothstep(0., 1., mask * .75);\n\n    vec3 col = mix(COL1, COL2, mask);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 263, 263, 430], [432, 432, 454, 454, 1100], [1102, 1102, 1157, 1157, 1828]], "test": "untested"}
{"id": "WlGSRw", "name": "MyDistortionv1", "author": "Arseny", "description": "2d", "tags": ["2d"], "likes": 1, "viewed": 260, "published": 3, "date": "1582362336", "time_retrieved": "2024-07-30T21:22:37.934053", "image_code": "float rand(float x){\n    return fract(sin(x * 100.) * 43758.5453);\n}\n\nvec2 rand(vec2 uv){\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y)  * 561.5453);\n    return uv;\n}\n\nvec2 uvtransform(vec2 uv, float strength){\n    float clsz = 0.5; // cellsize\n    //vec2 nwuv = float(int(uv / clsz)) * clsz;\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    vec2 A = mix(rand(nwuv + vec2(0., 0.)  ), rand(nwuv + vec2(clsz, 0.)  ), (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 B = mix(rand(nwuv + vec2(0., clsz)), rand(nwuv + vec2(clsz, clsz)), (uv - nwuv).x / clsz);\n    vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nvec2 distortion(vec2 uv, float strength, int power){\n    for (int i = 0; i < power; i++){\n        uv = uvtransform(uv, strength);\n    }\n    return uv;\n}\n\nvec4 something(vec2 uv){\n    vec2 ans = uvtransform(uv + vec2(0., iTime / 20.), 0.7);\n    if (abs(ans.y - 0.5 - iTime / 20.) < 0.1){\n        float f = 1. - smoothstep(0., 0.2, abs(ans.y - 0.5 - iTime / 20.));\n        return vec4(f);\n        return vec4(1.);\n    }\n    return vec4(0.);\n    //ans = (uv - nwuv) / clsz;\n    return vec4(ans, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.y += iTime / 2.;\n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(rand(uv), .0, .1);\n    fragColor = vec4(distortion(uv, 0.1, 100) - vec2(0., iTime / 2.), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 68], [70, 70, 89, 89, 374], [376, 376, 418, 418, 1054], [1056, 1056, 1108, 1108, 1208], [1210, 1210, 1234, 1234, 1558], [1560, 1560, 1617, 1667, 1979]], "test": "untested"}
{"id": "3tVSRh", "name": "Fractured Protophore", "author": "otaviogood", "description": "A variation on an old real-time shader done with my stochastic ray tracer. There's some dead code in this one because I'm doing only ray marching, not ray tracing.", "tags": ["fractal", "raymarch", "stochastic"], "likes": 37, "viewed": 976, "published": 3, "date": "1582354017", "time_retrieved": "2024-07-30T21:22:39.270480", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 c=texture(iChannel0,uv);\n\tfragColor=vec4(sqrt((c.xyz*4096.0) / c.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\n// --------------------------------------------------------------------------\n// 1 for fast GPUs, 0 for slow.\n#define HIGH_QUALITY 0\n// --------------------------------------------------------------------------\n\n// Number of samples per pixel - bigger takes more compute\n#define NUM_SAMPLES 1\n\n#if HIGH_QUALITY\n// Number of times the ray bounces off things before terminating\n#define NUM_ITERS 17\n// Number of times the fractal repeats\n#define RECURSION_LEVELS 5\n#else\n#define NUM_ITERS 7\n#define RECURSION_LEVELS 4\n#endif\n\n\n// ---- general helper functions / constants ----\n#define saturate(a) clamp(a, 0.0, 1.0)\n// Weird for loop trick so compiler doesn't unroll loop\n// By making the zero a variable instead of a constant, the compiler can't unroll the loop and\n// that speeds up compile times by a lot.\n#define ZERO_TRICK max(0, -iFrame)\nconst int BIG_INT = 2000000000;\nconst float PI = 3.14159265;\nconst float farPlane = 64.0;\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n// Find 2 perpendicular vectors to the input vector.\nmat3 MakeBasis(vec3 normal) {\n\tmat3 result;\n    result[0] = normal;\n    if (abs(normal.y) > 0.5) {\n        result[1] = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    } else {\n        result[1] = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    }\n    result[2] = normalize(cross(normal, result[1]));\n    return result;\n}\n\n\n// ---- Random functions use one 32 bit state var to change things up ----\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n// 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n// Check with Math.fround(0xffffff) in javascript.\nconst float invMax24Bit = 1.0 / float(0xffffff);\n\n// This is the main hash function that should produce a non-repeating\n// pseudo-random sequence for 2^31 iterations.\nuint SmallHashA(in uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u ^\n            ((seed*seed) * 4000000007u);\n}\n// This is an extra hash function to clean things up a little.\nuint SmallHashB(in uint seed) {\n    return (seed ^ 2156034509u) * 3699529241u;\n}\n\n// Hash the random state to get a random float ranged [0..1]\nfloat RandFloat() {\n    randomState = SmallHashA(randomState);\n    // Add these 2 lines for extra randomness. And change last line to tempState.\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return float((tempState>>8) & 0xffffffu) * invMax24Bit;\n}\n// Hash the random state to get 2 random floats ranged [0..1]\n// Reduced precision to 16 bits per component.\nvec2 RandVec2() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec2(tempState & 0xffffu,\n                (tempState >> 16) & 0xffffu) / float(0xffff);\n}\n// Hash the random state to get 3 random floats ranged [0..1]\n// Reduced precision to 10 bits per component.\nvec3 RandVec3() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec3((tempState >> 2) & 0x3ffu,\n                (tempState >> 12) & 0x3ffu,\n                (tempState >> 22) & 0x3ffu) / float(0x3ffu);\n}\n\n// Returns a random float from [0..1]\nfloat HashFloat(uint seed) {\n    seed = SmallHashA(seed);\n    return float((seed >> 8) & 0xffffffu) * invMax24Bit;\n}\nvec2 HashVec2(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec2(seed & 0xffffu,\n                (seed >> 16) & 0xffffu) / float(0xffff);\n}\nvec3 HashVec3(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                (seed >> 22) & 0x3ffu) / float(0x3ffu);\n}\nfloat HashFloatI2(ivec2 seed) {\n    uint seedB = SmallHashA(uint(seed.x ^ (seed.y * 65537)));\n    //seedB ^= SmallHashB(uint(seed.y));\n    return float(seedB & 0xffffffu) * invMax24Bit;\n}\n\nvoid SetRandomSeed(in vec2 fragCoord, in vec2 iResolution,\n                  in int iFrame) {\n    uint primex = max(uint(iResolution.x), 5003u);  // This prime is far from any 2^x\n    randomState = uint(fragCoord.x);\n    randomState += uint(fragCoord.y) * primex;\n    randomState += uint(iFrame) * primex * uint(iResolution.y);\n    RandFloat();\n}\n\n// Returns random number sampled from a circular gaussian distribution\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 RandGaussianCircle() {\n    vec2 u = RandVec2();\n    u.x = max(u.x, 0.00000003); // We don't want log() to fail because it's 0.\n    float a = sqrt(-2.0 * log(u.x));\n    return vec2(a * cos(2.0*PI*u.y), a * sin(2.0 * PI * u.y));\n}\n// Randomly sample the lifetime of a ray moving through particles\n// p = prob. of collision with particle per unit distance traveled\nfloat RayLifetime(float p) {\n    if (p < 0.00000003) return farPlane;  // Lower than this and the math seems to fail.\n    float unif = RandFloat();  // uniform(0, 1)\n    // This random shouldn't be allowed to hit 0 because log() is undefined.\n    unif = max(0.00000000000001, unif);\n    // p can't be 0 because log(1) == 0 and it divides by 0. Can't be 1 because log(0) is undefined.\n    p = min(p, .999999);\n    //float g = math.floor(math.log(unif) / math.log(1 - p))  # natural logs\n    // g = number of successes before failure\n    float g = log(unif) / log(1.0 - p);\n    return g;\n}\n\nvec3 HashPointOnSphere(uint seed) {\n    vec2 uv = HashVec2(seed);\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n\n// Random point *ON* sphere\nvec3 RandPointOnSphere() {\n    vec2 uv = RandVec2();\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n// Random point *IN* sphere\n// This is biased!!! About 1/32 of the time, it will return a point in box instead of a sphere.\n/*vec3 RandPointInSphere() {\n    return RandPointOnSphere();\n    vec3 p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    return p;\n}*/\n\n// ---- Environment maps - a few to choose from ----\n// Make a procedural environment map with a giant softbox light and 4 lights around the sides.\nvec3 GetEnvMap3(vec3 rayDir)\n{\n    // Just some basic fades for the background\n    return vec3(rayDir.y*0.5+0.5)*1.25 + vec3(1.0,0.7,0.1)*(rayDir.z*0.5+0.5) + vec3(0.1,0.4,0.61)*(-rayDir.z*0.5+0.5)*0.5;\n\n/*    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);*/\n}\n\nvec3 GetEnvMap2(vec3 rayDir) {\n    //return vec3(0.0);\n    return vec3(rayDir.y*0.5+0.5);// * vec3(1.0, 0.5, 0.7);\n}\n\n// ---- Ray intersection functions and data structures ----\nstruct Ray\n{\n    vec3 p0, dirNormalized;\n    int outside;  // 1 ray is outside, -1 ray is inside, 0 terminate ray tracing iteration\n};\nstruct SceneHit\n{\n    vec3 hitPos;\n    vec3 hitNormal;\n    float pt;  // parametric t variable - how far along the ray vector is the intersection\n    int objIndex;  // unique index per object - used for material tricks like hashing colors\n    int materialIndex;  // Which material are we using\n};\n\n// As the ray bounces, it records hits in these vars.\nstruct ColorHit {\n    vec3 diffuse;\n    vec3 emission;\n};\nColorHit colorHits[NUM_ITERS];\nint colorHitIndex;\nvoid ResetColorHitList() {\n    colorHitIndex = 0;\n    for (int i = 0; i < NUM_ITERS; i++) {\n        colorHits[i].emission.x = -1.0;\n    }\n}\nvoid SaveHit(in vec3 diffuse, in vec3 emission) {\n    colorHits[colorHitIndex] = ColorHit(diffuse, emission);\n    colorHitIndex++;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Return value is normal in xyz, t in w.\n// outside is 1 to intersect from the outside of the sphere, -1 to intersect from inside of sphere.\nvec4 SphereIntersect3(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, int outside)\n{\n    vec4 rh = vec4(farPlane);\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b2 = dot(bv, bv);\n    if (b2 > rad*rad) return rh;  // Ray missed the sphere\n    float x = sqrt(rad*rad - b2);\n    rh.w = projdist - (x * float(outside));\n    vec3 hitPos = pos + dirVecPLZNormalizeMeFirst * rh.w;\n    rh.xyz = normalize(hitPos - spherePos);//*float(outside);//??HACK>>>??  // Normal still points outwards if collision from inside.\n    return rh;\n}\n\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\n// Return value is normal in xyz, t in w.\n// **** rayInv is 1.0 / direction vector ****\nvec4 BoxIntersect(vec3 pos, vec3 rayInv, vec3 boxPos, vec3 rad, int outside)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n//    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tNear = max(vmin.z, max(vmin.x, vmin.y));\n    float tFar = min(vmax.z, min(vmax.x, vmax.y));\n\n    vec4 rh = vec4(0,1,0,farPlane);\n    if ((tFar < tNear)) return rh;\n    if (outside > 0) {\n        if ((tNear <= 0.0)) return rh;\n\t    rh.w = tNear;\n    } else if (outside < 0) {\n        if ((tFar <= 0.0)) return rh;\n\t    rh.w = tFar;\n    }\n\n    // optimize me!\n    if (t1.x == rh.w) rh.xyz = vec3(-1.0, 0.0, 0.0);\n    else if (t2.x == rh.w) rh.xyz = vec3(1.0, 0.0, 0.0);\n    else if (t1.y == rh.w) rh.xyz = vec3(0.0, -1.0, 0.0);\n    else if (t2.y == rh.w) rh.xyz = vec3(0.0, 1.0, 0.0);\n    else if (t1.z == rh.w) rh.xyz = vec3(0.0, 0.0, -1.0);\n    else if (t2.z == rh.w) rh.xyz = vec3(0.0, 0.0, 1.0);\n //\trh.xyz = rh.xyz * float(outside);  // Use this for normal to point inside if hit from inside\n    return rh;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return farPlane;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n\n// ---- Scattering (fog) vars ----\n// Scattering needs a stack because it's all about what you're moving through.\n// So if you move through fog and then through glass, when you come out of the glass,\n// you're back into the fog.\n\n// This is the scatter var for the outer-most place. RGB fog diffuse, fog density.\n// **** Set fog here ****\nconst vec4 globalScatter = vec4(0.3, 0.4, 0.6, 0.005);//.5\n// Scatter stack\nvec4 scatterStack[NUM_ITERS*2];  // Size correct?\nint scatterStackIndex;\nvec4 PeekScatter() {\n    return scatterStack[scatterStackIndex-1];\n}\nvoid PushScatter(in vec4 s) {\n    if (s != PeekScatter())\n    {\n        scatterStack[scatterStackIndex] = s;\n        scatterStackIndex++;\n    }\n}\nvec4 PopScatter(in vec4 s) {\n    if (s != PeekScatter())\n    {\n        scatterStackIndex--;\n        return scatterStack[scatterStackIndex];\n    }\n}\nvoid InitScatterStack(in vec4 s) {\n    scatterStack[0] = s;\n    scatterStackIndex = 1;\n}\n\n// ---- Materials ----\n\n// List of refraction values for different materials\n// Linear reflectance values from http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf\n// In w, refrective index - https://en.wikipedia.org/wiki/List_of_refractive_indices\n// These can be calculated from each other: https://en.wikipedia.org/wiki/Schlick%27s_approximation\nconst vec4 refDebug = vec4(1.0,1.0,1.0, 1.005);\nconst vec4 refNone = vec4(0.0,0.0,0.0, 1.0);\nconst vec4 refWater = vec4(0.02,0.02,0.02, 1.330);\nconst vec4 refPlasticGlassLow = vec4(0.03,0.03,0.03, 1.42);\nconst vec4 refGlassWindow = vec4(0.043,0.043,0.043,1.52);\nconst vec4 refPlasticHigh = vec4(0.05,0.05,0.05, 1.58);\nconst vec4 refGlassHigh = vec4(0.08,0.08,0.08,1.79);  // Ruby\nconst vec4 refDiamond = vec4(0.172,0.172,0.172,2.417);\n// Metals - refractive index is placeholder and shouldn't be used I guess\nconst vec4 refIron = vec4(0.56,0.57,0.58,1.0);\nconst vec4 refCopper = vec4(0.95,0.64,0.54,1.0);\nconst vec4 refGold = vec4(0.995, 0.71, 0.29,1.0);\nconst vec4 refAluminum = vec4(0.91,0.92,0.92,1.0);\nconst vec4 refSilver = vec4(0.95,0.93,0.88,1.0);\nconst vec4 refSimpleMetal = vec4(0.92,0.92,0.92,1.0);  // rgb is same for better performance\n\nstruct Material {\n\tvec4 reflectRefract;\n    float refMult;\n    bool doRefraction;\n    vec3 diffuse;\n    vec3 emission;\n    vec3 filterDiffuseDensity;  // This is like a cheap scatter. Not sure I like it.\n    vec4 scatter;  // Diffuse in xyz, scatter probability in w.\n};\nconst int defaultMaterialIndex = 3;\nconst int NUM_MATERIALS = 7;\nMaterial materials[NUM_MATERIALS] = Material[NUM_MATERIALS](\n    // water (refraction broken, so just glossy black)\n    Material(refWater, 1.0, true, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.1, 0.7, 0.99, 0.0)),\n    // (refraction broken, so just glossy black)\n    Material(refGlassWindow, 1.0, true, vec3(0.0), vec3(0.0), vec3(1.0), vec4(0.99, 0.2, 0.05, 0.001)),\n    //Material(refPlasticGlassLow, 1.0, false, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.0)),\n    // gold\n    Material(refGold, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // colored plastic\n    Material(refPlasticGlassLow, 1.0, false, vec3(0.5,0.8,0.92), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // non-shiny whatever\n    Material(refNone, 1.0, false, vec3(0.5), vec3(0.0), vec3(1.0), vec4(0.0)),\n    // light\n    Material(refNone, 0.0, true, vec3(1.0), vec3(14.0, 12.0, 7.0)*0.1, vec3(0.02), vec4(0.0)),\n    // light\n    Material(refNone, 0.0, false, vec3(1.0), vec3(200.0, 250.0, 300.0), vec3(0.0), vec4(0.0))\n);\n\n// ---- Intersect the ray with the scene, ray-trace style ----\nSceneHit SceneIntersect(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n\n    /*SceneHit poly;\n    poly.pt = 0.0;\n    for (int i = ZERO_TRICK; i <18; i++) {\n        vec3 normal = vec3(0,1,0);\n        float t = iPlane(ray.p0, ray.dirNormalized, vec2(-200.0, 200.0), normal,\n                  HashPointOnSphere(uint(i)), -1.8);\n        if ((t > 0.0) && (t < farPlane) && (t > poly.pt)) {\n            poly.objIndex = 12399+i;\n            poly.materialIndex = 3;// (i&1)*4+1;\n            //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n            poly.pt = t;\n            poly.hitPos = ray.p0 + ray.dirNormalized * t;\n            poly.hitNormal = normal;\n        }\n    }\n    if ((poly.pt < farPlane) && (poly.pt > 0.0)) result = poly;*/\n\n    vec3 rayInv = 1.0 / ray.dirNormalized;\n    vec4 sA = vec4(0.0, 0.0, 0.75, 1.5);\n    for (int i = ZERO_TRICK; i < 1; i++) {\n        sA.xyz = (HashVec3(uint(i+18)) - 0.5) * 0.0;\n        sA.y *= 0.5;\n        //sA.y += 0.5;\n        //sA.xyz += Randf1i1(uint(float(i)+iTime*60.0)) * sA.xyz * 0.93;\n        sA.w =1.6;// (Hashf1(uint(i+23)) + 0.75) * 1.6;\n        float tall = 1.25;\n        //if ((i & 7) == 0) {\n        //    sA.y += 2.0;\n        //    sA.w *= 0.152;\n        //    tall = 8.0*Hashf1i1(uint(i+23));\n        //}\n        vec4 rh = SphereIntersect3(ray.p0, ray.dirNormalized, sA.xyz, sA.w, ray.outside);\n\t\t//vec4 rh = BoxIntersect(ray.p0, rayInv, sA.xyz, vec3(sA.w, sA.w*tall, sA.w), ray.outside);\n        if ((rh.w > 0.0) && (rh.w < result.pt)) {\n            result.objIndex = i+27;//3;// i&3;\n\t\t    result.materialIndex =0;//i+1;//(i&1)*4+1;\n            //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n            result.pt = rh.w;\n            result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n            result.hitNormal = rh.xyz;\n        }\n    }\n    vec4 rh = BoxIntersect(ray.p0, rayInv, vec3(0,-4.5,0), vec3(1.0, 0.1, 1.0), ray.outside);\n    if ((rh.w > 0.0) && (rh.w < result.pt)) {\n        result.objIndex = 1234;\n        result.materialIndex =3;// (i&1)*4+1;\n        //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n        result.pt = rh.w;\n        result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n        result.hitNormal = rh.xyz;\n    }\n    rh = BoxIntersect(ray.p0, rayInv, vec3(0.0,1.95,0.5), vec3(40.0, 0.05, 0.91), ray.outside);\n    if ((rh.w > 0.0) && (rh.w < result.pt)) {\n        result.objIndex = 1235;\n        result.materialIndex = 5;// (i&1)*4+1;\n        //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n        result.pt = rh.w;\n        result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n        result.hitNormal = rh.xyz;\n    }\n//    IntersectBoxes(vec4(0.0,0.0,0.0,1.0), ray.p0, ray.dirNormalized, ray.outside, result, 0);\n\n    return result;\n}\n\n// ---- Also support ray marching, not just ray tracing. ----\n// k should be negative. -4.0 works nicely.\n// smooth blending function\n//float smin(float a, float b, float k)\n//{\n//\treturn log2(exp2(k*a)+exp2(k*b))/k;\n//}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        // rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);\n#endif\n        // main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        // subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        // calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        // subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        // make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t// 1/sqrt(2) to keep distance field normalized\n        float fin = -(abs(ap.x-ap.y) - finWidth);\n        fin = max(fin, -(abs(ap.y-ap.z) - finWidth));\n        fin = max(fin, -(abs(ap.z-ap.x) - finWidth));\n        //subtracter = max(subtracter, fin);\n        // subtract sphere from fins so they don't intersect the inner spheres.\n        // also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        // smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t// recurse\n        // do a material-min with the last iteration\n        final = matmin(final, vec2(d, float(i)));\n        final = matmax(final, vec2(fin, 2.0));\n        //float temp = length(p) - radius*0.3*outness;\n        //final = matmin(final, vec2(temp, 5.0));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25/blender);\n#endif\n        // Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        // Scale things for the next iteration / recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    // Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matmin(final, vec2(d, 2.0));\n    return final;\n}\n\n// This is the distance function that defines the ray marched scene's geometry.\n// The input is a position in space.\n// outside is 1 if the ray is intersecting with the outside of objects, -1 for insides (backface)\n// The output is the distance to the nearest surface, and a material index\nvec2 DistanceToObject(vec3 p, int outside)\n{\n\t//float d = length(p) - 4.0;\n    //return vec2(d, 1.0);\n    vec2 distMat = sphereIter(p, 5.2 / outness, cut);\n    return distMat;\n}\n\nSceneHit SceneMarch(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    //result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    vec2 distAndMat = vec2(0.0, -1.0);  // Distance and material\n\t// ----------------------------- Ray march the scene ------------------------------\n\tconst float maxDepth = 28.0; // farthest distance rays will travel\n    const float smallVal = 0.0625*0.125*0.0625;\n\tresult.pt = 0.0;\n    const float safety =1.0;// 0.975;\n    // First, escape if we are touching a surface already.\n    // Get the ray out of the negative part of the distance field. (rough hack)\n    float jump = smallVal;\n    for (int i = ZERO_TRICK; i < 16; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        if (abs(distAndMat.x) >= smallVal) break;\n        // move down the ray a safe amount\n        result.pt += jump;//safety;//* float(ray.outside);\n        //result.pt += distAndMat.x*2.0;//safety;//* float(ray.outside);\n        jump *= 2.0;  // This is not super good. Fix me eventually.\n        if (result.pt > maxDepth) break;\n    }\n\t// ray marching time\n    for (int i = 300; i >= 0; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if (abs(distAndMat.x) < smallVal) break;\n        // move down the ray a safe amount\n        result.pt += distAndMat.x*safety;\n        if (i == 0) result.pt = maxDepth+0.01;\n        if (result.pt > maxDepth) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// If a ray hit an object, calculate the normal and save the hit info.\n    if ((result.pt <= maxDepth) && (result.pt > 0.0))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        // Normals still point out even if we're on the inside.\n        //float mid = DistanceToObject(result.hitPos, 1).x;\n        //vec3 normalU = vec3(mid - DistanceToObject(result.hitPos - smallVec.xyy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yxy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yyx, 1).x);\n        vec3 normalU = vec3(0.0);\n        for( int i=min(0,iFrame); i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            normalU += e*DistanceToObject(result.hitPos+smallVal*e, 1).x;\n        }\n        result.hitNormal = normalize(normalU);\n        result.objIndex = int(distAndMat.y);\n        result.materialIndex = int(distAndMat.y);\n\t}\n    else\n    {\n        // Our ray trace hit nothing. Set object index to big int.\n        result.hitNormal = vec3(0.0);\n        result.pt = farPlane;\n        result.objIndex = BIG_INT;\n        result.materialIndex = BIG_INT;\n    }\n    return result;\n}\n\n// ---- Main ray trace function ----\n// Trace a ray, hit, apply material, save hit, and return the bounced ray\nRay TraceOneRay(const in Ray ray) {\n    vec3 diffuse = vec3(1.0);\n    vec3 emission = vec3(0.0);\n\n    // Send a ray out into the scene. Combine both ray marching and ray tracing.\n    Ray newRay;\n    newRay.outside = ray.outside;\n    SceneHit resultA = SceneIntersect(ray);\n    SceneHit resultB = SceneMarch(ray);\n    SceneHit result;\n    // Take closest hit.\n    if (resultA.pt < resultB.pt) {\n        result = resultA;\n    } else {\n        result = resultB;\n    }\n    result = resultB;// ***** HACK GOT RID OF RAY TRACING... *****\n\n    vec4 currentScatter = PeekScatter();\n    Material material = materials[result.materialIndex % materials.length()];\n    // Calculate how far the ray goes before hitting a random scattering particle.\n    float lifetime = RayLifetime(currentScatter.w);\n    // If we hit an object instead of a scatter-particle or the far-plane...\n    if (result.pt < min(farPlane, lifetime)) {\n\n        // Debug normal visualization\n        //emission = result.hitNormal * 0.5 + 0.5;\n        //newRay.outside = 0;\n        //SaveHit(diffuse, emission);\n        //return newRay;\n\n        //mat3 basis = MakeBasis(result.hitNormal);\n        newRay.p0 = result.hitPos;\n\n        vec4 refMaterial = material.reflectRefract;\n        float reflectance = material.refMult;\n        float fresnel = refMaterial.z;\n        // If reflectance is different for different wavelengths, then let's change from\n        // rgb to r, g, or b stochastically while not losing energy. So we will end up\n        // tracing a ray representing a single wavelength of light.\n        // This can be done unconditionally because if xyz are the same, it doesn't matter anyway.\n        float choice = RandFloat();\n        if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) {\n            // If we have already split to single wavelength, don't do it again.\n            /*if ( ((refMaterial.x == 0.0) && (refMaterial.y == 0.0)) ||\n                ((refMaterial.y == 0.0) && (refMaterial.z == 0.0)) ||\n                ((refMaterial.z == 0.0) && (refMaterial.x == 0.0)) ) {\n                // Take the non-zero component as the fresnel value.\n                fresnel = dot(refMaterial.xyz, vec3(1.0));\n            } else {\n                // .333 chance of switching to each single channel - r, g, or b.\n                if (choice < 0.33333) {\n                    fresnel = refMaterial.x;\n                    diffuse *= vec3(1.0, 0.0, 0.0);\n                } else if (choice < 0.66666) {\n                    fresnel = refMaterial.y;\n                    diffuse *= vec3(0.0, 1.0, 0.0);\n                } else diffuse *= vec3(0.0, 0.0, 1.0);\n                diffuse *= 3.0;  // To make up for stochastically dropping 2 out of 3 channels\n            }*/\n            fresnel = max(max(refMaterial.x, refMaterial.y), refMaterial.z);\n            diffuse *= refMaterial.xyz / fresnel;\n        }\n        // Figure out if we should reflect, or if the ray should go into the object (diffuse or refraction)\n        // Schlick's approximation\n        float oneMinusCos = 1.0 - saturate(dot(ray.dirNormalized, -result.hitNormal* float(ray.outside)));\n        float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n        reflectProb *= reflectance;\n        if (RandFloat() < reflectProb) {\n\t        //if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) diffuse *= refMaterial.xyz * fresnel;\n            // reflect\n\t        vec3 reflection = reflect(ray.dirNormalized, result.hitNormal);// * float(ray.outside));\n            newRay.dirNormalized = normalize(reflection);\n            // Already did the probability of reflection before, so no need to multiply anything.\n            //diffuse *= vec3(1.0);\n        } else {\n            //if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) diffuse *= 1000000.0;\n            if (material.doRefraction) {\n                // refract\n                float refractionIndex = 1.0 / refMaterial.w;  // 1.33 is water, 1.5 is glass.\n                if (ray.outside == -1) refractionIndex = 1.0 / refractionIndex;\n\n                vec3 refraction = refract(ray.dirNormalized, result.hitNormal * float(ray.outside), refractionIndex);\n                if (dot(refraction, refraction) > 0.0) {\n                    // Standard refraction\n\t                newRay.dirNormalized = normalize(refraction);\n                } else {\n                    // Special case - total internal reflection.\n                    // This is where at glancing angles, the surface will act like a mirror.\n                    // It's what makes fiber optics work. :D\n                    vec3 reflection = reflect(ray.dirNormalized, result.hitNormal * float(ray.outside));\n                    newRay.dirNormalized = normalize(reflection);\n                }\n                if (ray.outside == 1) {\n                    PushScatter(material.scatter);\n                } else {\n                    PopScatter(material.scatter);\n                }\n                newRay.outside = -ray.outside;\n            } else {\n                // Diffuse light\n                // Get a random vector in the hemisphere pointing along the normal.\n\t            vec3 rand = RandPointOnSphere();\n                vec3 bounce = rand * sign(dot(result.hitNormal, rand));\n                newRay.dirNormalized = bounce;\n                // Lambert shading model\n                //float intensity = dot(bounce, result.hitNormal);\n                diffuse *= material.diffuse;// * intensity;\n                emission = material.emission;\n            }\n\n        }\n    } else {\n        if (lifetime < farPlane) {\n            // Scattering (fog)\n            newRay.p0 = ray.p0 + ray.dirNormalized * lifetime;\n            newRay.dirNormalized = RandPointOnSphere();\n            diffuse *= currentScatter.xyz;\n            //emission = material.emission;\n        } else {\n            // Hit the background image. Let's be done ray tracing.\n            emission = GetEnvMap3(ray.dirNormalized);\n            newRay.outside = 0;  // This terminates the ray.\n        }\n    }\n    // Filtering\n    // Filter proportional to how long the ray moves inside the object\n    // This can also be done with scattering, but this should converge quicker.\n    if (ray.outside == -1) {\n        vec3 internal = material.filterDiffuseDensity.xyz;\n        diffuse *= pow(internal, vec3(abs(result.pt)));\n        emission = material.emission * pow(internal, vec3(abs(result.pt)));\n    }\n\n    // Save the ray hit in a list so we can calculate color of the pixel later on.\n    SaveHit(diffuse, emission);\n    return newRay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetRandomSeed(fragCoord.xy, iResolution.xy, iFrame);\n    vec2 position = (gl_FragCoord.xy / iResolution.xy);\n    // read original buffer so we can accumulate pixel values into back it.\n\tvec4 backpixel = texture(iChannel0, position);\n    // If we use the mouse to change the view, reset the pixel accumulation buffer\n    if (iMouse.z > 0.0) backpixel = vec4(0.0);\n\n\t// ----------------------------------- Animate ------------------------------------\n    float localTime = 3.99;// iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv_orig = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.4;\n    vec2 uv = uv_orig / zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\n\t//vec3 camLookat=vec3(0,0.91,0);\n\n    // camera orbit with mouse movement\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n\tvec3 camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(16.0);\n    // If mouse is in bottom left corner, then use pre-set camera angle.\n    //if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-4.0, 0.1, 7.1);\n    if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-7.0, 6.6, 7.0)*1.25;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\n    // Depth of field hack... I think the math is all wrong.\n    const float depthOfFieldAmount = 0.0003;\n    vec2 rg = RandGaussianCircle()*depthOfFieldAmount;\n    camPos += sideNorm * rg.x;\n    camPos += upNorm * rg.y;\n    camVec=normalize(camLookat - camPos);\n    sideNorm=normalize(cross(upNorm, camVec));\n    upNorm=cross(camVec, sideNorm);\n\n    // More camera setup\n    vec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// --------------------------------------------------------------------------------\n    vec3 colorSum = vec3(0.0);\n    // Loop through for a few samples and average the pixel colors from ray tracing.\n    for (int s = ZERO_TRICK; s < NUM_SAMPLES; s++) {  // Weird for loop trick so compiler doesn't unroll loop\n        InitScatterStack(globalScatter);\n        ResetColorHitList();\n        Ray ray;\n        ray.outside = 1;\n        ray.p0 = camPos;\n        // Anti-aliasing: Randomly jitter the ray direction by a gaussian distribution.\n        vec2 gauss = RandGaussianCircle();\n        float antialias = dFdx(uv.xy).x/1.5;\n        ray.dirNormalized = normalize(rayVec +\n                                      sideNorm*gauss.x*antialias +\n                                      upNorm * gauss.y*antialias);\n\n        // Trace a ray from the camera outwards, bounce the ray off objects and keep\n        // tracing until NUM_ITERS or until it hits the background.\n        for (int i = ZERO_TRICK; i < NUM_ITERS; i++) {\n            if (i == (NUM_ITERS-1)) break;\n            ray = TraceOneRay(ray);\n            if (ray.outside == 0) break;\n        }\n        /*int i = 0;\n        do {\n            ray = TraceOneRay(ray);\n            i++;\n        } while ((ray.outside != 0) && (i < NUM_ITERS-1));*/\n\n        // Once we're done iterating through rays from the camera outwards, we have a\n        // list of hits. Now we can go from the light source toward the camera and apply\n        // the color filters and emissions as we go.\n\t    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n        for (int i = NUM_ITERS-1; i >= ZERO_TRICK; i--) {\n            if (colorHits[i].emission.x != -1.0) {\n                finalColor.xyz *= colorHits[i].diffuse;\n                finalColor.xyz += colorHits[i].emission;\n                //finalColor.xyzw = finalColor.yzwx;  // Debug ray depth\n            }\n        }\n        colorSum += finalColor.xyz;\n    }\n    colorSum /= float(NUM_SAMPLES);\n\n    // output the final color\n\tfragColor = vec4(saturate(colorSum/4096.0),1.0) + backpixel;\n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSRh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1087, 1087, 1143, 1143, 1264]], "test": "untested"}
{"id": "ttVXzD", "name": "Triangulated Actors**", "author": "wyatt", "description": "Triangulated particle simulation ", "tags": ["particles", "triangulation"], "likes": 31, "viewed": 800, "published": 3, "date": "1582353667", "time_retrieved": "2024-07-30T21:22:40.155114", "image_code": "// Fork of \"Triangulated Actors*\" by wyatt. https://shadertoy.com/view/ttdXDB\n// 2020-02-22 04:42:08\n\n\nMain {\n    vec4 b = B(U),\n         a = A(b.xy), aa = A(b.zw);\n    \n    \tvec2 bb = floor(b.xy/10.+0.5)*10.;\n        bb = clamp(bb,vec2(30),R-30.)/R;\n    float o = length(U-a.xy),\n          w = sg(U,a.xy,aa.xy),\n          v = pie(U,a.xy,aa.xy);\n    Q = .7-vec4(exp(-w-0.1*(v+1.)*length(aa.xy-a.xy)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "// Information Storage\nMain {\n\tQ = A(U);;\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++)\n    Q.zw += C(Q.xy+vec2(x,y)).xy;\n    vec2 v = Q.zw;\n    float V = length(v);\n    v = v*sqrt(V*V/(1.+V*V));\n    //if (length(v)>0.)v = normalize(v);\n    Q.xy += v;\n    \n    if (Q.x<2.)Q.x=2.;\n    if (Q.y<2.)Q.y=2.;\n    if (R.x-Q.x<2.)Q.x=R.x-2.;\n    if (R.y-Q.y<2.)Q.y=R.y-2.;\n\n    \n    if (init)\n    {\n    \tU = floor(U/5.+0.5)*5.;\n        U = clamp(U,vec2(40),R-40.);\n        Q = vec4(U,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<=la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n    float pn = pie(U,a.xy,n.xy), \n          pa = pie(U,a.xy,aa.xy);\n    if (pn<=pa){\n        aa = n;\n        Q.zw = b.xy;\n    }\n\tn = A(b.zw);\n    ln = length(n.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.zw;\n        a.xy = n.xy;\n    }\n    pn = pie(U,a.xy,n.xy);\n    if (pn<pa){\n        aa = n;\n        Q.zw = b.zw;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, float r) {\n\t X(Q,a,aa,U,vec2(r,0));\n     X(Q,a,aa,U,vec2(0,r));\n     X(Q,a,aa,U,vec2(0,-r));\n     X(Q,a,aa,U,vec2(-r,0));\n    \n}\nMain {\n\tQ = B(U);\n    vec4 a = A(Q.xy), aa= A(Q.zw);\n    Xr(Q,a,aa,U,1.);\n    Xr(Q,a,aa,U,2.);\n    Xr(Q,a,aa,U,3.);\n    Xr(Q,a,aa,U,4.);\n    Xr(Q,a,aa,U,5.);\n    Xr(Q,a,aa,U,6.);\n   \tInit {\n        Q.xy = U;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE FORCE FIELD\nMain {\n\tvec4 b = B(U);\n\tvec4 a = A(b.xy), aa = A(b.zw);\n\tvec2 r = a.xy-aa.xy;\n\tfloat l = length(r);\n   \tvec2 v = vec2(0);\n\tfloat f = 0.;\n    if (length(a.xy-aa.xy)>0.&&length(aa.zw-a.zw)>0.) f = abs(dot(normalize(a.xy-aa.xy),normalize((aa-a).zw)));\n    if (l>0.&&length(a.xy-aa.xy)>4.42) v = \n        -1.*r/l/l+\n       \t50.*f*(aa-a).zw/max(.1,l*l*l*l);\n       ;\n    if (a.x<20.) v.x += .02;\n    if (R.x-a.x<20.) v.x -= .02;\n    if (a.y<20.) v.y += .02;\n    if (R.y-a.y<20.) v.y -= .02;\n    Q.xy = 3e-2*v;\n    if (iMouse.z>0.&&length(a.xy-iMouse.xy)>0.) Q.xy += clamp(0.03*(a.xy-iMouse.xy)/dot((a.xy-iMouse.xy),(a.xy-iMouse.xy)),-2e-4,2e-4);\n\tif (iFrame < 10) Q.xy += 3e-2*(U-0.5*R)/dot(U-0.5*R,U-0.5*R);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtKSRz", "name": "Up in flames", "author": "BigWIngs", "description": "For an upcoming video tutorial on The Art of Code", "tags": ["fire", "heat", "gyroid", "artofcode", "embers"], "likes": 46, "viewed": 1954, "published": 3, "date": "1582329701", "time_retrieved": "2024-07-30T21:22:41.262155", "image_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// https://youtu.be/-adHIyjIYgk\n//\n// See common tab for tweakable values.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord)/iResolution.xy;\n\tvec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n\tfloat t = iTime;\n   \n    float depth = texture(iChannel0,uv).w;\n   \t\n    depth = smoothstep(.0, .1, depth-.92)*(sin(t*.3)*.5+.5);\n    //depth = 0.;\n    \n    vec3 col = dof(iChannel0,uv,depth*1.2, iResolution.xy);\n    col *= col*EXPOSURE;\n    uv -= .5;\n    col *= 1.-dot(uv, uv)*VIGNETTE;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n\n\nfloat Gyroid(vec3 p, float scale, float bias, float thickness) {\n    p *= scale;\n    float d = abs(dot(sin(p), cos(p.yzx))+bias)-thickness;\n\treturn d/scale;\n}\n\nvec4 GetGyroids(vec3 p) {    \n    float t = iTime*.1;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., .4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, -7., .3, .1);\n    \n    return vec4(g1, g2, g3, g4);              \n}\n\nfloat GetDist(vec3 p) {\n\tfloat d = p.y;\n    p.x+=.33;\n    \n    float t = iTime*.1;\n    float scale = 20.;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., 1.4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, 89., .3, .1);\n    float g5 = Gyroid(p, 189., .3, .1);\n    float g6 = Gyroid(p, 289., .0, .1);\n    \n    d = g1*.7;\n    d -= g2*.3;\n    d += g3*.2;\n    d += g4*.1;\n    d += g5*g4*20.;\n    d += g6*.1;\n    \n   \tvec3 P = p;\n    P.xz = fract(P.xz)-.5;\n    vec2 id = floor(p.xz);\n    float n = Hash21(id);\n    //P = fract(P)-.5;\n    \n    \n    return d;              \n}\n\nfloat sdSpark(vec3 p) {\n    float t = iTime*.5;\n    \n    p.xz *= Rot(t*.1);\n    \n    vec3 id = floor(p);\n    p.xz = fract(p.xz)-.5;\n    \n    float n = Hash21(id.xz);\n    \n\tfloat z = fract(t+n)-.5;\n   \tz *= 10.;\n    \n    n *= 6.2832;\n    float size = .3+.2*sin(t*.1);\n    vec3 p1 = vec3(0, z-size*1., 0);\n    vec3 p2 = vec3(0, z+size*1., 0);\n    \n    p.x += sin(p.y*3.)*.1;\n    \n    float d = sdCapsule(p, p1, p2, size*.1);\n    \n    d = min(d, length(p.xz)+size*2.);\n    \n    return d;\n}\n\nvec2 SparkMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = sdSpark(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetSparkNormal(vec3 p) {\n\tfloat d = sdSpark(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sdSpark(p-e.xyy),\n        sdSpark(p-e.yxy),\n        sdSpark(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z, vec3 up) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 GetPos(float t) {\n    float y = .6+cos(t)*.2;\n\treturn mix(vec3(-.3, y, t), vec3(2.2, y, t), (sin(t)*.5+.5)*1.);\n}\n\nvec3 Bg(vec3 rd) {\n    float b = -rd.y*.5+.5;\n\tvec3 col = vec3(.9, .6, .5)*b*4.;\n    \n    float a = atan(rd.x, rd.z);\n    \n    //col += sin(a*10.+iTime)*(1.-rd.y);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n\tfloat t = iTime;\n   \n    vec2 heat=sin(vec2(.123, .234)*t*30.+uv*40.+vec2(0,t*10.));\n    //heat *= uv.y+.5;\n    float c = (sin(t*.1)*.5+.5);\n   \n    #ifndef ABSTRACT\n    c = .1;\n    #endif\n    \n   //c=.9;\n    uv += heat*.02*(c*c*c*c+.1);\n    \n    \n    vec3 ro = vec3(0, 0, .01);\n    ro.yz *= Rot(m.y*3.14*.25+.25);\n    ro.xz *= Rot(-m.x*6.2831+t*.1);\n   \n   // ro = GetPos(t*0.);\n    vec3 up = vec3(0,1,0);\n    //up.xy *= Rot(sin(t)*.4);\n    vec3 lookat = vec3(0,0,0);\n    \n    float zoom = mix(.7, 1.7, sin(t*.15)*.5+.5);\n    vec3 rd = R(uv, ro, lookat, zoom, up);\n\n    float d = RayMarch(ro, rd).x;\n    \n    vec3 bg = Bg(rd);\n    vec3 col = vec3(0.);\n\t\n    if(d<MAX_DIST) {\n        \n        vec3 p = ro + d*rd;\n        vec3 n = GetNormal(p);\n       \n        float dif = n.y*.5+.5;\n        \n        vec4 g = GetGyroids(p);\n        \n        col += dif;\n        col *= min(1., g.y*20.);\n        //col *= .1;\n        \n        float lava = S(.01-min(0., p.y*.1), -.01, g.y);\n        lava *= sin(g.z*100.+t)*.5+.5;\n       // lava += S(-.7, -1., n.y);\n        \n        \n        float flicker = Gyroid(p-vec3(0,t,0), 5., 0., .1);\n        flicker *= Gyroid(p-vec3(.2,.5,0)*t, 5., 0., .1);\n        \n        col *= sin(t*.2)*.5+.5; \n        col += flicker*10.*vec3(1., .4, .1);//*S(.01,.0, g.y);\n        \n        col += lava*vec3(1., .5, .1);\n        \n    }\n    col = mix(col, bg, S(0., 7., d));\n    \n    \n    float dSpark = SparkMarch(ro, rd).x;\n    \n    \n    if(dSpark<MAX_DIST && dSpark<d) {\n        //col += 1.;\n        \n        vec3 p = ro+rd*dSpark;\n        vec3 n = GetSparkNormal(p);\n        n = normalize(n*vec3(1,0,1));\n        \n        float f = max(0., dot(rd, -n));\n        float fade = 1.-pow(f, 5.);\n        fade = .05/fade;\n        fade *= S(.0, 1., f);\n        col += fade;\n        //col += 1.;\n    }\n    \n    \n    \n    fragColor = vec4(col,d);\n}", "buffer_a_inputs": [{"id": 21234, "src": "https://soundcloud.com/lucaslinsds/natural-sounds-wood-burning", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}, {"id": 21236, "src": "https://soundcloud.com/cubicolor/8-once-around?in=cubicolor/sets/hardly-a-day-hardly-a-night", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n\n// Not necessary unless you define ABSTRACT in common tab\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 old = texture(iChannel0, uv);\n    vec4 new = texture(iChannel1, uv);\n    \n    float fade = 1.;\n    \n    #ifdef ABSTRACT\n    fade = (sin(iTime*.07)*.48+.52);\n    #endif\n    \n    fragColor = mix(old, min(new,1.), fade);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n// uncomment this for some extra periodic 2d fuckery ;)\n//#define ABSTRACT\n\n#define VIGNETTE 1.\n#define EXPOSURE 1.3\n#define DOF_SAMPLES 40\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n// Dave Hoskins hash without sine\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.23,234.34));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y);\n}\n\nfloat Hash31(vec3 p) {\n\tp = fract(p*vec3(123.23,234.34,345.54));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y*p.z);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// DOF function borrowed from XT95\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad, vec2 iResolution)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<DOF_SAMPLES;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(DOF_SAMPLES);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[477, 477, 534, 534, 960]], "test": "untested"}
{"id": "wtKXRD", "name": "Wellons triple32 hash - 1x vs 4x", "author": "ttg", "description": "Testing uint vs. uvec4 performance of [url]https://www.shadertoy.com/view/WttXWX[/url]\n1200x675 window,\n\nNtriple32(512,(x).r) : 29 fps  (1x hash)\nu4Ntriple32_{A,B} (512,x) : 20 fps  (4x hash)\nu4Ntriple32_C(512,x) : 18 fps  (4x hash)", "tags": ["performance", "hash"], "likes": 6, "viewed": 489, "published": 3, "date": "1582328155", "time_retrieved": "2024-07-30T21:22:42.124848", "image_code": "// testing 4x hash performance from https://www.shadertoy.com/view/WttXWX\n// --- triple32 from Chris Wellons https://nullprogram.com/blog/2018/07/31/\n\n        // --- choose one:\n  #define hashi(x)   Ntriple32(512,(x).r)\n//  #define hashi(x)   u4Ntriple32_A(512,x)\n//  #define hashi(x)   u4Ntriple32_B(512,x)\n//  #define hashi(x)   u4Ntriple32_C(512,x)\n\n  #define hash(x)  ( vec4( hashi(x) ) / vec4( 0xffffffffU ) )\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuvec4 u4triple32(uvec4 x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuint Ntriple32(int N, uint x) {\n    for (int i=0; i<N; i++) {\n        x = triple32(x);\n    }\n    return x;\n}\n\nuvec4 u4Ntriple32_A(int N, uvec4 x) {\n    for (int i=0; i<N; i++) {\n        x = u4triple32(x);\n    }\n    return x;\n}\n\nuvec4 u4Ntriple32_B(int N, uvec4 x) {\n    for (int i=0; i<N; i++) {\n        x.x = triple32(x.x);\n        x.y = triple32(x.y);\n        x.z = triple32(x.z);\n        x.w = triple32(x.w);\n    }\n    return x;\n}\n\nuvec4 u4Ntriple32_C(int N, uvec4 x) {\n    x.x = Ntriple32(N,x.x);\n    x.y = Ntriple32(N,x.y);\n    x.z = Ntriple32(N,x.z);\n    x.w = Ntriple32(N,x.w);\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    uvec2 V = uvec2(U);\n    //float h = hash( V.x + hashi(V.y) ); // clean 2D hash\n    vec4 h = hash( uvec4(0,1,2,3)*1000000u + V.x + (V.y<<16) );  // 2D hash (should be ok too )\n    O = vec4( h );\n  //O = vec4( pow( h, 1./2.2) );        // sRGB conversion\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 472, 495, 495, 649], [651, 651, 678, 678, 832], [834, 834, 865, 865, 942], [944, 944, 981, 981, 1060], [1062, 1062, 1099, 1099, 1267], [1269, 1269, 1306, 1306, 1434], [1436, 1436, 1474, 1474, 1733]], "test": "untested"}
{"id": "tlVSRW", "name": "Light  Excursion", "author": "butadiene", "description": "Light  Excursion", "tags": ["raymarching", "particle"], "likes": 13, "viewed": 658, "published": 3, "date": "1582309618", "time_retrieved": "2024-07-30T21:22:43.043392", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col =\ttexture( iChannel0, uv ).xyz;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.141592;\n\nvec2 rot(vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn m*p;\n}\n\n\nfloat rand(vec2 st){\n\treturn fract(sin(dot(st,vec2(12.3456,78.9012)))+45678.9012);\n}\n\nfloat noise(vec2 st){\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\tfloat a = rand(i+vec2(0.0,0.0));\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\treturn mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.y*u.x;\n}\n\nfloat fbm(vec2 st){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100.);\n\tfor(int i = 0;i<5;i++){\n\t\tv = noise(st)*a;\n\t\tst = rot(st*2.,0.5)+shift;\n\t\ta*=0.5;\n\t}\n\treturn v;\n}\n\nvec3 hsv(float h,float s,float v){\n\treturn ((clamp(abs(fract(h+vec3(0.0,1.0,2.0)/3.0)),0.0,1.0)-1.0)*s+1.0)*v;\n}\n\nvec2 pmod(vec2 p,float r){\n\tfloat a = atan(p.x,p.y)+PI/r;\n\tfloat n = 2.0*PI/r;\n\ta = floor(a/n)*n;\n\treturn rot(p,-a);\n}\n\nfloat cylin(vec3 p,float r,float s){\n\tfloat ra = length(p.xy)-r;\n\tfloat kz = abs(p.z)-s;\n\treturn length(max(vec2(ra,kz),0.0))-min(max(-ra,0.0),max(-kz,0.0));\n}\nvec4 dist(vec3 p){\n\tp.y += 0.2+sin(iTime)*0.;\n\tp.zy = rot(p.zy,0.3*p.z+sin(iTime*1.2)*0.1);\n\tp.zx = rot(p.zx,0.3*p.z+cos(iTime*0.9)*0.1);\n\t//p.y -=0.2;\n\tfloat kn = 0.3;\n\tfloat kt = 0.01;\n\tp.xy = rot(p.xy,iTime*0.2);\n\tp.xyz += 5.*(vec3(fbm(p.xz*kn+10.+iTime*kt),0.1*fbm(p.xz*kn+p.y*+10.),fbm(p.zx*kn-iTime*kt)));\n\tp.z += iTime;\n\n\tp.xy  = pmod(p.xy,6.0);\n\n\tfloat k = 0.5;\n\tp.z = mod(p.z,k)-0.5*k;\n\tfloat id = floor(p.z/k-0.5*k);\n\tvec2 sid = vec2(0.0);\n\tfor(int i = 0;i<8;i++){\n\t\tsid += 0.5*(sign(p.xy)+1.0)*pow(2.0,float(i)+1.0);\n\t\tp.xy = abs(p.xy)-0.1+0.02*(rand(vec2(float(i)+id))-0.5);\n\t}\n\tfloat d = cylin(p,0.004,0.1);\n\tfloat h = rand(sid+id);\n\treturn vec4(hsv(h,1.0,1.0),d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.xy;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    p.y *= iResolution.y/iResolution.x;\n\tvec3 se = 1.0*vec3(0.5,0.0,0.0);\n\tvec3 ta = vec3(-0.3,0.0,0.0)+se;\n\tfloat ra = 0.1;\n\tfloat kt = iTime*0.0;\n\tvec3 ro = vec3(0.0,0.0,1.0)+se;\n\t//ro +=\n\tvec3 cdir = -normalize(ro-ta);\n\tvec3 up = vec3(0.0,1.0,.0);\n\tvec3 side = cross(cdir,up);\n\tup = cross(side,cdir);\n\tfloat fov = 1.0;\n\tvec3 rd = normalize(fov*cdir+p.y*up+p.x*side);\n\tfloat t  = 0.01;\n\tfloat d = 0.0;\n\tvec3 ac= vec3(0.0);\n\t\tfor(int i = 0;i<69;i++){\n\t\t\tvec4 c = dist(ro+rd*t);\n\t\td = c.w;\n\t\tt +=d;\n\t\tac += c.xyz*exp(abs(d)*-18.);\n\t}\n\tvec3 col = vec3(0.0);\n\tcol = vec3(ac*0.08);\n\tcol *= vec3(0.6,1.0,1.0);\n\tvec3 bcol =  texture( iChannel0,uv).xyz;\n\tcol = mix(bcol,col,0.3);\n\tfragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 283]], "test": "untested"}
{"id": "WlKXRW", "name": "Day 64", "author": "jeyko", "description": "yo, code is pretty messy", "tags": ["mdtmjvm"], "likes": 25, "viewed": 791, "published": 3, "date": "1582303821", "time_retrieved": "2024-07-30T21:22:43.830288", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 10.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,5.)*0.4;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*3.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.2;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.2);\n    \n    fragColor = max(fragColor, 0.);\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.5,1. + sin(iTime)*0.2,1. - cos(iTime)*0.4));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n", "buffer_a_code": "// Fork of \"Day 62\" by jeyko. https://shadertoy.com/view/wtySRh\n// 2020-02-21 08:51:00\n\n\nvec3 glow = vec3(0);\nvec3 glowG = vec3(0);\nvec3 glowB = vec3(0);\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define pi acos(-1.)\n#define tau (2.*pi)\n//#define mx (iTime*(0.8 )+ sin(iTime*2.)*0.4 + 20.*iMouse.x/iResolution.x)\n//#define mx (iTime*(0.6 )+ sin(iTime*2.)*0.3 + 20.*iMouse.x/iResolution.x)\n\n#define mx (   iTime*(0.6 )+ sin(iTime*1.)*0.2 + 20.*iMouse.x/iResolution.x)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    uv *= 0.8;\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define modD  (1.)\n#define dmin(a,b) a.x < b.x ? a : b\n\nfloat zid = 0.;\nvec3 pp = vec3(0);\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    \n    p.xz = pmod(p.xz, modD);\n    \n    vec3 q = p;\n    \n    #define ceilH 0.5\n    float ceils = p.y + ceilH;\n    ceils = min(ceils, -p.y + ceilH);\n    d.x = min(d.x, ceils );\n    #define colW 0.0328\n    //float cols = length(p.xz) - 0.06;\n    float cols = max(abs(p.x) - colW, abs(p.z) - colW);\n    #define floors 8.\n    \n    d = dmin(d, vec2(fOpUnionStairs(d.x, cols, 2.*ceilH/2., floors), 0.));\n    \n    // outer\n    p = q;\n    for(int i = 0; i < 4; i++){\n    \tp = abs(p);\n        p.xz *= rot(0.125*pi);\n        //q.x += 0.03;\n    }\n    p = abs(p);\n    //p.xy *= rot(0.4);\n    //p.y -= 0.2;\n    q = p;\n    p = abs(p);\n    p.z -= 0.25;\n    p.xz *= rot(pi*0.25);\n    p.yz = abs(p.yz) - 0.02;\n\tfloat outer = max(p.y,p.z);  \n    \n    //q.xz *= rot(0.1);\n    q.xz *= rot(0.25*pi);\n    q = abs(q);\n    q.xz *= rot(0.25*pi);\n    q = abs(q);\n    q -= 0.02;\n    pp = q;\n    d = dmin(d, vec2(outer, 1.));\n    //d.x = min(d.x, outer);\n    \n    q = abs(q);\n\touter = max(q.y,q.x);\n    \n    outer = max(outer, -q.z + 0.23) + 0.001;\n    \n    d = dmin(d, vec2(outer, 2.));\n    //d.x = min(d.x, outer);\n\t//outer = max(outer,max(q.y,q.x));\n    //glowB += exp(-outer*20.)*1.;\n    float gBsc = 0.05/(0.01 + outer*outer*200.);\n    glowB += gBsc*pal(0.0, 0.9, vec3(4.,2.,3.), vec3(1.,3.,1.6),5.9)*1.3;\n    \n    glowB += pow(abs(sin(p.x*4.+ iTime) ), 200.)*gBsc*pal(0.9, 0.9, vec3(4.,9.,3.), vec3(1.,3.,2.6),5.9)*2.;\n    \n    \n    glowG += exp(-d.x*200. )*pal(0.88, 0.2, vec3(4.,2.,3.), vec3(1.,2.3,1.6),5.9)*0.7;\n\n    d.x *= 0.7;\n    glow += exp(-d.x*150. );\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro;\n    hit = false; t = 0.;\n    \n    for(int i = 0; i < 250  ; i++){\n    \td = map(p);\n        if(d.x < 0.0005){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\nvec3 getNormal(vec3 p){\n\tvec2 u = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p - u.xyy).x,\n    \tmap(p - u.yxy).x,\n    \tmap(p - u.yyx).x\n    ));\n}\n\nvec3 text(vec2 t, vec3 p){\n\tvec3 o = vec3(0);\n\t\n    float d = 10e6;\n    t = pmod(t,1./16.);\n    \n    t *= 16.;\n    float yid = (floor( (p.y + 1.)*16. ) );\n    //t *= rot(0.25*pi);\n    //t *= rot(0.5*pi);\n    float W = 0.02;\n    \n    float modd = 0.15;\n    //t = abs(mod(t,modd)/modd - 0.5);\n    #define lmod(d, x) (mod(d,x)/x - 0.5)\n    float sqD = max(abs(t.x), abs(t.y));\n    sqD += iTime*0.2 + yid*0.04;\n    float sqid = floor(sqD/modd);\n    sqD = lmod(sqD, modd);\n    \n    d = min(d, sqD);\n    //d = min(d, length(t.x) - W );\n    //d = min(d, length(t.y) - W );\n\n    \n    o +=  pal(0.6, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n    o *= step(sin(sqid*40.), -0.3);\n\n    \n    float aa = 20.;\n    //sqD -= modd*0.25;\n    sqD -= 0.5;\n    sqD = abs(sqD*1.);\n    o -= exp(-sqD*aa)*4.;\n    sqD -= 1.;\n    sqD = abs(sqD*1.);\n    o -= exp(-sqD*aa)*4.;\n    //o += smoothstep(0.001,0., d);\n    \n    return o;\n}\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(  in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 q = (text(p.yz, p)*n.x + text(p.zx,p)*n.y + text(p.xy,p)*n.z).xyz;\n    \n    return q;\n}\nvec4 nint(float t){\n\tvec4 a = texture(iChannel0, vec2(floor(t)*0.02));\n\tvec4 b = texture(iChannel0, vec2(floor(t+ 1.)*0.02));\n    return mix(a,b, pow(smoothstep(0.,1.,fract(t)),1.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - length(uv)*0.2;\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    ro.y -= 0. + sin(iTime*0.25)*0.4;\n    ro.z += mx;\n    vec3 lookAt = vec3(0,0,ro.z + 2.);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n   \n    float r = nint(iTime/tau).x;\n    rd.xy *= rot(sin(nint(0.5*iTime/tau).x*tau)*0.2);\n    \n    rd.xz *= rot(sin(nint(0.5*iTime/tau).y\n                     *tau)*0.3);\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    vec3 n = getNormal(p);\n\n    float fogD = smoothstep(0.,1.,t*0.18);\n    if(hit){\n        //col += pal(0.5, 0.4, vec3(3.,1.,1.), vec3(1.,1.,2.),2.6 - did*2.3 )*0.09;\n        //col += pal(0.5, 0.6, vec3(3.,1.1,1.), vec3(1.,1.,2.),0.4 - did*0.6 )*0.09;\n        //p.y -= 0.03;\n        p.x -= 0.03;\n        p.z -= 0.03;\n    } \n    \n    if(d.y == 1.){\n\n        vec3 tt = tex3D(pp*0.1,n)*1.;\n        \n\t\tcol += 0.1*length(tt)* pal(0.7, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4), vec3(4.,7.,3.),-1. + iTime);; \n    } \n    if(d.y == 2.){\n        \n        col = clamp(col, 0., 1.);\n        col -= col;\n\t\tcol += 0.2*pal(0.3, vec3(1.,1.,0.6)*0.5, vec3(8.4 ,4.19,7.4), vec3(4.,7.,3.),-1. + iTime);; \n    }\n    col -= glowG*0.1;\n    col += glow*0.03;\n    col += glowB*0.03;\n    if(d.y == 0.){\n    \tcol += tex3D(p,n)*1.;\n    }\n    col = clamp(col, 0., 1.);\n\n    col = mix(col,vec3(0.2,0.014,0.1)*0.2,fogD);\n    //fogD = smoothstep(0.,1.,t*0.98);\n    col += glow*0.003*fogD*vec3(0.2,0.064,0.1);\n    //col += pal(0.5, 0.5, vec3(4.,2.,1.), vec3(1.,1.,1.),2.9 + pid.x + did*2.);\n    col = pow(col, vec3(0.45));\n    \n    col = mix(col, vec3(0), dot(uv*0.55,uv*0.55)*2.);\n    //col = mix(col, smoothstep(0.,1., col), 0.6);\n//    col *= 1. - pow(abs(uv.x) - 0.25,6. )*50.;\n//    col *= 1. - pow(abs(uv.y) - 0.3,3. )*50.;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1232]], "test": "untested"}
{"id": "3tVXRW", "name": "GeneralizedPenrose-v3", "author": "natpbs", "description": "An attempt at implementing generalized penrose tilings. \nInspired by https://youtu.be/KuXxly7-k1Q\nTouch the canvas to rotate the slicing plane. ", "tags": ["raymarching", "tesselation", "lattice"], "likes": 4, "viewed": 356, "published": 3, "date": "1582302186", "time_retrieved": "2024-07-30T21:22:44.768779", "image_code": "/* ==== GeneralizedPenrose-v3 ==== */\n// inspired by https://youtu.be/KuXxly7-k1Q\n// by natpbs\n\n/* ???? Explanation ???? */\n// the image shows a 2d ortographic of a 3d cubic lattice. \n// However, only those cubes which lie completely inside of one half-space\n// delimited by the cutting plane are represented.\n\n// The code is not well commented, this is because I wrote it in the\n// Android app ShaderEditor https://github.com/markusfisch/ShaderEditor\n// and comments ended up slowing down the text editor so I deleted them.\n// :/\n// Now I'm not even sure what most of the code means anymore...\n\n/* #### Constants #### */\n// scene\n// larger values mean that more cubes feet in the screen\nconst float scale = 8.0; \n// side of a cube, on a scale where 0.5 is the lattice step\nconst float side = 0.47;\n// how round the cubes' edges are\n//   0.0 -> cube\n//   1.0 -> sphere\nconst float roundness = 0.15;\n// ray-marching\nconst int max_steps = 64;\nconst float threshold = 1.0 / 64.0;\n// math\nconst float TAU = 6.28318530718;\nconst float PHI = 0.5 + sqrt(1.25);\nconst float MAX_FLOAT = 1e20;\n\nvec4 quaternion;\n\n/* ++++ Functions ++++ */\n\nvec3 rotate(vec3 point, vec4 quaternion) {\n\tpoint += 2.0 * cross(\n\t\tcross(point, quaternion.xyz)\n\t\t+ point * quaternion.w,\n\t\tquaternion.xyz\n\t);\n\treturn point;\n}\n\nvec2 rescale(vec2 coord) {\n\tcoord += coord;\n\tcoord -= iResolution.xy;\n\tcoord /= iResolution.x;\n\treturn coord;\n}\n\nvec4 get_rotation() {\n\tconst float depth = 0.3;\n\tvec2 coord = rescale(iMouse.xy);\n\tvec3 axis = vec3(coord, depth);\n\taxis = normalize(axis);\n\tfloat real = axis.z;\n\taxis = cross(axis, vec3(0, 0, 1));\n\treturn vec4(axis, real);\n}\n\nfloat lattice_d(vec3 p) {\n\tp = fract(p) - 0.5;\n\tp = abs(p) - side * (1.0 - roundness);\n\treturn length(max(p,0.0))\n\t\t+ min(max(p.x,max(p.y,p.z)),0.0)\n\t\t- side * roundness;\n}\n\nvec3 lattice_n(vec3 p) {\n\tconst vec2 eps = vec2(0, 1.0 / 128.0);\n\tvec3 n = vec3(\n\t\tlattice_d(p + eps.yxx)\n\t\t- lattice_d(p - eps.yxx),\n\t\tlattice_d(p + eps.xyx)\n\t\t- lattice_d(p - eps.xyx),\n\t\tlattice_d(p + eps.xxy)\n\t\t- lattice_d(p - eps.xxy)\n\t);\n\treturn normalize(n);\n}\n\nbool cube_beyond(vec3 p, vec3 point, vec3 direction) {\n\tp = floor(p);\n\tp -= point;\n\tfloat d0 = dot(p, direction);\n\tdirection *= d0;\n\tfor (int k = 1; k < 8; k++) {\n\t\tvec3 v = p + vec3(\n\t\t\t(k>>0) & 1,\n\t\t\t(k>>1) & 1,\n\t\t\t(k>>2) & 1\n\t\t);\n\t\tfloat d = dot(v, direction);\n\t\tif (d <= 1e-5) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvec3 set_color(vec3 p){\n\tvec3 n = lattice_n(p);\n\tquaternion.w = - quaternion.w;\n\tn = rotate(n, quaternion);\n\tvec3 color = 0.5 - 0.5 * n;\n\treturn color;\n}\n\nvec3 march(in vec3 p, in vec3 direction, out float d) {\n\tvec3 p_start = p;\n\tfor (int i = 0; i < max_steps; i++) {\n\t\td = lattice_d(p);\n\t\td = abs(d);\n\t\tif (d < threshold) {\n\t\t\tbool not_cut = cube_beyond(p, p_start, direction);\n\t\t\tif (not_cut) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\td += (0.5 - side) * 2.0;\n\t\t}\n\t\tp += d * direction;\n\t}\n\treturn p;\n}\n\n/* ~~~~ Main ~~~~ */\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n\tvec2 coord = rescale(frag_coord.xy);\n\n\tfloat depth = PHI - 1.0;\n\tvec3 param =\n\t\tvec3(scale * coord, depth);\n\n\tvec3 axis;\n\tvec2 angle;\n\tquaternion = get_rotation();\n\tvec3 point = rotate(param, quaternion);\n\tvec3 direction =\n\t\trotate(vec3(0, 0, 1), quaternion);\n\n\tfloat d;\n\tvec3 point_end = march(point, direction, d);\n\n\tvec3 color = set_color(point_end);\n    frag_color = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1130, 1130, 1172, 1172, 1290], [1292, 1292, 1318, 1318, 1403], [1405, 1405, 1426, 1426, 1630], [1632, 1632, 1657, 1657, 1804], [1806, 1806, 1830, 1830, 2072], [2074, 2074, 2128, 2128, 2396], [2398, 2398, 2421, 2421, 2551], [2553, 2553, 2608, 2608, 2884], [2886, 2907, 2964, 2964, 3354]], "test": "untested"}
{"id": "wlyXRD", "name": "Tube00000000", "author": "yy2901", "description": "tube", "tags": ["raymarch"], "likes": 0, "viewed": 267, "published": 3, "date": "1582301806", "time_retrieved": "2024-07-30T21:22:45.568640", "image_code": "#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define OCTAVES 4\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.002;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sceneSDF(vec3 sP) {\n    float f = sdCapsule(sP,vec3(-1.7,0.,0.),vec3(1.7,0.,0.),0.3);\n    float d = 0.02*sin(sP.x*5.0)*sin((sin(sP.x*2.0+iTime)+1.0)*sP.x*20.0)+noise(vec3(sP.z*2.5-iTime*1.0))-1.2;\n    return f+0.5*d;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn vec2(depth,i+1);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return vec2(end,0);\n        }\n    }\n    return vec2(end,0);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    vec3 ref = reflect(p-eye,N);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return (lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha))*0.5+0.5*texture( iChannel0, ref ).xyz);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    //dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec2 sdf = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    float dist = sdf.x;\n    //float occ = 1.0-float(sdf.y)/float(MAX_MARCHING_STEPS);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    vec3 N = estimateNormal(p);\n    //vec3 ref = reflect(dir,N);\n    //ref=texture( iChannel0, ref ).xyz;\n    \n    //vec3 color = ref;\n    \n    //color*=4.0*occ-3.0;\n    \n    float l1 = length( cross(vec3(0.,0.0,1.),N) );\n    l1 = smoothstep(0.65,0.6,l1)-smoothstep(l1,0.65,0.6);\n    float l2 = length( cross(vec3(0.,0.01,1.05),N) );\n    l2 = smoothstep(0.65,0.6,l2)-smoothstep(l2,0.65,0.6);\n    float l3 = length( cross(vec3(0.02,0.0,1.1),N) );\n    l3 = smoothstep(0.65,0.59,l3)-smoothstep(l3,0.65,0.59);\n    vec3 color = vec3(l1,l2,l3);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 62, 62, 103], [105, 105, 126, 126, 470], [490, 490, 509, 509, 675], [1051, 1140, 1171, 1171, 1262], [1505, 1505, 1549, 1549, 1649], [1651, 1651, 1674, 1674, 1799], [1801, 1801, 1824, 1824, 1949], [1951, 1951, 1974, 1974, 2099], [2101, 2101, 2153, 2153, 2274], [2276, 2276, 2301, 2301, 2500], [2503, 2924, 3014, 3014, 3346], [3361, 3615, 3680, 3680, 3812], [3814, 3903, 3932, 3932, 4242], [4738, 4738, 4878, 4878, 5546], [5920, 5920, 5977, 5977, 7111]], "test": "untested"}
{"id": "WlVSRW", "name": "Sphere and Volumetrics", "author": "Hei149", "description": "raymarching", "tags": ["raymarching", "volumetric", "glow"], "likes": 29, "viewed": 835, "published": 3, "date": "1582298896", "time_retrieved": "2024-07-30T21:22:46.415376", "image_code": "#define rotate(angle) mat2(cos(angle), sin(angle), sin(-angle), cos(angle))\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat mat = 0.0;\nfloat glow = 0.0;\nfloat map(vec3 p, bool shadow)\n{\n    p.yz *= rotate(iTime);\n    p.xz *= rotate(iTime);\n    float d = abs(sdSphere(p, 1.0)) - 0.01;\n    vec3 rp = p;\n    for(int i = 0; i < 4; ++i)\n        rp = abs(rp) - 0.2;\n\n    float d1 = sdSphere(rp + vec3(0.0, 0.0, 0.0), 0.15);\n    d = max(d, -d1);\n    d = min(d, abs(sdSphere(p, 4.0) - 0.1));\n    if(shadow){\n       return d;\n    }\n    float d2 = sdSphere(p, 0.1);\n    glow += 0.01 / (0.01 + d2 * d2);\n    if(d < d2)\n    {\n        mat = 0.0;\n        return d;\n    } \n    else{\n        mat = 1.0;\n        return d2;\n    }\n}\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = 0.05;\n    float shadow = 1.0;\n    while(d < maxDist)\n    {\n        float t = map(r0 + d * rd, true);\n        if(t < 0.01) return 0.0;\n        d += t;\n        shadow = min(shadow, 30.0 * (t / d));\n    }\n    return shadow;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy, false) - map(p - e.xyy, false),\n        map(p + e.yxy, false) - map(p - e.yxy, false),\n        map(p + e.yyx, false) - map(p - e.yyx, false)\n    ));\n}\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(13.549, 55.392))) * 312.93);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(0.0, 2.4, -3.0);\n    vec3 tgt = vec3(0.0);\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0,1,0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 0.95 * ww);\n    \n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    vec3 p = vec3(0.0);\n    vec3 lp = normalize(vec3(0.0));\n    float matId = 0.0;\n    for(int i = 0; i < 100; ++i)\n    {\n        p = r0 + d * rd;\n        float t = map(p, false);\n        d += t;\n        if(abs(t) < 0.001){\n            vec3 albedo = vec3(1.0);\n            if(matId < 0.5) albedo = vec3(1.0, 0.0, 0.2);\n            vec3 n = norm(p);\n            vec3 ld = normalize(lp - p);\n            vec3 diff = max(dot(n, ld), 0.0) * vec3(0.4, 0.2, 0.8);\n            float shad = shadow(p, ld, 8.0);\n            col += diff * shad;\n            col *= albedo;\n            break;\n        }\n        if(d > 100.0)\n        {\n            break;\n        }\n    }\n\n    const int numIter = 100;\n    vec3 vD = rd;\n    vD = normalize(vD);\n    float stepSize = length(p - r0) / float(numIter);\n    //vec3 vO = r0 + stepSize * vD * rand(uv) * 0.8;\n    vec3 vO = r0 + stepSize * vD;\n    float accum = 0.0;\n    for(int i = 0; i  < numIter; ++i)\n    {\n        vec3 ld = normalize(lp - vO);\n        float shad = shadow(vO, ld, 4.0);\n        float d = dot(vO, vO);\n        accum += (0.01 / d ) * shad;\n        vO += stepSize * vD;\n    }\n    col += glow * vec3(0.4, 0.2, 0.8);\n    col += accum * vec3(0.4, 0.2, 0.8) * 16.0;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 110, 110, 138], [175, 175, 207, 207, 735], [737, 737, 784, 784, 1021], [1023, 1023, 1042, 1042, 1274], [1276, 1276, 1297, 1297, 1362], [1364, 1364, 1419, 1419, 3022]], "test": "untested"}
{"id": "wlGXRD", "name": "PsychedelicSakura", "author": "Reva", "description": "Ex02", "tags": ["2d", "trigonometry", "cineshader"], "likes": 57, "viewed": 28465, "published": 3, "date": "1582294961", "time_retrieved": "2024-07-30T21:22:47.253137", "image_code": "// Author Reva - 2020-02-21\n\nfloat plot(float r, float pct){\n\treturn  smoothstep( pct-0.2, pct, r) -smoothstep( pct, pct+0.2, r);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n        return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1.0);\n    vec2 pos = vec2(0.5) - uv;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *= cos(iTime)*1.0+1.5;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\n    float f = abs(cos(a*2.5+iTime*0.5))*sin(iTime*2.0)*0.698+cos(iTime)-4.0;\n    float d = f-r;\n    \n    col = (vec3(smoothstep(fract(d),fract(d)+-0.200,0.160))-vec3(smoothstep(fract(d),fract(d)+-1.184,0.160)) ) \n\t* pal( f, vec3(0.725,0.475,0.440),vec3(0.605,0.587,0.007),vec3(1.0,1.0,1.0),vec3(0.310,0.410,0.154) );\n    float pct = plot(r*0.272,fract(d*(sin(iTime)*0.45+0.5)));\n\t\n    col += pct*pal( r, vec3(0.750,0.360,0.352),vec3(0.450,0.372,0.271),vec3(0.540,0.442,0.264),vec3(0.038,0.350,0.107) );\n\n    // Output to screen\n    fragColor = vec4(col,pct*0.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 60, 60, 131], [133, 133, 200, 200, 247], [250, 250, 307, 307, 1108]], "test": "untested"}
{"id": "3lyXzD", "name": "Opposing Fire", "author": "rls", "description": "Basic fire from a texture. Made for a stream background.", "tags": ["fire"], "likes": 20, "viewed": 865, "published": 3, "date": "1582260750", "time_retrieved": "2024-07-30T21:22:48.040033", "image_code": "#define timescale .5\n#define scaleX 1.5\n#define scaleY 0.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0,0,0);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float dist = texture(iChannel0,vec2(uv.x*scaleX - iTime*1.1*timescale,uv.y*scaleY - iTime*1.8*timescale)).r;\n    \n    float tex = texture(iChannel0,vec2(uv.x*scaleX + dist*0.2,uv.y*scaleY - iTime*1.5*timescale)).r;\n    \n    tex += uv.y*.5;\n    float fire = pow(1.-tex,2.3);\n    fire -= (1.-(abs(uv.x-.5)*2.))*.5;\n    \n    col += fire *5.* mix(vec3(.0,.2,1),vec3(1,.21,0),uv.x);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 117, 606]], "test": "untested"}
{"id": "WlySzD", "name": "hypnotize and stuff", "author": "elijahlucian", "description": "can't you see?", "tags": ["no", "hyp", "tize"], "likes": 6, "viewed": 563, "published": 3, "date": "1582255614", "time_retrieved": "2024-07-30T21:22:48.913697", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tfloat t = iTime * 2.1;\n    vec2 uv = fragCoord/iResolution.y*2.;\n  float u=uv.x;\n  float v=uv.y;\n  \n  float l=length(uv-vec2(1.,1.));\n  float d=distance(sin(t+uv),vec2(sin(l*10.+sin(u)+t),cos(l*5.)));\n \n  float circles=sin(dot(sin(t)+10.,l*10.));\n  \n  float shape=circles-d;\n  \n  vec3 color=vec3(u,v,u*v+sin(t*3.)*.5+.5);\n  \n  vec3 col=vec3(shape+color*.6);\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 454]], "test": "untested"}
{"id": "3tGXzW", "name": " - Quicky#022", "author": "totetmatt", "description": "Trying to create shader \"friendly\" with the portrait format of instagram story (1080x1920)", "tags": ["instagram", "quickly"], "likes": 9, "viewed": 427, "published": 3, "date": "1582239227", "time_retrieved": "2024-07-30T21:22:49.761430", "image_code": "mat2 r(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    uv  = abs(uv);\n      vec2 uuv= uv;\n      uv=uv*  (length(1.-uv)-.1*uv.x)*2.;\n    uv = (2.*uv+.1)-(.5*uv-.1);\n      uv *=r(iTime*.1);\n    vec2 id = floor(uv*10.);\n    uv*=r(length(fract(uuv))-(floor(atan(uuv.x+.05,uuv.y+.05)*3.1415)));    \n\n    uv = fract(uv*10.)-.5;\n    uv = abs(uv);\n    vec3 col  = vec3(0.,0.,0.0);\n\n     float t =  mix(0.45+(.654211-length(uv)),0.45+(.654211-length(uv))* (sign(sin(.1*iTime-length(id)))*.5 +.5),sin(floor(iTime*.5)+pow(fract(iTime*.5),4.))+1.); \n    uv.x >= t|| uv.y >= t  ? col=vec3(cos(1.66*iTime-length(id)*length(1.-uuv)),sin(-1.66*iTime+(length(id))),length(uv-length(uuv*.1))) : vec3(0.1) ;\n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 59], [60, 60, 115, 115, 861]], "test": "untested"}
{"id": "3lySzW", "name": "3D Simulation", "author": "wyatt", "description": "This technique is only really reasonable at massive scales in 3D - I think just a regular N-body would be better for shadertoy-scale. ", "tags": ["3dsdftexture"], "likes": 23, "viewed": 659, "published": 3, "date": "1582237908", "time_retrieved": "2024-07-30T21:22:50.589217", "image_code": "// MARCH THROUGH DISTANCE VOLUME\nSampler\nMain\n    vec3 mi = 0.5*R3D;\n    vec3 p = vec3(0,0,-0.8*max(R3D.x,max(R3D.y,R3D.z)));\n    vec3 d = normalize(vec3((u-0.5*R)/R.y,1));\n\t    \n\tif (iMouse.z>0.) {\n \t\tp.zx *= e(6.2*iMouse.x/R.x);\n\t\td.zx *= e(6.2*iMouse.x/R.x);\n        p.yz *= e(6.2*iMouse.y/R.y);\n\t\td.yz *= e(6.2*iMouse.y/R.y);\n    } else {\n\t\tp.xz *= e(.2*iTime);\n\t\td.xz *= e(.2*iTime);\n\t}\n    Q = vec4(0);\n    for (int i = 0; i < 20; i++) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m<1.)\n        { \t\n            p += d*(T(clamp(p+mi,vec3(1),R3D-1.)).w);\n        } else p += d*max(m,1.);    \n \t}\n\tvec3 q = p;\n\tp += d*T(p+mi).w;\n\t\n\tfloat \n        n = T(p+mi+vec3(0,1,0)).w,\n        e = T(p+mi+vec3(1,0,0)).w,\n        f = T(p+mi+vec3(0,0,1)).w,\n        s = T(p+mi-vec3(0,1,0)).w,\n        w = T(p+mi-vec3(1,0,0)).w,\n        b = T(p+mi-vec3(0,0,1)).w;\n\tvec3 no = vec3(e-w,n-s,f-b);\n\tif (length(no)>0.) no = normalize(no);\n\telse {Q = vec4(0);return;}\n\tvec4 bb = B(p+mi);\n\tvec4 a = A(bb.xy), aa = A(bb.zw);\n\tvec4 col = 0.5+0.5*sin(a.w+vec4(1,2,3,4));\n\tvec4 col1 = 0.5+0.5*sin(aa.w+vec4(1,2,3,4));\n\tQ = mix(col,col1,0.5*smoothstep(2.,3.,length(p+mi-a.xyz)));\n\t\n\tQ *= 0.6+0.4*texture(iChannel3,abs(reflect(no,vec3(0,0,1))));\n\tQ *= exp(-length(q-p));\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N ceil(sqrt(R.x+R.y)/4.)\n#define R iResolution.xy\n#define R3D vec3(R/N,N*N)\n#define d2(U) ((U).xy+vec2(mod(floor((U).z),N),floor(floor((U).z)/N))*R/N)\n#define d3(u) vec3(mod(u,R/N),floor(u/R*N).x+floor(u/R*N).y*N)\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(d2(mod((U),R3D))),0)\n#define C(U) texture(iChannel2, d2(mod((U),R3D))/R)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Sampler vec4 T(vec3 U) {return mix(texture(iChannel2,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel2,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Main void mainImage( out vec4 Q, in vec2 u ) { vec3 U = d3(u); \n#define Me Q = A(U);\n#define Them vec4 M = 1./6.*(A(U+vec3(1,0,0))+A(U+vec3(0,1,0))+A(U+vec3(0,0,1))+A(U-vec3(1,0,0))+A(U-vec3(0,1,0))+A(U-vec3(0,0,1)));\n#define Init  if (iFrame < 1)\n\n\n\n#define pie(p, a, b) ((length((a)-(b))<1e-3)?1e3:abs(dot((p)-0.5*((a)+(b)),(b)-(0.5*((a)+(b))))/dot((b)-0.5*((a)+(b)),(b)-0.5*((a)+(b)))))\n\n#define line(p, a, b)  ((length((p)-(a)-((b)-(a))*clamp(dot((p)-(a),(b)-(a))/dot((b)-(a),(b)-(a)),0.,1.))))\n\n", "buffer_a_code": "// STORE PARTICLE POSITION\nMain\n\tQ = A(u);\n    vec3 v = texelFetch(iChannel3,ivec2(u),0).xyz;\n\tQ.xyz += v;\n\t\n\tif (Q.x<3.) Q.x = 3.;\n\tif (R3D.x-Q.x<3.) Q.x = R3D.x-3.;\n\tif (Q.y<3.) Q.y = 3.;\n\tif (R3D.y-Q.y<3.) Q.y = R3D.y-3.;\n\tif (Q.z<3.) Q.z = 3.;\n\tif (R3D.z-Q.z<3.) Q.z = R3D.z-3.;\n\n    Init {\n        Q.xyz = round(clamp(U-vec3(0,0,1),R3D*.2,R3D*.8)/8.)*8.;\n        Q.w = Q.x+Q.y*R3D.x+Q.z*R3D.x*R3D.y;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, vec3 U, vec3 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xyz-U), la = length(a.xyz-U);\n    if (ln<la) {\n    \tQ.xy = b.xy;\n        a.xyz = n.xyz;\n    }\n    float pn = pie(U,a.xyz,n.xyz), \n          pa = pie(U,a.xyz,aa.xyz);\n    if (pn<pa){\n        aa = n;\n        Q.zw = b.xy;\n    }\n\tn = A(b.zw);\n    ln = length(n.xyz-U);\n    if (ln<la) {\n    \tQ.xy = b.zw;\n        a.xyz = n.xyz;\n    }\n    pn = pie(U,a.xyz,n.xyz);\n    if (pn<pa){\n        aa = n;\n        Q.zw = b.zw;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, vec3 U, float r) {\n\t X(Q,a,aa,U,vec3(r,0,0));\n     X(Q,a,aa,U,vec3(0,r,0));\n     X(Q,a,aa,U,vec3(0,0,r));\n     X(Q,a,aa,U,vec3(0,-r,0));\n     X(Q,a,aa,U,vec3(-r,0,0));\n     X(Q,a,aa,U,vec3(0,0,-r));\n    \n}\nMain \n\tQ = B(U);\n    vec4 a = A(Q.xy), aa= A(Q.zw);\n    Xr(Q,a,aa,U,1.);\n    Xr(Q,a,aa,U,2.);\n   \tInit {\n        Q.xy = u;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE DISTANCE & FORCE FIELD\nMain \n\tvec4 b = B(U);\n\tvec4 a = A(b.xy), aa = A(b.zw),\n         d = D(b.xy), dd = D(b.zw);\n\tQ.w = \n        min(\n            length(a.xyz-U)-2.,\n        \tline(U,a.xyz,aa.xyz)-1.\n        );\n\tvec3 r = a.xyz-aa.xyz;\n\tfloat l = length(r);\n\tQ.xyz = l>0.?\n       2e-2*(r/l/l-0.12*r/l+0.01*(dd-d).xyz/l-1e-4*(a.xyz-0.5*R3D))\n        \n        :vec3(0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// STORE & UPDATE VELOCITY\nMain\nQ = 0.999*D(u);\nU = (A(u).xyz);\nQ += C(U+vec3(-2,-2,0));\nQ += C(U+vec3(-2,-1,-1));\nQ += C(U+vec3(-2,-1,0));\nQ += C(U+vec3(-2,-1,1));\nQ += C(U+vec3(-2,0,-2));\nQ += C(U+vec3(-2,0,-1));\nQ += C(U+vec3(-2,0,0));\nQ += C(U+vec3(-2,0,1));\nQ += C(U+vec3(-2,0,2));\nQ += C(U+vec3(-2,1,-1));\nQ += C(U+vec3(-2,1,0));\nQ += C(U+vec3(-2,1,1));\nQ += C(U+vec3(-2,2,0));\nQ += C(U+vec3(-1,-2,-1));\nQ += C(U+vec3(-1,-2,0));\nQ += C(U+vec3(-1,-2,1));\nQ += C(U+vec3(-1,-1,-2));\nQ += C(U+vec3(-1,-1,-1));\nQ += C(U+vec3(-1,-1,0));\nQ += C(U+vec3(-1,-1,1));\nQ += C(U+vec3(-1,-1,2));\nQ += C(U+vec3(-1,0,-2));\nQ += C(U+vec3(-1,0,-1));\nQ += C(U+vec3(-1,0,0));\nQ += C(U+vec3(-1,0,1));\nQ += C(U+vec3(-1,0,2));\nQ += C(U+vec3(-1,1,-2));\nQ += C(U+vec3(-1,1,-1));\nQ += C(U+vec3(-1,1,0));\nQ += C(U+vec3(-1,1,1));\nQ += C(U+vec3(-1,1,2));\nQ += C(U+vec3(-1,2,-1));\nQ += C(U+vec3(-1,2,0));\nQ += C(U+vec3(-1,2,1));\nQ += C(U+vec3(0,-2,-2));\nQ += C(U+vec3(0,-2,-1));\nQ += C(U+vec3(0,-2,0));\nQ += C(U+vec3(0,-2,1));\nQ += C(U+vec3(0,-2,2));\nQ += C(U+vec3(0,-1,-2));\nQ += C(U+vec3(0,-1,-1));\nQ += C(U+vec3(0,-1,0));\nQ += C(U+vec3(0,-1,1));\nQ += C(U+vec3(0,-1,2));\nQ += C(U+vec3(0,0,-2));\nQ += C(U+vec3(0,0,-1));\nQ += C(U+vec3(0,0,1));\nQ += C(U+vec3(0,0,2));\nQ += C(U+vec3(0,1,-2));\nQ += C(U+vec3(0,1,-1));\nQ += C(U+vec3(0,1,0));\nQ += C(U+vec3(0,1,1));\nQ += C(U+vec3(0,1,2));\nQ += C(U+vec3(0,2,-2));\nQ += C(U+vec3(0,2,-1));\nQ += C(U+vec3(0,2,0));\nQ += C(U+vec3(0,2,1));\nQ += C(U+vec3(0,2,2));\nQ += C(U+vec3(1,-2,-1));\nQ += C(U+vec3(1,-2,0));\nQ += C(U+vec3(1,-1,-2));\nQ += C(U+vec3(1,-1,-1));\nQ += C(U+vec3(1,-1,0));\nQ += C(U+vec3(1,-1,1));\nQ += C(U+vec3(1,-1,2));\nQ += C(U+vec3(1,0,-2));\nQ += C(U+vec3(1,0,-1));\nQ += C(U+vec3(1,0,0));\nQ += C(U+vec3(1,0,1));\nQ += C(U+vec3(1,0,2));\nQ += C(U+vec3(1,1,-2));\nQ += C(U+vec3(1,1,-1));\nQ += C(U+vec3(1,1,0));\nQ += C(U+vec3(1,1,1));\nQ += C(U+vec3(1,1,2));\nQ += C(U+vec3(1,2,-1));\nQ += C(U+vec3(1,2,0));\nQ += C(U+vec3(1,2,1));\nQ += C(U+vec3(2,-2,0));\nQ += C(U+vec3(2,-1,-2));\nQ += C(U+vec3(2,-1,-1));\nQ += C(U+vec3(2,-1,0));\nQ += C(U+vec3(2,-1,1));\nQ += C(U+vec3(2,0,-2));\nQ += C(U+vec3(2,0,-1));\nQ += C(U+vec3(2,0,0));\nQ += C(U+vec3(2,0,1));\nQ += C(U+vec3(2,0,2));\nQ += C(U+vec3(2,1,-1));\nQ += C(U+vec3(2,1,0));\nQ += C(U+vec3(2,1,1));\nQ += C(U+vec3(2,2,0));\n    if (length(Q.xyz)>1.) Q.xyz = normalize(Q.xyz);\n\tInit Q = vec4(0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lySzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ttKXz1", "name": "Dithered Temporal Reprojection", "author": "piyushslayer", "description": "A simple demo of dithered temporal reprojection, something I found very useful for optimizing volumetric clouds. It's flexible enough to word with any N x N bayer matrix (See top of Buffer A).", "tags": ["dithering", "reprojection", "bayer", "temporal"], "likes": 8, "viewed": 1425, "published": 3, "date": "1582236078", "time_retrieved": "2024-07-30T21:22:51.360155", "image_code": "/**\n\tA simple demo of dithered temporal reprojection, something I found very\n\tuseful for optimizing volumetric clouds. It's flexible enough to word with\n\tany N x N bayer matrix (See top of Buffer A).\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;    \n    \n    vec3 col = vec3(0.);\n    \n    col += textureLod(iChannel0, uv, 0.).rgb;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BAYER_LIMIT 16\n#define BAYER_LIMIT_H 4\n\nconst int bayerFilter[BAYER_LIMIT] = int[]\n(\n\t 0,  8,  2, 10,\n\t12,  4, 14,  6,\n\t 3, 11,  1,  9,\n\t15,  7, 13,  5\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord / iResolution.xy;    \n    \n    vec3 col = vec3(0.);\n    \n    ivec2 iFragCoord = ivec2(fragCoord * .5);\n    \n    int index = int(iTime * 1.5) % BAYER_LIMIT;\n    \n    int iCoord = (iFragCoord.x + BAYER_LIMIT_H * iFragCoord.y) % BAYER_LIMIT;\n    \n    if (iCoord == bayerFilter[index])\n        col += textureLod(iChannel1, uv, 0.).rgb;\n    else if (index > 0)\n        col += textureLod(iChannel0, uv, 0.).rgb;\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 261, 261, 422]], "test": "untested"}
{"id": "wlVSz1", "name": "Intersection of SDFs", "author": "MyGoodSir", "description": "things", "tags": ["sdf"], "likes": 0, "viewed": 201, "published": 3, "date": "1582227170", "time_retrieved": "2024-07-30T21:22:52.230827", "image_code": "/**\n *Shader written by Joseph Adrian\n *2/18/2020\n *\n *My objective here was just to learn more about ray marching, GLSL, and implicit geometry\n *As it turns out, this method of rendering can do some nifty stuff.\n */\n\nconst int MAX_STEPS = 250;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.0;\nconst float EPSILON = 0.0001;\n\n\n//performs modulus division on a global 3D position vector and returns its position relative to the center of it's local subspace\n//(the effect is similar to subdividing all of 3D space into regular chunks and making them all copies of the chunk centered about\n//the origin, however the actual operation that takes place below just translates a vector based on the remainder when it is \n//divided bt the nearest multiple of a given displacement vector)\nvec3 repeat( vec3 pos, float offset )\n{\n    return mod(pos + offset * 0.5, offset) - offset * 0.5;\n}\n\n//signed distance function for a sphere\nfloat sphereSDF(vec3 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\n//signed distance function for a box\nfloat boxSDF(vec3 pos, vec3 lwh)\n{\n    vec3 x = abs(pos) - lwh;\n    return length(max(x,0.0)) + min(max(x.x,max(x.y,x.z)),0.0);\n}\n\n//signed distance function for the combination of all objects in the scene\nfloat sceneSDF(vec3 pos)\n{\n    \n    float plane = dot(pos, normalize(vec3(0.0, 1.0, 0.0)))-1.5*sin(0.5*iTime);\n    //vec3 lwh = vec3(0.20, 0.15, 0.45);\n    float d = max(sphereSDF(pos, 1.5), plane);\n    return d;\n}\n\n//returns the shortest distance from the camera to the closest surface\nfloat sd2s(vec3 cam, vec3 marchDirection, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = sceneSDF(cam + depth * marchDirection);\n        if(dist < EPSILON){\n            return depth;\n        }\n        depth+=dist;\n        if(depth >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\n//returns the direction vector for the ray that extends from this pixel\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan( radians(fov) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\n//estimate surface normal using the gradient of the signed distance function\nvec3 approxNormal(vec3 p)\n{\n    return normalize(vec3(\n        \t\t\tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n                    sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n        \t\t\t));\n\n}\n/**\n * cDiff = diffuse color\n * cSpec = specular color\n * cAmb = ambient color\n * a = alpha\n * lPos = light position\n * nct = intensity of light\n *\n *returns the shade of color that a light contributes to the surface at a given position\n *\n */\nvec3 phongLightContrib(vec3 cDiff, vec3 cSpec, float a, vec3 pos, \n                       vec3 camPos, vec3 lPos, vec3 nct) {\n    \n    vec3 normal = approxNormal(pos);\n    vec3 light = normalize(lPos - pos);\n    vec3 view = normalize(camPos - pos);\n    vec3 reflection = normalize(reflect(-light, normal));\n    \n    float dotLN = dot(light, normal);\n    float dotRV = dot(reflection, view);\n    \n    //if dotLN is less than 0 then there is no light on this part of the surface\n    if(dotLN < 0.0){\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    //light reflecting away from camera, so only apply diffuse lighting\n    if(dotRV < 0.0){\n        return nct * (cDiff * dotLN);\n    }\n    return nct * (cDiff * dotLN + cSpec * pow(dotRV, a));\n    \n    \n}\n\n//calculates frag color after light sources are accounted for\nvec3 phongLighting(vec3 cAmb, vec3 cDiff, vec3 cSpec, float a, vec3 pos, vec3 camPos){\n    \n    const vec3 AL = 0.5 * vec3(1.0, 1.0, 1.0);//AL = Ambient Light\n    vec3 color = AL * cAmb;\n    \n    vec3 pL1 = vec3(4.0 * sin(iTime),//light 1 position\n                    2.0,\n                    4.0 * cos(iTime));\n    vec3 nctL1 = vec3(0.4, 0.4, 0.4);//light 1 intensity\n    \n    color += phongLightContrib(cDiff, cSpec, a, pos, camPos, pL1, nctL1);\n    \n    \n    vec3 pL2 = vec3(2.0 * sin(0.37 * iTime),//light 2 position\n                    2.0 * cos(0.37 * iTime),\n                    2.0);\n    vec3 nctL2 = vec3(0.4, 0.4, 0.4); //light 2 intensity\n    \n    color += phongLightContrib(cDiff, cSpec, a, pos, camPos, pL2, nctL2);\n    \n    return color;\n}\n\n\n//main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float fov = 90.0;\n    \n    vec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n\tvec3 cam = vec3(0.0, 0.0, 5.0);\n    float dist = sd2s(cam, dir, MIN_DIST, MAX_DIST);\n    \n    //case if ray does not hit a surface\n    if(dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    vec3 point = cam + dist * dir;\n    vec3 cAmb = vec3(0.3, 0.3, 0.5);\n    vec3 cDiff = vec3(0.2, 0.2, 0.8);\n    vec3 cSpec = vec3(1.0, 1.0, 1.0);\n    float alpha = 10.0;\n    \n    vec3 color = phongLighting(cAmb, cDiff, cSpec, alpha, point, cam);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 788, 827, 827, 888], [890, 930, 968, 968, 1000], [1002, 1039, 1073, 1073, 1168], [1170, 1245, 1271, 1271, 1459], [1461, 1532, 1599, 1599, 1899], [1901, 1973, 2030, 2030, 2154], [2156, 2233, 2260, 2260, 2604], [2605, 2849, 2974, 2974, 3600], [3602, 3664, 3750, 3750, 4417], [4420, 4436, 4493, 4493, 5115]], "test": "untested"}
{"id": "wlKXzh", "name": "The Riemann Zeta Function", "author": "mla", "description": "Riemann's Zeta Function\n\nDerived from Justaway's [url]https://www.shadertoy.com/view/4lcBDs[/url], but computing the log of the Gamma function to avoid overflow.\n\nUse the mouse to move around (and see code header for other controls).", "tags": ["domain", "gamma", "zeta", "log"], "likes": 10, "viewed": 529, "published": 3, "date": "1582220208", "time_retrieved": "2024-07-30T21:22:53.015729", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Riemann zeta function using reflection.\n// Original by Justaway: https://www.shadertoy.com/view/4lcBDs\n// Use log gamma function to avoid overflow\n//\n// Method: http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\n//\n// Also optimize log sin and log cos:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\n//\n// Grid lines at Re(z) = 10n, Im(z) = 0.5 (the critical line)\n//\n// Seems accurate up to about Re(z) = 50 or so, then the reflection starts\n// to be misaligned and the purported roots come away from the critical line.\n//\n// <mouse> to move\n// g: show grid\n// r: don't do the reflection\n// x: show log gamma instead of zeta\n// z: zoomed view\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float LOGPI = 1.1447298858494002;\nconst float LOG2PI = 1.8378770664093453;\nconst float LOG2 = 0.6931471805599453;\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z1, vec2 z2) {\n  return cexp(cmul(z2,clog(z1)));\n}\n\nvec2 cpow(int n, vec2 z2) {\n  return cpow(vec2(n,0),z2);\n}\n\nvec2 cpow(float x, vec2 z2) {\n  return cpow(vec2(x,0),z2);\n}\n\nvec2 csin(vec2 z) {\n    return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\nvec2 ccos(vec2 z){\n  z += vec2(0.5*PI,0);\n  return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\n// Approximations to log(sin(z)) and log(cos(z)) from David Young:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\nvec2 clogsin(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(1.5*pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(0.5*pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(sin(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(1.5*PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(0.5*PI+x, 2.0*PI) - PI);\n  else return clog(csin(z));\n}\n\nvec2 clogcos(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(cos(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(PI+x, 2.0*PI) - PI);\n  else return clog(ccos(z));\n}\n\n// Lanczos approximation for Gamma function\n// See Numerical Recipes\nconst float[8] p = float[](\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  9.9843695780195716e-6,\n  1.5056327351493116e-7\n);\n\nvec2 cloggammaR(vec2 z) {\n  z -= vec2(1,0);\n  vec2 x = vec2(-1.9007e-13,0); // 0.99999999999980993 - 1\n  vec2 pval;\n  int N = 8;\n  // Add smallest first for hopefully increased accuracy.\n  for (int i = N-1; i >= 0; i--) {\n    x += p[i]*cinv(z+vec2(float(i+1),0));\n  }\n  x += vec2(1,0);\n  vec2 t = z + vec2(float(N)-0.5,0);\n  // Original non-log function\n  //return cmul(cmul(cmul(vec2(sqrt(2.0*PI),0.0),cpow(t,z+vec2(0.5,0.0))),cexp(-t)),x);\n  vec2 a = vec2(0.5*LOG2PI,0);\n  vec2 b = cmul(clog(t),z+vec2(0.5,0));\n  vec2 c = -t;\n  vec2 y = a+b+c+clog(x);\n  return y;\n}\n\nvec2 cloggammaL(vec2 z) {\n  vec2 a = vec2(LOGPI,0);\n  vec2 b = clogsin(PI*z);\n  vec2 c = cloggammaR(vec2(1,0)-z);\n  vec2 y = a-b-c;\n  return y;\n}\n\nvec2 cloggamma(vec2 z) {\n  if(z.x > 0.0) return cloggammaR(z);\n  else return cloggammaL(z);\n}\n\nvec2 zeta(vec2 s) {\n  int N = 10;//int(0.1*exp(iTime));  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\nvec2 zeta0(vec2 s) {\n  const int N = 20;\n  const float[N] ek = float[N](\n    1048575.000000,1048555.000000,1048365.000000,\n    1047225.000000,1042380.000000,1026876.000000,\n    988116.000000,910596.000000,784626.000000,\n    616666.000000,431910.000000,263950.000000,\n    137980.000000,60460.000000,21700.001953,\n    6196.000488,1351.000122,211.000000,21.000000,1.000000);\n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*cinv(cpow(float(i), s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = 1.0;\n  for(int i = N + 1; i <= 2 * N; i++) {\n    sum2 += a*ek[i - N - 1]*cinv(cpow(float(i),s));\n    a = -a;\n  }\n  sum2 = sum2/1048576.0; // 2**N\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\nvec3 gradient(float theta) {\n    vec3 color = vec3(0);\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec3 plotDomain(vec2 z) {\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1), rgb, c.y);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 offset = vec2(0.0*iTime,0);\n    if (false && iMouse.x > 0.0) {\n      offset = -(2.0*iMouse.xy - iResolution.xy)/iResolution.x*100.0;\n    }\n    float zoom = 10.0;\n    if (keypress(CHAR_Z)) zoom = 2.0;\n    vec2 z = (zoom*uv + offset).yx; // Scale and shift\n    vec2 z0 = z; // Starting value of z\n    if (keypress(CHAR_X)) {\n        z = cloggamma(z);\n    } else if (keypress(CHAR_R) || z.x > 0.5){\n      z = zeta(z);\n    } else {\n      // Reflection\n      vec2 temp = zeta(vec2(1,0)-z);\n      temp = clog(temp);\n      temp -= cloggamma(z)+vec2(LOG2,0);\n      temp += LOG2PI*z;\n      temp -= clogcos(0.5*PI*z);\n      temp = cexp(temp);\n      z = temp;\n    }\n    vec3 color = plotDomain(z);\n    //color = hsv2rgb(vec3(atan(z.y,z.x)/(2.0*PI),1,1));\n    //float k = log(length(z));\n    //k = max(k,1.0/k);\n    //color = hsv2rgb(vec3(k,1,1));\n    if (keypress(CHAR_G)) {\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.x-0.5)));\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.y-10.0*round(z0.y/10.0))));\n    }\n    fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1070, 1070, 1099, 1099, 1141], [1143, 1143, 1162, 1162, 1198], [1200, 1200, 1229, 1229, 1259], [1261, 1261, 1280, 1340, 1396], [1398, 1398, 1417, 1417, 1484], [1486, 1486, 1515, 1515, 1551], [1553, 1553, 1580, 1580, 1611], [1613, 1613, 1642, 1642, 1673], [1675, 1675, 1694, 1694, 1775], [1777, 1777, 1795, 1795, 1897], [1899, 2082, 2104, 2104, 2583], [2585, 2585, 2607, 2607, 3070], [3357, 3357, 3382, 3382, 3924], [3926, 3926, 3951, 3951, 4071], [4073, 4073, 4097, 4097, 4166], [4168, 4168, 4187, 4187, 4644], [5388, 5388, 5416, 5416, 6255], [6257, 6257, 6282, 6282, 6400], [6402, 6402, 6429, 6429, 6603], [6605, 6605, 6629, 6629, 6690], [6785, 6785, 6838, 6838, 7970]], "test": "untested"}
{"id": "tldXWX", "name": "Stereoscope", "author": "luckas", "description": "Render a stereoscopic image. (https://en.wikipedia.org/wiki/Magic_Eye)\nSwitch to full screen and cross your eyes on it.", "tags": ["stereoscope"], "likes": 1, "viewed": 383, "published": 3, "date": "1582213517", "time_retrieved": "2024-07-30T21:22:54.169644", "image_code": "//\n// Base patterns\n//\nconst float patternPeriod = 9.0; // px\nvec3 basePatternPeriodic(vec2 pos) {\n    float brightness = 0.5 + 0.5 * sin((pos.x + pos.y) / patternPeriod * 2.0 * 3.14);\n    return unit3 * brightness;\n}\n\nvec3 basePatternRandom(vec2 pos) {\n    return unit3 * rand(pos.xy);\n}\n\nconst int basePatternChannel = 0;\nvec3 basePatternTexture(vec2 pos) {\n    vec2 texturePos = pos / iChannelResolution[basePatternChannel].xy;\n    return texture(iChannel0, texturePos).rgb;\n}\n\n// Chose a base pattern\nvec3 basePattern(vec2 pos) {\n    return basePatternTexture(pos);\n}\n\n// Chose a distance model\nfloat pixelEyeDistance(vec2 pos) {\n\treturn distanceSphere(pos);\n}\n\nconst float paralaxFactor = eyeDistance * screenDistance * displayDensity;\nfloat paralax(vec2 pos) {\n    vec2 centeredPhysical = (iResolution.xy / 2.0 - pos) / displayDensity;\n\n    return paralaxFactor / pixelEyeDistance(centeredPhysical);\n}\n\nvec3 shadedImage(vec2 pos) {\n\tvec2 centeredPhysical = (iResolution.xy / 2.0 - pos) / displayDensity;\n    vec3 col = (baseDistance + 100.0 - pixelEyeDistance(centeredPhysical)) / 100.0 * unit3;\n\treturn col;\n}\n\nvec3 stereoscopicImage(vec2 pos) {\n    for(int i = 0; i < 1000; ++i) {\n        if (pos.x < 0.0) break;\n        pos.x = pos.x - paralax(pos);\n    }\n    vec3 col = basePattern(pos);\n\treturn col;\n}\n\n// Entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Call shadedImage instead of stereoscopicImage to see which shape is rendered\n    vec3 col = stereoscopicImage(fragCoord);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Setup model parameters\n\n// MacBook 15\"\n//const float displayDensity = 5.078740157480315;  // Pixel per mm\n\n// MacBok Air\nconst float displayDensity = 4.960629921259843;  // Pixel per mm\n\n    const float eyeDistance = 63.0; // Distance of your eyes in mm\nconst float screenDistance = 500.0; // Distance of eyes to screen in mm\n\n// Usefull constants\nconst vec3 unit3 = vec3(1.0, 1.0, 1.0);\n\nfloat rand(vec2 pos){\n    return fract(sin(dot(pos ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat distanceFromOrigin(vec2 pos) {\n\treturn sqrt(pos.x * pos.x + pos.y * pos.y);\n}\n\n//\n// Distance models\n//\n\n// Define distance of base plane used in many models\nconst float baseDistance = 500.0; // mm\n\n// Pyramide Model\nconst float width = 120.0; // mm\n\nfloat distancePyramide(vec2 pos) {\n    float elevation = width / 2.0 - (abs(pos.x) + abs(pos.y)) ;\n    if (elevation < 0.0) {\n        elevation = 0.0;\n    }\n    \n    return baseDistance + elevation;\n}\n\n// Cone Model\nconst float coneRadius = 60.0; // mm\n\nfloat distanceCone(vec2 pos)\n{\n    float radius = distanceFromOrigin(pos);\n    if (radius < coneRadius) {\n    \treturn baseDistance + (coneRadius - radius);\n    } else {\n        return baseDistance;\n    }\n}      \n \n\n// Sphere Model\nconst float sphereRadius = 60.0; // mm\n\nfloat distanceSphere(vec2 pos)\n{\n    float radius = distanceFromOrigin(pos);\n    if (radius < sphereRadius) {\n    \treturn baseDistance + sqrt(sphereRadius * sphereRadius - radius * radius);\n    } else {\n        return baseDistance;\n    }\n}\n\n\n// Circle Model\nconst float circleRadius = 60.0; // mm\nconst float circleDistance = baseDistance + 100.0; // mm\n\nfloat distanceCircle(vec2 pos)\n{\n    float radius = distanceFromOrigin(pos);\n    if (radius < circleRadius) {\n    \treturn circleDistance;\n    } else {\n        return baseDistance;\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 98, 98, 217], [219, 219, 253, 253, 288], [324, 324, 359, 359, 479], [481, 505, 533, 533, 571], [573, 599, 633, 633, 664], [741, 741, 766, 766, 907], [909, 909, 937, 937, 1116], [1118, 1118, 1152, 1152, 1312], [1314, 1329, 1386, 1467, 1575]], "test": "untested"}
{"id": "3lVSz1", "name": "Day 63", "author": "jeyko", "description": "some inversion stuff", "tags": ["inversion", "mdtmjvm"], "likes": 16, "viewed": 549, "published": 3, "date": "1582208977", "time_retrieved": "2024-07-30T21:22:55.200887", "image_code": "// Fork of \"Day 61\" by jeyko. https://shadertoy.com/view/WlKXRR\n// 2020-02-20 13:48:59\n\n// thanks to mla and Kali!\n// They have super nice examples on inversion\n\n// it's really simple, basically\n// p /= dot(p,p);\n// p = sin(p);\n// SDFs\n// return distance*dot(p,p);\n\n\n// and ofc Inigo quilez for pallete!\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor += texture(iChannel0, fragCoord/iResolution.xy, 6.)*0.3;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define mx (iTime*0. + 20.*iMouse.x/iResolution.x)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) (a + b*cos(tau*(c*d + e)))\n\nvec3 pA = vec3(0);\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    vec3 q = p;\n    \n\n    float sc = 3.4 - sin(iTime*0.5)*2. ;\n    float dp = dot(p,p);\n    p /= dp;\n    p*= sc;\n    p=sin(p+vec3(-T*tau*2.2,1.4 - 1.*T*tau,.1 + T*tau*3. + sin(T*tau)*1.5));\n    pA = p;\n    d.x = 0.;\n    d.x = length(p) - 0.7 + length(q)*0.3;\n    d.x *= 0.5;\n\treturn d*dp/sc;\n}\n\nvec3 glow = vec3(0);\nvec2 trace(vec3 ro, vec3 rd,inout vec3 p,inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    \n    for(int i = 0; i < 170; i++){\n    \td = map(p);\n        glow += exp(-d.x*90.);\n        if(d.x < 0.0001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    col += vec3(0.04,0.1,0.3)*0.02;\n    \n    col -= vec3(0.01,0.07,0.3)*length(uv)*0.03;\n    uv *= 1. + dot(uv,uv)*0.24;\n    vec3 ro = vec3(0.6,0.,1.)*0.9;\n\n    \n    //ro.x += sin(iTime)*0.1;\n    ro.z += 0.5-sin(iTime*0.5)*0.3;\n    vec3 lookAt = vec3(0.);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= rot(sin(iTime*0.5)*0.6);\n    rd.xz *= rot(sin(iTime*0.75)*0.2);\n    vec3 p; float t; bool hit;\n    vec2 d = trace(ro, rd, p, t, hit);\n    \n    if(hit){\n        vec3 pAA = pA;\n        float modD = 0.1;\n        float id = floor(pA.x/modD);\n        pA = pmod(pA, modD);\n        //col += pal(0.,vec3(0.7,0.8 ,0.8)*1., vec3(3.1,9.5,4.1 ), 1.5, id*1.2 + pAA.z*0.9 + pAA.y*0.9 + iTime*0.92)*1.;\n        vec3 balls = pal(0.5,vec3(0.6,0.4 ,0.8)*1., vec3(3.1,9.5,4.1 ), 1.5, id*1.2 + pAA.z*0.9 + pAA.y*0.1 + iTime*0.52 )*1.;\n    \tballs = mix(balls, 1. - balls,0. + 1.*pow(abs(uv.x)*0.55,2.9)*4.5);\n        col += balls;\n        col *= step(abs(sin(id*20.))*1., 0.7);\n        col -= exp((abs(pA.x) - modD*0.5)*100.);\n\n        col -= exp(-length(p)*15.)*10.;\n        //col += 0.1;\n        //col += smoothstep(0.01,0., length(pA.x) - modD*0.175);\n    \tcol -= glow*0.025;\n    }\n    \n    col = clamp(col, 0., 1.);\n\n    col *= 1.1;\n    col = pow(col, vec3(0.45));\n    col *= 1. + 1.*pow(abs(uv.x)*0.55,2.9)*3.5;\n    col *= 1. - 1.*pow(abs(uv.y)*1.0,2.9)*0.5;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 363, 363, 503]], "test": "untested"}
{"id": "3lVXR1", "name": "background removal + recontrast", "author": "FabriceNeyret2", "description": "just by replacing luminance by some \"character vs background index\".\n( not really making an alpha mask, even if  a poor one can be derivated )", "tags": ["video", "background", "keying"], "likes": 3, "viewed": 418, "published": 3, "date": "1582205397", "time_retrieved": "2024-07-30T21:22:56.035655", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel0, U/iResolution.xy); O.a = 0.;\n    O = pow(O,vec4(2.2));            // sRGB -> flat space\n    float l = O.r+O.g+O.b,           // luminance\n          v = (2.*O.r-O.g)/.6;       // character/background index\n    O /= l;                          // cancel luminance\n    O *= v;                          // ... and replace by C/B index\n  //O = vec4(v);                     // test: show pseudo-luminance\n  //O = vec4(v/l);                   // test: show pseudo-mask\n    O = pow(O,vec4(1./2.2));         // -> back to sRGB\n // O = mix(sqrt(max(O,0.)),texture(iChannel1, U/iResolution.xy),smoothstep(1.5,0.,v/l));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 675]], "test": "untested"}
{"id": "3tcXWX", "name": "Digital Heartbeat", "author": "elijahlucian", "description": "idkwtfimdoing", "tags": ["test"], "likes": 2, "viewed": 296, "published": 3, "date": "1582181161", "time_retrieved": "2024-07-30T21:22:56.933255", "image_code": "float dankSin(float v,float x,float t){\n  return sin(v*x+t)*.5+.5;\n}\n\nfloat nsin(float v){\n  return sin(v)*.5+.5;\n}\n\nfloat ncos(float v){\n  return cos(v)*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord.xy/iResolution.xy;\n  \n  float t=iTime*.3;\n  float u=uv.x;\n  float v=uv.y;\n  float PI=3.14;\n  float TAU=PI*2.;\n  float mult=5.5;\n  \n  // VARS\n  float su=dankSin(u,TAU*mult,0.);\n  float sv=dankSin(v,TAU*mult,0.);\n  \n  float d=distance(uv,vec2(.5,.5));\n  float du=distance(u,.5);\n  float dv=distance(v,.5);\n    \n  // SHAPES\n\n  float waves=mod(\n    distance(\n      su*sin(.05*t*TAU+nsin(v*10.+t+u*3.)*2.),\n      su+sin(.05*t*3.+cos(u*10.+t*2.))\n    ),\n    .4\n  );\n\n\n  vec3 circles = vec3(distance(9. * du * d, sin(v)));\n  //circles = mod(t - circles * circles * 15., 1); \n  vec3 shape = mod(t - 2. * circles * circles,1.) + circles * waves;\n//  shape = mod(t - shape * shape * 15., 1.);\n    \n  // COLORS\n  float r=1.;\n  float g=.2;\n  float b=.5;\n  \n  vec3 color=vec3(u*r,g,b);\n    \n  vec3 final = color * shape * 5.;\n    \n  fragColor=vec4(final,1.);\n  \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 68], [70, 70, 90, 90, 115], [117, 117, 137, 137, 162], [165, 165, 222, 222, 1093]], "test": "untested"}
{"id": "wlGSz1", "name": "Imprisoned", "author": "haptix", "description": "Experimenting with some concepts I'm learning", "tags": ["raymarched"], "likes": 1, "viewed": 239, "published": 3, "date": "1582176382", "time_retrieved": "2024-07-30T21:22:57.756055", "image_code": "float glow = 0.;  //GLOW baby\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nvec3 twist(vec3 pos)\n{\n    float c = sin(.1 * pos.x + iTime * cos(iTime*.001));\n    float s = cos(.1 * pos.x + iTime * cos(iTime*.001));\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.zy, pos.x);\n}\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat hollowBox(vec3 pos, float radius)\n{\n    return differenceSDF(box(pos, vec3(radius)), sphere(pos, radius*1.3));\n}\n\nfloat distfunc(vec3 pos, float radius)\n{\n    float hollowB = hollowBox(twist(pos), radius);\n    float sphereB = sphere(pos, radius*0.8);\n    float shape = unionSDF(hollowB, sphereB);\n    glow += 0.1 / (0.1 + shape*shape);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(20. * sin(iTime*.5), 20. * cos(iTime*.5), 14.);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 100.0;\n    const float EPSILON = 0.002;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    float radius = 10.;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos, radius);\n        totalDist += dist;\n        pos += dist * rayDir*.5;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx, radius) - distfunc(pos - eps.yxx, radius),\n            distfunc(pos + eps.xyx, radius) - distfunc(pos - eps.xyx, radius),\n            distfunc(pos + eps.xxy, radius) - distfunc(pos - eps.xxy, radius)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal * 0.9));\n        float specular = pow(diffuse, 100.0);\n\t\t\n        vec3 color = vec3(.2*sin(iTime*0.2) + 0.45,\n                          .2*cos(iTime*0.3) + 0.45,\n                          .2*sin(iTime*0.7) + 0.45) * (diffuse + specular) / (1. + totalDist * 0.05);\n\n\n        fragColor = vec4(color + glow*.015, 1.0);\n    }\n    else\n        fragColor = vec4(0.) + glow*.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 69, 69, 104], [106, 106, 138, 138, 186], [188, 188, 210, 210, 395], [397, 397, 439, 439, 471], [473, 473, 520, 520, 553], [555, 555, 596, 596, 673], [675, 675, 715, 715, 916], [918, 918, 975, 975, 2746]], "test": "untested"}
{"id": "wlyXRh", "name": "minimal pattern", "author": "Ausfragezeichen", "description": "fullscreen floating.\nwhy does the red line flicker if uv gets too big", "tags": ["fullscreen"], "likes": 1, "viewed": 303, "published": 3, "date": "1582153908", "time_retrieved": "2024-07-30T21:22:58.611767", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= 20000.;\n    vec2 gv = fract(uv)-0.5;\n\n    float mask = abs(gv.x + gv.y);//smoothstep(-0.01, 0.01, gv.x + gv.y);\n    col += mask;\n    \n    //col.rg = gv;\n    \n    /**/\n    if(gv.x > 0.48 || gv.y > 0.48) col = vec3(1,0.3,0);\n    if(gv.x < -0.48 || gv.y < -0.48) col = vec3(0.3,0.7,0);\n    if(abs(gv.x) < 0.01 || abs(gv.y) < 0.01) col += vec3(0.3,-0.3,-0.3);\n\t/**/\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 555]], "test": "untested"}
{"id": "wtySRh", "name": "Day 62", "author": "jeyko", "description": "yo", "tags": ["mdtmjvm"], "likes": 7, "viewed": 476, "published": 3, "date": "1582150884", "time_retrieved": "2024-07-30T21:22:59.441548", "image_code": "\nvec3 glow = vec3(0);\nvec3 glowG = vec3(0);\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define mx (iTime*(0.8 )+ sin(iTime*2.)*0.4 + 20.*iMouse.x/iResolution.x)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 path(float z){\n    z*= 0.4;\n\treturn vec3(\n    \tsin(z),\n        cos(z),\n        0.\n    )*1.;\n\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n#define tunnW 0.4\n#define md  vec2(1./10., 1.)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 pid;\nfloat did;\n\nvec2 sdBoxy(vec3 p, vec3 pC){\n\tvec2 d = vec2(10e5);\n    did = 1.;\n    float iters = 5.;\n    vec3 boxSz = vec3(md.x*0.46,0.1,1.4*md.y/10.);\n    \n    d.x = min(d.x, sdBox(pC,boxSz ));\n    pC.y += tunnW*0.47;\n    \n    for (float i = 0.; i < iters; i++){\n        boxSz.xz *= 0.7;\n        boxSz.y *= 1.05;\n        \n        float dB =sdBox(pC,boxSz );\n        if(d.x < -dB ){\n        \td.x = -dB;\n        } else {\n        \tdid++;\n        }\n        \n    }\n    \n    return d;\n}\n\nvec2 sdInner(vec3 p, vec3 pC){\n\tvec2 d = vec2(10e5);\n    float iters = 4.;\n    vec3 boxSz = vec3(md.x*0.46,0.1,1.4*md.y/10.)*0.3;\n    for (float i = 0.; i < 2.; i++){\n        pC = abs(pC);\n    \n        //pC.y -= 0.01;\n        pC.xz *= rot(0.);\n    }  \n    pC.y += tunnW*0.00;\n    d.x = min(d.x, sdBox(pC,boxSz ));\n\n    return d;\n}\n\nvec3 pCG;\nvec2 sdInnerB(vec3 p, vec3 pCG){\n\tvec2 d = vec2(10e5);\n    float iters = 4.;\n    vec3 boxSz = vec3(md.x*0.46,0.04,1.4*md.y/10.)*0.3;\n    for (float i = 0.; i < 2.; i++){\n        pCG = abs(pCG);\n    \n        //pC.y -= 0.01;\n        pCG.xz *= rot(0.);\n    }  \n    \n    \tpCG.y -= tunnW*0.1;\n    for(int i = 0; i < 2; i++){\n    \tpCG = abs(pCG);\n        pCG.xz *= rot(0.1);\n        pCG.xy *= rot(0.5);\n        pCG.x += 0.01;\n        //d.x = min(d.x, sdBox(pCG,boxSz ));\n        //pCG.x += 0.1;\n    }\n\n    return d;\n}\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    \n    //d.x = min(d.x, -length(p.xy) + 0.6);\n    vec3 pC = vec3(atan(p.y,p.x)/tau,length(p.xy),p.z);\n   \t\n    vec3 pCC = pC;\n    pid = floor(vec3(pC.x/md.x, pC.y, pC.z/md.y));\n    vec3 pidB = floor(vec3(pC.x/md.x - 0.5, pC.y, pC.z/md.y));\n    pC.x = pmod(pC.x, md.x);\n    pC.z = pmod(pC.z, md.x*tau*0.4);\n    \n    pC.y -= tunnW;\n    d.x = min(d.x, sdBoxy(p, pC).x);\n    pC.y += 0.12;\n    pC.x = pmod(pC.x, md.x);\n    //pC.x -= md.x*0.5;\n    \n    float dTube = length(pC.xy) - 0.01;\n    \n    d.x = min(d.x, dTube);\n    \n    \n    glowG += exp(-dTube*200. )*pal(0.78, 0.2, vec3(4.,3.,1.), vec3(1.,1.,1.),2.9 )*1.2;\n\t\n    glowG += exp(-dTube*100. )*pal(0.98, 0.2, vec3(1.,2.,1.), vec3(4.,4.3,2.6),2.9 )*pow(abs(sin(p.z*0.2 - iTime*0.5+ pidB.x) ), 300.)*1.;\n        \n    pCG = pC;\n    d.x = min(d.x, sdInner(p, pC).x);\n    float innB = sdInnerB(p, pCG).x;\n    d.x = min(d.x, innB);\n    glowG += exp(-innB*200. )*pal(0.98, 0.2, vec3(1.,2.,1.), vec3(4.,2.3,2.6),5.9 )*0.5;;\n\n    d.x *= 0.5;\n    glow += exp(-d.x*220. );\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro;\n    hit = false; t = 0.;\n    \n    for(int i = 0; i < 250 + min(0,iFrame); i++){\n    \td = map(p);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    ro += path(ro.z);\n    vec3 lookAt = vec3(0,0,ro.z + 2.);\n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    rd.xy *= rot(sin(iTime)*0.3);\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n    \tcol += pal(0.08, 0.2, vec3(4.,1.39,1.4 + sin(p.z)*0.4), vec3(1.,1.,1.),-6.4 - did*0.3)*0.24;\n        //col += pal(0.5, 0.4, vec3(3.,1.,1.), vec3(1.,1.,2.),2.6 - did*2.3 )*0.09;\n        //col += pal(0.5, 0.6, vec3(3.,1.1,1.), vec3(1.,1.,2.),0.4 - did*0.6 )*0.09;\n    \t\n    } \n    \n    col -= glow*0.008;\n    col += glowG*0.02;\n    col *= 1.2;\n    col.b *= 1.2;\n    col *= 5.;\n    col = mix(col,vec3(1.),t*0.2);\n    //col += pal(0.5, 0.5, vec3(4.,2.,1.), vec3(1.,1.,1.),2.9 + pid.x + did*2.);\n    col = pow(col, vec3(0.45));\n    col *= 1. - pow(max(abs(uv.x) - 0.25,0.),6. )*10.;\n    col *= 1. - pow(abs(uv.y) - 0.25,3. )*20.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtySRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 239, 239, 418], [420, 420, 439, 439, 519], [521, 521, 549, 549, 604], [769, 769, 798, 798, 1237], [1239, 1239, 1269, 1269, 1569], [1581, 1581, 1613, 1613, 2092], [2093, 2093, 2110, 2110, 3181], [3183, 3183, 3257, 3257, 3528], [3530, 3530, 3587, 3587, 4648]], "test": "untested"}
{"id": "WtGSR1", "name": "vector graphics 2c", "author": "FabriceNeyret2", "description": "false 3D\n\nNB:  You can add more turns with [int]*atan\n        You can change number of lines: O.a++ < 13*k ; O.a/2/k   ", "tags": ["2d", "vector", "fake3d", "golf"], "likes": 11, "viewed": 509, "published": 3, "date": "1582135950", "time_retrieved": "2024-07-30T21:23:00.247394", "image_code": "// variant of https://shadertoy.com/view/WlySzh\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 A = iResolution.xy,\n         U = ( u+u - A ) / A.y;\n    for ( float a = atan(U.y,U.x), l=0., t=iTime;\n          l++ < 7.;\n          O = max(O, ( 2.- abs(A)/fwidth(A) ).y\n                    *(3.+A.x)*.1\n                  *(1.+ cos( l/2.77+3.*a-t  + vec4(0,23,21,0)))\n                    *exp(-abs(fract(l/3.77+a/6.3-t)-.5)*8.))\n        )\n        A = cos( l +a -.3*t+ vec2(0,33) ),\n        A.y = length( U +vec2(0, U.y*.3-.13*A) ) -.6 -.2*A.y;\n}\n         ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 539]], "test": "untested"}
{"id": "WtGXzh", "name": "vector graphics 2c ( 263 chars )", "author": "FabriceNeyret2", "description": "false 3D\n\nNB:  You can add more turns with [int]*atan\n        You can change number of lines: O.a++ < 13*k ; O.a/2/k   ", "tags": ["2d", "vector", "fake3d", "2tweets", "golf"], "likes": 8, "viewed": 404, "published": 3, "date": "1582134227", "time_retrieved": "2024-07-30T21:23:01.295591", "image_code": "// variant of https://shadertoy.com/view/WlySzh\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 A = iResolution.xy,\n         U = ( u+u - A ) / A.y;\n    for ( float a = atan(U.y,U.x), l=0. ;\n          l++ < 25.;\n          O = max(O, ( 2.- abs(A)/fwidth(A) ).y\n                    *(3.+A.x)/8.\n                    *exp(-abs(fract(l/3.77+a/6.3-iTime)-.5)*8.))\n        )\n        A = cos( l/4. +a -.3*iTime+ vec2(0,33) ),\n        A.y = length( U +vec2(0, U.y*.3-.13*A) ) -.6 -.2*A.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 479]], "test": "untested"}
{"id": "WlySzh", "name": "vector graphics 2b ( 278 chars )", "author": "FabriceNeyret2", "description": "false 3D\n\nNB:  You can add more turns with [int]*atan\n        You can change number of lines: O.a++ < 13*k ; O.a/2/k   ", "tags": ["2d", "vector", "fake3d", "2tweets", "golf"], "likes": 6, "viewed": 397, "published": 3, "date": "1582133894", "time_retrieved": "2024-07-30T21:23:02.090466", "image_code": "// variant of https://shadertoy.com/view/WlySRh\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 A = iResolution.xy,\n         U = ( u+u - A ) / A.y;\n    for ( float a = atan(U.y,U.x), l=0. ;\n          l++ < 25.;\n          O = max(O, ( 2.- abs(A)/fwidth(A) ).y\n                    *(3.+A.x)/8.\n                    *vec4(1, A/A-exp(-abs(fract(l/3.77+a/6.3-iTime)-.5)*80.), 1))\n        )\n        A = cos( l/4. +a -.3*iTime+ vec2(0,33) ),\n        A.y = length( U +vec2(0, U.y*.3-.13*A) ) -.6 -.2*A.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 496]], "test": "untested"}
{"id": "tlKSRz", "name": "Irradiance Mapping, Ambient Cube", "author": "4rknova", "description": "Projection of an irradiance cubemap to an \"Ambient Cube\" and evaluation to reconstruct the approximated irradiance signal.", "tags": ["irradiance", "probe"], "likes": 6, "viewed": 712, "published": 3, "date": "1582131391", "time_retrieved": "2024-07-30T21:23:03.035938", "image_code": "// by Nikos Papadopoulos, 4rknova / 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPSILON\t\t\t\t0.0001\n#define EPSILON_M\t\t\t0.1\n#define PI\t\t\t\t\t3.14159265359\n#define PI2\t\t\t\t\tPI * 0.5\n#define RADIAN\t\t\t\t180.0 / PI\n\nfloat txt = 0.0;\n\n/* This implements both projection and evaluation for practical reasons.\n** Obviously projection would happen offline in a typical setup and then evaluated at run time.\n*/\nvec3 Evaluate(vec3 worldNormal)\n{\n    // Projection\n    vec3 cAmbientCube[6] = vec3[](\n    \t  textureLod(iChannel0, vec3( 1, 0, 0), 1e10).xyz\n    \t, textureLod(iChannel0, vec3(-1, 0, 0), 1e10).xyz\n   \t\t, textureLod(iChannel0, vec3( 0, 1, 0), 1e10).xyz\n    \t, textureLod(iChannel0, vec3( 0,-1, 0), 1e10).xyz\n    \t, textureLod(iChannel0, vec3( 0, 0, 1), 1e10).xyz\n   \t\t, textureLod(iChannel0, vec3( 0, 0,-1), 1e10).xyz\n\t);\n    \n    // Evaluation\n    vec3 nSquared = worldNormal * worldNormal;\n    ivec3 isNegative = ivec3 (\n          worldNormal.x < 0.0 \n        , worldNormal.y < 0.0\n        , worldNormal.z < 0.0\n    );\n    \n    return nSquared.x * cAmbientCube[isNegative.x  ]\n         + nSquared.y * cAmbientCube[isNegative.y+2]\n         + nSquared.z * cAmbientCube[isNegative.z+4];\n}\n\nvec3 sph2dir(vec2 p)\n{\n    vec2 s = (p*2.-1.) * vec2(PI,PI * 0.5); // Spherical coords\n    vec4 t = vec4(sin(s), cos(s));       // Precalculated sin/cos values\n    return t.zyx * vec3(t.w, 1, t.w);    // Conversion to direction\n}\n\nvec3 Unwrap(vec2 uv)\n{\n    vec3 d = sph2dir(uv);\n    return Evaluate(d);\n}\n\nvec3 UnwrapSource(vec2 uv)\n{\n    vec3 d = sph2dir(uv);\n    return texture(iChannel0, d).xyz;\n}\n\n#define MODE_SRC_UNWRAP 0.0\n#define MODE_RES_UNWRAP 1.0\n#define MODE_RES_PROBE  2.0\n#define MODE_COUNT      3.0\n\n// ****************************************************************\n// Ray marching\n// ****************************************************************\n\n#define RMARCH_MAX_STEPS \t64\n#define CLEAR_COLOR\t\t\tvec3(0.2)\n\nfloat des_sphere(vec3 p, float r) { return length(p) - r; }\nvec3  translate (vec3 v, vec3  t) { return v - t; }\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, Camera c, out Ray r)\n{\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\nfloat scene_distance(vec3 p)\n{\n\treturn des_sphere(translate(p, vec3(0)), 1.0);\n}\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z));\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z));\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 p, vec3 n)\n{\n\treturn Evaluate(n);\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos);\n\n\t\tif (d < EPSILON) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\t\n\treturn d < EPSILON;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 nv = (fragCoord.xy / iResolution.xy);\t\n    \n    vec3 col = CLEAR_COLOR;\n    \n    float mode = mod(floor(iTime*.5),MODE_COUNT);\n    \n    if (mode == MODE_SRC_UNWRAP)\n    {\n        col = UnwrapSource(nv);\n        txt = Text_Original(iResolution.xy, fragCoord.xy);\n    }\n    else if (mode == MODE_RES_UNWRAP) {\n    \tcol = Unwrap(nv);\n    \ttxt = Text_AmbientCube(iResolution.xy, fragCoord.xy);\n    }\n    else\n    {\n        vec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n        \t    * vec2(iResolution.x / iResolution.y, 1);\t\n   \n\t\tCamera c;\n\t\tc.p = vec3(cos(iTime) * 4.0, 0, sin(iTime) * 4.0);\n\t\tc.t = vec3(0, 0, 0);\n\t\tc.u = vec3(0, 1, 0); \n   \n\t\n\t\tRay r;\n\t\tgenerate_ray(uv, c, r);\n\t\n\t\tvec3 sp, sn;\n\t\tint iter = RMARCH_MAX_STEPS;\t\n\t\tbool res = rmarch(r, sp, sn, iter);\n\t\n    \n        if (res) {\n            col = scene_shade(sp, sn);    \n        }\n        txt = Text_Probe(iResolution.xy, fragCoord.xy);\n    }\n\t\n \n\tfragColor = vec4(col + txt, 1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Font rendering based on FlyGuy's shader: https://www.shadertoy.com/view/llSGRm\n#define FONTSC_SZ vec2(2.5, 5)     // Font size\n#define SCREEN_SZ vec2(800, 600) // Screen size\n#define CHR       vec4(6,7,6.*FONTSC_SZ.x,9.*FONTSC_SZ.y)  // Character size (xy), spacing(zw)\n#define STR_SZ(c) vec2(c*CHR.zw) // String size\n#define DWN_SC    2.             // Downscale\n\n#define C vec2\nC c_spc = C(      0,      0), c_exc = C( 276705,  32776), c_quo = C(1797408,      0)\n, c_hsh = C(  10738,1134484), c_dol = C( 538883,  19976), c_pct = C(1664033,  68006)\n, c_amp = C( 545090, 174362), c_apo = C( 798848,      0), c_lbr = C( 270466,  66568)\n, c_rbr = C( 528449,  33296), c_ast = C(  10471,1688832), c_crs = C(   4167,1606144)\n, c_per = C(      0,   1560), c_dsh = C(      7,1572864), c_com = C(      0,   1544)\n, c_lsl = C(   1057,  67584), c_0   = C( 935221, 731292), c_1   = C( 274497,  33308)\n, c_2   = C( 934929,1116222), c_3   = C( 934931,1058972), c_4   = C( 137380,1302788)\n, c_5   = C(2048263,1058972), c_6   = C( 401671,1190044), c_7   = C(2032673,  66576)\n, c_8   = C( 935187,1190044), c_9   = C( 935187,1581336), c_col = C(    195,   1560)\n, c_scl = C(    195,   1544), c_les = C( 135300,  66052), c_equ = C(    496,   3968)\n, c_grt = C( 528416, 541200), c_que = C( 934929,1081352), c_ats = C( 935285, 714780)\n, c_A   = C( 935188, 780450), c_B   = C(1983767,1190076), c_C   = C( 935172, 133276)\n, c_D   = C(1983764, 665788), c_E   = C(2048263,1181758), c_F   = C(2048263,1181728)\n, c_G   = C( 935173,1714334), c_H   = C(1131799,1714338), c_I   = C( 921665,  33308)\n, c_J   = C(  66576, 665756), c_K   = C(1132870, 166178), c_L   = C(1065220, 133182)\n, c_M   = C(1142100, 665762), c_N   = C(1140052,1714338), c_O   = C( 935188, 665756)\n, c_P   = C(1983767,1181728), c_Q   = C( 935188, 698650), c_R   = C(1983767,1198242)\n, c_S   = C( 935171,1058972), c_T   = C(2035777,  33288), c_U   = C(1131796, 665756)\n, c_V   = C(1131796, 664840), c_W   = C(1131861, 699028), c_X   = C(1131681,  84130)\n, c_Y   = C(1131794,1081864), c_Z   = C(1968194, 133180), c_lsb = C( 925826,  66588)\n, c_rsl = C(  16513,  16512), c_rsb = C( 919584,1065244), c_pow = C( 272656,      0)\n, c_usc = C(      0,     62), c_a   = C(    224, 649374), c_b   = C(1065444, 665788)\n, c_c   = C(    228, 657564), c_d   = C(  66804, 665758), c_e   = C(    228, 772124)\n, c_f   = C( 401543,1115152), c_g   = C(    244, 665474), c_h   = C(1065444, 665762)\n, c_i   = C( 262209,  33292), c_j   = C( 131168,1066252), c_k   = C(1065253, 199204)\n, c_l   = C( 266305,  33292), c_m   = C(    421, 698530), c_n   = C(    452,1198372)\n, c_o   = C(    228, 665756), c_p   = C(    484, 667424), c_q   = C(    244, 665474)\n, c_r   = C(    354, 590904), c_s   = C(    228, 114844), c_t   = C(   8674,  66824)\n, c_u   = C(    292,1198868), c_v   = C(    276, 664840), c_w   = C(    276, 700308)\n, c_x   = C(    292,1149220), c_y   = C(    292,1163824), c_z   = C(    480,1148988)\n, c_lpa = C( 401542,  66572), c_bar = C( 266304,  33288), c_rpa = C( 788512,1589528)\n, c_tid = C( 675840,      0), c_lar = C(   8387,1147904);\n\nvec2 carret = vec2(0);\n\n// Returns the digit sprite for the given number.\nvec2 digit(float d) {    \n    vec3 r = vec3(0, 0, floor(d));\n         if (r.z == 0.) r.xy = c_0; else if (r.z == 1.) r.xy = c_1;\n    else if (r.z == 2.) r.xy = c_2; else if (r.z == 3.) r.xy = c_3;\n    else if (r.z == 4.) r.xy = c_4; else if (r.z == 5.) r.xy = c_5;\n    else if (r.z == 6.) r.xy = c_6; else if (r.z == 7.) r.xy = c_7;\n    else if (r.z == 8.) r.xy = c_8; else if (r.z == 9.) r.xy = c_9;\n    return r.xy;\n}\n// Extracts bit\nfloat bit(float n, float b) {\n    b = clamp(b,-1.,22.);\n    return floor(mod(floor(n / pow(2.,floor(b))),2.));\n}\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat spr(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv/ FONTSC_SZ);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float b = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? bit(spr.x, b - 21.0) + bit(spr.y, b) : 0.0;\n}\n// Prints a character and moves the carret forward by 1 character width.\nfloat print_char(vec2 ch, vec2 uv) { \n    float px = spr(ch, CHR.xy, uv - carret);\n    carret.x += CHR.z;\n    return px;\n}\n// Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.;\n    \n\tfor(int i = 3; i >= -2; --i) {\n        //Clip off leading zeros.\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0);        \n        float d = mod(number / pow(10., float(i)),10.);\n        \n        if(i == -1) {\n            result += spr(c_per,CHR.xy, uv - dec_pos) * clip;\n            dec_pos.x += CHR.z * clip;\n        }\n        \n        result += spr(digit(d),CHR.xy, uv - dec_pos) * clip;\n        dec_pos.x += CHR.z * clip;\n    }\n    \n    return result;\n}\n\n#define T(x) print_char(x,uv)\nfloat Text_Original(vec2 resolution, vec2 uv)\n{    \n    vec2 res = resolution / DWN_SC,\n         pos = vec2(10,20.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_O) + T(c_r) + T(c_i) + T(c_g) + T(c_i) + T(c_n) + T(c_a) + T(c_l); \n    \n    return r;\n}\n\nfloat Text_AmbientCube(vec2 resolution, vec2 uv)\n{    \n    vec2 res = resolution / DWN_SC,\n         pos = vec2(10,20.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_A) + T(c_m) + T(c_b) + T(c_i) + T(c_e) + T(c_n) + T(c_t)\n       + T(c_spc)\n       + T(c_C) + T(c_u) + T(c_b) + T(c_e); \n    \n    return r;\n}\n\nfloat Text_Probe(vec2 resolution, vec2 uv)\n{    \n    vec2 res = resolution / DWN_SC,\n         pos = vec2(10,20.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_P) + T(c_r) + T(c_o) + T(c_b) + T(c_e); \n    \n    return r;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1233, 1233, 1255, 1255, 1462], [1464, 1464, 1486, 1486, 1538], [1540, 1540, 1568, 1568, 1634], [1964, 1964, 1999, 1999, 2023], [2024, 2024, 2059, 2059, 2075], [2173, 2173, 2222, 2222, 2560], [2562, 2562, 2592, 2592, 2642], [2644, 2644, 2682, 2682, 2956], [2958, 2958, 2992, 2992, 3015], [3017, 3017, 3075, 3075, 3325], [3327, 3327, 3382, 3382, 4344]], "test": "untested"}
{"id": "WtyXRh", "name": " - Gloubi-boulga", "author": "totetmatt", "description": "Started with a nice old skool effect, then everything went wrong, eventually gives something cool.", "tags": ["nonsense"], "likes": 2, "viewed": 373, "published": 3, "date": "1582128561", "time_retrieved": "2024-07-30T21:23:03.875693", "image_code": "#define PI 3.141592\n#define PI2 (PI*2.)\n#define mTime iTime\n#define fTime floor(mTime) + pow(fract(mTime),.5)\n#define fTime2 floor(mTime*4.) + pow(fract(mTime*4.),1.4)\nfloat fig(vec2 uv,float offset) {\n    uv +=sin(iTime*(2.) +offset)*.1;\n    return  step(0.01,0.02-min(0.02,abs(uv.y)));  \n}\nmat2 r(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 ball(vec2 uv,float offset) {\n    vec2 uuv = uv;\n    \n    uv.x+=sin(fTime+offset*sin(fTime))*.7;\n    uv.y+=cos(fTime2+offset)*.1;\n    uv*=20.*pow(1.-length(fract(uuv*5.)-.5),.5);\n      uv *= r(-fTime);\n    uv*=r(offset*iTime)*2.;\n    \n    vec2 b = vec2(1.09+cos(length(uv*2.)),1.09+sin(length(uv*1.))  );\n    \n    vec2 d = abs(uv)-b;\n    float di = length(max(d,0.0)) + min(max(d.x,d.y),0.0) -.0001;\n    di = abs(di-cos(-iTime*1.)*.5);\n    float ddi = di;\n  \n       di = 1.- ( smoothstep(0.801, 0.901,di) /smoothstep(0.510, 0.801,di) )  ;\n \n  \n    \n    vec3 vdi = vec3(di,di*.5*(1.-sin(floor(iTime*10.)+uuv.y*10.)),di*.5*(1.-cos(floor(iTime*10.)+uuv.x*10.)));\n    \n       di = smoothstep(0.910, 0.01,ddi);\n    vec3 vddi = vec3(di,di*.5*(1.-sin(floor(iTime*10.)+uuv.y*10.)),di*.5*(1.-cos(floor(iTime*10.)+uuv.x*10.)));\n             if(mod(length(floor(.5*iTime+(uuv*r(3.*PI/4.))*10.)),4.)>2.) { return vdi ; }\n    return vddi;\n    }\nvec3 master(vec2 uv,float r) {\n  \n    float qq = 9.;\n    vec3 col = vec3(0.1);\n    /*for(float i=0.;i<=qq; i++) {\n       \n        float id = mod(i,qq);\n        float ie = mod(i+1.,qq);\n        float iff = mod(i+1.,qq);\n        float d = fig(uv,r*PI2*(id/6.));\n        float e = fig(uv,r*PI2*(ie/6.));\n        float f = fig(uv,r*PI2*(iff/6.));\n        col[int(mod(i,3.))] = (d*.25+e*.5+f*.25);\n    }*/\n    float d = fig(uv,0.);\n    float e = fig(uv,r*PI2*(1.6/6.));\n    \n    float f = fig(uv,r*PI2*(2.5/6.));\n    float g = fig(uv,r*PI2*(3.4/6.));\n    \n    float h = fig(uv,r*PI2*(4.3/6.));\n    float i = fig(uv,r*PI2*(5.2/6.));\n    \n    \n    \n    //vec3 col = vec3(0.1);\n    col.r = (d*.25+e*.5+f*.25);\n    col.g = (f*.25+g*.5+h*.25);\n    col.b = (h*.25+i*.5+d*.25);\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    //uv +=cos(iTime+uv.x*2.)*.3+.3;\n    vec3 bb = vec3(0.);\n    float l =30.;\n    for(float i=0.;i <l;i++){\n            bb += ball(uv,PI*i/l);\n    }\n    vec3 col = (master(uv-.35,1.) + master(uv+.35,-1.)) + bb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 201, 201, 291], [292, 292, 308, 308, 351], [352, 352, 385, 385, 1287], [1288, 1288, 1318, 1318, 2071], [2072, 2072, 2127, 2127, 2441]], "test": "untested"}
{"id": "WlySRh", "name": "vector graphics 2 ( 200 chars )", "author": "FabriceNeyret2", "description": "false 3D\n\nNB:  You can add more turns with [int]*atan\n        You can change number of lines: O.a++ < 13*k ; O.a/2/k   ", "tags": ["2d", "vector", "fake3d", "2tweets", "golf"], "likes": 4, "viewed": 368, "published": 3, "date": "1582126821", "time_retrieved": "2024-07-30T21:23:04.652616", "image_code": "// variant of https://shadertoy.com/view/wtKSzz\n\nvoid mainImage(out vec4 O, vec2 u) {\n    for ( vec2 A = iResolution.xy,\n               U = ( u+u - A ) / A.y;\n          O.a++ < 26.;\n          O = max(O, ( 2.- abs(A)/fwidth(A) ).y *(3.+A.x)/8. )\n        )\n        A = cos( O.a/4. +atan(U.y,U.x) + vec2(0,33) ),\n        A.y = length( U +vec2(0, U.y*.3-.13*A) ) -.6 -.2*A.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 373]], "test": "untested"}
{"id": "wtKSzz", "name": "vector graphics ( 194 chars )", "author": "FabriceNeyret2", "description": "false 3D\n\nNB: also nice with more lines. e.g. O.a++ < 26 ; O.a/2.-iTime     or 39 / 3\n", "tags": ["2d", "vector", "fake3d", "2tweets", "golf"], "likes": 10, "viewed": 413, "published": 3, "date": "1582123580", "time_retrieved": "2024-07-30T21:23:05.416573", "image_code": "// readable version at the end ;-)\n\nvoid mainImage(out vec4 O, vec2 u) {\n    for ( vec2 A = iResolution.xy,\n               U = ( u+u - A ) / A.y;\n          O.a++ < 13.;\n          O = max(O, ( 2.- abs(A)/fwidth(A) ).y *(3.+A.x)/8. )\n        )\n        A = cos( (O.a-iTime)/2. + vec2(0,33) ),\n        A.y = length( U +vec2(0, U.y*.3-.13*A) ) -.6 -.2*A.y;\n}/*\n\n\n\n\n\n// --- 213 chars\n\n#define mainImage(O,u)                               \\\n    vec2 A = iResolution.xy,                         \\\n         U = ( u+u - A ) / A.y, V;                   \\\n    for (float a = 0.,l; a++ < 13.;  )               \\\n        A = cos(.5*a - .5*iTime + vec2(0,33)),       \\\n        V = U, V.y = (V.y-.1*A.x) *1.3,              \\\n        l = length(V) -.6 -.2*A.y,                   \\\n        O = max(O, sqrt( (1.- abs(l)/fwidth(l) )*(2.+A.x)/3. )) /*\n\n\n\n\n\n// --- 218 chars\n\n#define mainImage(O,u)                               \\\n    vec2 A = iResolution.xy,                         \\\n         U = ( u+u - A ) / A.y;                      \\\n    for (float a = 0.,l; a < 6.28; a += .5 )         \\\n        A = cos(a - .5*iTime + vec2(0,1.57)),        \\\n        l = length( ( U - vec2(0,.1*A.x) ) * vec2(1,1.3)) -.6-.2*A.y,\\\n        O = max(O, sqrt( (1.- abs(l)/fwidth(l) )*(2.+A.x)/3. )) /*\n\n\n\n\n\n// --- 254 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y, A;\n\n    for (float a = 0.,l; a < 6.283; a += .5 )\n        A = cos(a - .5*iTime + vec2(0,1.57)),\n        l = length( ( U - vec2(0,.1*A.x) ) * vec2(1,1.3))-.6-.2*A.y,\n        O = max(O, smoothstep(1.5,0.,abs(l)/fwidth(l)) * (2.+A.x)/3. );\n    O = sqrt(O);\n}  /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 72, 72, 353]], "test": "untested"}
{"id": "ttKXzR", "name": "Sampling cylindrical light", "author": "koiava", "description": "Uniform area sampling vs Visible area with importance sampling", "tags": ["illumination", "light", "sampling", "cylinder"], "likes": 12, "viewed": 575, "published": 3, "date": "1582105336", "time_retrieved": "2024-07-30T21:23:06.591431", "image_code": "#define PIXEL_SAMPLES \t\t1\t\t\t//Increase for higher quality\n#define LIGHT_SAMPLES\t\t1\t\t\t//Increase for higher quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\n#define LIGHT_CLIPPING\n#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t0\n#define SAMPLE_VISIBLE_AREA_IS\t1\n#define SAMPLE_NONE\t\t\t\t2\nint samplingTechnique;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    vec3 z = sphericalToCartesian(1.0,sin(iTime),cos(iTime));\n    vec3 x = z.x<0.8?vec3(1.0,0.0,0.0):vec3(0.0,0.0,1.0);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    mat4 trans = mat4( \tvec4( x, 0.0 ), \n    \t\t\t\t\tvec4( y, 0.0 ),\n    \t\t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\t\tvec4( 0.0, 4.0, -3.0, 1.0 ));\n    createCylinder(trans, 0.1, 0.0, 7.0, TWO_PI, MTL_LIGHT, objects[0]);\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 2.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.0, 0.0, -5.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        float t1;\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n\n        if( dot( ray.dir, hit.normal_ ) > 0.0 )\n            hit.normal_ *= -1.0;\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    for(int i=0; i<7; i++) {\n        CHECK_OBJ(objects[i]);\n    }\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, 1.0, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\nvoid sampleLine2(\tvec3 p,\t\t\t\t//shading point position\n                \tvec3 n,\t\t\t\t//normal at shadint point\n                    vec3 line_p0,\t\t//Endpoint of the light segment\n                    vec3 line_dir,\t\t//direction of light segment\n                    float line_len,\t\t//length of the light segment\n                    float Xi,\t\t\t//uniform random number\n                    out float t,\t\t//sampled t parameter on the light segment\n                    out float tPdfL ) {\t//corresponding pdf\n    vec3 p0p = line_p0 - p;\n    float ap = length(p0p);\n\tp0p = normalize(line_p0 - p);\n    line_dir = normalize(line_dir);\t//ensure that line dir is normalized\n    vec3 line_p1 = line_p0 + line_dir * line_len;\n    vec3 p1p = normalize(line_p1 - p);\n    \n    float angle_kap = acos(dot(line_dir, -p0p));\n    \n    vec3 plane_z = normalize(cross(p0p, p1p));\n    //vec3 plane_y = normalize(cross(plane_z,cross(normal, plane_z)));\n    vec3 plane_y = normalize(n - plane_z * dot(n, plane_z));\n    vec3 plane_x = cross(plane_y, plane_z);\n    \n    mat3 trans = mat3(plane_x, plane_y, plane_z);\n    mat3 trans_inv = mat3Inverse( trans );\n    \n    vec3 p0p_local = trans_inv * p0p;\n    vec3 p1p_local = trans_inv * p1p;\n    float thetaA = cartesian_to_angular(p0p_local.xy);\n    float thetaB = cartesian_to_angular(p1p_local.xy);\n    float theta = mix(thetaA, thetaB, Xi);\n    \n    float angle_apk = abs(thetaA - theta);\n    float angle_akp = PI - angle_apk - angle_kap;\n    \n    //sin theorem\n    float ak = abs((ap * sin(angle_apk)) / sin(angle_akp));\n    t = ak;\n    float kp = abs((ap * sin(angle_kap)) / sin(angle_akp));\n    float dist = abs(kp);\n    float cosTheta = cos(0.5*PI - angle_akp);\n    float tPdfW = 1.0 / (abs(thetaB - thetaA));\n    tPdfL = PdfWtoA(tPdfW, dist, cosTheta);\n}\n\n//Equiangular sampling of line segment\n//returns:\n// t - parametter on line\n// tPdf - pdf in length measure\nvoid sampleLine(vec3 pos,\n                vec3 normal,\n                vec3 line_p0,\n                vec3 line_dir,\n                float line_len,\n                float Xi,\n               \tout float t,\n                out float tPdfL ) {\n    \n    \n\tfloat t_fix = 0.0;\n    \n#ifdef LIGHT_CLIPPING\n    // clipping line segment\n    float line_len_max;\n    if(intersectPlane(normal, pos, line_p0, line_dir, line_len_max)) {\n        \n        //line_len = 0.0;//line_len_max;\n        if(line_len > line_len_max) {\n        \n            if(dot(line_dir, normal) > 0.0) {\n                line_p0 += line_dir*line_len_max;\n                line_len -= line_len_max;\n              \tt_fix = line_len_max;\n            } else {\n                line_len = line_len_max;\n            }\n        }\n    }\n#endif\n    \n    // project shading point on line and calculate length\n    float delta = dot(pos - line_p0, line_dir);\n\n    // distance from pos to line\n    float D = length(line_p0 + delta*line_dir - pos);\n\n    // get angle of endpoints\n    float thetaA = atan(0.0 - delta, D);\n    float thetaB = atan(line_len - delta, D);\n    float theta = mix(thetaA, thetaB, Xi);\n\n    // take sample\n    float delta1 = D*tan(theta);\n    float cosTheta = cos(theta);\n    float dist = D/cosTheta;\n    t = (delta1 + delta);\n    t += t_fix;\n    float tPdfW = 1.0 / (thetaB - thetaA);\n    tPdfL = PdfWtoA(tPdfW, dist, cosTheta);\n}\n\nvoid sampleDirectLight( vec3 pos,\n                       \tvec3 normal,\n                        float Xi1,\n                        float Xi2, \n                       \tout vec3 dir,\n                       \tout float pdf ) {\n    float height = objects[0].params_[2] - objects[0].params_[1];\n    float r = objects[0].params_[0];\n    float pdfA;\n    float d2;\n    float aCosThere;\n    float theta;\n    float thetaPdf;\n    float h;\n    float hPdf;\n    \n    //convert position to object space\n    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );\n    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );\n    \n    if(samplingTechnique == SAMPLE_TOTAL_AREA){\n        theta = Xi1*TWO_PI;\n        thetaPdf = 1.0/TWO_PI;\n        h = objects[0].params_[1] + Xi2*height;\n        hPdf = 1.0/height;\n        \n        vec3 n = vec3(cos(theta), sin(theta), 0.0);\n        vec3 p = n*r;\n        p.z = h;\n        dir = p - pos;\n        d2 = dot(dir,dir);\n        dir /= sqrt(d2);\n        aCosThere = max(0.0,dot(-dir,n));\n\n        pdfA = thetaPdf*hPdf*(1.0/r);\n        pdf = PdfAtoW( pdfA, d2, aCosThere );\n    } else {\n        vec3 cylinderPos = vec3(0.0, 0.0, objects[0].params_[1]);\n        vec3 cylinderVec = vec3(0.0, 0.0, 1.0);\n        \n        float dc_2 = dot(pos.xy,pos.xy);\n        float dc = sqrt(dc_2);\n        vec2 dirToPos = (-pos.xy)/dc;\n        float alphaMax = acos(r/dc);\n        float thetaMax = 0.5*PI - alphaMax;\n        theta = mix(0.0,thetaMax, Xi1);\n        float sinTheta = sin(theta);\n        float sin2Theta = sinTheta*sinTheta;\n        float cosTheta = sqrt(1.0-sin2Theta);\n        \n    \tfloat ds = dc * cosTheta - sqrt(max(0.0, r*r - dc_2 * sin2Theta));\n    \tfloat cosAlpha = (dc * dc + r*r - ds*ds) / (2.0 * dc * r);\n        \n        float alpha = acos(cosAlpha);\n        \n        //convert alpha to global angle\n        float baseAngle = atan(dirToPos.y,dirToPos.x) + PI;\n        float sign;\n        if(Xi2<0.5) {\n            sign =  1.0;\n            //normalize Xi\n            Xi2 /= 0.5;\n        } else {\n            sign = -1.0;\n            //normalize Xi\n            Xi2 = (Xi2 - 0.5) / 0.5;\n        }\n        \n        float alphaGlobal = baseAngle + alpha*sign;\n       \n        thetaPdf = 1.0/(2.0*thetaMax);// In angle measure\n        thetaPdf = PdfWtoA(thetaPdf, ds, cos(alpha+theta));\n        \n        vec3 n = vec3(cos(alphaGlobal), sin(alphaGlobal), 0.0);\n    \tvec3 p = n*r;\n        \n        //Sampling h\n        //We do equiangular sampling from shading point\n        {\n      \t\tsampleLine( pos, normalize(normal), p, normalize(cylinderVec), height, Xi2, h, hPdf );\n        }\n        \n        p.z = cylinderPos.z + h;\n        dir = p - pos;\n        d2 = dot(dir,dir);\n        dir /= sqrt(d2);\n        aCosThere = max(0.0,dot(-dir,n));\n\n        pdfA = thetaPdf*hPdf;\n        pdf = PdfAtoW( pdfA, d2, aCosThere );\n    }\n    \n    //convert dir to world space\n    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(25.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = L;\n        } else {\n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                float pdfWi;\n                \n            \tfloat Xi1 = rnd();\n            \tfloat Xi2 = rnd();\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                Xi2 = strataSize * (float(i) + Xi2);\n#endif\n                \n                sampleDirectLight( hit.position_, hit.normal_, Xi1, Xi2, Wi, pdfWi );\n                float dotNWi = dot( Wi, hit.normal_ );\n\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + hit.normal_*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float split = iMouse.x;\n    float k = iMouse.x/iResolution.x;\n    float split1 = iMouse.x*k;\n    float split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if(p > split+1.0){\n        samplingTechnique = SAMPLE_VISIBLE_AREA_IS;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[759, 856, 869, 869, 912], [952, 1070, 1130, 1130, 1223], [1225, 1276, 1336, 1336, 1476], [1553, 1553, 1576, 1576, 1666], [1668, 1668, 1795, 1795, 1903], [1905, 1905, 2075, 2075, 2206], [2208, 2208, 2239, 2239, 2390], [2392, 2431, 2462, 2462, 2848], [3434, 3472, 3563, 3563, 3999], [4001, 4001, 4108, 4108, 4475], [4477, 4477, 4546, 4546, 4913], [4915, 4915, 5026, 5026, 5393], [5395, 5395, 5434, 5434, 5627], [5629, 5629, 5647, 5647, 7746], [7748, 7827, 7903, 7903, 8193], [8195, 8195, 8369, 8369, 10772], [10775, 10775, 10903, 10903, 11785], [11788, 11788, 11957, 11957, 12582], [12584, 12584, 12752, 12752, 14030], [14032, 14032, 14185, 14185, 15833], [16079, 16079, 16208, 16208, 16340], [16423, 16505, 16583, 16583, 16691], [16693, 16693, 16783, 16783, 16933], [16935, 16935, 16990, 16990, 17244], [17246, 17246, 17321, 17321, 17464], [17466, 17466, 17542, 17542, 17661], [17663, 17663, 17715, 17715, 17843], [17845, 17917, 18062, 18062, 18316], [18960, 18960, 19017, 19017, 19267], [19269, 19269, 19355, 19399, 19604], [19606, 19606, 19644, 19644, 19683], [19685, 19685, 19721, 19721, 19768], [19770, 19770, 20249, 20269, 21551], [21553, 21661, 21899, 21899, 23057], [23059, 23059, 23280, 23280, 26012], [26014, 26014, 26052, 26052, 26234], [27738, 27738, 27775, 27775, 28150]], "test": "untested"}
{"id": "WtKXRz", "name": "Shaderplayer default shader", "author": "ttg", "description": "Default shader of [url=https://shaderplayer.com/]Shaderplayer[/url].  It's also meant as a very basic tutorial.  Is this a good compromise between having a somewhat interesting animation and still being short and understandable?", "tags": ["simple", "demo"], "likes": 6, "viewed": 479, "published": 3, "date": "1582092924", "time_retrieved": "2024-07-30T21:23:07.406253", "image_code": "void mainImage( out vec4 fragData, in vec2 fragCoord ) {\n\n  // Always initialize all variables\n  fragData = vec4(0.);\n\n  // Start all black\n  vec3 color = vec3(0.);\n\n  // A coordinate system for a 2D drawing, centered in frame, preserving aspect\n  vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n  // A soft circle\n  color = mix(color, vec3(.2), clamp( 4.-5.*length(uv), 0., 1.));\n\n  // Various sines\n  for (float i=0.; i<8.; i++) {\n    float h = i*.6;\n    float k = exp2(i/8.);\n    vec3 c = pow(.5+.5*cos(h-vec3(0,1,2)*2.094),vec3(2.));\n    color += .2*c*max( 0., 1.-2.*abs( sin(k*uv.x+iTime/k)*k - uv.y )/k );\n  }\n\n  // Convert to Gamma=2.2 and output to screen\n  fragData = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 94, 726]], "test": "untested"}
{"id": "WtKSzR", "name": "Marching Nyans", "author": "hanabi", "description": "cheap tricks...", "tags": ["nyan"], "likes": 0, "viewed": 289, "published": 3, "date": "1582069450", "time_retrieved": "2024-07-30T21:23:08.405581", "image_code": "#define M_PI 3.14159265358\n\n#define NYAN_W 40\n#define NYAN_H 32\n#define NYAN_W_F 40.\n#define NYAN_H_F 32.\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 nyan( in vec2 uv, in int index )\n{\n    index = index % 6;\n    ivec2 ruv = ivec2(NYAN_W * index + int(uv.x * float(NYAN_W)), int(uv.y * float(NYAN_H)));\n\treturn texelFetch(iChannel0, ruv, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rat = NYAN_W_F / NYAN_H_F;\n    float fFrame = float(iFrame);\n    float factor = abs(sin(M_PI / 180. * fFrame/5.)) + 2.0;\n    vec2 nyan_dim = vec2(NYAN_W_F, NYAN_H_F) * (iResolution.x / NYAN_W_F / 6.);\n    vec2 pos = fragCoord + vec2(fFrame * rat, fFrame);\n    vec2 fragCoordCapped =\n        mod(pos, nyan_dim) / nyan_dim;\n\tfragColor = nyan(fragCoordCapped, iFrame / 5 + int(pos / nyan_dim.x));\n    \n    fragColor = vec4(mix(\n        hsv2rgb(vec3(mod(nyan_dim.x*1.2-fragCoord.x + fragCoord.y * rat, nyan_dim.x) / nyan_dim.x, .65, 1.)),\n        fragColor.xyz,\n        fragColor.a), 1.);;\n}\n", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 134, 134, 303], [305, 305, 344, 344, 502], [504, 504, 561, 561, 1159]], "test": "untested"}
{"id": "WlKXRR", "name": "Day 61", "author": "jeyko", "description": "some inversion stuff", "tags": ["inversion", "mdtmjvm"], "likes": 43, "viewed": 1012, "published": 3, "date": "1582062441", "time_retrieved": "2024-07-30T21:23:09.245336", "image_code": "// thanks to mla and Kali!\n// They have super nice examples on inversion\n\n// it's really simple, basically\n// p /= dot(p,p);\n// p = sin(p);\n// SDFs\n// return distance*dot(p,p);\n\n\n// and ofc Inigo quilez for pallete!\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.3;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.2);\n    \n    fragColor = max(fragColor, 0.);\n    fragColor.xyz = pow(fragColor.xyz, vec3(2.,1. + sin(iTime)*0.2,1. - sin(iTime)*0.2));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define mx (iTime*0. + 20.*iMouse.x/iResolution.x)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) (a + b*cos(tau*(c*d + e)))\n\nvec3 pA = vec3(0);\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    float sc = 2.4;\n    float dp = dot(p,p);\n    p /= dp;\n    p*= sc;\n    p=sin(p+vec3(T*tau,1.4 - 1.*T*tau,.1 + sin(iTime*0.5)*0.6));\n    pA = p;\n    d.x = 0.;\n    d.x = max(d.x,-length(p) + 1.4);\n\treturn d*dp/sc;\n}\n\nvec3 glow = vec3(0);\nvec2 trace(vec3 ro, vec3 rd,inout vec3 p,inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    \n    for(int i = 0; i < 100; i++){\n    \td = map(p);\n        glow += exp(-d.x*90.);\n        if(d.x < 0.0001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    uv *= 1. + dot(uv,uv)*1.9;\n    vec3 ro = vec3(0.,0.,1.)*0.9;\n\n    ro.x += sin(mx)*0.;\n    vec3 lookAt = vec3(0.);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= rot(sin(iTime*0.5)*0.6);\n    rd.xz *= rot(sin(iTime*0.75)*0.2);\n    vec3 p; float t; bool hit;\n    vec2 d = trace(ro, rd, p, t, hit);\n    \n    if(hit){\n        vec3 pAA = pA;\n        float modD = 0.1;\n        float id = floor(pA.x/modD);\n        pA = pmod(pA, modD);\n        col += pal(0.12,vec3(1,0.7 + sin(id + iTime*0.25)*0.24,1.1)*1., vec3(5.,3.75 + cos(iTime + length(p))*0.04,1.1 ), 1.5, id*0.3 + pAA.z*0.5 + pAA.y*0.2 + iTime*0.12);\n        col *= 0.26 + step(abs(sin(id*4.))*1., 0.7);\n        col -= exp((abs(pA.x) - modD*0.5)*100.);\n\n        col -= exp(-length(p)*20.)*10.;\n        //col += smoothstep(0.01,0., length(pA.x) - modD*0.175);\n    }\n    \n    col -= glow*0.016;\n    col = clamp(col, 0., 1.);\n\n    col *= 1.;\n    //col = pow(col, vec3(0.45));\n    col = pow(col, vec3(0.45));\n    col *= 1. - 1.*pow(abs(uv.x)*0.55,2.9)*0.5;\n    col *= 1. - 1.*pow(abs(uv.y)*1.0,2.9)*0.5;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 276, 276, 1445]], "test": "untested"}
{"id": "wlGXzz", "name": " - Nvidia", "author": "totetmatt", "description": "nvidia", "tags": ["nvidia"], "likes": 8, "viewed": 381, "published": 3, "date": "1582059223", "time_retrieved": "2024-07-30T21:23:10.197789", "image_code": "\n#define ITER 92.\n#define dtime pow(fract(iTime*.25),.5)+floor(iTime*.25)\n#define ttime sin(iTime) *pow(cos(pow(iTime,.125)),2)\nmat2 r(float a){return mat2(cos(a),sin(a),\n                           -sin(a),cos(a));}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat sdBox (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n\n// SDF Sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// Global SDF\n// This represent our \"scene\" with the objects\n\n\nfloat fig(vec3 pos, float x,float b) {\n pos.y-=0.4;\n      pos.y +=cos(abs(pos.x))*.5*(b);\n      float sideBox =sdBox(pos,vec3(1.9*x,0.1-cos(abs(pos.x))*.05,0.4));\n      return sideBox;\n}\nvec2 SDF(vec3 pos) {\n   pos.y+=.5;\n   float c = 15.;\n      vec3 ppos = pos;\n      \n     vec3 id = floor(pos);\n      ppos.xy *=r(ppos.z*.006*sin(dtime));\n     pos = mod(ppos+0.5*c,c)-0.5*c;\n  \n   \n     pos.x*=1.4; \n     pos.yz  *=r(sin(iTime+pos.x*.5)*.4);\n     pos.xz  *=r(cos(iTime+pos.x*.5)*.4);\n \n\n   float dist = min(fig(pos+vec3(-.2,-0.4,.0),0.7,1.5),\n                min(fig(pos,1.,1.2),\n                    fig((-pos)+vec3(-.2,+1.1,.0),1./1.1,1.21))\n   \n   );\n   dist = min(dist,fig((-pos)+vec3(-.17,+.69,.0),0.5,1.21));\n\n   float labox = sdBox(pos-vec3(0.,.5,.0),vec3(2.3,.99,.29));\n  \n   \n   //dist = max(labox , -dist*cos(pos.x+dtime) );\n   dist = max(labox , -dist*sin(pos.x));\n      \n   return vec2(dist,0.0);\n  \n  }\n\n// Compute a normal from a vec3.\nvec3 get_normal(vec3 p) \n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(\n             vec3(\n                  SDF(p+eps.xyy).x - SDF(p-eps.xyy).x, // Diff in X\n                  SDF(p+eps.yxy).x - SDF(p-eps.yxy).x, // Diff in Y\n                  SDF(p+eps.yyx).x - SDF(p-eps.yyx).x  // Diff in Z\n             )\n            );  // Math Vector\n  }\n  \n// Lighting, here my limit of the knowledge\nfloat diffuse_directional(vec3 n,vec3 l){\n        \n    float a =  max(0.,dot(n,normalize(l))); // realistic lighting\n    float b =  dot(n,normalize(l))*.5+.5;   // less realistic lighting\n    return (b+a)/2. ; \n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n  \n  // Initialization of the Ray Marching algorithm\n  vec3 ray_origin = vec3(.01,.01,-8); // Were we start \n \n  vec3 ray_direction = normalize(vec3(uv,1.)); // going forward\n  \n  ray_direction.xz *=r(cos(iTime*.5)*.1);\n  vec3 position = ray_origin ; \n  \n  vec3 color = vec3(.0,.0,.0); // By default, everything will be black\n  \n  bool hit = false; \n  \n  float shad = 0.;\n  float part = 0.;\n  \n  \n  for(float i=0.; i<ITER; ++i) { // We iterate the ray\n \n    vec2 _distance = SDF(position); // Find the closest distance from the current position\n    if(_distance.x <0.0001) { // If we are close enough, it's a hit, we put the shad and break the loop\n        shad = i / ITER;\n        hit = true;\n        break;\n     }\n     part = _distance.y;\n     position += _distance.x * ray_direction; // Otherwise we conditnue the marching, updating the ray position\n   \n  }\n  \n  if(hit) { // If there is a hit we want to perfom some coloring\n  \n    // I don't really understand here, just some lighting effect to get a good rendering\n    vec3 n = get_normal(position);  \n    vec3 l = vec3(0.01+sin(iTime)*10.,-1.5+cos(iTime)*10.,-5.);\n    \n     color =  vec3(diffuse_directional(n,l)); // light diffuse\n   \n    \n      // Using the mix method toget some color\n      if(part == 0.){\n            vec3 color1 = mix(vec3(.1,0.1,0.1), vec3(0.0,0.9,0.2), color)*(1.-shad); \n             vec3 color2 = mix(vec3(.7,0.7,0.), vec3(0.0,0.5,0.6), color)*(1.6-shad); \n             color = mix(color1,color2,smoothstep(-0.5,0.9,sin(-iTime+length(uv)-2.*10.)));\n     } else {\n        color = mix(vec3(.9,0.9,0.9), vec3(0.9,0.0,0.2)+vec3(0.,0.,length(uv)), color)*(1.-shad); \n     }\n  } \n \n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 144, 144, 215], [381, 381, 416, 416, 511], [514, 528, 563, 563, 587], [589, 589, 646, 646, 982], [983, 983, 1019, 1019, 1369], [1434, 1434, 1472, 1472, 1620], [1621, 1621, 1641, 1641, 2349], [2351, 2384, 2410, 2410, 2734], [2738, 2782, 2823, 2823, 2994], [2996, 3013, 3068, 3068, 4823]], "test": "untested"}
{"id": "ttySzz", "name": "Protean Clouds (alow down", "author": "Onan", "description": "Fork of https://www.shadertoy.com/view/3l23Rh by the genius nimitz\n\nAdded a timeScaling variable (line 33) to speed up/slow down the shader.", "tags": ["procedural", "3d", "fast", "volumetric"], "likes": 12, "viewed": 789, "published": 3, "date": "1582051734", "time_retrieved": "2024-07-30T21:23:11.131293", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Edited by Onan\n// added timeScaling Variable for speeding up/slowing down\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\nfloat timeScaling = 0.2;\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime*timeScaling)*(0.1 + prm1*0.05) + iTime*timeScaling*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*timeScaling*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*timeScaling*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime*timeScaling)*0.5,sin(iTime*timeScaling*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*timeScaling*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySzz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1209, 1209, 1230, 1230, 1282], [1394, 1394, 1413, 1413, 1430], [1431, 1431, 1483, 1483, 1527], [1592, 1592, 1611, 1611, 1662], [1664, 1664, 1682, 1682, 2245], [2247, 2247, 2298, 2298, 3332], [3334, 3334, 3356, 3356, 3471], [3473, 3546, 3592, 3592, 3938], [3940, 3940, 3997, 3997, 5142]], "test": "untested"}
{"id": "tlGXRz", "name": "Dth Str", "author": "amausagi", "description": "from angle of victims", "tags": ["cineshader"], "likes": 45, "viewed": 45462, "published": 3, "date": "1582048197", "time_retrieved": "2024-07-30T21:23:12.118654", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \t\t\n    float t =  -iTime * 3. + 5000. +  sin(iTime / 3.) * 5.;\n    \n    float dist = distance(uv, vec2(0., 0.)) * .6;\n    float maxDist = .5;\n    vec4 color;\n               \n    float expDist = dist * dist * dist;\n    float strength = (sin(expDist * 100.)+1.)/2.;\n    float height = (sin(t * strength)+1.)/2.;\n    float alpha = 1. - expDist / (maxDist * maxDist * maxDist) + (1. - height) * -0.014  ;\n    color = vec4(.9,.9,.9, 9.) * height - (1. - alpha) * 0.652;\n    color.a = alpha;\n    if(dist > maxDist) color = vec4(.1,.1,.1, 0.);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 709]], "test": "untested"}
{"id": "tlySzR", "name": "Blue Noise scroll", "author": "iq", "description": "Translating blue noise over time instead of adding some irrational number (modulo 1) each frame to the noise values.", "tags": ["2d"], "likes": 26, "viewed": 2133, "published": 3, "date": "1582042808", "time_retrieved": "2024-07-30T21:23:13.010269", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n\n    p = (p+iFrame*ivec2(113,127)) & 1023;\n    \n    float f = texelFetch(iChannel0,p,0).x;\n    \n    fragColor = vec4(f,f,f,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 220]], "test": "untested"}
{"id": "tldSWl", "name": "Mandelbrot Zoom + AA", "author": "draradech", "description": "mandelbrot with zoom and AA", "tags": ["2d", "mandelbrot", "animated"], "likes": 0, "viewed": 28, "published": 3, "date": "1582041717", "time_retrieved": "2024-07-30T21:23:13.832072", "image_code": "#define ITER 4000.\n#define ESCA 1000.\n#define LOCA vec2(-.74587, .10071)\n\nvoid mandelbrot(out vec4 fragColor, in vec2 fragCoord)\n{\n    // small side is -1.5 to 1.5\n    vec2 uv = 1.5 * (2. * fragCoord - iResolution.xy) / min(iResolution.yy, iResolution.xx);\n    \n    // zoom in x1,000,000 over 60s\n    float fTime = mod(iTime, 60.) / 60.;\n    vec2 c = uv / pow(10., 6. * fTime) + LOCA;\n    \n    // skip M1 and M2 bulb\n    float c2 = dot(c, c);\n    if (  (256. * c2 * c2 - 96. * c2 + 32. * c.x - 3. < 0.)\n       || (16. * c2 + 32. * c.x + 15. < 0.)\n       )\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    // main loop\n    vec2 z = c;\n    vec2 zz;\n    float n;\n    for(n = 0.; n < ITER; n++)\n    {\n        zz = vec2(z.x * z.x, z.y * z.y);\n        if(zz.x + zz.y > ESCA) break;\n        z = vec2(zz.x - zz.y, 2. * z.x * z.y) + c;\n    }\n    \n    // coloration\n    if(n >= ITER)\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        float lzn = log(zz.x + zz.y) / 2.;\n        n -= log(lzn / log(2.)) / log(2.) - 1.;\n        n -= mix(0., 200., pow(fTime, 3.));\n    \tn /= mix(100., 3000., fTime);\n\t    fragColor = min(vec4(pow(n, 1.5), pow(n, .4), pow(n, .2), 1.), 1.);\n    }\n}\n\n#define AA 2.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0);\n    for (float dx = 0.; dx < AA; dx++)\n    {\n        for (float dy = 0.; dy < AA; dy++)\n        {\n            vec2 p = fragCoord + vec2(dx, dy) / AA;\n            vec4 col;\n            mandelbrot(col, p);\n            fragColor += col / AA / AA;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 130, 163, 1197], [1213, 1213, 1268, 1268, 1555]], "test": "untested"}
{"id": "3lyXzz", "name": "Motion Loop #003", "author": "lsdlive", "description": "A small one, just to practice patterns.", "tags": ["2d", "loop", "motion", "ease"], "likes": 7, "viewed": 655, "published": 3, "date": "1582036063", "time_retrieved": "2024-07-30T21:23:14.592040", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #003\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_003.fs\n\nWith the help of: https://thebookofshaders.com/examples/?chapter=motionToolKit\nWith the help of: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n\n*/\n\n#define bpm 120.\n#define speed .25\n#define cross_height .1\n#define cross_width .4\n#define circle_radius .25\n#define circle_stroke .2\n\n#define AA 5.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat bridge(float mask, float sdf, float w) {\n    mask *= 1. - stroke(sdf, w * 2.);\n    return mask + stroke(sdf, w);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat rect(vec2 p, vec2 size) {\n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t1 = fract(time * .25);// sliding\n    float t2 = fract(time);// rotation\n    t2 = easeInOutQuad(t2);\n    \n    uv *= r2d(pi * .25);\n    vec2 uv1 = fract((uv + t1) * 4.) - .5;\n    vec2 uv2 = fract(((uv-vec2(t1, 0)) * 4.)+.5) - .5;\n\n    // layer1 - cross\n    float mask = fill(rect(uv1 * r2d(t2 * pi), vec2(cross_height, cross_width)));\n    mask += fill(rect(uv1 * r2d(t2 * pi), vec2(cross_width, cross_height)));\n    \n    // layer2 - circle\n    mask = bridge(mask, circle(uv2, circle_radius), circle_stroke) ;\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXzz.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[640, 640, 659, 659, 725], [727, 727, 748, 748, 805], [807, 940, 976, 976, 1048], [1050, 1050, 1096, 1096, 1170], [1172, 1172, 1208, 1208, 1239], [1241, 1241, 1272, 1272, 1355], [1357, 1357, 1387, 1387, 1510], [1512, 1512, 1569, 1569, 2288]], "test": "untested"}
{"id": "3tyXRz", "name": "cartoonish Britney 2", "author": "FabriceNeyret2", "description": "extract local contrast using MIPmap LOD0/LOD1.", "tags": ["video", "video", "filter", "image", "processing", "integration", "signal", "gpmipmap"], "likes": 5, "viewed": 592, "published": 3, "date": "1582029262", "time_retrieved": "2024-07-30T21:23:15.373950", "image_code": "// variant of https://shadertoy.com/view/WlGXRz\n// variant of \"free local contrast \" https://shadertoy.com/view/Mt2cDm\n\n#define T(l) textureLod( iChannel0, U/iResolution.xy, l )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = .7* T(0.) / T(1.);         // local contrast\n    \n    O = vec4(length(O.rgb)/1.3);\n  //O = vec4(length(O.rgb)*1.4 -.7);\n  //O = vec4(length(O.rgb)*1.6 -1.);\n  //O = vec4(length(O.rgb)*2.4 -2.);\n  //O = vec4(length(O.rgb)*2.5 -2.);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 217, 217, 458]], "test": "untested"}
{"id": "WlGXRz", "name": "cartoonish Britney", "author": "FabriceNeyret2", "description": "extract highest frequency using MIPmap LOD0-LOD1, \nthen multiply by lowres chrominance.", "tags": ["video", "video", "filter", "image", "processing", "integration", "signal", "gpmipmap"], "likes": 6, "viewed": 559, "published": 3, "date": "1582028876", "time_retrieved": "2024-07-30T21:23:16.137907", "image_code": "// variant of \"free local contrast \" https://shadertoy.com/view/Mt2cDm\n\n#define T(l) textureLod( iChannel0, U/R, l )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = .5 + 30.*(T(0.) - T(1.));  // highest frequency\n  //O = .7* T(0.) / T(1.);         // local contrast\n    O.a = 0.;\n    \n    vec4 T = T(3.);\n    float m = min(T.r,min(T.g,T.b)),\n          M = max(T.r,max(T.g,T.b));\n    \n    O = dot(O,O) * (T-m)/(M-m);\n        // highest frequency luminance * lowres chrominance\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 156, 156, 506]], "test": "untested"}
{"id": "3tySRR", "name": "Line/Arc font stroke animation", "author": "hiogawa", "description": "Simple font made from line and arc.\nThe original font geometry (in svg) is here [url]https://github.com/hi-ogawa/python-shader-app/blob/master/misc/la_font[/url].\nHere only upper case alphabets but I implemented all ascii characters.", "tags": ["font"], "likes": 41, "viewed": 1297, "published": 3, "date": "1582014463", "time_retrieved": "2024-07-30T21:23:16.911838", "image_code": "//\n// Font distance function is defined in \"common\"\n//\n\n\n//\n// Parameters\n//\n\nfloat SCALE_TIME = 8.0;\nfloat LOOP_TIME = 32.0;\nbool  STROKE_MODE = true;\n\n// AA in pixel width\nfloat AA = 2.0;\n\n// isoline effect\nfloat ISOLINE_STEP = 10.0;\nfloat ISOLINE_WIDTH = 1.0;\nfloat ISOLINE_EXTENT = 200.0;\n\n// scene coordinate frame\nconst vec2 FONT_SIZE = vec2(4.0, 7.0);\nconst float NUM_COLUMNS = 10.0;\nconst vec2 BBOX_X = vec2(0.0, FONT_SIZE.x * NUM_COLUMNS) + vec2(-2.0, 2.0);\nconst float BBOX_Y1 = FONT_SIZE.y;\n\n// font width in scene size\nfloat FONT_WIDTH = 0.4;\n\n\n//\n// Implement scene\n//\n\nstruct SceneInfo {\n  float t;\n  float id;\n};\n\nSceneInfo mergeSceneInfo(SceneInfo info, float t, float id) {\n  info.id = info.t < t ? info.id : id;\n  info.t  = info.t < t ? info.t  : t ;\n  return info;\n}\n\nSceneInfo getSceneSdf(vec2 p, float time) {\n  SceneInfo result;\n  result.t = 1e30;\n\n  float index = 0.0;\n  float state = STROKE_MODE ? SCALE_TIME * mod(time, LOOP_TIME) : 1e30;\n  float len = 0.0;\n  float ud;\n  vec2 q;\n  // Loop over FONT_LIST_NAMES (macro defined in \"common\")\n  #define DRAW(NAME)                                                         \\\n      q = vec2(0.5 + mod(index, NUM_COLUMNS), - floor(index / NUM_COLUMNS)); \\\n      ud = NAME(p - FONT_SIZE * q, state -= len, len),       \\\n      result = mergeSceneInfo(result, ud, index++);\n    FONT_LIST_NAMES(DRAW)\n  #undef DRAW\n\n  result.t -= FONT_WIDTH / 2.0;\n  return result;\n}\n\n//\n// Misc\n//\n\nfloat SdfOp_isoline(float sd, float _step, float width) {\n  float t = mod(sd, _step);\n  float ud_isoline = min(t, _step - t);\n  float sd_isoline = ud_isoline - width / 2.0;\n  return sd_isoline;\n}\n\nfloat smoothCoverage(float signed_distance, float width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / width + 0.5);\n}\n\nvec3 easyColor(float t) {\n  float s = fract(sin(t * 123456.789) * 123456.789);\n  vec3 v = vec3(0.0, 1.0, 2.0) / 3.0;\n  vec3 c = 0.5 + 0.5 * cos(2.0 * M_PI * (s - v));\n  c = smoothstep(vec3(-0.2), vec3(0.8), c);\n  return c;\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  // \"window -> scene\" transform\n  float xform_s = (BBOX_X[1] - BBOX_X[0]) / iResolution.x;\n  vec2 xform_t = vec2(\n      BBOX_X[0],\n      BBOX_Y1 - (BBOX_X[1] - BBOX_X[0]) * (iResolution.y / iResolution.x));\n\n  vec2 p = frag_coord * xform_s + xform_t;\n  bool mouse_down = iMouse.z > 0.5;\n\n  vec3 color = vec3(1.0);\n  {\n    //\n    // Main rendering\n    //\n    SceneInfo info = getSceneSdf(p, iTime);\n    float fac = smoothCoverage(info.t, AA * xform_s);\n    vec3 c = easyColor(info.id);\n\n    //\n    // Fancy isolines\n    //\n    float sd = info.t / xform_s; // to window sp.\n    float ud = abs(max(0.0, sd));\n    float sd_isoline = SdfOp_isoline(ud, ISOLINE_STEP, ISOLINE_WIDTH);\n    float isoline_fac = smoothCoverage(sd_isoline, AA);\n    float fade_fac = exp(-7.0 * ud / ISOLINE_EXTENT); // n.b. exp(-7) ~ 0.001\n    color = mix(color, c, fade_fac);\n    color = mix(color, c * vec3(0.6), isoline_fac * fade_fac);\n  }\n\n  {\n    //\n    // Coordinate grid\n    //\n    {\n      // Grid\n      float step = 1.0;\n      float w = 1.0 * xform_s;\n      float sd = 1e30;\n      sd = min(sd, SdfOp_isoline(p.x, step, w));\n      sd = min(sd, SdfOp_isoline(p.y, step, w));\n      float fac = smoothCoverage(sd, AA * xform_s);\n      color = mix(color, vec3(0.0), 0.1 * fac);\n    }\n    {\n      // Axis\n      float w = 1.0 * xform_s;\n      float sd = 1e30;\n      sd = min(sd, SdfOp_isoline(p.x, FONT_SIZE.x, w));\n      sd = min(sd, SdfOp_isoline(p.y, FONT_SIZE.y, w));\n      float fac = smoothCoverage(sd, AA * xform_s);\n      color = mix(color, vec3(0.0), 0.4 * fac);\n    }\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "//\n// Sdf routines\n//\n\n#define M_PI 3.14159\n\nfloat Sdf_lineSegment(vec2 p, vec2 v, float t0, float t1) {\n  // assert |v| = 1\n  return distance(p, clamp(dot(p, v), t0, t1) * v);\n}\n\nfloat Sdf_arc(vec2 p, float t0, float t1) {\n  //\n  // \"Arc\" defined as a path of winding map:\n  //   R --> S1\n  //   t |-> (cos(2pi t), sin(2pi t))\n  //\n  // Thus, sign(t1 - t0) gives orientation i.e.\n  //   t1 >= t0  (counter clock wise)\n  //   t0 >= t1  (clock wise)\n  //\n  float t  = atan(p.y, p.x) / (2.0 * M_PI); // in [-0.5, 0.5]\n  float tt = mod(t - t0, 1.0) + t0;         // in [t0, t0 + 1]\n\n  // Check if \"(0, 0) -> p\" crosses arc\n  if ((t0 <= t1 && tt <= t1) || (t1 <= t0 && t1 <= tt - 1.0)) {\n    return abs(length(p) - 1.0);\n  }\n\n  // Otherwise return distance to two endpoints\n  vec2 q1 = vec2(cos(2.0 * M_PI * t0), sin(2.0 * M_PI * t0));\n  vec2 q2 = vec2(cos(2.0 * M_PI * t1), sin(2.0 * M_PI * t1));\n  return min(distance(p, q1), distance(p, q2));\n}\n\n\n//\n// Define font geometry (and stroke progress effect) via macro\n//\n\n#define SDF_FONT(NAME, RULE)     \\\n  float NAME(vec2 p, float state, out float stroke) { \\\n    float ud = 1e30;                                     \\\n    stroke = 0.0;                                        \\\n    RULE                                                 \\\n    return ud;                                           \\\n  }\n\n#define SDF_FONT_LINE(x0, y0, x1, y1) \\\n  {                                                                    \\\n    vec2 v = vec2(x1, y1) - vec2(x0, y0);                              \\\n    float l = length(v);                                               \\\n    float ll = min(state - stroke, l);                                 \\\n    if (ll > 0.0) {                                                    \\\n      ud = min(ud, Sdf_lineSegment(p - vec2(x0, y0), v / l, 0.0, ll)); \\\n    }                                                                  \\\n    stroke += l;                                                       \\\n  }\n\n#define SDF_FONT_ARC(cx, cy, r, t0, t1) \\\n  {                                                                       \\\n    float s = sign(t1 - t0);                                              \\\n    float l = r * 2.0 * M_PI * abs(t1 - t0);                              \\\n    float ll = min(state - stroke, l);                                    \\\n    float tt = ll / (r * 2.0 * M_PI);                                     \\\n    if (tt > 0.0) {                                                       \\\n      ud = min(ud, Sdf_arc((p - vec2(cx, cy)) / r, t0, t0 + s * tt) * r); \\\n    }                                                                     \\\n    stroke += l;                                                          \\\n  }\n\n\n//\n// These macros are generated from (annotated) svg\n//\n\nSDF_FONT(en_A,\n  SDF_FONT_LINE(0, 4, -1, 0)\n  SDF_FONT_LINE(0, 4, 1, 0)\n  SDF_FONT_LINE(-0.75, 1, 0.75, 1))\n\nSDF_FONT(en_B,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 4)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 2, -1, 2)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 0, -1, 0))\n\nSDF_FONT(en_C,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0))\n\nSDF_FONT(en_D,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_ARC (-1.0, 2.0, 2.0, 0.25, -0.25))\n\nSDF_FONT(en_E,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(-1, 2, 1, 2)\n  SDF_FONT_LINE(-1, 0, 1, 0))\n\nSDF_FONT(en_F,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(-1, 2, 1, 2))\n\nSDF_FONT(en_G,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 2)\n  SDF_FONT_LINE(0, 2, 1, 2))\n\nSDF_FONT(en_H,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 2, 1, 2)\n  SDF_FONT_LINE(1, 4, 1, 0))\n\nSDF_FONT(en_I,\n  SDF_FONT_LINE(-0.5, 4, 0.5, 4)\n  SDF_FONT_LINE(0, 4, 0, 0)\n  SDF_FONT_LINE(-0.5, 0, 0.5, 0))\n\nSDF_FONT(en_J,\n  SDF_FONT_LINE(0.5, 4, 1.5, 4)\n  SDF_FONT_LINE(1, 4, 1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.0, -0.5))\n\nSDF_FONT(en_K,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(1, 4, -1, 2)\n  SDF_FONT_LINE(-1, 2, 1, 0))\n\nSDF_FONT(en_L,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 0, 1, 0))\n\nSDF_FONT(en_M,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 0)\n  SDF_FONT_LINE(0, 0, 1, 4)\n  SDF_FONT_LINE(1, 4, 1, 0))\n\nSDF_FONT(en_N,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 1, 0)\n  SDF_FONT_LINE(1, 0, 1, 4))\n\nSDF_FONT(en_O,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 3)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.25))\n\nSDF_FONT(en_P,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 4)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 2, -1, 2))\n\nSDF_FONT(en_Q,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 3)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.25)\n  SDF_FONT_LINE(0, 1, 1, 0))\n\nSDF_FONT(en_R,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 4)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 2, -1, 2)\n  SDF_FONT_LINE(0, 2, 1, 0))\n\nSDF_FONT(en_S,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.75)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.25, -0.5))\n\nSDF_FONT(en_T,\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(0, 4, 0, 0))\n\nSDF_FONT(en_U,\n  SDF_FONT_LINE(-1, 4, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 4))\n\nSDF_FONT(en_V,\n  SDF_FONT_LINE(-1, 4, 0, 0)\n  SDF_FONT_LINE(0, 0, 1, 4))\n\nSDF_FONT(en_W,\n  SDF_FONT_LINE(-1, 4, -0.5, 0)\n  SDF_FONT_LINE(-0.5, 0, 0, 4)\n  SDF_FONT_LINE(0, 4, 0.5, 0)\n  SDF_FONT_LINE(0.5, 0, 1, 4))\n\nSDF_FONT(en_X,\n  SDF_FONT_LINE(-1, 4, 1, 0)\n  SDF_FONT_LINE(1, 4, -1, 0))\n\nSDF_FONT(en_Y,\n  SDF_FONT_LINE(-1, 4, 0, 2)\n  SDF_FONT_LINE(1, 4, 0, 2)\n  SDF_FONT_LINE(0, 2, 0, 0))\n\nSDF_FONT(en_Z,\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 0, 1, 0))\n\n#define FONT_LIST_NAMES(_) \\\n  _(en_A) \\\n  _(en_B) \\\n  _(en_C) \\\n  _(en_D) \\\n  _(en_E) \\\n  _(en_F) \\\n  _(en_G) \\\n  _(en_H) \\\n  _(en_I) \\\n  _(en_J) \\\n  _(en_K) \\\n  _(en_L) \\\n  _(en_M) \\\n  _(en_N) \\\n  _(en_O) \\\n  _(en_P) \\\n  _(en_Q) \\\n  _(en_R) \\\n  _(en_S) \\\n  _(en_T) \\\n  _(en_U) \\\n  _(en_V) \\\n  _(en_W) \\\n  _(en_X) \\\n  _(en_Y) \\\n  _(en_Z) \\\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tySRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 629, 690, 690, 785], [1445, 1445, 1502, 1502, 1640], [1642, 1642, 1700, 1700, 1770], [1772, 1772, 1797, 1797, 1996], [2013, 2013, 2067, 2100, 3659]], "test": "untested"}
{"id": "wtdSWs", "name": "Basic Fractal Zero Sin", "author": "PauloFalcao", "description": "Sin Distortion makes everything more beautiful... :D\nA variation of https://www.shadertoy.com/view/tltSWs\n", "tags": ["2d", "fractal"], "likes": 7, "viewed": 354, "published": 3, "date": "1581984779", "time_retrieved": "2024-07-30T21:23:17.694745", "image_code": "//Basic Fractal Sin by @paulofalcao\n\nconst int maxIterations=8;\n\n//generic rotation formula\nvec2 rot(vec2 uv,float a){\n    float c=cos(a);float s=sin(a);\n    return uv*mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//normalize stuff\n\tvec2 uv=iResolution.xy;uv=-.5*(uv-2.0*fragCoord.xy)/uv.x;\n\n\t//global zoom\n\tuv*=sin(iTime)*2.5+5.5;\n\n\t//shift, mirror, rotate and scale 6 times...\n\tfor(int i=0;i<maxIterations;i++){\n        uv*=1.5;                        //<-Scale\n        uv=rot(uv,iTime);               //<-Rotate\n        uv+=sin(uv*sin(iTime)*8.0)*0.1; //<-Sin Distortion\n\t\tuv=abs(uv);                     //<-Mirror\n        uv-=0.5;                        //<-Shift\n\t}\n\n\t//draw a circle\n\tfloat c=length(uv)>0.2?0.0:1.0;\t\n\n\tfragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 92, 118, 118, 185], [187, 187, 243, 262, 787]], "test": "untested"}
{"id": "tltSWs", "name": "Basic Fractal Zero", "author": "PauloFalcao", "description": "A very very simple fractal, just shift, mirror, rotate and scale space ;)\n\nThis a more elegant way to do my old \"basic fractal\" - https://www.shadertoy.com/view/Mss3Wf ", "tags": ["2d", "fractal"], "likes": 20, "viewed": 1125, "published": 3, "date": "1581982370", "time_retrieved": "2024-07-30T21:23:18.514553", "image_code": "//Basic Fractal Zero by @paulofalcao\n\nconst int maxIterations=6;\n\n//generic rotation formula\nmat2 rot(float a){\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//normalize stuff\n    vec2 R=iResolution.xy,uv=(fragCoord-0.5*R)/R.x;\n    \n\t//global zoom\n\tuv*=sin(iTime)*0.5+1.5;\n    \n\t//shift, mirror, rotate and scale 6 times...\n\tfor(int i=0;i<maxIterations;i++){\n        uv*=2.1;          //<-Scale\n        uv*=rot(iTime);   //<-Rotate\n\t\tuv=abs(uv);       //<-Mirror\n        uv-=0.5;          //<-Shift\n\t}\n\n\t//draw a circle\n\tfragColor=vec4(length(uv)<0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 93, 111, 111, 175], [177, 177, 233, 252, 631]], "test": "untested"}
{"id": "ttdXDl", "name": "Maskit Kleinian Limit Set", "author": "mla", "description": "Playing around with Jos Leys Kleinian Limit Set shader (I think knighty had a hand too): [url]https://www.shadertoy.com/view/MtKXRh[/url]\n\n<mouse> moves things around with a Mobius transformation (move to left edge to disable).\n\nOther keys: see code.", "tags": ["kleinian", "maskit", "limitset", "josleys"], "likes": 46, "viewed": 1176, "published": 3, "date": "1581980874", "time_retrieved": "2024-07-30T21:23:19.327379", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Maskit parameterization of Kleinian Limit Sets\n//\n// Original by Jos Leys: https://www.shadertoy.com/view/MtKXRh\n//\n// Jos Leys' explanation: http://www.josleys.com/articles/Kleinian%20escape-time_3.pdf\n// Indra's Pearls: https://en.wikipedia.org/wiki/Indra%27s_Pearls_(book)\n//\n// This version by Matthew Arcus, 2020, mainly just prettified a little.\n//\n// A Kleinian group is generated by two or more Mobius transformations.\n// Repeated application of the group operations result in points\n// moving towards the \"limit set\" which often has an interesting fractal\n// structure.\n//\n// The Maskit parameterization is a way of finding \"interesting\" Kleinian\n// groups that are also amenable to being computer generated in a pointwise\n// way.\n//\n// <mouse>: apply Mobius transformation\n// <up>/<down>: zoom in/out\n// h: map to half plane\n// p: use mouse position for Maskit parameters\n// i: invert in unit disc at mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat AA = 2.0;\n\nbool check = false; // Debugging\nvec3  color1 = vec3(0);\nvec3  color2 = vec3(1,0,0);\nvec3  color3 = vec3(1,1,0);\n\nconst float PI = 3.14159265;\n\n// Interesting parameters, mostly taken from \"Indra's Pearls\"\nconst vec2[] Params =\n  vec2[](vec2(1.8462756,0.09627581),\n         vec2(1.958591,0.011278), // 1/15 cusp\n         vec2(1.857382,0.076258), // 2/15 cusp\n         //vec2(1.90378,0.03958), // 2/19 cusp\n         //vec2(1.64213876,0.76658841),\n         //vec2(1.658312,0.5), // 3/10 cusp\n         //vec2(1.926434053,0.027381792) // MSW p. 323\n         vec2(2,0)); // Apollonian Gasket\n\nconst int NPARAMS = Params.length();\n\nbool domix = true;\n\nint NSTEPS = 50;\n\n//circle inversion\nvec2 InvCentre = vec2(0,-1);\nfloat radius2 = 2.0;\n\nfloat wrap(float x, float a, float s) {\n  return mod(x-s,a) + s;\n}\n\n// Apply Maskit Mobius transformation\nvoid TransA(inout vec2 z, float a, float b, inout float scale){\n  float iR = 1.0/dot(z,z);\n  z *= iR;\n  scale *= iR;\n  z.x = z.x - b;\n  z.y = a - z.y; \n}\n\n// Rotate positions above this line to below the line.\n// This is the clever part.\nbool separation(vec2 z, float a, float b) {\n  //return z.y >= a * 0.5 + sign(b)*(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5)));\n  float u = a, v = b, x = z.x, y = z.y;\n  float f = (x >= -v/2.0) ? 1.0 : -1.0;\n  float K = sign(b)*(2.0*a-1.95)/4.3;\n  float M = 7.2-(1.95-a)*18.0;\n  return z.y >= 0.5*u + K*f*(1.0 - exp(-M*abs(z.x + v * 0.5)));\n}\n\nvec4 JosKleinian(vec2 z, float a, float b, inout float scale) {\n  //if (separation(z,a,b)) check = true;\n  float f = sign(b);\n  vec2 lz = z+vec2(1), llz = z-vec2(1);\n  //z.y = mod(z.y,a);\n  float flag = 1.0;\n  for (int i = 0; i < 2*NSTEPS ; i++) {\n    z.x = z.x+f*b/a*z.y;\n    z.x = wrap(z.x, 2.0, -1.0);\n    z.x = z.x-f*b/a*z.y;\n                       \n    //If above the separation line, rotate by 180 about (-b/2, a/2)\n    if (separation(z,a,b)) {\n      z = vec2(-b, a) - z;\n      flag++;\n    }\n        \n    // Apply Mobius transformation a\n    TransA(z,a,b,scale);\n\t\t\n    // If the iterated points enters a 2-cycle, bail out.\n    if (dot(z-llz,z-llz) < 1e-6) {\n      return vec4(0,i,0.05,scale);\n    }\n    // If the iterated point gets outside z.y=0 and z.y=a, bail out.\n    if (z.y < 0.0) return vec4(flag,i,-z.y,scale);\n    if (z.y > a) return vec4(flag,i,z.y-a,scale);\n\n    //Store previous iterates for 2-cycle check\n    llz=lz; lz=z;\n  }\n  return vec4(0,NSTEPS,0,0);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_P = 80;\nconst int CHAR_S = 83;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0);\n  vec2 Klein = Params[int(iTime)%NPARAMS];\n  if (domix) {\n    float t = mod(0.2*iTime,float(NPARAMS));\n    int i = int(floor(t));\n    t = fract(t);\n    Klein = mix(Params[i],Params[(i+1)%NPARAMS],smoothstep(0.0,1.0,t));\n  }\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord.xy + vec2(i,j)/AA) - iResolution.xy) / iResolution.y;\n      float zoom = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n      z *= zoom;\n      float a = Klein.x;\n      float b = Klein.y;\n      float scale = 1.0; // Keep track of scaling factor here\n      if (false) {\n        // Invert in moving disc.\n        vec2 c = vec2(0,1.225*cos(iTime));\n        z -= c;\n        float k = 1.0/dot(z,z);\n        z *= k;\n        scale *= k;\n        z += c;\n      }\n      if (false && dot(z,z) > 1.0) {\n        float k = 1.0/dot(z,z);\n        z *= k;\n        scale *= k;\n      }\n      // Mouse handling\n      if (iMouse.x > 10.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        if (keypress(CHAR_P)){\n          a = 2.0+0.1*m.x;\n          b = 0.1*m.y;\n        } else if (keypress(CHAR_I)) {\n          // Invert in unit disc at mouse\n          z -= m;\n          float k = 1.0/dot(z,z);\n          z *= k;\n          scale *= k;\n          z += m;\n        } else {\n          // Unit disc inversion\n          m /= dot(m,m);\n          z -= m;\n          float k = (dot(m,m)-1.0)/dot(z,z);\n          z *= k;\n          scale *= abs(k);\n          z += m;\n        }\n      }\n      if (keypress(CHAR_H)) {\n        // Leave in half plane, but adjust position & size\n        z.y += 1.0;\n        z *= 0.5*a;\n      } else {\n        // Invert to unit disc\n        z -= InvCentre;\n        float d2 = radius2/dot(z,z);\n        z *= d2;\n        scale *= d2;\n        z += InvCentre;\n      }\n      vec4 hit = JosKleinian(z,a,b,scale);\n      vec3 col = color1;\n      if (hit.x != 0.0) {\n        //if (mod(hit.x,2.0) == 0.0) col = color2;\n        //else col = color3;\n        col = hsv2rgb(vec3(0.7+hit.y/float(NSTEPS),1,1));\n      }\n      //col = mix(col,vec3(0),smoothstep(0.0,0.005,hit.z/hit.w));\n      //col = mix(col,vec3(0),smoothstep(0.0,max(zoom*4.0/iResolution.y,0.005),hit.z/scale));\n      col = mix(col,vec3(0),smoothstep(0.0,zoom*4.0/iResolution.y,hit.z/scale));\n      fragColor += vec4(col, 1.0);\n    }\n  }\n  fragColor /= AA*AA;\n  fragColor = pow(fragColor,vec4(0.4545));\n  if (check) fragColor.x = 0.5;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1849, 1849, 1888, 1888, 1915], [1917, 1955, 2018, 2018, 2108], [2110, 2193, 2236, 2363, 2578], [2580, 2580, 2643, 2684, 3559], [3561, 3656, 3683, 3683, 3859], [3861, 3861, 3886, 3886, 3946], [3948, 3948, 3973, 3973, 4021], [4023, 4023, 4046, 4046, 4078], [4479, 4479, 4534, 4534, 6998]], "test": "untested"}
{"id": "wttXDl", "name": "Palace of Mind", "author": "butadiene", "description": "IFS", "tags": ["raymarchingcineshader"], "likes": 36, "viewed": 46915, "published": 3, "date": "1581980540", "time_retrieved": "2024-07-30T21:23:20.151177", "image_code": "vec2 rot(vec2 p,float r) {\n    mat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n    return m*p;\n}\n\nfloat cube(vec3 p,vec3 s) {\n    vec3 q = abs(p);\n    vec3 m = max(s - q,0.0);\n    return length(max(q - s,0.0)) - min(min(m.x,m.y),m.z);\n}\n\n\nfloat hasira(vec3 p,vec3 s) {\n    vec2 q = abs(p.xy);\n    vec2 m = max(s.xy - q.xy,vec2(0.0,0.0));\n    return length(max(q.xy - s.xy,0.0)) - min(m.x,m.y);\n}\n\nfloat closs(vec3 p,vec3 s) {\n    float d1 = hasira(p,s);\n    float d2 = hasira(p.yzx,s.yzx);\n    float d3 = hasira(p.zxy,s.zxy);\n    return min(min(d1,d2),d3);\n}\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat dist(vec3 p) {\n    float k = 1.2;\n    vec3 sxyz = floor((p.xyz - 0.5 * k) / k) * k;\n    float sz = rand(sxyz.xz);\n    float t = iTime*0.05+50.0;\n    p.xy = rot(p.xy, t*sign(sz-0.5) * (sz * 0.5 + 0.7));\n    p.z += t*sign(sz - 0.5)*(sz*0.5+0.7);\n    p = mod(p, k) - 0.5*k;\n    float s = 7.0;\n    p *= s;\n    p.yz = rot(p.yz, 0.76);\n    for (int i = 0; i < 4; i++) {\n        p = abs(p) - 0.4+(0.25+0.1*sz)*sin(t*(0.5+sz));\n        p.xy = rot(p.xy, t*(0.7+sz));\n        p.yz = rot(p.yz, 1.3*t+sz);\n    }\n\n    float d1 = closs(p,vec3(0.06,0.06,0.06));\n\n    return d1/s;\n}\n\nvec3 gn(vec3 p) {\n\n    const float h = 0.001;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy * dist(p + k.xyy * h) +\n                     k.yyx * dist(p + k.yyx * h) +\n                     k.yxy * dist(p + k.yxy * h) +\n                     k.xxx * dist(p + k.xxx * h));\n\n}\nvec3 light(vec3 p,vec3 view) {\n    vec3 normal = gn(p);\n    float vn = clamp(dot(-view, normal),0.0,1.0);\n    vec3 ld = normalize(vec3(-1,0.9*sin(iTime*0.5)-0.1,0));\n    float NdotL = max(dot(ld, normal), 0.0);\n    vec3 R = normalize(-ld + NdotL * normal * 2.0);\n    float spec = pow(max(dot(-view, R), 0.0), 20.0) * clamp(sign(NdotL),0.0,1.0);\n    vec3 col = vec3(1, 1, 1) * (pow(vn,2.0)*0.9 +spec * 0.3);\n    float  k = 0.5;\n    float ks = 0.9;\n    vec2 sxz = floor((p.xz - 0.5 * ks) / ks) * ks;\n    float sx = rand(sxz);\n    float sy = rand(sxz+100.1);\n    float emissive = clamp(0.001/abs((mod(abs(p.y*sx+p.x*sy)+iTime*sign(sx-0.5)*0.4, k) - 0.5 * k)),0.0,1.0);\n    return clamp(col * vec3(0.3,0.5,0.9)*0.7 +emissive*vec3(0.2,0.2,1.0),0.0,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.yy;\n    vec3 tn = iTime*vec3(0.0,0.0,1.0)*0.3;\n    float tk = iTime*0.3;\n    vec3 ro = vec3(1.*cos(tk),0.2*sin(tk),1.*sin(tk))+tn;\n    vec3 ta = vec3(0.0,0.0,0.0)+tn;\n    vec3 cdir = normalize(ta-ro);\n    vec3 up =vec3(0.,1.,0.);\n    vec3 side = cross(cdir,up);\n    up = cross(side,cdir);\n    float fov = 1.3;\n    vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n    float d = 0.0;\n    float t = 0.1;\n    float far = 18.;\n    float near = t;\n    float hit = 0.0001;\n    for(int i =0;i<100;i++){\n      d = dist(ro+rd*t);\n      t += d;\n      if (hit>d) break;\n    }\n\tvec3 bcol = vec3(0.1, 0.1, 0.8);\n    vec3 col = light(ro + rd * t, rd);\n\n    col = mix(bcol, col, pow(clamp((far - t) / (far - near), 0.0, 1.0),2.0));\n\n   \tcol.x = pow(col.x,2.2);\n    col.y = pow(col.y,2.2);\n    col.z = pow(col.z,2.2);\n\tcol *= 2.0;\n    fragColor = vec4(col,1.1-t);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 93], [95, 95, 122, 122, 233], [236, 236, 265, 265, 392], [394, 394, 422, 422, 555], [556, 556, 577, 577, 650], [652, 652, 674, 674, 988], [990, 990, 1010, 1010, 1562], [1564, 1564, 1581, 1581, 1852], [1853, 1853, 1883, 1883, 2603], [2607, 2607, 2664, 2664, 3576]], "test": "untested"}
{"id": "tttXDl", "name": "nyan-simple", "author": "hanabi", "description": "playing with nyan", "tags": ["nyan"], "likes": 0, "viewed": 266, "published": 3, "date": "1581980532", "time_retrieved": "2024-07-30T21:23:20.932089", "image_code": "vec4 nyan( in vec2 uv, in int index)\n{\n    ivec2 nyan = ivec2(40, 32);\n    ivec2 ruv = ivec2(nyan.x * index, 0) + ivec2(uv * vec2(nyan));\n\treturn texelFetch(iChannel0, ruv, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = nyan(uv, (iFrame / 5) % 6);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 178], [180, 180, 237, 237, 322]], "test": "untested"}
{"id": "tl3XDs", "name": "Day 60", "author": "jeyko", "description": "potaot", "tags": ["mdtmjvm"], "likes": 13, "viewed": 442, "published": 3, "date": "1581977744", "time_retrieved": "2024-07-30T21:23:21.701033", "image_code": "// Fork of \"Day 59\" by jeyko. https://shadertoy.com/view/3ldSWf\n// 2020-02-17 13:02:38\n\n// Fork of \"Day 55\" by jeyko. https://shadertoy.com/view/wl3Szs\n// 2020-02-16 14:20:34\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    #define chromaticAbberationAmt (0.01 + sin(iTime)*0.00)\n    //float f = length(uv  - 0.5);\n    float f = dot(uv  - 0.5,uv  - 0.5);\n    fragColor.x = T(uv + f*chromaticAbberationAmt).x;\n    fragColor.y = T(uv).y;\n    fragColor.z = T(uv -f*chromaticAbberationAmt).z;\n    fragColor += clamp(texture(iChannel0,uv, 6.), 0., 1.)*0.4;\n    fragColor *= 1.9;\n    //fragColor = smoothstep(0.,1., fragColor);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define iTime (iTime + 100.)\n\n#define outline(x, w) (abs(x) - w)\n#define inline(x) -((x)) \n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(a, x) mod(a, x) - x*0.5\n\n//#define KALEIDOMODE\n\n\nfloat rand2D(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n// http://www.science-and-fiction.org/rendering/noise.html\n// dot noise from here\n\nfloat dotNoise2D(in float x, in float y, in float fractionalMaxDotSize, in float dDensity)\n{\n    float integer_x = x - fract(x);\n    float fractional_x = x - integer_x;\n\n    float integer_y = y - fract(y);\n    float fractional_y = y - integer_y;\n\n    if (rand2D(vec2(integer_x+1.0, integer_y +1.0)) > dDensity)\n       {return 0.0;}\n\n    float xoffset = (rand2D(vec2(integer_x, integer_y)) -0.5);\n    float yoffset = (rand2D(vec2(integer_x+1.0, integer_y)) - 0.5);\n    float dotSize = 0.5 * fractionalMaxDotSize * max(0.25,rand2D(vec2(integer_x, integer_y+1.0)));\n\n    vec2 truePos = vec2 (0.5 + xoffset * (1.0 - 2.0 * dotSize) , 0.5 + yoffset * (1.0 -2.0 * dotSize));\n\n    float distance = length(truePos - vec2(fractional_x, fractional_y));\n\n    return 1.0 - smoothstep (0.3 * dotSize, 1.0* dotSize, distance);\n\n}\n\n    \n#define pal(a,b,c,d,e) (a + b*sin(tau*(c*d + e)))\n\nvec4 valueNoise(float i, float tol){\n    vec4 a = texture(iChannel0,vec2(floor(i)*0.02));\n    vec4 b = texture(iChannel0,vec2(floor((i+1.))*0.02));\n    \n    if (a.z > tol)\n        a -= a;\n    if (b.z > tol)\n        b -= b;\n    \n\treturn mix(a,b,pow(fract(i), 20.));\n}\n\n\nvec2 sUv = vec2(0);\n#define mx (iTime*4. + 10.*iMouse.x/iResolution.x)\nvec3 sumonTheDemon( vec2 p, float id )\n{\n    vec3 col = vec3(0);\n\n    #define spacing (0.08 + sin(iTime*0.7)*0.07)\n    #define PLANES 40.\n    #define W 0.0005\n    \n    float rA = texture(iChannel0, vec2(sin(id*0.01)*200.,id )).x;\n    float rB = texture(iChannel0, vec2(sin(id*0.03 + 0.2)*200.,id*1.4 )).x;\n    float rS = sign(rA - 0.5);\n    float rSB = sign(rB - 0.5);\n    float fig = 10e6;\n    vec2 k = p;\n    \n    p.xy *= rot(iTime*rB*rS*0.9);\n    \n    float baseW = 0.05;\n   \n    vec4 nScreen = valueNoise(iTime, 1.);\n    \n    p.x += 0.1*nScreen.z*exp(-(500.+nScreen.y*500.)*abs(sUv.y - nScreen.x + 0.5))*0.2*sin(sUv.y*200. + iTime*50.);\n    \n    #define onion(d, amt) (length(mod(amt*d, 1.) - 0.5 ) - 0.0)\n    \n    #define ysep 2.\n    \n    float idy = floor(2000.*k.y/ysep);\n    vec4 nPolar = valueNoise(iTime*2000.*rS + atan(p.y, p.x)*100.5 + id*2., 0.7);\n    p.x += valueNoise(iTime*20. + idy*20.5 + id, 0.1).x*0.02;\n    p.xy *= 1. + nPolar.x*.06;\n    vec4 nPolarB = valueNoise(iTime*1.*rS + mod(atan(p.y, p.x), 6.14)*10. + id*2., 0.9);\n        \n    float pol = mod(atan(p.y, p.x) + id*0.2, 6.38);\n    pol = 1.;\n    p.xy += normalize(p.xy)*nPolarB.x*pol*0.007;\n    //p.xy += normalize(p.xy)*nPolarB.x*.008;\n    \n    p.xy += 0.005;\n    \n    p *= rot(0.25*pi);\n    if(rA < 0.5){\n    \tp = abs(p);\n    \tp *= rot(0.25*pi);\n    }\n    \n    \n    fig = min(fig, outline( length(p.xy*3.) - 0.2 + sin(id)*0.05, 0.001    ));\n    \n    //fig = onion(fig , (20. + 5.*sin(iTime + id)));\n \n    col += smoothstep(0.02,0.,fig)*vec3(1)*1.;    \n\n    col *= pal(0.,vec3(1.,1.,1.)*(1.5 - nPolar.y),vec3(3.87,4.4,4.1), vec3(2.1,-0.9,5.1), id*0.1 + sin(id*2. + nPolar.x)*0.05);\n    col *= 1. + 2.*pol/6.38;\n    \n    \n    k += id;\n    for(int i = 0; i < 2; i++){\n    \tk = abs(k);\n    \t\n        k.x -= 0.6;\n        k *= rot(2.);\n    }\n    k *= 20.;\n    col += dotNoise2D(k.x, k.y, 0.05, 1.);\n    \n    float stars = 10e5;\n    \n\n    \n    //col += smoothstep(0.005,0.,stars)*vec3(1)*2.;    \n\n    \n    return col;\n}\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 p0, vec3 n){\n    float denom = dot(rd,n);\n    if (denom > 1e-6) {\n        float t = - dot(ro - p0, n)/denom; \n\t\tif (t > 0.) return t;\n        return t;\n    }  \n    return 1e10;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tsUv = uv;\n    //uv *= 1. + dot(uv,uv)*0.7;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    \n    \n    \n    ro.z;\n    vec3 rd = normalize(vec3(uv,1));\n   \n    rd.xz *= rot(sin(iTime)*0.04);\n    rd.xy *= rot(sin(iTime*0.2)*0.5);\n    \n    #define fog(a) smoothstep(1., 0., a*0.8)\n    \n    for(float i = 0.; i < PLANES + float(min(iFrame, 0)); i++ ){\n    \tfloat plA = iPlane(ro, rd, vec3(0,0,mod(-mx + i,PLANES))*spacing, vec3(0,0,1));\n    \tcol += sumonTheDemon( (ro+rd*plA).xy, floor((-mx+i)/PLANES)*PLANES + i)*fog(plA);\n    }\n    \n\t\n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 271, 271, 718]], "test": "untested"}
{"id": "3ltSWs", "name": "approx of min/max", "author": "FabriceNeyret2", "description": "max() = L norm. can be approx by L_big.\n-> many applications:\n- derivable -> ease analytical calculations and many iterative algorithms\n- like sRGB <-> flat color space, allows to replace op by + . Eg, MIPmap: https://shadertoy.com/results?query=minmax", "tags": ["optimization", "min", "smoothmin", "max", "smoothmax"], "likes": 2, "viewed": 429, "published": 3, "date": "1581962228", "time_retrieved": "2024-07-30T21:23:22.461998", "image_code": "#define S(v)  smoothstep(2./R.y,0., v)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R;\n\n    float p = 15., // choose carefully: largest that doesn't cause overflow\n         x1 = U.x, x2 = U.x + iTime/6.,\n#if 0    // better for testing max possible p (artifacts near y=0 ).\n         v0 = .5+.5*cos(6.28*x1),\n         v1 = .5+.5*cos(6.28*x2),\n#else\n         v0 = .5+.3*cos(6.28*x1)     + .2*sin(6.28*x1*2.7),\n         v1 = .5+.2*cos(6.28*x2*1.3) - .3*sin(6.28*x2*3.1),\n#endif\n          m = pow( pow(v0,-p) + pow(v1,-p), -1./p), // approx min\n          M = pow( pow(v0, p) + pow(v1, p),  1./p); // approx Max\n         // quite like to_sRGB( Sum_i{ from_sRGB( C[i] ) } )\n    \n    O = S( U.y- vec4(m,M,0,0) );                    // draw yellow:pseudo-min, green:pseudo-max\n    \n    O = mix( O, vec4(1,0,0,0), S( abs(U.y-v0) ) );  // draw curves\n    O = mix( O, vec4(1,0,0,0), S( abs(U.y-v1) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tdXDl", "name": "Running Stickfigure", "author": "pyBlob", "description": "Plitch ... Platch ...", "tags": ["walk"], "likes": 3, "viewed": 177, "published": 3, "date": "1581961262", "time_retrieved": "2024-07-30T21:23:23.229945", "image_code": "const float pi = radians(180.);\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(-k*a)+exp(-k*b))/k;\n}\nmat3 Tx(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat3(1,0,0, 0,c,-s, 0,s,c);\n}\nmat3 Ty(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat3(c,0,s, 0,1,0, -s,0,c);\n}\nfloat sphere(vec3 x, float r)\n{\n    return length(x) - r;\n}\nfloat square(vec3 x, float r)\n{\n    return length(vec3(max(vec2(0.), abs(x.xz)-r), x.y));\n}\nfloat cube(vec3 x, float r)\n{\n    return length(max(vec3(0.), abs(x)-r));\n}\nfloat capsule(vec3 x, vec3 b, float r)\n{\n    vec3 m = b / 2.;\n    vec3 n = normalize(b);\n    float l = length(b - m);\n    x -= m;\n    return length(vec4(cross(x, n), max(0., abs(dot(x, n))-l))) - r;\n}\nstruct Arm\n{\n    float a, b;\n};\nstruct Body\n{\n    vec3 x;\n    vec4 rippleLeft, rippleRight;\n    Arm legLeft, legRight;\n    Arm armLeft, armRight;\n    float y;\n    float headY;\n};\nfloat arm(vec3 x, Arm joints)\n{\n    float r = 1e8;\n    x -= vec3(0.1,0,0);\n    x = x * Tx(-joints.a);\n    r = min(r, capsule(x, vec3(.20, -.20, 0), .1));\n    x -= vec3(.20, -.20, 0);\n    x = x * Tx(-joints.b);\n    r = min(r, capsule(x, vec3(.05, -.35, 0), .1));\n    x -= vec3(.05, -.35, 0);\n    return r;\n}\nfloat leg(vec3 x, Arm joints)\n{\n    float r = 1e8;\n    x = x * Tx(-joints.a);\n    r = min(r, capsule(x, vec3(.15, -.45, 0), .1));\n    x -= vec3(.15, -.45, 0);\n    x = x * Tx(-joints.b);\n    r = min(r, capsule(x, vec3(.05, -.45, 0), .1));\n    x -= vec3(.05, -.45, 0);\n    r = min(r, sphere(x, .1));\n    return r;\n}\nvec3 mirror(vec3 x)\n{\n\treturn vec3(-x.x, x.yz);\n}\nvoid figure(inout float r, vec3 x, Body joints)\n{\n    x.y -= joints.y;\n    vec3 hip = vec3(0, 1., 0);\n    vec3 neck = vec3(0, 1.45, 0);\n    vec3 head = vec3(0, 1.80 + joints.headY, 0);\n    vec2 arms = vec2(\n    \tarm(mirror(x - neck), joints.armLeft),\n    \tarm(x - neck, joints.armRight)\n    );\n    vec2 legs = vec2(\n        leg(mirror(x - hip), joints.legLeft),\n    \tleg(x - hip, joints.legRight)\n\t);\n    float c = capsule(x - hip, neck-hip, .1);\n    float b = smin(min(arms.x, arms.y), c, 15.);\n    r = min(r, smin(min(legs.x, legs.y), b, 25.));\n    r = min(r, sphere(x-head, .15));\n}\nfloat fade(float p)\n{\n    float c = cos(p * pi);\n    return c*c;\n}\nvoid walkHeight(out float y, float t0)\n{\n    \tfloat t = fract(t0);\n        float f, w = 1e-10;\n        f = fade(t - 0.00); w += f; y += f * +0.2f;\n        f = fade(t - 0.20); w += f; y += f * +0.0f;\n        f = fade(t - 0.40); w += f; y += f * +0.0f;\n        f = fade(t - 0.60); w += f; y += f * +0.0f;\n        f = fade(t - 0.80); w += f; y += f * +0.0f;\n        y /= w;\n}\nvoid walkCycle(out Arm arm, out Arm leg, float phase, float t0)\n{\n    {\n    \tfloat t = fract(t0 + phase);\n        float f, w = 1e-10;\n        f = fade(t - 0.00); w += f; leg.a += f * +1.5f; leg.b += f * -1.7f;\n        f = fade(t - 0.20); w += f; leg.a += f * +0.0f; leg.b += f * -0.0f;\n        f = fade(t - 0.40); w += f; leg.a += f * -1.5f; leg.b += f * +0.5f;\n        f = fade(t - 0.60); w += f; leg.a += f * +0.0f; leg.b += f * -0.9f;\n        f = fade(t - 0.80); w += f; leg.a += f * +0.0f; leg.b += f * -0.0f;\n        leg.a /= w;\n        leg.b /= w;\n    }\n    {\n    \tfloat t = fract(t0 + phase + .5);\n        float f, w = 1e-10;\n        f = fade(t - 0.00); w += f; arm.a += f * +1.0f; arm.b += f * +0.5f;\n        f = fade(t - 0.20); w += f; arm.a += f * -0.0f; arm.b += f * -0.0f;\n        f = fade(t - 0.40); w += f; arm.a += f * -1.0f; arm.b += f * -0.5f;\n        f = fade(t - 0.60); w += f; arm.a += f * +0.0f; arm.b += f * -0.0f;\n        f = fade(t - 0.80); w += f; arm.a += f * +0.0f; arm.b += f * -0.0f;\n        arm.a /= w;\n        arm.b /= w;\n    }\n}\nfloat rounded_square(vec3 x, float r)\n{\n    vec3 y = vec3(x.x, 0, x.z);\n    return length(vec2(x.y, max(0., square(y, r) - .1)));\n}\nfloat tile(vec3 x)\n{\n    float r = 1e8;\n    r = min(r, rounded_square(x, .7));\n    r = min(r, rounded_square(x - vec3(0,-.05,0), .75));\n    return r;\n}\nfloat rippleHeight(vec3 x, vec4 ripple)\n{\n    float l = length(x.xz-ripple.xz);\n    float t = ripple.w;\n    float source = 1. - exp(-pow(l*10.,2.));\n    float front = exp(-pow(l*3.-t*5.,2.));\n    float falloff = 1./(1.+l*l) * (1. - smoothstep(.5, 1., t));\n\treturn .02*sin(l*40.) * source * front * falloff;\n}\nfloat scene(vec3 x, Body joints)\n{\n    float r = 1e8;\n    float scale = 1.;\n    vec3 gx = vec3(x - -joints.x);\n    gx.z = mod(gx.z, 2.2);\n    for (float i=-1. ; i<=1. ; i+=1.)\n    {\n        float ripple = 0.;\n        ripple += rippleHeight(x, joints.rippleLeft);\n    \tripple += rippleHeight(x, joints.rippleRight);\n    \tr = min(r, tile(gx - vec3(0,ripple,2.2*i)));\n    }\n    figure(r, x, joints);\n    return r / scale;\n}\n#define saw(x) abs(fract((x)/2.)*2.-1.)\n#define R iResolution\nvec4 zview(float z)\n{\n\tz = log(z) * 10.;\n    return vec4(saw(z*4.), saw(z*2.), saw(z*1.), 1.);\n}\nvec3 getNormal(vec3 p, Body joints){\n\tvec2 t = vec2(0.0002, 0);\n\treturn normalize(\n    \tscene(p, joints) - vec3(\n        \tscene(p - t.xyy, joints),\n        \tscene(p - t.yxy, joints),\n        \tscene(p - t.yyx, joints)\n        )\n    );\n}\nvec4 crotate(vec4 c, float t)\n{\n    vec4 c2 = c;\n    c2.xyz *= Ty(t);\n    return mix(c, c2, .5);\n}\nvoid mainImage( out vec4 C, in vec2 o )\n{\n    vec2 uv = (o-R.xy/2.)/R.y;\n    float t = iTime * .1;\n    t = -2.0;\n    vec3 dx = normalize(vec3(uv,-1)) * Tx(-.35) * Ty(t);\n    vec3 x = vec3(-2,3,5) * Ty(t);\n    float z = 0.;\n    Body joints;\n    int i=0;\n    {\n        float t = iTime;\n        float v = 2.2;\n        joints.x = vec3(0, 0, -.3-v * t);\n        {\n            float rt = t + .0;\n            joints.rippleLeft = vec4(-0.20, 0, -.3 + v * fract(rt), rt-floor(rt));\n        }\n        {\n            float rt = t + .5;\n            joints.rippleRight = vec4(0.20, 0, -.3 + v * fract(rt), rt-floor(rt));\n        }\n        walkHeight(joints.y, t * 2.);\n        walkCycle(joints.armLeft, joints.legLeft, .0f, t);\n        walkCycle(joints.armRight, joints.legRight, .5f, t);\n        float y1;\n        walkHeight(y1, t * 2. - .1);\n        joints.headY = (y1 - joints.y) * .5;\n    }\n    bool found = true;\n    for ( ; i<100 ; ++i)\n    {\n        float r = scene(x+dx*z, joints);\n        if (z > 100.)\n        {\n            found = false;\n            break;\n        }\n        if (r<z*1e-3 || z > 100.)\n            break;\n        z += r * .5;\n    }\n    C = pow(texture(iChannel0, (dx * Ty(-.5)).xy).zyxw, vec4(1.5))*.3;\n    if (found)\n    {\n        vec3 p = x+dx*z;\n        vec3 normal = getNormal(p, joints);\n        //C = vec4(.5+.5*normal, 1.);\n        vec4 M = vec4(1);\n        if (p.y <= .1)\n        {\n            vec3 pg = p + joints.x;\n            M = crotate(texture(iChannel1, pg.xz), dot(pg.xz, vec2(.5, -.3)));\n        }\n        if (p.y <= -.025)\n            M = vec4(1,1,1, .2);\n        M.xyz *= vec3(.05 + .9 * max(0.,normal.y));\n        M.xyz *= exp(-.2*(z-6.));\n        C = mix(C, M, M.w);\n    }\n    C = sqrt(C);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 71, 71, 113], [114, 114, 132, 132, 203], [204, 204, 222, 222, 293], [294, 294, 325, 325, 353], [354, 354, 385, 385, 445], [446, 446, 475, 475, 521], [522, 522, 562, 562, 722], [902, 902, 933, 933, 1208], [1209, 1209, 1240, 1240, 1522], [1523, 1523, 1544, 1544, 1572], [1573, 1573, 1622, 1622, 2158], [2159, 2159, 2180, 2180, 2225], [2226, 2226, 2266, 2266, 2598], [2599, 2599, 2664, 2664, 3659], [3660, 3660, 3699, 3699, 3791], [3792, 3792, 3812, 3812, 3943], [3944, 3944, 3985, 3985, 4252], [4253, 4253, 4287, 4287, 4673], [4736, 4736, 4757, 4757, 4832], [4833, 4833, 4869, 4869, 5068], [5069, 5069, 5100, 5100, 5167], [5168, 5168, 5209, 5209, 6892]], "test": "untested"}
{"id": "3ldXDl", "name": "smallest Nyan Cat (107 chars)", "author": "FabriceNeyret2", "description": "could it be less ? ;-)", "tags": ["nyancat", "onetweet", "golf"], "likes": 3, "viewed": 362, "published": 3, "date": "1581960331", "time_retrieved": "2024-07-30T21:23:24.053743", "image_code": "void mainImage(out vec4 O, vec2 u) {\n    vec2 U = u / max( iResolution.yy , u )\n             + vec2( int(15.*iTime) % 6 );\n    U.x /= 6.4;\n    O = texture( iChannel0, U );\n} /*\n        \n\n\n\n\n\n// --- 115 chars\n        \n#define mainImage(O,u)                                \\\n    vec2 U = min( u/iResolution.y , u/u );            \\\n    U.x = ( U.x+ floor( mod( 15.*iTime, 6.) )) / 6.4; \\\n    O = texture( iChannel0, U )                      /*\n\n/**/", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 173]], "test": "untested"}
{"id": "tl3XWn", "name": "Learning aboat Raymarch", "author": "firegump", "description": "just learning, left click to rotate the camera.1", "tags": ["raymarch"], "likes": 10, "viewed": 1468, "published": 3, "date": "1581949213", "time_retrieved": "2024-07-30T21:23:25.039108", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n  \tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    return length(p - c) - r;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n  \tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t- .5) - .5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x,y), 0.);\n        \n    return e + i ;\n}\nfloat sdTorus(vec3 p, vec2 r){\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\nfloat sdBox(vec3 p, vec3 s){\n    p = abs(p)-s;\n    float  i = min(max(p.x, max(p.y, p.z)), 0.);\n    float  e = length(max(p, 0.));\n\treturn e + i ;\n    \n}\n\nfloat GetDist(vec3 p){ //p is the sample point\n    float t = iTime;\n    float t1 = t* 0.9;\n    float t2 = t* 0.08;\n    float y = -fract(t1)*(fract(t1)-1.);\n    y *= 3.;\n    float planeDist = p.y;\n    \n    for(int i = 1; i < 9;i++){\n        float j = float(i)*8.;\n        float c= fract(sin( float(i) * 100.) * 5377.)* 6.283;\n        \n        float m = -fract(t2 *float(i)+c)*(fract(t2*float(i)+c)-1.);\n        m *= 1.;\n    \tvec4 sr = vec4(-15.+ float(i)*3. + sin(t2+float(i)),-.3 + m*15. , 0.+cos(t2*float(i))*2., .8 );\n        sr.w *= sin(m)*3.;\n        sr.xyz += sin(m);\n     \n        float sdr = length(p - sr.xyz) - sr.w;\n        \n        vec4 sc = vec4( 0.+cos(t2*float(i))*2.,-.3 + m*15. + cos(t1+float(i))*3.,-15.+ float(i)*3. + sin(t2+float(i)), .8);\n        sc.w *= sin(m)*3.;\n        sc.xyz += sin(m);\n        float sdc = length(p - sc.xyz) - sc.w;\n        \n        \n        float sdf = smin(sdr, sdc , .7);\n        \n        for(int e; e<5; e++){\n            \n            float Rr = float(e)*3.;\n            \n            vec4 sq = vec4(sin(j+Rr)*Rr,-.3+m*15.*((c/6.283)*.3+.7),cos(j)*Rr,.7*m);//around sphere\n            sq.xyz += m*1.;\n            sq.w += m*.1 + (c/6.283)*.1;\n            float sdq = length(p - sq.xyz) - sq.w;\n\n            sdf = smin(sdf, sdq, .7);\n        }\n        \n        \n        planeDist = smin(planeDist, sdf, 0.5);\n        \n    }\n    \n    vec4 sA = vec4(0, 1.2 + y,0,1);\n    float sdA = length(p - sA.xyz) - sA.w;\n   \n    vec4 sB = vec4(0., -.4 + y , 0, 1.1);\n    float sdB = length(p - sB.xyz) - sB.w;\n    \n    \n    float sd = sdB;\n    \n    float td = sdTorus(p - vec3(0, 2.2 + y*2., 0), vec2(0.7+ y*.3, 0.27));\n    sd = smin(sd,td,0.5);\n    \n    float Cad = sdCapsule(p, vec3(0,1. + y *2.,0), vec3(0, 0,0), 0.7);\n    sd = smin(sd, Cad,0.5);\n    \n    \n    float tda = sdTorus(p - vec3(0,fract(-t1)*2., 0), vec2(0.5*(abs(sin(t*2.))), 0.27));//absorb\n    sd = smin(sd, tda, 0.5);\n    \n    vec3 bp = p - vec3(0, 1 , 0);\n    bp.xz *= Rot(iTime);\n    \n    float BoxDist = sdBox(bp, vec3(.7));\n    \n    float CylDist = sdCylinder(p, vec3(2, 0.3,2), vec3(6, 0.3,5), 0.3);\n    \n    sd = smin(BoxDist, sd, 0.7);\n    float d= smin(sd, planeDist, 0.7); \n    \n    //float planeDist1 = 9.- p.y;//ceil\n    \n   \t//d = smin(d, planeDist1, .7);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i = 0 ; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(GetDist(p - e.xyy),//same to vec3(d- d1, d- d2, d- d3);\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    \n   \n    return normalize(n);\n}\n\n\nvec3 GetLight(vec3 p,vec3 rd,vec3 lightPos, vec3 lightCol){\n\tvec3 v = -rd;\n    ;\n    \n    //attenuation\n    float atten = 1. - length(lightPos - p)/21.;//float is light Area\n    \n    float MoveRadius = 0.;\n    float MoveSpeed = 0.;\n    \n    float t = iTime * MoveSpeed;\n    lightPos.xz += vec2(sin(t), cos(t)) * MoveRadius;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    vec3 ref = reflect(n,rd);\n    //ambient\n    float amb = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n    //diffuse\n    float NdotL = dot(n, l);\n    NdotL = NdotL*.5 + .5;\n    float dif = clamp(NdotL, 0. , 1.);\n    //specular\n    vec3 h = normalize(l + v);\n    float spe = pow(max(dot(n,h),0.), 128.);\n    //fresnel\n    //float fs = .4; //fresnel scale\n    \n    \n    \n    \n    \n    float fre =  clamp(  1.+ dot(rd,n)       ,0.,1.);\n    fre = pow(fre, 1.4);\n    //dom\n    float dom = smoothstep( -0.2, 0.2, ref.y );\n    \n    \n    vec3 finCol = vec3(0.); \n    finCol += amb * vec3(1,1,0) * .5;\n    finCol += dif * vec3(1,1,1) * .5;\n    finCol += spe * vec3(1,1,1) * 2.;\n    finCol += fre * vec3(.3,0,1) * 2.;\n   \tfinCol += dom * vec3(0,1,1) * 0.3;\n    \n    \n    finCol *= atten*lightCol;\n    finCol *= 1.;\n    //finCol = vec3(dom);\n    //shadow\n    float d = RayMarch(p + n * SURF_DIST *2. , l);// 2. is fixed the center of the sphere sample\n    if(p.y< 0.01 && d < length(lightPos - p))\n    {\n        finCol *= 0.3;\n    }\n    return finCol;\n    \n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m -= 0.5;\n    //m.y *= .2;\n    vec3 col = vec3(0);\n    \n    //camera position\n    vec3 ro = vec3(0,5,-20.);\n    //ro.yz *= Rot(-m.y+.4);\n    //ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    ro.yz *= Rot(-m.y + 0.4);\n    ro.xz *= Rot(-m.x*6.2831+ iTime );\n     \n    vec3 rd = R(uv, ro, vec3(0,1.,0), 2.);\n    \n    \n    \n\tfloat d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec3 lightPos = vec3(-2, 9., -4);\n    vec3 lightCol = vec3(1, 1 ,1);\n    col = GetLight(p,rd,lightPos, lightCol);\n    \n    \n    //col = vec3(dif);\n    \n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 108, 108, 199], [200, 200, 219, 219, 295], [296, 296, 338, 338, 533], [534, 534, 583, 583, 756], [757, 757, 807, 807, 1134], [1135, 1135, 1165, 1165, 1237], [1238, 1238, 1266, 1266, 1391], [1393, 1393, 1415, 1439, 3685], [3687, 3687, 3721, 3721, 3940], [3942, 3942, 3965, 3965, 4215], [4218, 4218, 4277, 4277, 5659], [5660, 5660, 5717, 5717, 6410]], "test": "untested"}
{"id": "3ttSWl", "name": "Raymarching basic test", "author": "xfennec", "description": "Simple Raymarching test", "tags": ["raymarchingtest"], "likes": 3, "viewed": 296, "published": 3, "date": "1581946032", "time_retrieved": "2024-07-30T21:23:25.887839", "image_code": "// based on Rmi Papilli's WebGL conference\n// https://www.youtube.com/watch?v=s6t0mJsgUKw\n\n// NOTE :\n// smooth-min (blending SDF)\n// https://iquilezles.org/articles/smin\n\n\nvec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n\n\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n}\n\n\nfloat opU(float d1, float d2)\n{\n\treturn min(d1,d2);\n}\n\nfloat map(vec3 pos) {\n    float dPlane = sdPlane(pos);\n\n    float dSphere = sdSphere(  pos + vec3( 3.0, -3.0,  0.0), 2.0);\n\n    vec3 posBox = pos + vec3(-3.0, -3.0,  0.0);\n    posBox.xy = rotate(posBox.xy, iTime);\n    posBox.xz = rotate(posBox.xz, iTime * 0.5);\n    float dBox = sdRoundBox(posBox, vec3(1.5, 1.5, 1.5), 0.3);\n    \n    float res = dPlane;\n    res = opU(res, dSphere);\n    res = opU(res, dBox);\n\treturn res;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal) {\n\t//return max(dot(normal, lightDir), 0.0);\n\treturn dot(normal, lightDir) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // map uv from 0..1 to -1..1 (x will be scaled using viewport ratio)\n    uv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    \n \tvec3 pos = vec3(\n        sin(iTime),\n        3.5 + cos(iTime * 0.4),\n        -10.0\n    );\n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0 ; i < 256 ; ++i) {\n        float d = map(pos);\n        if (d < 0.01) {\n            //color = fract(pos * 0.5);\n            color = 0.5+pos*0.1;\n            break;\n        }\n        if (pos.z > 100.0) {\n            break;\n        }\n        pos += d * dir;\n    }\n\n    \n    vec3 finalColor = color * diffuse(computeNormal(pos));\n        \n    // Output to screen\n    //fragColor = vec4(color, 1.0);\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "// distance functions, inigo quilez\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n  return length(pos)-radius;\n}\n\nfloat sdRoundBox(vec3 pos, vec3 size, float radius)\n{\n  vec3 q = abs(pos) - (size - vec3(radius));\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n// NOT USED (YET?)\n// https://www.shadertoy.com/view/Wtl3zN \n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(\n    \toc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0,\n        0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 264, 264, 351], [354, 354, 385, 385, 407], [409, 409, 430, 430, 832], [834, 834, 864, 864, 1079], [1081, 1081, 1109, 1152, 1197], [1199, 1199, 1256, 1306, 2116]], "test": "untested"}
{"id": "tttXWf", "name": "Moai Statue", "author": "Del", "description": "a very poor Moai head", "tags": ["raymarch", "sdf", "island", "poor", "moai", "easter"], "likes": 7, "viewed": 384, "published": 3, "date": "1581915974", "time_retrieved": "2024-07-30T21:23:27.005850", "image_code": "// A very badly modelled Moai statue :) - Del 16/02/2020\n\n#define AA 2\n#define PI\t\t3.1415926\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat mouth (in vec3 p)\n{\n    vec3 mouthpos = p-vec3(0.0,-0.4,0.10);\t\n    float body = length (mouthpos);\n    float size = 0.15;\n\tbody = max (body - size,  -body);\n\tfloat Angle = PI * ( 0.1 * abs(sin (iTime*3.0)));\n\tfloat mouthT = dot (mouthpos, vec3 (0.0, -cos (Angle), sin (Angle)));\n\tAngle *= 2.4;\n\tfloat mouthB = dot (mouthpos, vec3 (0.0, cos (Angle), sin (Angle)));\n    return max (body, min (mouthT, mouthB));\n}\nfloat ear (in vec3 p)\n{\n    p.y += 0.15;\n    p.z -= 0.02;\n    float d1 =  sdCone(p, vec3(0.22,-0.2,0.0), vec3(0.19,0.2,0.0), 0.02,0.01 );\n    float d2 =  sdCone(p, vec3(-0.22,-0.2,0.0), vec3(-0.19,0.2,0.0), 0.02,0.01 );\n    return min(d1,d2);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nfloat map( in vec3 pos )\n{\n    \n\t//pos.xz *= rotate(sin(iTime+pos.y));\n    pos.x = mod(pos.x,0.6)-0.3;\n    \n    pos.y -= 0.2;\n    float d1 =  sdCone(pos, vec3(0.0,-0.5,0.0), vec3(0.0,0.2,0.0), 0.225, 0.16 );\n    float d7 = mouth(pos);\n    d1 = smin(d1,d7,0.15);\n    float d3 = sdBox(pos+vec3(0.0,0.15,-0.4),vec3(0.2,0.15,0.3));\n    d1 = opSmoothSubtraction(d3,d1,0.025);\t\t// box cutout\n    vec3 q = pos+vec3(0.0,0.0,-0.08);\t//-vec3(0.0,0.0,-0.1);\n    float d2 =  sdCone(q, vec3(0.0,0.0,0.04), vec3(0.0,-0.3,0.105), 0.1*0.4, 0.1*0.9 );\n    d1 = smin(d1,d2,0.045);\n\tfloat d4 = sdBox(pos+vec3(0.0,0.1,0.15),vec3(0.2,0.5,0.1));\n    d1 = opSmoothSubtraction(d4,d1,0.09);\t\t// box cutout\n    \n    float ep = ear(pos);\n    d1 = smin(ep,d1,0.05);\n    \n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n//    vec\n     // camera movement\t\n    float an = sin(iTime)*0.8;\n    an+=3.14*0.5;\n    float y = 0.0;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*2.0;\n        y-=1.0;\n    }\n    \n\tvec3 ro = vec3( 1.0*cos(an), y, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 0.0;\n        for( int i=0; i<80;i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.6,0.4,0.4*abs(sin(uv.x*0.1+iTime)))*1.0-abs(uv.y*0.5);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            vec3 ambcol = vec3(0.4,0.3,0.3)*amb;\n            col = ambcol + vec3(0.6,0.55,0.85)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 146, 146, 245], [247, 247, 305, 305, 405], [406, 406, 449, 449, 471], [473, 473, 531, 531, 1091], [1092, 1092, 1133, 1133, 1217], [1218, 1218, 1249, 1249, 1336], [1337, 1337, 1362, 1362, 1754], [1755, 1755, 1778, 1778, 1999], [2001, 2001, 2023, 2023, 2090], [2091, 2091, 2117, 2161, 2850], [2852, 2852, 2884, 2884, 3123]], "test": "untested"}
{"id": "wldSDX", "name": "polar tunnel", "author": "isk", "description": "class tunnel effect using polar coordinate texture mapping.\nlook around with the mouse.", "tags": ["tunnel", "classic"], "likes": 1, "viewed": 255, "published": 3, "date": "1581885080", "time_retrieved": "2024-07-30T21:23:27.960297", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=((fragCoord+iMouse.xy)-iResolution.xy)/iResolution.y;\n    float r=length(uv);\n    float t=atan(uv.y,uv.x);\n    uv=vec2(t,1./r+iTime);\n    vec3 col=texture(iChannel0,uv).rgb*r;\n    fragColor=vec4(col,1.);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 272]], "test": "untested"}
{"id": "ttdXWX", "name": "Square / circle tutorial", "author": "xfennec", "description": "Basic shapes tutorial", "tags": ["test"], "likes": 1, "viewed": 283, "published": 3, "date": "1581883326", "time_retrieved": "2024-07-30T21:23:28.726250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // map uv from 0..1 to -1..1 (x will be scaled using viewport ratio)\n    uv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n \t\n    // naive square\n    float inside1 = 0.0;    \n    if (uv.x > -0.25 && uv.x < 0.25 &&\n        uv.y > -0.25 && uv.y < 0.25) {\n        inside1 = 1.0;\n    }\n    \n    // smarter square\n    // step(edge, value)\n    // we reverse step() usage: edge is dynamic and value is the square size\n    vec2 square = step(abs(uv), vec2(0.25));\n    float inside2 = square.x * square.y; // \"and\"\n\n    \n\t// circle (we reverse step() here too, to make things a bit simplier)\n    float inside3 = step(distance(uv, vec2(0)), 0.25);\n    \n    // Output to screen\n    fragColor = vec4(inside3, 0.0, 0.0 ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 877]], "test": "untested"}
{"id": "3ldSWf", "name": "Day 59", "author": "jeyko", "description": "potaot", "tags": ["mdtmjvm"], "likes": 37, "viewed": 1142, "published": 3, "date": "1581879266", "time_retrieved": "2024-07-30T21:23:29.602906", "image_code": "// Fork of \"Day 55\" by jeyko. https://shadertoy.com/view/wl3Szs\n// 2020-02-16 14:20:34\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    #define chromaticAbberationAmt (0.00 + sin(iTime)*0.005)\n    //float f = length(uv  - 0.5);\n    float f = dot(uv  - 0.5,uv  - 0.5);\n    fragColor.x = T(uv + f*chromaticAbberationAmt).x;\n    fragColor.y = T(uv).y;\n    fragColor.z = T(uv -f*chromaticAbberationAmt).z;\n    fragColor += clamp(texture(iChannel0,uv, 6.), 0., 1.)*0.4;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// sdfs from inigo quilez\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdEquilateralTriangle( in vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n#define iTime (iTime + 100.)\n\n#define outline(x, w) (abs(x) - w)\n#define inline(x) -((x)) \n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(a, x) mod(a, x) - x*0.5\n\n//#define KALEIDOMODE\n\n\nfloat rand2D(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n// http://www.science-and-fiction.org/rendering/noise.html\n// dot noise from here\n\nfloat dotNoise2D(in float x, in float y, in float fractionalMaxDotSize, in float dDensity)\n{\n    float integer_x = x - fract(x);\n    float fractional_x = x - integer_x;\n\n    float integer_y = y - fract(y);\n    float fractional_y = y - integer_y;\n\n    if (rand2D(vec2(integer_x+1.0, integer_y +1.0)) > dDensity)\n       {return 0.0;}\n\n    float xoffset = (rand2D(vec2(integer_x, integer_y)) -0.5);\n    float yoffset = (rand2D(vec2(integer_x+1.0, integer_y)) - 0.5);\n    float dotSize = 0.5 * fractionalMaxDotSize * max(0.25,rand2D(vec2(integer_x, integer_y+1.0)));\n\n    vec2 truePos = vec2 (0.5 + xoffset * (1.0 - 2.0 * dotSize) , 0.5 + yoffset * (1.0 -2.0 * dotSize));\n\n    float distance = length(truePos - vec2(fractional_x, fractional_y));\n\n    return 1.0 - smoothstep (0.3 * dotSize, 1.0* dotSize, distance);\n\n}\n\n    \n#define pal(a,b,c,d,e) (a + b*sin(tau*(c*d + e)))\n\nvec4 valueNoise(float i, float tol){\n    vec4 a = texture(iChannel0,vec2(floor(i)*0.01));\n    vec4 b = texture(iChannel0,vec2(floor((i+1.))*0.01));\n    \n    if (a.z > tol)\n        a -= a;\n    if (b.z > tol)\n        b -= b;\n    \n\treturn mix(a,b,pow(fract(i), 20.));\n}\n\n\nvec2 sUv = vec2(0);\n#define mx (iTime*1. + 10.*iMouse.x/iResolution.x)\nvec3 sumonTheDemon( vec2 p, float id )\n{\n    vec3 col = vec3(0);\n\n    #define spacing (0.04 + sin(iTime*0.7)*0.02)\n    #define PLANES 40.\n    #define W 0.0003\n    \n    float rA = texture(iChannel0, vec2(sin(id*0.01)*200.,id )).x;\n    float rB = texture(iChannel0, vec2(sin(id*0.03 + 0.2)*200.,id*1.4 )).x;\n    float rS = sign(rA - 0.5);\n    float rSB = sign(rB - 0.5);\n    float fig = 10e6;\n    vec2 k = p;\n    //p.xy *= rot(iTime*rB*rS*0.2);\n    \n    float baseW = 0.05;\n   \n    vec4 nScreen = valueNoise(iTime, 1.);\n    \n    p.x += 0.1*nScreen.z*exp(-(500.+nScreen.y*500.)*abs(sUv.y - nScreen.x + 0.5))*0.2*sin(sUv.y*200. + iTime*50.);\n    \n    #ifdef KALEIDOMODE\n    for(int i = 0; i < 7; i++){\n\t\tp = abs(p);\n        p *= rot(0.1 + sin(id*0.1)*0.2);\n        p -= 0.05 + sin(iTime*0.1 + id*0.1)*0.0;\n    //    p.x -= 0.008;\n    }\n    #endif\n    \n    #define onion(d, amt) (length(mod(amt*d, 1.) - 0.5 ) - 0.0)\n    \n    #define ysep 10.\n    float idy = floor(2000.*k.y/ysep);\n    p.x += valueNoise(iTime*4. + idy*20.5 + id, 0.1).x*0.04;\n    p = abs(p);\n    p *= rot(0.25*pi);\n    if(rA < 0.5){\n    \tp = abs(p);\n    \tp *= rot(0.25*pi);\n    \n    }\n    p = abs(p);\n    \n    \n    fig = min(fig, outline( length(p.y*1.) - 0.4, 0.4    ));\n    fig = mix(fig, outline( length(p.y*1.) - 0.4, 0.4    ), 3.);\n    \n    fig = onion(fig , (20. + 5.*sin(iTime + id)));\n    \n    \n    \n    col += smoothstep(0.01,0.,fig)*vec3(1)*1.;    \n\n    col *= pal(1.4,vec3(1.,1.,1.)*0.7,vec3(.87,4.4,1.8), vec3(3.7,2.5,1.1), id*0.1);\n    \n    \n    k += id;\n    for(int i = 0; i < 2; i++){\n    \tk = abs(k);\n    \t\n        k.x -= 0.6;\n        k *= rot(2.);\n    }\n    k *= 20.;\n    col += dotNoise2D(k.x, k.y, 0.05, 1.);\n    \n    float stars = 10e5;\n    \n\n    \n    //col += smoothstep(0.005,0.,stars)*vec3(1)*2.;    \n\n    \n    return col;\n}\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 p0, vec3 n){\n    float denom = dot(rd,n);\n    if (denom > 1e-6) {\n        float t = - dot(ro - p0, n)/denom; \n\t\tif (t > 0.) return t;\n        return t;\n    }  \n    return 1e10;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tsUv = uv;\n    uv *= 1. + dot(uv,uv)*0.2;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    \n    ro.z;\n    vec3 rd = normalize(vec3(uv,1));\n   \n    #define fog(a) smoothstep(1., 0., a*1.4)\n    \n    for(float i = 0.; i < PLANES + float(min(iFrame, 0)); i++ ){\n    \tfloat plA = iPlane(ro, rd, vec3(0,0,mod(-mx + i,PLANES))*spacing, vec3(0,0,1));\n    \tcol += sumonTheDemon( (ro+rd*plA).xy, floor((-mx+i)/PLANES)*PLANES + i)*fog(plA);\n    }\n    \n\t\n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 183, 183, 561]], "test": "untested"}
{"id": "wttSWX", "name": "Length(gv)-rad and atan Static", "author": "soundmasteraj", "description": "Martijn mentioned iq's sdf, got intertwined with a color calculation; pretty accident, more of a standing wave", "tags": ["radial", "distance", "distance", "tangential"], "likes": 4, "viewed": 373, "published": 3, "date": "1581878211", "time_retrieved": "2024-07-30T21:23:30.371850", "image_code": "// Fork of \"Length(gv)-rad and atan gv\" by soundmasteraj. https://shadertoy.com/view/WtdXDf\n// 2020-02-16 18:36:05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y+.5;\n\tvec2 gv = vec2(uv.x * 5., -.25 + uv.y * 5.);\n    float rad = .25 +.01 -cos(iTime)*.25+.25;\n    float dist = length(gv*rad)-rad;\n\n    vec3 col =atan(gv.x*uv.x*.5, gv.y*rad) + .618 *cos(iTime+dist+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 173, 223, 553]], "test": "untested"}
{"id": "WtdXDf", "name": "Length(gv)-rad and atan gv", "author": "soundmasteraj", "description": "Martijn mentioned iq's sdf, got intertwined with a color calculation; pretty accident", "tags": ["radialdistancetangentialdistance"], "likes": 3, "viewed": 397, "published": 3, "date": "1581877110", "time_retrieved": "2024-07-30T21:23:31.274437", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5/**sin(iTime*.5)*-.5+.5*/)/iResolution.y+.5;\n\tvec2 gv = vec2(uv.x * 5., -.25+uv.y * 5.);\n    float rad = .25;\n    float dist = length(gv)-rad;\n    // Time varying pixel color\n    vec3 col =atan(gv.x*uv.x*.5, gv.y) + .618 *cos(iTime+dist+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col),10);//pow(col, col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ldXWf", "name": "Beat detection test", "author": "xfennec", "description": "Basic test for beat detection using a few FFT samples (using lower frequencies).", "tags": ["beatbass"], "likes": 3, "viewed": 320, "published": 3, "date": "1581875094", "time_retrieved": "2024-07-30T21:23:32.250826", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data\n\tfloat fft = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\n\n\t// crude beat detection\n    float bass = 0.0;\n    int samples = 5;\n    for(int i = 0 ; i < samples ; ++i) {\n        bass += texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n    }\n    bass /= float(samples);\n    float beat = smoothstep(0.8, 1.0, bass);\n    \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\n    float waveR = 1.0 - smoothstep(0.0, 0.01, abs(wave - uv.y));\n    float waveG = 1.0 - smoothstep(0.0, 0.04, abs(wave - uv.y));\n    float waveB = 1.0 - smoothstep(0.0, 0.5, abs(wave - uv.y));\n\n\tvec3 waveRGB = vec3(waveR, waveG * 0.5, waveB * 0.4);\n\n    // output final color\n    fragColor = vec4(waveRGB + beat * waveRGB + beat * vec3(1.0, 0.0, 0.1), 1.0);\n\t//fragColor = vec4(vec3(beat), 1.0);\n    //fragColor = vec4(vec3(waveRGB), 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 1111]], "test": "untested"}
{"id": "WttSDf", "name": "auto-correlation in texture", "author": "FabriceNeyret2", "description": "compute the correlation between the image and the region around the mouse.\nred: positive correlation blue : anti-correlation\n\nstrange: N=32 faster than 31 and 33 !", "tags": ["statistics", "autocorrelation"], "likes": 6, "viewed": 420, "published": 3, "date": "1581872090", "time_retrieved": "2024-07-30T21:23:33.025754", "image_code": "#define N 32   // correlation window size\n\n//#define T(U)   texelFetch(iChannel0, ivec2(U*1.), 0).x           // pixel precision\n//#define T(U)   texture(iChannel0, (U)/R ).x                      // fit to screen\n  #define T(U)   smoothstep(0.,1., texture(iChannel0, (U)/R ).x )  // amplify contrasts\n//#define T(U) ( texture(iChannel0, (U)/R ) - texture(iChannel0, (U+1.)/R ) ).x // analyse Sobel\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    vec2 M = iMouse.xy, P,\n         R = iResolution.xy; \n    if (length(M)<15.) M = floor( R*(.5 + .3*cos(iTime+vec2(0,11))) );\n    \n    float m0=0., m1=0., m01=0., m00=0., m11=0., c, v0, v1, v01, n2=float(N*N);\n    for (int k=0; k < N*N; k++) {               // compute all moments around M,U and cross\n        P = vec2(k%N,k/N) - float(N+1)/2.;\n        v0   = T(M+P);                          // texture around mouse\n        v1   = T(U+P);                          // texture around pixel\n        m0  += v0;                              // E(X0)\n        m1  += v1;                              // E(X1)\n        m01 += v0*v1;                           // E(X0.X1)\n        m00 += v0*v0;                           // E(X0)\n        m11 += v1*v1;                           // E(X1)\n    }\n    m0/=n2; m1/=n2; m01/=n2; m00/=n2; m11/=n2;  // moments of order 1 & 2\n    v0  = m00 - m0*m0;                          // variance X0\n    v1  = m11 - m1*m1;                          // variance X1\n    v01 = m01 - m0*m1;                          // covariance\n    c   = v01 / sqrt(v0*v1);                    // correlation\n    \n    O = vec4( c , .3*T(U), -c, 1 ) \n        + pow(max(0.,c),8.); // emphase maximum. variant: abs(c)\n    \n    U = abs(U-M) - floor(float(N)/2.*R.y/iChannelResolution[0].y);  // draw stat window around mouse\n    if (U.x*U.y==0. && ( U.x<0. || U.y<0.) ) O +=.3;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 437, 437, 1831]], "test": "untested"}
{"id": "WtdXDX", "name": "Best Integer Hash - test pairs", "author": "FabriceNeyret2", "description": "quality test :  distrib of points ( hash(t) , hash(t+1) )\nhash from from Chris Wellons [url]https://nullprogram.com/blog/2018/07/31/[/url] \n\nvariants: see comments and #if", "tags": ["hash"], "likes": 3, "viewed": 461, "published": 3, "date": "1581864508", "time_retrieved": "2024-07-30T21:23:33.786719", "image_code": "// Fork of https://shadertoy.com/view/WttXWX\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0, ivec2(U), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of https://shadertoy.com/view/WttXWX\n// --- from Chris Wellons https://nullprogram.com/blog/2018/07/31/\n// Note that it might not be costlier than the infamous fract(big*sin(big*x)) ;-) \n\n        // --- choose one:\n//#define hashi(x)   lowbias32(x)\n  #define hashi(x)   triple32(x) \n\n  #define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n#define N 130\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0, ivec2(U), 0); // * .996;\n    int t = iFrame*N;\n    \n    for (int i=0; i < N; i++) {\n        ivec2 P = ivec2( hashi(uint(i+t)),hashi(uint(i+1+t)) ) % ivec2(iResolution);\n#if 0\n        O += .3* max(0., 1.-.3*length(vec2(P)-U) ); // better with * .996 above\n#else\n        if (P  == ivec2(U) )\n            O++;\n        //  O = 1.-O;\n#endif\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 84, 84, 130]], "test": "untested"}
{"id": "3tdXWX", "name": "", "author": "alighazi", "description": "just another ", "tags": ["vegetables"], "likes": 0, "viewed": 294, "published": 3, "date": "1581857230", "time_retrieved": "2024-07-30T21:23:34.545690", "image_code": "vec2 rot(float d){\n    return vec2(9.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y: -0.5 -> 0.5 | x: -1 -> 1;)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\t\t\n    float d = length(uv);\n    \n    vec3 col = vec3(0.01/d);\n    col += max(0., 1.-abs(uv.y*uv.x*1000.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 41], [42, 42, 99, 166, 398]], "test": "untested"}
{"id": "WttXWX", "name": "\"Best\" Integer Hash", "author": "FabriceNeyret2", "description": "from Chris Wellons [url]https://nullprogram.com/blog/2018/07/31/[/url] \n( thanks for this ref that was raised... I don't remember in which discussion ! :-) )\n\nNote that it might not be costlier than the infamous fract(big*sin(big*x)) ;-) ", "tags": ["hash"], "likes": 58, "viewed": 8891, "published": 3, "date": "1581856091", "time_retrieved": "2024-07-30T21:23:35.305660", "image_code": "// --- from Chris Wellons https://nullprogram.com/blog/2018/07/31/\n// Note that it might not be costlier than the infamous fract(big*sin(big*x)) ;-) \n\n        // --- choose one:\n//#define hashi(x)   lowbias32(x)\n  #define hashi(x)   triple32(x) \n\n  #define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    uvec2 V = uvec2(U);\n    float h = hash( V.x + hashi(V.y) ); // clean 2D hash\n  //float h = hash( V.x + (V.y<<16) );  // 2D hash (should be ok too )\n    O = vec4( h );\n  //O = vec4( pow( h, 1./2.2) );        // sRGB conversion\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 379, 403, 403, 517], [519, 575, 598, 598, 752], [754, 754, 792, 792, 1024]], "test": "untested"}
{"id": "wtcSDf", "name": "Polygon - parametrization", "author": "iq", "description": "Space parametrization of a polygon, so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are barely distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url].", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 32, "viewed": 1413, "published": 3, "date": "1581855637", "time_retrieved": "2024-07-30T21:23:36.112501", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a polygon. It only works for convex\n// polygons, has some problems, and I still need to optimize it.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    const int num = verts.length();\n\tfloat s = 1.0;\n    float d = length(p-verts[0]);\n    for( int i=0; i<num; i++ )\n    {\n        vec2 a = verts[i];\n        vec2 b = verts[(i+1)%num];\n       \n        vec2  pa = p-a;\n        vec2  ba = b-a;\n        float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = min(d,length( pa - ba*h ));\n        \n        bvec3 cond = bvec3( p.y>=a.y, p.y<b.y, ba.x*pa.y>ba.y*pa.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*d-r;\n}\n\nfloat angle( in vec2 a, in vec2 b )\n{\n    float n = atan(dot(a,b),cro(a,b));\n    if( n<0.0 )n+=6.283185;\n    return n;\n}\n    \n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band ) \n{\n    const int num = verts.length();\n\n    float od = sdPoly( p, verts, r );\n    \n    float ra = band*round(od/band);\n    \n    float d = length(p-verts[0])-ra;\n    float l = 0.0;\n    float t = 0.0;\n    for( int i=0; i<num; i++ )\n    {\n        vec2 a = verts[ i       ];\n        vec2 b = verts[(i+1)%num];\n        vec2 c = verts[(i+2)%num];\n            \n        vec2  pa1 = p-a; vec2 ba1 = b-a;\n        vec2  pa2 = p-b; vec2 ba2 = c-b;\n        float h1 = dot(pa1,ba1)/dot(ba1,ba1);\n        float h2 = dot(pa2,ba2)/dot(ba2,ba2);\n        float tmp = length( pa1 - ba1*clamp(h1,0.0,1.0) ) - (r+ra);\n        \n        float lba = length(ba1);\n        \n        if( tmp<d || ((i==num-1) && cro(ba1,pa1)>0.0) )\n        {\n            d = min(d,tmp);\n            if( h1>=0.0 && h1<=1.0 )\n            {\n                l = t + h1*lba;\n            }\n            else if( h1>1.0 && h2<0.0)\n            {\n                l = t+lba;\n                l += (r+ra)*angle(ba1,pa2);\n            }\n        }\n        t += lba+(r+ra)*angle(ba1,vec2(-ba2.y,ba2.x));\n    }\n    \n    return vec4(d,l,t,od);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    // animate polygon\n    float id = floor((iTime+0.1)/3.0);\n    vec2 kVerts[5];\n    for( int i=0; i<5; i++ )\n    {\n        kVerts[i] = 0.75*cos( float(i)*vec2(1.1,1.3) + vec2(0,2) + id*11.0 );\n    }\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paPoly(uv,kVerts,0.15,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += 1.0-smoothstep(0.0, 0.005, abs(d)-0.003);\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n        \n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,abs(l-0.35)-0.03);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,l-0.10);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSDf.jpg", "access": "api", "license": "mit", "functions": [[1489, 1489, 1514, 1514, 1533], [1534, 1534, 1567, 1567, 1593], [1595, 1636, 1691, 1691, 2194], [2196, 2196, 2233, 2233, 2316], [2322, 2426, 2489, 2489, 3567], [3574, 3574, 3631, 3667, 4861]], "test": "untested"}
{"id": "ttcXWX", "name": "Box - parametrization", "author": "iq", "description": "Space parametrization of a rounded box, so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are slightly distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url].", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 26, "viewed": 1259, "published": 3, "date": "1581855631", "time_retrieved": "2024-07-30T21:23:36.881445", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a rounded box. Or could also be called\n// \"rounded box\" coordinates.\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat msign( in float x ) { return (x<0.0)?-1.0:1.0; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 q = abs(p)-b;\n        \n    float l = b.x+b.y + 1.570796*r;\n    \n    float k1 = min(max(q.x,q.y),0.0) + length(max(q,0.0))-r;\n    float k2 = ((q.x>0.0)?atan(q.y,q.x):1.570796);\n    float k3 = 3.0 + 2.0*msign(min(p.x,-p.y)) - msign(p.x);\n    float k4 = msign(p.x*p.y);\n    float k5 = r*k2+max(-q.x,0.0);\n    \n    float ra = s*round(k1/s);\n    \n    float l2 = l + 1.570796*ra;\n\n    return vec4(k1-ra,\n                k3*l2+k4*(b.y+((q.y>0.0)?k5+k2*ra:q.y)),\n                4.0*l2,\n                k1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n\n    // animate segment\n    float id = floor((iTime+0.1)/3.0);\n    vec2  si = vec2(0.35,0.15) + 0.1*cos( vec2(1,2) + id*vec2(3,1) );\n    float ra = 0.15 + 0.05*sin(id*0.2);\n    \n    // distance and parametrization    \n    const float band = 0.1;\n    vec4 b = paBox( p, si, ra, band );\n\n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/band)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/band+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    // circles\n    if( d>-band*0.5 )\n    {\n\tvec2 q = b.xy;\n    q.y *= floor(b.z/band)*(band/b.z);  // optional - ensure periodicity, but break physicallity\n    q.y -= iTime*0.1;                   // animate circles\n    \n    vec2 uv = fract(q/band+0.5)-0.5;    // draw circles\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcXWX.jpg", "access": "api", "license": "mit", "functions": [[1259, 1259, 1286, 1286, 1313], [1315, 1419, 1505, 1505, 2016], [2018, 2018, 2075, 2104, 3227]], "test": "untested"}
{"id": "3ttSWX", "name": "Segment - parametrization", "author": "iq", "description": "Space parametrization of a segment (capsule), so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are barely distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url].", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 22, "viewed": 883, "published": 3, "date": "1581855624", "time_retrieved": "2024-07-30T21:23:37.642410", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a segment, or can maybe also call it\n// \"capsule\" coordinates.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    vec2 pb = p-b;\n    \n    float f = dot(pa,ba)/dot(ba,ba);\n    float h = clamp(f, 0.0, 1.0 );\n    float d = length(pa-h*ba) - r;\n    \n    float ra = band*round(d/band);\n    \n    float lba = length(ba);\n   \n    float l = 0.0;\n    if( f<0.0 )\n    {\n        l = (r+ra)*atan(dot(pa,ba),cro(pa,ba));\n    }\n    else if( f>1.0 )\n    {\n        \n        l = lba + (r+ra)*atan(dot(pb,ba),cro(pb,ba));\n    }\n    else\n    {\n        if( cro(pa,ba)<0.0 )\n        {\n            l = lba*2.0 + 3.1415927*(r+ra) - f*lba;\n        }\n        else\n        {\n        \tl = f*lba;\n        }\n    }\n    \n    return vec4( d-ra, l, lba*2.0+6.283185*(r+ra), d );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n\n    // animate segment\n    float id = floor((iTime+0.1)/5.0);\n    vec2  pa = 0.7*cos( vec2(3,2) + id*1.0);\n    vec2  pb = 0.7*cos( vec2(6,1) + id*1.7);\n    float ra = 0.15 + 0.05*sin(id*0.2);\n\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paSegment(uv,pa,pb,ra,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSWX.jpg", "access": "api", "license": "mit", "functions": [[1450, 1450, 1475, 1475, 1494], [1495, 1495, 1528, 1528, 1554], [1556, 1660, 1727, 1727, 2402], [2405, 2405, 2462, 2498, 3664]], "test": "untested"}
{"id": "WldSWX", "name": "Circle - parametrization", "author": "iq", "description": "Space parametrization of a circle, so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are barely distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url]", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 29, "viewed": 976, "published": 3, "date": "1581855617", "time_retrieved": "2024-07-30T21:23:38.408363", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a circle.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band ) \n{\n    float d = length(p) - r;\n    float ra = band*round(d/band);\n    float l = (r+ra)*(atan(p.x,p.y)+3.1415927);\n    return vec4( d-ra, l, 6.283185*(r+ra), d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    const float ra = 0.5 ;\n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paCircle(uv,ra,bandSize);\n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    #if 1\n    q.y -= iTime*0.1;\n    #else\n    q.y -= iTime*0.01*floor(b.z/bandSize);\n    #endif\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSWX.jpg", "access": "api", "license": "mit", "functions": [[1398, 1398, 1423, 1423, 1442], [1443, 1443, 1476, 1476, 1502], [1504, 1608, 1658, 1658, 1820], [1822, 1822, 1879, 1915, 2970]], "test": "untested"}
{"id": "tt3XDf", "name": "Melting snow filter", "author": "avin", "description": "visual experiment", "tags": ["filter", "spring"], "likes": 14, "viewed": 921, "published": 3, "date": "1581844289", "time_retrieved": "2024-07-30T21:23:39.207227", "image_code": "#define SIZE 50.1\n\nfloat rand(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.y;\n    vec2 ouv = fragCoord/iResolution.xy;\n    \n    float m = 0.;\n    float t = iTime*2.2 + 100.;\n    \n    for(float i=0.; i<=1.0; i+=0.25){\n        vec2 iuv = uv + vec2(i*.05, 0.);\n        vec2 ruv = iuv*SIZE;    \n    \tvec2 id = ceil(ruv);\n        \n        for(float y=-1.; y<=1.; y+=1.){\n            for(float x=-1.; x<=1.; x+=1.0){\n                vec2 nuv = ruv + vec2(x,y);\n                vec2 nid = id + vec2(x,y);\n\n                nuv.y += t*2. * (rand(vec2(nid.x))*.75+.5) * i;\n                nuv.y += ceil(mod(nid.x, 3.))*0.3 * t;\n\n                vec2 guv = fract(nuv); \n\n                nuv = floor(nuv) ;    \n                float g = length(guv - vec2(x,y));\n\n                float v = rand(nuv);\n                v *= step(0.9, v); \n                m += smoothstep(v,v-.8, g);\n            }\n        }    \t\n    }\n      \n    m = m*.2 + step(1.25, m) *.2 + step(2.0, m) *.1;\n       \n    \n    vec3 col = texture(iChannel0, ouv + m*.125).rgb;\n            \n    \n    fragColor = vec4(col ,1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 39, 39, 159], [161, 161, 218, 218, 1264]], "test": "untested"}
{"id": "tt3SDf", "name": "Snake scales", "author": "avin", "description": "visual experiment", "tags": ["circles", "lines", "vector"], "likes": 19, "viewed": 627, "published": 3, "date": "1581841590", "time_retrieved": "2024-07-30T21:23:40.202565", "image_code": "#define SIZE 15.0\n#define COL1 vec3(32, 43, 51) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 1. / min(iResolution.x, iResolution.y) * SIZE * .5\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    float ssf = SF * iResolution.y * .004;\n\n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;\n\n    float mask = 0.0;\n    float rmask = 0.0;\n\n    for (int k = 0; k < 9; k++) {\n        vec2 P = vec2(k % 3, k / 3) - 1.;\n        vec2 rid = id - P;\n        vec2 ruv = uv + P + vec2(0, mod(rid, 2.) * .5) + vec2(0, sin(iTime * 2. + rid.x * 5. + rid.y * 100.) * .2);\n\n        float l = length(ruv);\n\n        float d = SS(l, .75) * (ruv.y + 1.);\n\n        mask = max(mask, d);\n        if (d >= mask) {\n            mask = d;\n            rmask = SS(abs(l - .65), SF * iResolution.y * .007);\n        }\n    }\n\n    vec3 col = mix(COL1, COL2, rmask);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3SDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 260, 260, 1017]], "test": "untested"}
{"id": "wlcSWf", "name": "petal 3 (139 chars)", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/wtcSDX[/url]", "tags": ["2d", "onetweet", "golf"], "likes": 5, "viewed": 326, "published": 3, "date": "1581837689", "time_retrieved": "2024-07-30T21:23:41.021376", "image_code": "// variant of https://shadertoy.com/view/wtcSDX\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R  = iResolution.xy, U  = u+u - R ;\n    O += .5 + ( R.x = sin( 30.*( abs( cos( 3.* atan(U.y,U.x) -iTime )) - length(U)/R.y +iTime ) ) ) / fwidth(R.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 86, 86, 248]], "test": "untested"}
{"id": "tlcSWf", "name": "petal 2 (117 chars)", "author": "FabriceNeyret2", "description": "inspired and golfed from [url]https://shadertoy.com/view/wtcSDX[/url]", "tags": ["2d", "onetweet", "golf"], "likes": 3, "viewed": 291, "published": 3, "date": "1581837209", "time_retrieved": "2024-07-30T21:23:41.939920", "image_code": "// inspired and golfed from https://shadertoy.com/view/wtcSDX\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R  = iResolution.xy, U  = u+u - R ;\n    O += abs( cos( 3.* atan(U.y,U.x) -iTime )) - length(U)/R.y *vec4(1,.8,.6,0);\n} \n/*\n\n\n\n\n\n// --- 113 chars: antialiased petals\n\n#define mainImage(O,u)                        \\\n    vec2 R  = iResolution.xy, U  = u+u - R ;  \\\n    O += ( abs( R.x = cos( 3.* atan(U.y,U.x) )) - length(U)/R.y ) / fwidth(R.x) /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 99, 99, 227]], "test": "untested"}
{"id": "wtcXWX", "name": "Art Of Code: Starfield! (SS7)", "author": "angelo12", "description": "Following along https://www.youtube.com/watch?v=rvDo9LvfoVE&feature=emb_title this week!", "tags": ["procedural", "noise", "stars"], "likes": 20, "viewed": 1010, "published": 3, "date": "1581821630", "time_retrieved": "2024-07-30T21:23:42.945232", "image_code": "/*\n\tShader Sundays! (7/52) \n\t\"Starfield from Art of Code\"\n\t\n\tHad relatives visiting this week so couldn't spend too much time on this one. \n\tInstead I decided to follow along one of @Bigwings excellent shader tutorials and get \n\tsomething cool going in under an hour. This is basically a one for one version of his \n\tshader, except I added a cool nebula cloud that I repurposed from a previous shader.\n\tLots of details could be added to this to make it better, like random nebula variation,\n\tphysically accurate star color pattern and nicer star clustering. But alas, maybe for\n\tthe next star pattern. Cheers!\n\n\tPart1:\n\thttps://www.youtube.com/watch?v=rvDo9LvfoVE&feature=emb_title\n\n\tPart2:\n\thttps://www.youtube.com/watch?v=dhuigO4A7RY&feature=emb_title\n\t\n\tCheckout his patreon! \n\thttps://www.patreon.com/TheArtOfCode\n*/\n\nfloat\nmakeStar(vec2 uv, float flare)\n{\n    float d = length(uv);\n    float star = .06/d;\n    float m = star;\n\n\n    float rays = max(1.0 - abs(uv.x*uv.y * 1000.0), 0.0);\n    m +=rays * flare;\n\n    uv = rotate(uv, M_PI/ 4.0);\n        rays = max(1.0 - abs(uv.x*uv.y * 1000.0), 0.0);\n        m +=rays*flare *0.3;\n\n    m *= smoothstep(1.0, .2, d);\n\n    return m;\n}\n\nfloat\nhash21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec2 \nrandom2D(vec2 val){\n    val = vec2(dot(val, vec2(127.1, 311.7)),\n               dot(val, vec2(242.51, 184.2)));\n    \n    float scale = 182364.0;\n    return 1.0 -  2.0 * fract(sin(val) * scale);\n}\n\nfloat \nnoise(vec2 p){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor( p + (p.x + p.y) * K1);\n\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step(a.yx, a.xy);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\n    vec3 n = h*h*h*h*vec3(dot(a, random2D(i)), dot(b, random2D(i + o)), dot(c, random2D(i+1.0)));\n\n    return dot(n, vec3(100.0));\n}\nfloat \nsimplex(vec2 p, int octaves){\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\n    float f = 0.0;\n    float scale = 1.0;\n    for(int i = 0; i < octaves; i++){\n        scale /= 2.0;\n        f += scale*noise(p);\n        p *= m;\n    }\n\n    return 0.5 + 0.5*f;\n}\n\nvec3\nStarLayer(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv) - 0.5;\n\n    for(int y = -1; y <= 1; ++y)\n    for(int x = -1; x <= 1; ++x)\n    {\n        vec2 offset = vec2(x, y);\n        float n = hash21(id + offset);\n        float size = fract(n*345.45);\n\n        float star = makeStar(gv - offset - vec2(n, fract(n*34.0) ) + .5, smoothstep(.9, 1.0, size)* 0.6);\n        vec3 color = sin(vec3(1.2, .3, .2)*fract(n*2345.2) * 123.2)*.5 + 0.5;\n        color = color * vec3(1.0, 0.25, 1.0 + size);\n        star *= sin(iTime*3.0 + n*M_TAU)*.5 +1.;\n        col += star*size*color;\n    }\n\n    return col;\n}\n\nvec3\ngas_halo_outer(vec2 uv, float size, int density)\n{\n    float halo_mask = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 color =  vec3(0.1, 0.3, 1.8);\n    for(int i = 0; i < density; ++i){\n        float offset = hash21(vec2(i));\n        float r = size + (size / 2.0f) * cos(atan(uv.y + offset * 0.2f, uv.x)* (3.0 ) + radians(offset * 360.0f));\n        halo_mask = smoothstep(r, r + 0.35f, length(uv));\n        col += color * (1.0 - halo_mask - simplex(uv, 5)) *  1.0f / float(density);\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\n#define NUM_LAYERS 8.0\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPosition)\n{\n    vec2 uv  = ((fragPosition) - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float t = iTime*.04;\n    \n    for(float i = 0.0;i < 1.0; i += 1.0/NUM_LAYERS)\n    {\n        float depth = fract(i +t);\n\n        float scale = mix(20.0, 0.5, depth);\n\n        float fade = depth*smoothstep(1., .9, depth);\n\n        float size = 1.6;\n\n        col += StarLayer(uv*scale + i*453.2)*fade;\n        scale = mix(10.0, 0.5, fract(i + 1.0*t));\n        col += gas_halo_outer(uv*scale + i*400.2, size, 10)*fade;\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "/*\n\tJust a bunch of common variables/functions that I use in most of my shaders\n\tProbably very few of these got used in this shader, but it's easier to just include\n\tthe whole thing.\n*/\n\n#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[822, 822, 860, 860, 1181], [1183, 1183, 1205, 1205, 1299], [1301, 1301, 1326, 1326, 1502], [1504, 1504, 1525, 1525, 1999], [2000, 2000, 2036, 2036, 2257], [2259, 2259, 2284, 2284, 2895], [2897, 2897, 2952, 2952, 3420], [3445, 3445, 3503, 3503, 4057]], "test": "untested"}
{"id": "3t3XWf", "name": "Expression Plotter", "author": "ttg", "description": "Plot any expression using a macro!  (Function definition not required).\nFocus is on accuracy, not speed.  For lineweight lw (pixels), function is evaluated 2+floor(lw) times.\nAntialiasing still a bit dodgy.", "tags": ["plot", "util", "macro"], "likes": 15, "viewed": 492, "published": 3, "date": "1581813898", "time_retrieved": "2024-07-30T21:23:43.870758", "image_code": "void mainImage( out vec4 v, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    mat2 domain = transpose(mat2(-2.,2.,-2.,2.));\n    \n    mat2 window;\n    \n    window = transpose(mat2(.01,.48,.51,.48));\n\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(1), 1, 0, 0., sin(x*2.) );\n    for (float o = .4; o < 3.; o+=.4) {\n        float lw = 0.006*o;\n        float k = 2./(1.+.5*o);\n        PLOT_CONTINUOUS(col,uv,window,domain,vec3(1), 0, 0, lw, sin(k*x)+o );\n        PLOT_CONTINUOUS(col,uv,window,domain,vec3(0), 0, 0, lw, sin(k*x)-o );\n    }\n    \n    window = transpose(mat2(.51,.48,.51,.48));\n\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(0,1,.2), 0, 1, .02, 1.5*(x<0.?cos(exp(-x)*6.):.5*sign(cos(x*20.))) );\n    \n    mat2 window_ll = transpose(mat2(.01,.49,.01,.48));\n    mat2 window_lr = transpose(mat2(.50,.49,.01,.48));\n    mat2 domain_ll = transpose(mat2(-2.,0.,-2.,2.));\n    mat2 domain_lr = transpose(mat2( 0.,2.,-2.,2.));\n    \n    PLOT_CONTINUOUS(col,uv,window_lr,domain_lr, vec3(1), 1, 0, 0., 2. );\n\n    if (abs(uv.x-.5)>.01)\n    for (float o = 0.; o < 1.; o+=.1) {\n        float lw = 0.03;\n        float k = 8.*exp(-o*.3);\n        float h = 1.+3.*o;\n        vec3 c = pow(.5+.5*cos(h+vec3(0,1,2)*2.094),vec3(2.));\n        int blend = (uv.x<.25?1:0);\n        if (abs(uv.x-.25)>.01)\n        PLOT_CONTINUOUS(col,uv,window_ll,domain_ll, blend==1?c*.3:c, 0, blend, lw, cos(k*(x-2.5)-iTime) );\n        PLOT_CONTINUOUS(col,uv,window_lr,domain_lr,               c, 0, 2,     lw, cos(k*(x-2.5)-iTime) );\n    }\n    \n    v = vec4(pow(col,vec3(1./2.2)),0);\n}\n", "image_inputs": [], "common_code": "\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 1576]], "test": "untested"}
{"id": "3lcSDf", "name": "Trabecular 3D Mesh No. 2", "author": "wyatt", "description": "Devoirs de Fabrice. ", "tags": ["raymarching"], "likes": 21, "viewed": 610, "published": 3, "date": "1581813470", "time_retrieved": "2024-07-30T21:23:44.782320", "image_code": "// Fork of \"Trabecular 3D Mesh No. 1\" by wyatt. https://shadertoy.com/view/Wt3SDf\n// 2020-02-15 23:47:38\n\nMain\n{\n    Q = A(U)/float(iFrame);\n    Neighborhood;\n    vec3 no = normalize(vec3(grd,.001));\n    Q *= 0.5+0.5*texture(iChannel1,no);\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.w-w.w,n.w-s.w)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n", "buffer_a_code": "#define O 3.\nvec3 cell (vec3 u, out vec3 h) {\n\tvec3 V = round(u*O) / O;\n    h = hash33(V);\n    return V + ( h*2.-1. ) / O;\n}\nfloat pie (vec3 p, vec3 a, vec3 b) {\n\tvec3 m = (a+b)/2.;                    // midpoint\n    return length(a-b) < 1e-3\n        ? 1e3                             // ignore self\n\t    : abs(dot(p-m,b-m)/dot(b-m,b-m)); // projection\n}\nfloat line (vec3 p, vec3 a, vec3 b) {\n    p -= a; b -= a;\n    float i = clamp(dot(p,b)/dot(b,b),0.,1.);\n\treturn length(p-b*i);\n}\nfloat bord (vec3 p, vec3 a, vec3 b, vec3 c) {\n\tif (length(a-c)<1e-3||length(c-b)<1e-3) return 1e3;\n    float e1 = pie(p,a,b)*length(a-b);\n    float e2 = pie(p,a,c)*length(a-c);\n    return max(e1,e2);\n}\nMain\n{\n    Q = A(U);\n    if (iFrame < 1) Q-=Q;\n    \n    U = (U-.5*R) / R.y;\n    vec3 d = normalize(vec3(U,.66)),\n         p = d*Q.w -28.55,\n         V = vec3(1e3), W=V,\n       col = V-V;\n\tfloat border = 1e3;\n#define loopNb                               \\\n    for (int k = 0; k < 5*5*5; k++) {        \\\n        vec3 h, c = cell( p + vec3( k%5-2, (k/5)%5-2, k/25-2 ) / O, h);\n                                     \n    loopNb if (length(c-p) < length(V-p)) V=c, col = h; }\n    loopNb if (pie(p,V,c) < pie(p,V,W)) W = c; }\n\tloopNb border = min(border,bord(p,V,W,c)-0.001); }\n    float    y = col.y,\n          ball = length(p-V) - .03,\n       segment = line(p,W,V) -.003,\n          edge = pie(p,W,V) * length(W-V);\n    \n    col = abs( sin( 10.*col.x+ (1.+2.*col.z)* vec3(1,2,3) ) );\n    Q.xyz += col * exp(-30.*abs(ball))\n          + (1.+col) * smoothstep(1e-4,0.,ball)\n   \t      + .1 * smoothstep(1e-4,0.,segment)\n          + (col+1.) * smoothstep(2e-2,0.,edge);\n    Q.w +=  0.5*min(min(ball, min(segment,border))\n           * (1.-.95*exp(-100.*edge*edge))\n           *( 1.-.9 *exp(-500.*ball*ball)),.01);\n}", "buffer_a_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wt3SDf", "name": "Trabecular 3D Mesh No. 1", "author": "wyatt", "description": "Homework assignment for Fabrice. \nIt has a terrible framerate, but the result in full screen isn't bad. ", "tags": ["volumetric"], "likes": 13, "viewed": 462, "published": 3, "date": "1581809773", "time_retrieved": "2024-07-30T21:23:45.546278", "image_code": "// Fork of \"Color Distribution\" by wyatt. https://shadertoy.com/view/wltXRs\n// 2020-02-15 22:56:54\n\nSampler\nMain\n{\n    vec3 mi = 0.5*vec3(R/N,N*N);\n    vec3 p = vec3(0,0,-R.x/N);\n    vec3 d = normalize(vec3((u-0.5*R)/R.y,1));\n    if (iMouse.z>0.) {\n \t\tp.zx *= e(6.2*iMouse.x/R.x);\n\t\td.zx *= e(6.2*iMouse.x/R.x);\n        p.yz *= e(6.2*iMouse.y/R.y);\n\t\td.yz *= e(6.2*iMouse.y/R.y);\n    } else {\n\t\tp.yz *= e(.2*iTime);\n\t\td.yz *= e(.2*iTime);\n\t}\n    Q = vec4(0);\n    for (int i = 0; i < 120; i++) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m<.01)\n        { \t\n            vec4 a = 25.*T(p+mi);\n            float aa = a.x;\n            Q += 4e-4*(1.-exp(-aa))*a;\n            p += d*(.08+exp(-aa));\n            p = mod(p+mi,R3D)-mi;\n        } else p += d*m;\n        \n \t}\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 7.\n#define R iResolution.xy\n#define R3D vec3(R/N,N*N)\n#define d2(U) ((U).xy+vec2(mod(floor((U).z),N),floor(floor((U).z)/N))*R/N)\n#define d3(u) vec3(mod(u,R/N),floor(u/R*N).x+floor(u/R*N).y*N)\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define A(U) texture(iChannel0 d2(mod(U,R3D))/R)\n#define B(U) texture(iChannel1,d2(mod(U,R3D))/R)\n#define Sampler vec4 T(vec3 U) {return mix(texture(iChannel0,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel0,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Main void mainImage( out vec4 Q, in vec2 u )\n#define _3D  vec3 U = d3(u);\n#define Me Q = A(U);\n#define Them vec4 M = 1./6.*(A(U+vec3(1,0,0))+A(U+vec3(0,1,0))+A(U+vec3(0,0,1))+A(U-vec3(1,0,0))+A(U-vec3(0,1,0))+A(U-vec3(0,0,1)));\n#define Init  if (iFrame < 1) Q = vec4(0);\n\n\n\n#define pie(p, a, b) ((length((a)-(b))<1e-3)?1e3:abs(dot((p)-0.5*((a)+(b)),(b)-(0.5*((a)+(b))))/dot((b)-0.5*((a)+(b)),(b)-0.5*((a)+(b)))))\n\n#define line(p, a, b)  ((length((p)-(a)-((b)-(a))*clamp(dot((p)-(a),(b)-(a))/dot((b)-(a),(b)-(a)),0.,1.))))\n\n", "buffer_a_code": "#define O 1.\n// Dave Hashkins\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 cell (vec3 u) {\n\tvec3 V = floor(u*O+0.5)/O;\n    vec3 h = hash33(V);\n    float t = 0.2*iTime;\n    return V + h.x*vec3(cos(6.2*h.y+t),sin(6.2*h.y+t),sin(6.2*h.z+t))/O;\n}\nMain\n{\n    _3D\n    Q = vec4(0);\n    U = (.7-0.3*sin(.1*iTime))*2.*(U-0.5*R3D)/R3D.y;\n    vec3 V = vec3(1e3);\n    for (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++) \n    for (int z = -2; z <= 2; z++) {\n\t\tvec3 c = cell(U+vec3(x,y,z)/O);\n        if (length(c-U) < length(V-U))\n            V=c;\n    }\n    vec3 W = vec3(1e3);\n    for (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++) \n    for (int z = -2; z <= 2; z++) {\n\t\tvec3 c = cell(U+vec3(x,y,z)/O);\n        if (pie(U,V,c) < pie(U,V,W))\n            W=c;\n    }\n    Q += vec4(1,0,0,1)*smoothstep(0.2,0.,length(U-V));\n   \tQ += vec4(1,0,1,1)*smoothstep(0.05,0.0,line(U,W,V));\n    Q += smoothstep(0.08,0.0,pie(U,W,V)*length(W-V));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3SDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 114, 114, 800]], "test": "untested"}
{"id": "3ldXD2", "name": "thorn garden", "author": "mahalis", "description": "learning about iterated function systems. also gave antialiasing a shot, with dubious success.", "tags": ["fractal", "ifs"], "likes": 5, "viewed": 424, "published": 3, "date": "1581793340", "time_retrieved": "2024-07-30T21:23:46.442880", "image_code": "// license: CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\n// set to 1 if the holes bother you\n#define TRYPOPHOBIA 0\n\n// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTet(vec3 p, float r) {\n    const vec3 c = normalize(vec3(1.,-1.,1.));\n    return max(max(max(dot(p, c.xxx) - r, dot(p, c.yyx) - r), dot(p, c.xyy) - r), dot(p, c.yxy) - r);\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// assumes normalized axis\nmat3 makeRotation(vec3 axis,float angle) {\n    \n    float c = cos(angle), s = sin(angle);\n    float mc = 1. - c;\n    float sz = s * axis.z;\n    float sy = s * axis.y;\n    float sx = s * axis.x;\n    float mx = mc * axis.x;\n    float my = mc * axis.y;\n    float mz = mc * axis.z;\n    \n    return mat3(c + mx * axis.x,\n                mx * axis.y - sz,\n                mx * axis.z + sy,\n                mx * axis.y + sz,\n                c + my * axis.y,\n                my * axis.z - sx,\n                mx * axis.z - sy,\n                my * axis.z + sx,\n                c + mz * axis.z);\n}\n\n// -----------------\n\nmat3 innerRotation;\n\nfloat d(vec3 position) {\n    position = rX(position, iTime * 0.13);\n    float fScale = 0.79 + sin(iTime * 0.9) * 0.013;\n    float accumulatedScale = 1.;\n    \n    for(int i = 0; i < 8; i++) {\n        position = abs(position);\n        position *= fScale;\n        accumulatedScale *= fScale;\n        position -= (0.0137 + 0.001 * sin(iTime * 0.6 + 1.));\n        position = innerRotation * position;\n    }\n    float cutoutAmount = pow(sin(iTime * 0.231), 4.);\n    #if TRYPOPHOBIA\n    float innerCutout = sdTet(-position,0.003 + cutoutAmount * 0.009);\n    #else\n    float innerCutout = sdSphere(position, 0.014 + cutoutAmount * 0.002);// sdSphere(position, 0.009 + cutoutAmount * 0.007);\n    #endif\n    float outerCrop = sdSphere(position, 0.021 + sin(iTime * 0.831 + 2.) * 0.003);\n    return opInt(opSub(sdTet(position, 0.01), innerCutout), outerCrop) / accumulatedScale;\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 70; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\n// ambient occlusion using iqs technique from https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat occlusion(vec3 position, vec3 normal) {\n    const float aoStep = 0.04;\n    float aoAcc = 0.;\n    const float distanceScale = 0.005; // decrease for less attenuation of shadows\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float sampleDistance = aoStep * fi;\n        aoAcc += (sampleDistance - max(0.,d(position + normal * sampleDistance))) / exp2(fi * distanceScale);\n    }\n    return aoAcc;\n}\n\nvec3 palette(float v) {\n    v *= 4.;\n    return vec3(0.5) + 0.5 * cos(6.28318 * (v + vec3(0.0,0.333,0.667)));\n}\n\n// soft shadows also using iqs technique  https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 origin, vec3 direction, float sharpness) {\n    const float maxDistance = 2.;\n    float amount = 1.;\n    float totalDistance = 0.;\n    for(int i = 0; i < 70; i++) {\n        float localDistance = d(origin);\n        amount = min(amount, 0.5 + 0.5 * localDistance / (sharpness * totalDistance));\n        if (localDistance < 0.) break;\n        origin += direction * max(0.002, localDistance);\n    }\n    \n    amount = max(amount, 0.);\n    return amount * amount * (3. - 2. * amount);\n    \n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.4, 1.0, 0.6)  - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    float nDotV = max(0., dot(normal, toEye));\n    const float diffuse = 1.;\n    float ambience = 0.1 + max(0., dot(normal, vec3(0.,-1.,0.))) * 0.4;\n    const float specular = 0.3;\n    float ao = (1.0 - occlusion(position, normal));\n    float fres = pow(1. - nDotV, 8.);\n    float shadowAmount = shadow(position + normal * 0.01, toLight, .5);\n    \n    vec3 color = vec3((ndotL * diffuse + pow(ndotH, 4.) * specular) * shadowAmount + ao * (ambience + fres)) * palette(nDotV * -0.5 + 0.6 + iTime * 0.03);\n    return color;\n}\n\n\n#define ANTIALIASING_SAMPLES 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, -0.04, 0.0);\n    vec3 cameraPosition = vec3(0.0, 0.2, 1.5) * 1.7;\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    innerRotation = makeRotation(normalize(vec3(1.,2.,-3.)), iTime * 0.122 + sin(iTime * 0.23) * 0.1);\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < ANTIALIASING_SAMPLES; i++) {\n        vec3 aaOffset = 0.002 * (cameraRight * float(i == 1 || i == 3) + cameraUp * float(i == 0 || i == 2));\n    \tvec4 marchResult = march(cameraPosition + aaOffset, rayDirection, 0.0001);\n    \tif (marchResult.w > 0.0) {\n    \t    color += vec3(0.0); // sky color\n    \t} else {\n    \t    vec3 position = marchResult.xyz;\n    \t    color += lightSurface(position, gradient(position, marchResult.w), -rayDirection);\n    \t}\n    }\n    color /= float(ANTIALIASING_SAMPLES);\n    color = pow(color, vec3(1.2)) * 1.5;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXD2.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[140, 140, 186, 186, 295], [297, 297, 328, 328, 417], [419, 419, 452, 452, 480], [482, 482, 512, 512, 663], [665, 665, 702, 702, 748], [750, 750, 783, 783, 810], [812, 812, 845, 845, 871], [873, 873, 906, 906, 932], [934, 934, 960, 960, 1099], [1101, 1101, 1127, 1127, 1267], [1269, 1269, 1295, 1295, 1434], [1436, 1463, 1505, 1505, 2051], [2096, 2096, 2120, 2120, 2965], [2967, 2967, 2999, 2999, 3125], [3127, 3127, 3176, 3176, 3611], [3613, 3720, 3765, 3765, 4144], [4146, 4146, 4169, 4169, 4257], [4259, 4349, 4409, 4409, 4851], [4853, 4853, 4912, 4912, 5618], [5653, 5653, 5710, 5710, 6938]], "test": "untested"}
{"id": "WtcXDX", "name": " - Quicky#021", "author": "totetmatt", "description": "Vector mountains ! ", "tags": ["quicky"], "likes": 1, "viewed": 337, "published": 3, "date": "1581792945", "time_retrieved": "2024-07-30T21:23:47.320534", "image_code": "# define ttime floor(iTime*.2) + pow(fract(iTime*.2),1.25)\n\nmat2 r(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));  }\n\n\nvec3 fig(vec2 uv, float p) {\n    float d =abs(atan(uv.x,uv.y))+3.141592;\n    return floor(p*vec3(d)/(3.141592*2.))/p;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    \n    uv *=r(3.14*.85);\n    \n    uv*=4.;\n    vec3 a = fig(uv*r(3.1415/4.+cos(iTime)*.1)+vec2(0.5,0.5),10.+sin(ttime));\n    vec3 b = fig((uv*r(3.1415*4.+sin(iTime)*.1))-vec2(0.5,0.5),10.+cos(ttime));\n    \n     vec3 c = fig(uv*r(3.1415*4.+sin(iTime)*.1)+vec2(0.5,0.5),10.+cos(ttime));\n    vec3 d = fig((uv*r(3.1415/4.+cos(iTime))*.1)-vec2(0.5,0.5),10.+sin(ttime));\n    \n    vec3 kk = smoothstep(0.69,.75+sin(iTime)*.01,(b+a+c+d)/4.);\n    kk = mix(vec3(0.9),vec3(0.1,0.2,0.3),kk);\n    fragColor = vec4(kk,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 76, 76, 122], [125, 125, 153, 153, 244], [245, 245, 300, 300, 876]], "test": "untested"}
{"id": "3tcXDX", "name": "Different aspect ratio blur", "author": "luluco250", "description": "Typical filter you see in videos with vertical aspect ratio, simplified.", "tags": ["2d", "blur", "filter", "gaussian", "aspect", "ratio"], "likes": 7, "viewed": 372, "published": 3, "date": "1581792581", "time_retrieved": "2024-07-30T21:23:48.311883", "image_code": "//============//\n// Parameters //\n//============//\n\n// Amount of blur samples.\nconst int BlurSamples = 13;\nconst int BlurHalfSamples = BlurSamples / 2;\nconst float BlurInvSamples = 1.0 / float(BlurSamples);\n\n// Extra cropping of the video area, in percentage of the screen.\nconst vec2 ExtraCrop = vec2(0.1, 0.0);\n\n// Tint applied to the blurred area.\nconst vec3 Tint = vec3(1.0);\n\n//===========//\n// Functions //\n//===========//\n\n// Scale a coordinate while keeping it anchored to a point.\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\n// Apply a simple 1D blur, dir should specify pixel size.\nvec3 simple_blur(sampler2D sp, vec2 uv, vec2 dir) {\n    vec3 color = vec3(0.0);\n    \n    // Initial offset so that the result is later centered.\n    uv -= dir * vec2(BlurHalfSamples);\n    \n    // Explanation:\n    //  A: Starting pixel.\n    //  B: Ending pixel.\n    //  C: Center of the blur kernel.\n    //\n    // Before offset:\n    //               v~~~ The initial coordinate is here.\n    // | - | - | - | A | x | x | C | x | x | B |\n    //                           ^~~~ The center gets shifted all the way here.\n    //\n    // After offset:\n    //   v~~~ We offset backwards...\n    // | A | x | x | C | x | x | B | - | - | - |\n    //               ^~~~ ...so that the center remains where it was before the blur.\n    \n    for (int i = 0; i < BlurSamples; ++i)\n        color += texture(sp, uv + dir * float(i)).rgb;\n    \n    color *= BlurInvSamples;\n    return color;\n}\n\n// Correct the aspect ratio of a coordinate relative to a source\n// and destination resolution.\nvec2 correct_aspect(vec2 uv, vec2 source_res, vec2 dest_res) {\n    float ar_source = source_res.x / source_res.y;\n    float ar_dest = dest_res.x / dest_res.y;\n    float ar = ar_dest / ar_source;\n    \n    // Choose to adjust either the horizontal or vertical scale\n    // depending on whether the source ratio is vertical to the dest.\n    vec2 scale = mix(vec2(ar, 1.0), vec2(1.0, ar), step(ar, 1.0)); \n    return scale_uv(uv, scale, vec2(0.5));\n}\n\n// Check whether a point is inside a given area (xStart, yStart, xEnd, yEnd).\nfloat is_visible(vec2 uv, vec4 area) {\n    return\n        step(area.x, uv.x) *\n        step(uv.x, area.z) *\n        step(area.y, uv.y) *\n        step(uv.y, area.w);\n}\n\n//========//\n// Shader //\n//========//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    vec2 mouse = iMouse.xy * ps;\n    mouse.y = 1.0 - mouse.y;\n    \n    // Draw blurred background.\n    color.rgb = simple_blur(iChannel0, uv, vec2(ps.x * float(BlurHalfSamples), 0.0));\n    color.rgb *= Tint;\n    color.a = 1.0;\n    \n    // Draw actual video.\n    vec2 video_uv = correct_aspect(uv, iChannelResolution[0].xy, iResolution.xy);\n    vec3 video = texture(iChannel0, video_uv).rgb;\n    \n    // Cut-off pixels outside the video aspect ratio.\n    vec2 extraCrop = mix(ExtraCrop, mouse, step(0.1, iMouse.z)) * 0.5;\n    vec4 visible_area = vec4(extraCrop, 1.0 - extraCrop);\n    color.rgb = mix(color.rgb, video, is_visible(video_uv, visible_area));\n    \n    // Expand contrast range.\n    color.rgb = smoothstep(0.15, 1.0, color.rgb);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[430, 490, 539, 539, 584], [586, 644, 695, 695, 1514], [1516, 1612, 1674, 1674, 2058], [2060, 2138, 2176, 2176, 2304], [2346, 2346, 2390, 2390, 3199]], "test": "untested"}
{"id": "WtcXWX", "name": "Grid glow experiment", "author": "rodgzilla", "description": "glow on grid experiment", "tags": ["raymarching", "glow"], "likes": 4, "viewed": 369, "published": 3, "date": "1581785555", "time_retrieved": "2024-07-30T21:23:49.073846", "image_code": "#define time .7 * iTime\n#define ZPOS -10.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * sin(time * tempo) + .5;\n}\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c); \n}\n\nvec3 kifs(vec3 p) {\n    float s = 1.;\n//    float t = floor(time) + smoothstep(.0, 1., fract(time));\n  \tfloat t = time * .3;\n    for (float i = 0.; i < 1.; i++) {\n        p.xy *= rot2d(t);\n        p.yz *= rot2d(.9 * t + i * .7);\n        p = abs(p);\n        p -= s;\n//        s *= .6 + .2 * sin(time / 1.5);\n        s *= .7;\n    }\n    \n    return p;\n}\n\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n//    t = clamp(t, 0., 1.);\n    vec3 c = a + ab * t;\n    \n    return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n    vec3 q = mod(p, r) - .5 * r;\n    \n    return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n//    p.xy *= rot2d(cos(time) * sin(p.z / 3.));\n    vec3 rawP = p;\n//    p = kifs(p);\n    p = rep(p, vec3(1. + wave(.65), 2. + wave(.6), 1.5 + wave(.7)));\n    \n    float d = 5000.;\n\n//    d = min(d, sphere(p, 1.));\n    d = min(d, tube(p, vec3(0, -2, 0), vec3(0, 2, 0), .1));\n    d = min(d, tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), .1));\n    d = min(d, tube(p, vec3(0, 0, 2), vec3(0, 0, -2), .1));\n//    d = max(d, -sphere(rawP, 10.));\n    \n    at += .05 / (.1 + 5. * d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < 0.01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds * .5;\n//        glow += .015 * at * vec3(.8, .5 * sin(time / 1.) + .5, .5 * cos(time / 5.) + .5);\n        glow += .001 * at * vec3(.8, wave(.5) * cos(.1 * p.z), 0);\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    ));\n  \n   return n;                 \n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(0, 0, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n\tvec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    vec3 col = dif * glow;\n//    vec3 col = vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 91, 91, 133], [135, 135, 156, 156, 228], [230, 230, 249, 249, 580], [583, 583, 614, 614, 642], [644, 644, 689, 689, 862], [864, 864, 890, 890, 944], [961, 961, 980, 1028, 1470], [1493, 1493, 1521, 1521, 1930], [1932, 1932, 1952, 1952, 2137], [2139, 2139, 2160, 2160, 2412], [2414, 2414, 2471, 2471, 2879]], "test": "untested"}
{"id": "tttXD2", "name": "Showdown practice", "author": "rodgzilla", "description": "Shader showdown practice, coded in 25mn.", "tags": ["raymarching", "kifs"], "likes": 1, "viewed": 349, "published": 3, "date": "1581775256", "time_retrieved": "2024-07-30T21:23:49.979425", "image_code": "#define time .7 * iTime\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c); \n}\n\nvec3 kifs(vec3 p) {\n    float s = 5.;\n    float t = floor(time) + smoothstep(.3, .7, fract(time));\n    \n    for (float i = 0.; i < 5.; i++) {\n        p.xy *= rot2d(t);\n        p.yz *= rot2d(.9 * t + i * .7);\n        p = abs(p);\n        p -= s;\n        s *= .6 + .2 * sin(time / 1.5);\n//        s *= .8 +;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p);\n    \n    float d = 5000.;\n   \td = min(d, sph(p, 1.));\n\n    vec3 shift = vec3(1.5 + sin(time * 5.), 0, 0);\n    shift.xy *= rot2d(time * .4);\n    shift.yz *= rot2d(time * .6);\n    d = min(d, sph(p + shift, 1. + .3 * cos(time * .7)));\n    \n    at += .05 / (.1 + d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < 0.01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds;\n        glow += .015 * at * vec3(.8, .5 * sin(time / 1.) + .5, .5 * cos(time / 5.) + .5);\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    ));\n  \n   return n;                 \n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(0, 0, -80);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, -60);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n\tvec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    vec3 col = dif * glow;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 46, 46, 118], [120, 120, 139, 139, 451], [453, 453, 481, 481, 509], [526, 526, 545, 545, 846], [869, 869, 897, 897, 1232], [1234, 1234, 1254, 1254, 1439], [1441, 1441, 1462, 1462, 1713], [1715, 1715, 1772, 1772, 2151]], "test": "untested"}
{"id": "3tdSWj", "name": "Mercoeur", "author": "JulesFouchy", "description": "coeur", "tags": ["coeur"], "likes": 1, "viewed": 353, "published": 3, "date": "1581761992", "time_retrieved": "2024-07-30T21:23:50.918913", "image_code": "float heartSDF(vec2 uv){\n  \tfloat x = uv.x; float y = uv.y;\n    \n  \t//             L'QUATION EST L\n    \n    //     | | | | | | | | | | | | | | | | | |\n    //     v v v v v v v v v v v v v v v v v v\n\treturn pow(x*x + y*y - 1., 3.) - x*x*y*y*y;\n}\n\nfloat rand(vec2 id){\n  \tvec2 r = fract(id * vec2(127.34, 456.21));  \n \tr += dot(r, r+475.32);\n    return fract(r.x*r.y);\n}\n\nvec3 rand3(vec2 id){\n    return vec3(rand(id), rand(id*714.62), rand(id*164397.241));\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat singlePuls(vec2 id, float phase){\n    float puls = 2.2 + 1.7*rand(id);\n    float s = 0.5*pow(sin(puls*(iTime + phase) + rand(id)*15.), 2.0);\n    return smin(s, 0., 32.);\n}\n\nfloat heartbeatPuls(vec2 id) {\n    return (singlePuls(id, 0.)\n         +  singlePuls(id, 0.35)) *0.5;\n}\n\nfloat heart(vec2 uv, vec2 id){\n    uv += 0.6* (rand(id)-0.5);\n    uv *= 2.8 * (1. + 4.*heartbeatPuls(id));\n    \n    float margin = 0.00001;\n    return smoothstep(margin, -margin, heartSDF(uv)) - smoothstep(margin, -margin, heartSDF(uv*1.14));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 heartCol = vec3(1.0, 0.2, 0.8);\n    vec3 backCol  = vec3(1.0, 0.65, 0.92);\n    //vec3 backCol  = vec3(255, 237, 110)/255.;\n    //vec3 backCol  = vec3(182, 196, 250)/255.;\n    //vec3 backCol  = vec3(255, 194, 89)/255.;\n    \n    vec2 uv = fragCoord/iResolution.y - vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n   \tuv *= 4.;\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float t = 0.;\n    vec3 col = vec3(0.);\n    for (float x = -1.; x < 1.5; x+=1.){\n        for (float y = -1.; y < 1.5; y+=1.){\n            vec2 off = vec2(x, y);\n            float h = heart(gv - off, id + off);\n            t += h;\n            if (h>0.5)\n                col = heartCol + (rand3(id+off)-0.5)*vec3(0.3, 0.5, 0.5);\n        }\n    }\n    //t = min(t, 1.);\n    //col = t * heartCol + (1.-t) * backCol;\n    \n    if (t < 0.5)\n        col = backCol;\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 248], [250, 250, 270, 270, 372], [374, 374, 394, 394, 461], [463, 463, 502, 502, 576], [578, 578, 617, 617, 755], [757, 757, 787, 787, 860], [862, 862, 892, 892, 1106], [1108, 1108, 1165, 1165, 2056]], "test": "untested"}
{"id": "wtdXDj", "name": "fast heightfield rendering", "author": "FabriceNeyret2", "description": "WIP (remaining bugs, not optimal yet...)\nFast terrain marching using hierarchical quad-tree of min/max values ( obtained for ~free by twisting MIPmap feature ) as bounding box hierarchy / BVH.\nMouse controls camera.\nuncomment line #51 to see cost heatmap.", "tags": ["video", "minmax", "gpmipmap", "bbox"], "likes": 27, "viewed": 1197, "published": 3, "date": "1581761315", "time_retrieved": "2024-07-30T21:23:51.806540", "image_code": "// minmax quadtree from \"making minmax quadtree for free\"  https://shadertoy.com/view/WdyGWd\n\n#define LOD 4.\n\n#define rot(t) mat2( cos(t+vec4(0,11,33,0)) )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float res = texture(iChannel0, .5/R.xy).a,  // size of texture in channel0\n            r = res / R.y, d;                   // texture res % window res\n\n                                                // test: show texture snippet\n  //if (max(U.x/R.x,U.y/R.y)<.1) { O = .2+texture(iChannel0, U*r/(R.xy*.1)).rrrr; return; }\n      \n    vec3  D = vec3(.7*(U+U-R.xy)/R.y, 1),       // ray direction\n          V,P0,F, p;                            // marching point along ray \n    O-=O;  \n    D.yz *= rot(-1.1);                          // rotation\n    vec2 M = iMouse.xy, T;                      // user rotation\n    if (length(M) > 15.) { \n        M = 2.*M/R.xy - 1.;\n        D.xz *= rot(-M.x*2.);\n        D.yz *= rot(-M.y*1.5);\n    }\n    D = normalize(D);\n    p = vec3(.5,.5,.1);                         // viewpoint\n    r = res;\n    int i=300;                                  // to limit iterations\n    float h = .2;                               // heightfield thickness\n    int l, lM = 6, lm = 0;                      // thinnest LOD\n#define w(l) (float(1<<l)/res)                  // tile width\n    ivec2 _B,B=ivec2(0),B2;\n    do {\n        T = fract(p.xz);                        // pos in texture heightfield\n      //float pix = dFdx(p.x);                  // pixel size [ can't use: cause discontinuities ]\n      //lm = int(log2(pix*res));\n      //[ lM = int(log2(res)) ? but max MIPmap levels are flawn ]\n      //_B=B; B = ivec2(T*res); B2 = ivec2(log2(float(B ^ _B))); // highest tile level change \n      //lM = min(6, max(B2.x,B2.y) );\n        for( l=lM; l>=lm; l--) {    // try LOD from top to bottom [we should resume prev l]\n          //if ( w(l) < pix ) { l=lm-1; break; }// stop LOD at pixel footprint size\n            M.x = h* minLOD(T,l);               // tile min-max heights\n            M.y = h* maxLOD(T,l);\n            F = p/w(l); F.xz = fract(F.xz)*2. - 1.;\n            // forward tile intersection: compute intersection F+kD  with box [-1,1] \n            V = ( sign(D) -  F ) / D,           // see https://www.shadertoy.com/view/WldSWj\n            P0 = p +  min(V.x,V.z) *D/2. *w(l); // [ if D[i] = 0., should use V[1-i] ]\n            if( /*max(p.y,P0.y) < M.x || */ min(p.y,P0.y) > M.y )  break; // tile BB out of ray\n        }     // [ ^^ not working as long as we display columns rather than smooth heightfield ]\n        if (l<lm) break;                        // hit\n        d = length((P0-p).xz);                  // we can march out of this tile\n        d+=.5/res* length(P0-p)/d;              // eps to cross tile border\n\n        p += d*D; \n    } while (p.z<8. && p.y>0. && --i > 0 );     // until ray gets out\n    \n  //p.y = (M.x+M.y)/2.;                         // estimate average height\n  //p.y = textureLod(iChannel0,T*res/R.xy,float(l)).r * h;\n    \n  //O = vec4(float(300-i)/40.); return;         // test: show NB iterations\n  //O = fract(float(300-i)/vec4(40,20,10,1)); return;         // test: show NB iterations\n    O = vec4( l<lm ? 1.8*p.y/h : 0. );          // shade voxel\n    O = mix(vec4(0,0,1,0),O, exp(-.3*abs(p.z)));// fog\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float res = iChannelResolution[0].y,\n          lod = max(0., ceil(log2(res/R.y))); // pixel = lod % texel \n    O.r = length( texelFetch(iChannel0, ivec2(U), int(lod) ).rb ) / 1.3;\n    O.r = max(O.r,.019);              // no denormalized IEEE floats on the GPU ? or in float buffers ?\n    O.r = pow( O.r, 2.2 );            // sRGB to flat (was it necessary ?)\n    O.g = pow( O.r,-POW );            // this approximates MIN\n    O.b = pow( O.r, POW );            // this approximates MAX\n    O.a = res / exp2(lod);            // texture res at pixel lod\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define POW 10.  // the larger the better min/max, but more bigfloats precision issues\n\n#define R  iResolution\n\n#define minLOD(U,l) pow( text(U,l).g, -1./POW ) \n#define maxLOD(U,l) pow( text(U,l).b,  1./POW ) \n#define text(U,l) ( texelFetch(iChannel0, ivec2(U*r)>>l, l) * float(1<<2*l) ) //exp2(2.*float(l)) )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 193, 193, 3268]], "test": "untested"}
{"id": "tdGBDt", "name": "Smooth Minimum - gradient 2D", "author": "iq", "description": "Analytic Gradient of a quadratic smooth-minimum function. Faster than central differences. More info: [urll]https://iquilezles.org/articles/smin[/url]", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "smooth", "smoothminimum"], "likes": 9, "viewed": 2023, "published": 3, "date": "1581747241", "time_retrieved": "2024-07-30T21:23:52.798886", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient of the quadratic smooth minimum.\n// (https://iquilezles.org/articles/smin)\n//\n// Please note that the smooth-minimum is not a SDF preserving\n// operator. It's a good approximation when far enough from the\n// surfaces, but quickly distorts near them. However, the gradient\n// stays smaller than 1, which explains why it does NOT break\n// raymarchers, but just slows them down.\n//\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .yz = f(p) = {f(p)/x, f(p)/y} with f(p)<1 unfortunatelly\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n{\n    float h = 0.5 - min( abs(a.x-b.x)/(8.0*k), 0.5 );\n    float m = h*h*k;\n    return (a.x<b.x) ? vec3(a.x-m, mix(a.yz, b.yz, h) ): \n                       vec3(b.x-m, mix(b.yz, a.yz, h) );\n}\n\n// .x = f(p)\n// .yz = f(p) = {f(p)/x, f(p)/y} with f(p)=1 iff a(p)=b(p)=1\nvec3 sdgMin( in vec3 a, in vec3 b )\n{\n    return (a.x<b.x) ? a : b;\n}\n\n// .x = f(p)\n// .yz = f(p) = {f(p)/x, f(p)/y} with f(p)=1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l   : g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n// .x = f(p)\n// .yz = f(p) = {f(p)/x, f(p)/y} with f(p)=1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d,q/d);\n}\n\n\nvec3 map( in vec2 p )\n{\n    vec3 dg1 = sdgBox(p,vec2(0.8,0.3));\n    vec3 dg2 = sdgSegment( p, vec2(-1.0,-0.5), vec2(0.7,0.7) ) - vec3(0.15,0.0,0.0);\n\n // return sdgMin(dg1,dg2);\n    return sdgSMin(dg1,dg2,0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // sdf(p) and gradient(sdf(p))\n    vec3 dg = map(p);\n    float d = dg.x;\n    vec2  g = dg.yz;\n    \n    // central differenes based gradient, for validation\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    // interaction\n    if( iMouse.z>0.001 )\n    {\n        d = map(m).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBDt.jpg", "access": "api", "license": "mit", "functions": [[1648, 1745, 1795, 1795, 1987], [1989, 2105, 2142, 2142, 2174], [2176, 2258, 2295, 2295, 2556], [2558, 2640, 2692, 2692, 2860], [2863, 2863, 2886, 2886, 3076], [3078, 3078, 3135, 3135, 4019]], "test": "untested"}
{"id": "WtdXWj", "name": "Cross - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) cross. Faster than central differences or automatic differentiation/dual numbers most probably. Also it's correct in the interior, unlike the union of two boxes.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "cross"], "likes": 11, "viewed": 967, "published": 3, "date": "1581747057", "time_retrieved": "2024-07-30T21:23:53.795223", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a cross. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgCross( in vec2 p, in vec2 b ) \n{\n    vec2 s = sign(p);\n    \n    p = abs(p); \n\n\tvec2  q = ((p.y>p.x)?p.yx:p.xy) - b;\n    float h = max( q.x, q.y );\n    vec2  o = max( (h<0.0)?vec2(b.y-b.x,0.0)-q:q, 0.0 );\n    float l = length(o);\n\n    vec3  r = (h<0.0 && -q.x<l)?vec3(-q.x,1.0,0.0):vec3(l,o/l);\n   \n    return vec3( sign(h)*r.x, s*((p.y>p.x)?r.zy:r.yz) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // size\n\tvec2 si = 0.5 + 0.3*cos( iTime + vec2(0.0,1.57) + 0.0 );     if( si.x<si.y ) si=si.yx;\n    // corner radious\n    float ra = 0.0;//0.1*(0.5+0.5*sin(iTime*1.2));\n\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgCross(p,si);\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXWj.jpg", "access": "api", "license": "mit", "functions": [[1369, 1464, 1504, 1504, 1828], [1830, 1830, 1887, 1887, 2653]], "test": "untested"}
{"id": "wlcXD2", "name": "Box - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a box. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "box"], "likes": 10, "viewed": 2740, "published": 3, "date": "1581747055", "time_retrieved": "2024-07-30T21:23:54.554193", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a box. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n\n// List of other 2D distances+gradients:\n//   https://iquilezles.org/articles/distgradfunctions2d\n// and\n//   https://www.shadertoy.com/playlist/M3dSRf\n\n\n\n// Other Box functions\n// https://iquilezles.org/articles/boxfunctions\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgBox( in vec2 p, in vec2 b, float ra )\n{\n    vec2 w = abs(p)-(b-ra);\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l-ra: g-ra,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // corner radious\n    float ra = 0.3*(0.5+0.5*sin(iTime*1.7));\n    vec2  si = vec2(0.9,0.4);\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgBox(p,si,ra);\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n \n    // interaction\n    if( iMouse.z>0.001 )\n    {\n        d = sdgBox(m,si,ra).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXD2.jpg", "access": "api", "license": "mit", "functions": [[1794, 1889, 1936, 1936, 2205], [2208, 2208, 2265, 2265, 3298]], "test": "untested"}
{"id": "WtdSDj", "name": "Segment - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) segment. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "segment"], "likes": 11, "viewed": 1454, "published": 3, "date": "1581747052", "time_retrieved": "2024-07-30T21:23:55.323137", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a segment. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//   https://iquilezles.org/articles/distgradfunctions2d\n// and\n//   https://www.shadertoy.com/playlist/M3dSRf\n\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    \n    return vec3(d,q/d);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec2 v1 = 0.8*cos( 0.5*iTime*vec2(1.3,1.0) + vec2(2,4) );\n        vec2 v2 = 0.8*cos( 0.5*iTime*vec2(0.9,1.2) + vec2(1,5) );\n        float th = 0.15*(0.5+0.5*sin(iTime*1.2+2.0));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgSegment(p,v1,v2);\n        float d = dg.x - th;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdSDj.jpg", "access": "api", "license": "mit", "functions": [[1367, 1462, 1514, 1514, 1687]], "test": "untested"}
{"id": "WltSDj", "name": "Circle - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a circle. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "circle", "gradient", "distance"], "likes": 23, "viewed": 3104, "published": 3, "date": "1581747048", "time_retrieved": "2024-07-30T21:23:56.294540", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a circle.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    const float ra = 0.5;\n\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgCircle(p,ra);\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n \n    // interaction\n    if( iMouse.z>0.001 )\n    {\n        d = sdgCircle(m,ra).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSDj.jpg", "access": "api", "license": "mit", "functions": [[1282, 1377, 1419, 1419, 1475], [1478, 1478, 1535, 1535, 2492]], "test": "untested"}
{"id": "3tdSDj", "name": "Segment - distance 2D", "author": "iq", "description": "Distance to a line segment. Tutorial on how to derive the code and why it works: [url]https://www.youtube.com/watch?v=PMltMdi1Wzg[/url]. Mouse click and drag to see unbounding sphere", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "segment"], "likes": 30, "viewed": 9178, "published": 3, "date": "1581746600", "time_retrieved": "2024-07-30T21:23:57.194135", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment. Tutorial on how to derive\n//\n// the formula and code: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n   \nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n    \n\tfloat d = udSegment( p, v1, v2 ) - th;\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = udSegment(m, v1, v2) - th;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSDj.jpg", "access": "api", "license": "mit", "functions": [[1349, 1349, 1401, 1401, 1524], [1526, 1526, 1583, 1583, 2412]], "test": "untested"}
{"id": "3ttSD2", "name": "Fly quaternion city (edit)", "author": "jarble", "description": "I edited just one line of code in this shader, and found a bizarre world of iridescent surfaces.\n\nUse the mouse and arrow keys to move. The original shader is here: https://www.shadertoy.com/view/4tSyRz", "tags": ["fractal"], "likes": 14, "viewed": 778, "published": 3, "date": "1581725766", "time_retrieved": "2024-07-30T21:23:58.332094", "image_code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#define steps 100\n#define maxdistance 4.0\n#define epsilon 0.003\n\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-0.1667,0.0))+min(max(q.x,q.y)-0.1667,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(max(abs(q2.yz-vec2(0.0,0.5)),0.0))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = inside;\n    } else if (type == 1) {\n        //\n        len = -outside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        len = squarering(p.xyz-vec3(0,0,0.5));\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    }\n    \n    \n    return len;\n}\n\nfloat mapOcreeeTruchet(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    float size = 1.0;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p*exp2(i));\n    \n    int type = int(hash13((fp+exp2(-i-1.0))*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*exp2(-i);\n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p*exp2(i));\n        //check for the overlapping black dots\n        vec3 p2 = p*exp2(i);\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*exp2(-i);\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*exp2(-i),len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    //len *= size;\n    return len;\n    \n    /*vec3 q = abs(p-0.5);\n    \n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n    \n    float inside = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    if (floor(p) == vec3(0)) {\n    \tlen = -outside;\n    } else {\n        len = inside;\n    }\n    return len;*/\n    //return outside;\n\n}\n\n\n/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n\n\n//cut off half of the distance field along a plane that that the .y axis as its normal.\n#define cutY\n\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .00001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 256\n\n\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n#define doFog\n\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n\n//do specular light, fake reflectio of sunlight\n#define doSpec\n\n//max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n#define iterDfFractal 4.\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 8.\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n#define THRUST 0.02*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define sat(a) clamp(a,.0,1.)\n\n//load and save, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n//quaterion math\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n/*\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nvec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\nvec4 qslerp(vec4 q1, vec4 q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*/\n\n//hash\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n//quaterion math, just to be different\n\n//shape:\nvec3 Tile(vec3 p\n){\n ;vec3 a=vec3(8.0)\n ;//return p\n ;return abs(mod(p,a)-a*0.5)-a*0.25\n ;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n//colors\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//return signed distane of[p] to a surface.\nfloat gd(vec3 u//gradient differential, signed distance field:\n){\n ;//u.z+=1.\n // #define DareOctree  //toggle\n ;vec3 p=u \n  #ifndef DareOctree\n ;p=Tile(p)\n  #endif\n ;vec4 z=vec4(p,1)*sin(length(p)-1.0+sin(p.x+p.y)/10.0)\n ;float dG=1e3\n #ifdef DareOctree\n     //slow octree truchet (without octree traversal)\n;dG=mapOcreeeTruchet(u*.01)   //scale big to make navigable (woth collision detection scaling)\n     //https://www.shadertoy.com/view/MlcfRl\n #else    \n ;for(float n=.0;n<iterDfFractal;n++ //fractal\n ){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==2.)dG=DERect(z,rcL)\n ;}\n #endif\n //;dG=min(dG,DERect(z,rc))\n #ifdef cutY\n //;dG=max(dG,u.y);\n #endif\n ;return dG;\n ;}\n\n\n//a variant of gd(), that is HERE used to get a color and tto derive a surface normal.\n//the inout vec4 mcol is a big difference.\nfloat gd1(vec3 p,inout vec4 mcol\n){p=Tile(p)\n ;vec4 z=vec4(p,1)\n ;float dG=1e3\n ;vec4 mc=vec4(0)\n ;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n ){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n  ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n  ;z+=p0\n  ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n  ;else if(n==2.)dG=DERect(z,rcL);\n }float ds=DERect(z,rc)\n ;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n ;else mcol+=mc\n ;return min(dG,ds);}\n\nvec3 fog(float ts,vec3 spc,vec3 fcol){\n //;float fog=min(pow(ts*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n ;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n //must be reciprocal log() ?\n ;return mix(spc,fcol,fog);}\n\nfloat AO(in vec3 o,in vec3 d,float s){//origin, direction, scatterHash\n ;float t=.0,a=1.,f,n=.01+.04*s\n ;for(float i=.0;i<iterAO;i++ \n ){f=max(gd(o+d*t)*1.5,n)\n  ;a=min(a,f/t+t*0.5)\n  ;t+=f;\n }return a;}//soft shadow with \"noisy lens\".\n\n\n//return occluded specular.\nvec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 so,vec3 o,float s,vec4 mcol){\n;float l=dot(N,sunDir)//sundir must be normalized\n#ifdef doAO\n,shad=AO(so+N*.001,sunDir,s)//shadow\n#else\n,shad=.5\n#endif\n#ifdef doSpec\n;float v=dot(-d,N)\n;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n;float cd=exp(-distance(o,so))\n;vec3 R=reflect(d,N)\n;float spcl=pow(sat(dot(R,sunDir)),10.)\n,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n#endif\n;r=sat(r)\n;return r;}\n\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qmulv(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u\n){vec4 p,qrot\n ;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n }else{//next frame\n  ;p=load(0);qrot=load(1)//load state from previous frame\n  ;vec3 fw=vec3(0,0,1)\n  ;fw=qmulv(qrot,fw) //this can be done simpler\n  ;vec3 newp=p.xyz+fw*p.w*.2\n  ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n  ;else{\n   ;if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n   ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n   ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n  ;}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-iMouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 113]], "test": "untested"}
{"id": "3ttXDj", "name": "Collision detection + gravity", "author": "jarble", "description": "This is a modification of https://www.shadertoy.com/view/3ldGRX\n\nThe camera \"bounces\" on this fractal using coliision detection.", "tags": ["fractal"], "likes": 25, "viewed": 987, "published": 3, "date": "1581723936", "time_retrieved": "2024-07-30T21:23:59.290530", "image_code": "// Fork of \"Fractal terrain generator\" by michael0884. https://shadertoy.com/view/3lcGRX\n// 2019-12-22 20:51:23\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized centered pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    LOD = 0.8/max(iResolution.x,iResolution.y);\n    \n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tvec3 ray = getRay(angles, pos);\n    \n    vec4 cpos = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    vec4 dir = vec4(ray,0.);\n    \n    vec3 col = render_ray(cpos, dir, LOD);\n    \n    // Output to screen\n    fragColor = vec4(HDRmapping(col, 0.5),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(iChannel0,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(iChannel0,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(iChannel0,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(iChannel0,  ivec2(VEL_INDX,0), 0);\n\t\tvec4 speed = texelFetch(iChannel0,  ivec2(SPEED_INDX,0), 0);\n        vec4 norm = calcNormal(posit.xyz, MIN_DIST);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.0001);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n            fragColor.y *= 1.- 0.01*clamp(length(vel.xyz),0.,1.);\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(0.,0.);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = DE(fragColor.xyz + vel.xyz*speed.x) + norm.w;\n            if(DX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,11.,1.);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            \n            if(length(norm) > 1.1){\n                fragColor.y -= 0.1; //gravity\n            }\n            else{\n            \tfragColor += norm/20.0; //bounce off the ground\n            }\n            \n            //fractal collision detection, removing the normal velocity component \n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n            \n\n\n            \n            break;\n          case LIGHT_INDX:  //light\n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz = posit.xyz;\n                fragColor.w = .08;\n            }\n            if(iFrame < 1)\n            {\n                fragColor = vec4(12.5,-4,10.5, 0.1);\n            }\n            break; \n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265\n#define SQRT2 1.4142135\n#define SQRT3 1.7320508\n#define SQRT5 2.2360679\n#define FOV 2.5\n\n#define MAX_DIST 500.\n#define MIN_DIST 1e-5\n#define MAX_MARCHES 512.\n#define LIGHT_ANGLE 0.04\n\n//how much does the terrain change in large scale\n#define PERLIN_SCALE 2\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n#define N_instructions 6.\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define LIGHT_INDX 4\n#define SPEED_INDX 5\n\n//coefficients are fine-tuned\n//you can get all kinds of weird terrain by carefully setting the coefficients, \n//even forests are possible, but they may look not as realistic as the rock fractals\nconst int FRACTAL_ITER = 22;\nconst float iFracScale = 1.6467;\nconst float iFracAng1 = 2.7315;\nconst float iFracAng2 = -0.2082;\nconst vec3 iFracShift = vec3(-8.92, 3.66, 5.49);\nconst vec3 iFracCol = vec3(0.3, 0.3, -0.2);\nfloat s1 = sin(iFracAng1), c1 = cos(iFracAng1), s2 = sin(iFracAng2), c2 = cos(iFracAng2);\n\nfloat PBR_METALLIC = 0.0;\nfloat PBR_ROUGHNESS = 0.8;\n\nvec3 BACKGROUND_COLOR = vec3(0.);\nvec3 LIGHT_DIRECTION = normalize(vec3(-1.,1.,0.68));\nvec3 LIGHT_COLOR = vec3(1., 0.95, 0.8);\nbool SHADOWS_ENABLED = true; \n\nfloat gamma_material = 0.1;\nfloat gamma_sky = 0.6;\nfloat gamma_camera = 2.2;\n\nfloat LOD;\n\nfloat hash(float p)\n{\n   p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\n//normally distributed random numbers\nvec3 randn(float p)\n{\n    vec4 rand = hash41(p);\n    vec3 box_muller = sqrt(-2.*log(max(vec3(rand.x,rand.x,rand.z),1e-8)))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.w));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere(float p)\n{\n    return normalize(randn(p))*pow(hash(p+85.67),0.333333);\n}\n\nvec3 cosdistr(vec3 dir, float seed)\n{\n    vec3 rand_dir = normalize(randn(seed*SQRT2));\n    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);\n    float u = hash(seed);\n    return normalize(dir*sqrt(u) + norm_dir*sqrt(1.-u));\n}\n\n\nvec4 perlin_octave(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 a = vec2(0.,1.);\n   \n   vec4 a00 = hash42(pi+a.xx);\n   vec4 a01 = hash42(pi+a.xy);\n   vec4 a10 = hash42(pi+a.yx);\n   vec4 a11 = hash42(pi+a.yy);\n   \n   vec4 i1 = mix(a00, a01, pfc.y);\n   vec4 i2 = mix(a10, a11, pfc.y);\n   \n   return mix(i1, i2, pfc.x);  \n}\n\nmat2 rotat = mat2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5));\n\nvec4 perlin4(vec2 p)\n{\n\tfloat a = 1.;\n\tvec4 res = vec4(0.);\n\tfor(int i = 0; i < PERLIN_SCALE; i++)\n\t{\n       \n\t\tres += a*(perlin_octave(p)-0.5);\n        //inverse perlin\n         p *= 0.2*rotat;\n\t\ta *= 15.;\n\t\t\n\t}\n\treturn res;\n}\n\n/////\n/////Code from Marble Marcher Community Edition\n/////\n\n#define COL col_scene\n#define DE de_scene\n#define DEv de_scene_var\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec4 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec4 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\n\n// Polynomial smooth minimum by iq\nfloat smoothmin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\n/*void mengerFold(inout vec4 z) {\n\tfloat a = smoothmin(z.x - z.y, 0.0, 0.03);\n\tz.x -= a;\n\tz.y += a;\n\ta = smoothmin(z.x - z.z, 0.0, 0.03);\n\tz.x -= a;\n\tz.z += a;\n\ta = smoothmin(z.y - z.z, 0.0, 0.03);\n\tz.y -= a;\n\tz.z += a;\n}*/\n\nvoid mengerFold(inout vec4 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\nvoid boxFold(inout vec4 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\nvoid rotX(inout vec4 z, float s, float c) {\n\tz.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvoid rotY(inout vec4 z, float s, float c) {\n\tz.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\nvoid rotZ(inout vec4 z, float s, float c) {\n\tz.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\nvoid rotX(inout vec4 z, float a) {\n\trotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec4 z, float a) {\n\trotY(z, sin(a), cos(a));\n}\nvoid rotZ(inout vec4 z, float a) {\n\trotZ(z, sin(a), cos(a));\n}\n\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_sphere(vec4 p, float r) {\n\treturn (length(p.xyz) - r) / p.w;\n}\nfloat de_box(vec4 p, vec3 s) {\n\t\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;\n}\nfloat de_tetrahedron(vec4 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / (p.w * sqrt(3.0));\n}\nfloat de_capsule(vec4 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r) / p.w;\n}\n\n//##########################################\n//   Main DEs\n//##########################################\nfloat de_fractal(vec4 p, float error)\n{\n\tvec3 p0 = p.xyz*2.;\n   \n\tp.xz = mod(p.xz + vec2(2.*p.w), vec2(4.*p.w)) - vec2(2.*p.w); \n\tvec4 perlin1 = 0.08*perlin4(p0.xz);\n\tvec3 shift =iFracShift + perlin1.xyz;\n    \n    //estimating the number of iterations needed to have this error\n    float iter = log(length(shift)/error)/log(iFracScale)-2.;\n    float max_iter = min(float(FRACTAL_ITER)+1e-4, iter);\n    \n    vec4 prev_p;\n\tfor (float i = 0.; i < max_iter; ++i) {\n\t\tprev_p = p;\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n        if(i == 1.) shift -= perlin1.xyz;\n\t\trotX(p, s2, c2);\n\t\tp *= iFracScale*(1.);\n\t\tp.xyz += shift;\n\t}\n    \n    //interpolate between LOD's\n\tfloat de = mix(de_box(prev_p, vec3(6.0)), de_box(p, vec3(6.0)), fract(max_iter));\n    \n\treturn 0.75*de;\n}\n\nvec4 col_fractal(vec4 p) \n{\n\tvec3 p0 = p.xyz;\n\tvec3 orbit = vec3(0.0);\n\tp.xz = mod(p.xz + vec2(0.5*p.w), vec2(1.*p.w)) - vec2(0.5*p.w); \n\tvec4 perlin1 = perlin4(p0.xz);\n\tvec3 shift =iFracShift + 0.35*(perlin1.xyz - 0.5);\n\tfor (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n\t\trotX(p, s2, c2);\n\t\tp *= iFracScale*(1.);\n\t\tp.xyz += shift;\n\t\torbit = max(orbit, p.xyz*iFracCol);\n\t}\n\treturn vec4(orbit, de_box(p, vec3(6.0)));\n}\n\nfloat de_scene(vec3 pos) \n{\n\tvec4 p = vec4(pos,1.f);\n\tfloat d = de_fractal(p, MIN_DIST);\n\treturn d;\n}\n\nfloat de_scene_var(vec3 pos, float error)\n{\n    vec4 p = vec4(pos,1.f);\n\tfloat d = de_fractal(p, error);\n\treturn d;\n}\n\nvec4 col_scene(vec3 pos) \n{\n\tvec4 p = vec4(pos,1.f);\n\tvec4 col = col_fractal(p);\n\treturn vec4(min(col.xyz,1.), 0.0);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*DEv(p + k.xyy*dx, 2.*dx) +\n\t\t\t k.yyxx*DEv(p + k.yyx*dx, 2.*dx) +\n\t\t\t k.yxyx*DEv(p + k.yxy*dx, 2.*dx) +\n\t\t\t k.xxxx*DEv(p + k.xxx*dx, 2.*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid scene_material(vec3 pos, inout vec4 color, inout vec2 pbr)\n{\n\t//DE_count = DE_count+1;\n\tvec4 p = vec4(pos,1.f);\n\t\n\tcolor = col_fractal(p);\n\t\n\tpbr = vec2(PBR_METALLIC, PBR_ROUGHNESS);\n\tfloat reflection = 0.;\n\n\tcolor = vec4(min(color.xyz,1.), reflection);\n}\n\n\n#define overrelax 1.35\n\nvoid ray_march(inout vec4 p, inout vec4 ray, inout vec4 var, float angle, float max_d)\n{\n    float prev_h = 0., td = 0.;\n    float omega = overrelax;\n    float candidate_td = 1.;\n    float candidate_error = 1e8;\n    for(; ((ray.w+td) < max_d) && (var.x < MAX_MARCHES);   var.x+= 1.)\n    {\n        p.w = DEv(p.xyz + td*ray.xyz, LOD*td);\n        \n        if(prev_h*omega>max(p.w,0.)+max(prev_h,0.)) //if overtepped\n        {\n            td += (1.-omega)*prev_h; // step back to the safe distance\n            prev_h = 0.;\n            omega = (omega - 1.)*0.6 + 1.; //make the overstepping smaller\n        }\n        else\n        {\n\t\t\tif(p.w < 0.)\n\t\t\t{\n\t\t\t\tcandidate_error = 0.;\n\t\t\t\tcandidate_td = td;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n            if(p.w/td < candidate_error)\n            {\n                candidate_error = p.w/td;\n                candidate_td = td; \n\t\t\t\t\n                if(p.w < (ray.w+td)*angle) //if closer to the surface than the cone radius\n                {\n                    break;\n                }\n            }\n            \n            td += p.w*omega; //continue marching\n            \n            prev_h = p.w;        \n        }\n    }\n    \n    ray.w += candidate_td;\n\tp.xyz = p.xyz + candidate_td*ray.xyz;\n\tp.w = candidate_error*candidate_td;\n}\n\n\nvoid ray_march(inout vec4 p, inout vec4 ray, inout vec4 var, float angle)\n{\n\tray_march(p, ray, var, angle, MAX_DIST);\n}\n\n\n\n#define shadow_steps 256\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, float dist2cam)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = DE(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = DEv(pos.xyz, (dist2cam+dir.w)*LOD);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n\t\tif(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(LOD*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n#define AMBIENT_MARCHES 3\n#define AMBIENT_COLOR 2*vec4(1,1,1,1)\n\n\n///PBR functions \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n///END PBR functions\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = LIGHT_DIRECTION;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./gamma_sky)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\t//step out\n\tpos.xyz += 0.05*dir.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < AMBIENT_MARCHES; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = DEv(pos.xyz, dir.w*LOD);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= float(AMBIENT_MARCHES); // average weighted by importance\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\n\nvec3 refraction(vec3 rd, vec3 n, float p) {\n\tfloat dot_nd = dot(rd, n);\n\treturn p * (rd - dot_nd * n) + sqrt(1.0 - (p * p) * (1.0 - dot_nd * dot_nd)) * n;\n}\n\nvec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, vec3 refl, vec3 refr, float shadow) \n{\n\tvec3 albedo = color.xyz;\n\talbedo = pow(albedo,vec3(1.f/gamma_material)); //square it to make the fractals more colorfull \n\t\n\tvec4 ambient_color = ambient_occlusion(pos, norm, dir);\n\t\n\tfloat metallic = pbr.x;\n\tvec3 F0 = vec3(0.04); \n\tF0 = mix(F0, albedo, metallic);\n\t\n\t//reflectance equation\n\tvec3 Lo = vec3(0.0);\n\tvec3 V = -dir.xyz;\n\tvec3 N = norm.xyz;\n\t\n\t{ //ambient occlusion contribution\n\t\tfloat roughness = max(pbr.y,0.5);\n\t\tvec3 L = normalize(N);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = ambient_color.xyz;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\tif(!SHADOWS_ENABLED)\n\t{\n\t\tshadow = ambient_color.w;\n\t}\n\t\n\tvec3 sun_color = sky_color(LIGHT_DIRECTION);\n\n\t{ //light contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(LIGHT_DIRECTION);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = sun_color*shadow*(0.65+0.35*ambient_color.w);        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\t{ //light reflection, GI imitation\n\t\tfloat roughness = max(PBR_ROUGHNESS,0.8);\n\t\tvec3 L = normalize(-LIGHT_DIRECTION);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = 0.5*sun_color*ambient_color.w*(1.-ambient_color.w);        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\n\tif(color.w>0.5) // if metal\n\t{\n\t\tvec3 n = normalize(norm.xyz);\n\t\tvec3 q = dir.xyz - n*(2.*dot(dir.xyz,n));\n\t\n        //metal\n        vec3 F0 = vec3(0.6); \n        vec3 L = normalize(q);\n        vec3 H = normalize(V + L);\n        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);  \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        Lo += kS*refl;\n\t}\n\t\n\treturn Lo;\n}\n\nvec3 shading_simple(in vec4 pos, in vec4 dir, float fov)\n{\n\tif(pos.w < max(1.*fov*dir.w, MIN_DIST))\n\t{\n\t\t//calculate the normal\n\t\tfloat error = 0.5*fov*dir.w;\n\t\tvec4 norm = calcNormal(pos.xyz, max(MIN_DIST, error)); \n\t\tnorm.xyz = normalize(norm.xyz);\n        \n        vec4 spos = vec4(pos.xyz, pos.w);\n\t\tfloat shadow = shadow_march(spos, vec4(LIGHT_DIRECTION,0.), 5., LIGHT_ANGLE, dir.w);\n\t\tif(norm.w < -error)\n\t\t{\n\t\t\treturn COL(pos.xyz).xyz;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//optimize color sampling \n\t\t\tvec3 cpos = pos.xyz - pos.w*norm.xyz;\n\t\t\t//cpos = cpos - DE(cpos)*norm.xyz;\n\t\t\t//cpos = cpos - DE(cpos)*norm.xyz;\n\t\t\t\n\t\t\tvec4 color; vec2 pbr;\n\t\t\tscene_material(cpos, color, pbr);\n\t\t\treturn lighting(color, pbr, pos, dir, norm, vec3(0), vec3(0), shadow); \n\t\t}\n\t}\n\telse\n\t{\n\t\treturn sky_color(dir.xyz);\n\t}\n}\n\n\nvec3 render_ray(in vec4 pos, in vec4 dir, float fov)\n{\n\tvec4 var = vec4(0,0,0,1);\n\tray_march(pos, dir, var, fov); \n\treturn shading_simple(pos, dir, fov);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / gamma_camera));\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n    angles.y = - angles.y;\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   sin(angles.y),  cos(angles.y),\n                          0,  -cos(angles.y),  sin(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),  0.,  -sin(angles.x),\n        \t\t       0.,  1., 0.,\n        \t\t        sin(angles.x),              0.,           cos(angles.x)); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 170, 216, 682]], "test": "untested"}
{"id": "3ltSW2", "name": "Disk - distance 2D", "author": "iq", "description": "Distance to a disk", "tags": ["2d", "distancefield", "sdf", "circle", "distance"], "likes": 68, "viewed": 26033, "published": 3, "date": "1581721208", "time_retrieved": "2024-07-30T21:24:00.058477", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdCircle(p,0.5);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdCircle(m,0.5);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSW2.jpg", "access": "api", "license": "mit", "functions": [[1239, 1239, 1281, 1281, 1307], [1310, 1310, 1367, 1367, 2004]], "test": "untested"}
{"id": "Wl3XD2", "name": "Day 57", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 21, "viewed": 614, "published": 3, "date": "1581720076", "time_retrieved": "2024-07-30T21:24:00.834402", "image_code": "// thanks to mla and Kali!\n// They have super nice examples on inversion\n\n// it's really simple, basically\n// p /= dot(p,p);\n// p = sin(p);\n// SDFs\n// return distance*dot(p,p);\n\n\n// and ofc Inigo quilez for pallete!\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.4)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*1.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    \n    fragColor = max(fragColor, 0.);\n    //fragColor.xyz = pow(fragColor.xyz, vec3(2.,1. + sin(iTime)*0.2,1. - sin(iTime)*0.2));\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.45 + dot(uvn,uvn)*.9));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}", "buffer_a_code": "#define pi acos(-1.)\n#define lightDist 7.\nvec3 glow = vec3(0);\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat valueNoise(float i){return mix(texture(iChannel0,vec2(floor(i))/1024.),texture(iChannel0,vec2(floor(i) + 1.)/1024.),smoothstep(0.,1.,fract(i))).x; }\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec2 uCoords;\n\n#define pmod(p,x) mod(p,x) - x*0.5\n\n#define modDist 1.\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sqId;\n\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define dmax(a,b) a.x > b.x ? a : b\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    vec3 u = p;\n    u.z = mod(u.z, lightDist) - 0.5*lightDist;\n    \n    vec2 sqId = vec2(pModPolar(p.xy, 6.), floor(p.z/modDist));\n    float ri = texture(iChannel0, vec2(sqId.x*0.01, sqId.y*0.01)).x;\n    float rb = texture(iChannel0, vec2(sqId.x*0.014, sqId.y*0.015)).x;\n    //p.y += 0.4;\n    //p.xy *= rot(-0.7*pi);    \n    \n    p.z = pmod(p.z, modDist);\n    \n    //d.x = min(d.x,p.y);\n    //d.x = min(d.x,length(p) - 0.1);\n    \n    \n    #define W 0.5\n    \n    float wall = -p.x + W;\n    if(rb < 0.33){\n    \tfloat freq = 40.;\n    \tvec2 uWall = fract(p.yz*freq) - 0.5;\n    \twall -= smoothstep(0.,0.3,length(uWall))*0.004;\n    \td = dmin(d,vec2(wall, 1.));\n    } else if(rb < 0.66){\n    \tfloat freq = 10.;\n    \tvec2 uWall = fract(p.yz*freq) - 0.5;\n        \n        wall += smoothstep(0.1,1., min(length(uWall.x), length(uWall.y)))*0.01;\n    \t//wall -= smoothstep(0.,0.3,length(uWall))*0.004;\n    \td = dmin(d,vec2(wall, 5.));\n    } else {\n    \tfloat freq = 21.;\n    \tvec2 uWall = fract(p.yz*freq) - 0.5;\n        \n        //wall += smoothstep(0.,1., exp(-length(uWall.x) ))*0.03;\n        \n        wall += smoothstep(0.,1., max(exp(-length(uWall.x*20.) ), exp(-length(uWall.y*20.) )))*0.002;\n        //wall += smoothstep(0.2,1., length(uWall.x))*0.03;\n        //wall += smoothstep(0.2,1., min(length(uWall.x), length(uWall.y)))*0.03;\n    \t//wall -= smoothstep(0.,0.3,length(uWall))*0.004;\n    \td = dmin(d,vec2(wall, 6.));\n    }\n    \n    //wall -= length(uWall)*0.006;\n    \n    //wall -= sin(uWall.x + uWall.y )*0.001;\n    \n    \n    u.x = abs(u.x);\n    u.x -= 0.05;\n    u.y -= 0.5;\n    \n    //q.xz *= rot(0.25);\n    \n    vec3 l = vec3(0);\n    l.z = floor(p.z/lightDist)*lightDist ;\n    l.y += W*0.6;\n    l.z += 0.5*lightDist;\n    d = dmin( d, vec2( sdCapsule( u, vec3(0,0,0.5), vec3(0.0), 0.03 ), 4.) );\n    \n    \n    vec3 q = p;\n    \n    q = p ;\n    q.y = abs(q.y);\n    //p.y -= 0.29;\n    q.y -= W*0.6;\n    \n    d = dmin(d, vec2(length(q.xy ) - 0. , 1.));\n    \n\n    //p.xy\n    \n    q.xy -= vec2(W, 0.);\n    q.xy = abs(q.xy) - vec2(0.01,0.04);\n    \n    d = dmin(d,vec2(max(q.x,q.y ), 2. ));\n    q = p;\n    q.xy -= vec2(W, 0.);\n    q.z -= W*0.91;\n    q.zx = abs(q.zx) - vec2(0.05,0.01);\n    d = dmin(d,vec2(\n        max(\n            max(q.z,q.x ),\n            -max(q.z + 0.02,q.x - 0.002 )\n        )\n        , 2.) );\n    \n    //d.x = min(d.x,max(p.x,p.y ) + 0.001 );\n    \n    \n    \n    p.z -= modDist*0.5;\n    p.x -= 0.5;\n    //d = dmin(d,vec2(length(p) - 0.02, 2.) );\n    \n    float bW = 0.3;\n    p.z += bW*1.75;\n    vec2 dB = dmax(\n        vec2(sdRoundBox( p, vec3(0.01,0.1,bW), 0.001 ), 2.),\n        vec2(-sdRoundBox( p + vec3(0.02,0,0), vec3(0.01,0.1*0.8,bW*0.8), 0.004 ), 3.)\n    \t);\n\n    \n    if(ri > 0.8){\n    \td = dmin(d,dB );\n    \n    }\n        \n    if(sqId.x == 1.){\n        //p.y\n    \t\n    \t//d = dmin(d,vec2(length(p) - 0.22, 2.) );\n    \t//d = dmin(d,vec2(max(p.z,p.x ) - 0.1, 2.) );\n    }\n    \n    //d = dmin(d,vec2(length(p) - 0.02, 2.) );\n    uCoords = p.yz;\n    //d.x *= 0.1;\n    return d;\n}\n\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n    return normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n    \n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p,inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n    p = ro; t = 0.; hit = false;\n    for (int i = 0; i < 250; i++){\n    \td = map(p);\n        if(d.y == 4.)\n    \t\tglow += exp(-d.x*10.);\n        if (d.x < 0.001){\n            hit = true;\n        \tbreak;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\treturn d;\n}\n#define mx (iTime*0.7 + 20.*iMouse.x/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv, uv)*0.05;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    \n    vec3 rd = normalize(vec3(uv, 1.9));\n    \n    rd.xy *= rot(sin(iTime*0.2)*0.1);\n    rd.yz *= rot(sin(-iTime*0.2)*0.02);\n    \n    bool hit; float t; vec3 p ; ro;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    float lightNoise;\n    if(hit){\n        vec3 l = vec3(0);\n        float lid = floor(p.z/lightDist);\n        l.z = lid*lightDist ;\n        l.y += W*0.6;\n        l.z += 0.5*lightDist;\n    \tvec3 n = getNormal(p);\n    \t//col += n*0.7;\n        vec3 albedo;\n        if(d.y == 1.){\n        \talbedo = vec3(1);\n        }\n    \tvec3 h = normalize(l - rd);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        \n        vec3 lightCol = vec3(1.,1.,1.);\n\n        vec3 L = normalize(l - p);\n        vec3 H = normalize(L - rd);\n\n\n        int id = int(d.y);\n        float METALNESS = 0.1;\n        float ROUGHNESS = 0.5;\n        \n        \n        vec3 F0 = vec3(0.03); \n        if(d.y == 2.){\n        \talbedo = vec3(0.02);\n        } else if (d.y == 1.){\n        \talbedo = vec3(1.);\n        }else if (d.y == 4.){\n        \tcol = vec3(1.);\n        } else if (d.y == 3.){\n            \n            uCoords.x += sin(uCoords.y*200. + iTime);\n        \tcol += mix(\n                texture(iChannel0, uCoords*0.4).x,\n                texture(iChannel0, uCoords*0.4).x,0.1\n            \n            );\n            col = 1. - col;\n        }else if (d.y == 5.){\n        \tF0 = vec3(0.63); \n        \talbedo = vec3(0.1);\n        \t//col = vec3(1.);\n        }else if (d.y == 6.){\n        \tMETALNESS = 0.9;\n        \tROUGHNESS = 0.9;\n        \talbedo = vec3(1.);\n        \t//col = vec3(1.);\n        }\n        //albedo = vec3(1);\n        vec3 N = getNormal(p);\n        vec3 V = normalize(ro - p);\n        //vec3 V = -rd;\n\n        F0 = mix(F0, albedo, METALNESS);\n\n        // calculate per-light radiance\n        float distL    = length(l - p)*1.;\n        float attenuation = 1. / (distL * distL);\n        //float attenuation = dist*0.02;\n        //attenuation = 1.;\n        vec3 radiance     = lightCol * attenuation;        \n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, ROUGHNESS);   \n        float G   = GeometrySmith(N, V, L, ROUGHNESS);      \n        vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - METALNESS;\t  \n\n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0); \n        \n        lightNoise = valueNoise(iTime*200.)*0.9*(mod(lid, 2.)- 1.)*abs(sin(iTime));\n        attenuation -= lightNoise;\n        \n\t\t//attenuation += valueNoise(iTime);\n        col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation; \n        \n\t\t\n\n        //col.xz += mod(uCoords, 0.29);\n    } else {\n    \n    }\n    \n    col += glow * (0.05 - lightNoise*2.);\n    \n    col *= 1. -  smoothstep(0.,1., t*0.03);\n    \n    //col += glow*0.02*smoothstep(0.,1.,t*4.1);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3XD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 276, 276, 1515]], "test": "untested"}
{"id": "WldSWj", "name": "clamp ray to box", "author": "FabriceNeyret2", "description": "draw ray Red-Green by dragging the mouse.\ndraw ray Pink-Cyan clamped to box", "tags": ["tuto", "clamp", "short"], "likes": 7, "viewed": 345, "published": 3, "date": "1581713266", "time_retrieved": "2024-07-30T21:24:01.768903", "image_code": "#define S(v) smoothstep( s*1.5/R.y, 0., v ) // for antialiasing\n\nfloat line(vec2 p, vec2 a,vec2 b) { // draw line. https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O-=O;\n    float s = 3.;                                    // number of grid rows\n    vec2 R = iResolution.xy, V, P0,P1,\n         U = s*u/R.y,\n        M0 = iMouse.z > 0. ? s*iMouse.zw/R.y : s* .5*R/R.y, \n         M = iMouse.z > 0. ? s*iMouse.xy/R.y : s*(.5+.4*cos(iTime+vec2(0,11))),\n        F0 = fract(M0)*2. - 1.,                      // mouse0 cell local coords\n         D = normalize(M-M0);                        // ray direction\n    \n    O.ra += S( length(M0-U) -.07 );                  // draw mouse from, to\n    O.ga += S( length(M -U) -.07 );                  // ( 2 dots + line )\n    if (M0.x>0.) O += (1.-O.a)* S( line(U,M0,M) );   // NB: lines blended behind dots\n    \n    // compute intersection M0+s.kD  with box [-1,1]  (s = + or - )\n#define box(s) (  V = ( sign(D) - s F0 ) / D,  \\\n                  M0 + s min(V.x,V.y) *D/2.    )\n                 // NB: if D[i] = 0., should use V[1-i]\n    P0 = box(+);                                     // forward box intersection\n    P1 = box(-);                                     // backward box intersection\n    O.bga += S( length(P0-U) -.04 ),\n    O.bra += S( length(P1-U) -.04 ),                 // draw ( 2 dots + line )\n    O.b   += (1.-O.a)* S( line(U,P0,P1) -.015 );\n\n    V = S(abs(fract(U+.5)-.5));                      // draw grid\n    O += (1.-O.a)* .5* max(V.x,V.y);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 100, 152, 323]], "test": "untested"}
{"id": "tl3XDj", "name": "Four Black Squares", "author": "lsdlive", "description": "A motion design exercice I tried to solve with shaders and simple cue/easing.\nhttp://www.movecraft.com/wnm205-module-02/\n\nEach animation is 2 seconds long and tries to describe these 5 words:\n1. Bold\n2. Playful\n3. Nervous\n4. Witful\n5. Ordered", "tags": ["2d", "motion", "design", "easing"], "likes": 8, "viewed": 410, "published": 3, "date": "1581697083", "time_retrieved": "2024-07-30T21:24:02.554802", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nFour Black Squares.\n\nA motion design exercice I tried to solve with shaders and simple cue/easing.\nhttp://www.movecraft.com/wnm205-module-02/\n\nEach animation is 2 seconds long and tries to describe these 5 words:\n1. Bold\n2. Playful\n3. Nervous\n4. Witful\n5. Ordered\n\n\nWith the help of:\nhttps://thebookofshaders.com/examples/?chapter=motionToolKit\n\n*/\n\n#define AA 3.\n\n#define pi 3.141592\n#define time iTime\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\nfloat rect(vec2 p, vec2 size) {\n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0., 1.);\n}\n\nfloat tri(float x) {\n    return abs(mod((x + .5) * 2., 2.) - 1.);\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064320\nfloat easeInOutExpo(float t) {\n    if (t == 0. || t == 1.) {\n        return t;\n    }\n    if ((t *= 2.) < 1.) {\n        return .5 * exp2(10. * (t - 1.));\n    } else {\n        return .5 * (-exp2(-10. * (t - 1.)) + 2.);\n    }\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t * t;\n    } else {\n        return .5 * ((t -= 2.) * t * t + 2.);\n    }\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\nfloat easeInExpo(float t) {\n    return (t == 0.) ? 0. : pow(2., 10. * (t - 1.));\n}\n\nfloat bold(vec2 uv) {\n    uv *= 1.3;\n    float t1 = linearstep(.5, 1., fract(time*.5));\n    float t2 = linearstep(0., .8, fract(time*.5));\n    t2 = easeInExpo(t2);\n    t1 = easeInOutExpo(t1);\n    \n    // alternative\n    /*\n    float s1 = mix(.1, .3, t1);\n    float offs = mix(.2, .4, t1);//.2\n    float alpha = mix(.5, 1., t1);\n    float mask = fill(rect(uv+vec2(0, .2), vec2(s1))) * alpha;\n    mask += fill(rect(uv+vec2(offs, .2), vec2(.1)));\n    mask += fill(rect(uv-vec2(0, -.2 + offs), vec2(.1)));\n    mask += fill(rect(uv-vec2(offs, -.2), vec2(.1)));\n\t*/\n    \n    float s1 = mix(.05, .3, t1);\n    float offs = mix(.7, .42, t2);//.2\n    float alpha = mix(.5, 1., t1);\n    float mask = fill(rect(uv+vec2(0, .2), vec2(s1))) * alpha;\n    mask += fill(rect(uv+vec2(offs, .2), vec2(.12)));\n    mask += fill(rect(uv-vec2(0, -.2 + offs), vec2(.12)));\n    mask += fill(rect(uv-vec2(offs, -.2), vec2(.12)));\n    \n    return mask;\n}\n\nfloat playful(vec2 uv) {\n    float t1 = fract(time);\n    //t1 = easeInOutQuad(t1);\n    \n    float alpha = mix(.5, .8, tri(t1));;\n    \n    vec2 south = vec2(0, .3);\n    vec2 east = vec2(.3, 0);\n    vec2 north = vec2(0, -.3);\n    vec2 west = vec2(-.3, 0);\n    \n    \n    vec2 pos1 = mix(south, east, t1);\n    vec2 pos2 = mix(east, north, t1);\n    vec2 pos3 = mix(north, west, t1);\n    vec2 pos4 = mix(west, south, t1);\n    \n    float mask = fill(rect((uv-pos1)*r2d(t1*pi), vec2(.1))) * alpha;\n    mask += fill(rect((uv-pos2)*r2d(-t1*pi), vec2(.1))) * alpha;\n    mask += fill(rect((uv-pos3)*r2d(t1*pi), vec2(.1))) * alpha;\n    mask += fill(rect((uv-pos4)*r2d(-t1*pi), vec2(.1))) * alpha;\n    \n    return mask;\n}\n\nfloat nervous(vec2 uv) {\n    float t1 = fract(time*.5);\n    t1 = easeInOutQuad((t1));\n    \n    float offs = mix(.5, .25, t1);\n    float alpha = .5;\n    float shake = sin(time*30.*pi)*.01;\n    float mask = fill(rect(uv+vec2(shake, .2), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(offs, .2), vec2(.12)));\n    mask += fill(rect(uv-vec2(0, -.2 + offs), vec2(.12)));\n    mask += fill(rect(uv-vec2(offs, -.2), vec2(.12)));\n    \n    return mask;\n}\n\nfloat wistful(vec2 uv) {\n    float t1 = fract(time*.5);\n    t1 = easeInOutQuad(t1);\n    \n    float dx = mix(0., .3, t1);\n    \n    float alpha = mix(1., 0., t1);\n    float mask = 0.;\n    mask += fill(rect(uv+vec2(dx, -.37), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(-dx, -.12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(dx, .12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(-dx, .37), vec2(.1))) * alpha;\n    return mask;\n}\n\nfloat ordered(vec2 uv) {\n    float t1 = fract(time);\n    t1 = easeInOutExpo(t1);\n    \n    if(fract(time*.5) < .5)\n    \tuv.x += mix(.4, 0., t1);\n    else\n    \tuv.x += mix(0., -.4, t1);\n    \n    float alpha = 1.;//mix(1., 0., t1);\n    float mask = 0.;\n    mask += fill(rect(uv+vec2(0, -.37), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(0, -.12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(0, .12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(0, .37), vec2(.1))) * alpha;\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float t1 = fract(time*.1);\n    float mask = 0.;\n    if(t1 < 2./10.)\n        mask = bold(uv);\n    else if(t1 < 4./10.)\n        mask = playful(uv);\n\telse if(t1 < 6./10.)\n        mask = nervous(uv);\n    else if(t1 < 8./10.)\n        mask = wistful(uv);\n\telse\n        mask = ordered(uv);\n        \n\t\n    //mask = bold(uv);\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, 1. - mask);\n    \n    col += .05 * texture(iChannel0, uv).r * texture(iChannel1, uv).r;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XDj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[556, 556, 575, 575, 641], [643, 643, 664, 664, 721], [723, 723, 754, 754, 836], [838, 838, 889, 889, 946], [948, 948, 968, 968, 1015], [1017, 1075, 1105, 1105, 1299], [1301, 1301, 1331, 1331, 1454], [1456, 1456, 1487, 1487, 1611], [1613, 1613, 1641, 1641, 1674], [1676, 1676, 1703, 1703, 1723], [1725, 1725, 1752, 1752, 1807], [1809, 1809, 1830, 1830, 2735], [2737, 2737, 2761, 2761, 3444], [3446, 3446, 3470, 3470, 3892], [3894, 3894, 3918, 3918, 4338], [4340, 4340, 4364, 4364, 4846], [4848, 4848, 4905, 4905, 5484]], "test": "untested"}
{"id": "wt3SWj", "name": "shader_02", "author": "monodnb", "description": "i want it bw", "tags": ["cineshader"], "likes": 11, "viewed": 26706, "published": 3, "date": "1581685910", "time_retrieved": "2024-07-30T21:24:03.551138", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.876 + 1.284*(d2-d1)/k, 0.112, 2.616 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 0.480;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 1.073) - 1.020) * 1.152;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.024\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 0.368) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 0.0 );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"shader2\",\n\t\"description\": \"sure\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 160], [162, 162, 197, 197, 221], [224, 224, 243, 243, 587], [589, 589, 619, 619, 901], [903, 903, 960, 960, 1659]], "test": "untested"}
{"id": "tlcSzs", "name": "Photoreal Clouds", "author": "TekF", "description": "Idea for rendering light scattered through gas: rather than having a separate bounce loop, the marcher randomly changes directions (with a probability proportional to the gas density), to trace radiosity bounces between gasses of different densities.", "tags": ["scatter"], "likes": 165, "viewed": 7239, "published": 3, "date": "1581685832", "time_retrieved": "2024-07-30T21:24:04.718019", "image_code": "// Tone Mapping by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\nconst float exposure = .75;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.5);\nconst vec3 blackClip = vec3(.0,.1,.2);\nconst vec3 blackSoftness = vec3(.65,.5,.35);\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n    col *= exposure;\n\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord /= vec2(RESOLUTION_REDUCTION);\n    // smooth out the transition between pixels\n//    fragCoord -= 1.*sin(fragCoord*6.283185)/6.283185;\n    fragColour = SampleTextureCatmullRom4Samples(iChannel0,fragCoord/iResolution.xy,iResolution.xy);\n#else    \n    ivec2 ifragCoord = ivec2(fragCoord);\n    fragColour = texelFetch(iChannel0,ifragCoord,0);\n\n#ifdef MOSAIC_PREVIEW\n    const float targetCount = 1536.;\n    if ( fragColour.a < targetCount )\n    {\n        // blend a square big enough to hit targetCount\n        int kernelSize = int(ceil(sqrt(targetCount/fragColour.a)));\n        const int maxKernel = 16;\n        kernelSize = min(kernelSize,maxKernel);\n        ivec2 blockuv = (ifragCoord/kernelSize)*kernelSize;\n        for ( int i=0; i < maxKernel; i++ )\n        {\n            if ( i > kernelSize ) break;\n            for ( int j=0; j < maxKernel; j++ )\n            {\n                if ( j > kernelSize ) break;\n                fragColour += texelFetch(iChannel0,blockuv+ivec2(i,j),0);\n            }\n        }\n    }\n#endif\n#endif\n    fragColour /= fragColour.a;\n \n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n    \n#ifdef SHOW_CURVE\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 f = HDRtoLDR(vec3( uv.x*3. ));\n    f = SRGBToLinear(f); // show curve without gamma correction (comment this out to see actual HDR->colour value mapping)\n    f -= (uv.y*1.04-.02);\n    fragColour.rgb = SRGBToLinear(fragColour.rgb);\n    fragColour.rgb = mix( vec3(1), fragColour.rgb, smoothstep( 0., 1.4, abs(f)/max(dFdx(f),vec3(1)/iResolution.y) ) );\n    fragColour.rgb = LinearToSRGB(fragColour.rgb);\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Photoreal Clouds by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// scene parameters\nconst float cloudiness = .6;\n\nconst vec3 groundColour = vec3(.1,.15,.05); // grassy\n//const vec3 groundColour = vec3(.1); // dark grey (looks a bit brown because of tone mapping)\n//const vec3 groundColour = vec3(1); // snow\n\nconst vec3 lightDirection = normalize(vec3(1,2,3));\nconst vec3 lightColour = vec3(3);\n\n\n// control the ray marcher\nconst float minStepLength = .15;\nfloat stepLength = minStepLength;\nconst float shadowDrawDistance = 8.;\n\nconst float directLightProportion = 1./6.; // proportion of scattered rays used to sample direct light (balance graininess of god rays vs graininess of radiosity)\n//^ this shouldn't be affecting radiosity brightness, but it is! Bah!\n\nstruct ScatterData\n{\n\tfloat scatter; // proportion of rays scattered per metre - must be less than 1.0\n\tvec3 tint; // what proportion of RGB light remains after 1m - must be more than 0.0 - applies independent of scatter, so if this is 1,1,1 we still have reduction in visibility caused by scatter\n    vec3 emission; // amount of light added per 1m - should work for values > 1 but I'm not sure\n\tvec3 scatterTint; // particles can have one colour when light bounces off them and a different colour when light is absorbed by them - this can be [0,1]\n    float eccentricity; // bias the direction of scattering toward/away from (+ve/-ve) incident light direction\n};\n\nScatterData Mix( ScatterData a, ScatterData b, float c )\n{\n\t// this isn't perfect - interpolated media can have values that look different either of the two being blended\n    // e.g. this can cause a halo around very dense objects when they interpolate to the colour of the sky\n    // to reduce this effect, premultiply by scatter, to prioritise the parameters of the denser media\n    ScatterData m = \n        ScatterData(\n            mix( a.scatter, b.scatter, c ),\n            mix( a.tint*a.scatter, b.tint*b.scatter, c ),\n            mix( a.emission*a.scatter, b.emission*b.scatter, c ),\n            mix( a.scatterTint*a.scatter, b.scatterTint*b.scatter, c ),\n            mix( a.eccentricity*a.scatter, b.eccentricity*b.scatter, c )\n        );\n    return\n        ScatterData(\n            m.scatter,\n            m.tint/m.scatter,\n            m.emission/m.scatter,\n            m.scatterTint/m.scatter,\n            m.eccentricity/m.scatter\n        );\n}\n\n\n// signed distance field (SDF) for a torus\n// returned value is distance of pos from the surface (negative if inside)\nfloat Torus( vec3 position, vec3 axis, float majorRadius, float minorRadius )\n{\n    axis = normalize(axis);\n    float perp = dot(axis,position);\n    position -= perp*axis;\n    return length( vec2( perp, length(position) - majorRadius ) ) - minorRadius;\n}\n\n    \nScatterData SampleMedia( vec3 pos )\n{\n    ScatterData air = ScatterData( .03, vec3(1,.996,.99), vec3(0), vec3(.6,.8,1), .3 );\n\n    // a curve through 0, steeper on the underside of clouds so they have flat bottoms\n\tfloat cloudSDF = pos.y*pos.y/mix(1.,12.,step(0.,pos.y));\n    \n\t// columns of cloud (shadow draw distance is too short to catch shadows from these, but they look cool despite this)\n\t//cloudSDF = min(cloudSDF,(length((fract((pos.xz-vec2(0,-2))/12.+.5)-.5)*12.)-3.)*.5);\n    \n    // add layers of noise to the clouds\n    vec3 cloudNoisePos = pos;\n#ifdef ANIMATE\n    cloudNoisePos += iTime*vec3(0,.01,.06);\n#endif\n    cloudSDF += 1.5*Noise(cloudNoisePos/3.+9.); // lowest frequency defines the boundaries of the clouds\n    cloudSDF += .7*(Noise(cloudNoisePos*2.)-.5) + .25*(Noise(cloudNoisePos*6.)-.5) + .16*(Noise(cloudNoisePos*18.)-.5); // higher freqs make the edges lumpy\n    cloudSDF -= cloudiness; // offset the SDF to give more/less cloud coverage\n    \n    ScatterData cloud = ScatterData( .99, vec3(1), vec3(0), vec3(1), .3 /* directionality of scatter - silver lining vs reflected light */ );\n\n    // ground is a very dense gas\n\tfloat groundSDF = pos.y+4.+1.*(Noise(pos/3.+1.)-.5);\n    ScatterData ground = ScatterData( 1., vec3(1), vec3(0), groundColour, .0 );\n    \n    // \"solid\" test objects\n    float objSDF = length(pos-vec3(0,-2,0)) - 2.;\n//    objSDF = min(objSDF,length(pos-vec3(0,2,-3)) - 2.); // 2nd ball in the sky\n    objSDF = min( objSDF, Torus(pos-vec3(4,1.5,-9),vec3(.1,1,.2),12.,1.) ); // giant torus in the sky\n//    objSDF += (Noise(pos*1.4)-.5)*.2; // bumpy surface\n//    objSDF += sin(Noise(pos*1.3)*20.)*.1; // ripply surface\n//    objSDF = max(objSDF,(Noise(pos*3.5)-.65)*10.); // random holes/dents\n//    objSDF *= exp2(-8.*smoothstep(.3,.7,Noise(pos*.4))); // soften the edge of the object in random places\n\n    ScatterData obj = ScatterData( 1., vec3(1), vec3(0), vec3(.4,.19,.13), .0 ); // brown\n\n    return\n        Mix(Mix(Mix(\n            air,\n            cloud,\n            smoothstep( 1., -1., cloudSDF/.1 ) ),\n            obj,\n            smoothstep( 1., -1., objSDF/.01 ) ),\n            ground,\n            smoothstep( 1., -1., groundSDF/.01 )\n        );\n}\n\nconst float tau = 6.283185;\n\nvec3 SphereMap( vec2 uv )\n{\n    // uv is in the range [0,1)\n    // map this range onto a unit sphere, with a uniform distribution of points\n    \n    // use the fact that the surface area of a slice of a sphere is the same\n    // as the surface area of a cylinder with the height of the slice and the\n    // radius of the sphere\n    \n    // wrap the 2D space around a cylinder\n    float h = uv.y*2.-1.; // height up cylinder\n    float a = uv.x*tau; // angle around the circle\n    \n    // position on the circular slice of the cylinder at this height\n    vec2 v = vec2(sin(a),cos(a));\n    \n    // project onto the corresponding slice of the sphere\n    // by multiplying by width of sphere at this height\n    v = v * sqrt(1.-h*h);\n    \n    return vec3(v,h);\n}\n\n/* obsfuscated version:\nvec3 SphereMap( vec2 uv )\n{\n    return vec3( sin((uv.xx+vec2(0,.25))*6.283185)*2.*sqrt(uv.y*(1.-uv.y)), uv.y*2.-1. );\n}*/\n\n                 \nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 pixelIndex = ivec2(fragCoord);\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord *= vec2(RESOLUTION_REDUCTION);\n    if ( fragCoord.x > iResolution.x || fragCoord.y > iResolution.y )\n    {\n        fragColour = vec4(.5,.5,.5,1);\n        return;\n    }\n#endif\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // slightly ugly hack: remap the range of mouse movements to give better camera control without re-adjusting all the magic numbers below.\n    mouse.y = pow(mouse.y,.5)*.6+.1;\n    mouse.x = mouse.x*1.3;\n    \n    if ( iMouse.x < 1. && iMouse.y < 1. )\n        mouse = vec2(.845,.608);\n    \n    vec2 camAngle = (mouse-.5)*6.283185*vec2(1.,-.4999);\n\n#ifdef ANIMATE\n    camAngle.x+=iTime*.05;\n#endif\n    \n    float mouseH = .608 - mouse.y; // make high camera positions frame the whole torus\n    \n    vec3 camTarget = vec3(-1.5,-1.,0) + vec3(5.5,2.5,-9)*1.6*mouseH;\n    float camDistance = 10.;\n    float camZoom = 1.1;\n\n\tcamDistance *= exp2(3.*mouseH); // move camera in/out\n    \n    vec3 camPos = camDistance*vec3(-vec2(sin(camAngle.x),cos(camAngle.x))*cos(camAngle.y),sin(camAngle.y)).xzy;\n    vec3 camK = normalize( camTarget-camPos );\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n\n    const int maxPasses = 100;\n    \n    int sampleCountMul = sampleCountMultiplier;\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    sampleCountMul *= (RESOLUTION_REDUCTION*RESOLUTION_REDUCTION);\n    sampleCountMul = (sampleCountMul*7)/8; // not sure why but without this res reduction always slows it down\n#endif        \n\n    // there's a bug here where it's making things translucent if it's > 1!?\n    int numPasses = 1;//max(1,sampleCountMul*(320*180)/int(iResolution.x*iResolution.y));\n\n    fragColour = vec4(0);\n    for ( int pass=0; pass < maxPasses; pass++ )\n    {\n        if ( pass >= numPasses ) break;\n\n        SeedRand( iFrame*numPasses+pass, fragCoord );\n\n        vec2 jitter = vec2(rand2())-.5;\n        vec3 ray = normalize( vec3( (fragCoord+jitter-iResolution.xy*.5)/iResolution.y, camZoom ) );\n\n        ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n\n        // First, march through space, allowing the ray to be deflected randomly by scatter\n        vec3 pos = camPos;\n        pos += ray * rand() * stepLength; // randomize initial step to hide aliasing errors (doesn't fix them, but hides them really well)\n        float lastH = stepLength;\n        vec3 lastTint = SampleMedia(pos).tint;\n        vec3 tint = vec3(1);\n        vec3 emission = vec3(0);\n\t\tbool lightRay = false;\n\t    int bounceCount = 0;\n        float t = 0.;\n        for ( int i=0; i < 150; i++ )\n        {\n            //if ( max(max(tint.r,tint.g),tint.b) <= .01 ) break; // early out when rays have almost no effect - this doesn't seem to improve performance\n            \n            // step through media [step size modified by probability]\n            ScatterData scatter = SampleMedia(pos);\n\n            float h = stepLength*(1. + .9*(rand()*2.-1.)); // adjust steps randomly to hide aliasing errors\n\n            // experimenting with variable step size\n            // at the moment it just increases with distance, so rays can travel further but become less accurate\n\t\t\t// I could do this adaptively, but that's more complicated\n\t\t\tstepLength *= 1.01;\n\n            // accumulate average tint\n            tint *= pow(mix(scatter.tint,lastTint,.5),vec3(lastH));\n\n            float pointH = mix(lastH,h,.5); // length of step represented by this scatter sample        \n\n            // accumulate emission with current tint applied        \n            emission += tint*(scatter.emission * pointH);  // pretty sure emission should be multiplied not pow'd, so it's additive not exponential\n\n            if ( pow(1.-scatter.scatter, pointH) < rand() )// [modified by average of last/next step size]\n            {\n                if ( rand() < directLightProportion ) // proportion of rays which become direct light rays\n                {\n                \t// direct light\n                    // apply the scatter tint and point the ray at the light\n\n                    // correct brightness by proportion of rays not scattered this way\n                    tint /= directLightProportion;\n\t                tint *= scatter.scatterTint;\n\n                    // apply a curve for eccentricity\n                    // this uses the derivative of the curve used for the random scatter\n                    // we want to say \"how much light is scattered in this direction\" rather than \"what direction should this light be scattered in\"\n                    float cos0 = dot(ray,lightDirection);\n                    float ae = abs(scatter.eccentricity);\n                    \n                    float se = (scatter.eccentricity<0.)?-1.:1.; // sign(eccentricity) but without 0.0\n\t\t\t\t\t//float cos1 = (pow(cos0*se*.5+.5,1.-ae)*2.-1.)*se;\n\t\t\t\t\t// dcos1/dcos0 (computed by wolframalpha.con)\n                    float dcos1dcos0 = (1. - ae)*pow( max(.00000001,0.5 - se*0.5*cos0), -ae );\n\n                    // hack to reduce speckly artefacts caused by lighting amplified by multiple bounces\n                    // these speckles are technically correct, but they occur as a result of highly unlikely combinations of bounces\n                    // so it will take a very long time for them to average out\n\t\t\t\t\tif ( bounceCount > 0 ) dcos1dcos0 = clamp(dcos1dcos0,0.,10.);\n                    \n                    tint *= dcos1dcos0;\n\n                    // break out of this loop so we can do a separate shadow-tracing loop which doesn't scatter\n\t\t            ray = lightDirection;\n                    lightRay = true;\n                    break;\n                }\n                else\n                {\n                    vec3 newRay = SphereMap( vec2(rand2()) );\n\n                    // eccentricity - push & scale the sphere along the view ray to bias rays in same/opposite direction\n                    // amount of push such that at -1 or 1 the near side of the spheroid hits 0 and the far side hits infinity\n                    float cos0 = dot(newRay,ray);\n\n                    // Apply a curve to the distribution of rays.\n                    // This isn't ideal, it tends to create a sharp bright spot around the light rather than a softer blob\n                    // but it has the advantage that it reduces to 1-dimension which makes it easier to compute the derivative, \n                    // which is needed for direct light.\n                    // We can do this in 1D because a slice through the surface of a sphere has the same area for a given\n                    // thickness of slice, regardless of where the slice is positioned. (napkin ring problem)\n                    float ae = 1.-abs(scatter.eccentricity);\n                    float se = (scatter.eccentricity<0.)?-1.:1.;\n                    float cos1 = (pow(cos0*se*.5+.5,ae*ae)*2.-1.)*se;\n                    newRay = normalize(newRay - cos0*ray);\n                    newRay = ray*cos1 + newRay*sqrt(1.-cos1*cos1);\n                    ray = newRay;\n\n                    // correct brightness by proportion of rays not scattered this way\n                    // to conserve energy (this seems to have a bug, as the image changes significantly when I change directLightProportion)\n                    tint /= 1.-directLightProportion;\n\n                    // break energy conservation to prevent speckles caused by rare multiply scattered rays\n                    // technically they are correct, but they're so rare the speckles they cause are unlikely\n                    // to ever be corrected.\n                    // reduce this amount for faster convergence but less radiosity\n\t\t\t\t\ttint = clamp(tint,0.,5.);\n                    \n                    tint *= scatter.scatterTint;\n                }\n                \n                bounceCount++;\n            }\n\n            pos += ray*h;\n            t += h;\n            lastH = h;\n            lastTint = scatter.tint;\n        }\n                \n        \n        if ( lightRay )\n        {\n            // haven't balanced this for variable step size, so use a const step\n\t\t\tconst float shadowStepLength = minStepLength*1.;\n            \n            vec3 lastAbsorption;\n            float shadowT = 0.;\n            for ( int i=0; i < int(shadowDrawDistance/shadowStepLength); i++ )\n            {\n                // step through media [step size modified by probability]\n                ScatterData scatter = SampleMedia(pos);\n\n                float h = shadowStepLength; // todo: port the random stuff here too, and change the loop the same way\n                \n                // accumulate average tint\n               \t// don't scatter, just count the proportion of scattered rays as a darkening tint\n                vec3 absorption = scatter.tint*(1.-scatter.scatter);\n                if ( i > 0 )\n                {\n                \ttint *= pow(mix(absorption,lastAbsorption,.5),vec3(lastH));\n                }\n\n                pos += ray*h;\n                shadowT += h;\n                lastH = h;\n                lastAbsorption = absorption;\n            }\n            \n            emission += lightColour*tint;\n        }\n        fragColour.rgb += emission;\n\n        fragColour.a += 1.;\n    }\n    \n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    // precompute checkerboard of negative/positive values\n    // required by SampleTextureCatmullRom4Samples\n    fragColour = (pixelIndex.x&1)==(pixelIndex.y&1) ? fragColour : -fragColour;\n#endif\n    \n    if ( iFrame > 0 && iMouse.z <= 0. )\n    {\n        fragColour += texelFetch(iChannel0,pixelIndex,0)\n#ifdef ANIMATE\n            *.97\n#endif\n            ;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// quality adjustments - to improve fps\nconst int sampleCountMultiplier = 11; // increase this until fps drops\n#define MOSAIC_PREVIEW 1\n//#define RESOLUTION_REDUCTION 2\n\n//#define ANIMATE 1\n\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n// sequential rand functions - return a different value each time\nuint seed = 1u;\n\nvoid SeedRand( int frame, vec2 fragCoord )\n{\n    seed = coord3(uvec3(frame,fragCoord));\n}\nfloat rand() { return hash1(coord1(seed++)); }\nvec2 rand2() { return hash2(coord1(seed++)); }\nvec3 rand3() { return hash3(coord1(seed++)); }\nvec4 rand4() { return hash4(coord1(seed++)); }\n\n\n// continuous noise\n// cheaper and uglier than perlin\nfloat Noise( vec3 pos )\n{\n    uvec3 p = uvec3(ivec3(floor(pos))+0x8000000);\n    vec3 f = smoothstep(.0,1.,fract(pos));\n    uvec2 d = uvec2(0,1);\n    \n    return\n        mix(\n        \tmix(\n                mix( hash1(coord3(p+d.xxx)), hash1(coord3(p+d.yxx)), f.x ),\n                mix( hash1(coord3(p+d.xyx)), hash1(coord3(p+d.yyx)), f.x ),\n                f.y\n            ),\n        \tmix(\n                mix( hash1(coord3(p+d.xxy)), hash1(coord3(p+d.yxy)), f.x ),\n                mix( hash1(coord3(p+d.xyy)), hash1(coord3(p+d.yyy)), f.x ),\n                f.y\n            ),\n            f.z\n        );\n}\n\n\n// catmull-rom texture sampler, from https://www.shadertoy.com/view/4tyGDD by Giliam de Carpentier\nvec4 SampleTextureBilinearlyAndUnpack(sampler2D tex, vec2 uv)\n{\n    vec4 sample_color = texture(tex, uv, 0.0);\n#ifdef PACK_SIGNED_TO_UNSIGNED\n    sample_color = 2.0 * sample_color - 1.0;\n#endif // PACK_SIGNED_TO_UNSIGNED\n    return sample_color;\n}\n \nvec4 SampleTextureCatmullRom4Samples(sampler2D tex, vec2 uv, vec2 texSize)\n{\n    // Based on the standard Catmull-Rom spline: w1*C1+w2*C2+w3*C3+w4*C4, where\n    // w1 = ((-0.5*f + 1.0)*f - 0.5)*f, w2 = (1.5*f - 2.5)*f*f + 1.0,\n    // w3 = ((-1.5*f + 2.0)*f + 0.5)*f and w4 = (0.5*f - 0.5)*f*f with f as the\n    // normalized interpolation position between C2 (at f=0) and C3 (at f=1).\n \n    // half_f is a sort of sub-pixelquad fraction, -1 <= half_f < 1.\n    vec2 half_f     = 2.0 * fract(0.5 * uv * texSize - 0.25) - 1.0;\n \n    // f is the regular sub-pixel fraction, 0 <= f < 1. This is equivalent to\n    // fract(uv * texSize - 0.5), but based on half_f to prevent rounding issues.\n    vec2 f          = fract(half_f);\n \n    vec2 s1         = ( 0.5 * f - 0.5) * f;            // = w1 / (1 - f)\n    vec2 s12        = (-2.0 * f + 1.5) * f + 1.0;      // = (w2 - w1) / (1 - f)\n    vec2 s34        = ( 2.0 * f - 2.5) * f - 0.5;      // = (w4 - w3) / f\n \n    // positions is equivalent to: (floor(uv * texSize - 0.5).xyxy + 0.5 +\n    // vec4(-1.0 + w2 / (w2 - w1), 1.0 + w4 / (w4 - w3))) / texSize.xyxy.\n    vec4 positions  = vec4((-f * s12 + s1      ) / (texSize * s12) + uv,\n                           (-f * s34 + s1 + s34) / (texSize * s34) + uv);\n \n    // Determine if the output needs to be sign-flipped. Equivalent to .x*.y of\n    // (1.0 - 2.0 * floor(t - 2.0 * floor(0.5 * t))), where t is uv * texSize - 0.5.\n    float sign_flip = half_f.x * half_f.y > 0.0 ? 1.0 : -1.0;\n \n    vec4 w          = vec4(-f * s12 + s12, s34 * f); // = (w2 - w1, w4 - w3)\n    vec4 weights    = vec4(w.xz * (w.y * sign_flip), w.xz * (w.w * sign_flip));\n \n    return SampleTextureBilinearlyAndUnpack(tex, positions.xy) * weights.x +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zy) * weights.y +\n           SampleTextureBilinearlyAndUnpack(tex, positions.xw) * weights.z +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zw) * weights.w;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSzs.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[427, 427, 459, 459, 544], [546, 546, 578, 578, 660], [662, 662, 689, 689, 1202], [1204, 1204, 1262, 1262, 2936]], "test": "untested"}
{"id": "WlcSD2", "name": "Live Assembly Instructions", "author": "dr2", "description": "No words needed (mouse overrides autopaging)", "tags": ["toy", "train", "book"], "likes": 8, "viewed": 500, "published": 3, "date": "1581683986", "time_retrieved": "2024-07-30T21:24:05.857971", "image_code": "// \"Live Assembly Instructions\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define N_CAR 6\n\nvec3 qHit, ltDir, ltDirEx, pgSize;\nvec2 rlSize, cId;\nfloat dstFar, tCur, szFac, angX, rgHSize, trkWid, dstFarEx, tpBook, phsTurn, idPage;\nint idObj, showTrn, showDec, trkSeg;\nbool sigStop, isCol, trkWide;\nconst float pi = 3.14159;\nconst int nPage = 8;\n\nconst int idRail = 1, idRbase = 2, idXingV = 3, idXingB = 4, idPlatB = 5, idPlatU = 6,\n   idSig = 7, idSigV = 8, idTun = 9, idTrunk = 10, idTree = 11, idCar = 21,\n   idCon = 22, idWhl = 23, idFLamp = 24, idBLamp = 25;\nconst int dirNS = 0, dirEW = 1, dirSW = 2, dirNW = 3, dirSE = 4, dirNE = 5, dirX = 6;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetTrkParms ()\n{\n  vec2 s;\n  int isq;\n  s =  mod (cId + rgHSize, 2. * rgHSize);\n  isq = int (2. * rgHSize * s.y + s.x);\n  trkSeg = -1;\n  if (isq == 1 || isq == 2 || isq == 3 || isq == 4 || isq == 13 ||\n     isq == 16 || isq == 19 || isq == 22 || isq == 31 || isq == 34) trkSeg = dirEW;\n  else if (isq == 6 || isq == 11 || isq == 24 || isq == 26 || isq == 27 ||\n     isq == 29) trkSeg = dirNS;\n  else if (isq == 12 || isq == 30 || isq == 33) trkSeg = dirSE;\n  else if (isq == 17 || isq == 32 || isq == 35) trkSeg = dirSW;\n  else if (isq == 0 || isq == 15 || isq == 18) trkSeg = dirNE;\n  else if (isq == 5 || isq == 14 || isq == 23) trkSeg = dirNW;\n  else if (isq == 20 || isq == 21) trkSeg = dirX;\n}\n\nvec2 SimpTrkSeg (vec3 q, int indx)\n{\n  float dB, dR;\n  if (indx == dirEW) q.xz = q.zx;\n  else if (indx == dirNW) q.z *= -1.;\n  else if (indx == dirSE) q.x *= -1.;\n  else if (indx == dirNE) q.xz *= -1.;\n  if (indx <= dirEW) {\n    q.x = abs (q.x);\n  } else {\n    q.xz += 0.5;\n    q.x = abs (length (q.xz) - 0.5);\n  }\n  dB = PrBox2Df (q.xy, vec2 (2. * trkWid, 0.2 * rlSize.y));\n  q.xy -= vec2 (trkWid, 0.7 * rlSize.y);\n  dR = PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x);\n  return vec2 (dB, dR);\n}\n\nvec2 CrossTrkSeg (vec3 q)\n{\n  vec3 qq;\n  float dB, dR;\n  qq = q;\n  q = qq;  q.x = abs (q.x);\n  dB = PrBoxDf (q, vec3 (2. * trkWid, 0.2 * rlSize.y, 0.5));\n  q = qq;  q.xz = q.zx;   q.x = abs (q.x);\n  dB = min (dB, PrBoxDf (q, vec3 (2. * trkWid, 0.2 * rlSize.y, 0.5)));\n  qq.y -= 0.7 * rlSize.y;\n  q = qq;  q.x = abs (q.x) - trkWid;  q.z += 0.5;\n  dR = PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x);\n  q = qq;  q.xz = q.zx;  q.z += 0.5;  q.x = abs (q.x) - trkWid;\n  dR = min (dR, PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x));\n  q = qq;  q.xz = abs (q.xz) - trkWid + 2.1 * rlSize.x;\n  dR = max (dR, - min (PrBox2Df (q.xz, vec2 (trkWid, 0.7 * rlSize.x)),\n     PrBox2Df (q.zx, vec2 (trkWid, 0.7 * rlSize.x))));\n  return vec2 (dB, dR);\n}\n\nfloat TrackDf (vec3 p)\n{\n  vec3 q;\n  vec2 d2;\n  float dMin, d, dUsq;\n  dMin = dstFar;\n  q = p;  q.xz -= cId + 0.5;\n  if (trkSeg >= 0 && trkSeg <= dirX) {\n    q.y -= 0.5 * rlSize.y;\n    d2 = (trkSeg < dirX) ? SimpTrkSeg (q, trkSeg) : CrossTrkSeg (q);\n    dUsq = PrBox2Df (p.xz, vec2 (rgHSize));\n    d = max (d2.y, dUsq);\n    DMIN (idRail);\n    d = max (d2.x, dUsq);\n    DMIN (idRbase);\n  }\n  return dMin;\n}\n\nfloat TrackRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0001;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetTrkParms ();\n    }\n    d = TrackDf (p);\n    s = (cId + step (0., rd.xz) - p.xz) * rdi.xz;\n    dHit += min (d, 0.001 + max (0., min (s.x, s.y)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat CarDf (vec3 p, float dMin, float dir)\n{\n  vec3 q;\n  float d, s, ds;\n  q = p;\n  s = 0.25;\n  if (q.z * dir > 0.5) {\n    ds = -0.25 * (q.z * dir - 0.5);\n    s += ds;\n    q.y -= ds;\n  }\n  d = PrRoundBoxDf (q, vec3 (0.3, s, 1.55), 0.4);\n  DMINQ (idCar);\n  q = p;  q.xz = abs (q.xz);  q.z = abs (q.z - 0.9);\n  q -= vec3 (0.39, -0.6, 0.2);\n  d = PrCylDf (q.yzx, 0.15, 0.07);\n  DMINQ (idWhl);\n  q = p;  q.z = (dir == 0.) ? abs (q.z) - 1.8 : q.z + 1.8 * dir;\n  d = PrCylDf (q.xzy, 0.3, 0.5);\n  DMIN (idCon);\n  if (dir > 0.) {\n    q = p;  q.yz -= vec2 (-0.25, 1.9);\n    d = PrCylDf (q, 0.1, 0.1);\n    DMINQ (idFLamp);\n  } else if (dir < 0.) {\n    q = p;  q.x = abs (q.x) - 0.2;  q.yz -= vec2 (-0.25, -1.9);\n    d = PrCylDf (q, 0.08, 0.1);\n    DMINQ (idBLamp);\n  }\n  return 0.9 * dMin;\n}\n\nfloat SceneDf (vec3 p)\n{\n  vec4 pCar;\n  vec3 q;\n  float dMin, d;\n  int pxcMin;\n  dMin = dstFar;\n  if (showDec >= 1) {\n    q = p;  q.z = abs (q.z - 0.5);\n    d = PrBoxDf (q, vec3 (0.3, 0.7 * rlSize.y, 0.3));\n    DMIN (idRbase);\n    q = p;  q.xy -= vec2 (0.27 * sign (q.z - 0.5), 0.05);\n    q.z = abs (q.z - 0.5) - 0.16;\n    d = PrCapsDf (q.xzy, 0.017, 0.05);\n    DMIN (idXingV);\n    q = p;  q -= vec3 (0.25, 0.03, 0.66);\n    q.xy = Rot2D (q.xy, angX);  q.xy -= vec2 (-0.22, 0.05);\n    d = PrBoxDf (q, vec3 (0.2, 0.008, 0.005)); \n    DMINQ (idXingB);\n    q = p;  q -= vec3 (-0.25, 0.03, 0.34);\n    q.xy = Rot2D (q.xy, - angX);  q.xy -= vec2 (0.22, 0.05);\n    q.x *= -1.;\n    d = PrBoxDf (q, vec3 (0.2, 0.008, 0.005)); \n    DMINQ (idXingB);\n    q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);\n    d = PrBoxDf (q, vec3 (0.9, 1.5 * rlSize.y, 0.12));\n    DMIN (idPlatB);\n    q.x = abs (q.x) - 0.4;  q.yz -= vec2 (0.07, 0.08);\n    d = max (PrBoxDf (q, vec3 (0.24, 0.09, 0.035)),\n       - PrBoxDf (q, vec3 (0.22, 0.08, 0.04)));\n    DMIN (idPlatU);\n  }\n  if (showDec >= 2) {\n    q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);\n    q -= vec3 (0.8, 0.1, -0.05);\n    d = PrCylDf (q.xzy, 0.01, 0.1);\n    DMIN (idSigV);\n    q.y -= 0.1;\n    d = PrSphDf (q, 0.02);\n    DMIN (idSig);\n    q = p;  q.x = abs (q.x) - 2.48;  q.z -= 1.5;\n    d = max (PrCylAnDf (q, 0.16, 0.005, 0.4), - q.y - 0.04);\n    DMINQ (idTun);\n    q = p;  q.xz = abs (q.xz) - 1.5;  q.y -= 0.14 - 0.04;\n    d = PrCylDf (q.xzy, 0.03 * (1. - q.y), 0.14);\n    DMINQ (idTrunk);\n    q.y -= 0.17;\n    d = PrCapsDf (q.xzy, 0.1 * (1. - 2. * q.y), 0.03);\n    DMINQ (idTree);\n  }\n  if (showTrn > 0) {\n    dMin /= szFac;\n    pxcMin = 5;\n    for (int k = VAR_ZERO; k < N_CAR; k ++) {\n      pCar = Loadv4 (pxcMin + (showTrn - 1) * N_CAR + k);\n      pCar.y = 2.7 * rlSize.y + 0.06;\n      q = p;  q -= pCar.xyz;\n      q.xz = Rot2D (q.xz, pCar.w);\n      dMin = CarDf (q / szFac, dMin, (k > 0) ? ((k < N_CAR - 1) ? 0. : -1.) : 1.);\n    }\n    dMin *= szFac;\n  }\n  return dMin;\n}\n\nfloat SceneRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps;\n  eps = 0.0001;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = SceneDf (ro + dHit * rd);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrackNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- TrackDf (p + e.xxx), TrackDf (p + e.xyy), TrackDf (p + e.yxy), TrackDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SceneNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- SceneDf (p + e.xxx), SceneDf (p + e.xyy), SceneDf (p + e.yxy), SceneDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = SceneDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 CarCol ()\n{\n  vec4 col4;\n  col4 = vec4 (0.1, 0.3, 1., 0.3);\n  if (idObj == idCar) {\n    if (abs (qHit.y - 0.22) < 0.26) col4 = vec4 (0.2, 0.2, 0.2, 0.3);\n    else if (abs (abs (qHit.y - 0.22) - 0.28) < 0.02) col4 = vec4 (1., 0.2, 0.2, 0.3);\n  } else if (idObj == idWhl) {\n     col4 = (length (qHit.yz) < 0.07) ? vec4 (0.2, 0.2, 0.2, 0.1) :\n        vec4 (0.6, 0.6, 0.6, 0.2);\n  } else if (idObj == idFLamp) {\n    if (qHit.z > 0.1) col4 = vec4 (1., 1., 0., -1.);\n  } else if (idObj == idBLamp) {\n    if (qHit.z < -0.1) col4 = vec4 (1., 0., 0., -1.);\n  }\n  return col4;\n}\n\nfloat BrickSurfShd (vec2 p)\n{\n  vec2 q, iq;\n  q = p;\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) {\n    q.x += 0.5;  iq = floor (q);\n  }\n  q = smoothstep (0.015, 0.025, abs (fract (q + 0.5) - 0.5));\n  return 0.5 + 0.5 * q.x * q.y;\n}\n\nfloat BrickShd (vec3 p, vec3 n)\n{\n  return dot (vec3 (BrickSurfShd (p.zy), BrickSurfShd (p.xz), BrickSurfShd (p.xy)),\n     abs (n));\n}\n\nvec4 SceneCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  if (isCol) {\n    if (idObj == idRail) col4 = vec4 (0.7, 0.7, 0.7, 0.2);\n    else if (idObj == idRbase) col4 = vec4 (mix (vec3 (0.25, 0.25, 0.27),\n       vec3 (0.32, 0.32, 0.34), smoothstep (0.6, 0.9, Noisefv2 (512. * ro.xz))), 0.1);\n    else if (idObj == idXingV) col4 = vec4 (0.7, 0.8, 0.7, 0.3);\n    else if (idObj == idXingB) col4 = mix (vec4 (1., 0., 0., 1.),\n       vec4 (1.), step (0.5, mod (10. * qHit.x, 1.)));\n    else if (idObj == idPlatB) col4 = mix (vec4 (0.2, 0.2, 0.22, 0.1),\n       vec4 (0.25, 0.25, 0.2, 0.1), Noisefv2 (1024. * ro.xz));\n    else if (idObj == idPlatU) col4 = vec4 (0.5, 0.3, 0.1, 0.2) *\n       BrickShd (50. * ro, vn);\n    else if (idObj == idSig) col4 = sigStop ? vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.);\n    else if (idObj == idSigV) col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n    else if (idObj == idTun) col4 = vec4 (0.7, 0.3, 0.1, 0.05) *\n       (1. - 0.4 * Noisefv2 (vec2 (512. * (1. + atan (qHit.y, qHit.x) / pi), 128. * qHit.z)));\n    else if (idObj == idTree) col4 = vec4 (0., 0.4, 0., 0.) *\n       (1. - 0.5 * Noisefv2 (vec2 (64. * (1. + atan (qHit.x, qHit.z) / pi), 128. * qHit.y)));\n    else if (idObj == idTrunk) col4 = vec4 (0.3, 0.1, 0., 0.02) *\n       (1. - 0.3 * Noisefv2 (vec2 (32. * (1. + atan (qHit.x, qHit.z) / pi), 64. * qHit.y)));\n  } else {\n    if (idObj == idRail) col4.rgb = vec3 (0.6);\n    else if (idObj == idRbase) col4.rgb = vec3 (0.4);\n    else if (idObj == idXingV) col4.rgb = vec3 (0.7);\n    else if (idObj == idXingB) col4.rgb = vec3 (0.9);\n    else if (idObj == idPlatB) col4.rgb = vec3 (0.3);\n    else if (idObj == idPlatU) col4.rgb = vec3 (0.4);\n    else if (idObj == idSig) col4.rgb = vec3 (1.);\n    else if (idObj == idSigV) col4.rgb = vec3 (0.7);\n    else if (idObj == idTun) col4.rgb = vec3 (0.5);\n    else if (idObj == idTree) col4.rgb = vec3 (0.3);\n    else if (idObj == idTrunk) col4.rgb = vec3 (0.2);\n    col4.a = 0.;\n  }\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, e;\n  float f;\n  if (isCol) {\n    e = vec2 (0.01, 0.);\n    w = 5. * ro.xz;\n    f = Fbm2 (w);\n    vn = normalize (vec3 (f - Fbm2 (w + e), 0.04, f - Fbm2 (w + e.yx)));\n    col = 0.4 * mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n    col *= 0.1 + 0.9 * max (dot (vn, ltDir), 0.);\n  } else {\n    col = vec3 (0.5);\n  }\n  return col;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col;\n  float f;\n  col = vec3 (0.05, 0.1, 0.25) + 0.2 * pow (1. - rd.y, 8.) +\n     0.4 * min (pow (max (dot (rd, ltDir), 0.), 256.), 0.3);\n  f = Fbm2 ((4. / rd.y) * rd.xz);\n  col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y > 0.) col = SkyCol (rd);\n  else col = GrndCol (ro - (ro.y / rd.y) * rd, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 rdd, qHitT, col, vn;\n  float dstObj, d, reflFac, sh;\n  int idObjT;\n  bool isTrk;\n  dstObj = dstFar;\n  d = TrackRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    isTrk = true;\n  }\n  idObjT = idObj;\n  qHitT = qHit;\n  d = SceneRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    isTrk = false;\n  } else {\n    idObj = idObjT;\n    qHit = qHitT;\n  }\n  reflFac = 0.;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    idObjT = idObj;\n    qHitT = qHit;\n    vn = isTrk ? TrackNf (ro) : SceneNf (ro);\n    idObj = idObjT;\n    qHit = qHitT;\n    if (idObj == idCar) {\n      rdd = reflect (rd, vn);\n      reflFac = (abs (qHit.y - 0.22) < 0.26) ? 0.6 : 0.2;\n    }\n    if (idObj < idCar) {\n      if (idObj == idRbase || idObj == idTun || idObj == idTree) vn = VaryNf (128. * ro, vn, 2.);\n      col4 = SceneCol (ro, vn);\n    } else col4 = CarCol ();\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      sh = (showTrn == 1) ? ObjSShadow (ro, ltDir) : 1.;\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    if (showTrn == 1) {\n      sh = (dstObj < dstFar) ? ObjSShadow (ro, ltDir) : 1.;\n      col = GrndCol (ro, rd);\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));\n      col = mix (col, SkyCol (abs (rd)), smoothstep (0.7, 1., dstObj / dstFar));\n    } else {\n      col = (max (abs (ro.x) - 2.8, abs (ro.z) - 3.2) < 0.) ?\n         vec3 (0., 0.25, 0.) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) : vec3 (0.15);\n    }\n  } else {\n    col = (showTrn == 1) ? BgCol (ro, rd) : vec3 (0.15);\n  }\n  if (showTrn == 1 && reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, rdd), reflFac);\n  if (! isCol) col = Maxv3 (smoothstep (0., 1., col)) * vec3 (1., 1., 0.9);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvoid InitSys ()\n{\n  vec4 stDat;\n  float trMov, trCyc, t;\n  int trStop;\n  rgHSize = 3.;\n  szFac = 0.08;\n  trkWid = 0.03;\n  rlSize = trkWide ? vec2 (0.006, 0.005) : vec2 (0.003, 0.005);\n  stDat = Loadv4 (2);\n  trMov = stDat.x;\n  trCyc = stDat.w;\n  stDat = Loadv4 (4);\n  trStop = int (stDat.x);\n  t = mod (trMov / trCyc, 1.);\n  angX = 0.3 * pi * (1. - SmoothBump (0.55, 0.69, 0.02, t));\n  sigStop = (trStop != 2);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec4 pVu;\n  vec3 ro, rd, col, u, vd;\n  float zmFac, f;\n  int vuMode;\n  dstFar = 20.;\n  isCol = true;\n  if (idPage == 1.) {\n    vuMode = 0;\n    showDec = 0;\n    showTrn = 0;\n    isCol = false;\n  } else if (idPage == 2.) {\n    vuMode = 0;\n    showDec = 1;\n    showTrn = 0;\n    isCol = false;\n  } else if (idPage == 3.) {\n    vuMode = 0;\n    showDec = 2;\n    showTrn = 0;\n    isCol = false;\n  } else if (idPage == 4.) {\n    vuMode = 0;\n    showDec = 2;\n    showTrn = 2;\n    isCol = false;\n  } else {\n    vuMode = int (mod (idPage - 5., 4.));\n    showDec = 2;\n    showTrn = 1;\n  }\n  InitSys ();\n  if (vuMode == 0) {\n    vuMat = StdVuMat (-0.2 * pi, -0.25 * pi);\n    ro = vuMat * vec3 (0., -0.1, -50.);\n    zmFac = 39.;\n    dstFar = 80.;\n  } else if (vuMode == 1) {\n    ro = vec3 (0., 2., -5.);\n    vd = normalize (Loadv4 (5 + 2).xyz - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 16. * (atan (length (vd.xz), vd.y) / pi);\n  } else if (vuMode == 2 || vuMode == 3) {\n    pVu = Loadv4 ((vuMode == 2) ? 0 : 1);\n    ro.xz = pVu.xz;\n    ro.y = 0.4;\n    vuMat = StdVuMat (-0.1 * pi, - pVu.w);\n    zmFac = 5.4;\n  }\n  trkWide = (showTrn != 1 || vuMode <= 1);\n  ltDir = normalize (vec3 (1., 2., -1.));\n  rd = vuMat * normalize (vec3 (fCoord, 0.5 * zmFac));\n  col = ShowScene (ro, rd);\n  fCol = col;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 5.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.x / nRing;\n  bc = q.x;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = 0; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.zy = Rot2D (vec2 (q.z, y), 2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.z + rRad, bc));\n    q.z -= - (pgSize.z - hOff + rRad);\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.x) - pgSize.x;\n  q.x = bc;\n  q = q.zyx;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = HsvToRgb (vec3 ((idPage - 1.) / float (nPage), 0.3, 1.));\n      s = pgSize.xz - abs (qHit.xz);\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      } else {\n        col4 = vec4 (c, 0.2);\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.1 * rd.z);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  stDat = Loadv4 (3);\n  tpBook = stDat.x;\n  el = stDat.y;\n  az = stDat.z;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -1.7, -20.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (0.3, 1., 0.3));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  col = pow (col, vec3 (0.8));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Live Assembly Instructions\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define N_CAR 6\n#define TRK_LEN 24\n\nvec3 drP;\nvec2 rP;\nfloat ti[TRK_LEN + 1], tCur, trCyc, rgHSize, tC, aP;\nconst float pi = 3.14159;\n\n#define SLIN(k,d) ti[k + 1] = ti[k] + d\n#define SCRV(k) ti[k + 1] = ti[k] + tC\n\nvoid TrSetup ()\n{\n  tC = 0.25 * pi;\n  ti[0] = 0.;\n  SCRV(0);  SLIN(1, 4.);  SCRV(2);  SLIN(3, 1.);  SCRV(4);  SLIN(5, 1.);  SCRV(6);\n  SLIN(7, 2.);  SCRV(8);  SLIN(9, 1.);  SCRV(10);  SLIN(11, 1.);  SCRV(12);\n  SLIN(13, 4.);  SCRV(14);  SLIN(15, 1.);  SCRV(16);  SLIN(17, 1.);  SCRV(18);\n  SLIN(19, 2.);  SCRV(20);  SLIN(21, 1.);  SCRV(22);  SLIN(23, 1.);\n  trCyc = ti[TRK_LEN];\n  rgHSize = 3.;\n}\n\nvec2 TrackPath (float t)\n{\n  t = mod (t, trCyc);\n  drP = vec3 (0., 0., 99.);\n  if (t < ti[6]) {\n    if (t < ti[1]) {\n      rP = vec2 (0., 0.);  drP = vec3 (1., 1., 0.5 * tC + 0.25 * (t - ti[0]));\n    } else if (t < ti[2]) {\n      rP = vec2 (1., 0.5);  drP.x = (t - ti[1]);\n    } else if (t < ti[3]) {\n      rP = vec2 (5., 0.);  drP = vec3 (0., 1., 0.75 * tC + 0.25 * (t - ti[2]));\n    } else if (t < ti[4]) {\n      rP = vec2 (5.5, 1.);  drP.y = (t - ti[3]);\n    } else if (t < ti[5]) {\n      rP = vec2 (5., 2.);  drP.z = 0. * tC + 0.25 * (t - ti[4]);\n    } else {\n      rP = vec2 (5., 2.5);  drP.x = - (t - ti[5]);\n    }\n  } else if (t < ti[12]) {\n    if (t < ti[7]) {\n      rP = vec2 (4., 2.);  drP = vec3 (0., 1., 0.75 * tC - 0.25 * (t - ti[6]));\n    } else if (t < ti[8]) {\n      rP = vec2 (3.5, 3.);  drP.y = (t - ti[7]);\n    } else if (t < ti[9]) {\n      rP = vec2 (3., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[8]));\n    } else if (t < ti[10]) {\n      rP = vec2 (4., 5.5);  drP.x = (t - ti[9]);\n    } else if (t < ti[11]) {\n      rP = vec2 (5., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[10]);\n    } else {\n      rP = vec2 (5.5, 5.);  drP.y = - (t - ti[11]);\n    }\n  } else if (t < ti[18]) {\n    if (t < ti[13]) {\n      rP = vec2 (5., 3.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[12]));\n    } else if (t < ti[14]) {\n      rP = vec2 (5., 3.5);  drP.x = - (t - ti[13]);\n    } else if (t < ti[15]) {\n      rP = vec2 (0., 3.);  drP = vec3 (1., 1., 0.75 * tC - 0.25 * (t - ti[14]));\n    } else if (t < ti[16]) {\n      rP = vec2 (0.5, 4.);  drP.y = (t - ti[15]);\n    } else if (t < ti[17]) {\n      rP = vec2 (0., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[16]));\n    } else {\n      rP = vec2 (1., 5.5);  drP.x = (t - ti[17]);\n    }\n  } else {\n    if (t < ti[19]) {\n      rP = vec2 (2., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[18]);\n    } else if (t < ti[20]) {\n      rP = vec2 (2.5, 5.);  drP.y = - (t - ti[19]);\n    } else if (t < ti[21]) {\n      rP = vec2 (2., 2.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[20]));\n    } else if (t < ti[22]) {\n      rP = vec2 (2., 2.5);  drP.x = - (t - ti[21]);\n    } else if (t < ti[23]) {\n      rP = vec2 (0., 2.);  drP = vec3 (1., 0., 0.25 * tC + 0.25 * (t - ti[22]));\n    } else {\n      rP = vec2 (0.5, 2.);  drP.y = - (t - ti[23]);\n    }\n  }\n  if (drP.z != 99.) {\n    drP.z *= 2. * pi / tC;\n    rP += 0.5 * vec2 (cos (drP.z), sin (drP.z));\n  }\n  rP += drP.xy - rgHSize;\n  return rP;\n}\n\nconst float txRow = 64.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[2], pCar, pVu, stDat, mPtr;\n  vec2 iFrag, canvas, ust, vo, p1, p2;\n  float el, az, asp, cGap, tCurP, trVar, trSpd, trMov, t1, t2, t, ntStop, tpBook;\n  int pxId, trStop, pxcMin;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * N_CAR + 5) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  if (iFrame <= 5) {\n    tpBook = 0.;\n    trMov = 0.;\n    trStop = 2;\n    ntStop = 0.;\n    trVar = 0.25;\n  } else {\n    stDat = Loadv4 (2);\n    trMov = stDat.x;\n    trSpd = stDat.y;\n    tCurP = stDat.z;\n    stDat = Loadv4 (3);\n    tpBook = stDat.x;\n    el = stDat.y;\n    az = stDat.z;\n    trVar = stDat.w;\n    stDat = Loadv4 (4);\n    trStop = int (stDat.x);\n    ntStop = stDat.y;\n  }\n  tpBook = tCur;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    tpBook = - clamp (1.05 * mPtr.y + 0.5, 0., 1.);\n  }\n  trSpd = 1.2 * trVar;\n  if (trSpd < 0.01) trSpd = 0.;\n  TrSetup ();\n  t = mod (trMov / trCyc, 1.);\n  if (trStop == 0) {\n    if (t > 0.122) {\n      trStop = 1;\n      trSpd = 0.;\n      ntStop = 100.;\n    }\n  } else if (trStop == 1) {\n    if (-- ntStop > 0.) trSpd = 0.;\n    else trStop = 2;\n  } else if (trStop == 2) {\n    if (t < 0.07) trStop = 0;\n  }\n  trMov += trSpd * (tCur - tCurP);\n  cGap = 0.33;\n  pxcMin = 5;\n  if (pxId >= pxcMin) {\n    if (pxId - pxcMin < N_CAR) t = trMov - float (pxId - pxcMin) * cGap;\n    else t = 0.122 * trCyc - float (pxId - pxcMin - N_CAR) * cGap;\n    p1 = TrackPath (t + 0.3 * cGap);\n    p2 = TrackPath (t - 0.3 * cGap);\n    pCar.xz = 0.5 * (p1 + p2);\n    pCar.y = 0.;\n    vo = p1 - p2;\n    pCar.w = atan (vo.x, vo.y);\n  } else if (pxId == 0 || pxId == 1) {\n    if (pxId == 0) {\n      t1 = trMov - (float (N_CAR - 1) + 2.5) * cGap;\n      t2 = t1 + 2. * cGap;\n    } else {\n      t1 = trMov + 2.5 * cGap;\n      t2 = t1 - 2. * cGap;\n    }\n    p1 = TrackPath (t1);\n    p2 = TrackPath (t2);\n    pVu.xz = p1;\n    pVu.y = 0.;\n    vo = p2 - p1;\n    pVu.w = - atan (vo.x, vo.y);\n  }\n  tCurP = tCur;\n  if (pxId < 2) stDat = pVu;\n  else if (pxId == 2) stDat = vec4 (trMov, trSpd, tCurP, trCyc);\n  else if (pxId == 3) stDat = vec4 (tpBook, el, az, trVar);\n  else if (pxId == 4) stDat = vec4 (float (trStop), ntStop, 0., 0.);\n  else if (pxId >= pxcMin) stDat = pCar;\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcSD2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1577, 1577, 1598, 1598, 2280], [2282, 2282, 2318, 2318, 2776], [2778, 2778, 2805, 2805, 3509], [3511, 3511, 3535, 3535, 3916], [3918, 3918, 3953, 3953, 4577], [4579, 4579, 4624, 4624, 5361], [5363, 5363, 5387, 5387, 7370], [7372, 7372, 7407, 7407, 7688], [7690, 7690, 7713, 7713, 7916], [7918, 7918, 7941, 7941, 8144], [8146, 8146, 8183, 8183, 8414], [8416, 8416, 8432, 8432, 8989], [8991, 8991, 9020, 9020, 9234], [9236, 9236, 9269, 9269, 9370], [9372, 9372, 9406, 9406, 11336], [11338, 11338, 11371, 11371, 11775], [11777, 11777, 11800, 11800, 12063], [12065, 12065, 12096, 12096, 12212], [12214, 12214, 12249, 12249, 14183], [14185, 14185, 14221, 14221, 14427], [14429, 14429, 14446, 14446, 14841], [14843, 14843, 14889, 14889, 16306], [16308, 16308, 16332, 16332, 17223], [17225, 17225, 17260, 17260, 17448], [17450, 17450, 17473, 17473, 17676], [17678, 17678, 17717, 17717, 17948], [19618, 19618, 19674, 19674, 20581], [20583, 20583, 20615, 20615, 20715], [20717, 20717, 20763, 20763, 20810], [20812, 20812, 20845, 20845, 20934], [20936, 20936, 20983, 20983, 21030], [21032, 21032, 21065, 21065, 21092], [21094, 21094, 21136, 21136, 21187], [21189, 21189, 21242, 21242, 21303], [21305, 21305, 21348, 21348, 21412], [21414, 21414, 21460, 21460, 21517], [21519, 21519, 21541, 21541, 21579], [21581, 21581, 21638, 21638, 21721], [21723, 21723, 21768, 21768, 21871], [21873, 21873, 21903, 21903, 22016], [22018, 22018, 22042, 22042, 22159], [22193, 22193, 22217, 22217, 22347], [22349, 22349, 22374, 22374, 22560], [22562, 22562, 22583, 22583, 22738], [22740, 22740, 22769, 22769, 22981], [22983, 22983, 23022, 23022, 23207], [23300, 23300, 23325, 23325, 23448]], "test": "untested"}
{"id": "Wl3GR4", "name": "Secret Box", "author": "Plento", "description": "Not the effect I was going for but sorta cool. Not really optimized so it might be slow.", "tags": ["3d", "glass", "oops"], "likes": 5, "viewed": 379, "published": 3, "date": "1581671952", "time_retrieved": "2024-07-30T21:24:07.462680", "image_code": "// Plento\nvec2 R;\n\n#define FAR 32.\n\nconst float pi = 3.14159;\n\nmat2 rot(float a){return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opsub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat minDist = 999.;\nfloat mat = -1.0;\n\nvoid cd(float tDist, float m, out float tmat){\n\tif(tDist <minDist){\n\t\tminDist = tDist;\n\t\tmat = m;\n\t\ttmat = m;\n\t}\n}\n\nconst vec3 gd = vec3(1.4, 0.5, 0.5);\n\nfloat frame(vec3 p){\n    float d = sdBox(p, gd+.05);\n    d = opsub(sdBox(p, vec3(gd.x-.05, gd.y-.05, gd.z + 1.)),d );\n    d = opsub(sdBox(p, vec3(gd.x+1., gd.y-.05, gd.z -.05)),d );\n    d = opsub(sdBox(p, vec3(gd.x-.05, gd.y+1., gd.z -.05)),d );\n    \n    return d;\n}\n\nvec2 map(vec3 rp){\n    float d = 999.;\n    float hmat = 0.;\n    \n \tvec3 p0 = rp - vec3(0.0, 0.0, 3.0);\n    vec3 p1 = rp - vec3(0.0, 0.0, 3.0);\n    \n    p0.xy *= rot(iTime*.4);\n    p0.xz *= rot(iTime*.3);\n    p0.yz *= rot(-sin(iTime)*.2);\n    \n    d = min(d, abs(sdBox(p0, gd)) - 0.005);\n    cd(d, 0., hmat);\n    \n    d = min(d, frame(p0));\n    cd(d, 2., hmat);\n    \n    d = min(d, length(p1)-.1);\n    cd(d, 1., hmat);     \n    \n    rp.xy *= rot(iTime);\n    vec3 p2 = rp - vec3(.3*sin(iTime*2.), 0.0,3. + .3*cos(iTime*2.) );\n    d = min(d, length(p2)-.05);\n    \n    \n    cd(d, 3., hmat); \n    \n    return vec2(d, hmat);\n}\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy).x + \n        e.yyx * map(pos + e.yyx).x + \n        e.yxy * map(pos + e.yxy).x + \n        e.xxx * map(pos + e.xxx).x);\n}\n\nvec2 march(vec3 rd, vec3 ro){\n \tfloat t = 0.;   \n    vec2 d = vec2(0);\n    \n    for(int i = 0; i < 64; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d.x) < 0.002)break;\n        if(t > FAR){t = FAR;break;}\n        t += d.x * 0.9;\n    }   \n    \n    return vec2(t, d.y);\n}\nvec3 color(vec3 p, vec3 rd, vec3 n, float t, float m){\n    vec3 lp = vec3(0., 4.0, -5.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect( rd, n );\n    \n    float lgd = length(lp - p);\n    float faloff = 1.-exp(-(4. / lgd));\n    \n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 32.);\n    float dom = smoothstep(-0.2, 0.2, ref.y);\n    float dif = max(dot(n, ld), .0);\n    \n    vec3 col = vec3(0);    \n    vec3 lig = vec3(0);\n    \n    \n    if(t < FAR){\n    \tif(m == 0.)col = vec3(0.2, 0.3, 0.3);\n    \tif(m == 1.)col = vec3(1.0, 0., 0.);\n    \tif(m == 2.)col = vec3(.01);\n    \tif(m == 3.)col = vec3(0., 0.4, 1.);\n    \n    \tlig += .15*dom*vec3(0.4,0.6,1.3)*dom;\n    \tlig += 2.*dif*vec3(1., 1., 1.) * faloff;\n    \tcol *= lig;\n    \tcol += vec3(0.85, 0.83, 0.85) * spec * .2;\n    }\n    else col = vec3(.2);\n    \n\treturn col;   \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n   \n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.5));\n    vec3 ro = vec3(0);\n    \n    vec2 t = march(rd, ro);\n    vec3 p = ro+rd*t.x;\n    vec3 n = normal(p);\n    \n    vec3 col = vec3(0);\n    \n    float na = 0.;\n    \n    vec3 acol = vec3(0);\n    vec3 bcol = vec3(0);\n    vec3 ccol = vec3(0);\n    \n    col = color(p, rd, n, t.x, t.y);\n    na++;\n    \n    if(t.y == 0.){\n        minDist = 999.;\n        mat = -1.;\n        \n        p -= n*.18;\n        \n        rd = refract(rd, n, .5);\n        \n        vec2 t2 = march(rd, p);\n    \tvec3 p2 = p+rd*t2.x;\n    \tvec3 n2 = normal(p2);   \n        \n        col += color(p2, rd, n2, t2.x, t2.y);\n        na++;\n        \n        /*\n        if(t2.y == 0.){\n            minDist = 999.;\n        \tmat = -1.;\n        \tcol.b+=.1;\n            p2 -= n2*.1;\n            \n            rd = refract(rd, n2, .93);\n            \n            vec2 t3 = march(rd, p2);\n    \t\tvec3 p3 = p2+rd*t3.x;\n    \t\tvec3 n3 = normal(p3);\n            \n            col += color(p3, rd, n3, t3.x, t3.y);\n            na++;\n           \n        } \n*/\n    }\n    col /= na;\n    \n    \n    \n    vec2 v = u / R;\n    v *=  1. - v.yx;\n    float vig = v.x*v.y * 15.; \n    vig = pow(vig, .35); \n    col *= vig;\n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3GR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 81, 81, 127], [129, 129, 159, 159, 246], [248, 248, 283, 283, 305], [348, 348, 394, 394, 462], [502, 502, 522, 522, 768], [770, 770, 788, 788, 1390], [1391, 1391, 1418, 1418, 1627], [1629, 1629, 1658, 1658, 1912], [1913, 1913, 1967, 1967, 2758], [2760, 2760, 2800, 2800, 4164]], "test": "untested"}
{"id": "WltXRj", "name": "7.5 kilobytes for Nathalie", "author": "BrunoLevy", "description": " A special valentine shader for my wife Nathalie, rendered using 'cupidon arrows tracing'.\n", "tags": ["raytracing", "aabb", "mesh", "valentine"], "likes": 28, "viewed": 1119, "published": 3, "date": "1581666305", "time_retrieved": "2024-07-30T21:24:08.490930", "image_code": "// Settings\n// (smoothness, extinction and scale are changed in function of heart beats)\n      float smoothness;           // 1.0: smooth shading  0.0: faceted shading \n      float refract_index;        // 1.0: no refraction   1.3: water   2.4: diamond\n      float extinction;           // the higher, the darker (in function of thicness) \nconst float reflect_coeff = 0.75; // 0.0: no reflection   1.0: shiny reflections\nconst vec3  core_color = vec3(1.0,0.0,0.0); \n      float scale;\n      bool  dispersion = true;    // set to true to decompose light like a prism\nbool  fixed_cam = false;          // Set to true for fixed cam and rotating lighting env.\n\n// Mesh data borrowed from https://www.thingiverse.com/thing:4041510\n\nconst vec3 bbox_min = vec3(-0.429853,-0.406522,-0.147051);\nconst vec3 bbox_max = vec3(0.429853,0.406522,0.147051);\n\n// Yes, I could have compressed that in a single int per triangle, on the other hand there are\n// only 64 of them, so I think it will not make a big difference...\nconst ivec3 triangles[64] = ivec3[](\nivec3(0x00000004,0x00000015,0x00000003),ivec3(0x00000015,0x00000017,0x00000003),ivec3(0x00000004,0x00000016,0x00000015),ivec3(0x00000003,0x00000005,0x00000004),ivec3(0x00000016,0x00000017,0x00000015),ivec3(0x00000001,0x00000016,0x00000004),ivec3(0x00000003,0x00000006,0x00000005),ivec3(0x00000005,0x00000019,0x00000004),ivec3(0x00000002,0x00000016,0x00000001),ivec3(0x00000004,0x0000001a,0x00000001),ivec3(0x00000000,0x00000017,0x00000016),ivec3(0x00000017,0x00000020,0x00000003),ivec3(0x00000019,0x0000001a,0x00000004),ivec3(0x00000000,0x00000016,0x00000002),ivec3(0x00000001,0x0000001a,0x00000002),\nivec3(0x00000003,0x00000020,0x00000006),ivec3(0x00000006,0x00000007,0x00000005),ivec3(0x00000008,0x00000019,0x00000005),ivec3(0x00000007,0x00000008,0x00000005),ivec3(0x00000019,0x0000001b,0x0000001a),ivec3(0x00000002,0x0000001a,0x00000013),ivec3(0x00000000,0x00000018,0x00000017),ivec3(0x00000018,0x00000021,0x00000017),ivec3(0x00000017,0x00000021,0x00000020),ivec3(0x00000002,0x00000013,0x00000000),ivec3(0x00000006,0x00000020,0x00000007),ivec3(0x00000008,0x0000001b,0x00000019),ivec3(0x0000001a,0x0000001b,0x00000013),ivec3(0x00000013,0x00000018,0x00000000),ivec3(0x00000007,0x0000001d,0x00000008),ivec3(0x00000009,0x00000021,0x00000018),\nivec3(0x00000007,0x00000020,0x0000001d),ivec3(0x00000020,0x00000021,0x00000009),ivec3(0x0000000a,0x00000018,0x00000013),ivec3(0x00000013,0x0000001b,0x00000012),ivec3(0x00000008,0x0000001c,0x0000001b),ivec3(0x0000001d,0x00000020,0x0000001f),ivec3(0x0000000a,0x00000013,0x0000000b),ivec3(0x00000009,0x00000018,0x0000000d),ivec3(0x0000000d,0x00000020,0x00000009),ivec3(0x0000001d,0x0000001e,0x00000008),ivec3(0x0000000b,0x00000013,0x00000012),ivec3(0x0000001b,0x0000001c,0x00000012),ivec3(0x0000000d,0x00000018,0x0000000a),ivec3(0x0000001f,0x00000020,0x0000000d),ivec3(0x00000008,0x0000001e,0x0000001c),ivec3(0x0000001d,0x0000001f,0x00000014),\nivec3(0x0000000b,0x00000012,0x0000000f),ivec3(0x00000014,0x0000001e,0x0000001d),ivec3(0x0000000b,0x00000010,0x0000000a),ivec3(0x00000012,0x0000001c,0x00000011),ivec3(0x0000000a,0x00000010,0x0000000d),ivec3(0x0000001c,0x0000001e,0x00000014),ivec3(0x0000000f,0x00000012,0x00000011),ivec3(0x00000011,0x0000001c,0x00000014),ivec3(0x0000000f,0x00000010,0x0000000b),ivec3(0x00000014,0x0000001f,0x0000000e),ivec3(0x0000000e,0x0000001f,0x0000000d),ivec3(0x0000000f,0x00000011,0x00000010),ivec3(0x00000011,0x00000014,0x0000000e),ivec3(0x0000000d,0x00000010,0x0000000c),ivec3(0x00000010,0x00000011,0x0000000c),ivec3(0x0000000c,0x0000000e,0x0000000d),\nivec3(0x0000000c,0x00000011,0x0000000e));\n\nconst int points[34] = int[](\n0x017d7191,0x2c5eb8dd,0x21cffd13,0x21aab001,0x354c7486,0x353860b1,0x21530152,0x35235591,0x3a4545f4,0x01c6fe52,0x017d726d,0x21cffeeb,0x21cd03ff,0x020aeb32,0x21aab3fd,0x2e3ebb21, 0x223ebba2,0x351c7f79,0x351eb2aa,0x21fe21ff,0x3598b72a,0x21cd0000,0x223eb85c,0x020ae8dd,0x000a7606,0x3e3cd911,0x351eb154,0x382b6dff,0x3ffca6ee,0x3523566d,0x3588b32b,0x2182e29b, 0x21700206,0x01d6f9ac\n);\n\nconst int normals[34] = int[](\n0x053c5a11,0x380ca561,0x184fba2a,0x13745467,0x3b99790f,0x3b95f121,0x2bd36c88,0x3b44b15d,0x3fd755fd,0x01b5ce56,0x053c59ed,0x186fb9d5,0x153aa7c2,0x0396d6de,0x1de42bbf,0x380ca69c, 0x0f0d76ff,0x3ba936f2,0x390cb9a1,0x1dcff5ff,0x36e53b34,0x13ea9c44,0x0ead60ff,0x03a6c91e,0x0038edff,0x3fe831e5,0x38fcc657,0x3f29c1f7,0x3fe83219,0x3b94f6a7,0x3f16da59,0x19535390, 0x07132da4,0x01c5cda4\n);\n\n\n\n// Gets x,y,z, coordinates packed in a single 32 bits int (10 bits per coordinate)\nint get_compressed_point(in int v) {\n    return  points[v];\n}\n\n// Converts a single-int 10 bits per components packed point into a standard vec3.\nvec3 uncompress_point(in int xyz) {\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return scale * (bbox_min + (bbox_max - bbox_min) * vec3(XYZ) / 1023.0);\n}\n\n// Gets a point from a vertex index\nvec3 get_point(int v) {\n   return uncompress_point(get_compressed_point(v));\n}\n\n// Gets a normal from a vertex index\nvec3 get_normal(int v) {\n   int xyz = normals[v];\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return vec3(-1) + vec3(XYZ) / 512.0;    \n}\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 1.0, 0.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Intersection {\n   float t;\n   vec3 P;\n   vec3 N;\n   vec3 Nsmooth;\n   int id; // index of latest intersected triangle, used to avoid finding the point\n           //  where you started from when computing multiple bounces.\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   I.id = -1; \n   return I;\n}\n\nRay reflect_ray(in Ray R, in Intersection I) {\n    return Ray(I.P, reflect(R.Dir, I.N));\n}\n\nRay refract_ray(in Ray R, in Intersection I, in float n1, in float n2) {\n    return Ray(I.P, refract(normalize(R.Dir), I.N, n1/n2));\n}\n\n// Branchless ray-triangle intersection that gives, for free, as by-products:\n//   Normal N\n//   Barycentric coordinates (1-u-v, u, v)\n// (slightly modified Moller-Trumbore algorithm)\n// References and explanations here:\n// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d/42752998#42752998\nbool intersect_triangle(\n    in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t, \n    out float u, out float v, out vec3 N\n) { \n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n         N = cross(E1,E2);\n   float det = -dot(R.Dir, N);\n   float invdet = 1.0/det;\n   vec3 AO  = R.Origin - A;\n   vec3 DAO = cross(AO, R.Dir);\n   u =  dot(E2,DAO) * invdet;\n   v = -dot(E1,DAO) * invdet;\n   t =  dot(AO,N)   * invdet;\n   return (abs(det) >= 1e-6 && t >= 0.0 && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0);\n}\n\n// Computes ray-triangle intersection from node index (i)\n// Returns true if there was an intersection.\n// Note: normal is not normalized\nbool triangle(in Ray R, in int i, inout Intersection I) {\n   ivec3 T = triangles[i];\n   vec3 A = get_point(T.x);\n   vec3 B = get_point(T.y);\n   vec3 C = get_point(T.z);    \n   float t,u,v;\n   vec3 N;\n   if(intersect_triangle(R, A,B,C, t, u, v, N) && t < I.t) {\n      I.t = t;\n      I.P = R.Origin + t*R.Dir;\n      I.id = i;\n      vec3 N1 = get_normal(T.x);\n      vec3 N2 = get_normal(T.y);\n      vec3 N3 = get_normal(T.z);       \n      I.Nsmooth = (1.0-u-v)*N1 + u*N2 + v*N3;\n      I.N = N;\n      return true;\n   }\n   return false;\n}\n \n// Good explanations here:\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax,\n  in float t \n) {  \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2);\n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);\n}\n\n// No AABB-tree here (not worth it, we only got 64 triangles !)\n// Mesh ray-tracing with AABB-tree is here: https://www.shadertoy.com/view/WlcXRS\nbool raytrace_mesh(in Ray R, inout Intersection I) {\n    int prev_id = I.id; // index of latest intersected triangle\n    bool result = false;  \n    // ... But I still keep a single AABB around the whole mesh.\n    // We could do without it, but it gains a couple of FPS.\n    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);\n    if(!segment_box_intersection(R.Origin, invDir, scale*bbox_min, scale*bbox_max, I.t)) {\n        return false;\n    }\n    for(int i=0; i<triangles.length(); ++i) {\n       if(i == prev_id) { continue; } // skip latest triangle\n       bool t_isect = triangle(R, i, I);\n       result = result || t_isect;\n    }\n    if(result) { // Interpolating between facetted and smooth shading, just for fun.\n        I.N = mix(normalize(I.N), normalize(I.Nsmooth), smoothness);\n        I.N = normalize(I.N); \n    }\n    return result;\n}  \n\n// Modifies ray and intersection, returns total length of traversed matter.\nfloat multi_refract(inout Ray R, inout Intersection I) {\n    float result = 0.0;\n    for(int i=0; i<10; ++i) {\n        if(dot(R.Dir,I.N) > 0.0) { // Exiting matter\n            result += I.t;\n            vec3 old_dir = R.Dir;\n            I.N = -I.N;\n            R = refract_ray(R, I, refract_index, 1.0);\n            if(R.Dir == vec3(0)) { \n               R.Dir = reflect(old_dir, I.N); // total reflection  \n            }\n        } else { // Entering matter\n            R = refract_ray(R, I, 1.0, refract_index);\n            R.Dir = normalize(R.Dir); // Needs to be unit, so that on exit, I.t is distance\n        }\n        I.t = FARAWAY;\n        if(!raytrace_mesh(R, I)) { break; }  \n    }\n    return result;\n}\n\nvec3 sky(in Ray R) {\n    if(fixed_cam) {\n        float alpha = iTime/2.0;\n        float s = sin(alpha);\n        float c = cos(alpha);\n        vec3 V = vec3(\n            R.Dir.x * c + R.Dir.z * s,\n            R.Dir.y,\n            R.Dir.x * s - R.Dir.z * c\n        );\n        return vec3(textureLod(iChannel0, V, 0.0));\n    }\n    return vec3(textureLod(iChannel0, R.Dir, 0.0));\n}\n\n\n// Borrowed from https://www.shadertoy.com/view/XsKBWD\nfloat beat() {\n  return .7 + abs(-abs(sin(iTime * 3.)) + .5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n   bool animate = (sin(iTime/2.0) < 0.0); \n   if(animate) {\n      refract_index = 1.2;\n      scale      = 5.0+5.0*beat();\n      extinction = 0.5*(1.0 + sin(iTime*6.0));\n      smoothness = beat(); // 0.5*(1.0 + sin(iTime*3.0));        \n   } else {\n      refract_index = 2.4;\n      scale = 10.0;  \n      extinction = 0.0;  \n      smoothness = 0.0;          \n   }\n    \n   float alpha = fixed_cam ? 0.0 : iTime;  \n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(20.0*s, 1.5, 20.0*c),\n       vec3(0.0, 0.0, 0.0),\n       30.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n   raytrace_mesh(R, I);\n \n   if(I.t == FARAWAY) {\n      fragColor.xyz = sky(R); \n    } else {        \n      float fresnel = 1.0 + dot(R.Dir,I.N) / length(R.Dir);\n      fresnel = clamp(fresnel, 0.0, 1.0); \n      fragColor.xyz = reflect_coeff * fresnel * sky(reflect_ray(R,I)); \n       \n      if(dispersion) {\n         // Trace three rays (red, green, blue), change refraction index\n         // for each of them.\n         float base_refract_index = refract_index;\n         Ray R0 = R;\n         Intersection I0 = I;\n         refract_index = base_refract_index;\n         float l = multi_refract(R,I);\n         float d = exp(-l * extinction);\n         float r = sky(R).r;\n         I = I0; R = R0; refract_index = base_refract_index + 0.03;\n         multi_refract(R,I); \n         float g = sky(R).g; \n         I = I0; R = R0; refract_index = base_refract_index + 0.06;\n         multi_refract(R,I); \n         float b = sky(R).b;  \n         // Assemble final color using the contributions from the\n         // red, green and blue rays.\n         fragColor.xyz += mix(core_color, vec3(r,g,b), d);\n      } else {\n         float l = multi_refract(R,I);\n         float d = exp(-l * extinction);\n         fragColor.xyz += mix(core_color, sky(R), d);\n      }       \n    }\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4433, 4516, 4552, 4552, 4577], [4579, 4662, 4697, 4697, 4836], [4838, 4874, 4897, 4897, 4952], [4954, 4991, 5015, 5015, 5148], [5342, 5342, 5405, 5405, 5703], [5705, 5705, 5742, 5742, 5845], [6080, 6080, 6109, 6109, 6176], [6178, 6178, 6224, 6224, 6268], [6270, 6270, 6342, 6342, 6404], [6406, 6738, 6868, 6868, 7224], [7226, 7364, 7421, 7421, 7897], [7900, 8000, 8116, 8116, 8404], [8406, 8552, 8604, 8604, 9405], [9409, 9485, 9541, 9541, 10195], [10197, 10197, 10217, 10217, 10574], [10577, 10632, 10646, 10646, 10695], [10698, 10698, 10755, 10755, 12657]], "test": "untested"}
{"id": "3ttSRS", "name": " -  ", "author": "totetmatt", "description": "Soyombo with special change for Valentine's Day.", "tags": ["valentine", "soyombo"], "likes": 0, "viewed": 289, "published": 3, "date": "1581664367", "time_retrieved": "2024-07-30T21:24:09.427427", "image_code": "/*Source : \n -  https://www.shadertoy.com/view/XsdyWr for the Rose Code\n -  https://www.shadertoy.com/view/Msc3WB inspiration for yin yang\n -  https://www.shadertoy.com/view/Msc3WB for the basic shape code\n -  Diverse HBHS Stream from Flopine (https://www.twitch.tv/flopine) for some GLSL tricks and the Ray March framework\n*/\n\n#define ITER 64.\n#define dtime pow(fract(iTime*.654),1.)+floor(iTime*.654)\n#define ttime sin(iTime*.8) *pow(cos(pow(iTime*.8,.125)),2.)\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// 2D matrix Rotation\n\nmat2 r(float a){return mat2(cos(a),sin(a),\n                           -sin(a),cos(a));}\n// Using a shadertoy \n// https://www.shadertoy.com/view/XsdyWr\n///\nmat3 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n    \n    return mat3(\n        c.y      ,  0.0, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    );\n} \nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s) {\nfloat ratio = 7.;\n    p*=ratio+cos(fract(iTime))* sin(fract(iTime)*2.) ;\n    s/=1.5;\n    p = p * vec3(0.8, 1.5, 0.6) + vec3(0.1, 0.0, 0.0)*ratio;\n    vec2 q = vec2(length(p.xz), p.y);\n    \n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n    \n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n    \n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region)/16.;\n}\nfloat flower(vec3 p) {\np.xy*=r(PI);\np.yz*=r(PI/12.);\np.xz*=r(iTime*.33);\n float ratio = .8;\n p*=ratio;\n \n float d = 1000., s = 2.0;\n    mat3 r = rotationXY(vec2(0.01, PI2 * 0.618034));\n    r = r * mat3(1.08,0.,max(0.0,sin(dtime)*.2) ,0.0,0.995,max(0.0,cos(dtime)*.1), 0.0,max(0.0,cos(dtime)*.1),1.08);\n    for (int i = 0; i < 24; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.001, 0.0);\n        s *= 1.05;\n    }\n    return d/ratio;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n/// Basic Shape & Operation\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdBox (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat hash21(vec2 p) {\n  p = fract(p * vec2(247.34, 961.21324));\n  p += dot(p, p + 21.87);\n  return fract(p.x * p.y);\n}\n/////////////////////\n// Scene Shape\nfloat moon(vec3 pos) {\npos .xz*=r(-iTime+PI/2.);\nfloat visible = sdCappedCylinder(pos.xyz,vec3(0.,.0,-.1),vec3(.0,.0,.1),.4);\nfloat remove = sdCappedCylinder(pos.xyz-vec3(0.,.2,.0),vec3(0.,.0,-.2),vec3(.0,.0,.2),.5);\n    return max(visible,-remove);\n    return mix(remove,visible,sin(iTime));\n}\n\n\n\n\n\n\nfloat yin(vec3 pos, float p){\n       pos.xy *= r(p);\n   \n\n   float q = pos.y >0. ? sdCappedCylinder(pos.xyz-vec3(0.,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.6 ) : 1. ;\n   float r = sdCappedCylinder(pos.xyz-vec3(0.30,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.3 );\n   float t = sdCappedCylinder(pos.xyz-vec3(-0.30,0.0,.0),vec3(0.,0.0,-.2),vec3(0.0,0.0,.2), 0.3 );\n   float v = sdCappedCylinder(pos.xyz-vec3(0.30,0.0,.0),vec3(0.,0.0,-.2),vec3(0.0,0.0,.2), 0.1 );\n  \n   return max(-v,max(-t,min(r,q)));\n}\nfloat yinyang(vec3 pos) {\n        float ratio = 2.7;\n        pos *=ratio;\n      pos.xy *= r(PI/2.);\n        pos .zy*=r(tan(sin(iTime))*.25);\n       pos .xz*=r(tan(cos(iTime*.45))*.25);\n     return min(\n       yin(pos+vec3(.0,-.05,.0),0.),\n       yin(pos+vec3(.0,+.05,.0),PI)\n    )/ratio;\n}\nfloat flame(vec3 pos) {\n\n     float ratio = 2.5;\n    pos.y -=1.6;\n    pos*=2.5;\n    float q = pos.y <0. ? sdCappedCylinder(pos.xyz-vec3(0.,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.6 ) : ratio;\n    float f = pos.y >0. ? sdRoundCone(abs(pos)-vec3(0.4+(sin(pos.y*12.+iTime)+1.)*.04,0.,0.),.1,.01,.5)  : ratio ;\n    float central_flame = pos.y > 0. ? sdRoundCone(pos-vec3(-0.025+(sin(PI/2.+pos.y*12.+iTime*.7)+1.)*.04,0.,0.),.1,.01,.8) : ratio ;\n    return opSmoothUnion(q,opSmoothUnion(central_flame,f,0.5),0.25)/ratio ;\n    return min(q,min(central_flame,f))/ratio;\n\n}\n\nfloat sideBox(vec3 pos) {\n  pos.x = abs(pos.x);\n  pos = pos-vec3(.6,.0,.0);\n  pos.xz *= r(pow(sin(pos.y*2.*PI),2.)+iTime*.1);\n return sdBox(pos,vec3(0.16,0.6,0.1));\n}\n\nfloat backflower( in vec3 p, in float c, in vec3 l )\n{\n    p*=.5;\n      vec3 id = round(p/c);\n     p.x += .25+sign(sin(4.*id.z))*sin(iTime*.16);\n   \n    p.y -= .25+sign(cos(4.*id.z))*cos(iTime*.23);\n    \n   \n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    \n    q.zx*=r(iTime*.2+length(p.xz));\n   \n    return flower(q);\n}\n\nvec2 SDF(vec3 pos) {\n     vec3 ppos = pos;\n         pos.xz*=r(cos(iTime*.9)*.2);\n      pos.yz*=r(cos(iTime*.78)*.1);\n      \n    float sideBox =sideBox(pos);\n    \n    vec3 pos_tri = pos;\n    pos_tri.xy *= r(3.141592);\n    pos_tri.xy *= vec2(.5,1.3);\n    \n    float triangle = sdTriPrism(pos_tri+vec3(0.,.67,.0),vec2(0.2,0.1));\n    float box = sdBox(pos-vec3(.0,.29,.0),vec3(0.35,0.05,0.1));\n    float box2 = sdBox(pos-vec3(.0,-.29,.0),vec3(0.35,0.05,0.1));\n    \n    float triange2 = sdTriPrism(pos_tri+vec3(0.,-.6,.0),vec2(0.2,0.1));\n    float moon = moon(pos-vec3(.0,1.05,.0));\n    \n    float yy= yinyang(pos);\n    float fl = flame(pos);\n    float flow   = flower( (pos.xzy)+vec3(.0,-.01,-1.08));\n   \n    float flowrz = backflower(pos.xzy+vec3(0.,-10.,0.),1.,vec3(4.,.1,4.));\n    \n   float dist = min(fl,min(yy,min(moon,min(min(box,box2),min(min(triange2,triangle),min(sideBox,flowrz))))));\n    dist = min(dist,flow);\n   if(dist == flow && pos.y > .75) { // A DIRTY TRICK TO REMOVE BUG\n    \treturn vec2(dist,1.0);\n   } else if (dist == flowrz){\n   \t\treturn vec2(dist,2.0);\n   } else {\n       \treturn vec2(dist,0.0);\n   }\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  // Initialization of the Ray Marching algorithm\n  vec3 ray_origin = vec3(.01,.61,-3.); // Were we start \n  vec3 ray_direction = normalize(vec3(uv,1.)); // going forward\n  vec3 position = ray_origin ; \n  \n  vec3 color = vec3(.0,.3,.6); // By default, everything will be black\n  \n  bool hit = false; \n  \n  float shad = 0.;\n  float part = 0.;\n  for(float i=0.; i<ITER; ++i) { // We iterate the ray\n  \n    vec2 _distance = SDF(position); // Find the closest distance from the current position\n    if(_distance.x <0.001) { // If we are close enough, it's a hit, we put the shad and break the loop\n        shad = i / ITER;\n        hit = true;\n        break;\n     }\n     part = _distance.y;\n      \n      float f = position.z > 0.1 ? 1.9:1.; // Speedup for background\n     \n     position += _distance.x*f * ray_direction; // Otherwise we conditnue the marching, updating the ray position\n  }\n  \n  if(hit) { \n     color = vec3(1.-shad*.766); // Yeah no real lighting here, I like the render as it is\n    if(part == 0.){\n     color = mix(vec3(1.0,0.1,.0), vec3(.9,.9,0.1)+vec3(0.,0.,length(uv)), color)*(1.-shad); \n     } else if(part== 1.) {\n        color = mix(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.4)+vec3(0.,0.,length(uv)), color)*(1.-shad);\n        color-=max(0.,sin(iTime*1.3))*vec3(.0,.3,.6);\n    } else if(part ==2.) {\n    \tcolor = mix(vec3(.0,.3,.6), vec3(.0,.3,.6), color)*(1.75-shad);   \n        \n    }\n     \n  } \n \n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[752, 752, 768, 768, 839], [840, 907, 938, 938, 1127], [1129, 1129, 1160, 1160, 1186], [1188, 1188, 1219, 1219, 1245], [1247, 1247, 1278, 1278, 1305], [1307, 1307, 1339, 1339, 1958], [1959, 1959, 1981, 1981, 2433], [2435, 2625, 2677, 2677, 2776], [2777, 2777, 2812, 2812, 2907], [2911, 2911, 2946, 2946, 2970], [2972, 2972, 3029, 3029, 3365], [3366, 3366, 3402, 3402, 3752], [3753, 3753, 3811, 3811, 4075], [4077, 4077, 4099, 4099, 4196], [4197, 4234, 4256, 4256, 4528], [4535, 4535, 4564, 4564, 5042], [5043, 5043, 5068, 5068, 5332], [5333, 5333, 5356, 5356, 5903], [5905, 5905, 5930, 5930, 6071], [6073, 6073, 6127, 6127, 6390], [6392, 6392, 6412, 6412, 7514], [7516, 7533, 7588, 7588, 9099]], "test": "untested"}
{"id": "Wt3SDj", "name": "Gold Rings", "author": "kstyler", "description": "Gold rings, rotating around a sphere.", "tags": ["noise", "raymarch", "ring", "gold"], "likes": 3, "viewed": 341, "published": 3, "date": "1581662383", "time_retrieved": "2024-07-30T21:24:10.517512", "image_code": "int mat = 0;\nfloat epsi = 0.001;\n\nfloat random(vec2 p){\n\n    vec3 p3  = fract(vec3(p.xyy) * .10031);\n    p3 += dot(p3, p3.yyx + 33.33);\n    return fract((p3.x + p3.y) );\n}\nfloat noise(vec2 uv){\n\n    vec2 id = floor(uv*8.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*8.));\n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n    \n}\n\nfloat octaves(vec2 uv,int octs){\n\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<octs+1;i++){\n        f+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n   \n    return f;\n}\nmat2 rot(float a){\n    return mat2(sin(a),-cos(a),cos(a),sin(a));\n}\nfloat sdSphere(vec3 p){\n    return length(p)-1.;\n}\nfloat sdRCyl( vec3 p, float ra, float rb, float h ){\n  \n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRing(vec3 p,float size,mat2 rotate){\n    p.zy*=rotate;\n    float or =  sdRCyl(p,size,0.,0.4);\n    float ir =  sdRCyl(p,size+0.1,0.,0.3);\n    return (max(-or,ir));\n}\nfloat sdRing2(vec3 p,float size,mat2 rotate){\n    p.xy*=rotate;\n    float or =  sdRCyl(p,size,0.,0.4);\n    float ir =  sdRCyl(p,size+0.1,0.,0.3);\n    return (max(-or,ir));\n}\n\nfloat map(vec3 p){\n\n    float sphere = sdSphere(p);\n   \n \n    \n    float ring = sdRing(p,0.85,rot(iTime));\n    float ring2 = sdRing2(p,0.65,rot(iTime));\n    float ring3 = sdRing(p,1.1,rot(-iTime));\n     //p.y+=(sin(length(p.xz*0.9)-iTime*3.)*.5);\n          float plane = p.y +3.5;\n    \n    float best = min(min(min(min(sphere,plane),ring),ring2),ring3);\n    if(best == sphere){\n        mat = 1;\n    } else if(best == plane){\n        mat = 2;\n    } else if(best == ring || best == ring2||best == ring3 ) {\n        mat = 3;\n    }else{mat = 4;}\n    return best;\n}\nvec3 normal(vec3 p){\n    vec2 e = vec2(epsi,0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                        map(p+e.yxy)-map(p-e.yxy),\n                        map(p+e.yyx)-map(p-e.yyx)));\n}\n\nfloat tr(vec3 ro,vec3 rd){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i< 180; i++){\n        dst = map(ro+rd*tot);\n        tot+=dst;\n        if(dst <epsi||tot>180.)break;\n    }\n    \n    if(dst >epsi){\n        mat = 0;\n    }\n    return tot;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5* iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(2,-1.5,-9);\n    vec3 rd = normalize(vec3(uv,1));\n    ro.zy*=rot(2.1);\n    rd.zy*=rot(2.1);\n    ro.zx*=rot(iTime);\n    rd.zx*=rot(iTime);\n    vec3 color = vec3(1);\n    \n    for(int i =0;i<7;i++){\n        vec3 p = (ro+rd*tr(ro,rd));\n       \n      \n        if(mat == 0){\n        \n          \n            uv.x+=iTime/60.;\n            uv.x*=0.7;\n            color *= vec3(octaves(uv,9)+0.5);\n     \n            \n           \n        }if(mat == 1){\n         vec3 n = normal(p);\n           float fresnel = pow(1.-dot(- rd,n),5.);\n            color*= fresnel;\n               ro = p+1.;\n                rd = reflect(rd,n);\n        }\n        if(mat == 2){\n         vec3 n = normal(p);\n            color*= vec3(0.25,0.3,0.3);\n              ro = p+1.;\n            rd = reflect(rd,n);\n        }\n        if(mat ==3){\n         vec3 n = normal(p);\n            color *= vec3(0.9,0.7,0.3);\n               ro = p+1.;\n        rd = reflect(rd,n);\n        }\n \n    }\n\n   \n    fragColor = vec4((color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3SDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 55, 55, 171], [172, 172, 193, 193, 535], [537, 537, 569, 569, 728], [729, 729, 747, 747, 796], [797, 797, 820, 820, 847], [848, 848, 900, 900, 1023], [1024, 1024, 1068, 1068, 1196], [1197, 1197, 1242, 1242, 1370], [1372, 1372, 1390, 1390, 1932], [1933, 1933, 1953, 1953, 2139], [2141, 2141, 2167, 2167, 2397], [2400, 2400, 2454, 2454, 3520]], "test": "untested"}
{"id": "3lcXWj", "name": "Voronoi Triangulation*", "author": "wyatt", "description": "How my recent simulations work.", "tags": ["voronoi", "triangulation"], "likes": 16, "viewed": 575, "published": 3, "date": "1581661774", "time_retrieved": "2024-07-30T21:24:11.453011", "image_code": "#define R iResolution.xy\n#define O 3.\nvec2 hash22(vec2 p) // Dave H\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 cell (vec2 u) {\n\tvec2 V = floor(u*O+0.5)/O;\n    vec2 h = hash22(V);\n    return V + h.x*vec2(cos(6.2*h.y+iTime),sin(6.2*h.y+iTime))/O;\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    //if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n}\nfloat line (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nvec2 cc (vec2 a, vec2 b, vec2 c) {\n    vec2 ab = 0.5*(a+b), ac = 0.5*(a+c);\n\tfloat m1 = (a.x-b.x)/(b.y-a.y), m2 = (a.x-c.x)/(c.y-a.y);\n    float b1 = ab.y-m1*ab.x, b2 = ac.y-m2*ac.x;\n    float x = (b1-b2)/(m2-m1);\n    return vec2(x,m1*x+b1);\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn length(p-a-(b-a)*i);\n}\nfloat tri (vec2 U, vec2 a, vec2 aa, vec2 aaa) {\n    vec2 m = cc(a,aa,aaa);\n    float v = length(a-m), w = length(U-m);\n    return w-v;\n}\nvoid mainImage (out vec4 Q, vec2 U) {\n\tU = 2.*(U-0.5*R)/R.y;\n    vec2 V = vec2(1e3);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n\t\tvec2 c = cell(U+vec2(x,y)/O);\n        if (length(c-U) < length(V-U))\n            V=c;\n    }\n    vec2 W = vec2(1e3);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n\t\tvec2 c = cell(U+vec2(x,y)/O);\n        if (pie(U,V,c) < pie(U,V,W))\n            W=c;\n    }\n    vec2 Z = vec2(1e3);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n\t\tvec2 c = cell(U+vec2(x,y)/O);\n        if (tri(U,V,W,c) < tri(U,V,W,Z))\n            Z=c;\n    }\n    \n    Q = 0.5+0.3*sin(30.*(tri(U,V,W,Z))+vec4(1,2,3,4));\n\tQ *= smoothstep(0.01,0.02,pie(U,W,V)*length(W-V));\n    Q += vec4(.5)*smoothstep(0.03,0.00,min(line(U,W,V),min(line(U,W,Z),line(U,V,Z))));\n    Q *= smoothstep(0.03,0.04,length(U-V));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 69, 69, 203], [204, 204, 224, 224, 344], [345, 345, 381, 381, 524], [525, 525, 562, 562, 649], [650, 650, 684, 684, 893], [894, 894, 929, 929, 1014], [1015, 1015, 1062, 1062, 1151], [1152, 1152, 1189, 1189, 2021]], "test": "untested"}
{"id": "Wl3SWj", "name": "Notebook Cover", "author": "cacheflowe", "description": "Notebook starter for Joel", "tags": ["pattern", "notebook"], "likes": 0, "viewed": 49, "published": 3, "date": "1581658829", "time_retrieved": "2024-07-30T21:24:12.294760", "image_code": "\n\n// noise function\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// pattern calculations\n\nfloat patternForPos(vec2 uv, float reso, float time) {\n    float timeOsc = sin(time) * 0.15;\t\t\t\t\t\t\t\t// oscillation helper\n    float dist = 0.;\t\t\t\t\t\t\t\t\t\t\t\t// start distance count from 0\n    uv *= 1. + noise(-uv * 0.001)/20.;\t\t\t\t\t\t\t\t// adjust incoming uv w/noise\n    for(float i=10.; i < 30.; i++) {\t\t\t\t\t\t\t\t// create x control points\n        float rads = timeOsc + i;\t\t\t\t\t\t\t\t\t// get rads for control point\n        vec2 ctrlPoint = vec2(cos(rads), sin(rads));\t\t\t\t// control points in a circle \n        ctrlPoint *= abs(cos(rads)) * 185.;\t\t\t\t\t\t\t// oscillate control point radius - the magic happens w/abs()\n        dist += sin(i + reso * distance(uv, ctrlPoint));\t\t\t// sum up oscillated distance between control points\n    }\n    return dist;\n}\n\n// rotation helper\n\nvec2 rotateCoord(vec2 uv, float rads) {\n    uv *= mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n\treturn uv;\n}\n\n// main program\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime / 200.;\n    \n    // grab postion and rotate per layer\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    \n    // translate zoom\n    float zoom = 12.;\n    uv *= zoom;\n        \n    // create more UV coords that are rotated from original zoomed UV\n    vec2 uv2 = rotateCoord(uv + time + noise(uv/10.), time + 0.2);\n    vec2 uv3 = rotateCoord((uv - time + 1.) - noise(uv/5.), time + 0.3);\n    vec2 uv4 = rotateCoord((uv + time + 1.) - noise(uv/1.), time + 0.1);\n    uv3 *= 1.1;\n    uv4 *= 1.9;\n    \n    // create pattern at different resolutions via different uv coords\n\tfloat col = patternForPos(uv, 4., time);\n\tfloat col2 = patternForPos(uv2, 8., time);\n\tfloat col3 = patternForPos(uv3, 3., time);\n\tfloat col4 = patternForPos(uv4, 5., time);\n    \n    // average uv components\n    float avgColor = (col + col2 + col3 + col4) / 4.;\n    \n    // draw final pattern\n    vec3 color = vec3(smoothstep(0.7, 0.8, avgColor)); // threshold/antialias, weighted to black\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3SWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 41, 41, 108], [110, 110, 130, 130, 337], [364, 364, 418, 418, 1103], [1125, 1125, 1164, 1164, 1239], [1258, 1258, 1315, 1315, 2370]], "test": "untested"}
{"id": "wldXWB", "name": "Wedge - distance 2D", "author": "iq", "description": "Distance to a wedge. Use the mouse to move the apex.", "tags": ["2d", "distancefield", "sdf", "primitive"], "likes": 7, "viewed": 641, "published": 3, "date": "1581656656", "time_retrieved": "2024-07-30T21:24:13.413769", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a wedge.  Use the mouse to move the apex.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdWedge( in vec2 q, in vec2 a, in vec2 c, in vec2 b )\n{\n    q -= c, a -= c, b -= c;\n\n    return \n    // distance\n    sqrt(min( dot2(q-a*clamp(dot(q,a)/dot(a,a),0.0,1.0)),\n              dot2(q-b*clamp(dot(q,b)/dot(b,b),0.0,1.0)) )) * \n    // sign                                  \n    sign(max( cro2(a,q),\n              cro2(q,b) ));\n}\n\nvec2 cossin( in float r )\n{\n    return vec2(cos(r),sin(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float t = 1.0 + 0.1*iTime;\n\tvec2 a = cossin(0.0*t) * 0.5;\n\tvec2 b = cossin(1.0*t) * 0.5;\n\tvec2 c = cossin(2.0*t) * 0.5;\n    \n    // Make sure our geometry has the right winding order.\n    // This line of code would never exist in reality since the\n    // right winding order can be ensured at modeling/editing\n    // time - it doesn't need to happen at runtime.\n    if( cro2(a-b,c-b)>0.0 ) { vec2 tmp=a;a=c;c=tmp; }\n    \n    // distance\n    float d = sdWedge(p,a,b,c);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdWedge(m, a,b,c);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXWB.jpg", "access": "api", "license": "mit", "functions": [[1266, 1266, 1291, 1291, 1310], [1311, 1311, 1347, 1347, 1375], [1377, 1377, 1438, 1438, 1717], [1719, 1719, 1746, 1746, 1780], [1782, 1782, 1839, 1875, 2990]], "test": "untested"}
{"id": "ttdXDB", "name": "Triangulated Actors*", "author": "wyatt", "description": "Triangulated particle simulation ", "tags": ["particles", "triangulation"], "likes": 24, "viewed": 512, "published": 3, "date": "1581656650", "time_retrieved": "2024-07-30T21:24:14.715288", "image_code": "// Fork of \"Triangulated Actors\" by wyatt. https://shadertoy.com/view/tltSW8\n// 2020-02-14 04:50:44\n\nMain {\n    vec4 bb = B(U), cc = C(U), dd = D(U),\n         a = A(bb.xy), b = A(cc.xy);\n    float s = sign(bb.x-0.5*R.x);\n    vec4 col = vec4(s,-0.5*s,-s,1);\n    float r = 8.;\n    if (bb.y>0.4*R.y) {r*=1.5;col=vec4(0.8,1,0,1);}\n    \n    float l = length(U-a.xy),\n        j = smoothstep(r,r-1.,l);\n   \tQ = vec4(j)*col;//*max(0.6+0.4*sin(.3+(.1*cc.x/R.x+cc.y+1./(1.+10.*length(dd.zw))*vec4(1,2,3,4))),0.);\n\tfloat o = smoothstep(2.,0.,sg(U,a.xy,b.xy));\n    Q = 5.*Q*o*(1.-o);\n    //Q += smoothstep(2.,1.,mp(U,a.xy,b.xy)*length(a.xy-b.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "// Information Storage\nMain {\n\tQ = A(U);\n    if (iMouse.z>0.) {\n        vec2 r = (iMouse.xy-Q.xy);\n        Q.zw -= 1e3*r/dot(r,r)/length(r);\n    }\n   \tif (iFrame > 10) \n    Q.zw -= D(Q.xy).zw;\n    if (U.y>0.4*R.y) Q.w -= 1e-2;\n    if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n    Q.xy += Q.zw;\n    \n\n    if (Q.x<2.) {Q.x = 2.; Q.z *= -1.;}\n    if (R.x-Q.x<2.) {Q.x = R.x-2.; Q.z *= -1.;}\n    if (Q.y<2.) {Q.y = 2.; Q.w *= -1.;}\n    if (R.y-Q.y<2.) {Q.y = R.y-2.; Q.w *= -1.;Q.z*=0.;}\n    \n    if(Q.y<25.)Q.w += 1.;\n    if(Q.x<25.)Q.z += 1.;\n    if(R.x-Q.x<25.)Q.z -= 1.;\n    if(R.y-Q.y<25.)Q.w -= 1.;\n    if (init)\n    {\n    \tU = floor(U/15.+0.5)*15.;\n        Q = vec4(clamp(U,vec2(3),R-3.),0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, inout vec4 a, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, vec2 U, float r) {\n\t X(Q,a,U,vec2(r,0));\n     X(Q,a,U,vec2(0,r));\n     X(Q,a,U,vec2(0,-r));\n     X(Q,a,U,vec2(-r,0));\n}\nMain {\n\tQ = B(U);\n    vec4 a = A(Q.xy);\n    Xr(Q,a,U,1.);\n    Xr(Q,a,U,2.);\n    Xr(Q,a,U,3.);\n    Xr(Q,a,U,4.);\n   \tInit {\n    \tQ.xy = A(U).xy;\n        Q.zw = vec2(0.);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Nearest Normalized Bisector\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, vec2 r) {\n    vec4 Qn = C(U+r), qn = B(U+r), na = A(qn.xy), nb = A(Qn.xy);\n   \tfloat l = mp(U,a.xy,b.xy);\n    \n    if (mp(U,a.xy,na.xy)<l) {\n    \tQ = qn;\n        b = na;\n    }\n    if (mp(U,a.xy,nb.xy)<l) {\n        Q = Qn;\n        b = nb;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, float r) {\n\t X(Q,a,b,U,vec2(r,0));\n     X(Q,a,b,U,vec2(0,r));\n     X(Q,a,b,U,vec2(0,-r));\n     X(Q,a,b,U,vec2(-r,0));\n}\nMain {\n\tQ = C(U);\n    vec4 q = B(U),\n         a = A(q.xy),\n         b = A(Q.xy);\n    Xr (Q,a,b,U,1.);\n    Xr (Q,a,b,U,2.);\n    Xr (Q,a,b,U,3.);\n    Xr (Q,a,b,U,4.);\n    \n    vec2 r = b.xy - a.xy;\n    float s = sign((Q.x-0.5*R.x)*(q.x-0.5*R.x));\n    if (Q.y>0.4*R.y) s = 0.3*(s);\n    if (q.y>0.4*R.y) s = 0.3*(s);\n    if (length(r)>0.&&length(b.xy)>0.) \n    Q.zw = \n        s*r/dot(r,r)+\n        abs(s)*100.*r/dot(r,r)/dot(r,r) - \n        abs(0.1*dot(b.zw-a.zw,r))*(b.zw-a.zw)*exp(-0.04*dot(r,r));\n    \n    Init {\n        Q = A(U);\n    \tQ.zw = vec2(0);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Sum the forces\nMain {\n\tQ = vec4(0);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n    \tvec2 r = vec2(x,y);\n        Q += C(U+r)*exp(-.5*dot(r,r));\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ldSDB", "name": "Day 56", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 5, "viewed": 405, "published": 3, "date": "1581631484", "time_retrieved": "2024-07-30T21:24:15.620868", "image_code": "// simple volumetric raymarching of voronoi\n\n// Inspired by izuix's Blender render on Fractal Discord\n\n// If slow uncomment slowdetail in buffera or click on screen\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.004).x;\n    fragColor.y = T(uv -f*0.004).y;\n    fragColor.z = T(uv).z;\n    fragColor = mix(fragColor, smoothstep(0.,1.,fragColor), 0.4);\n    fragColor *= 2.2;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime (iTime + 3.)\n// do not use texture\n#define FULL_PROCEDURAL\n#define LOWDETAIL\n\n\n#ifdef FULL_PROCEDURAL\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n#else\nvec3 hash( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n// voronoi code from inigo quilez\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n//#define mx (iTime + 40.*iMouse.x/iResolution.x)\n#define mx (iTime )\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) (a + b*sin(tau*(c*d + e)))\n\nvec3 density(vec3 p){\n\tvec3 d = vec3(0);\n    vec3 q = p;\n    q.z += mx;\n    #define pi acos(-1.)\n    for (int i = 0; i < 3; i++){\n    \tq = abs(q);\n    \tq.xy *= rot(0.25*pi);\n        q.yz *= rot(0.3);\n    }\n    //q *= 1. - length(q)*0.002;\n    \n    vec3 v = voronoi(q);\n    #define tau (2.*pi)\n    \n    //#define cPal(a, b) pal(0.6,vec3(1.,1.,1.)*0.8,vec3(6.87,4.4,1.8), a , b)\n    #define cPal(a, b) pal(0.9,vec3(1.,1.,1.)*0.8,vec3(6.87,4.4,1.8), a , b)*0.5\n    vec3 lA = vec3(-1,2,7);\n    vec3 lCA = vec3(0,1,1);\n    \n    lCA = cPal(0.1, iTime*0.1 + 0.4);\n\n    vec3 lB = vec3(1,-02,5. );\n    vec3 lCB = vec3(1,0,1);\n    lCB = cPal(0.1, iTime*0.08);\n    vec3 lC = vec3(1,2,5);\n    vec3 lCC = vec3(3,2,1);\n    lCC = cPal(0.1, iTime*0.14 + 0.2);\n    \n\tfloat c = smoothstep(0., 0.01,v.x - 0.71 + sin(iTime*0.6)*0.0);\n    \n    float attenA = 2./(length(p-lA)*length(p-lA));\n    float attenB = 2./(length(p-lB)*length(p-lB));\n    float attenC = 2./(length(p-lC)*length(p-lC));\n    attenB = min(attenB, 1.);\n    attenA = min(attenA, 1.);\n    attenC = min(attenC, 1.);\n    d += c * attenA*lCA;\n    d += c * attenB*lCB;\n    d += c * attenC*lCC;\n    //d += c * attenB*lCB;\n    \n    \n    d -= vec3( pow(v.y*0.98, 20.))*0.4*cPal(0.5, 0.1 + iTime*0.1);\n    \n    \n    d *= 2.;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + length(uv)*0.2;\n    \n    vec3 col = vec3(0);\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    rd.xy *= rot(sin(iTime*0.1)*0.1);\n    rd.yz *= rot(sin(iTime*0.1)*0.1);\n    \n    #define iters (400. - 400.*iMouse.x/iResolution.x)\n    vec3 p = ro;\n    \n    vec3 accum = vec3(0);\n    for(float i = 0.; i < iters; i++){\n    \t#ifdef LOWDETAIL\n    \t\tp += 0.06*rd;\n        #else \n        \tp += 0.03*rd;\n        #endif\n        vec3 d = density(p);\n        accum += d;\n    }\n    \n    accum *= 0.014;\n    \n    //accum /= iters;\n    \n    col += accum;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 260, 260, 531]], "test": "untested"}
{"id": "3ttSDB", "name": "Show Business", "author": "hanabi", "description": "work in progress", "tags": ["rain"], "likes": 1, "viewed": 239, "published": 3, "date": "1581630980", "time_retrieved": "2024-07-30T21:24:16.568334", "image_code": "#define PI 3.14159265358979323846\n\nfloat rand1(in float f)\n{\n    return fract(sin(f)*100000.0);\n}\n\nfloat random(in vec2 _st)\n{\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n//  Function from Iigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float fFrame = float(iFrame);\n    \n    fragColor = vec4(hsb2rgb(vec3(0.7, 0.6, uv.y / 1.4)), 1.0);    \n    \n    float WIDTH = iResolution.x / 4.;\n    for (float i = 0.; i < WIDTH; i++) {\n        // radius of a ball\n        float r = 10.;\n        float hspace = iResolution.x / WIDTH;\n        // some dancing, some horizontal space\n        float x = iResolution.x / 60.0 * sin(PI / 180. * fFrame) + hspace * i - hspace  * rand1(i);\n        float movement = fFrame * iResolution.y / 360.;\n        // movement, some vertical space\n        float y = movement + iResolution.y * rand1(i);\n        \t  y = mod(-abs(y), iResolution.y + r);\n\n        vec2 ball = vec2(x, y);\n        vec2 ballDist = fragCoord - ball;\n\n        fragColor = mix(fragColor, vec4(hsb2rgb(vec3(0.20, .9, .9)), 1.0),\n                        1.-smoothstep(\n                            ball.y / 10., ball.y / 2.,\n                            dot(ballDist, ballDist)));\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 60, 60, 97], [99, 99, 126, 126, 202], [204, 278, 306, 306, 538], [541, 541, 598, 598, 1583]], "test": "untested"}
{"id": "3ttXDS", "name": "fn frac 3", "author": "anttikan", "description": "Composition using a randomly generated function that maps x, y, and time to color values. The fractional approach demonstrated here (https://www.shadertoy.com/view/lsl3RH) is used.", "tags": ["2d", "abstract"], "likes": 2, "viewed": 279, "published": 3, "date": "1581624447", "time_retrieved": "2024-07-30T21:24:17.694324", "image_code": "\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat noise( float x, float y )\n{\n    \n    vec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat proc(vec2 p, float iTime){\n    float x = p.x;\n    float y = p.y;\n    return (log(abs((pow((sqrt(pow(sign((sqrt(pow(((noise((sqrt(pow(((x)+(x)),2.0)+pow(((x)-(sin(iTime/0.966987073505152 + 0.6111521249421139))),2.0))),(sin(iTime/0.4363697787300387 + 0.12117539940795363)))/ (abs(noise((sin(iTime/0.5158599562708615 + 0.16600295224153383)),sin(((sin(iTime/0.6756154310519074 + 0.21928104695785633))-(y)))))+0.0001))/ (abs(pow((sqrt(abs(abs((sin(iTime/0.10046810537438944 + 0.16472793169855549))) - floor(abs((sin(iTime/0.06664122762711977 + 0.15718604023595528))))))*sqrt(abs((sin(iTime/0.4570874330557644 + 0.8750506328606864))))),3.0))+0.0001)),2.0)+pow((x),2.0)))),2.0)+pow(((sin((((pow((sin(iTime/0.9411628721004033 + 0.7970329359978641)),2.0)*pow((x),3.0))/ (abs((x))+0.0001))+(y)))-((sqrt(pow(sin(sin(((y)*(y)))),2.0)+pow((abs(noise((x),(y))) - floor(abs(noise((x),(y))))-sqrt(abs(sign((sin(iTime/0.31979339437329113 + 0.6727109187652756)))))),2.0)))-(y)))*pow(((x)+cos(sign(sqrt(abs((sqrt(pow((y),2.0)+pow((y),2.0)))))))),3.0)),2.0))),3.0)+((sqrt(pow(noise(log(abs(pow(log(abs((((y)+(sin(iTime/0.6262793977377104 + 0.19748571464784503)))-(sqrt(pow(((y)/ (abs((x))+0.0001)),2.0)+pow(((x)/ (abs((x))+0.0001)),2.0)))))+0.0001),2.0))+0.0001),sin(sin(((y)+(y))))),2.0)+pow(((sin(iTime/0.16396662366658754 + 0.27674858164238003))-sqrt(abs(((sqrt(pow(((sin(iTime/0.2834978288486667 + 0.5743516223794598))+(sin(iTime/0.15568232361922707 + 0.7840086800987247))),2.0)+pow(sqrt(abs((x))),2.0)))*(sin((sqrt(pow(((y)+(y)),2.0)+pow(pow((y),3.0),2.0))))/ (abs(((sqrt(pow(abs((sin(iTime/0.21214125730436129 + 0.15950010259741676))) - floor(abs((sin(iTime/0.23599852758426532 + 0.8305195272596266)))),2.0)+pow(sign((y)),2.0)))-sign((y))))+0.0001)))))),2.0)))*abs(sin(pow(cos(sin(sin((((y)-(sin(iTime/0.09431146868556373 + 0.24818217157847644)))/ (abs(sqrt(abs((sin(iTime/0.037376425340919894 + 0.43268205672704463)))))+0.0001))))),3.0))) - floor(abs(sin(pow(cos(sin(sin((((y)-(sin(iTime/0.27702937544993445 + 0.797806488383189)))/ (abs(sqrt(abs((sin(iTime/0.7390386126490491 + 0.7347386838432937)))))+0.0001))))),3.0)))))))+0.0001)+(sqrt(pow(sin((y)),2.0)+pow(pow(exp(((abs(((sin(iTime/0.14356340742759954 + 0.7790959326773577))/ (abs(pow(pow((sqrt(pow(((x)+(y)),2.0)+pow(sin((sin(iTime/0.6612596860985003 + 0.11710398818870238))),2.0))),2.0),2.0))+0.0001))) - floor(abs(((sin(iTime/0.4870341755973422 + 0.6541018216662755))/ (abs(pow(pow((sqrt(pow(((x)+(y)),2.0)+pow(sin((sin(iTime/0.825267914962508 + 0.027399235966053315))),2.0))),2.0),2.0))+0.0001))))/ (abs(sign((sin(iTime/0.4859768935419986 + 0.23220255975823956))))+0.0001))/ (abs(sin((log(abs((sin(iTime/0.670649400313476 + 0.8547119247089336)))+0.0001)/ (abs(cos(cos(cos((y)))))+0.0001))))+0.0001))),3.0),2.0))));\n}\n\nfloat pixelfunc(float x, float y, float iTime) {\n\tvec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*proc( p, iTime )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*proc( p, iTime )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*proc( p, iTime )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*proc( p, iTime )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*proc( p, iTime )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*proc( p, iTime ));\n    return f/0.96875;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    \n        \n    float x = p.x*(0.4 + 0.2*cos(iTime*0.1 + 10.0)) + sin(iTime*0.12 + 10.0);\n    float y = (0.4+0.2*cos(iTime*0.1 + 10.0))*p.y; // p.y*0.2; //\n    float t = iTime*0.2+12.0;\n    \n    float shade = pixelfunc(x, y, t);\n    float mapped_shade = map(shade,-3.0, 3.0, 0.0, 1.0);\n    \n    \n    vec3 col = mix( vec3(0.1,0.6,0.8), vec3(0.1,0.3,0.5), mapped_shade );\n    col = vec3(mapped_shade) - vec3(0.1, 0.1, 0.2);\n    \n    \n    \n    \n \tvec3 nor = normalize( vec3( pixelfunc(x+e,y,t)-shade, \n                                2.0*e,\n                                pixelfunc(x,y+e,t)-shade ) );\n\n    vec3 lig = normalize( vec3( 0.8, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.25,0.4,0.95)*(nor.y*0.5+0.5) + vec3(0.9,0.30,0.2)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 76, 76, 105], [107, 107, 140, 140, 522], [525, 525, 557, 557, 3293], [3295, 3295, 3343, 3343, 3753], [3756, 3756, 3828, 3828, 3912], [3914, 3914, 3971, 3971, 4997]], "test": "untested"}
{"id": "WtdXWS", "name": "Eggs", "author": "avin", "description": "visual experiment", "tags": ["2d", "circles"], "likes": 12, "viewed": 405, "published": 3, "date": "1581623793", "time_retrieved": "2024-07-30T21:24:18.548041", "image_code": "#define SIZE 10.0 \n#define COL1 vec3(32, 43, 51) / 255.0 \n#define COL2 vec3(235, 241, 245) / 255.0 \n\n#define SF 1./min(iResolution.x,iResolution.y)*SIZE*.5\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;    \n        \n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;              \n    \n    float mask = 0.0;    \n    for(float y =- 1.0; y <= 1.0; y++ ) {\n        for(float x =- 1.0; x <= 1.0; x++ ) {\n            vec2 rid = id - vec2(x, y);\n            vec2 ruv = uv + vec2(x, y) + \n                vec2(0, mod(rid, 2.)*.5) + \n                vec2(0, sin(simplex_noise(vec3(rid*0.5, iTime))*5.)*.1);            \n                        \n            float l = length(ruv);            \n                                           \n            float d = SS(l, .65) * (ruv.y+.5);      \n                        \n            mask = max(mask, d);                       \n        }\n    }\n    \n    vec3 col = vec3(1.0);\n    col = mix(COL1, COL2, abs(mask));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 258, 258, 378], [380, 380, 402, 402, 554], [556, 556, 585, 585, 1249], [1252, 1252, 1308, 1308, 2176]], "test": "untested"}
{"id": "wl3XDB", "name": "Very Cool RayTracer", "author": "jamesgriffiths01", "description": "Very cool RayTraced sphere for Sajid", "tags": ["ray", "sphere", "raytrace"], "likes": 2, "viewed": 304, "published": 3, "date": "1581614440", "time_retrieved": "2024-07-30T21:24:19.390788", "image_code": "float sphereIntersect(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n    vec3 rc = ray-center;\n    float c = dot(rc, rc) - (radius * radius);\n    float b = dot(dir, rc);\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t,d));\n    return mix(-1.0, t, st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // units are in mm\n    vec3 sphereCenter = vec3(0.0, 0.0, 10.0);\n    float sphereRadius = 2.0f;\n    \n    vec3 cameraCenter = vec3(0.0, 0.0, -3.0);\n    float imagePlaneDist = 1.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // turn uv from 0-1 to -1-1\n    vec2 newUV = (uv * 2.0) - 1.0;\n    newUV.x *= iResolution.x / iResolution.y;\n    \n    vec4 image = texture(iChannel0, uv);\n    \n    vec3 ray = cameraCenter * imagePlaneDist;\n    \n    vec3 imagePlanePixel = vec3(newUV.x, newUV.y, cameraCenter + imagePlaneDist);\n    \n    vec3 rayDir = normalize(imagePlanePixel - ray);\n    \n    float t = sphereIntersect(ray, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 hitPoint = ray + rayDir * t;\n    \n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 hitNormal = sphereCenter - hitPoint;\n    \n    vec3 lightPos = vec3(-10.0, -10.0, 10.0);\n    \n    float lightLambert = max(dot(hitNormal, normalize(lightPos - hitNormal)), 0.0);\n    \n    vec3 sphereCol = vec3(0.1, 0.25, 1.0);\n    sphereCol *= lightLambert;\n    image *= lightLambert;\n    \n    // Output to screen\n    fragColor = vec4(image * t);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 70, 70, 294], [296, 296, 353, 376, 1504]], "test": "untested"}
{"id": "tl3XDB", "name": "RandomSamplingTest", "author": "ThomasSchander", "description": "Testing sampling patterns for a sphere", "tags": ["sampling"], "likes": 3, "viewed": 287, "published": 3, "date": "1581613571", "time_retrieved": "2024-07-30T21:24:20.172697", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = textureLod(iChannel0, uv, 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 311]], "test": "untested"}
{"id": "tt3SWB", "name": "[TWITCH] Pounding Aldebaran", "author": "evvvvil", "description": "Pounding Aldebaran\nResult of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["noise", "terrain", "demoscene", "light", "particles", "planet", "landscape", "glow", "ripple", "point", "core", "twitch", "improv", "interstellar"], "likes": 52, "viewed": 3046, "published": 3, "date": "1581608706", "time_retrieved": "2024-07-30T21:24:21.086254", "image_code": "// Pounding Aldebaran - Result of an improvised live coding session on Twitch\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"People who do not know how to laugh are always pompous and self-conceited.\" - William Makepeace Thackeray\n\nvec2 z,v,e=vec2(.0035,-.0035); float t,tt,bb,b,b2,g,g2,td,cn,texNoi; vec3 pp,po,no,ld,al,lp; //global vars: same old garbage, just like any Coldplay album.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function, yeah I know it's boring but then so is sitting next to you at a Wedding.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like the meaningless chat we're gonna have at that wedding.\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} // Smooth merge - Merging geometry softly. Bit like a wedding actually, you know, being an excuse for two people eventually physically merging.\nfloat noi(vec3 p){ // Noise function. I don't really understand any of this, I was so bored at that wedding that I spent all my neurones on halucinagenics, so much so I even forgot how to spell halucinogenics\n  vec3 f=floor(p),s=vec3(7,157,113); \n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nvec2 pounder( vec3 p )\n{ //Phallic symbol incoming, why be subtle when you can litterally fuck a planet's core? You're just not ambitious enough broski: I once fucked the sea.\n  pp=abs(p+vec3(0,-6.,0))-vec3(0,5.+bb,0); //make new position pp out of p for the half spheres, abs symetry along y and animate. Give it some serious pumping action (that's what she said)\n  vec2 h,t=vec2(length(pp)-2.2,6.); //WHITE SPHERE soon to be slashed in half, just like public services funding under Boris Johnson.\n  t.x=abs(t.x)-.3; //Onion trick to make the sphere hollow, carving holes basically, this time with math rather than the smallest part of your body.\n  t.x=max(t.x,-pp.y); //Slash sphere in half and reveal it hollow, just like those brexit promises. \n  h=vec2(length(pp)-2.2,3.); //BLACK SPHERE soon to be slashed in half, just like the UK's international reputation under Boris Johnson.\n  h.x=abs(h.x)-.1; //Onion trick to make the sphere hollow, with smaller radius so it creates edge.\n  h.x=max(h.x,-pp.y-.5); //Slash sphere in half and reveal it as a hollow, just like those brexit promises. \n  pp.xz*=r2(1.2+sin(p.y*(1.-0.07*bb))*.5); // reusing pp as new position for splines, rotate and twist a bit.\n  h.x=min(h.x,bo(abs(abs(pp)-vec3(0.5,0.0,.6))-vec3(1,0,0.3),vec3(0.2,20.0,0.15))); //BLACK SPLINES Made out of couple of abs symetry cloning a bunch of fucking boxes.\n  t=t.x<h.x?t:h; //Merge all geometries from both black and white materials. There is an interratial sex joke to be made here but I'm too scared of offended millenials.\n  t.x=max(t.x,-(length(p.xz)-1.)); //HOLE IN MIDDLE, digs hole through both half spheres, letting the blue core through it. Noone will hear you scream in space but there is still time for sexual inuendos \n  h=vec2(bo(abs(abs(pp)-vec3(0.5,0.0,.6))-vec3(1,0,0.3),vec3(0.3,20.0,0.01)),6.); //GLOW SPLINES Made out of couple of abs symetry cloning a bunch of fucking boxes.\n  g+=0.1/(0.1+h.x*h.x*(150.-sin(p.y*0.5+tt*2.)*149.)); //First glow, making the splines above glow and sweeping the glow along Y axis. It's like building fireworks but without the fun of burning things.\n  t=t.x<h.x?t:h; //Merge the glow splines with the rest. Like putting fairy lights around your room to pretend you are not the twisted fucker your neighbour knows you are.\n  h=vec2(  length(p.xz+texNoi*2.5)-(.5+0.2*sin(p.y*2.+tt*2.)),5.); //BLUE CORE, inifinte cylinder with bit of displacement along y and reusing texNoi for crunchy effect.\n  g2+=0.1/(0.1+h.x*h.x*(5.-sin(p.y*0.5+tt*2.-0.5)*4.9)); //Second glow, making blue core glow and sweeping along y axis with a bit of an offset so it comes in a little after white.\n  t=t.x<h.x?t:h; t.x*=0.9; //Merge the core with rest and tweak distance field a bit to avoid artifact (t.x*=0.9)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nfloat texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return f*.45+.05;\n}// We miss you on Twitch Luna... Sending some love.\nvec2 mp( vec3 p )\n{ \n  texNoi=texNoise(0.35*vec2(p.y,dot(p.xz,vec2(.7))))*.2; //texture based noise with naive triplanar uvs, adds really nice tiny crunchy details hard to recreate with a 3d noise function\n  td=noi(p*.2+1.5)*4.-noi(p*2.-.5)*.1-noi(p*.05)*2.+noi(p*.03)*5.-noi(p*.5)+texNoi; //td = terain displacement = a whole bunch of noise calls at different scales to create natural terrain. Bit like jamming your fingers in the socket and getting out an expensive haircut.\n  float ripple=sin(5.*(length((p.xz+vec2(2,2))*.7)-(0.2))-tt*10.)*0.5*b2; //Ripple motion for the pounding.\n  pp=p+td;//Make new position pp for terrain and add all the noise to displace it.\n  pp.y-=sin(p.x*.1)-sin(p.x*30.)*0.01; //Bit more displacement for the terrain and a subtl frill along the x axis\n  vec2 h,t=vec2(pp.y+5.+ripple,5.); //Create base terrain from a displaced plane\n  cn=noi(p*1.5+ripple)*.2; //To make terrain more interesting than plane we gonna add some displaced infinite cylinders, but we need to tweak them even more with more noise. It's like seeing Autechre live, but as if it's wasn't fucked up enough, you also took some acid.\n  t.x=smin(t.x,length(abs(pp.xz+cn)-vec2(5,5))-(1.1+ripple*.2-sin(p.y*.2)+sin(p.y*30.)*0.02),3.); //Add some vertical infinite tweaked out cylinder and do smooth merge with terrain. It's like genetrification, it's ok because hipsters are actually \"nice guys\".\n  t.x=smin(t.x,length(abs(pp.xy+cn-vec2(0,3))-vec2(12,0))-(1.1+ripple*.2-sin(p.z*.2)),13.); //More infinite cylinders this time horizontal. Making caves makes me feel like a man... I miss the days of slaying sabre tooth tigers to impress the ladies.\n  t.x*=0.55; //Remove the atrifact, fix me beautiful, baby.\n  h=pounder(p+vec3(2,5,2)); //MAKE IT POUND! Yeah could have been boring but then we have major earth pounding action, who doesn't love pumping hey? Even Donald Trump is a fan.\n  t=t.x<h.x?t:h; // Ah yeah make it pound but we gotta merge the columns with the rest, while retaining material IDs. It's like international diplomacy, everyone wants war, but let's have some tea and discuss these borders.\n  h=vec2(length(cos((p*.3-td*.2)+vec3(0,tt*1.,0))),6.); //MAKE IT SNOW! I know winter is finished but I live in England were it's always bleak and we like it like this. Yeah you can keep your sunshine, Europe!\n  g+=0.1/(0.1+h.x*h.x*400.); //Yeah make them little snow particles glow, it might lift the mood a bit, we sort of miss the European sunshine since Brexit.\n  t=t.x<h.x?t:h; //Add particles to rest, like sprinkling glitter over your dick to make up for its lack of girth.\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started there were no craft beer shops and boating shoes were for sailors.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft (get distance to geom)\n    if(h.x<.0001||t.x>40.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime+32.,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some life you've lived, Steve.\n  b=clamp(sin(tt*2.-1.4),0.,1.),b2=clamp(sin(tt*2.-2.2),0.,1.),bb=smoothstep(0.,1.,b); //some global animation variables. Because cranking automatons is almost as fun as maturbation, my friends.\n  vec3 ro=mix(vec3(-2.-cos(tt*.4)*5.,5.,-17.+sin(tt*.2+1.)*-3.),vec3(cos(tt*.2)*3.,sin(tt*.4)*5.+6.,-12),ceil(sin(tt*.5))),//Ro=ray origin=camera position We bild camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0,cos(tt*.1)*5.,0)-ro), //cw camera forward?      \n  cu=normalize(cross(cw,vec3(0,1,0))), \t\t//cv camera up??\n  cv=normalize(cross(cu,cw)), \t\t\t\t//cu camera left vector??? Not sure broh, too busy burning fossil fuels and maximizing my carbon footprint.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,lp; //rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  lp=vec3(2,5,2);//POINT LIGHT position is where the pounder is to create fake illumination from the core... Area lights I will do the day after I give up drinking, I promise.\n  co=fo=vec3(.1)-length(uv)*.09-rd.y*.07; //background is grey with vignette and subtle vertical gradient based on ray direction y axis. It's grey like the heart of people from Birmingham.\n  z=tr(ro,rd);t=z.x;//Trace the trace in the loop de loop. Aka sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying it with that mediocre looking waitress\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(1),vec3(0.0,.2,.3),min(td*.4+0.1*abs(sin(pp*1.)),1.)); //by default albedo is mix between white and blue but the mix is done with noise of terrain so give really nice details in hues of blue\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    ld=normalize(lp-po);   //Point light direction shit, get light dir from light pos.\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    attn=1.0-pow(min(1.0,length(lp-po)/20.),4.0), //Point light attenuation\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from Shane, who is \"da man\"\n    co=attn*mix(sp+al*(a(.1)*a(.3)+.2)*(dif+(z.y==5.?s(0.8):0.)),fo,fr);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=clamp(mix(fo,co,exp(-.0001*t*t*t)),0.,1.);//Fog soften things, but it won't stop hipsters from gentrifying the north of England.\n  }  \n  fragColor = vec4(pow(co+g*0.1+g2*0.20*vec3(0.0,.2,.3),vec3(0.45)),1);// Naive gamma correction\n} //Thank you and good night brooooooski", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3SWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 457, 481, 481, 522], [523, 622, 639, 639, 682], [683, 784, 820, 820, 885], [886, 1030, 1048, 1238, 1458], [1459, 1459, 1483, 1634, 4224], [4225, 4336, 4360, 4360, 4558], [4558, 4610, 4629, 4629, 7209], [7210, 7210, 7292, 7292, 8059], [8149, 8149, 8278, 8278, 11494]], "test": "untested"}
{"id": "ttcSDB", "name": "Difference Paint", "author": "smkgames", "description": "Difference Paint", "tags": ["2d", "paint", "draw"], "likes": 3, "viewed": 366, "published": 3, "date": "1581608139", "time_retrieved": "2024-07-30T21:24:22.053668", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(distance(iMouse.xy, fragCoord) < 20.0);\n    fragColor = abs(fragColor - texture(iChannel0, fragCoord.xy / iResolution.xy));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]], "test": "untested"}
{"id": "tttSzs", "name": "Menger Sponge Raytraced", "author": "phi16", "description": "raytracing menger sponge by tree traversal / cyclic camera motion (simply a loop)", "tags": ["raytrace"], "likes": 12, "viewed": 595, "published": 3, "date": "1581597651", "time_retrieved": "2024-07-30T21:24:23.180655", "image_code": "vec4 dmin(vec4 x, float y, vec3 n) {\n\tif(x.w < 0.0) return vec4(n,y);\n    else if(y < 0.0) return x;\n    return x.w < y ? x : vec4(n,y);\n}\nfloat square(vec3 p, vec3 v) {\n    if(p.z < 0.0 || v.z > 0.0) return -1.0;\n    float t = - p.z / v.z;\n    vec3 c = p + v * t;\n    if(abs(c.x) < 1.0 && abs(c.y) < 1.0) return t;\n    else return -1.0;\n}\nvec4 cube(vec3 p, vec3 v, float flip) {\n\tvec4 dist = vec4(-1);\n    vec3 u = vec3(0,0,1) * flip;\n    dist = dmin(dist, square(p.xyz-u,v.xyz), vec3(0,0,1));\n    dist = dmin(dist, square(p.zxy-u,v.zxy), vec3(0,1,0));\n    dist = dmin(dist, square(p.yzx-u,v.yzx), vec3(1,0,0));\n    dist = dmin(dist, square(-p.xyz-u,-v.xyz), vec3(0,0,-1));\n    dist = dmin(dist, square(-p.zxy-u,-v.zxy), vec3(0,-1,0));\n    dist = dmin(dist, square(-p.yzx-u,-v.yzx), vec3(-1,0,0));\n    return dist;\n}\n\nvec3 scene(vec3 p, vec3 v) {\n    vec3 empty = vec3(0.1);\n    vec4 t;\n    int count = 0;\n    ivec3 l = ivec3(0);\n    bool hole = false;\n    if(abs(p.x) < 1. && abs(p.y) < 1. && abs(p.z) < 1.) {\n        for(int i=0;i<18;i++) {\n            vec3 c = p;\n            ivec3 e = clamp(ivec3(c * 3. / 2. + 1.5), 0, 2);\n            l = l * 3 + e;\n            vec3 o = vec3(e - 1) * 2.0 / 3.0;\n            p = (p - o) * 3.0;\n            count++;\n            ivec3 u = e;\n            hole = false;\n            if(u.x == 1 && u.y == 1) hole = true;\n            if(u.y == 1 && u.z == 1) hole = true;\n            if(u.z == 1 && u.x == 1) hole = true;\n            if(hole) break;\n        }\n    }\n    for(int i=0;i<18;i++) {\n        if(!hole) {\n            t = cube(p,v,1.);\n            if(t.w < 0.) return empty;\n            vec3 c = p + v * t.w;\n            ivec3 e = clamp(ivec3(c * 3. / 2. + 1.5), ivec3(0), ivec3(2));\n            l = l * 3 + e;\n            vec3 o = vec3(e - 1) * 2.0 / 3.0;\n            p = (p - o) * 3.0;\n            count++;\n        } else {\n            t = cube(p,v,-1.);\n            if(t.w < 0.) return empty;\n            for(int j=0;j<10;j++) {\n                ivec3 e = (l%3+3)%3;\n                bool up = false;\n                if(t.x < -0.5 && e.x == 2) up = true;\n                if(t.y < -0.5 && e.y == 2) up = true;\n                if(t.z < -0.5 && e.z == 2) up = true;\n                if(t.x > 0.5 && e.x == 0) up = true;\n                if(t.y > 0.5 && e.y == 0) up = true;\n                if(t.z > 0.5 && e.z == 0) up = true;\n                if(up) {\n                    vec3 o = vec3(e - 1) * 2.0 / 3.0;\n                    p = p / 3.0 + o;\n                    l /= 3;\n                    count--;\n                    if(count == 0) return empty;\n                } else break;\n            }\n            l -= ivec3(t.xyz);\n            p += t.xyz * 2.;\n        }\n        ivec3 u = l%3;\n        hole = false;\n        if(u.x == 1 && u.y == 1) hole = true;\n        if(u.y == 1 && u.z == 1) hole = true;\n        if(u.z == 1 && u.x == 1) hole = true;\n        if(count >= 7) break;\n    }\n    vec3 wp = (p+v*t.w) / pow(3.,7.); // what\n    vec3 lv = normalize(vec3(-1,2,-0.5));\n    return (wp*0.3+0.7) * (normalize(t.xyz)*0.3+0.7) * (dot(t.xyz,lv)*0.5+0.5);\n}\n\nvec3 image(vec2 uv) {\n    vec3 dir = normalize(vec3(uv*0.7,-1));\n    float vignetting = pow(mix(-dir.z,1.,0.5),10.0)*3.0;\n    float gt = iTime/2.;\n    \n    // Uniform Catmull-Rom spline\n    vec3 p0 = vec3(0,5,2);\n    vec3 p1 = vec3(0,0,1);\n    vec3 p2 = vec3(0,1./3.,-2./3.);\n    vec3 p3 = vec3(0,8./9.,-5./9.);\n    float t = fract(gt);\n    float a = 0.0;\n    float t0 = 0.;\n    float t1 = pow(distance(p0,p1),a) + t0;\n    float t2 = pow(distance(p1,p2),a) + t1;\n    float t3 = pow(distance(p2,p3),a) + t2;\n    float tt = mix(t1,t2,t);\n    vec3 a1 = ((t1-tt)*p0 + (tt-t0)*p1) / (t1-t0);\n    vec3 a2 = ((t2-tt)*p1 + (tt-t1)*p2) / (t2-t1);\n    vec3 a3 = ((t3-tt)*p2 + (tt-t2)*p3) / (t3-t2);\n    vec3 b1 = ((t2-tt)*a1 + (tt-t0)*a2) / (t2-t0);\n    vec3 b2 = ((t3-tt)*a2 + (tt-t1)*a3) / (t3-t1);\n    vec3 c  = ((t2-tt)*b1 + (tt-t1)*b2) / (t2-t1);\n    vec3 eye = c;\n    float r = t*3.1415926535/2. - 0.1;\n    dir.yz *= mat2(cos(r),-sin(r),sin(r),cos(r));\n   \n    float m = floor(gt)*3.1415926535/2.;\n    eye.yz *= mat2(cos(m),-sin(m),sin(m),cos(m));\n    dir.yz *= mat2(cos(m),-sin(m),sin(m),cos(m));\n    return scene(eye,dir) * vignetting;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y*2.;\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++) {\n        for(int j=0;j<2;j++) {\n            col += image(uv + vec2(i,j)/iResolution.y/2.) / 4.;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 138], [139, 139, 169, 169, 339], [340, 340, 379, 379, 817], [819, 819, 847, 847, 3088], [3090, 3090, 3111, 3111, 4225], [4227, 4227, 4284, 4284, 4541]], "test": "untested"}
{"id": "wltXRs", "name": "Color Distribution", "author": "wyatt", "description": "Volumetric histogram of the colors in an image.\nChange buffer B, in buffer A to experiment. (reset time)\n\nI assume an AI could minimize the parameter space of the shape?", "tags": ["color", "volumetric"], "likes": 7, "viewed": 422, "published": 3, "date": "1581571543", "time_retrieved": "2024-07-30T21:24:24.191951", "image_code": "// Fork of \"Reaction Diffusion 3D\" by wyatt. https://shadertoy.com/view/wtcGzB\n// 2020-02-13 05:26:37\n\nSampler\nMain\n{\n    R = iResolution.xy;\n    vec3 mi = 0.5*vec3(R/N,N*N);\n    vec3 p = vec3(0,0,-R.x/N);\n    vec3 d = normalize(vec3((u-0.5*R)/R.y,1));\n    if (iMouse.z>0.) {\n \t\tp.zx *= e(6.2*iMouse.x/R.x);\n\t\td.zx *= e(6.2*iMouse.x/R.x);\n        p.yz *= e(6.2*iMouse.y/R.y);\n\t\td.yz *= e(6.2*iMouse.y/R.y);\n    } else {\n\t\tp.yz *= e(.2*iTime);\n\t\td.yz *= e(.2*iTime);\n\t}\n    Q = vec4(0);\n    for (int i = 0; i < 120; i++) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m<.01)\n        { \t\n            vec4 a = 25.*T(p+mi)/float(iFrame);\n            float aa = a.x;\n            Q += 10./R.x*(1.-exp(-aa))*a;\n            p += d*(exp(-5.*aa));\n            p = mod(p+mi,R3D)-mi;\n        } else p += d*m;\n        \n \t}\n    Q = 0.8*atan(Q);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 7.\nvec2 R;\n#define R3D vec3(R/N,N*N)\nvec2 d2 (vec3 U) {\n    U = mod(U,R3D);\n    U.z = floor(U.z);\n\treturn U.xy+vec2(mod(U.z,N),floor(U.z/N))*R/N;\n}\nvec3 d3 (vec2 u) {\n    vec2 o = floor(u/R*N);\n\treturn vec3(mod(u,R/N),o.x+o.y*N);\n}\nmat2 e (float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n#define A(U) texelFetch(iChannel0,ivec2(d2(U)),0)\n#define B(U) texelFetch(iChannel1,ivec2(d2(U)),0)\n#define Sampler vec4 T(vec3 U) {return mix(texture(iChannel0,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel0,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Main void mainImage( out vec4 Q, in vec2 u )\n#define _3D  R = iResolution.xy; vec3 U = d3(u);\n#define Me Q = A(U);\n#define Them vec4 M = 1./6.*(A(U+vec3(1,0,0))+A(U+vec3(0,1,0))+A(U+vec3(0,0,1))+A(U-vec3(1,0,0))+A(U-vec3(0,1,0))+A(U-vec3(0,0,1)));\n#define Init  if (iFrame < 1) Q = vec4(0);\n// Dave Hashkins\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n", "buffer_a_code": "Main\n{\n    _3D\n    Me\n        for (int i = 0; i < 100; i++) {\n        vec2 v = hash22(vec2(i,iFrame));\n        vec3 color = texture(iChannel1,v).xyz;\n        if (length(color)>0.) Q.xyz += normalize(color)*exp(-length(R3D*color-U));\n        }\n    Init  \n   \n\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 117, 117, 864]], "test": "untested"}
{"id": "wl3Szs", "name": "Day 55", "author": "jeyko", "description": "potaot", "tags": ["mdtmjvm"], "likes": 26, "viewed": 582, "published": 3, "date": "1581547402", "time_retrieved": "2024-07-30T21:24:25.171332", "image_code": "// for something similar check out BigWIngs's shader\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.002).x;\n    fragColor.y = T(uv -f*0.002).y;\n    fragColor.z = T(uv).z;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3Szs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 148, 148, 331]], "test": "untested"}
{"id": "WldSRs", "name": "fn psych 2", "author": "anttikan", "description": "Composition using a randomly generated function mapping x, y, and time to color values. Here also a noise function and simple lighting is implemented, as shown here: https://www.shadertoy.com/view/lsl3RH", "tags": ["2d", "abstract"], "likes": 6, "viewed": 375, "published": 3, "date": "1581543480", "time_retrieved": "2024-07-30T21:24:26.062949", "image_code": "\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat noise( float x, float y )\n{\n    \n    vec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pixelfunc(float x, float y, float iTime) {\n    return (sqrt(pow(sin(((((y)-(log(abs((sqrt(abs(((((y)*(x))-pow((x),2.0))-(noise((x),(y))+((y)*(x))))))*sin(pow(exp((y)),3.0))))+0.0001)-noise(abs((sqrt(pow(pow(pow(pow((y),2.0),2.0),2.0),2.0)+pow((y),2.0)))) - floor(abs((sqrt(pow(pow(pow(pow((y),2.0),2.0),2.0),2.0)+pow((y),2.0))))),(sin(iTime/0.9034435963811109 + 0.20637479410149906)))))/ (abs(exp((sin(iTime/0.8529278085443219 + 0.8213404700193889))))+0.0001))*(sqrt(abs((sqrt(pow(pow(abs(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.9995009860820951 + 0.6881438036038101)),3.0))))) - floor(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.26979193952694613 + 0.3785319489160377)),3.0))))))) - floor(abs(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.22226978701805833 + 0.24191002823528662)),3.0))))) - floor(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.5739308110903445 + 0.45896373432699944)),3.0)))))))),2.0),2.0)+pow((sin(iTime/0.7264469109570366 + 0.08679412060619152)),2.0)))))/ (abs((sqrt(pow(sin((y)),2.0)+pow(sin(cos((sqrt(pow((sign((sin((x))*log(abs((sin(iTime/0.9613027990997718 + 0.6659919369591429)))+0.0001)))/ (abs(noise((sin(iTime/0.6989492096617616 + 0.36615005376399967)),pow(((sin(iTime/0.71852557018322 + 0.1619393542530836))+(x)),2.0)))+0.0001)),2.0)+pow((sin(iTime/0.6209043266540595 + 0.8417751048573665)),2.0))))),2.0))))+0.0001)))),2.0)+pow(sin(pow(noise((sqrt(abs((sqrt(pow(pow(((sin(iTime/0.3462935766066413 + 0.3097821178771951))*sin(pow(((y)+(y)),2.0))),2.0),2.0)+pow((log(abs(noise((sqrt(pow(abs((x)) - floor(abs((x))),2.0)+pow(((x)*(y)),2.0))),(x)))+0.0001)/ (abs(((y)/ (abs(noise((((sin(iTime/0.7866078460146608 + 0.2681747389535367))*(y))/ (abs(abs((sin(iTime/0.3774955185871607 + 0.7938241880557342))) - floor(abs((sin(iTime/0.6122868317852803 + 0.6912683134142241)))))+0.0001)),sqrt(abs(abs((x)) - floor(abs((x)))))))+0.0001)))+0.0001)),2.0)))))/ (abs(pow((sqrt(pow((sign((x))/ (abs(cos(cos(abs(cos((x))) - floor(abs(cos((x)))))))+0.0001)),2.0)+pow(noise(sqrt(abs(exp(sin(sign((x)))))),sqrt(abs(exp(pow(sin((y)),2.0))))),2.0))),3.0))+0.0001)),((sin((pow((sqrt(pow((sin(iTime/0.6991922402347979 + 0.21404984070124788)),2.0)+pow(abs(((x)/ (abs((x))+0.0001))) - floor(abs(((x)/ (abs((x))+0.0001)))),2.0))),3.0)/ (abs(sqrt(abs(log(abs((y))+0.0001))))+0.0001)))/ (abs((((sqrt(pow(((sin(iTime/0.26754650486706133 + 0.12570778401332916))-abs(((sin(iTime/0.12503305278658794 + 0.01130819450429632))/ (abs((x))+0.0001))) - floor(abs(((sin(iTime/0.2653499101486092 + 0.00871470719699241))/ (abs((x))+0.0001))))),2.0)+pow(sin(sin(((x)-(sin(iTime/0.10483245318883472 + 0.600138486042491))))),2.0)))+sign(abs((y)) - floor(abs((y)))))-(sin(sin(sin(exp((sin(iTime/0.9940380440346446 + 0.5464411881844877))))))/ (abs(sign(((sqrt(pow((sin(iTime/0.6341745666062364 + 0.8531862440589704)),2.0)+pow(exp((y)),2.0)))-(x))))+0.0001))))+0.0001))*sin(pow((sqrt(pow(sin(sin(cos(((y)+(x))))),2.0)+pow((y),2.0))),3.0)))),2.0)),2.0)));\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    \n        \n    float x = p.x*(0.4 + 0.2*cos(iTime*0.1 + 10.0)) + sin(iTime*0.12 + 10.0);\n    float y = (0.4+0.2*cos(iTime*0.1 + 10.0))*p.y; // p.y*0.2; //\n    float t = iTime*0.2;\n    \n    float shade = pixelfunc(x, y, t);\n    float mapped_shade = map(shade,-3.0, 3.0, 0.0, 1.0);\n    \n    \n    vec3 col = mix( vec3(0.1,0.6,0.8), vec3(0.2,0.3,0.5), mapped_shade );\n    col = vec3(mapped_shade) - vec3(0.1, 0.1, 0.2);\n    \n    \n    \n    \n \tvec3 nor = normalize( vec3( pixelfunc(x+e,y,t)-shade, \n                                2.0*e,\n                                pixelfunc(x,y+e,t)-shade ) );\n\n    vec3 lig = normalize( vec3( 0.8, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.65,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.65,0.30,0.2)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 76, 76, 105], [107, 107, 140, 140, 522], [525, 525, 573, 573, 3521], [3524, 3524, 3596, 3596, 3680], [3682, 3682, 3739, 3739, 4762]], "test": "untested"}
{"id": "wtcXRs", "name": "AangHead", "author": "samhattangady", "description": "Felt like doing some character that I know. Thought Aang would be a\ngood fit. No hair... And the arrow would be fun to figure out.", "tags": ["characteraang"], "likes": 13, "viewed": 423, "published": 3, "date": "1581525942", "time_retrieved": "2024-07-30T21:24:26.904808", "image_code": "/*\nFelt like doing some character that I know. Thought Aang would be a\ngood fit. No hair... And the arrow would be fun to figure out.\n*/\nfloat PI = 3.14159;\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec3 bendSpaceZ (vec3 position, float degree) {\n    //position = rotate3D(position, vec3(0.0, PI/2.0, 0.0));\n    float k = degree;\n    float c = cos(k*position.y);\n    float s = sin(k*position.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = m*position.xy;\n    return vec3(q, position.z);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\nfloat smin(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nvec2 aangHead(vec3 position) {\n\tvec3 symPosX = vec3(abs(position.x), position.yz);\n    float material = 1.0;\n    float d, d1, d2;\n\n    // Basic head sphere\n    d = sdfEllipsoid(position, vec3(0.0), vec3(0.4, 0.5, 0.5));\n    // basic jaw\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.3, -0.1), vec3(0.08, 0.2, 0.20),\n                            vec3(0.0), 0.2);\n    d2 = sdfRoundBoxRotated(position, vec3(0.0, -0.90, 0.1), vec3(0.5, 0.8, 0.3),\n                            vec3(PI/2.5, 0.0, 0.0), 0.0);\n    d1 = smax(d1, -d2, 0.3);\n    d2 = sdfRoundBoxRotated(symPosX, vec3(0.30, -0.56, -0.40), vec3(0.38, 0.45, 0.08),\n                            vec3(-0.6, -1.3, -0.2), 0.0);\n    //d1 = smin(d1, d2, 0.1);\n    d1 = smax(d1, -d2, 0.15);\n    d2 = sdfRoundBoxRotated(symPosX, vec3(0.35, -0.56, -0.50), vec3(0.58, 0.53, 0.18),\n                            vec3(-0.0, -1.1, -0.0), 0.0);\n    //d1 = smin(d1, d2, 0.1);\n    d1 = smax(d1, -d2, 0.1);\n    d = smin(d, d1, 0.1);\n    // sculpt head\n    d1 = sdfRoundBoxRotated(symPosX, vec3(0.51, 0.0, 0.0), vec3(0.07, 1.0, 1.0),\n                            vec3(0.0, 0.0, -0.1), 0.01);\n    d = smax(d, -d1, 0.1);\n    // ears\n    d1 = sdfEllipsoidRotated(symPosX, vec3(0.38, -0.15, 0.1), vec3(0.12, 0.15, 0.03),\n                             vec3(-0.3, -PI/9.9,- 0.3));\n    d2 = sdfSphere(symPosX, vec3(0.43, -0.15, 0.1), 0.001);\n    d1 = smax(d1, -d2, 0.1);\n    d = smin(d, d1, 0.01);\n\n    // eye sockets\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.04, -0.57), vec3(0.2, 0.1, 0.1),\n                            vec3(PI/4.0, 0.0, -0.0), 0.01);\n    d = smax(d, -d1, 0.2);\n    // nose\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.12, -0.45), vec3(0.005, 0.12, 0.05),\n                            vec3(0.7, 0.0, 0.0), 0.02);\n    d = smin(d, d1, 0.1);\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.22, -0.53), vec3(0.05, 0.005, 0.05),\n                            vec3(0.0, PI/4.0, 0.0), 0.0);\n    d = smin(d, d1, 0.1);\n    // mouth\n    d1 = sdfEllipsoid(vec3(symPosX.x, symPosX.y-4.9*pow(symPosX.x, 2.3), symPosX.z),\n                      vec3(0.0, -0.42, -0.5), vec3(0.15, 0.07, 0.6));\n    d = smax(d, -d1, 0.01);\n    d1 = sdfSphere(position, vec3(0.0, -0.42, -0.35), 0.13);\n    if (d1 < d) {\n        material = 6.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfJoint3DSphere(position, vec3(0.08, -0.36, -0.45),\n                          vec3(PI/2.0, -PI/1.4, 0.0),\n                          0.2, PI/4.0, 0.01).x;\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfJoint3DSphere(position, vec3(0.08, -0.47, -0.45),\n                          vec3(PI/2.0, -PI/1.4, 0.0),\n                          0.2, PI/4.0, 0.01).x;\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    // cheeks\n    d1 = sdfSphere(symPosX, vec3(0.2, -0.22, -0.35), 0.05);\n    d = smin(d, d1, 0.2);\n    // eyes\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.35), 0.11);\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.41), 0.06);\n    if (d1 < d) {\n        material = 3.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.445), 0.03);\n    if (d1 < d) {\n        material = 4.0;\n    }\n    d = smin(d, d1, 0.01);\n    // eye brows\n    d1 = sdfJoint3DSphere(symPosX, vec3(0.1, 0.13+0.01*sign(position.x), -0.455),\n                          vec3(0.0, -0.9, -PI/3.2),\n                          0.2, 0.9, 0.01).x;\n    if (d1 < d) {\n        material = 5.0;\n    }\n    d = smin(d, d1, 0.01);\n\n    return vec2(d, material);\n}\n\nint calculateArrow(vec3 position) {\n    // To calculate the arrow, we take the origin as 0. If facing back (z=1)\n    // is 0, we trace a circle on the yz plane, and calculate the angle made\n    // we use that to calculate the stem of the arrow, and the position of the\n    // pointyhead.\n    if (abs(position.x) > 0.20) {\n        return 0;\n    }\n    float angle = atan(position.y, position.z);\n    float maxAngle = PI-0.2;\n    float arrowAngle = PI/6.0;\n    if (-PI/2.0 < angle && angle < maxAngle) {\n        // pointy head\n        if (angle > maxAngle-arrowAngle) {\n            float rem = (angle-(maxAngle-arrowAngle)) / arrowAngle;\n            rem = -1.0 * (rem-1.0);\n            if (abs(position.x) < 0.20*rem) {\n                return 1;\n            }\n        } else if (abs(position.x) < 0.11) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvec4 distanceField(vec3 position) {\n\tvec2 d = aangHead(position);\n    return vec4(d, 0.0, 0.0);\n}\n\nvec3 calcNormal(vec3 p) {\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p).x+ distanceField(p+vec3(h,0.0,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,h,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,0.0,h)).x\n    \t\t\t\t ));\n}\n\nvec4 raymarch(vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    vec3 pos = start;\n    float d = 0.0;\n    vec4 obj = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<100; i++) {\n    \tobj = distanceField(pos);\n        float dist = obj.x;\n        pos += dist*direction;\n        d += dist;\n        if (dist < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return vec4(d, obj.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n\n    float mouseX = ((iMouse.x/iResolution.x)-0.5) * 2.0 * 3.14159/2.0;\n    mouseX = -0.3;\n    mouseX = 0.4*sin(iTime/3.6);\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 planePosition = vec3(p, 1.0) + cameraPosition;\n\n    mat2 camRotate = mat2(cos(mouseX), -sin(mouseX), sin(mouseX), cos(mouseX));\n    cameraPosition.xz = camRotate * cameraPosition.xz;\n    planePosition.xz = camRotate * planePosition.xz;\n\n    float yRotate = 0.1;\n    yRotate = 0.2*sin(iTime/4.2);\n    camRotate = mat2(cos(yRotate), -sin(yRotate), sin(yRotate), cos(yRotate));\n    cameraPosition.yz = camRotate * cameraPosition.yz;\n    planePosition.yz = camRotate * planePosition.yz;\n\n    vec3 lookingDirection = (planePosition - cameraPosition);\n\n    // This was fun to sort out, but is it the best way?\n    float lightTime = iTime/3.0;\n    float multiplier = -1.0 + (step(-0.0, sin(lightTime*3.14159)) *2.0);\n    float parabola = (4.0 * fract(lightTime) * (1.0-fract(lightTime)));\n    float lightX = multiplier*parabola *-1.2;\n    vec3 lightPoint = normalize(vec3(lightX, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    // lightFacing = vec3(1.0, 1.0, -0.3) - vec3(0.0);\n\n    // raymarch to check for colissions.\n    vec4 obj = raymarch(lookingDirection, planePosition);\n    float dist = obj.x;\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        vec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        int arrow = calculateArrow(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        light = max(light, 0.0);\n        if (obj.y < 1.5) {\n            // skin\n        \tcolor = vec3(0.505, 0.205, 0.105);\n            color += 0.3* smoothstep(0.1, 1.0, light);\n            if (arrow==1) {\n        \t    color = vec3(0.21, 0.21, 0.31);\n                color += 0.1* smoothstep(0.1, 1.0, light);\n            }\n        } else if (obj.y < 2.5) {\n            //eyes\n        \tcolor = vec3(0.75, 0.75, 0.85);\n            color += 0.1 * smoothstep(0.5, 1.0, light);\n        } else if (obj.y < 3.5) {\n        \tcolor = vec3(0.21, 0.21, 0.31);\n            color += 0.7 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 4.5) {\n        \tcolor = vec3(0.01);\n            color += 0.5 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 5.5) {\n            // eyebrows\n        \tcolor = vec3(0.05, 0.02, 0.01);\n            color += 0.05 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 6.5) {\n            // mouth\n        \tcolor = vec3(0.15, 0.02, 0.01);\n            color += 0.1 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        }\n    }\n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 199, 199, 644], [645, 645, 704, 704, 754], [755, 755, 815, 815, 954], [955, 955, 1037, 1037, 1218], [1219, 1219, 1260, 1260, 1312], [1313, 1313, 1406, 1406, 1584], [1585, 1585, 1605, 1605, 1626], [1627, 1627, 1674, 1735, 1916], [1917, 1917, 2023, 2023, 2686], [2687, 2687, 2728, 2728, 2804], [2805, 2805, 2846, 2846, 2922], [2924, 2924, 2954, 2954, 6528], [6530, 6530, 6565, 6817, 7385], [7387, 7387, 7422, 7422, 7484], [7486, 7486, 7511, 7743, 8056], [8058, 8058, 8101, 8390, 8774], [8776, 8776, 8833, 8876, 11697]], "test": "untested"}
{"id": "tl3XRs", "name": "glsl compil bug:  ? sampler1 : 2", "author": "FabriceNeyret2", "description": "turn the #if 1 into 0:\nApparently the parameter of texture cannot be a sampler resulting from an expression.\nOr the result of a test cannot be a sampler. ", "tags": ["glsl", "bug"], "likes": 1, "viewed": 295, "published": 3, "date": "1581524377", "time_retrieved": "2024-07-30T21:24:27.900036", "image_code": "// sampler2D s;                            // forbidden (not uniform)\n   uniform sampler2D s;                    // ok\n// uniform sampler2D s = iChannel0;        // forbidden (param not constant)\n// #define mysampler     iChannel0         // only (limited) solution ?\n\nvec4 txt(sampler2D ch, vec2 uv)            // ok (but cf constraints at call)\n{ return texture( ch, uv ); } \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n  //sampler2D s;                           // forbidden (not uniform)\n  //uniform sampler2D s;                   // forbidden (not global)\n  //s = iChannel0;                         // forbidden l-value\n  //s = uv.x < .5 ? iChannel0 : iChannel1; // forbidden l-value\n\n#if 1   // --- try 0: won't compile \n    fragColor = txt( iChannel1, uv );      // ok \n    fragColor = txt( s, uv );              // ok\n    fragColor = texture( s, uv );          // ok (but no way to initialize s !!! )\n#else\n    fragColor = texture( uv.x < .5 ? iChannel0 : iChannel1, uv ); // why forbidden ?\n    fragColor = texture(   true    ? iChannel0 : iChannel1, uv ); // why forbidden ?\n#endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 348, 348, 376], [379, 379, 436, 436, 1153]], "test": "untested"}
{"id": "wlcXRl", "name": "turbulent landscape", "author": "unnick", "description": "experimenting a bit with video feedback\nadvection -> sharpening -> color rotation -> noise -> normalization -> centered scaling and rotation", "tags": ["2d", "feedback", "infinite", "multipass", "buffers"], "likes": 24, "viewed": 671, "published": 3, "date": "1581516841", "time_retrieved": "2024-07-30T21:24:28.918314", "image_code": "//parameters in the common tab\nvoid mainImage(out vec4 col, in vec2 pos) {\n    //col.xy = fetch(ivec2(pos)).xy * .5 + .5;\n    col.xyz = vec3(fetch(ivec2(pos)).xy, 1) * colormat;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 col, in vec2 pos) {\n    ivec2 ipos = ivec2(pos);\n    //advection\n    vec2 dir = fetch(ipos).xy;\n    dir = tex(dir*advection + pos).xy;\n    \n    //sharpening\n    dir -= ( fetch(ipos+ivec2(1,0)).xy\n           + fetch(ipos+ivec2(0,1)).xy\n           + fetch(ipos-ivec2(1,0)).xy\n           + fetch(ipos-ivec2(0,1)).xy) * sharpening;\n    \n    //rotation\n    dir *= rotmat(dirrot);\n    \n    //noise\n    dir += (texelFetch(iChannel3, (ivec2(pos)+iFrame*ivec2(158,83)) & 255, 0).xy * 2. - 1.) * noise;\n    \n    col.xy = dot(dir,dir) < .00001 ? vec2(1,0) : normalize(dir);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//supported interpolation methods: linear, cubic, lanczos3\n#define interpolation_cubic\n\n//parameters\n//replace .02 with .06 for linear interpolation\n#define sharpening .02\n#define advection 2.\n#define dirrot .1\n#define zoom .98\n#define screenrot .03\n#define noise .01\n\n//color transform\n#define colormat mat3(.5,0,.5, -.25,sqrt(3.)/4.,.5, -.25,-sqrt(3.)/4.,.5)\n//#define colormat mat3(.5,0,.5, 0,.5,.5, 0,0,0)\n\n#define res iResolution.xy\n#define tau 6.283185\n#define htau (tau*.5)\n#define fetch(p) texelFetch(iChannel0, p, 0)\n\n#ifdef interpolation_linear\n#define tex(p) texture(iChannel0, (p) / res)\n#endif\n#ifdef interpolation_cubic\n#define tex(p) cubic_tex(iChannel0, p)\n#endif\n#ifdef interpolation_lanczos3\n#define tex(p) lanczos3_tex(iChannel0, p)\n#endif\n\nvec4 cubic_tex(sampler2D ch, vec2 p) {\n    ivec2 ires = textureSize(ch, 0);\n    p -= .5;\n    \n    ivec2 ip = ivec2(floor(p));\n    vec2 fp = fract(p);\n    \n    vec2 w0 = -fp*(1.-fp)*(1.-fp)*.5;\n    vec2 w1 = fp*fp*(1.5*fp-2.5)+1.;\n    vec2 w2 = (.5+2.*fp-1.5*fp*fp)*fp;\n    vec2 w3 = -.5*(1.-fp)*fp*fp;\n    \n    #define tmpfetch(p) texelFetch(ch, (((p)%ires)+ires)%ires, 0)\n    vec4 p00 = tmpfetch(ip+ivec2(0,0)-1);\n    vec4 p10 = tmpfetch(ip+ivec2(1,0)-1);\n    vec4 p20 = tmpfetch(ip+ivec2(2,0)-1);\n    vec4 p30 = tmpfetch(ip+ivec2(3,0)-1);\n    vec4 p01 = tmpfetch(ip+ivec2(0,1)-1);\n    vec4 p11 = tmpfetch(ip+ivec2(1,1)-1);\n    vec4 p21 = tmpfetch(ip+ivec2(2,1)-1);\n    vec4 p31 = tmpfetch(ip+ivec2(3,1)-1);\n    vec4 p02 = tmpfetch(ip+ivec2(0,2)-1);\n    vec4 p12 = tmpfetch(ip+ivec2(1,2)-1);\n    vec4 p22 = tmpfetch(ip+ivec2(2,2)-1);\n    vec4 p32 = tmpfetch(ip+ivec2(3,2)-1);\n    vec4 p03 = tmpfetch(ip+ivec2(0,3)-1);\n    vec4 p13 = tmpfetch(ip+ivec2(1,3)-1);\n    vec4 p23 = tmpfetch(ip+ivec2(2,3)-1);\n    vec4 p33 = tmpfetch(ip+ivec2(3,3)-1);\n    #undef tmpfetch\n    \n    return p00*w0.x*w0.y + p10*w1.x*w0.y + p20*w2.x*w0.y + p30*w3.x*w0.y\n         + p01*w0.x*w1.y + p11*w1.x*w1.y + p21*w2.x*w1.y + p31*w3.x*w1.y\n         + p02*w0.x*w2.y + p12*w1.x*w2.y + p22*w2.x*w2.y + p32*w3.x*w2.y\n         + p03*w0.x*w3.y + p13*w1.x*w3.y + p23*w2.x*w3.y + p33*w3.x*w3.y;\n    \n    /*\n    cleaner but slower version of the code above:\n\n    vec4 wx = vec4(w0.x,w1.x,w2.x,w3.x);\n    vec4 wy = vec4(w0.y,w1.y,w2.y,w3.y);\n    vec4 sum = vec4(0);\n    for(int y = 0; y < 4; y++)\n    for(int x = 0; x < 4; x++) {\n        sum += tmpfetch(ip+ivec2(x,y)-1) * wx[x] * wy[y];\n    }\n    */\n}\n\n//#define sinc(x) mix(sin((x)*tau) / ((x)*tau), vec2(1.), lessThan(abs(x),vec2(.01)))\nvec4 lanczos3_tex(sampler2D ch, vec2 p) {\n    ivec2 ires = textureSize(ch, 0);\n    p -= .5;\n    \n    ivec2 ip = ivec2(floor(p));\n    vec2 fp = fract(p);\n    \n    vec2 w[6];\n    \n    for(int i = 0; i < 6; i++) {\n        vec2 x = vec2(i) - 2. - fp;\n        vec2 tmp = 3. * sin(x*htau) * sin(x*htau/3.) / (htau*htau*x*x);\n        w[i] = mix(tmp, vec2(1.), lessThan(abs(x), vec2(.1)));\n        \n    }\n    \n    #define tmpfetch(p) texelFetch(ch, (((p)%ires)+ires)%ires, 0)\n    vec4 sum = vec4(0);\n    for(int y = 0; y < 6; y++)\n    for(int x = 0; x < 6; x++) {\n        sum += tmpfetch(ip+ivec2(x,y)-2) * w[x].x * w[y].y;\n    }\n    #undef tmpfetch\n    return sum;\n}\n\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n", "buffer_b_code": "void mainImage(out vec4 col, in vec2 pos) {\n    //centered scaling and rotation\n    col.xy = normalize(tex(((pos-res*.5) * zoom * rotmat(screenrot))+res*.5).xy);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 74, 121, 179]], "test": "untested"}
{"id": "wt3SRl", "name": "Motion Loop #002", "author": "lsdlive", "description": "Progressing with 2D & motion.\nCritique & Comments are welcome.", "tags": ["2d", "loop", "motion", "ease"], "likes": 7, "viewed": 466, "published": 3, "date": "1581513207", "time_retrieved": "2024-07-30T21:24:29.816911", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #002\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_002.fs\n\nWith the help of https://thebookofshaders.com/examples/?chapter=motionToolKit\nInspired by: https://thebookofshaders.com/edit.php?log=160909064609\n\n*/\n\n#define bpm 120.\n#define speed .5\n#define blink_factor (0.*.125)\n\n#define AA 3.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat pulse(float begin, float end, float t) {\n  return step(begin, t) - step(end, t);\n}\n\nfloat easeInOutExpo(float t) {\n    if (t == 0. || t == 1.) {\n        return t;\n    }\n    if ((t *= 2.) < 1.) {\n        return .5 * exp2(10. * (t - 1.));\n    } else {\n        return .5 * (-exp2(-10. * (t - 1.)) + 2.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float mask;\n    \n    float t1 = fract(.125 + time * .25); // for blinking rings\n    float t2 = easeInOutExpo(fract(time));// for easing ring\n    \n    // blinking rings\n    if (uv.x < 0.) {\n        if (uv.y < 0. && pulse(0., .25 - blink_factor, t1) == 1.) {\n            mask = fill(circle(uv, .35));\n            mask += stroke(circle(uv, .3725), .005);\n        } else if(uv.y > 0. && pulse(.25, .5 - blink_factor, t1) == 1.) {\n            mask = fill(circle(uv, .35));\n            mask += stroke(circle(uv, .3725), .005);\n        }\n    } else {\n        if (uv.y > 0. && pulse(.5, .75 - blink_factor, t1) == 1.) {\n            mask = fill(circle(uv, .35));\n            mask += stroke(circle(uv, .3725), .005);\n        } else if (uv.y < 0. && pulse(.75, 1. - blink_factor, t1) == 1.) {\n            mask = fill(circle(uv, .35));\n            mask += stroke(circle(uv, .3725), .005);\n        }\n    }\n    \n    // opposite blinking rings\n    if (uv.x < 0.) {\n        if (uv.y < 0. && pulse(.5, .75 - blink_factor, t1) == 1.) {\n            mask = stroke(circle(uv, .25), .05);\n            mask += stroke(circle(uv, .2), .005);\n        } else if(uv.y > 0. && pulse(.75, 1. - blink_factor, t1) == 1.) {\n            mask = stroke(circle(uv, .25), .05);\n            mask += stroke(circle(uv, .2), .005);\n        }\n    } else {\n        if (uv.y > 0. && pulse(0., .25 - blink_factor, t1) == 1.) {\n            mask = stroke(circle(uv, .25), .05);\n            mask += stroke(circle(uv, .2), .005);\n        } else if (uv.y < 0. && pulse(.25, .5 - blink_factor, t1) == 1.) {\n            mask = stroke(circle(uv, .25), .05);\n            mask += stroke(circle(uv, .2), .005);\n        }\n    }\n    \n    \n    // easing ring\n    vec2 uv2 = uv * r2d(-pi / 2. * (floor(time) + t2));\n    if(uv2.x < 0. && uv2.y < 0.)\n        mask -= 2. * stroke(circle(uv2, .15), .05);\n    mask += stroke(circle(uv, .15), .05);\n    \n    \n    // outer rings + central circle\n    mask -= fill(circle(uv, .09));\n    mask += stroke(circle(uv, .4), .01);\n    mask += stroke(circle(uv, .43), .01);\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SRl.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[565, 565, 584, 584, 650], [652, 652, 673, 673, 730], [732, 865, 901, 901, 973], [975, 975, 1011, 1011, 1042], [1044, 1044, 1090, 1090, 1132], [1134, 1134, 1164, 1164, 1358], [1360, 1360, 1417, 1417, 3650]], "test": "untested"}
{"id": "WtcSzl", "name": "The Mandelbrot Set", "author": "42yeah", "description": "Zoomed in too much.\n\nhttps://frame.42yeah.casa/2020/02/12/mandelbrot-set.html", "tags": ["mandelbrot"], "likes": 2, "viewed": 666, "published": 3, "date": "1581499147", "time_retrieved": "2024-07-30T21:24:30.867104", "image_code": "float julia(vec2 uv, vec2 c) {\n    int i;\n    for (i = 0; i < 100; i++) {\n        uv = vec2(uv.x * uv.x - uv.y * uv.y + c.x,\n                  2.0 * uv.x * uv.y + c.y);\n        if (length(uv) > 100.0) {\n            break;\n        }\n    }\n    return float(i) / 100.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    uv *= pow(0.5, -1.0 + 30.0 * (0.5 + 0.5 * sin(iTime * 0.20 - (3.14159265))));\n    uv += vec2(-0.51, -0.61351); // From iq\n    float f = julia(vec2(0.0, 0.0), uv);\n    \n    // Output to screen\n    fragColor = vec4((1.0 - uv) * pow(f, 0.5), f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 268], [271, 271, 328, 378, 759]], "test": "untested"}
{"id": "WlcXRl", "name": "Raycasting Shader", "author": "WillGordon", "description": "A simple shader that renders a sphere using raycasting, can be used for point or directional light", "tags": ["rays", "sphere"], "likes": 0, "viewed": 325, "published": 3, "date": "1581496393", "time_retrieved": "2024-07-30T21:24:31.824543", "image_code": "float sphereIntersect(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n vec3 rc = ray-center;\n float c = dot(rc, rc) - (radius*radius);\n float b = dot(dir, rc);\n float d = b*b - c;\n float t = -b - sqrt(abs(d));\n float st = step(0.0, min(t,d));\n return mix(-1.0, t, st);\n}\n\n//CAMERA VARS --------\n\nvec3 cameraCenter = vec3(0.0, 0.0, -3.0);\n\nfloat imagePlaneDist = 1.0;\n\n//SPHERE VARS --------\n\nvec3 sphereCenter = vec3(0.0, 0.0, 10.0);\n\nfloat radius = 3.0;\n\nvec3 sphereColor = vec3(1.0, 0.1, 0.1);\n\n//LIGHTING ------------\n\n//Set 1 to use direction, 0 to use Point\nfloat useDirectionalLight = 0.0; \n\n//DIRECTIONAL ONLY\n\n//Strength of light\nfloat intensity = 1.0;\n\n//Direction of light\nvec3 lightDir = vec3(0.0, 1.0, -1.0);\n\n\n//POINT ONLY\n\n//Position of light\nvec3 lightPos = vec3(0.0, 1.0, 1.0);\n\n//Only maximum range\nfloat maxLightRange = 10.0;\n\n//resulting range based on position, no need to set\nfloat lightRange = 0.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Fix Aspect ratio\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Ray start\n    vec3 rayOrigin = cameraCenter;\n\n    //Ray move\n    vec3 imagePlanePixel = vec3(uv.x, uv.y, cameraCenter.z + imagePlaneDist);\n    vec3 rayDir = normalize(imagePlanePixel - rayOrigin);\n   \n    //Sphere Intersect\n    float t = sphereIntersect(rayOrigin, rayDir, sphereCenter, radius);\n\n    //hit position\n    vec3 hit = rayOrigin + rayDir * t;\n    \n    //Clamp sphere intersection to 0 or 1\n    t = clamp(t, 0.0, 1.0);\n    \n    //Normal of sphere\n    vec3 normal = normalize(hit - sphereCenter); \n    \n    //Get distance to light\n    vec3 lightDist = (lightPos - normal);            \n        \n    //Get how bright the pixel should be if using directional light\n    float dotProduct = max(dot(normalize(lightDist), normalize(-lightDir)), 0.0);                       \n            \n    //Falloff calculations    \n    lightRange = step(maxLightRange, length(lightDist));    \n    lightRange = (length(lightDist) * length(lightDist)) / (maxLightRange * maxLightRange);\n    lightRange = 1.0 - lightRange;\n    float lightLambert = max(dot(normal, normalize(lightPos - hit)), 0.0);        \n                        \n    // Output to screen\n    //Check to see if using directional or point light\n    float check = step(1.0, useDirectionalLight);    \n        \n    vec4 dirColor = vec4(sphereColor * dotProduct * t * intensity, 1.0) * check;            \n    \n    vec4 pointColor = vec4(sphereColor * lightRange * t * lightLambert, 1.0) * (1.0 - check);\n    \n    //One will be zero the other will have a color\n    fragColor = dirColor + pointColor;     \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 70, 70, 271], [924, 924, 981, 1039, 2742]], "test": "untested"}
{"id": "tldSzf", "name": "City of Future", "author": "TimoKinnunen", "description": "Shiny", "tags": ["raytracing", "reflection", "glass", "city", "lensflare"], "likes": 28, "viewed": 1110, "published": 3, "date": "1581480878", "time_retrieved": "2024-07-30T21:24:32.908645", "image_code": "// Fork of \"Crystal City\" by omgadev. https://shadertoy.com/view/tt3SW7\n// 2020-02-09 04:29:40\n\n//\n// Added huge lensflare filter kernel to try to keep up with shiny pixels from frame to frame.\n//\n// Added coloring and fudged the normals for more realism. Minor tweaks to liven up the scene. \n//\n// Removed original limit of 2 reflection bounces, now stops when contribution to pixel color drops low.\n//\n\nvec4 image(vec2 U) {\n    vec4 S = texelFetch(iChannel0, ivec2(U), 0);\n    vec4 V = texelFetch(iChannel1, ivec2(U), 0);\n    vec2 pos = V.xy;\n    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n\n    vec4 O = S;\n    O += sunflare(U, R, pos, T);\n\n    O.rgb *= smoothstep(vec3(0.875),vec3(0.5,0.5,0.6),vec3(length(0.5-U/R)));\n    return O;\n}\nMAIN", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 lightColor = normalize(vec3(0.8, 1.0, 1.0));\nvec3 skyColor1 = normalize(vec3(0.2, 0.6, 1.0));\nvec3 skyColor2 = normalize(vec3(0.8, 0.9, 1.0));\nvec3 buildingColor = vec3(0., 0., 0.);\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat GetDist(vec3 pos)\n{\n\tfloat dist = 99999999.;\n\n\tfor (float j = 0.; j < 6.; j++) {\n\t\tfloat s = exp2(5. - j);\n\t\tvec3 c = vec3(0.5 * s, -2., 0.5 * s);\n\t\tvec3 p = vec3(mod(pos.x, s), pos.y, mod(pos.z, s));\n\t\tvec3 b = vec3(0.1, 0.4, 0.1) * s;\n\t\tvec3 q = abs(p - c) - b;\n\t\tfloat d = length(max(q, 0.0)) + min(vmax(q), 0.0);\n\t\tdist = min(dist, d);\n\t}\n    {\n        const float j = 7.;\n\t\tfloat s = exp2(5. - j);\n\t\tvec3 c = vec3(0.5 * s, -2., 0.5 * s);\n\t\tvec3 p = vec3(mod(pos.x, s), pos.y, mod(pos.z + ((j == 7.) ? iTime*(-1.+2.*mod(floor(pos.x/s),2.0)) : 0.0), s));\n\t\tvec3 b = vec3(0.1, (j == 7.) ? 0.1 : 0.4,(j == 7.) ? 0.35 : 0.1) * s;\n\t\tvec3 q = abs(p - c) - b;\n\t\tfloat d = length(max(q, 0.0)) + min(vmax(q), 0.0);\n\t\tdist = min(dist, d);\n    }\n\tdist = min(dist, pos.y + 2.25-0.125);\n\n\treturn dist;\n}\n\nvec3 GetNormal(vec3 point) {\n\tfloat d = GetDist(point);\n\tvec2 e = vec2(0, 0.01);\n\treturn normalize(vec3(\n\t\td - GetDist(point - e.yxx),\n\t\td - GetDist(point - e.xyx),\n\t\td - GetDist(point - e.xxy)\n\t));\n}\n\nvec3 SkyColor(vec3 lightDir, vec3 rayDir) {\n    vec3 color = mix(skyColor2, skyColor1, 0.5+0.5*rayDir.y);\n    float hor = 1.-abs(rayDir.y);\n    hor *= hor;\n    hor *= hor;\n    return color+hor*0.0625*0.75;\n}    \n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir) {\n\tfloat rayLength = 0.;\n\n    for(int j = 0; j < 500; j++) {\n\t\tfloat dist = GetDist(rayOrigin + rayDir * rayLength);\n\t\trayLength += dist;\n\n        if (rayLength >= 128.) {\n\t\t\tbreak;\n        }\n        if (dist < 0.01) {\n            return rayLength;\n        }\n\t}\n\n\treturn 128.;\n}\n\nvec4 GetColor(vec3 rayOrigin, vec3 lightDir, vec3 rayDir) {\n\tvec3 totalColor = vec3(0);\n\tvec3 r = vec3(1.);\n    float viewDist = 0.0;\n    float rayLength = 0.0;\n    for(int j = 0; j < 100; j++) {\n\t\tfloat dist = GetDist(rayOrigin + rayDir * rayLength);\n\t\trayLength += dist;\n        \n\t\tif (rayLength >= 128.) {\n\t\t\tbreak;\n        }\n            \n        if (dist < 0.01) {\n            vec3 point = rayOrigin + rayLength * rayDir;\n\n            vec3 baseColor = buildingColor+0.25+0.25*sin(vec3(24,17,22)*floor(vec3(5,2,4)*point));\n            baseColor = mix(baseColor,vec3(0.03125),smoothstep(0.4375,0.46875,abs(0.5-fract(vec3(2,3,4)*point))));\n\n            vec3 color = baseColor;\n\n            vec3 cellI = floor(vec3(2.5,3.125,2.5)*point)+0.25;\n            vec3 imperfections = vec3(1,0.75,1)*texture(iChannel0,fract(vec2(cellI.x+cellI.z,cellI.y)/1024.)).xyz;\n            vec3 normal = GetNormal(point);\n            normal = normalize(mix(normal,imperfections,0.5*0.25*0.125));\n\n            color *= 0.0625 + 0.9375 * lightColor * clamp(dot(-lightDir, normal), 0., 1.);\n            color += lightColor * pow(max(dot(reflect(-lightDir, normal), rayDir), 0.), 32.);\n            \n            vec3 sky = SkyColor(lightDir, rayDir);\n            float attenuation = clamp(rayLength / 128., 0., 1.);\n            color = mix(color, sky, attenuation);\n            color *= r;\n            totalColor += color;\n\n            float farFade = clamp((128.-rayLength)*0.25, 0., 1.);\n            vec3 glassTint = max(abs(rayOrigin.y-point.y)+length(normal.xz)*2.-16.*abs(normal.y),2.) /(1.+baseColor);\n            r = min(r / glassTint,farFade);\n\n            if(viewDist==0.0) viewDist = rayLength;\n\n            rayDir = reflect(rayDir, normal);\n            rayOrigin = point;\n            rayLength = 0.02*4.;\n\n            if(vmax(r)<0.0625) break;\n        }\n\t}\n    {\n            vec3 sky = SkyColor(lightDir, rayDir);\n            vec3 color = sky + lightColor*pow(max(dot(-lightDir, rayDir)*128.-127., 0.), 32.)*16.;\n            color *= r;\n            totalColor += color;\n    }\n\n    return vec4(totalColor,viewDist);\n    \n}\n\n\nvec4 image(vec2 U) {\n\tvec2 uv = (U - 0.5 * R) / R.y;\n\tvec3 rayDir = normalize(vec3(uv, 0.5));\n\tvec3 camPos = vec3(-3.+2.75-1.*sin(iTime*0.41)+0.25*sin(iTime*0.11), -1.+2.+2.*sin(iTime*0.31), iTime * 5.);\n    //camPos.yz*=0.25;\n\tvec3 lightDir = normalize(vec3(-5, -3, -1));\n\trayDir = rotate(rayDir, vec3(0., 1., 0.), sin(iTime) * 0.1 + 1.);\n    lightDir = rotate(lightDir, vec3(0., 1., 0.), iTime * 0.125 + 0.);\n\n    vec4 color = GetColor(camPos, lightDir, rayDir);\n    color.rgb = mix(sqrt(432.0/7.0)*color.rgb*color.rgb,sqrt((8.0/7.0)*color.rgb-(1.0/7.0)),greaterThan(color.rgb,vec3(1./6.)));\n    return color;\n}\nMAIN", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//const int[16] mult0 = int[](3,5,6,10,12,17,20,24,29,34,40,58,68,116,136,232);\nconst int[] mult0 = int[](3,5,6,10,12,17,20,24,29,34,40,58,68);\nconst ivec2[4] mult1 = ivec2[](ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(1,2));\nvec4 image(vec2 U) {\n    vec2 R = iResolution.xy;\n    ivec2 pos0 = ivec2(U);\n    vec4 O = texelFetch(iChannel1, pos0, 0);\n    float hi = 0.0;\n    for(int i0 = 0; i0 < mult0.length(); i0++) {\n        for(int i1 = 0; i1 < 4; i1++) {\n            ivec2 off1 = mult0[i0]*mult1[i1];\n            for(int i2 = 0; i2 < 2; i2++) {\n                ivec2 off2 = i2==0?off1:ivec2(-off1.y,off1.x);\n                for(int i3 = 0; i3 < 2; i3++) {\n                    ivec2 off = i3==0?off2:-off2;\n                    vec4 V = texelFetch(iChannel1, pos0+off, 0);\n                    vec2 pos = floor(V.xy)+0.5;\n                    if(distance(U,pos)<distance(U,O.zw)) {\n                        O.zw=pos;\n                    }\n                    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                    float lu=sunflare(U, R, pos, T);\n                    if(hi<lu) {\n                        hi=lu;\n                        O.xy=pos;\n                    }\n                }\n            }\n        }\n    }\n    float hiApprox = 0.0;\n    vec2 hiPos = O.zw;\n    {\n        const int SIZE = 3;\n        ivec2 pos1 = ivec2(O.zw);\n        for(int i0 = -SIZE; i0 <= SIZE; i0++) {\n            for(int i1 = -SIZE; i1 <= SIZE; i1++) {\n                ivec2 off = ivec2(i0,i1);\n                vec4 V = texelFetch(iChannel1, pos1+off, 0);\n                vec2 pos = floor(V.xy)+0.5;\n                vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                float lu=sunflare(U, R, pos, T);\n                if(hi<lu) {\n                    hi=lu;\n                    O.xy=pos;\n                }\n            }\n        }\n    }\n    \n    {\n        vec2 pos1 = floor(hiPos)+0.5;\n        for(int i0 = -1; i0 <= 0; i0++) {\n            for(int i1 = -1; i1 <= 0; i1++) {\n                {\n                    vec2 pos = pos1+vec2(i0,i1);\n                    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                    float lu=sunflare(U, R, pos, T);\n                    if(hi<lu) {\n                        hi=lu;\n                        O.xy=pos;\n                    }\n                }\n                {\n                    vec2 pos = U+vec2(i0,i1);\n                    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                    float lu=sunflare(U, R, pos, T);\n                    if(hi<lu) {\n                        hi=lu;\n                        O.xy=pos;\n                    }\n                }\n            }\n        }\n    }\n\n    O.zw=vec2(0);\n    return O;\n}\nMAIN", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 M;\nvec2 R;\n#define MAIN void mainImage(out vec4 O,vec2 U){M=iMouse;R=iResolution.xy;O=image(U);}\n\nfloat sinpi(float v) {return sin(radians(180.0)*v);}\nvec2  sinpi(vec2  v) {return sin(radians(180.0)*v);}\nvec3  sinpi(vec3  v) {return sin(radians(180.0)*v);}\nvec4  sinpi(vec4  v) {return sin(radians(180.0)*v);}\nfloat cospi(float v) {return cos(radians(180.0)*v);}\nvec2  cospi(vec2  v) {return cos(radians(180.0)*v);}\nvec3  cospi(vec3  v) {return cos(radians(180.0)*v);}\nvec4  cospi(vec4  v) {return cos(radians(180.0)*v);}\nfloat tanpi(float v) {return tan(radians(180.0)*v);}\nvec2  tanpi(vec2  v) {return tan(radians(180.0)*v);}\nvec3  tanpi(vec3  v) {return tan(radians(180.0)*v);}\nvec4  tanpi(vec4  v) {return tan(radians(180.0)*v);}\nfloat atanpi(vec2 v) {return atan(v.y,v.x)/radians(180.0);}\nfloat vmax(vec2 v) {return max(v.x, v.y);}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {return min(v.x, v.y);}\nfloat vmin(vec3 v) {return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {return min(min(v.x, v.y), min(v.z, v.w));}\n\nfloat lum(vec4 t) {return dot(vec4(0.25,0.625,0.125,0),max(t,0.));}\nfloat flare(vec2 U, vec2 R, vec2 sunPos, float strength1, float strength2) {\n    const float K_n0 = 5.0, K_f0 = K_n0, K_r0 = 0.50, K_o0 = 0.5;\n    const float K_n1 = 3.0, K_f1 = K_n1, K_r1 = 1., K_o1 = 0.0;\n    const float K_n2 = 4.0, K_f2 = K_n2*K_f1, K_r2 = K_f2/K_n1, K_o2 = 0.5+0.0*fract((K_f2*K_f1)*0.5);\n        \n    float lenSun = distance(sunPos,U)/R.y*strength1+strength2;\n    float angle = atanpi(sunPos-U);\n    float flare2 = 5.0*exp2(-2.-2.*lenSun-7.*lenSun*abs(0.5-fract(sunPos.x/R.x*K_r2+K_o2+K_f2*angle)));\n    float flare1 = 6.0*exp2(-3.-3.*lenSun-7.*lenSun*abs(0.5-fract(sunPos.x/R.x*K_r1+K_o1+K_f1*angle)));\n    float flare0 = 9.0*exp2(-3.-3.*lenSun-7.*lenSun*abs(0.5-fract(sunPos.x/R.x*K_r0+K_o0+K_f0*angle)));\n    flare0 = sqrt(flare0);\n    return flare0 + flare1 + flare2;\n}\nfloat flare(vec2 U, vec2 R, vec2 sunPos) {return flare(U,R,sunPos,2.0,1.0);}\n\nvec4 calcSunFlare(vec2 U, vec2 R, vec2 pos, float luma, float dist) {\n    const vec4 M1 = vec4(800,300,80,0)/vec4(800,450,800,450);\n    //vec4 M1 = M/R.xyxy;\n    const vec4 M2 = vec4(200,350,400,400)/vec4(800,450,800,450);\n    //vec4 M2 = M/R.xyxy;\n    float distanceFactor = clamp(log2(dist*2.)-4.,0.,1.);\n    float strength1 = (mix(M2.x,M2.z,distanceFactor)-0.0)*64.;\n    float strength2 = (mix(M2.y,M2.w,distanceFactor)-0.5)*4.0;\n    float distancy = 1.0-0.*distanceFactor;//clamp(distancy0,0.,1.);//clamp(2.-T.w/64.,0.,1.);\n    //float strength = strength0;//exp2(4.-2.*strength);\n    float luminosity = clamp(luma*16.*M1.x-16.*M1.y,0.,1.);\n    float lensflare = clamp(flare(U,R,pos,strength1,strength2)*16.*M1.z-16.*M1.w,0.,1.);\n    return vec4(distancy,luminosity,lensflare,strength1);\n}\nfloat sunflare(vec2 U, vec2 R, vec2 pos, vec4 tex) {\n    vec3 f = calcSunFlare(U,R,pos,lum(tex),tex.w).xyz;\n    return f.x*f.y*f.z;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 405, 425, 425, 740]], "test": "untested"}
{"id": "3tdSzX", "name": "The Vandamme Wave", "author": "xjorma", "description": "\"Do you like Sushi?\"\n\nLittle variation of https://www.shadertoy.com/view/tttXRB", "tags": ["2d", "funny", "vandamme"], "likes": 15, "viewed": 471, "published": 3, "date": "1581476136", "time_retrieved": "2024-07-30T21:24:33.685568", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define TAU radians(360.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 \ttex = texture(iChannel0, fragCoord / iResolution.xy);\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tangle = atan(p.y, p.x);\n    float \tl = length(p) * 20.;\n    float\tcircleId = floor(l);\n    float\tmodCircleId = mod(circleId, 2.);\n    float \td = tex.x;\n    float speed = mix(0.1, -0.1, modCircleId);\n    l+= sin((angle - iTime * speed) * circleId * 5.) * 0.3 * d;\n    l = fract(l) * 2.;\n    float\tt = min(l, 2. - l);\n    t = smoothstep((100. + 100. * tex.y) / iResolution.y, 0., abs(t-1.)); \n    fragColor = vec4(vec3(pow(t,1./2.2)),1.);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const\tvec3\tck = vec3(13., 163., 38.) / 255.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    vec3 d = c - ck;\n    float m = smoothstep(0., 0.01, dot(d, d));    \n    fragColor = vec4(vec3(m,dot(c, vec3(1)) * m, 0.),1.);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = vec4(0);\n    for(int i = -10; i <= 10; i ++)\n    {\n\t\t acc += texture(iChannel0, fragCoord / iResolution.xy + vec2(float(i), 0.) / iResolution.x);\n    }\n    fragColor = acc / float(10 * 2 + 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = vec4(0);\n    for(int i = -10; i <= 10; i ++)\n    {\n\t\t acc += texture(iChannel0, fragCoord / iResolution.xy + vec2(0., float(i)) / iResolution.y);\n    }\n    fragColor = acc / float(10 * 2 + 1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[141, 141, 198, 198, 772]], "test": "untested"}
{"id": "tldSzX", "name": "\"Simplex-Gabor\" Noise", "author": "KdotJPG", "description": "Controllably anisotropic Gabor-like noise based on OpenSimplex2 instead of Voronoi-esque control point placement. Intended for proof of concept moreso than performance.", "tags": ["noise", "simplex", "gabor"], "likes": 7, "viewed": 721, "published": 3, "date": "1581469468", "time_retrieved": "2024-07-30T21:24:34.875386", "image_code": "bool ANIMATE = true;\nfloat noiseFrequency = 16.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y);\n    vec3 X = vec3(uv * noiseFrequency, ANIMATE ? mod(iTime, 578.0) * 0.8660254037844386 : 0.0);\n    \n    vec3 direction = vec3(normalize(uv+.2), 0.0);\n    float sinusoidFrequencyScalar = 12.0;\n    \n    float value = simplexGaborNoise_XYBeforeZ(X, direction * sinusoidFrequencyScalar);\n    \n    value = value * 0.5 + 0.5;\n    vec3 col = vec3(value);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "////////////////// K.jpg's Smooth Re-oriented 8-Point BCC Noise //////////////////\n////////////////////// a.k.a. OpenSimplex2, Smooth Version ///////////////////////\n///////////// Modified to produce a Gabor noise like output instead. /////////////\n//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// BCC lattice split up into 2 cube lattices\nvec2 simplexGaborNoisePart(vec3 X, vec3 dir) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    vec4 sineOffsets = hashes / 48.0 * 3.14159265 * 4.0;\n    \n    // Gradient extrapolations are replaced with sin(dot(dX, inputVector) + pseudorandomOffset)\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaa = aa * a;\n    vec4 extrapolations = vec4(dot(d1, dir), dot(d2, dir), dot(d3, dir), dot(d4, dir)) + sineOffsets;\n    extrapolations = sin(extrapolations);\n    \n    // Return (kernels^3) * sinusoids, and just (kernels^3), so we can average them later\n    return vec2(dot(aaa, extrapolations), dot(aaa, vec4(1.0)));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nfloat simplexGaborNoise_Classic(vec3 X, vec3 dir) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    dir = dot(dir, vec3(2.0/3.0)) - dir;\n    \n    vec2 both = simplexGaborNoisePart(X, dir) + simplexGaborNoisePart(X + 144.5, dir);\n    return both.x / both.y;\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Might be good for terrain, or a time varying X/Y plane. Z repeats.\nfloat simplexGaborNoise_XYBeforeZ(vec3 X, vec3 dir) {\n    \n    // Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    dir = orthonormalMap * dir;\n    vec2 both = simplexGaborNoisePart(X, dir) + simplexGaborNoisePart(X + 144.5, dir);\n    return both.x / both.y;\n}\n\n//////////////////////////////// End noise code ////////////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 552]], "test": "untested"}
{"id": "wtdSzX", "name": "Minimal Hexagonal Shader/Grid", "author": "leftofzen", "description": "Based on https://www.shadertoy.com/view/Xljczw, but actually a minimal example; no superfluous shading or colouring. See that shader for more info.", "tags": ["hexagonalgrid"], "likes": 47, "viewed": 4982, "published": 3, "date": "1581469312", "time_retrieved": "2024-07-30T21:24:35.728106", "image_code": "//#define FLAT_TOP_HEXAGON\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453);\n}\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p)\n{    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    #else\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    #endif    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p)\n{    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    \n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, translating, then converting it to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(u*5. + s.yx*iTime/2.);\n    \n    // The beauty of working with hexagonal centers is that the relative edge distance will simply \n    // be the value of the 2D isofield for a hexagon.\n    float eDist = hex(h.xy); // Edge distance.\n\n    // Initiate the background to a white color, putting in some dark borders.\n    vec3 col = mix(vec3(1.), vec3(0), smoothstep(0., .03, eDist - .5 + .04));    \n    fragColor = vec4(col, 1);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 338, 338, 404], [406, 735, 757, 757, 931], [933, 1625, 1646, 2025, 2863], [2865, 2865, 2920, 2962, 3715]], "test": "untested"}
{"id": "WldXzf", "name": "discrete sine transform fluid", "author": "public_int_i", "description": "alternative to https://www.shadertoy.com/view/WtdXRX testing to see what the differences between sine and cosine transform have on the simulation", "tags": ["simulation", "fluid", "sine", "physics", "discrete", "transform", "dst"], "likes": 3, "viewed": 453, "published": 3, "date": "1581464258", "time_retrieved": "2024-07-30T21:24:36.617728", "image_code": "void mainImage(out vec4 o, in vec2 u)\n{\n    o = vec4(length(texelFetch(iChannel0,ivec2(u),0))*.3);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592653589793\n\n#define TURBULENCE 1.5\n#define DIFFUSION 1e-8", "buffer_a_code": "//Buffer A - X axis forward sine transform + stochastic advection\n\n#define R4P 1.1673039782614187\nvec4 r4(float n) {\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash4(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat pmod(float v, float m) {\n \tif (v < 0.) return m-mod(-v,m)-1.;\n    return mod(v,m);\n}\n\nvec2 advec(float x, float y) {\n    vec2 v = -texelFetch(iChannel0,ivec2(x,y),0).xy;\n    v += (hash4(vec4(x,y,v.x+float(iFrame)/1000.,v.y)*11.1627863).xy-.5)*TURBULENCE;\n    return texelFetch(iChannel0, ivec2(pmod(v.x+x,iResolution.x),pmod(v.y+y,iResolution.y)),0).xy;\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.x; i++) s += advec(i,u.y)*sin((1.+i)*PI*floor(1.+u.x)/(1.+iResolution.x));\n\to = vec4(s,0,0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Buffer B - Y axis forward sine transform + frequency space fluid processing\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*sin((1.+i)*PI*floor(1.+u.y)/(1.+iResolution.y));\n    \n    //frequency space processing\n    \n    //rescaling\n    s /= (iResolution.x+1.)*(iResolution.y+1.)*.25;\n    \n    //mass conservation, this is the core of the fluid sim\n    float len = length(s);\n    vec2 nu = normalize(floor(u));\n    s -= nu*dot(nu,s);\n    s *= len/(DIFFUSION+length(s));\n    \n    //prevent drifting\n    if (dot(u,u) < 1.) s = vec2(0);\n    if (min(u.x,u.y) < 1.) s *= max(u.x/iResolution.x,u.y/iResolution.y);\n    \n    o = vec4(s,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Buffer C - Y axis inverse sine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*sin((1.+i)*PI*floor(1.+u.y)/(1.+iResolution.y));\n    o = vec4(s,0,0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Buffer D - X axis inverse sine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.x; i++) s += texelFetch(iChannel0,ivec2(i,u.y),0).xy*sin((1.+i)*PI*floor(1.+u.x)/(1.+iResolution.x));\n     \n    //add velocity forces\n    s += (pow(texture(iChannel1,u/iResolution.xy).xy,vec2(2.2))*2.-1.)*.05;\n    if (iMouse.w > 0.) {\n       \tvec2 d = u-iMouse.xy;\n     \ts += normalize(d)*max(0.,1.-length(d)/40.);\n    }\n    \n    o = vec4(s,0,0);\n}\n", "buffer_d_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 100]], "test": "untested"}
{"id": "3tdSzf", "name": "Simple mandelbrot set", "author": "bane9", "description": "Simple mandelbrot set", "tags": ["mandelbrot"], "likes": 0, "viewed": 285, "published": 3, "date": "1581456316", "time_retrieved": "2024-07-30T21:24:37.629024", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = ((fragCoord - 0.5 * iResolution.xy) / iResolution.y) * 2.5, z = vec2(0.0);\n    float i = 0.0;\n    for(; i < 100.0; i++){\n        float a = z.x * z.x, b = z.y * z.y;\n    \tif(a + b >= 16.0) break;\n        z = vec2(a - b, 2.0 * z.x * z.y) + uv;\n    }\n    fragColor = vec4(vec3(i / 100.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 360]], "test": "untested"}
{"id": "tt3Szf", "name": "filtering vector field -analysis", "author": "FabriceNeyret2", "description": "Direction = angular quantity -> hard to interpolate or filter.\nWIP visu experiments about unwrapped-diffusion ( better use accelerator: cf plugin )\n- clear/dark = extrema (vanish as surf becomes minimal)\n- white = flat zones ( |df|=0)\n- checker = wrapli\n", "tags": ["hue", "interpolation", "phasor", "chrominance"], "likes": 4, "viewed": 499, "published": 3, "date": "1581447189", "time_retrieved": "2024-07-30T21:24:38.633339", "image_code": "// Forked from https://shadertoy.com/view/Wl3SDM\n\n//#define T(d) texelFetch(iChannel0, ivec2(d+u), 0 ).x\n#define T(d) fract( texture(iChannel0,U+d/R).x - v + .5 )-.5 + v\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R, d = vec2(1,0);\n    vec4 BG = vec4(0);\n    \n    float eps=1e-3, eps2 = 1e-11, t,c,\n        v = texture(iChannel0,U).x; //T() ;\n    // --- draw hue\n    O = hue( v ); \n    // --- draw differential geometry curves\n    vec2  B = vec2( T(d)+T(-d), T(d.yx)+T(-d.yx) ) /2. - v,\n          D = vec2( T(d)-T(-d), T(d.yx)-T(-d.yx) ) /2.;\n    float C = ( T(d)+T(-d)+T(d.yx)+T(-d.yx)+T(d.xx)+T(-d.xx)+T(vec2(1,-1))+T(vec2(-1,1)))/8. - v;\n    c = B.x*B.y; t = D.x*D.y;\n  //O *= length(B); return;\n    O = .5*O;\n  //if (abs(C) < 1e-6) O = vec4(1,0,0,0); // all !\n  //if (abs(C) > 1e-6) O = vec4(sign(C),-sign(C),0,0);\n  vec2 z = floor(u/4.); float chk = mod(z.x+z.y,2.); // for checkers\n  bvec2 bD = lessThan(abs(D),vec2(1e-3)); // 1st derivative ~0\n\nif (bD.x||bD.y) // some 1st derivatives are ~0\n//if (abs(t*t) < 1e-6) \n      O = vec4( \n           bD.x && B.x> eps || bD.y && B.y> eps, // valley: red\n           bD.x && B.x<-eps || bD.y && B.y<-eps, // ridge: green\n           //chk,0); \n           bD.x && bD.y ? chk  // 2 tangents = 0: blue checker\n          : 0.,0);             // black: inflexions ?\n  //if (abs(B.x+B.y) < 1e-6 ) O++; // white: minimal surface (all ! )\n#if 1\n    O +=  c > eps2 ? .3*sign(B.x)   // positive / negative curvature\n        : abs(c)<eps2 ? .5 : 0. ;   // white: flat areas (possibly with a gradient)\n      //: min(B.x*B.x,B.y*B.y) < eps2 ? 1. : 0. ;\n      //: max(B.x*B.x,B.y*B.y) < eps2 ? 1. : 0. ;\n      //: abs(dot(B,B))/2.     < eps2 ? 1. : 0. ;\n#endif\n    \n    // --- wrap zone\n    if (abs(v) < 3./R.y) O = vec4(chk); // white checker\n \n    // --- vector field\n  //v += .3*iTime; in the case of phasor noise, phase is just up to a constant\n    float scale = R.y/8.;\n    vec2 n = vec2(cos(6.283*v),sin(6.283*v)),\n         p = fract(scale*U)*2.-1.; // p = local centered coords in cells\n    float l = length(n), f,\n          x = (n.x*p.y-n.y*p.x) / l,\n          w = dot(n,p) / l;         // option: arrow points to vector dir\n    f  = smoothstep(scale*3./R.y, 0., abs(x)+.1*w ); // display vector line\n    f *= smoothstep(scale*3./R.y, 0., abs(w)- l ); // optional: show vector length\n    O += .5*f;\n    \n    if keyToggle(32) {\n      //O = vec4( .5+ texture(iChannel0,U).x );                        // B&W\n      //O = vec4( .5+.5* sin(50.*texture(iChannel0,U).x ));            // isovals\n        O = vec4( .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x )); // phasor\n     // O *=      .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x );  // phasor (color)\n     // vec2 V = U-.5*R/R.y; O = vec4( .5+.5* sin(200.*atan(V.y,V.x)*length(V) +6.283*texture(iChannel0,U).x )); // phasor\n        BG = vec4(0,1,0,1);\n    }\n    \n    //if (int(u) == int(R)/2  ) O = BG;\n    //if (int(u) == int(R*.83)) O = BG; \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define T(d)        texture(iChannel0,U+d/R)\n  #define T(d) fract( texture(iChannel0,U+d/R) - T + .5 )-.5 + T\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= R;\n    \n    //O = texture(iChannel0,U,1.);    // linear diffusion\n    \n#if 0\n    vec2 d = vec2(1,0);               // --- unwrapped diffusion (cross pattern)\n    vec4 T  = texture(iChannel0,U),   // first unwrap the neighborhood\n         T1 = T( d),                  // to never filter cross-wrap.\n         T2 = T(-d),\n         T3 = T( d.yx),\n         T4 = T(-d.yx);\n    O = ( T1+T2+T3+T4 ) / 4.;\n#else\n    O-=O; int N = 5;                  // --- unwrapped diffusion (NxN filter)\n    vec4 T  = texture(iChannel0,U);   // first unwrap the neighborhood\n    for (int k=0; k < N*N; k++)       // to never filter cross-wrap.\n        O += T(vec2( k%N -N/2, k/N -N/2 ));\n  //O = fract( O - T + .5 )-.5 + T;\n    O /= float(N*N);\n  //O = fract( O - T + .5 )-.5 + T;\n#endif\n    \n  //O = .5 + sign(O-.5)*sqrt(2.*abs(O-.5));\n  //O = .5*sin(6.263*O);\n    \n    if (iChannelResolution[2].x < 10.) { O-=O; return; } // wait texture\n    if (iFrame < 1 || texelFetch(iChannel0,ivec2(0),0)==vec4(0) ) { // --- init state\n        float  k = 1.; // try 3 or 8 :-p\n        // k = U.x<.5 ? .5+8.*(.5-U.x) : U.x-.5<.33 ? 1. : 3.;\n        \n      //O.x = 3.*rgb2hls(texture(iChannel1,U)).x; return; // hue from true image\n      //T = texture(iChannel2,U,0.); O.x = T.a > .9 ? T.x : .3*T.x; return; // isolated random dots      \n      //O.x = abs(U.y-.5)>.25 ? U.x : 2.*U.x; return; // 1 vs 2 rainbow -> bipole\n      //U -= .5; O.x = 20.*length(U); return;         // concentric, no pole\n      //U -= .5; O.x = 4.5*atan(U.x,-U.y); return;    // radial, 1 pole + bad cycling\n\n      //vec2 V = texture(iChannel2,U+.0,5.).xy - .5;     // dir field from rand texture\n      //vec2 V = textureLod(iChannel2,U+.0,2.5).xy - .5;     // dir field from rand texture\n        vec2 V = textureLod(iChannel2,U+.0,2.).xy - .5;     // dir field from rand texture\n      //k = 8.*U.x;\n        //if (U.x<.5) { O.x = k*8.*V.x; return; }       // left: no pole\n      //if (U.x<.5) { O.x = 9.*U.x;  if (U.y>.5) O.x += .5;return; }  // left: gradiant + PI-jump\n      //V *= sin(20.*U.x);                            // strip modulation\n        \n        O.x = atan(V.y,V.x);                          // dir = norm rand texture\n      //O.x = atan(dFdy(V.x),dFdx(V.x));              // gradients of rand texture.x\n      //O.x = atan(dFdx(V.x),-dFdy(V.x));             // isolines of rand texture.x\n        \n        O.x *= k/6.2816;                              // hue on [0,1]\n        return;\n    }\n    \n#if 0 // sources\n    if (length(U-.5) < .05 ) O.x = 1.;\n    if (length(U-vec2(.8,.3)) < .05 ) O.x = 1.;\n    if (length(U-.8) < .05 ) O.x = .5;\n    if (length(U-.3) < .05 ) O.x = .7;\n#endif\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvec4 rgb2hls(vec4 C) {\n    float r =C.r, g=C.g, b=C.b,\n        M = max(r,max(g,b)),\n        m = min(r,min(g,b)),\n        l = (M + m) / 2.,\n        d =  M - m;\n\n    if (M == m) return vec4(0,l,0,0);\n    \n    C.y = l;\n    C.z = .5* d / min(l, 1.-l);\n    C.x =  r > max(g,b) ? (g - b) / d + (g < b ? 6. : 0.)\n         : g > b        ? (b - r) / d + 2.\n         :                (r - g) / d + 4.;\n    C.x /= 6.;\n    return C;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3Szf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtdXRX", "name": "discrete cosine transform fluid", "author": "public_int_i", "description": "fluid simulation using discrete cosine transform, based on rory618's fft fluid shader https://www.shadertoy.com/view/wdBGWG\nim fairly certain the mass conservation doesnt work properly without complex numbers but made this for the sake of experimenting", "tags": ["simulation", "fluid", "physics", "cosine", "discrete", "transform", "dct"], "likes": 13, "viewed": 781, "published": 3, "date": "1581446363", "time_retrieved": "2024-07-30T21:24:39.402283", "image_code": "void mainImage(out vec4 o, in vec2 u)\n{\n    o = vec4(length(texelFetch(iChannel0,ivec2(u),0))*.3);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Buffer A - X axis forward(type 2) cosine transform + stochastic advection\n\n#define R4P 1.1673039782614187\nvec4 r4(float n) {\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash4(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat pmod(float v, float m) {\n \tif (v < 0.) return m-mod(-v,m)-1.;\n    return mod(v,m);\n}\n\nvec2 advec(float x, float y) {\n    vec2 v = -texelFetch(iChannel0,ivec2(x,y),0).xy;\n    v += (hash4(vec4(x,y,v.x+float(iFrame)/1000.,v.y)*11.1627863).xy-.5)*TURBULENCE;\n    return texelFetch(iChannel0, ivec2(pmod(v.x+x,iResolution.x),pmod(v.y+y,iResolution.y)),0).xy;\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = .5; i < iResolution.x; i++) s += advec(i,u.y)*cos(i*PI*floor(u.x)/iResolution.x);\n\to = vec4(s,0,0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Buffer B - Y axis forward(type 2) cosine transform + frequency space fluid processing\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = .5; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*cos(i*PI*floor(u.y)/iResolution.y);\n\t\n    //frequency space processing\n    \n    //rescaling\n    s /= iResolution.x*iResolution.y*.25;\n    \n    //mass conservation, this is the core of the fluid sim\n    float len = length(s);\n    vec2 nu = normalize(floor(u));\n    s -= nu*dot(nu,s);\n    s *= len/(DIFFUSION+length(s));\n    \n    //prevent drifting\n    if (dot(u,u) < 1.) s = vec2(0);\n    \n    o = vec4(s,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Buffer C - Y axis inverse(type 3) cosine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = texelFetch(iChannel0,ivec2(u.x,0),0).xy*-.5;\n    for (float i = 0.; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*cos(i*PI*u.y/iResolution.y);\n    o = vec4(s,0,0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Buffer D - X axis inverse(type 3) cosine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = texelFetch(iChannel0,ivec2(0,u.y),0).xy*-.5;\n    for (float i = 0.; i < iResolution.x; i++) s += texelFetch(iChannel0,ivec2(i,u.y),0).xy*cos(i*PI*u.x/iResolution.x);\n     \n    //add velocity forces\n    s += (pow(texture(iChannel1,u/iResolution.xy).xy,vec2(2.2))*2.-1.)*.05;\n    if (iMouse.w > 0.) {\n       \tvec2 d = u-iMouse.xy;\n     \ts += normalize(d)*max(0.,1.-length(d)/40.);\n    }\n    \n    o = vec4(s,0,0);\n}\n", "buffer_d_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592653589793\n\n#define TURBULENCE 1.5\n#define DIFFUSION 1e-8", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 100]], "test": "untested"}
{"id": "3ttSzX", "name": "The Nautilus, Part 4", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\"; part 4 of a series", "tags": ["model", "submarine", "sciencefiction", "verne"], "likes": 7, "viewed": 314, "published": 3, "date": "1581442601", "time_retrieved": "2024-07-30T21:24:40.433525", "image_code": "// \"The Nautilus, Part 4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot;\nint idObj;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idBase = 20;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  q = p;\n  q.y -= -2.;\n  d = PrRoundBoxDf (q, vec3 (1.5, 0.05, 4.), 0.05);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 2.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (1.5, 0.3, 0.03), 0.05));\n  DMIN (idBase);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.4, 0.4, 0.5, 0.1);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj != idBase) {\n      col4 = NautColN (ro, vn);\n      col4.rgb = pow (Maxv3 (col4.rgb), 0.7) * mix (vec3 (0.8, 1., 1.), vec3 (1., 1., 0.8), - dot (vn, rd));\n      if (col4.a < 0.) col4.a = 0.2;\n    } else {\n      col4 = vec4 (0.4, 0.1, 0., 0.2) * (0.3 + 0.7 * Fbm2 (vec2 (1., 4.) * ro.xz));\n    }\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else {\n    col = vec3 (0., 0., 0.5);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  sbPos = vec3 (-0.5, 0., 0.);\n  sbRot = 0.5 * pi;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.05 * pi * tCur;\n    el -= 0.1 * pi * sin (0.04 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  dstFar = 60.;\n  zmFac = 5.;\n  ro = vuMat * vec3 (0., 0., -24.);\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1037, 1037, 1060, 1060, 3941], [3943, 3943, 3965, 3965, 4328], [4330, 4330, 4363, 4363, 4546], [4548, 4548, 4569, 4569, 4824], [4826, 4826, 4863, 4863, 5104], [5106, 5106, 5145, 5145, 7783], [7785, 7785, 7820, 7820, 8603], [8620, 8620, 8676, 8676, 9798], [9800, 9800, 9833, 9833, 9922], [9924, 9924, 9970, 9970, 10017], [10019, 10019, 10052, 10052, 10079], [10081, 10081, 10123, 10123, 10174], [10176, 10176, 10235, 10235, 10366], [10368, 10368, 10421, 10421, 10482], [10484, 10484, 10506, 10506, 10544], [10546, 10546, 10582, 10582, 10788], [10790, 10790, 10835, 10835, 10938], [10940, 10940, 10997, 10997, 11080], [11082, 11082, 11112, 11112, 11225], [11259, 11259, 11283, 11283, 11413], [11415, 11415, 11439, 11439, 11659], [11661, 11661, 11686, 11686, 11872], [11874, 11874, 11899, 11899, 12124], [12126, 12126, 12147, 12147, 12302], [12304, 12304, 12325, 12325, 12480], [12482, 12482, 12511, 12511, 12723], [12725, 12725, 12764, 12764, 12949]], "test": "untested"}
{"id": "3ttXzj", "name": "whiskey runner", "author": "flockaroo", "description": "billy gibbons' whiskey runner - car physics simulation (needs a while to compile on windows)\nsteering: WASD, or cirsor keys\nzoom: +/- keys", "tags": ["simulation", "physics", "car", "zztop"], "likes": 52, "viewed": 1519, "published": 3, "date": "1581436123", "time_retrieved": "2024-07-30T21:24:41.848742", "image_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop whiskey runner\n\n//#define RENDERED_REFECTIONS\n#define SHADOW\n#define SCRATCHES\n#define RENDER_GLASS\n//#define RENDER_BBOX\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n#ifndef PhysTex\n#define PhysTex iChannel1\n#endif\n#ifndef RandTex\n#define RandTex iChannel0\n#endif\n\n\nvec4 myRandInterpol(vec2 uv)\n{\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv-1./512.);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    //f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\n//#define RND_SC (256./64.)\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=\n     .8*myRandInterpol(p.xy*.00006*RND_SC)\n    +.4*myRandInterpol(p.xy*.00012*RND_SC)\n    //+.1*textureLod(iChannel0,p.xy*.12*RND_SC,0.)\n    ;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    vec2 fp=fract(p.xy*.5)-.5;\n    //return .2*exp(-fp.x*fp.x/.1/.1)+.2*exp(-fp.y*fp.y/.1/.1);\n    return rTerr.x*min(pp*pp,40.)+.1*textureLod(RandTex,p.xy*.012*.5*RND_SC,0.).x;\n}\n\nvec3 terrNormal(vec3 pos)\n{\n    //float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(1,0,0))-hTerr(pos-vec3(1,0,0)),\n    \t\t\t  hTerr(pos+vec3(0,1,0))-hTerr(pos-vec3(0,1,0)))*.5;\n    return normalize(vec3(-dh,1));\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,0)*.5,1.); WheelOffsFL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,0)*.5,1.); WheelOffsFR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,0)*.5,1.); WheelOffsRL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,0)*.5,1.); WheelOffsRR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n}\n\n\n#define BG 0.\n#define CARBODY 1.\n#define GUMMI 2.\n#define RIM 3.\n#define FLOOR 4.\n#define CHROME 5.\n#define INTERIOR 6.\n#define GLASS 7.\n#define CHASSIS 8.\n#define DBG_GREEN 9.\n#define DBG_RED 10.\n\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n//#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.5),    1.,   1., vec2(1,.03))\n#define MAT_GUMMI      Material(vec3(.15,.15,.15),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(.3),          -1.,   0.6, vec2(1,.01))\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#define MAT_CHROME     Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.45),              1.,  1.0, vec2(1,.01)*.5)\n#define MAT_DBG_GREEN  Material(vec3(0,1,0), -1.,  0.0, vec2(1,.01))\n#define MAT_DBG_RED    Material(vec3(1,0,0), -1.,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[11] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_GUMMI     ,\nMAT_RIM       ,\nMAT_FLOOR     ,\nMAT_CHROME    ,\nMAT_INTERIOR  ,\nMAT_GLASS     ,\nMAT_CHASSIS   ,\nMAT_DBG_GREEN ,\nMAT_DBG_RED\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==CHROME)       return MAT_CHROME    ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==DBG_GREEN)    return MAT_DBG_GREEN ;\n    if(mtl==DBG_RED)      return MAT_DBG_RED   ;\n}\n#endif\n\n#define DESERT FLOOR\n#define TIRE GUMMI\n#define GRILL CHROME\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 rand3d(vec3 uv)\n{\n    float pz=uv.z*256.;\n    float z=floor(pz);\n    vec2 uv1=uv.xy+z*vec2(17,31)/256.;\n    vec2 uv2=uv1+vec2(17,31)/256.;\n    return mix(textureLod(RandTex,uv1,0.),textureLod(RandTex,uv2,0.),pz-z);\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    float ang = atan(p.z,p.y);\n    float l=length(p.zy);\n    p.x+=cos(ang*100.)*.005*smoothstep(.87*r,1.*r,l);\n    d=max(d,distTorus(p.yzx+vec3(0,0,.03),r*.78,r*.28));\n    d=max(d,-l+r*.61);\n    float dx=.04;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.01));\n    return d;\n}\n\n\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    vec3 p0=p;\n    p.x=abs(p.x);\n    //p.yz=(p.y>p.z)?p.zy:p.yz; // only first 1/8 segment\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,.6*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.6*r),.015);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.8*r),.015);\n    float d_i=sdRoundedCylinder(p,.77*r,.01,1.9*r);\n    d=-smin(-d,d_i,.015);\n    \n    float d2=length(p0-vec3(-r*.6,0,0))-r*1.05;\n    d2=max(d2,d_i);\n    d2=-smin(-d2,sdRoundedCylinder(p,.4*r,.01,.8*r),.1);\n    d2=abs(d2)-.005;\n    d2=max(d2,-p0.x);\n\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    float dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n\n    d2=-smin(-d2,(length(p.xz-.95*r*cos(ang-vec2(0,1.57)))-.25*r),.01);\n    d=min(d,d2);\n    dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.3*r*cos(ang-vec2(0,1.57)))-.05*r)));\n    d=min(d,sdRoundedCylinder(p-vec3(0,-.23,0),.1*r,.01,.25));\n    float l=length(p0.zx);\n    d=min(d,sdRoundedCylinder(p0.zxy-vec3(0,-.06,0),.7*r,.02,.05-.015*fermi((length(p.xz)-.6*r)/.003)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,-.06,.07);\nconst vec3 bbsize=vec3(ALLW*1.12,3.63,1.5);\nconst vec3 bbpos1=vec3(0,.04,-.231);\nconst vec3 bbsize1=vec3(ALLW*1.08,3.68,1.23);\nconst vec3 bbpos2=vec3(0,.23,.33);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\n#define PF WheelPosFL\n#define PR WheelPosRL\n\n\nvec2 distCar(vec3 p)\n{\n    //p.xy*=-1.;\n    vec3 p0rot=p;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),-.023));\n    float d=1000., d_mat=1001., mat=-1.;\n    SET_PREV_MAT(BG);\n    p*=2.;\n    if(p.x<0.) p.x=-p.x;\n    vec3 p0=p+vec3(0,0,.13);\n//#define SIMPLE_CAR\n#ifndef SIMPLE_CAR\n    //d=min(d,length(p)-.5);\n    p=p0+vec3(0,.1,0);\n    float drumpf=sdRoundBox( p, vec3(RUMPFW+p.y*.15-p.y*p.y*.04+p.z*p.y*.03, \n                                 3.2-p.z*.3+p.z*p.z*.1 - step(0.,-p.y)*p.x*.3-step(0.,p.y)*.4*p.z, \n                                 .8+p.y*.02-p.x*p.x*.05*(1.+.01*(p.y*p.y*p.y*p.y))),\n                             max(p.y*.04,mix(.25+p.y*.05,.07,-p.z*1.5+.5)))*.7;\n    p=p0-vec3(0,.5,.7);\n    float dcabin = sdRoundBox( p, vec3(RUMPFW*1.04+p.y*.07-p.y*p.y*.08+p.z*.0, \n                                       1.2-p.z*(.7-.4*step(0.,p.y)),\n                                       .7+p.y*.07-p.x*p.x*.05-p.y*p.y*.05),\n                               .33+.15*p.y )*.7;\n    d=min(d,dcabin);\n    // rear front screen\n    p=p0-vec3(0,.4,.88+.10-.06*p.x*p.x);\n    //float dfrontscr=sdRoundBox( p, vec3(RUMPFW*.4-step(0.,p.y)*.2,2.,.1-step(0.,p.y)*.03)*2., .1 )*.7;\n    // only 2d needed - not sure if rect is faster - maybe some compilers can optimize something out...\n    float sy=step(0.,p.y);\n    float dfrontscr=sdRoundRect( p.xz-vec2(0,-.12+sy*.1), vec2(RUMPFW*.4-sy*.2,.12-step(0.,p.y)*.07)*2., .14-sy*.04 )*.7;\n    dfrontscr=max(dfrontscr,-(drumpf-.07));\n    d=-smin(-d,dfrontscr,.03);\n    //d+=rille(dfrontscr-.03,.007);\n    // side screens\n    p=p0-vec3(0,.23,.91);\n    vec3 sidebox=vec3(2.,.35-(p.z+.3)*(.1+step(0.,p.z+.3)*.1),.065+p.y*.023-.05*p.y*p.y*step(0.,p.z))*2.;\n    //float dsidescr=sdRoundBox( p-vec3(0,.1*p.z,.015*p.y), sidebox, .13+.04*p.y )*.7;\n#if 1\n    float dsidescr=sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y), sidebox.yz, .1+.07*p.y )*.7;\n    //p.z+=.25;\n    //float ddoor   =sdRoundBox( p-vec3(0,.1*p.z,.015*p.y)+vec3(0,0,.59), sidebox+vec3(0,0,.59), .13+.04*p.y )*.7;\n    float ddoor   =sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y)+vec2(0,.79), sidebox.yz+vec2(0,.79), .08+.07*p.y )*.7;\n#else\n    // not sure if even making 2 rects at once is really faster...\n    vec2 dssdoor=sdRoundRect2( (p.yz-vec2(.1*p.z,.015*p.y)).xyxy+vec4(0,0,0,.59), sidebox.yzyz+vec4(0,0,0,.59), vec2(.13+.04*p.y) )*.7;\n    float dsidescr=dssdoor.x;\n    float ddoor=dssdoor.y;\n#endif\n    ddoor-=.07;\n    //p=p0-vec3(0,-2.05,.77)*1.;\n    //p=transformVecByQuat(p-vec3(0,p.x*.25,0),axAng2Quat(vec3(1,0,0),.28));\n    //float dhood   =sdRoundBox( p,vec3(ALLW,.9,1.),.18)*.7;\n    //float dhood   =sdRoundRect( p.yz,vec2(.9,2.),.18)*.7;\n    float dhood1 =  dot(p0-vec3(0,-3.22,0),vec3(.28,-1,.28));\n    float dhood2 =  -dot(p0-vec3(0,-1.35,0),vec3(.28,-1,.28));\n    float dhood=max(dhood1,dhood2);\n    d=-smin(-d,dsidescr,.05);\n    //d=-smin(-d,abs(dsidescr-.03),.02);\n    d-=clamp((abs(dsidescr-.03)-.016)*.2,-0.02,0.);\n    p=p0;\n    p-=vec3(0,0,-.77);\n    float dz1=.5*(cos(p.x*4./ALLW)-1.)*(cos(p.y*1.5-2.-step(2.86,-p.y)*.8*(p.y+2.86)*(p.y+2.86))*.4+.4)*step(.766,-p.y);\n    float dz2=.5*(cos(p.x*3.3/ALLW)-1.)*clamp((cos(p.y*.6-1.5)*2.5-2.)*1.7,0.,1.);\n    p.z+=dz1+dz2;\n    p-=vec3(0,-.07,0);\n    //float dfender = sdHalfRoundBox( p, vec3(ALLW+p.y*.05,\n    //                            3.5-.12*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16),\n    //                            .16 )*.7;\n    \n    #if 1\n    float dfender = sdRoundBox( p-vec3(0,0,-.3), vec3(ALLW+p.y*.05,\n                                3.5-.1*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16+.3),\n                                .16 )*.7;\n    float ss=1.-smoothstep(-3.,-1.8,p.y);\n    float fz0=p.z-dz1*(exp2(-ss*7.));\n    dfender=min(dfender,(sqrt(dfender*dfender+fz0*fz0)-.01)*.7);\n    dfender=max(dfender,-(fz0)*.7);\n    //d=min(d,dfender);\n    #endif\n    \n    SET_PREV_MAT(CARBODY);\n    //drumpf-=clamp(abs(dhood)-.005,-0.02,0.);\n    \n    //drumpf = max(drumpf,-sdBox(pi+vec3(0,.12,0),vec3(2.,.05,.1))/1.4);\n\n    //drumpf=max(drumpf,-sdRoundedCylinder((p0-PR).zxy,.8,.05,.5));\n    float dfloorline=p0.z+0.7-.5*(.5-.5*cos((p0.y*1.-p0.y*p0.y*.1)*step(0.,-p0.y)));\n    ddoor=-smin(-ddoor,dfloorline-.06,clamp(.15-.1*p0.y,0.01,.3));\n    dhood=-smin(-dhood,dfloorline-.08,clamp(.25+.05*p0.y,0.01,.3));\n    drumpf-=max(-dfloorline*.5-1.3*dfloorline*dfloorline,0.)*5.*clamp(((-p0.y-1.8)-.9*(-p0.y-1.8)*(-p0.y-1.8))*abs(-p0.y-1.8),0.,11.);\n    //drumpf-=rille2(dfender,.02);\n\n    drumpf+=rille(dhood,.005);\n\n    dfloorline=smin(length((p0-PR-vec3(0,0,.15)).zy)-.75,dfloorline,.4);\n    //drumpf-=.5*rille2(length((p0-PR-vec3(0,0,.15)).zy)-.75,.03);\n    drumpf-=.5*rille2(dfloorline,.03)*smoothstep(-.05,.05,p0.y+3.1);\n    \n    //side stripe\n    p=p0+vec3(0,.1,0);\n    drumpf-=.6*rille2(p.z-.4+.03*p.y-.1*p.x,.02)*(1.-smoothstep(2.4,2.6,abs(p0.y+.3)));\n\n    //drumpf+=min(bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.2+.02*smoothstep(2.8,2.9,-p.y),0.)/1.5; \n    //float dBigZ=length(vec2(bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.2,drumpf))-.01;\n    float dBigZ=bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.085*(1.-smoothstep(2.55,2.6,abs(p0.y+.35)))+abs(drumpf);\n    //drumpf+=dBigZ;\n    \n    // side lamelles\n    vec3 pi = p0+vec3(0,-drumpf*2.-p0.z*.3,0)-vec3(0,-1.78,.3);\n    drumpf = max(drumpf,-sdBox(pi-vec3(0,clamp(floor(pi.y/.12+.5)*.12,-1.08,0.34),0),vec3(2.,.047,.11))/1.4);\n    \n    drumpf+=rille(sdRoundRect(p0.yz-vec2(-2.05+(p0.z-.3)*.3,.3),vec2(.8,.15),.03),.005);\n    \n    drumpf=min(drumpf,dBigZ);\n    \n    //*clamp((abs(p.z-.55)-.02)*.5,-0.02,0.);\n    d=smin(d,drumpf,.03);\n    //d=-smin(-d,abs(ddoor),.01);\n    //d-=clamp(abs(ddoor)-.005,-0.02,0.);\n    d+=rille(ddoor,.005);\n    //d=min(d,dfender+.01-.03*smoothstep(-1.45,-1.4,-p0.y)*smoothstep(-.95,-.9,p0.y));\n    //SET_PREV_MAT(TIRE);\n    \n    float z=p.z+.2;\n    float dgrillhole=sdRoundBox( p-vec3(0,-3.,-.02), vec3(.18*.9*RUMPFW-step(0.,-z)*z*z*.58*RUMPFW,.5,.33)*2., .1 );\n    d=-smin(-d,dgrillhole,.04);\n    float f=smoothstep(-3.,0.,p.y);\n    //float d2 = -smin(-d,-dgrillhole+.15,.04)\n    d=-smin(-d,-dgrillhole+.1+f*10.,.04);\n    float newmtl=(dhood1<0.)?CARBODY:GRILL;\n    SET_PREV_MAT(newmtl);\n    //SET_PREV_MAT(TIRE);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.01,dcabin+.01))-.015);\n    SET_PREV_MAT(GUMMI);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.02,dcabin+.01))-.02);\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3( 0, -3.26+.3*p.z+.35*p.x-.1*p.z*p.z, 0);\n    p.x=mod(p.x+.005,.025)-.0125;\n    d=min(d,max(dgrillhole,(length(p.xy)-.007)*.8));\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3(0,.7,.87-.2);\n    d=max(d,-dcabin-.06);\n    SET_PREV_MAT(INTERIOR);\n    \n#ifdef RENDER_GLASS\n    // window glass\n    //if(enable_glass)\n    {\n        d=min(d,dcabin+.035+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n#endif\n\n#else // SIMPLE_CAR\n    d=min(d,sdBox(p,vec3(2,5,1.)*.5));\n    SET_PREV_MAT(GRILL);\n#endif // SIMPLE_CAR\n\n    p0-=vec3(0,0,.13);\n    \n    vec3 pf=p0-PF;\n    vec3 pr=p0-PR;\n    \n    // check tire only once\n    //bool rear = (dot(pr,pr)<dot(pf,pf));\n    float rear = step(0.,p0rot.y);\n    float left = step(0.,p0rot.x);\n    float leftSgn=sign(p0rot.x);\n    p=mix(pf,pr,rear); float siz=mix(WheelRadiusF,WheelRadiusR,rear);\n    \n    float axOffs=0.;\n    vec4 axQuat=vec4(0,0,0,1);\n#ifdef USE_SIMDATA\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    axQuat=mix(qf,qr,rear);\n    p=transformVecByQuat(p+wo*2.,axQuat)-wo*2.;\n    axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n    p.z-=axOffs;\n#endif\n\n#if 1\n    {\n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*SteerAng*(1.-rear));\n#if 0\n    p+=vec3(.07,0,0);\n    p = (p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w*p ));\n    p-=vec3(.07,0,0);\n#else\n    // the above is exactly this below... why is this not working... bug in nvidia pipeline?! or am i missing sth here??\n    p=transformVecByQuat(p+vec3(.16,0,0),q)-vec3(.16,0,0);\n#endif\n    }\n#endif\n\n#ifdef USE_SIMDATA\n    // wheel rotations\n    float rot=WheelRot.x;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n\n    d=min(d, distTire(p,siz));\n    SET_PREV_MAT(TIRE);\n    d=min(d, distRim(p,siz));\n    SET_PREV_MAT(RIM);\n    \n    p=p0;\n    float xx=p.x*p.x;\n    //p=pf+vec3(ALLW*.38,0,+.1-xx*.03-step(ALLW*.6,p.x)*(p.x-ALLW*.6)*.3)*2.;\n    //d=min(d,max(length(p.yz)-.05,p.x-ALLW*.7));\n    p=p0-PF*vec3(0,1,1);\n    // Frame\n    d=min(d,sdRoundBox(p-vec3(.55+p.y*.1,0,.15)+vec3(0,0,1)*(p.y+.3)*(p.y+.3)*sign(-p.y)*.38, vec3(.06-p.y*p.y*.05,.7,.08-p.y*p.y*.05), .015 ));\n    p=transformVecByQuat(p,axQuat);\n    // Blattfeder (leaf spring)\n    d=min(d,sdRoundBox(p+vec3(0,0,1)*p.x*p.x*.18*(1.-axOffs/.1), vec3(.8,.05,floor((.05-p.x*p.x*.035)/.008)*.008), .005 ));\n    p.z-=axOffs;\n    p.z+=.25*cos(p0.x*.8)-.15*fermi((p0.x-PF.x+.3)/.02);\n    d=min(d,sdRoundBox(p, vec3(1.15,.02+.02*fermi((abs(p.z)-.03)/.002),.065-p.x*p.x*.015), .005 ));\n    d=min(d,sdRoundedCylinder(p.xzy-vec3(+.9,0,0),.035,.005,.11));\n    d=min(d,sdRoundedCylinder(p.xzy-vec3(+1.15,0,0),.035,.005,.11));\n    d=max(d,-sdRoundedCylinder(p-vec3(floor(min(p.x,.8)/.1+.5)*.1,0,0),.03,.005,.11));\n    //d=min(d,dDirLine(pf,vec3(-.4,-.1,-.1),vec3(-1,0,1.5),.5)-.04);\n    //d=min(d,dDirLine(pf,vec3(-.42,.1,-.2),vec3(.05,1,-0.02),1.5)-.005+p0.y*.025);\n    d=min(d,sdLine(p0-vec3(0,PF.yz),transformVecByQuat(vec3(-.42+PF.x,.1,-.2),inverseQuat(axQuat))+vec3(0,0,axOffs),\n                      vec3(-.22+PF.x,2.,-.25)\n                  )-.02+p0.y*.015);\n    \n    SET_PREV_MAT(CHASSIS);\n    \n    #if 0\n    p=p0-vec3(.37,-1.57,0.1)*2.;\n    float d1=1000.;\n    d1=min(d1, length(p)-.11*2.1);\n    d1=-smin(-d1, (length(p+vec3(0,.35,0))-.17*2.1),.02);\n    d=min(d,d1);\n    SET_PREV_MAT(HEADLIGHTS);\n    #endif\n    \n    #ifdef RENDER_BBOX\n    //if(enable_glass)\n    {\n        p=p0;\n        //d=min(d,abs(sdRoundBox( p0rot-bbpos, bbsize*.5, .0)));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos1, bbsize1*.5, .0))+(enable_glass?0.:1000.));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos2, bbsize2*.5, .0))+(enable_glass?0.:1000.));\n        //d=min(d,abs(sdRoundBox( p0rot-vec3(0,-.06,-.11), vec3(ALLW*1.1,3.63,1.13)*.5, .0)));\n        //d=min(d,abs(sdRoundBox( p0rot-vec3(0,.33,.47), vec3(ALLW*.8,1.25,.7)*.5, .0)));\n        SET_PREV_MAT(GLASS);\n    }\n    #endif\n    \n    return vec2(d*.5,mat);\n}\n\nbool enable_car=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    \n    if(enable_car)\n    {\n        vec2 dm=distCar(carTrafo(p));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    \n    vec4 r=texture(iChannel0,p.xy*1.5*RND_SC,0.)-.5;\n    vec4 r2=texture(iChannel0,(p.xy*.005*RND_SC),-.5)-.5;\n    vec4 r3=texture(iChannel0,(p.xy*.015*RND_SC),-.0)-.5;\n    vec4 r4=texture(iChannel0,(p.xy*.03*RND_SC),-.0)-.5;\n    vec4 r5=texture(iChannel0,(p.xy*.06*RND_SC),-.0)-.5;\n    float rm=r3.y*1.+r4.y*.5+r5.y*.25;\n    float rm2=r3.z*.7+r4.z*.5;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n\n    d=min(d,p.z\n    +.66\n    -hTerr(p)\n    -.02-min(-abs(rm)*.06,.04-exp(-abs(rm/(r2.x+.15)*.25)*3.)*.07)-r.x*.0035\n    );\n    SET_PREV_MAT(FLOOR);\n    \n    //#define DEBUG\n    #ifdef DEBUG\n    vec3 accFrontAxe = texelFetch(PhysTex,ivec2(7,0),0).xyz;\n    vec3 accRearAxe  = texelFetch(PhysTex,ivec2(8,0),0).xyz;\n    d=min(d,sdLine(p,carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.),carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.)+accFrontAxe)-.1);\n    d=min(d,sdLine(p,carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.),carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.)+accRearAxe)-.1);\n    SET_PREV_MAT(DBG_GREEN);\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad()\nvec3 getGrad(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=1000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=0;i<150;i++)\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.8;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n        if (d>300.) break;\n    }\n    return clamp(dmin/length(pmin-p0)/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=1.;\n    ao=getAO(pos,n);\n    ao=sqrt(ao);\n    ao=ao*.7+.3;\n\n    //vec3 light = normalize(vec3(-.5,.5,2));\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    if(mat==CARBODY) // brushed metal surface\n    {\n        vec4 r1=rand3d(pc*.1);\n        vec4 r2=rand3d(pc*.05);\n        // scramble normals randomly\n        n+=clamp((r1.xyz-.5)*5.,0.,1.)*.015 + clamp((r2.xyz-.5)*5.,0.,1.)*.015;\n        // darken randomly\n        n*=clamp(r1.w*3.-1.,0.,1.)*.05 + clamp(r2.w*3.-1.,0.,1.)*.07 + .88;\n    }\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.85+.15;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        //col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.5,vec3(1.,1,.9),diff)*ao*1.3;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,bg,1.-clamp(exp(-zr+.1),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol,glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\n#ifdef CAM_ANIM\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    calcWheelOffsets(-.2,.2);\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    if(iMouse.x<1.) { th=1.45; ph=-iTime*.25; }\n    th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=camTrafoInv(pos,1.);\n    // make sure cam is always above ground\n    pos.z=max(hTerr(pos)-.6,pos.z);\n    dir=camTrafoInv(dir,0.);\n\n    #ifdef CAM_ANIM\n    if(iMouse.x<1.)\n    {\n        pos=getCamAnimPos(iTime);\n        dir=normalize(getCamAnimDir(iTime));\n        vec3 right=normalize(cross(dir,vec3(0,0,1)));\n        vec3 up=cross(right,dir);\n        dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    #endif\n\n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    float fres=0., ao=0.;\n    fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n    #endif\n    \n    #ifdef CAM_ANIM\n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    #endif\n\n\tfragColor.w=1.;\n}\n\n#if 0\nvoid mainImageXX( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    float snum=4.;\n    for(int i=0;i<max(int(snum),1);i++)\n    {\n        enable_glass=true;\n        vec4 col=vec4(0);\n        vec2 r = (texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(i*5+iFrame*13,0)+.1,256.0))&255,0).xy-.5)*1.;\n        //vec2 r = getRand(i+int(fragCoord.x+fragCoord.y*iResolution.x)).xy-.5;\n        mainImageS(col,fragCoord+r*((snum>0.)?1.:0.3));\n        fragColor+=col;\n        vec4 r2=texture(iChannel0,fragCoord/Res0*.707+iTime*4.5+float(i)*.1)-.5;\n        fragColor+=.05*r2;\n    }\n    fragColor/=floor(max(snum,1.));\n}\n#endif\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop whiskey runner\n\n// helper functions\n\n//#define COARSE_TERRAIN\n\n#define USE_SIMDATA\n\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// iq's capsule\nfloat sdLine( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n#if 0\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    //vec3 n=cross(cross(dir,p),dir);\n    //return length(p-dot(p,n)*n/dot(n,n))<size.y;\n\n    //return true;\n    \n    size*=.5;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    \n    vec3 s=sign(dir);\n    vec3 invdir=1./dir;\n\n    tmin  = (-size.x*s.x - p.x) * invdir.x; \n    tmax  = ( size.x*s.x - p.x) * invdir.x; \n    tymin = (-size.y*s.y - p.y) * invdir.y; \n    tymax = ( size.y*s.y - p.y) * invdir.y; \n \n    if ((tmin > tymax) || (tymin > tmax)) return false; \n    if (tymin > tmin) tmin = tymin; \n    if (tymax < tmax) tmax = tymax; \n \n    tzmin = (-size.z*s.z - p.z) * invdir.z; \n    tzmax = ( size.z*s.z - p.z) * invdir.z; \n \n    if ((tmin > tzmax) || (tzmin > tmax)) return false; \n    if (tzmin > tmin) tmin = tzmin; \n    if (tzmax < tmax) tmax = tzmax; \n \n    return true; \n}\n#endif\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec2 ROT(float ang, vec2 v) \n{ \n    vec2 cs=sin(vec2(1.6,0)+ang); \n    return mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\nfloat bigZ(vec2 p)\n{\n    vec2 p0=p;\n    \n    p=ROT(-.05,p);\n    \n    p+=vec2(0,.7);\n    //float falloff=exp(-dot(p,p));\n    float falloff=1./(1.+dot(p,p)*2.);\n    p=ROT(-PI2*.2*falloff*p.y,p-vec2(0,.7));   // locally rotate around x by 180 degrees\n\n    p.x+=.7*p.y;\n    \n    //p.x-=p.y;\n    p=-sign(p.y+p.x)*p;\n    \n    float d=abs(max(-p.y-.5,p.x));\n    d-=.04+.1/(1.+dot(p0,p0)*3.)+.03*min(p0.x,0.);\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(-x));\n}\n\nfloat zmask(vec2 p)\n{\n    float skew=1.;\n    p.x += skew*p.y;\n    return step(p.y,step(-.35,p.x)-.5+.1)\n          -step(p.y,step( .35,p.x)-.5-.1);\n}\n\n\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define WheelDistF (ALLW*.78)\n#define WheelDistR (ALLW*.96)\n#define WheelPosFR (vec3(-WheelDistF*.5,-1.43,-.33)*2.)\n#define WheelPosRL (vec3( WheelDistR*.5, 1.23,-.35)*2.)\n#define WheelPosFL (vec3( WheelDistF*.5,-1.43,-.33)*2.)\n#define WheelPosRR (vec3(-WheelDistR*.5, 1.23,-.35)*2.)\n\nvec4 wheelOffs=vec4(0);\n#define WheelOffsRL wheelOffs.x\n#define WheelOffsRR wheelOffs.y\n#define WheelOffsFL wheelOffs.z\n#define WheelOffsFR wheelOffs.w\n\n#define WheelRadiusF .62\n#define WheelRadiusR .7\n\n\n", "buffer_a_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// some minimal driving sim (not much physics involved here, just simple driving/steering)\n\n#define RandTex iChannel2\n#define PhysTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#ifndef PhysTex\n#define PhysTex iChannel1\n#endif\n#ifndef RandTex\n#define RandTex iChannel0\n#endif\n\nvec4 myRandInterpol(vec2 uv)\n{\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv-1./512.);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    //f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\n//#define RND_SC (256./64.)\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=\n     .8*myRandInterpol(p.xy*.00006*RND_SC)\n    +.4*myRandInterpol(p.xy*.00012*RND_SC)\n    //+.1*textureLod(iChannel0,p.xy*.12*RND_SC,0.)\n    ;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    vec2 fp=fract(p.xy*.5)-.5;\n    //return .2*exp(-fp.x*fp.x/.1/.1)+.2*exp(-fp.y*fp.y/.1/.1);\n    return rTerr.x*min(pp*pp,40.)+.1*textureLod(RandTex,p.xy*.012*.5*RND_SC,0.).x;\n}\n\nvec3 terrNormal(vec3 pos)\n{\n    //float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(1,0,0))-hTerr(pos-vec3(1,0,0)),\n    \t\t\t  hTerr(pos+vec3(0,1,0))-hTerr(pos-vec3(0,1,0)))*.5;\n    return normalize(vec3(-dh,1));\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,0)*.5,1.); WheelOffsFL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,0)*.5,1.); WheelOffsFR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,0)*.5,1.); WheelOffsRL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,0)*.5,1.); WheelOffsRR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n}\n\n\n#define keyTex iChannel1\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_A (texture(keyTex,vec2((65.5+ 0.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_W (texture(keyTex,vec2((65.5+22.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_R (texture(keyTex,vec2((65.5+17.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_S (texture(keyTex,vec2((65.5+18.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_D (texture(keyTex,vec2((65.5+ 3.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_F (texture(keyTex,vec2((65.5+ 5.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_PLUS  (texture(keyTex,vec2((187.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_MINUS (texture(keyTex,vec2((189.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_LEFT  (texture(keyTex,vec2(( 37.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_RIGHT (texture(keyTex,vec2(( 39.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_DOWN  (texture(keyTex,vec2(( 40.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_UP    (texture(keyTex,vec2(( 38.5)/256.0,(0.5+0.0)/3.0)).x)\n\n#define CalcTorque(a,r) cross((r),transformVecByQuat((a),iquat)*Mass)/I\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    #ifdef ZZT_AS_TEX\n    vec2 uv = fragCoord.xy / Res0;\n    fragColor = zztop((uv*2.-.75)*11.,-1.);\n    #endif\n\n    vec3  pos      = texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    vec3  vel      = texelFetch(PhysTex,ivec2(1,0),0).xyz;\n    vec3  omega    = texelFetch(PhysTex,ivec2(2,0),0).xyz;\n    vec4  quat     = texelFetch(PhysTex,ivec2(3,0),0);\n    float SteerAng = texelFetch(PhysTex,ivec2(4,0),0).x;\n    float camDist  = texelFetch(PhysTex,ivec2(4,0),0).y;\n    vec4  wheelRot = texelFetch(PhysTex,ivec2(5,0),0);\n    vec4  camQuat  = texelFetch(PhysTex,ivec2(6,0),0);\n    vec4  iquat = inverseQuat(quat);\n    \n    calcWheelOffsets(-1.2,1.2);\n    \n    float dt=min(iTimeDelta,.03);\n    \n    float axDist=3.5;\n    vec3 rearAxPos = vec3(0,1.7,0);\n    \n    //quat=vec4(0,0,0,1);\n    vec3 bx=transformVecByQuat(vec3(1,0,0),quat);\n    vec3 by=transformVecByQuat(vec3(0,1,0),quat);\n    vec3 bz=transformVecByQuat(vec3(0,0,1),quat);\n    \n    vec3 acc=vec3(0);\n    vec3 alpha=vec3(0);\n    \n    float Mass=1000.;\n    vec3 S=vec3(2.,3.2,1.5);\n    vec3 I=vec3(S.y*S.y+S.z*S.z, S.z*S.z+S.x*S.x, S.x*S.x+S.y*S.y)*Mass/12.;\n    float mu = .7;\n    #define GRAVITY 9.81\n    acc+=GRAVITY*vec3(0,0,-1);\n    float SpringOmega=10.;\n    float SpringGamma=20.;\n    \n    vec3 n=terrNormal(pos);\n    \n    float grip=step(pos.z,hTerr(pos)+.1);\n    \n    // FIXME: just one central springforce for now\n    float dTerr=(pos.z-hTerr(pos))*n.z;\n    acc += grip*(0.*GRAVITY+SpringOmega*SpringOmega*(.1-dTerr))*n;\n        \n    // FIXME: just angular spring for now... (use wheel forces instead)\n    alpha -= 150.*grip*cross(transformVecByQuat(n,iquat)*Mass,normalize(vec3(0,.0,1)))/I;\n\n    vec3 dacc=vec3(0);\n    vec3 dalpha=vec3(0);\n    \n    dacc-=30.*grip*(max(KEY_W,KEY_UP)-max(KEY_S,KEY_DOWN))*by;\n    acc+=dacc;\n    \n    // FIXME: get rid of tweak-constant 0.15\n    alpha-=.2*grip*cross(transformVecByQuat(dacc,iquat)*Mass,.5*(WheelPosRL+WheelPosRR))/I;\n        \n    SteerAng*=.91;\n    SteerAng-=(max(KEY_A,KEY_LEFT)-max(KEY_D,KEY_RIGHT))*.05;\n    camDist*=(1.-.02*KEY_PLUS);\n    camDist*=(1.+.02*KEY_MINUS);\n    \n    //quat=multQuat(quat,axAng2Quat(vec3(0,0,1),+.001*SteerAng*dot(vel,by)));\n    \n    vec3 accFrontAxe;\n    vec3 accRearAxe;\n    \n    // friction on front/back tire (one virtual middle tire)\n    for(int i=0;i<2;i++)\n    {\n        vec3 fricDir=vec3(cos(SteerAng),-sin(SteerAng),0);\n        vec3 fricPos=.5*(WheelPosFL+WheelPosFR);\n        if (i==1)\n        {\n            fricDir=vec3(1,0,0);\n            fricPos=.5*(WheelPosRL+WheelPosRR);\n        }\n        // FIXME: this should be +omega ?!\n        vec3 dv = cross(omega,fricPos) + transformVecByQuat(vel,iquat); // speed of wheelpos (by car rotation) + car speed\n        dv = clamp(dot(dv,fricDir)*1.,-4.,4.)*fricDir;  // just component normal to wheel\n        dacc   = -transformVecByQuat(dv,quat)*mu*GRAVITY*grip*.5;\n        dalpha = CalcTorque(dacc,fricPos);\n        if(i==0) accFrontAxe=dacc;\n        if(i==1) accRearAxe=dacc;\n        acc+=dacc;\n        alpha+=dalpha;\n    }\n    \n    camQuat=normalize(mix(quat,camQuat,.95));\n\n    if(pos.z<hTerr(pos)) vel-=dot(vel,n)*n*.5;\n    //pos.z=.5+hTerr(pos);\n    //quat=multQuat(getTiltQuat(pos),quat);\n    acc-=.03*vel*length(vel);\n\n    vel+=acc*dt*.5;\n    pos+=vel*dt;\n    vel+=acc*dt*.5;\n#if 1\n    omega+=alpha*dt*.5;\n    //if (length(omega)>.1) omega=normalize(omega)*.1;\n    if (length(omega)>.001)\n        quat=multQuat(quat,angVec2Quat(omega*dt));\n    omega+=alpha*dt*.5;\n#endif\n    \n    //if(pos.z<hTerr(pos)) \n    vec3 omegaN=dot(omega,n)*n;\n    omega=(omega-omegaN)*mix(.98,.85,grip)+omegaN;\n    omega*=.99;\n    //vel*=.99;\n    if(length(vel)>.001) vel-=normalize(vel)*.005;\n    //if(length(vel)<.1) vel=vec3(0);\n    //if(length(omega)<.01) omega=vec3(0);\n    \n    float wheelRadius=(WheelRadiusF+WheelRadiusR)*.5*.5;\n    wheelRot-=-dot(vel,by)*dt/wheelRadius;\n    \n    if(iFrame==0)\n    {\n        pos=vec3(0,0,0.);\n        pos.z=hTerr(pos)+1.;\n        vel=vec3(0,0,0);\n        quat=normalize(vec4(0.03,0.02,0,1));\n        camQuat=quat;\n        omega=vec3(0);\n        SteerAng=0.;\n        wheelRot=vec4(0);\n        camDist=1.;\n    }\n    \n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor = vec4(pos,1.0);\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor = vec4(vel,1.0);\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor = vec4(omega,1.0);\n    if (ivec2(fragCoord)==ivec2(3,0)) fragColor = vec4(quat);\n    if (ivec2(fragCoord)==ivec2(4,0)) fragColor = vec4(SteerAng,camDist,0,1);\n    if (ivec2(fragCoord)==ivec2(5,0)) fragColor = vec4(wheelRot);\n    if (ivec2(fragCoord)==ivec2(6,0)) fragColor = vec4(camQuat);\n    if (ivec2(fragCoord)==ivec2(7,0)) fragColor = vec4(accFrontAxe,0);\n    if (ivec2(fragCoord)==ivec2(8,0)) fragColor = vec4(accRearAxe,0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[472, 472, 502, 502, 1060], [1108, 1108, 1129, 1129, 1509], [1511, 1511, 1538, 1566, 1728], [1730, 1730, 1758, 1758, 2183], [2186, 2213, 2253, 2253, 2529], [2531, 2531, 2554, 2554, 2584], [2586, 2615, 2658, 2658, 2920], [2922, 2922, 2965, 2965, 3227], [3229, 3229, 3278, 3278, 3689], [5460, 5460, 5493, 5493, 5517], [5524, 5524, 5557, 5557, 6098], [6245, 6245, 6267, 6267, 6466], [6468, 6468, 6494, 6494, 6730], [6816, 6862, 6909, 6909, 7747], [7750, 7750, 7783, 7783, 8183], [8186, 8186, 8218, 8218, 9373], [9616, 9616, 9648, 9648, 9683], [9684, 9684, 9715, 9779, 9864], [10191, 10191, 10213, 10230, 20756], [20781, 20781, 20805, 20805, 20827], [20829, 20829, 20849, 20849, 22027], [22029, 22029, 22049, 22049, 22070], [22072, 22072, 22109, 22109, 22308], [22310, 22351, 22385, 22385, 22653], [22655, 22655, 22692, 22758, 23377], [23379, 23379, 23421, 23421, 23467], [23469, 23469, 23500, 23500, 24149], [24151, 24151, 24256, 24256, 28372], [29291, 29291, 29348, 29348, 31204]], "test": "untested"}
{"id": "ttcXzX", "name": "Black Hole Render (my approach)", "author": "Txoka", "description": "Seems different to https://www.shadertoy.com/view/3ttXW7 i think it should be more accurate, but also i think its not.\n(define PATH CALCULATION MODE to 1 to see the other way (which should be less acurate?))\ndefine eyes for 3d view\nmouse to look arround", "tags": ["blackhole", "raypath"], "likes": 1, "viewed": 510, "published": 3, "date": "1581427948", "time_retrieved": "2024-07-30T21:24:43.028587", "image_code": "#define R iResolution\n//#define eyes\n\n#define PATH_CALCULATION_MODE 0\n\nconst float march_step_size=0.1;\nconst float eps=1e-5;\nconst int STEPS=128;\n\nstruct ray{\n\tvec3 ro;\n    vec3 rd;\n};\n\n//gravitational lens force\nvec4 glf(vec3 p,vec3 lens_pos,float lens_size){\n    p-=lens_pos;\n    return vec4(-normalize(p)/dot(p,p),-1./length(p))*lens_size;\n}\n\n//all forces (you can add more gravitational lenses)\nvec4 map(vec3 p){\n    vec4 n=glf(p,vec3(0),0.4);//vec4(force (vec3), potential (float))\n\t//n+=glf(p,vec3(4.*cos(iTime*.3),0.,4.*sin(iTime*.3)),0.3);\n    return n;\n}\n\nvoid march(inout ray r){\n    for(int i=0;i<STEPS;i++){\n    \tvec4 m=map(r.ro);\n        float step_size=march_step_size/(eps-m.w);\n        #if PATH_CALCULATION_MODE==0\n        r.rd=normalize(r.rd+step_size*m.xyz);\n        #else\n        r.rd=normalize(r.rd+0.1*m.xyz);\n        #endif\n        r.ro+=r.rd*step_size;\n        if(m.w>-0.01)break;\n    }\n}\n\nconst float pi=4.*atan(1.);\nvoid mainImage(out vec4 Q, in vec2 U){\n    vec3 uv = vec3((U*2.-R.xy)/R.y,1);\n    vec2 m=(iMouse.xy*2.-R.xy)/R.xy;\n    m*=vec2(1,0.5)*pi;\n    //if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    if(length(iMouse.xy)==0.)m=vec2(0);\n    \n    #ifdef eyes\n    vec3 ro=vec3(-0.2,0,0);\n    if(uv.x<0.)ro.x=0.2;\n    uv.xy+=ro.xy*5.;\n    #else\n    vec3 ro=vec3(0,0,0);\n    #endif\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    vec3 pos=vec3(0,0,sin(iTime/10.*pi/4.)*5.);\n    ray r=ray(ro-pos,normalize(uv-ro));\n    \n    march(r);\n    float potential=map(r.ro).w;\n    Q=texture(iChannel0,r.rd)/(1.-potential);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 214, 261, 261, 345], [347, 400, 417, 417, 564], [566, 566, 590, 590, 912], [942, 942, 980, 980, 1724]], "test": "untested"}
{"id": "3l3Xzf", "name": "Noise - wave - 2D : vector field", "author": "FabriceNeyret2", "description": "variant of Wave Noise - a simple wave based noise based on extremely simplified Gabor kernel. [url]https://shadertoy.com/view/tldSRj[/url]\n\nvector field +flownoise variant using complex Gabor (attention: div(V) != 0 ;-) ).", "tags": ["procedural", "2d", "noise", "velocity", "arrows"], "likes": 14, "viewed": 809, "published": 3, "date": "1581406493", "time_retrieved": "2024-07-30T21:24:43.789552", "image_code": "// vector field variant of \"Noise - wave - 2D\" by iq. https://shadertoy.com/view/tldSRj\n\n// Fabrice's way to see it: 1 Gabor kernel at each cell center, overlapping neighbor cells\n// Here, complex Gabor instead of just the real part.\n\n#define CS(a) cos(a + vec2(0,33))\n\nvec2 g( vec2 n ) { return CS(n.x*n.y); }  // use better hash than n.x*n.y\n\nvec2 noise(vec2 p)\n{\n    const float kF = 3.1415927;\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.-2.*f);\n    float t = (mod(i.x+i.y,2.)*2.-1.) * iTime;       // checkered rotation ( flownoise )\n    return mix(mix(CS( t+ kF*dot(p,g(i+vec2(0,0)))), // Gabor kernel (and overlapping neighbors)\n               \t   CS(-t+ kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(CS(-t+ kF*dot(p,g(i+vec2(0,1)))),\n               \t   CS( t+ kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\n\nfloat f, scale = 24.,      // scale of noise\n      sampling = 7.;       // density of vectors\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n\t    uv = ( u - R/2. ) / R.y,\n\t     p = fract(scale*uv)*2.-1., n; // p = local centered coords in cells\n    \n    // left: 1-band noise\t\n\tif( uv.x<0. )\n\t{\n        n = noise( floor(scale*uv)/sampling ); // floor: optional (without = curvy)\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n        mat2 m = mat2(2); // mat2( 1.6,  1.2, -1.2,  1.6 ); // sqrt2 not floor-friendly ;-)\n#define N(uv,s) noise( floor(scale*uv/s)*s/sampling ); // floor: optional (without = curvy)\n\t\tn  = 0.5000*N( uv, 1.); uv = m*uv;\n\t\tn += 0.2500*N( uv, 2.); uv = m*uv;\n\t\tn += 0.1250*N( uv, 4.); uv = m*uv;\n\t\tn += 0.0625*N( uv, 8.); uv = m*uv;\n\t}\n\n    // --- display vector field \n    \n  //n = normalize(n);  // optional : for more dramatic vortices\n    float l = length(n),\n          x = (n.x*p.y-n.y*p.x) / l,\n          w = dot(n,p) / l;         // option: arrow points to vector dir\n    f = smoothstep(scale*3./R.y, 0., abs(x)+.05*w ); // display vector line\n    f *= smoothstep(3./R.y, 0., abs(w)- l ); // optional: show vector length\n\t\n\tO = vec4( f );\n    \n    O.x += smoothstep( 3./R.y, 0., abs(uv.x) );\t// separator\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3Xzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 288, 288, 310], [345, 345, 365, 365, 830], [928, 928, 966, 966, 2103]], "test": "untested"}
{"id": "WlcSRf", "name": "Small Image Loader - 146 chars", "author": "GregRostami", "description": "This is the golfed version of archee's amazing \"press play on tape\" shader:\n[url]https://www.shadertoy.com/view/XtGXzW[/url]\n\nPlease help me make this smaller.\nThank you", "tags": ["2d", "image"], "likes": 6, "viewed": 569, "published": 3, "date": "1581390667", "time_retrieved": "2024-07-30T21:24:44.551515", "image_code": "// Greg's old code\n// #define mainImage(o,u) o = texture(iChannel0, u / iResolution.xy)\n\nvoid mainImage(out vec4 o, vec2 u) {mi(o,u);}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Greg's old code:\n/*\n#define mainImage(O,u)                    \\\n    vec2 U=u, R = iResolution.xy;         \\\n    U.y -= fract(iTime*20. * R.x/512.);   \\\n    O += U.y<1. ? texture(iChannel1, vec2((ceil( (1.- U.x/R.x) *512.)+.5)/512.,0 ) ).r * 2.  \\\n                : texture(iChannel0, U/R).r\n*/\n\nvoid mainImage(out vec4 o, vec2 u) {mi(o,u);}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21147, "src": "https://soundcloud.com/user-318202294/out-9", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// 146 chars - iq kills another character for the shortest version:\n#define mi(O,u)                              \\\n    vec2 R = iResolution.xy, U=u;                   \\\n    O += ( U.y -= fract(iTime*R.x*.04) ) < 1.       \\\n        ? U.x=R.x-U.x,texture(iChannel1, U/R ).r*2. \\\n        :             texture(iChannel0, U/R ).r /*\n\n// Thanks to ttg, iq, and Fabrice the whole shader is now 147 chars!!\n          \n#define mainImage(O,u)                         \\\n    vec2 R = iResolution.xy, U=u,              \\\n         V = R-U; V.y = 0.;                    \\\n    O += ( U.y -= fract(iTime*R.x*.04) ) < 1.  \\\n        ? texture(iChannel1, V/R ).r * 2.      \\\n        : texture(iChannel0, U/R ).r\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 125, 125, 134]], "test": "untested"}
{"id": "ttdXR2", "name": "Binary Fourier Image", "author": "ttg", "description": "Demonstrates how a Fourier domain representation of an image may be encoded into only two levels and still reproduce line drawings.\nLeft: Input\nCenter: Fourier transform's sign encoded into 0 and 1\nRight: Reverse Fourier transform Result of Center", "tags": ["fourier"], "likes": 6, "viewed": 629, "published": 3, "date": "1581382106", "time_retrieved": "2024-07-30T21:24:45.450113", "image_code": "void mainImage (out vec4 v, vec2 d) {\n  vec2 R = iResolution.xy;\n  vec2 uv = d/R;\n  float nx = 3.;\n  int n = int(floor(uv.x*nx));\n  uv.x = fract(uv.x*nx);\n  uv = .5+(uv-.5)/vec2(1.,R.x/R.y/nx);\n  v = vec4(0.);\n  if (all(lessThan(abs(uv-.5),vec2(.5)))) {\n    // Dot products: (Visual) Intensity is square of (EM wave) amplitude\n    if(n==0) { vec2 f = texture(iChannel0, uv*float(imgsize)/R).xy; v.rgb = vec3(dot(f,f)); }\n    if(n==1) { vec2 f = texture(iChannel1, uv*float(imgsize)/R).xy; v.rgb = vec3(f*f,0.); }\n    if(n==2) { vec2 f = texture(iChannel2, uv*float(imgsize)/R).xy; v.rgb = vec3(dot(f,f)); }\n  }\n  v*=.25;\n  v = pow(v,vec4(1./2.2));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A: Source image\n\nvoid mainImage (out vec4 v, vec2 d) {\n  v = vec4(0.);\n  if (any(greaterThan(ivec2(d),ivec2(imgsize)-1))) return;\n  vec2 uv = d/float(imgsize);\n  if (uv.x<.5) uv = 1.-uv;\n  float f = pow(texture(iChannel0, .05*uv).r, 2.2);\n  \n  // Make antialiased line contours\n  f = clamp(.75-1.*abs(f-.03)/fwidth(f),0.,1.)*.01/fwidth(f);\n\n  if (isnan(f)) f = 0.;\n  f = sqrt(f); // amplitude is sqrt of intensity\n  v = vec4(1,0,0,0)*f;\n}\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B: Complex Fourier transform of Buffer A\n\nvoid mainImage (out vec4 v, vec2 d) {\n  if (any(greaterThan(ivec2(d),ivec2(imgsize)-1))) discard;\n\n#ifndef METHOD_2\n\n  // Easier to understand: compute the Fourier transform one block at a time\n  BLOCKBAIL\n  v.xy += fourier(iChannel1, float(imgsize+1)-d, scale);\n\n#else\n\n  // Faster? : split sampling of the input over many frames\n  v = texelFetch(iChannel0, ivec2(d), 0);\n  v.zw += fourier_method2(iChannel1, float(imgsize+1)-d, scale, iFrame);\n  int nframes = m2subsample*m2subsample;\n  if (iFrame%nframes==0) {\n    // swap and reset\n    v.xy = v.zw; v.zw = vec2(0.);\n  }\n  if (iFrame<nframes) {\n    // first run: show progress\n    v.xy = v.zw;\n  }\n\n#endif\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifdef HW_PERFORMANCE\nconst int imgsize = 384;\n#else\nconst int imgsize = 192;\n#endif\n\nint m1blocksize = (1<<5);\n\n// turn off METHOD_2 for the original form of the shader\n#define METHOD_2\nint m2subsample = (1<<3);\n\nbool blocktest (ivec2 d, int frame) {\n    ivec2 s = ivec2(m1blocksize);\n    int b = d.x/s.x+imgsize/s.x*(d.y/s.y);\n    return (b==frame%(imgsize*imgsize/(s.x*s.y)));\n}\n\n#define BLOCKBAIL \\\n  if (blocktest(ivec2(d),iFrame-1)) { v=texelFetch(iChannel0,ivec2(d),0); return; } \\\n  if (!blocktest(ivec2(d),iFrame)) discard;\n\nvec2 fourier(sampler2D samp, vec2 d, float scale) {\n  vec2 v = vec2(0.);\n  d-=float(imgsize/2);\n  for (int iy=0; iy<imgsize; iy++) {\n    for (int ix=0; ix<imgsize; ix++) {\n      ivec2 i = ivec2(ix,iy);\n      float a = scale*2.*3.1415927*dot(floor(d),vec2(i-imgsize/2))/float(imgsize);\n      v += mat2(cos(a),sin(a),-sin(a),cos(a))*texelFetch(samp, i, 0).xy;\n    }\n  }\n  return v/float(imgsize)*scale;\n}\n\nvec2 fourier_method2(sampler2D samp, vec2 d, float scale, int frame) {\n  vec2 v = vec2(0.);\n  d-=float(imgsize/2);\n  ivec2 s = ivec2(m2subsample);\n  for (int iy=0; iy<imgsize; iy+=s.y) {\n    for (int ix=0; ix<imgsize; ix+=s.x) {\n      ivec2 i = ivec2(ix+frame%s.x,iy+(frame/s.x)%s.y);\n      float a = scale*2.*3.1415927*dot(floor(d),vec2(i-imgsize/2))/float(imgsize);\n      v += mat2(cos(a),sin(a),-sin(a),cos(a))*texelFetch(samp, i, 0).xy;\n    }\n  }\n  return v/float(imgsize)*scale;\n}\n\nconst float scale = 128./float(imgsize);", "buffer_c_code": "// Buffer C: Apply Two-value Thresholding to value from Buffer B\n\nvoid mainImage (out vec4 v, vec2 d) {\n\n  vec2 f = texelFetch(iChannel1, ivec2(d), 0).xy;\n\n//  v.xy = f; // plain fourier transform (complex)\n    \n  float fb = f.x;\n\n  // real component only, discretized into two values\n  // (with antialiasing of edges)\n  v.xy = vec2(1,0)*clamp(fb/fwidth(fb)+.5,0.,1.);\n\n//  v.xy = vec2(1,0)*(.5+.5*sign(fb)); // (no antialiasing)\n\n//  v.xy = .5*normalize(f); // (something else to try)\n\n  // Limit to a circle to avoid cross fringes along axes\n  // (with antialiasing of edges)\n  v.xy*= clamp(float(imgsize)/2.-length(d-float(imgsize)/2.+.5),0.,1.);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 649]], "test": "untested"}
{"id": "Wt3XRX", "name": "Path traced GI", "author": "loicvdb", "description": "Real time path tracing, except this time only the GI gets reprojected for a sharper result, it also makes room to add more effects such as volume rendering as demonstrated here", "tags": ["raymarching", "fractal", "volume", "gi", "dof", "volumetric", "fog", "pathtracing", "ao", "reprojection", "volumetrics"], "likes": 125, "viewed": 4313, "published": 3, "date": "1581380776", "time_retrieved": "2024-07-30T21:24:46.462407", "image_code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0.);\n    float frd = iResolution.y*cam.aperture*DoFClamping;\n    int rd = int(ceil(frd - .5));\n    for(int y = -rd; y <= rd; y++){\n        int ln = int(ceil(sqrt(frd*frd-float(y*y)) - .5));\n        for(int x = -ln; x <= ln; x++){\n            vec4 p = texelFetch(iChannel0, ivec2(clamp(fragCoord + vec2(x, y), vec2(0), iResolution.xy-1.)), 0);\n            float dof = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping) * iResolution.y*cam.aperture;\n            p.a = 1.;\n            p *= clamp((dof - length(vec2(x, y))) + .5, 0.0, 1.0) / (dof*dof+.5);\n            col += p;\n    \t}\n    }\n    \n    col /= col.a;\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.07 * iResolution.y, .0, fragCoord) * .06;\n    \n    fragColor = vec4(ACESFilm(col.rgb + bloomSum), 1.);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "bool trace(inout vec3 pos, in vec3 dir){\n    pos += dir*sdf(pos);\n    pos += dir*sdf(pos);\n    for(int i = 0; i < MaxStepsDirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            pos -= (2.*MinDist-dist) * dir;\n            pos -= (2.*MinDist-sdf(pos)) * dir;\n            pos -= (2.*MinDist-sdf(pos)) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    fragColor = vec4(0.);\n    vec3 pos = cam.pos;\n    if(trace(pos, dir)) fragColor = vec4(pos, 1.);\n}", "buffer_b_inputs": [], "buffer_c_code": "float seed;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\nvec3 background(vec3 dir){\n    return LightColor * Density * 8. * henyeyGreenstein(-LightDir, dir);\n}\n\nvec3 directBackground(vec3 dir){\n    return LightColor * Density * 1.;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < MaxStepsIndirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir;\n    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;\n    for(int i = 0; i < Bounces; i++){\n        dir = getCosineWeightedSample(normal);\n        if(!trace(pos, dir, normal)) return light + abso*background(dir);\n        sdf(pos, dc, ec);\n        light += abso * (ec + dc*directLight(pos, normal));\n        abso *= dc;\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MaxDist;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = MaxDist;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = .256435865*fragCoord.x+.316548465*fragCoord.y+sin(iTime)*16886.3158915;\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(directBackground(uv2dir(cam, uv)), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal = normalEstimation(hit.xyz);\n        \n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        \n        fragColor = previousSample(hit);\n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        iLight = clamp(iLight, vec3(.0), vec3(fragColor.a/10.)); // clamp gi for low sample count\n        fragColor.rgb = mix(fragColor.rgb, iLight, 1.0/(fragColor.a/float(IndirectSamples)));\n        #endif\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 tx = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 finalPos = tx.rgb;\n    col.a = length(cam.pos-finalPos);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    \n    if(tx.a != 0.) {\n        vec3 dc, ec;\n        sdf(finalPos, dc, ec);\n        col.rgb = ec + dc * (col.rgb + directLight(finalPos, normalEstimation(finalPos)));\n    } else {\n        finalPos = cam.pos + dir * 100.;\n    }\n    \n    vec3 volCol = vec3(0.), volAbs = vec3(1.), pos = cam.pos;\n    float stepDist = (tx.a == 0. ? FogRange : min(FogRange, col.a))/float(FogSteps);\n    vec3 stepAbs = exp(-Density*stepDist);\n    vec3 stepCol = (vec3(1.) - stepAbs) * henyeyGreenstein(-LightDir, dir);\n    pos += stepDist * dir * texture(iChannel2, fragCoord/vec2(1024)).a;\n    for(int i = 0; i < FogSteps; i++){\n        volAbs *= stepAbs;\n        volCol += stepCol*volAbs*directLight(pos, -LightDir);\n        pos += dir * stepDist;\n    }\n    \n    col.rgb = col.rgb*volAbs + volCol;\n\t\n    \n\n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//increase this number for a better GI\n#define IndirectSamples 1\n\n//increase to remove more noise, but might make the result blurrier\n#define SamplesLimit 150\n\n//GI bounces\n#define Bounces 1\n\n\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .5\n\n\n\n#define Pi 3.14159265359\n\n#define MaxStepsDirect 128\n#define MaxStepsIndirect 32\n#define MaxShadowSteps 32\n#define FogSteps 8\n\n#define MaxDist 4.\n#define MinDist .015\n\n#define DoFClamping .3\n#define DoFSamples 128\n\n#define Density vec3(.0025, .0045, .006)\n#define Anisotropy .4\n#define FogRange 13.\n\n\nvec3 LightDir = normalize(vec3(.0, .0, -1));\nvec3 LightColor = vec3(1.) * 6.;\nfloat LightRadius = .02;\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    //time = 0.;\n    vec3 rot = vec3(cos(time*.4)/6., 1. + time*.2 + sin(time*.2)/4., .5);\n    return Camera(vec3(0., 0., -10.) * rotationMatrix(rot), rot, 1., 7.5, .025);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n\nfloat sdf(vec3 position, out vec3 diffuseColor, out vec3 emissionColor){\n    diffuseColor = vec3(1.);\n    emissionColor = vec3(0.);\n    float Scale = 2.25;\n    float Radius = .25;\n    mat3 Rotation;\n    \n    float time = 15.;\n    \n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1- /*iterations*/7));\n\tvec4 p = vec4(position.xyz*Rotation, 1.0), p0 = p;\n\tfor (int i = 0; i<7; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 3) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n    /*diffuseColor = fract(p0.x)<.1 ? vec3(.2) : vec3(1.);\n    emissionColor = fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.);*/\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat sdf(vec3 position){\n    vec3 dc, ec;\n    return sdf(position, dc, ec);\n}\n\nvec3 normalEstimation(vec3 pos){\n  vec2 k = vec2(MinDist, 0);\n  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),\n\t  \t\t\t\t\tsdf(pos + k.yxy) - sdf(pos - k.yxy),\n  \t\t\t\t\t\tsdf(pos + k.yyx) - sdf(pos - k.yyx)));\n}\n\nfloat henyeyGreenstein(vec3 dirI, vec3 dirO){\n\tfloat cosTheta = dot(dirI, dirO);\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    //return vec3(0.);\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 2.5;\t//goes 2.5 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 162], [288, 288, 345, 345, 668], [670, 670, 726, 726, 1559]], "test": "untested"}
{"id": "WtcSRX", "name": "Vennevadjagskakalladen", "author": "Tysken", "description": "Drag your mouse around a bit.", "tags": ["simulation"], "likes": 1, "viewed": 290, "published": 3, "date": "1581378681", "time_retrieved": "2024-07-30T21:24:47.228358", "image_code": "vec4 get(float x, float y, in vec2 fragCoord, sampler2D channel ){\n\t    return texture(channel,(fragCoord + vec2(x,y))/iResolution.xy).rgba;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col.r = get(0.0,0.0,fragCoord,iChannel3).r/10.0;\n    col.g = get(0.0,0.0,fragCoord,iChannel3).r/100.0;\n    col.b = get(0.0,0.0,fragCoord,iChannel3).r/1000.0;\n\n    \n    //col += getHeight\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor += texture(iChannel2,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 get(float x, float y, in vec2 fragCoord, sampler2D channel ){\n\t    return texture(channel,(fragCoord + vec2(x,y))/iResolution.xy).rgba;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //update depth\n    \n    float depth = get(0.0,0.0,fragCoord,iChannel2).r; //current depth\n    depth -= iTimeDelta*(get(0.0,0.0,fragCoord,iChannel1).r + get(0.0,0.0,fragCoord,iChannel1).g + get(0.0,0.0,fragCoord,iChannel1).b + get(0.0,0.0,fragCoord,iChannel1).a); //ooutflow\n    depth += iTimeDelta*(get(0.0,-1.0,fragCoord,iChannel1).r + get(1.0,0.0,fragCoord,iChannel1).g + get(0.0,1.0,fragCoord,iChannel1).g + get(-1.0,0.0,fragCoord,iChannel1).a); //inflow\n    \n\n    if(distance(iMouse.xy,fragCoord.xy) < 10.0) depth += 1.01;\n    \n    depth = max(depth,0.0);\n    \n    fragColor = vec4(depth,0.0,0.0,0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 get(float x, float y, in vec2 fragCoord, sampler2D channel ){\n\t    return texture(channel,(fragCoord + vec2(x,y))/iResolution.xy).rgba;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float gdt = 9.81 * iTimeDelta;\n    \n    float waterHeight      = get( 0.0, 0.0,fragCoord,iChannel3).r;\n    float waterHeightUp    = get( 0.0, 1.0,fragCoord,iChannel3).r;\n    float waterHeightLeft  = get(-1.0, 0.0,fragCoord,iChannel3).r;\n    float waterHeightDown  = get( 0.0,-1.0,fragCoord,iChannel3).r;\n    float waterHeightRight = get( 1.0, 0.0,fragCoord,iChannel3).r;\n\n    float up = max(get(0.0,0.0,fragCoord,iChannel2).r,0.0) + gdt*(waterHeight-waterHeightUp);\n    float left = max(get(0.0,0.0,fragCoord,iChannel2).g,0.0) + gdt*(waterHeight-waterHeightLeft);\n    float down = max(get(0.0,0.0,fragCoord,iChannel2).b,0.0) + gdt*(waterHeight-waterHeightDown);\n    float right = max(get(0.0,0.0,fragCoord,iChannel2).a,0.0) + gdt*(waterHeight-waterHeightRight);\n    \n    if(waterHeight - (up+left+down+right) < 0.0){\n    \tfloat k = min(1.0,waterHeight/((up+left+down+right)*iTimeDelta));   \n        up *= k;\n        left *= k;\n        down *= k;\n        right *= k;\n    }\n    \n    //border conditions\n    \n    if(fragCoord.x < 2.0){\n    \tright += left;\n        left   = 0.0;\n    }if(fragCoord.x > iResolution.x-2.0){\n    \tleft  += right;\n        right  = 0.0;\n    }if(fragCoord.y < 2.0){\n    \tup   += down;\n        down  = 0.0;\n    }if(fragCoord.y > iResolution.y-2.0){\n    \tdown += up;\n        up    = 0.0;\n    }\n    \n\t\t\n\t\n    \n    \n    \n    fragColor = vec4(up,left,down,right);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 142], [144, 144, 201, 251, 676]], "test": "untested"}
{"id": "ttdXzj", "name": "Day 53 - Couch Tunnel", "author": "jeyko", "description": "It's a tunnel of a couch", "tags": ["mdtmjvm"], "likes": 19, "viewed": 480, "published": 3, "date": "1581373785", "time_retrieved": "2024-07-30T21:24:48.471036", "image_code": "#define mx (iTime*1.4 + 200.*iMouse.x/iResolution.x)\n\n#define dmin(a, b) a.x < b.x ? a : b\n\n\n// PBR Equation from https://learnopengl.com/PBR/Theory\n\nvec3 path(float z){\n    z *= 0.4;\n\treturn vec3(\n    \tsin(z),\n    \tcos(z),\n    \t0.\n    );\n}\n\nfloat random(vec2 u){\n\treturn fract(sin(u.y*4125.1 + u.x *125.625)*225.5235);\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*25.1 + u.x *125.125 + u.z*525.5215)*115.125235);\n} \nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec3 p){\n\n    float n = 0.;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*1.4);\n    float i = valueNoise(p*5.4 + q*2.);\n    float z = valueNoise(p*f*1.4);\n    \n    n += f*1.8 + q*0.5;\n    //n += f*1.8 + q*0.5 + z*0.5 + i*0.3;\n    \n\treturn n;\n}\n\nfloat bumps;\n#define tunnW 1.2\n#define pmod(p, z) mod(p,z) - 0.5*z\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    p -= path(p.z);\n    \n    vec3 pC = vec3(atan(p.y, p.x),length(p.xy),p.z);\n    \n    #define modDist vec2(1.,3.14/3.)\n    \n    vec3 pCO = pC;\n    vec2 id = floor(pC.zx/modDist);\n    pC.z = pmod(pC.z, modDist.x);\n    pC.x = pmod(pC.x, modDist.y);\n    pC.y -= tunnW;\n    \n    float dTunn = -length(p.xy)+tunnW;\n    \n    vec2 lCoords = vec2(atan(pC.z, pC.x), length(pC.zx));\n    float lA =  exp(-length(pC.zx)*10.);\n    \n    \n    dTunn += smoothstep(0.09,1.,exp(-length(pC.zx)*5.))*0.1;\n    //dTunn += exp(-length(pC.zx)*5.)*0.1;\n\n    \n    //dTunn += exp(-length(pC.x)*10.)*0.1*exp(-length(pC.z)*1.);\n    dTunn += exp(-length(pC.x)*10.)*0.1*smoothstep(0.0,0.6,exp(-length(pC.z)*1.));\n    \n    dTunn += exp(-length(pC.z)*10.)*0.1*exp(-length(pC.x)*6.);\n    \n    dTunn += sin(lCoords.x*10.)*0.01*smoothstep(0.1,1.,exp(-length(pC.xz)*6.));\n    \n    \n    dTunn -= bumps = fbm(pCO.xyz*80.)*0.0006;\n    d = dmin(d, vec2(dTunn,1.));\n    \n    pC.y -= 0.24;\n    d = dmin(d, vec2(length(pC.xyz)- 0.05,2.));\n    \n    //p.z -= 1.;\n    //d = dmin(d, vec2(length(p)-0.5,1.));\n    \n    //d = dmin(d, vec2(length(p)-1.,1.));\n    d.x *= 0.8;\n    return d;\n}\n\nvec3 glow = vec3(0);\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro;\n    hit = false;\n    t = 0.;\n    for(int i = 0; i < 140; i++){\n    \td = map(p);\n    \tglow += exp(-d.x*2.);\n        if(d.x < 0.001){\n            hit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv, uv)*0.8;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    ro += path(ro.z);\n    vec3 lookAt = vec3(0); \n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p; float t; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if (hit) {\n    \tvec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n    \tvec3 h = normalize(l - rd);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        \n\t\t//vec3 lightPos = ro.z +\n        float ppp = sin(iTime)*1.;\n        vec3 lightPos = vec3(0,0,ro.z + 4. + ppp) + path(ro.z + 4. + ppp) + vec3(0. + sin(iTime)*0.1,0,0.);\n        //lightPos = vec3(0,0,0);\n        vec3 lightCol = vec3(1.,0.9,0.9);\n        //vec3 lightCol = vec3(0.5);\n\n        vec3 L = normalize(lightPos - p);\n        vec3 H = normalize(L - rd);\n\n\n        int id = int(d.y);\n        float METALNESS = 0.31;\n        float ROUGHNESS = 0.34;\n        \n        ROUGHNESS += bumps*50.;\n        //vec3 albedo = vec3(0.95,0.001,0.06)*0.4;\n        //vec3 albedo = vec3(0.5,0.001,0.01)*2.;\n        vec3 albedo = vec3(0.06,0.11,0.8)*0.;\n        if(d.y == 2.){\n        \talbedo = vec3(0.02);\n        }\n        //albedo = vec3(1);\n        vec3 N = getNormal(p);\n        vec3 V = normalize(ro - p);\n        //vec3 V = -rd;\n\n        vec3 F0 = vec3(0.43); \n        F0 = mix(F0, albedo, METALNESS);\n\n\n        // calculate per-light radiance\n        float distL    = length(lightPos - p)*1.;\n        float attenuation = 1. / (distL * distL);\n        //float attenuation = dist*0.02;\n        //attenuation = 1.;\n        vec3 radiance     = lightCol * attenuation;        \n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, ROUGHNESS);   \n        float G   = GeometrySmith(N, V, L, ROUGHNESS);      \n        vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - METALNESS;\t  \n\n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0); \n        \n\n        col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation; \n//\t\tcol += fres* radiance * NdotL * attenuation*0.1;\n        //col += diff*fres;\n        //col += n*0.1;\n        \n    } else {\n    \t\n    \n    }\n    col *= 5.9;\n    col = pow(col, vec3(0.4545));\n    //col *= 2.4;\n    //col *= 2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define PI acos(-1.)\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 169, 169, 240], [242, 242, 263, 263, 321], [324, 324, 345, 345, 623], [625, 625, 643, 643, 716], [718, 718, 744, 744, 1429], [1431, 1431, 1449, 1449, 1705], [1774, 1774, 1791, 1791, 2955], [2978, 2978, 3048, 3048, 3332], [3334, 3334, 3376, 3376, 3552], [3553, 3553, 3576, 3576, 3715], [3717, 3717, 3774, 3774, 6549]], "test": "untested"}
{"id": "wldSR2", "name": "Undefined functions test", "author": "ttg", "description": "Does this shader compile for you?  I'm trying to determine: do all WebGL implementations catch undefined functions, even for unused call chains?\n\nFrom discussion in [url]https://www.shadertoy.com/view/WldSRj[/url]", "tags": ["test", "glsl", "compiler"], "likes": 0, "viewed": 316, "published": 3, "date": "1581372789", "time_retrieved": "2024-07-30T21:24:49.371628", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec3 unused_function_impl (vec2 uv);\n\nvec3 unused_function (vec2 uv) {\n    return unused_function_impl(uv);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "tldSRj", "name": "Noise - wave - 2D", "author": "iq", "description": "Wave Noise - a simple wave based noise based on extremely simplified Gabor kernel. Performs similar to Garient Noise, but slower than Value Noise. It provides however some flexibility in the look, and is infinitely derivable.", "tags": ["procedural", "2d", "noise"], "likes": 34, "viewed": 3591, "published": 3, "date": "1581369413", "time_retrieved": "2024-07-30T21:24:50.374945", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A wave based noise, similar to gabor and all its variants but much\n// simplified, originially explored in shadertoy by user robobo1221\n// in this shader: https://www.shadertoy.com/view/wttSRj\n//\n// It is comparable in speed to traditional gradient noise (if the\n// architecture supports fast sin/cos, like GPUs do anyways), but\n// slower than value noise of course. The advantage is that it's\n// infinitely derivable. It can also be easily animated by moving\n// the waves over time or rotating the gradients, which is fun.\n//\n// But the main advantage is that it can generate a wromy look, as\n// in robobo1221's original shader, by changing the kF constant in \n// line 36 to be closer to 6\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n\n\n\n// You should replace this hash by one that you like and meets\n// your needs. This one is here just as example and should not\n// be used in production.\nvec2 g( vec2 n ) { return sin(n.x*n.y*vec2(12,17)+vec2(1,2)); }\n//vec2 g( vec2 n ) { return sin(n.x*n.y+vec2(0,1.571)); } // if you want the gradients to lay on a circle\n\nfloat noise(vec2 p)\n{\n    const float kF = 2.0;  // make 6 to see worms\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\n    float f = 0.0;\n\t\n    // left: noise\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 24.0*uv + iTime*4.0 );\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 8.0;\n        uv += iTime*4.0/3.0;\n        const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSRj.jpg", "access": "api", "license": "mit", "functions": [[1869, 2021, 2039, 2039, 2084], [2192, 2192, 2213, 2213, 2553], [2555, 2555, 2612, 2612, 3216]], "test": "untested"}
{"id": "tttXRB", "name": "Triangle Waves", "author": "xjorma", "description": "Triangle waves, lunch break shader.\nhttps://twitter.com/InfinityLoopGIF/status/1217908945421066240\n", "tags": ["2d", "hypnotic", "reproduction", "illuminati"], "likes": 22, "viewed": 688, "published": 3, "date": "1581355828", "time_retrieved": "2024-07-30T21:24:51.143889", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define TAU radians(360.)\n\n//#define AUDIOREACT\n\nconst float nbCircle = 13.; \n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nfloat udTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n  vec2 ab = b - a; vec2 pa = a - p;\n  vec2 bc = c - b; vec2 pb = b - p;\n  vec2 ca = a - c; vec2 pc = c - p;\n    \n  float d0 = dot(perp(ab), pa);\n  float d1 = dot(perp(bc), pb);\n  float d2 = dot(perp(ca), pc);\n    \n  return min(min(d0, d1), d2);\n}\n\nfloat sdfTriangle(vec2 p)\n{\n    float radius = 1.2;\n    float angle = iTime * 0.8;\n    vec2 a = rotate( angle, radius);\n    vec2 b = rotate( TAU / 3. + angle, radius);\n    vec2 c = rotate( 2. * TAU / 3. + angle, radius);\n    \n    return udTriangle(p, a, b, c);\n}\n\nfloat radFilter(float v)\n{\n    return smoothstep(100. / iResolution.y, 0., abs(v-1.));\n}\n\nfloat distFilter(float v)\n{\n    return smoothstep(0., 0.5, v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tangle = atan(p.y, p.x);\n    float \tl = length(p) * nbCircle;\n    float\tcircleId = floor(l);\n    #ifdef AUDIOREACT\n    float\ts = texture(iChannel0, vec2(0.5, 1. - circleId / nbCircle)).x;\n    #else\n    float\ts = 0.6;    \n    #endif\n    float\tmodCircleId = mod(circleId, 2.);\n    float d = sdfTriangle(p);\n    d = distFilter(d);\n    float speed = mix(0.1, -0.1, modCircleId);\n    l+= sin((angle - iTime * speed) * circleId * 5.) * 0.5 * d * s;\n    l = fract(l) * 2.;\n    float\tt = min(l, 2. - l);\n    t = radFilter(t); \n    fragColor = vec4(vec3(pow(t,1./2.2)),1.);\n}", "image_inputs": [{"id": 21152, "src": "https://soundcloud.com/acidgecko/warhawk-rob-hubbard-remix-acidgecko", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[192, 192, 232, 232, 284], [286, 286, 305, 305, 335], [337, 337, 389, 389, 636], [638, 638, 665, 665, 900], [902, 902, 928, 928, 990], [992, 992, 1019, 1019, 1056], [1059, 1059, 1116, 1116, 1753]], "test": "untested"}
{"id": "ttdSR7", "name": "Apollonian Zoom II", "author": "mla", "description": "Another zoom into an Apollonian gasket. This one shows inverted images of the inversion circles themselves.\n\nmouse: extra mobius transform.\na: disable transform\nz: disable zooming (use <up> and <down> to zoom manually)", "tags": ["zoom", "inversion", "apollonian"], "likes": 11, "viewed": 453, "published": 3, "date": "1581350884", "time_retrieved": "2024-07-30T21:24:52.085372", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian circles. Iterated inversion in a ring of circles.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int maxsteps = 20;\nconst float AA = 2.0;\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_M = 77;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst float sqrt2 = 1.414214;\n\nconst float r = 1.0/(sqrt2+1.0);\nconst float r0 = r*(sqrt2-1.0);\nconst vec4 circles[] =\n  vec4[](vec4(0,0,r0*r0,1.0),\n         vec4(r,r,r*r,1.0),\n         vec4(r,-r,r*r,1.0),\n         vec4(-r,r,r*r,1.0),\n         vec4(-r,-r,r*r,1.0),\n         vec4(0,0,1,-1.0)\n     );\nconst int N = circles.length();\n\nfloat length2(vec2 p) {\n  return dot(p,p);\n}\n\nbool inside(vec2 p, vec4 c) {\n  float r = length2(p-c.xy);\n  if (c.w < 0.0) return r > c.z;\n  else return r <= c.z;\n}\n\nvec2 invert(vec2 p, vec4 c) {\n  p -= c.xy;\n  p *= c.z/dot(p,p);\n  p += c.xy;\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  fragColor = vec4(0);\n  vec2 z0 = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  bool dozoom = !keypress(CHAR_Z);\n  float zoom = !dozoom ? exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))) \n      : exp(40.0-mod(iTime,60.0));\n  // Transform to put centre at m\n  vec2 m = (iMouse.x > 0.0) ? (2.0*iMouse.xy - iResolution.xy)/iResolution.y\n    : 0.8*vec2(cos(0.1*iTime),sin(0.1*iTime));\n  m *= zoom;\n  m /= dot(m,m); // m inverted in unit circle\n\n  vec4 tcircle = vec4(m,dot(m,m)-1.0,0);\n  float aadelta = 1.0/(AA*iResolution.y);\n  for (float p = 0.0; p < AA; p++) {\n    for (float q = 0.0; q < AA; q++) {\n      vec2 z = zoom*(z0 + aadelta*vec2(p,q));\n      if (!keypress(CHAR_A)) {\n        z = invert(z,tcircle);\n      }\n      for (int step = 0; step < maxsteps; step++) {\n        bool found = false;\n        for (int i = 0; i < N; i++) {\n          if (inside(z,circles[i])) {\n            z = invert(z,circles[i]);\n            found = true;\n            break;\n          }\n        }\n        if (!found) break;\n      }\n      float dmin = 1e10;\n      int imin = 0;\n      for (int i = 0; i < N; i++) {\n        vec4 c = circles[i];\n        float d = abs(length(z-c.xy) - sqrt(c.z));\n        if (d < dmin) {\n          dmin = d;\n          imin = i;\n        }\n      }\n      vec3 col = hsv2rgb(vec3(float(imin)/float(6),0.8,0.8));\n      fragColor.xyz += col*(1.0-smoothstep(0.0,0.05,dmin));\n    }\n  }\n  fragColor.xyz /= AA*AA;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 376, 403, 403, 579], [581, 581, 606, 606, 666], [668, 668, 693, 693, 741], [743, 743, 766, 766, 798], [1342, 1342, 1365, 1365, 1386], [1388, 1388, 1417, 1417, 1505], [1507, 1507, 1536, 1536, 1597], [1599, 1599, 1655, 1655, 3081]], "test": "untested"}
{"id": "WldSRj", "name": "This should be allowed!", "author": "ttg", "description": "Compilation success of Common tab is useless, but its failure prompts Shadertoy to block the shader on startup and prevent saving.\n\nOtherwise this is useful for routines in Common to use a function with a per-buffer implementation.", "tags": ["shadertoy", "bug"], "likes": 5, "viewed": 1643, "published": 3, "date": "1581347643", "time_retrieved": "2024-07-30T21:24:52.951057", "image_code": "\nvec3 someFunction_impl (vec2 uv) {\n    return vec3(.5+.5*sin(uv.y*24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = myFunction(uv);\n    if (uv.x<.5) col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*                                #if __LINE__<15\n                                #define _SHADERTOY_TAB_COMMON\n                                #endif\n*/\n\n// Hey, look, there _IS_ a way to detect Common tab\n#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON\n#endif\n\nvec3 someFunction (vec2 uv);\n\nvec3 myFunction (vec2 uv)\n{\n    // Do something non-trivial...\n    return someFunction(uv);\n}\n\nvec3 someFunction_impl (vec2 uv);\nvec3 someFunction (vec2 uv) {\n    return someFunction_impl(uv);\n}\n\n// In Shadertoy, no way (without #ifdef HW_PERFORMANCE or #if __LINE__ hack)\n// to make compilation of Common tab satisfied.\n\n#ifdef _SHADERTOY_TAB_COMMON\nvec3 someFunction_impl (vec2 uv) { return vec3(0.); }\n#endif\n", "buffer_a_code": "\nvec3 someFunction_impl (vec2 uv) {\n    return vec3(.5+.5*sin(uv.y*36.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = myFunction(uv);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 35, 35, 75], [77, 77, 134, 134, 315]], "test": "untested"}
{"id": "ttcSR2", "name": "random sample bokeh blur", "author": "battlebottle", "description": "based on: shadertoy.com/view/XlKSDR \n\nI use randomized sampled to implement some effects including:\nbokeh blur\nchromatic aberration\n6-way star filter\ndifferential grating filter\n\nedit \"maxSamples\" in Buffer B to adjust the sample rate", "tags": ["bokeh"], "likes": 8, "viewed": 455, "published": 3, "date": "1581343477", "time_retrieved": "2024-07-30T21:24:53.953377", "image_code": "\n//Edit this to adjust the sample rate\nconst float maxSamples = pow(2.0, 7.0);\n\n//by default rbg channels are samples indidually\nconst bool sampleIndividualChannels = true;\n\n\nconst float PI = 3.14159265359;\n\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 rotate(vec2 vecToRotate, float angleInRadians) {\n    float s = sin(angleInRadians);\n    float c = cos(angleInRadians);\n    mat2 m = mat2(c, -s, s, c);\n    return m * vecToRotate;\n}\n\nvec2 sampleTransform(int channel, float rand[4]) {\n    \n    float blurRadMax = 0.08;\n    float blurRadius = blurRadMax * ((sin(iTime / 2.0) + 1.0) / 2.0);\n    \n    if (iMouse.z > 0.0) {\n        blurRadius = blurRadMax * (iMouse.x / iResolution.x);\n    }\n    \n    //simulate chromatic abbration\n    float caFactor = 1.0;\n    if (channel == 1) {\n        caFactor = 1.05;\n    } else if (channel == 3) {\n        caFactor = 0.92;\n        \n    }\n    blurRadius *= caFactor;\n    \n    \n    \n    float sampleRadius = sqrt( rand[0]) * blurRadius;\n    vec2 samplePoint = vec2(0.0, sampleRadius);\n\n    float angle = (2.0 * PI) * rand[1];\n\n    samplePoint = rotate(samplePoint, angle);\n    \n    //an attempt at some diffraction grating\n    float diffractionLineAnlgeRadians = (PI * 1.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0));\n    if (rand[2] < 0.1) {\n        float mult = (rand[2] < 0.05) ? 1.0 : -1.0;\n        samplePoint *= rotate(vec2(3.5,1.0), diffractionLineAnlgeRadians);\n        samplePoint += rotate(vec2((0.6 + 4.0 * rand[2]) * pow(caFactor, 3.0) * mult,0.0), diffractionLineAnlgeRadians);\n    }\n    \n    //an attempt at star filter\n    \n    vec2 starLines[] = \n        vec2[](\n            rotate(vec2(1.0,0.0), (PI * 1.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0))),\n            rotate(vec2(1.0,0.0), (PI * 2.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0))),\n            rotate(vec2(1.0,0.0), (PI * 3.0) / 3.0 + (PI * mod(iTime / 5.0, 2.0)))\n        );\n    \n    if (rand[2] >= 0.1 && rand[2] < 0.2 ) {\n        int starLineIndex = int (floor(rand[0] * 3.0));\n        \n        vec2 starLine = starLines[starLineIndex];\n        \n        float rnd = rand[3];\n        starLine *= 3.0;\n        samplePoint += starLine * rnd - (starLine / 2.0);\n    }\n    \n\n    samplePoint *= vec2(iResolution.y / iResolution.x, 1.0);\n    return samplePoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    vec3 colAcum2 = vec3(0.0);\n    for(float sampleIndex = 0.0; sampleIndex < maxSamples; sampleIndex++) {\n        \n        \n        \n    \tvec2 texRand = mod(texture(iChannel1, fragCoord.xy / 256.0 + vec2(sampleIndex) / 256.0).rg, 1.0);   \n        float rand[4];\n        \n        for (int i = 0; i < 4; i++) {\n            rand[i] = random(texRand * (sampleIndex / (maxSamples * 2.0) + float(i)) + mod(iTime, 1.0));\n        }\n        \n        \n        int channel = int(mod(sampleIndex, 3.0)) + 1;\n        if (!sampleIndividualChannels){\n         \tchannel = 0;   \n        }\n        \n        \n        vec2 samplePoint = sampleTransform(channel, rand);\n        \n        float blurRadMax = 0.08;\n        float blurRadius = blurRadMax * ((sin(iTime / 2.0) + 1.0) / 2.0);\n        if (channel == 0) { //all colors\n        \tcolAcum2 += textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).rgb;\n        } else if (channel == 1) { //r\n        \tcolAcum2 += vec3(textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).r, 0.0, 0.0);\n        } else if (channel == 2) { //g\n        \tcolAcum2 += vec3(0.0, textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).g, 0.0);\n        } else if (channel == 3) { //b\n        \tcolAcum2 += vec3(0.0, 0.0, textureLod(iChannel0, uv + samplePoint, blurRadius * 30.0).b);\n        }\n\n        \n    }\n    \n    \n    fragColor =  vec4(colAcum2 / (maxSamples * (sampleIndividualChannels ? (1.0/3.0) : 1.0)), 1.0);\n    \n    fragColor = vec4(OECF_sRGBFast(ACESFitted(fragColor.rgb)), 1.0);\n    //add some noise\n    //fragColor -= vec4( texture(iChannel1, fragCoord.xy / 256.0).rgb / 64.0, 0.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Render the scene\n//Code taken from: https://www.shadertoy.com/view/XlKSDR\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    \n    float brightnessMult = (sin(iTime) + 1.0) / 2.0 + 0.5;\n\n    if (iMouse.z > 0.0) {\n        brightnessMult = (iMouse.y / iResolution.y) * 2.0;\n    }\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n        \n\n        float intensity = (brightnessMult + 0.0) * 1.0;\n        float indirectIntensity = 0.64 * (brightnessMult + 0.0) * .5;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = hueShift(vec3(0.1, 0.6, 0.05),iTime);\n            roughness = 0.2;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(iTime * 0.2);\n    origin.z += 1.7 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    //// Tone mapping\n    //if (iMouse.z > 0.0) {\n    //    if (iMouse.x < fragCoord.x) {\n    //    \tcolor = ACESFitted(color);\n    //    }\n    //} else {\n    //    color = ACESFitted(color);\n    //}\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    //color = OECF_sRGBFast(color);\n    \n    \n\n    fragColor = vec4(color, distance);\n    \n    //add some noise\n    //fragColor -= vec4( texture(iChannel0, fragCoord.xy / 256.0).rgb / 64.0, 0.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[610, 610, 637, 637, 761], [763, 763, 792, 792, 1002], [1006, 1006, 1045, 1045, 1088], [1092, 1092, 1116, 1116, 1223], [1225, 1225, 1278, 1278, 1410], [3232, 3232, 3289, 3289, 4958]], "test": "untested"}
{"id": "tl3XRj", "name": "Lense to infinity v 2023", "author": "pthextract", "description": "Lense to infinity. Can possibly make you blind. Some computers freezez on grey squares, some show infinityflowers. :) ", "tags": ["inversion", "infinity", "lense", "ptolemy"], "likes": 9, "viewed": 614, "published": 3, "date": "1581325025", "time_retrieved": "2024-07-30T21:24:54.715340", "image_code": "void mainImage( out vec4 o, in vec2 i )\n{\n \tvec2 ir = iResolution.xy;\n    vec2 uv = i/ir;\n    uv-=.5;\n    uv.x*=ir.x/ir.y;\n    \n    uv*=8.-4.*cos(2.*iTime);\n    if (length(uv)<8.88) uv*=.5+5.*cos(iDate.w)/length(uv);\n    float col = 1.*length(round(.01*cos(iDate.w)+1.01*uv)-uv);\n    o = vec4(col);\n    o.rb-=.1*(uv);\n  \n   //if (length(uv)<1.5) o.rb+=.15*(uv);\n    o+=.5*o*o;\n}", "image_inputs": [{"id": 21145, "src": "https://soundcloud.com/antonio-antetomaso/mutiny-on-the-bounty-closing-titles-cover", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 378]], "test": "untested"}
{"id": "wt3SRj", "name": "sin more precise than fract :-)", "author": "FabriceNeyret2", "description": "top:         sin( length * 1e5)\nmiddle:    sin( length * 5e7)\nbottom:  fract( length * 1e5)\nred: exactly 0\n\n( As posted below, it's probably more about random bits surviving than precision ;-) )\n", "tags": ["glsl", "precision", "compilation"], "likes": 3, "viewed": 384, "published": 3, "date": "1581318192", "time_retrieved": "2024-07-30T21:24:55.522183", "image_code": "void mainImage( out vec4 O,  vec2 U )\n{\n    O  = vec4(0); \n    vec2 R = iResolution.xy;\n    float l = length( U -= vec2(0, R.y/2.) ),\n        tau = 6.28318530718;\n    if ( int(abs(U.y))== int(R.y*.1) ) O.g++;\n    U /= R;     \n    O +=  U.y > .1 ?   sin(l*1e5) *.5 + .5\n        : U.y >-.1 ?   sin(l*5e7)\n                    // ( l     - tau*floor(l    /tau) )\n                    // ( l*1e3 - tau*floor(l*1e3/tau) )\n                   : fract(l*1e5) ;\n\n    if( O==vec4(0) ) O.r ++;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 482]], "test": "untested"}
{"id": "3l3Xzj", "name": "smallest Moir ( 88 chars)", "author": "FabriceNeyret2", "description": "Is indeed the derivative of zoomed texture pixels (yes, with interpolation on) :-D\nvariants in comments", "tags": ["texture", "moir", "precision", "golf"], "likes": 3, "viewed": 347, "published": 3, "date": "1581287642", "time_retrieved": "2024-07-30T21:24:56.509543", "image_code": "// inspired from https://shadertoy.com/view/tttSzS\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n    O = .5+.5*R.x* dFdx(texture(iChannel0,U/R/32.) );\n}/*\n\n\n\n\n\n// 85 chars binary variant: \n//     O = fract( dFdx(texture(iChannel0,U/R/32.) ) )\n        \n        \n// 83 chars binary variant: \n//     O = fract(1e5* texture(iChannel0,U/R/32.)  )\n        \n/**/", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3Xzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 89, 89, 174]], "test": "untested"}
{"id": "WltXzB", "name": "Day 52", "author": "jeyko", "description": "buffer feedback stuff", "tags": ["mdtmjvm"], "likes": 18, "viewed": 514, "published": 3, "date": "1581285771", "time_retrieved": "2024-07-30T21:24:57.321372", "image_code": "// Fork of \"Day 51\" by jeyko. https://shadertoy.com/view/wl3XRS\n// 2020-02-09 08:53:58\n\n// For more buffer feedback check out wyatt, michael0884, Flexi\n\n// Borrowed the idea of using a blur as a uv offset\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float m = sin(iTime);\n \tC = (sin(T(U).xyzw*1. + vec4(1.+ length(U/R - 0.5)*2.,2.4,2.6 ,1.)));\n\t//C = (sin(T(U)*4.1 + vec4(5.,2.9,2.6,6)));    \n    C = smoothstep(0.,1.,C);\n    \n    //C = sinT(U);\n    //C *= 1. - dot(U, U)*2.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvec4 blur(in vec2 p){\n    #define bcomp x\n    vec3 e = 2.*vec3(1, 0, -1);\n    vec2 px = iResolution.xy/iResolution.xy;\n\tvec4 res = vec4(0.0);\n\tres += T(p + e.xx*px ) + T(p + e.xz*px ) + T(p + e.zx*px ) + T(p + e.zz*px );\n    res += (T(p + e.xy*px ) + T(p + e.yx*px ) + T(p + e.yz*px ) + T(p + e.zy*px ))*2.;\n\tres += T(p + e.yy*px )*4.;\n    return res/16.;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    #define grad vec2(e.x - w.x, n.y - s.y)\n    #define gradd(i) vec2(e.i - w.i, n.i - s.i)\n    #define div (e.x - w.x + n.y - s.y)\n    \n    #define curl(i) (n.i-e.i-s.i+w.i)\n    #define init abs(0.8*sin((rot(iTime*2.)*(U - 0.5*R)).xyxy*0.2))\n\n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    Neighbors;\n    U -= 0.5*R;\n    vec2 Q = U;\n    U *= rot(-0.0005 );\n    //U *= 1. - dot(U/R.y, U/R.y)*0.001;\n    U *= 0.996;\n    U += 0.5*R;\n    C = T(U);\n    U -= grad*0.4;\n    U += div*-0.4*grad;\n    \n    vec2 st = 1./iResolution.xy;\n        vec3 t = vec3(1,0,-1);\n\n    vec2 lap =  vec2(T(U + t.xy*st).y - T(U - t.xy*st).y, T(U + t.yx*st).y - T(U - t.yx*st).y);\n\n    U -= blur(U).xy*length( (U - 0.5*R)/R)*9.4;\n    //U -= m.xy*length( (U - 0.5*R)/R)*7.4;\n    \n    C = T(U)*1.;\n    \n    C.xy += div*0.1925;\n    \n    C.xy -= grad*0.1825*exp(-length(U/R - 0.5)*0.8);\n    //C.y += grad(*0.1425;\n    \n    C.z = div;\n    \n    C = sin(C*1.);\n    //C = mix(C, init, 0.001);\n    \n    \n    \n    \n\n    float mouse;\n    \n    vec2 I = U;\n    \n    if(iMouse.z > 0.){\n    \t//C = mix(C, vec4(1,1,1,1)*(sin(Q.xyyx*4.2))*1., mouse );\n        mouse = smoothstep(0.24,0.023,length(iMouse.xy/R.x - U/R.x));\n    }\n    \n    //U -= 0.5*R;\n    \n    //U += 0.5*R;\n    C -= mix(\n        blur(I).xyzw,\n        blur(I).xyxz\n        , 0.5 + sin(iTime)*0.5)*(0.05 + mouse*0.85);\n    \n    //C.xy += T(U + grad*4.).xy*3.9;\n    if(length(C.xy) >0.){\n    \t//C.xy = mix(C.xy, -normalize(C.xy), 0.01);\n    }\n    \n    //C = mix(C, m - C, 0.005);\n    //C = sin(C );\n    //Q *= rot(iTime*6.);\n    if (iFrame < 3){\n    \tC = (sin(U.yxyx*0.24))*1.;\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n\n\n#define Neighbors vec4 n = T(U + vec2(0,1)); vec4 s = T(U - vec2(0,1)); vec4 e = T(U + vec2(1,0)); vec4 w = T(U - vec2(1,0)); vec4 m = 0.25*(n + w + e + s);\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 247, 247, 479]], "test": "untested"}
{"id": "wldSzB", "name": "Office Cake v2", "author": "angelo12", "description": "Added more details to the cake!", "tags": ["cakepathtraced"], "likes": 3, "viewed": 466, "published": 3, "date": "1581271044", "time_retrieved": "2024-07-30T21:24:58.144173", "image_code": "\n#define INV_GAMMA  0.454545\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec2 uv = (fragPos) /iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n    }\n\n    col *= 2.5;// Exposure\n    col = pow(col, vec3(INV_GAMMA)); //Gamma correction\n    fragColor = vec4(col, 1.0);\n}   ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.1415926535\n#define M_TAU M_PI*2.0\n\nfloat seed_;\n\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat \nsdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat \nsdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat\nhash(float seed)\n{\nuvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\np = 1103515245U*((p >> 1U)^(p.yx));\nuint h32 = 1103515245U*((p.x)^(p.y>>3U));\nuint n = h32^(h32 >> 16);\nreturn float(n)/float(0xffffffffU);\n}\n\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n#define DEF_ID 0.0\n#define LEFT_WALL_ID 1.0\n#define RIGHT_WALL_ID 2.0\n#define LIGHT_ID 5.0\n#define CAKE_ID 6.0\n#define TORUS_ID 7.0\n#define CHERRY_ID 8.0\n\n#define EPS 0.01\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n\n    //Interior\n    if(p.x > -0.27 && p.x < 0.27) \n    if(p.z > -0.65 && p.z < 0.5) \n    if(p.y > -0.1 && p.y < 0.25) \n    {\n        //Center cornerll box items\n        UOP(sdSphere(p - vec3(0.07, 0.13, -0.18), 0.04), DEF_ID);\n        vec3 q = p;\n        q.xz = rotate(q.xz, -0.4);\n        UOP(sdBox(q - vec3(-0.12, 0.0, -0.12), vec3(0.02, 0.2, 0.02)), DEF_ID);\n\n        //Cake\n        vec3 pCake = p - vec3(0.0f, 0.0f, -0.15f);\n        float cakeRad = 0.13;\n        //cakeRad -= 0.0005*(0.5 + 0.5*sin(200.0 * p.y));\n        UOP(sdRoundedCylinder(pCake,  cakeRad, 0.012f, 0.08), CAKE_ID);\n\n        //Candle\n        vec3 pDecoration = pCake - vec3(0.0, 0.097, 0.0);   \n\n        //Candy Spheres\n        if(pDecoration.y > -0.01 && pDecoration.y < 0.058) //No need to evaluate this for every ray\n        {\n            float rSphere = 0.024;\n            float radius = 0.21;\n            float numElements = 8.0;\n            vec3 ring = pDecoration;\n            for(float i = 0.0; i < numElements; ++i){\n                float angle = 2.0 * M_PI * i / numElements; \n                vec3 rotatedPos = ring - vec3(0.0 - radius*cos(angle), 0.0, -radius*sin(angle));\n                float tRad = 0.005;\n                tRad -= 0.0007*(0.5 + 0.5*sin(16.0 * atan(rotatedPos.x, rotatedPos.z)));\n                UOP(sdTorus(rotatedPos, vec2( 0.02, tRad)),TORUS_ID);\n                UOP(sdSphere(rotatedPos - vec3(0.0, rSphere, 0.0), rSphere ),CHERRY_ID);\n            }\n        }\n    }\n\n    //Exterior box\n    {\n        //Bottom wall\n        UOP(sdBox(p - vec3(0.0, -0.1, 0.0), vec3(0.5, EPS, 1.0)), DEF_ID);\n        UOP(sdBox(p - vec3(-0.5, 0.2, 0.0), vec3(EPS, 0.5, 1.0)), LEFT_WALL_ID);\n        UOP(sdBox(p - vec3(0.5, 0.2, 0.0), vec3(EPS, 0.5, 1.0)), RIGHT_WALL_ID);\n\n        //Ceiling wall\n        UOP(sdBox(p - vec3(0.0, 0.7, 0.0), vec3(0.5, EPS, 1.0)), DEF_ID);\n        UOP(sdBox(p - vec3(0.0, 0.7, 0.0), vec3(0.2, EPS, 0.2)), LIGHT_ID);\n\n        //Back wall\n        UOP(sdBox(p - vec3(0.0, 0.0, 0.3), vec3(1.0, 1.0, EPS)), DEF_ID);\n    }\n\n    return res;\n}\n\n#define MAX_STEPS 200\n#define MIN_DIST 0.001\n#define MAX_DIST 20.0\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n\n        if(abs(hit.x) < t*MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n\n        t += hit.x;\n    }\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x\n    ));\n\n}\n\nstruct Material\n{\n    vec3 col;\n    float emi;\n    float rough;\n    float fresnel;\n    vec2 pad;\n};\n\nMaterial\nGetMaterialFromID(float id, vec3 p, vec3 N)\n{\n    Material mat;\n    //Default\n    mat.col = vec3(1.0);\n    mat.emi = 0.0;\n    mat.rough = 1.0; //1.0 is maximum roughness 0.0 is perfectly reflective\n    mat.fresnel = 0.0;\n    if(id == DEF_ID) return mat; //fast path for default mat\n\n    if(id == CAKE_ID)\n    {\n        mat.col = vec3(0.06, 0.04, 0.02);\n        float row = 1.0;\n        if(N.y < 0.1)\n        {\n            row = mod(floor((p.y - 0.045) * 37.0),2.0);\n            mat.col = row * mat.col + (1.0 - row) * (vec3(1.0, 0.84, 0.3));\n            mat.rough = 0.3 * (row) + (1.0 - row) * 1.0;\n        }\n        else\n        {\n            mat.col.r *= 2.0;\n            mat.rough = 0.1;// * (1.0 - row);\n        }\n    }\n    else if(id == LEFT_WALL_ID)\n    {\n        mat.col = vec3(1.0, 0., 0.0);\n    }\n    else if(id == RIGHT_WALL_ID)\n    {\n        mat.col = vec3(0.0, 1.0, 1.0);\n    }\n    else if(id == LIGHT_ID)\n    {\n        mat.col = vec3(1.0, 0.8, 0.54);\n        mat.emi = 1.6;\n    }\n    else if(id == CHERRY_ID)\n    {\n        mat.col = vec3(0.8, 0.0, 0.0);\n        mat.rough = 0.5;\n        mat.fresnel = 1.0;\n    }\n    return mat;\n}\n\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n#define saturate(val) clamp(0.0, 1.0, val)\n\nvec3\nCalcRayDirection(vec3 originalRd, vec3 reflectionDir, vec3 normal, float rough, float seed)\n{\n    vec3 newRd = vec3(0.0);\n    vec3 randDir = CosineWeightedRay(normal, seed);\n    if(rough >= 1.0)\n    {\n        newRd = randDir;\n    }\n    else\n    {\n        newRd = reflectionDir*(saturate(1.0 - rough)) + rough * randDir;\n        newRd = normalize(newRd);\n    }\n\n    return newRd;\n}\n\n#define GI_BOUNCES 4\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //Ray setup\n    vec3 tot = vec3(0.0);\n    vec3 rayCol = vec3(1.0);\n\n    for(int bounce = 0; bounce < GI_BOUNCES; ++bounce) \n    {\n        //Unpacking Ray results\n        vec2 res = RayMarch(ro, rd);\n        float t = res.x;\n        float id = res.y;\n\n        //Geometry        \n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n        vec3 R = reflect(rd, N);\n\n        //Material\n        Material mat = GetMaterialFromID(id, P, N); \n        rayCol *= mat.col;\n        float emi = mat.emi;\n        float fresnel = mat.fresnel;\n\n        //Lighting\n        vec3 colAcc = vec3(0.0); \n        vec3 indirect = emi * rayCol;\n        float fre = fresnel * pow( saturate(1.0+dot(N,rd)), 5.0 );\n\n        //Shading\n        colAcc += 1.00 * indirect;\n        colAcc += 0.07 * fre;\n        tot += colAcc;\n\n        //Next bounce ray Dir\n        float timeSeed =  76.2 + 73.1*float(bounce) + seed_ + 17.7*float(iFrame);\n        rd = CalcRayDirection(rd, R, N, mat.rough, timeSeed);\n        ro = P;\n    }\n\n    return tot;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    //Random number generator\n    float seed = dot(fragPos, vec2(12.9898, 78.233)) + 1131.1*float(iFrame);\n    seed_ = hash(seed * 81.94);\n    vec2 offset = - 0.5  + vec2(hash(seed + 13.271), hash( seed + 63.216));\n\n    //Initializing color to the prev frame value\n    vec2 screen = (fragPos) / iResolution.xy;\n    vec3 col = texture(iChannel0, screen).xyz;\n    if(iFrame == 0) col = vec3(0.0);\n\n    //Camera setup\n    float roll = 0.0;\n\n    float nearP = 1.0;\n    vec3 ta = vec3(0.0, 0.22, 0.0);\n    vec3 ro = ta + vec3(0.0, 0.0, -1.0);\n    mat3 cam = SetCamera(ro, ta, roll);\n    vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv, nearP));\n\n    col += Render(ro, rd);\n\n    fragColor = vec4(col, 1.0);\n}   \n\n/*\n\tShader Sundays! (6/52) \n\t\"Office Cake Part 2\"\n\t\n\tTuned most of the cake values to make it look nicer, there's more I would have liked to do with it but \n\tmaybe I'll revisit it some other time. \n*/\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 83, 83, 372]], "test": "untested"}
{"id": "wldXRB", "name": "kifs tunnel", "author": "rodgzilla", "description": "kifs tunnel with glow.", "tags": ["raymarching", "tunnel", "kifs"], "likes": 2, "viewed": 485, "published": 3, "date": "1581268767", "time_retrieved": "2024-07-30T21:24:59.095629", "image_code": "#define time .5 * iTime\n//#define ZPOS -30.\n#define ZPOS -30. + 30. * time\n#define XPOS 0.\n#define YPOS 0.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float tf1, float tf2, float s, float r) {\n    float tr1 = floor(time) + smoothstep(0., .5, fract(time));\n\tfloat tr2 = floor(time) + smoothstep(.5, 1., fract(time));\n    for (float i = 0.; i < 6.; i++) {\n        p.xy *= rot2d(tf1 * tr1);\n        p.yz *= rot2d(tf2 * tr2 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n\treturn length(p.xy - c.xy) - c.z;   \n}\n\nvec3 rep(vec3 p, vec3 r) {\n    vec3 q = mod(p, r) - .5 * r;\n    \n    return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p.xy *= rot2d(p.z / 100.);\n    p = rep(p, vec3(35.));\n    p.xy *= rot2d(sin(p.z * .2));\n    float d = 500.;\n    \n    vec3 pk = kifs(p, .5, .3, 3., .7);\n    float obj = max(\n        // repeated shape interpolates between cylinder and box\n        mix(\n            cylinder(pk, vec3(.1, .05, .1)),\n            box(pk, vec3(.2)),\n          \t.5 * sin(time * .6) + .5  \n        ),\n        // Intersection with a big sphere or box to\n        // prevent the shape going to infinity\n        mix(\n            sphere(p, 12.),\n            box(p, vec3(10)),\n            .5 * sin(2. * time) + .5\n        )\n    );\n\n    d = min(d, obj);\n\tat += .1 / (.2 + abs(d));\n        \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float swave = .5 * sin(.7 * time) + .5;\n    float d = 0.;\n\n    // The glow color interpolates between blue and red\n    vec3 glowCol = mix(\n        vec3(0., 0., .5),\n        vec3(.5, 0., 0.),\n        swave\n    );\n    \n    for (int i = 0; i < 60; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        \n        glow += 0.002 * at * glowCol;\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n\t));\n\n    return n;\n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(XPOS, YPOS, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n     \tdif *= .1;   \n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    vec3 ro = vec3(XPOS, YPOS, ZPOS);\n//    ro.x -= step(10. * time;\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    col = .2 * dif + glow * vec3(sin(p.z / 10.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 152, 152, 223], [225, 225, 284, 284, 596], [598, 598, 629, 629, 657], [659, 659, 688, 688, 775], [777, 777, 809, 809, 849], [851, 851, 877, 877, 931], [948, 948, 967, 967, 1644], [1667, 1667, 1695, 1695, 2174], [2176, 2176, 2197, 2197, 2361], [2363, 2363, 2384, 2384, 2643], [2645, 2645, 2702, 2702, 3145]], "test": "untested"}
{"id": "tltSRB", "name": "KIFS experiments 9", "author": "rodgzilla", "description": "KIFS with glow", "tags": ["raymarching", "glow"], "likes": 3, "viewed": 328, "published": 3, "date": "1581263595", "time_retrieved": "2024-07-30T21:24:59.938376", "image_code": "#define time .5 * iTime\n//#define ZPOS -30.\n#define ZPOS -30.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float tf1, float tf2, float s, float r) {\n    float tr1 = floor(time) + smoothstep(0., .5, fract(time));\n\tfloat tr2 = floor(time) + smoothstep(.5, 1., fract(time));\n    for (float i = 0.; i < 6.; i++) {\n        p.xy *= rot2d(tf1 * tr1);\n        p.yz *= rot2d(tf2 * tr2 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n\treturn length(p.xy - c.xy) - c.z;   \n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    float d = 500.;\n    \n    vec3 pk = kifs(p, .5, .3, 3., .7);\n    float obj = max(\n        // repeated shape interpolates between cylinder and box\n        mix(\n            cylinder(pk, vec3(.1, .05, .1)),\n            box(pk, vec3(.2)),\n          \t.5 * sin(time * .6) + .5  \n        ),\n        // Intersection with a big sphere or box to\n        // prevent the shape going to infinity\n        mix(\n            sphere(p, 12.),\n            box(p, vec3(10)),\n            .5 * sin(2. * time) + .5\n        )\n    );\n\n    d = min(d, obj);\n\tat += .1 / (.2 + abs(d));\n        \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float swave = .5 * sin(.7 * time) + .5;\n    float d = 0.;\n\n    // The glow color interpolates between blue and red\n    vec3 glowCol = mix(\n        vec3(0., 0., .5),\n        vec3(.5, 0., 0.),\n        swave\n    );\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        \n        glow += 0.004 * at * glowCol;\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n\t));\n\n    return n;\n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(2, 2, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n     \tdif *= .1;   \n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    col = .2 * dif + glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 107, 107, 178], [180, 180, 239, 239, 551], [553, 553, 584, 584, 612], [614, 614, 643, 643, 730], [732, 732, 764, 764, 804], [821, 821, 840, 840, 1425], [1448, 1448, 1476, 1476, 1956], [1958, 1958, 1979, 1979, 2143], [2145, 2145, 2166, 2166, 2419], [2421, 2421, 2478, 2478, 2861]], "test": "untested"}
{"id": "tttSzS", "name": "reminder: texture = low precisio", "author": "FabriceNeyret2", "description": "Derivative of zoomed texture pixels (yes, interpolation is on).\n\nEasy to forget, but loaded textures only have 8 bits precision. So derivative and zoom shows the misery", "tags": ["texture", "derivatives", "precision", "bits"], "likes": 2, "viewed": 341, "published": 3, "date": "1581255671", "time_retrieved": "2024-07-30T21:25:00.766162", "image_code": "#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O -= O;\n    vec2 R = iResolution.xy,\n          U = u/R -.03*iTime;\n    \n    float z = 32.,\n          v = texture(iChannel0,U/z).x - .5; \n    \n  //O = vec4(10.*v); return;\n  //O = vec4(fract(10.*v)); return;\n    \n    O.xy = .5+.5*R*z/64.* vec2( dFdx(v),dFdy(v) );\n    \n  //O = hue( atan(dFdx(v),-dFdy(v)) ); \n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 98, 98, 412]], "test": "untested"}
{"id": "wttXRS", "name": "KIFS experiments 8", "author": "rodgzilla", "description": "KIFS with glow.", "tags": ["raymarching", "glow", "kifs"], "likes": 2, "viewed": 371, "published": 3, "date": "1581251136", "time_retrieved": "2024-07-30T21:25:01.655918", "image_code": "#define time iTime\n#define ZPOS -30.\n\nfloat PI = acos(-1.);\n\nvec3 palette(float x) {\n    vec3 a = vec3(.81, .16, .53);\n    vec3 b = vec3(.3, .5, .7);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0., 0., 1.);\n\n\treturn a + b * sin(2. * PI * (c + x * d)); \n}\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float tf1, float tf2, float s, float r) {\n    float tr1 = floor(time) + smoothstep(0., .5, fract(time));\n\tfloat tr2 = floor(time) + smoothstep(.5, 1., fract(time));\n    for (float i = 0.; i < 6.; i++) {\n        p.xy *= rot2d(tf1 * tr1);\n        p.yz *= rot2d(tf2 * tr2 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n\treturn length(p.xy - c.xy) - c.z;   \n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    float d = 500.;\n    \n    vec3 pk = kifs(p, .5, .3, 3. + sin(2. * time), .7);\n    float obj = max(\n        cylinder(pk, vec3(.1, .05, .1)),\n        sphere(p, 12.)\n    );\n  \td = min(d, obj);\n\tat += .1 / (.2 + abs(d));\n//  \tat += .01 * abs(d);\n        \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        \n        glow += 0.01 * at * vec3(.3, 0, 0);\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n\t));\n\n    return n;\n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(2, 2, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n     \tdif *= .1;   \n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    col = .2 * dif + glow;\n//\tcol = dif * vec3(palette(p.z / 5.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 84, 84, 259], [261, 261, 282, 282, 353], [355, 355, 414, 414, 726], [728, 728, 759, 759, 787], [789, 789, 821, 821, 861], [878, 878, 897, 897, 1167], [1190, 1190, 1218, 1218, 1506], [1508, 1508, 1529, 1529, 1693], [1695, 1695, 1716, 1716, 1969], [1971, 1971, 2028, 2028, 2451]], "test": "untested"}
{"id": "3ldXzB", "name": "Lit bricks", "author": "Ref", "description": "1) A Sobel filter is apllied to get edges\n2) A normal map is computed from edges", "tags": ["sobel", "light", "normal"], "likes": 8, "viewed": 595, "published": 3, "date": "1581250352", "time_retrieved": "2024-07-30T21:25:02.488557", "image_code": "//#define EDGES\n//#define NORMALS\n\nfloat luminance(vec3 color)\n{\n\treturn dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 texel(sampler2D sampler, vec2 pos, vec2 resolution)\n{\n    return texture(sampler, pos / resolution).rgb;\n}\n\nfloat sobel(sampler2D sampler, vec2 pos, vec2 resolution)\n{\n    float gx = luminance\n        (\n            -1.0 * texel(sampler, pos + vec2(-1.0, -1.0), resolution) +\n            -2.0 * texel(sampler, pos + vec2(-1.0,  0.0), resolution) +\n            -1.0 * texel(sampler, pos + vec2(-1.0,  1.0), resolution) +\n             1.0 * texel(sampler, pos + vec2( 1.0, -1.0), resolution) +\n             2.0 * texel(sampler, pos + vec2( 1.0,  0.0), resolution) +\n             1.0 * texel(sampler, pos + vec2( 1.0,  1.0), resolution)\n        );\n    float gy = luminance\n        (\n            -1.0 * texel(sampler, pos + vec2(-1.0, -1.0), resolution) +\n            -2.0 * texel(sampler, pos + vec2( 0.0, -1.0), resolution) +\n            -1.0 * texel(sampler, pos + vec2( 1.0, -1.0), resolution) +\n             1.0 * texel(sampler, pos + vec2(-1.0,  1.0), resolution) +\n             2.0 * texel(sampler, pos + vec2( 0.0,  1.0), resolution) +\n             1.0 * texel(sampler, pos + vec2( 1.0,  1.0), resolution)\n        );\n    return sqrt(gx * gx + gy * gy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    \n    vec2 eps = vec2(1.0, 0.0);\n    float dx = sobel(iChannel0, fragCoord + eps.xy, resolution) - sobel(iChannel0, fragCoord - eps.xy, resolution);\n    float dy = sobel(iChannel0, fragCoord + eps.yx, resolution) - sobel(iChannel0, fragCoord - eps.yx, resolution);\n\tvec3 norm = normalize(vec3(dx, dy, 1.0));\n        \n    float angle = iTime * 3.1415 * 0.5;\n    vec2 lightPos = vec2(cos(angle), sin(angle)) * 0.5 + 0.5;\n    vec3 lightDir = normalize(vec3(lightPos - fragCoord / resolution, 0.5));\n    \n    float diffuse = max(dot(lightDir, norm), 0.0);\n    vec3 albedo = texel(iChannel0, fragCoord, resolution) * 1.5;\n                          \n    #if defined EDGES\n    fragColor = vec4(vec3(sobel(iChannel0, fragCoord + eps.xy, resolution)), 1.0);\n    #elif defined NORMALS\n    fragColor = vec4(norm * 0.5 + 0.5, 1.0);\n    #else\n    fragColor = vec4(albedo * diffuse, 1.0);\n    #endif\n\t//fragColor = vec4(mix(albedo * 1.2, albedo * diffuse, smoothstep(0.001, 0.5, length(fragCoord / resolution - lightPos))), 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 64, 64, 113], [115, 115, 173, 173, 226], [228, 228, 287, 287, 1277], [1279, 1279, 1336, 1336, 2395]], "test": "untested"}
{"id": "wttSRS", "name": "grid of poles (pseudo phasor no)", "author": "FabriceNeyret2", "description": "artificials phasor noise with no discont.\nMouse.y: grid scale  Mouse.x: jitter scale\nSettle poles at nodes of square grid so that phasor angle does 1 turn around node (in checkered direction).\nHue = phasor (i.e. phase offset in the regular oscillation)\n", "tags": ["noise", "interpolation", "phasor"], "likes": 8, "viewed": 611, "published": 3, "date": "1581249538", "time_retrieved": "2024-07-30T21:25:03.311357", "image_code": "// interp from triangle sides : see https://www.desmos.com/calculator/anchdwvynw\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         V = u/R.y,\n         M = iMouse.xy/R,\n         U = V * (iMouse.x < 10. ? 5. : 20.*M.y),\n         F = fract(U)*2.-1.,     // coords in tile in [-1,1]\n         I = mod(floor(U),2.);   // tile id in checker pattern\n\n    float n = iMouse.x < 10. ? 10. : 20.*M.x,      // noise scale\n          x = F.x, y = F.y, k=0., X,Y,Z, a,c, v, s = sqrt(2.);\n                                                // --- settle phase at edges\n#if 1                   // checker : 2pi turn around nodes\n    a = I==vec2(0) ? abs(y) > abs(x) ? 4. : 0.  // phase along diagonals\n                   : I.y==0. ? I.x : 3.-I.x;\n    c = abs(y) < abs(x) ? I.y==0. ?  .5 : 2.5   // phase along tile border\n                        : I.x==0. ? 3.5 : 1.5;\n    a /= 4.; c /= 4.;\n#else                   // no checker : 8pi turn around nodes\n    float S = I.x==I.y ? 1. : 0.;\n    a =  abs(y) > abs(x) ? S : 1.-S;            // phase along diagonals\n    c = .5;                                     // phase along tile border\n#endif\n                                                // --- get triangle coordinates\n    if ( abs(y) > abs(x) ) k=x,x=y,y=k;         // wrap to first quadrant (right triangle in tile)\n    x = abs(x), \n    X = (x-y)/s, Y = (x+y)/s, Z = 1.-x;         // coords in triangle\n    float A = Y*Z, B=X*Z, C=X*Y;                // --- interp within triangle\n    v = ( a*A + a*B + c*C ) / (A+B+C) ;\n\n    v += 1.*texture(iChannel0,(n*V+.5*0.)/iChannelResolution[0].x).x; // global perturbations\n    O = hue(v); //return;\n    // v = .5+.5*sin(30.*6.28*v);               // display isolines\n    \n    v = .5 + .5* sin( 150.* dot(V-.5, cos(.1*iTime+vec2(0,11))) + 6.28*v ); // phasor\n    \n    O *= vec4(v);\n\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 227, 227, 1947]], "test": "untested"}
{"id": "wlG3RW", "name": "Volumetric 3D fluid", "author": "tmst", "description": "- Single pass fluid simulation on 128x128x128 voxels (references: see top of \"Cube A\")\n- Hit space to clear the density, mouse drag to change viewing position\n- Not perfect, but I guess it's interesting as is!", "tags": ["fire", "fluid", "volumetric", "vorticity"], "likes": 128, "viewed": 5830, "published": 3, "date": "1581247877", "time_retrieved": "2024-07-30T21:25:04.370525", "image_code": "#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define BOX_MIN vec3(-1.0)\n#define BOX_MAX vec3(1.0)\n\n#define EPS 0.001\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid boxClip(\n    in vec3 boxMin, in vec3 boxMax,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n){\n    //for each coord, clip tRange to only contain t-values for which p+t*v is in range\n    vec3 tb0 = (boxMin - p) / v;\n    vec3 tb1 = (boxMax - p) / v;\n    vec3 tmin = min(tb0, tb1);\n    vec3 tmax = max(tb0, tb1);\n\n    //t must be > tRange.s and each tmin, so > max of these; similar for t1\n    tRange = vec2(\n        max(max(tmin.x, tmin.y), tmin.z),\n        min(min(tmax.x, tmax.y), tmax.z)\n    );\n\n    //determine whether ray intersects the box\n    didHit = step(tRange.s, tRange.t);\n}\n\nvec3 lmnFromWorldPos(vec3 p) {\n    vec3 uvw = (p - BOX_MIN) / (BOX_MAX - BOX_MIN);\n    return floor(uvw * vec3(BOX_N));\n}\n\nvec4 readLMN(vec3 lmn) {\n    return texture(iChannel0, vcubeFromLMN(1, lmn));\n}\n\nvec3 readCurlAtLMN(vec3 lmn) {\n    return texture(iChannel0, vcubeFromLMN(2, lmn)).xyz;\n}\n\nvoid boxFromLMN(in vec3 lmn, out vec3 boxMin, out vec3 boxMax) {\n    vec3 boxSize = (BOX_MAX - BOX_MIN) / BOX_N;\n\n    boxMin = BOX_MIN + (floor(lmn)/BOX_N) * (BOX_MAX - BOX_MIN);\n    boxMax = boxMin + boxSize;\n}\n\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nvec3 colormapInferno(float t) {\n    return vec3(\n        1.0 - (t - 1.0)*(t - 1.0),\n        t*t,\n        t * (3.0*t - 2.0)*(3.0*t - 2.0)\n    );\n}\n\nvoid march(\n    in vec3 p, in vec3 nv,\n    out vec4 color\n) {\n    vec2 tRange;\n    float didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n\n    color = vec4(0.0);\n    if (didHitBox < 0.5) {\n        return;\n    }\n\n    float t = tRange.s;\n    for (int i=0; i<800; i++) {\n\t\t// Get voxel data\n        vec3 lmn = lmnFromWorldPos( p + (t+EPS)*nv );\n        vec4 data = readLMN(lmn);\n\n        vec3 curlV = readCurlAtLMN(lmn);\n\n        float normalizedDensity = unmix(0.5, 3.0, data.w);\n        float normalizedSpeed = pow(unmix(0.0, 10.0, length(data.xyz)), 0.5);\n        float normalizedVorticity = clamp(pow(length(curlV),0.5), 0.0, 1.0);\n\n        #ifdef VORTICITY_CONFINEMENT\n        vec3 cbase = colormapInferno( normalizedVorticity );\n        float calpha = pow(normalizedSpeed, 3.0);\n        #else\n        vec3 cbase = colormapInferno( normalizedSpeed );\n        float calpha = pow(normalizedDensity, 3.0);\n        #endif\n\n        vec4 ci = vec4(cbase, 1.0)*calpha;\n\n        // Determine path to next voxel\n        vec3 curBoxMin, curBoxMax;\n        boxFromLMN(lmn, curBoxMin, curBoxMax);\n\n        vec2 curTRange;\n        float curDidHit;\n        boxClip(curBoxMin, curBoxMax, p, nv, curTRange, curDidHit);\n\n        // Adjust alpha for distance through the voxel\n        ci *= clamp((curTRange.t - curTRange.s)*15.0, 0.0, 1.0);\n\n        // Accumulate color\n        color = vec4(\n            color.rgb + (1.0-color.a)*ci.rgb,\n            color.a + ci.a - color.a*ci.a\n        );\n\n        // Move up to next voxel\n        t = curTRange.t;\n        if (t+EPS > tRange.t || color.a > 1.0) { break; }\n    }\n}\n\nvec3 skybox(vec3 vDir) {\n    return texture(iChannel1, vDir).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    vec2 mouseAng = mix(\n        vec2(-iTime*0.27, 0.5*3.14159 + 0.6*sin(iTime*0.21)),\n        3.14159 * iMouse.xy / iResolution.xy,\n        isMousePressed\n    );\n    vec3 camPos = 2.5 * (\n        sin(mouseAng.y) * vec3(cos(2.0*mouseAng.x), 0.0, sin(2.0*mouseAng.x)) +\n        cos(mouseAng.y) * vec3(0.0, 1.0, 0.0)\n    );\n    vec3 lookTarget = vec3(0.0);\n\n \tvec3 nvCamFw = normalize(lookTarget - camPos);\n    mat4 clipToWorld = getClipToWorld(iResolution.x/iResolution.y, nvCamFw);\n\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    vec3 nvCamDir = normalize(vWorld.xyz / vWorld.w);\n\n    vec3 bgColor = 0.2 * skybox(nvCamDir);\n\n    vec4 finalColor;\n    march(camPos, nvCamDir, finalColor);\n    fragColor = vec4(finalColor.rgb + (1.0 - finalColor.a)*bgColor, 1.0);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VORTICITY_CONFINEMENT\n#define VORTICITY_COEFF 1.0\n\n#define BOX_N 128.0\n\n// Data is organized into 3 \"pages\" of 128x128x128 voxels.\n// Each \"page\" takes up 2 faces of the 1024x1024 cubemap,\n// each face storing 8x8=64 of the 128x128 slices.\n\nvec3 vcubeFromLMN(in int page, in vec3 lmn)\n{\n    // subtexture within [0,8)^2\n    float l = mod(floor(lmn.x), 128.0);\n    float tm = mod(l, 8.0);\n    float tn = mod((l - tm)/8.0, 8.0);\n    vec2 tmn = vec2(tm, tn);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(floor(lmn.yz), 128.0);\n\n    // pixel position on 1024x1024 face\n    vec2 fragCoord = 128.0*tmn + mn + 0.5;\n    vec2 p = fragCoord*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else {\n        fv = fv = vec3(p, 1.0);\n    }\n\n    if (l < 64.0) {\n        return fv;\n    } else {\n        return -fv;\n    }\n}\n\nvoid lmnFromVCube(in vec3 vcube, out int page, out vec3 lmn)\n{\n    // page and parity, and pixel position on 1024x1024 texture\n    vec2 p;\n    float parity;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        page = 1;\n        p = vcube.yz/vcube.x;\n        parity = vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        page = 2;\n        p = vcube.xz/vcube.y;\n        parity = vcube.y;\n    } else {\n        page = 3;\n        p = vcube.xy/vcube.z;\n        parity = vcube.z;\n    }\n    vec2 fragCoord = floor((0.5 + 0.5*p)*1024.0);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(fragCoord, 128.0);\n\n    // subtexture within [0,8)^2\n    vec2 tmn = floor(fragCoord/128.0);\n\n    float lAdd;\n    if (parity > 0.0) {\n        lAdd = 0.0;\n    } else {\n        lAdd = 64.0;\n    }\n    lmn = vec3(tmn.y*8.0 + tmn.x + lAdd, mn);\n}\n\n\n", "cube_a_code": "// Description and references:\n// -------------------------------------------------------------------------------\n// This shader adapts the fluid simulation described in [1] to 3D and adds\n// vorticity confinement as described in [2].  The shader [3] does the same in 2D.\n// Some other 3D fluids here include [4], [5].  If there are others, leave a comment!\n// - [1] \"Simple and Fast Fluids\" (Guay, Colin, Egli) for the single-pass fluid simulation.\n// - [2] \"Visual Simulation of Smoke\" (Fedkiw, Stam, Jensen) for vorticity confinement.\n// - [3] nimitz - \"Chimera's Breath\" (https://www.shadertoy.com/view/4tGfDW)\n// - [4] flockaroo - \"single pass 3D fluid\" (https://www.shadertoy.com/view/tl33RM)\n// - [5] wyatt - \"Fluid 3D Volumetric*\" (https://www.shadertoy.com/view/WsSXRy)\n// -------------------------------------------------------------------------------\n\n// Keyboard input description: https://www.shadertoy.com/view/lsXGzf\n#define KEY_SPACE 32\n\n#define DENSITY_SMOOTHING 0.2\n#define VISCOSITY 0.15\n#define TIME_STEP 0.1\n#define MAX_VELOCITY 10.0\n#define K_CONST 0.3\n\nvec4 getDataNearest(vec3 lmn) {\n\treturn texture(iChannel0, vcubeFromLMN(1, lmn));\n}\n\nvec3 getCurlNearest(vec3 lmn) {\n    return texture(iChannel0, vcubeFromLMN(2, lmn)).xyz;\n}\n\nvec4 getDataInterp(vec3 lmn) {\n    vec3 flmn = floor(lmn);\n\n    vec4 d000 = getDataNearest( flmn );\n    vec4 d001 = getDataNearest( flmn + vec3(0.0, 0.0, 1.0) );\n    vec4 d010 = getDataNearest( flmn + vec3(0.0, 1.0, 0.0) );\n    vec4 d011 = getDataNearest( flmn + vec3(0.0, 1.0, 1.0) );\n    vec4 d100 = getDataNearest( flmn + vec3(1.0, 0.0, 0.0) );\n    vec4 d101 = getDataNearest( flmn + vec3(1.0, 0.0, 1.0) );\n    vec4 d110 = getDataNearest( flmn + vec3(1.0, 1.0, 0.0) );\n    vec4 d111 = getDataNearest( flmn + vec3(1.0, 1.0, 1.0) );\n\n    vec3 t = lmn - flmn;\n    vec4 dY0Z0 = mix(d000, d100, t.x);\n    vec4 dY1Z0 = mix(d010, d110, t.x);\n    vec4 dY0Z1 = mix(d001, d101, t.x);\n    vec4 dY1Z1 = mix(d011, d111, t.x);\n    vec4 dZ0 = mix(dY0Z0, dY1Z0, t.y);\n    vec4 dZ1 = mix(dY0Z1, dY1Z1, t.y);\n    return mix(dZ0, dZ1, t.z);\n}\n\nvoid addSource(\n    in vec3 uvw,\n    in vec3 uvwSource, in vec3 dirSource,\n    inout float nextDensity, inout vec3 nextVelocity\n) {\n    float t = 1.0 - smoothstep( 0.0, 0.4, distance(uvw, uvwSource) );\n    nextDensity += t * 0.1;\n    nextVelocity += t * MAX_VELOCITY*normalize(dirSource);\n}\n\nvoid doPage1(out vec4 fragColor, in vec3 lmn)\n{\n    float isSpacePressed = texelFetch(iChannel1, ivec2(KEY_SPACE,0), 0).x;\n    if (isSpacePressed > 0.5) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.5);\n        return;\n    }\n\n    vec4 data0  = getDataNearest( lmn );\n    vec4 dataLA = getDataNearest( lmn + vec3(-1.0,  0.0,  0.0) );\n    vec4 dataLB = getDataNearest( lmn + vec3( 1.0,  0.0,  0.0) );\n    vec4 dataMA = getDataNearest( lmn + vec3( 0.0, -1.0,  0.0) );\n    vec4 dataMB = getDataNearest( lmn + vec3( 0.0,  1.0,  0.0) );\n    vec4 dataNA = getDataNearest( lmn + vec3( 0.0,  0.0, -1.0) );\n    vec4 dataNB = getDataNearest( lmn + vec3( 0.0,  0.0,  1.0) );\n\n    #ifdef VORTICITY_CONFINEMENT\n    vec3 curl0  = getCurlNearest( lmn );\n    vec3 curlLA = getCurlNearest( lmn + vec3(-1.0,  0.0,  0.0) );\n    vec3 curlLB = getCurlNearest( lmn + vec3( 1.0,  0.0,  0.0) );\n    vec3 curlMA = getCurlNearest( lmn + vec3( 0.0, -1.0,  0.0) );\n    vec3 curlMB = getCurlNearest( lmn + vec3( 0.0,  1.0,  0.0) );\n    vec3 curlNA = getCurlNearest( lmn + vec3( 0.0,  0.0, -1.0) );\n    vec3 curlNB = getCurlNearest( lmn + vec3( 0.0,  0.0,  1.0) );\n    #endif\n\n    // Various derivative approximations\n    vec4 dxData = 0.5 * (dataLB - dataLA);\n    vec4 dyData = 0.5 * (dataMB - dataMA);\n    vec4 dzData = 0.5 * (dataNB - dataNA);\n\n    vec3 gradDensity = vec3(dxData.w, dyData.w, dzData.w);\n    float divVelocity = dxData.x + dyData.y + dzData.z;\n    vec3 laplacian = dataLA.xyz + dataLB.xyz + dataMA.xyz + dataMB.xyz + dataNA.xyz + dataNB.xyz - 6.0*data0.xyz;\n\n    #ifdef VORTICITY_CONFINEMENT\n    vec3 gradAbsCurl = vec3(\n        length(curlLB) - length(curlLA),\n        length(curlMB) - length(curlMA),\n        length(curlNB) - length(curlNA)\n\t);\n    vec3 fVorticityConfinement = vec3(0.0);\n    if (length(gradAbsCurl) > 0.0) {\n    \tfVorticityConfinement =  VORTICITY_COEFF*cross(normalize(gradAbsCurl), curl0);\n    }\n    #else\n    vec3 fVorticityConfinement = vec3(0.0);\n    #endif\n\n    // Solve for density\n    float nextDensity = mix(data0.w, (dataLA.w + dataLB.w + dataMA.w + dataMB.w + dataNA.w + dataNB.w)/6.0, DENSITY_SMOOTHING);\n    nextDensity -= TIME_STEP*( dot(gradDensity,data0.xyz) + divVelocity*data0.w );\n\n    // Solve for velocity\n    vec3 nextVelocity = getDataInterp(lmn - TIME_STEP*data0.xyz).xyz;\n    vec3 fViscosity = VISCOSITY * laplacian;\n    vec3 fCorrectivePressure = gradDensity * K_CONST;\n    nextVelocity += TIME_STEP*(fViscosity + fVorticityConfinement) - fCorrectivePressure;\n\n    // Add sources\n    vec3 uvw = (2.0*lmn - vec3(BOX_N)) / vec3(BOX_N);\n    addSource(uvw, vec3(0.0,-0.5,0.5), vec3(0.1*sin(iTime),1.0,0.0), nextDensity, nextVelocity);\n    addSource(uvw, vec3(0.0,0.0,-0.5), vec3(cos(iTime), sin(iTime*2.0), sin(iTime)), nextDensity, nextVelocity);\n\n    // Clamp and set boundary values\n    nextDensity = clamp(nextDensity, 0.5, 3.0);\n    if (length(nextVelocity) > MAX_VELOCITY) {\n        nextVelocity = normalize(nextVelocity)*MAX_VELOCITY;\n    }\n    nextVelocity *= step(0.5, lmn) * (1.0 - step(BOX_N-1.5, lmn));\n\n    // Done!\n    fragColor = vec4(nextVelocity, nextDensity);\n}\n\nvoid doPage2(out vec4 fragColor, in vec3 lmn)\n{\n    vec4 data0  = getDataNearest( lmn );\n    vec4 dataLA = getDataNearest( lmn + vec3(-1.0,  0.0,  0.0) );\n    vec4 dataLB = getDataNearest( lmn + vec3( 1.0,  0.0,  0.0) );\n    vec4 dataMA = getDataNearest( lmn + vec3( 0.0, -1.0,  0.0) );\n    vec4 dataMB = getDataNearest( lmn + vec3( 0.0,  1.0,  0.0) );\n    vec4 dataNA = getDataNearest( lmn + vec3( 0.0,  0.0, -1.0) );\n    vec4 dataNB = getDataNearest( lmn + vec3( 0.0,  0.0,  1.0) );\n\n    // Various derivative approximations\n    vec4 dxData = 0.5 * (dataLB - dataLA);\n    vec4 dyData = 0.5 * (dataMB - dataMA);\n    vec4 dzData = 0.5 * (dataNB - dataNA);\n\n    vec3 curlVelocity = vec3(dyData.z - dzData.y, dzData.x - dxData.z, dxData.y - dyData.x);\n    fragColor = vec4(curlVelocity, 1.0);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 lmn;\n    int pageDst;\n    lmnFromVCube(rayDir, pageDst, lmn);\n\n    if (pageDst == 1) {\n        doPage1(fragColor, lmn);\n    } else if (pageDst == 2) {\n\n        #ifdef VORTICITY_CONFINEMENT\n        doPage2(fragColor, lmn);\n        #else\n        discard;\n        #endif\n\n    } else if (pageDst == 3) {\n        discard;\n    }\n}\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 253, 253, 809], [811, 811, 927, 1014, 1417], [1419, 1419, 1449, 1449, 1540], [1542, 1542, 1566, 1566, 1621], [1623, 1623, 1653, 1653, 1712], [1714, 1714, 1778, 1778, 1925], [1927, 1927, 1967, 1967, 1997], [1999, 1999, 2030, 2030, 2144], [2146, 2146, 2207, 2207, 3765], [3767, 3767, 3791, 3791, 3834], [3836, 3836, 3893, 3893, 4772]], "test": "untested"}
{"id": "wltSRS", "name": " - Quicky#006 - Cineshader", "author": "totetmatt", "description": "Cineshader version\nhttps://cineshader.com/view/wltSRS", "tags": ["cineshader"], "likes": 19, "viewed": 27385, "published": 3, "date": "1581244325", "time_retrieved": "2024-07-30T21:25:05.136478", "image_code": "\n// /!\\ move everything fast and flashy #define time tan(iTime*16.)\n#define time iTime\n#define clock time/5.\n#define ttime floor(time) + pow(fract(time),sin(iTime*1.333)*.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n    vec2 uuv = uv;\n    uv.x += tan(abs(uv.x)*5.);\n    \n    float d = fract(10.*uv.x+clock);\n    d = smoothstep(0.2,0.10,d);\n    \n    float p = tan(uv.x+time);\n    vec3 col = mix(vec3(0.1,0.1,0.1),vec3(p*0.1+step(.1,abs(cos(clock*2.))*uv.x),p*0.9,0.1+step(1.,sin(clock)*sin(clock)*abs(uv.x))),d);\n    \n    fragColor = vec4(\n        col,\n        d*sin(ttime+1.-floor(length(floor(uuv*10.)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 231, 231, 691]], "test": "untested"}
{"id": "3ltXzB", "name": "sohere defoirmation", "author": "antoinefortin", "description": "34rregtr", "tags": ["333"], "likes": 6, "viewed": 336, "published": 3, "date": "1581239086", "time_retrieved": "2024-07-30T21:25:05.974237", "image_code": "float sdElipsoid(vec3 pos, vec3 rad)\n{\n\tfloat k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    \n    return k0 *(k0 - 1.0) / k1;\n    \n    \n}   \n\nvec2 rotate(vec2 pos, float angle)\n{\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c) * pos;\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n    \nfloat sdSphere(vec3 pos, vec3 r)\n{\n\treturn 1.0;\n}\n\n \n\nfloat shape(vec3 p)\n{\n\n    vec3 res = vec3(1.0,-1., -1.);\n\tvec3 q = p;\n   \tq.y -=5.5;\n    q.xz = rotate(q.xz, iTime *.5);\n    q.yx = rotate(q.yx, iTime *1.25);\n    float rad = 5.0 + .5 * sin(q.z - iTime * 5.)\n        * cos(q.x + 2.0 * 1.5) \n        * (sin(q.z * 3.5) + cos(q.y * 1.5) ); // base\n  \n     // q.x = mod(q.x + .5, 1.0) - .5;\n    float d = length(q) - rad;\n    \n    \n    d *= .25;\n    \n    res = vec3(d, 1.0, res.z);\n    return res.x; // the distance;\n    \n}\n\n\n\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n\tfloat d = shape(q);\n    \n    \n    // Floor\n    float d2 = pos.y - (-0.95);\n    float ret = min(d, d2);\n    \n        \n    \n    return ret;\n}\n\n\n\n    \n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\t//vec3 ro = vec3(0.0 + iTime * 3.,4.5 + sin(iTime),12.5 + iTime * 5.);\n    \n    \n    vec3 ro = vec3(1.,  4., 15.);\n    vec3 rd = normalize(vec3(p, -1.5));\n\t\n    \n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 sunPosition = vec3(sin(iTime),  1. + cos(iTime),0.9);\n       \tvec3 sundir = normalize(sunPosition);\n     \tvec3 mate = vec3(0.18);\n        \n\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n        \n        col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n        col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n        col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 158], [163, 163, 199, 199, 291], [295, 295, 340, 340, 431], [438, 438, 472, 472, 487], [492, 492, 513, 513, 961], [966, 966, 987, 987, 1151], [1161, 1161, 1194, 1194, 1497], [1499, 1499, 1526, 1526, 1738], [1740, 1740, 1797, 1847, 2971]], "test": "untested"}
{"id": "WtdXRB", "name": "Procgen Planet With IQ's Color1", "author": "soundmasteraj", "description": "Procedural generation of a gas-like planet using fbm / domain warping. + Inigo's pallete color(t) = a + b  cos[ 2(ct+d)]", "tags": ["procedural", "noise", "fbm", "planet", "domainwarping", "procgen"], "likes": 24, "viewed": 994, "published": 3, "date": "1581237102", "time_retrieved": "2024-07-30T21:25:06.800030", "image_code": "// Fork of \"Procgen Planet\" by kchnkrml. https://shadertoy.com/view/tltXWM\n// 2020-02-09 06:37:49\n\n// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// https://iquilezles.org/articles/warp\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n//#define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift; // 1.618\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    vec3 a = vec3(0.5, .25+(sin(iTime*.1)-.25+.25), 0.5)*.5;\n    vec3 b = vec3(0.5, 0.5, 0.5)*.5;\n    vec3 c = vec3(1.0, 1.0, 1.0)*.5;\n\tvec3 d = vec3(0.00, 0.33, 0.67)*.5;\n    \n    // iq's palette https://iquilezles.org/articles/palettes\n    // Signature == palette(iTime, vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    // iq's rainbow\n\t// palette( a=vec3(0.5, 0.5, 0.5), b=vec3(0.5, 0.5, 0.5), c=vec3(1.0, 1.0, 1.0), d=vec3(0.00, 0.33, 0.67))\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top =  palette(iTime *  .11 ,  a,  b, c,  d )*.5;\n    vec3 col_bot =  palette(iTime *  .115,  a,  b, c,  d )*.5;\n    vec3 col_mid1 = palette(iTime * .1135,  a,  b, c,  d )*.33;\n    vec3 col_mid2 = palette(iTime *-.1135,  d,  c, b,  a )*.33;\n    vec3 col_mid3 = palette(iTime *-.114 ,  c,  d, c,  b )*.33;\n    \n\t// original colors    \n    // vec3 col_top = vec3(0.0, 0.5, 0.0);\n\t// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n\t// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n\t// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n\t// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    color *= (P + w*t).z * 2.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1140, 1214, 1235, 1235, 1302], [1304, 1304, 1325, 1325, 1908], [1910, 1910, 1929, 1929, 2114], [2386, 2386, 2409, 2409, 2425], [2426, 2426, 2456, 2456, 2487], [2489, 2564, 2620, 2620, 2894], [2896, 2928, 2949, 2949, 2987], [2989, 3028, 3100, 3100, 3143], [3145, 3145, 3184, 3221, 6558], [6560, 6560, 6616, 6616, 7102]], "test": "untested"}
{"id": "3ltSzS", "name": "Phi Hash", "author": "TinyTexel", "description": "A minimalist hash function based on the constants of the R2 sequence. Hash function in Buffer A.", "tags": ["random", "hash", "rng"], "likes": 5, "viewed": 453, "published": 3, "date": "1581213735", "time_retrieved": "2024-07-30T21:25:07.567976", "image_code": "// A minimalist hash function based on the constants of the R2 sequence. \n// Hash function in Buffer A.\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        col = pow(vec3(n), vec3(1.0/2.2));\n        \n        #ifdef SHOW_1BITGRADIENT\n        if(q.y < 0.25)\n        col = vec3(n < q.x * 2.0 ? 0.0 : 1.0);\n        #endif\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n  #define SHOW_1BITGRADIENT\n  #define SHOW_FOURIER\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\nconst float globalScale = 1.;\n", "buffer_a_code": "// The MIT License\n// Copyright  2020 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n #define ANIMATE_NOISE\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n//uint PhiHash(uint x, uint seed)\n//{\n//    const uint r0 = 3242174893u;// prime[(2^32-1) / phi_2  ]\n//    const uint r1 = 2447445397u;// prime[(2^32-1) / phi_2^2]\n//    \n//    uint h = ((x * r0) ^ (x * r1) ^ seed) * r0;\n//    \n//    return h;\n//}\n\n// related: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nuint PhiHash(uvec2 uv)\n{\n    const uint r0 = 3242174893u;// prime[(2^32-1) / phi_2  ]\n    const uint r1 = 2447445397u;// prime[(2^32-1) / phi_2^2]\n    \n    uint h = ((uv.x * r0) ^ (uv.y * r1)) * r0;\n    \n    return h;\n}\n\nuint PhiHash(uvec3 uvw)\n{\n    const uint r0 = 3518319149u;// prime[(2^32-1) / phi_3  ]\n    const uint r1 = 2882110339u;// prime[(2^32-1) / phi_3^2]\n    const uint r2 = 2360945581u;// prime[(2^32-1) / phi_3^3]\n    \n    uint h = ((uvw.x * r0) ^ (uvw.y * r1) ^ (uvw.z * r2)) * r1;\n    \n    return h;\n}\n\n\nfloat Float01(uint x) { return float(x)      * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    uvec2 uv = uvec2(fragCoord);\n    \n    #ifdef ANIMATE_NOISE\n    fragColor = vec4(vec3( Float01(PhiHash(uvec3(uv, iFrame))) ), 1.0); \n\t#else    \n    fragColor = vec4(vec3( Float01(PhiHash(uv)) ), 1.0);\n    #endif\n}", "buffer_a_inputs": [], "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ltSXRz", "name": "Simple Fisheye Distortion", "author": "ddoodm", "description": "Test of implementing fisheye distortion and chromatic aberration", "tags": ["fisheyefisheyecameradistortion"], "likes": 11, "viewed": 1854, "published": 3, "date": "1581208559", "time_retrieved": "2024-07-30T21:25:08.357864", "image_code": "#define SPEED 1.2\n#define INTENSITY 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n    uv = (uv - 0.5) * 2.0;\n        \n   \tfloat t = iTime * SPEED;\n    \n    vec2 fishuv;\n    float fishyness = (0.1 + 0.1 * cos(t)) * INTENSITY;\n    fishuv.x = (1.0 - uv.y*uv.y) * fishyness * uv.x;\n    fishuv.y = (1.0 - uv.x*uv.x) * fishyness * uv.y;\n    \n    // Fisheye Chromatic Aberration !\n    float cr = texture(iChannel0, uv - fishuv*0.95).x;\n    vec2 cgb = texture(iChannel0, uv - fishuv).yz;\n    vec3 c = vec3(cr, cgb);\n    \n    // Vignetting\n    float uvMagSqrd = dot(uv,uv);\n    float vignette = 1.0 - uvMagSqrd * fishyness;\n    c *= vignette;\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 769]], "test": "untested"}
{"id": "wtfXDj", "name": "Checkerboard Floor", "author": "ddoodm", "description": "Just a simple test of trying to make a checkerboard floor!", "tags": ["grid", "checkerboard"], "likes": 5, "viewed": 422, "published": 3, "date": "1581208482", "time_retrieved": "2024-07-30T21:25:09.244494", "image_code": "#define INFINITY 100.0\n#define EPSILON 0.01\n#define PRECIS 32\n#define AA 8\n#define PI 3.14159\n\nstruct HIT\n{\n    vec3 point;\n    float dist;\n};\n\nfloat plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat world(in vec3 p, in float t)\n{\n    float plane1 = plane(p);\n    \n    return plane1;\n}\n\nHIT trace(in vec3 ro, in vec3 rd, in float t)\n{\n    vec3 p = ro;\n    for(int i=0; i<PRECIS; i++)\n    {\n        float d = world(p,t);\n        \n        if(d >= INFINITY)\n            return HIT(p, INFINITY);\n        \n        p += rd * d;\n        \n        if(d <= EPSILON)\n            break;\n    }\n    \n    return HIT(p, length(p-ro));\n}\n\nvec3 material(in vec3 p)\n{\n    const float SIZE = 0.5;\n    bool inx = mod(p.x*SIZE, 1.0) > 0.5;\n    bool inz = mod(p.z*SIZE, 1.0) > 0.5;\n    bool ing = inx ^^ inz;\n    \n    return vec3(0.4) * (ing ? 1.2 : 1.0);\n}\n\nvec3 image(in vec2 uv, in float t)\n{\n    float tt = 2.0*sin(t*0.9);\n    \n\tvec3 ro = vec3(cos(tt)*15.0, 10.0, 9.0*-sin(tt));\n    vec3 ta = vec3(0., 0., 0.);\n    vec3 up = normalize(vec3(0.5+0.5*sin(t), 1., 0.));\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(cross(cw,up));\n    vec3 cv = normalize(cross(cu,cw));\n    mat3 cam = mat3(cu,cv,cw);\n\tvec3 rd = cam * normalize(vec3(uv, 2.0));\n\t\n\tHIT hit = trace(ro, rd, t);\n\tfloat d = hit.dist;\n    vec3 p = hit.point;\n    \n    vec3 ambient = vec3(0.025,0.05,0.1);\n    \n\tif(d < INFINITY)\n\t{\n        vec3 albedo = material(p);\n        \n        float diff = 1.0;\n        \n        float fog = smoothstep(0.0, 1.0, d*0.015);\n        \n\t    vec3 pc = ambient + albedo*diff - fog;\n\t\tpc = max(ambient, pc);\n        \n\t    return clamp(pc, 0., 1.);\n\t}\n    else\n    {\n        return ambient;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize UV and aspect correct\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Offset UV to -1...1\n    uv *= 2.;\n    uv -= 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = vec3(0.);\n    \n    for(int m=0; m<AA; m++)\n        for(int n=0; n<AA; n++)\n        {\n            // AA offset\n            vec2 o = vec2(float(m),float(n)) / float(AA) / iResolution.xy * 2.0;\n            vec2 ouv = uv+o;\n            \n            // Motion blur time-offset\n            float t = iTime - texture(iChannel0, ouv+vec2(m,n)/float(AA)).r * .03;\n\n            // Capture image\n\t\t\tc += image(ouv, t);\n        }\n\n    // Output to screen\n    c /= float(AA * AA);\n    //c = pow(c,vec3(0.8));\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 183], [185, 185, 221, 221, 276], [278, 278, 325, 325, 611], [827, 827, 863, 863, 1667], [1669, 1669, 1726, 1765, 2449]], "test": "untested"}
{"id": "wtdXWM", "name": "virtual lava lamp (fluid sim)", "author": "unnick", "description": "my second attempt at a traditional eulerian fluid simulation, and it kind of works!\nits probably slighty messy though.", "tags": ["simulation", "fluid", "multipass", "convection", "finitedifference"], "likes": 14, "viewed": 882, "published": 3, "date": "1581206201", "time_retrieved": "2024-07-30T21:25:10.012440", "image_code": "//color channel layout\n//xy: velocity\n//z: pressure (inverted)\n//w: temperature/density\n\n//buffers\n//A: velocity update, diffusion / viscosity, & mouse interaction\n//B: pressure update\n//C: smoother\n//D: advection (uses C for velocity)\n\n//i might implement vorticity confinement later, but idk\n//id appreciate any suggestions\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    vec4 c = iA(pos);\n    //vec4 r = iA(pos+ivec2(1,0));\n    //vec4 u = iA(pos+ivec2(0,1));\n    \n    //float curl = c.x+r.y-u.x-c.y; curl *= 10.;\n    \n    float speed = dot(c.xy,c.xy);\n    //col.xyz = mix(vec3(0,.5,1), vec3(1,.5,0), clamp(c.w*speed*.5+.5,0.,1.)) * min(speed,1.);\n    col.xyz = (c.w > 0. ? vec3(1,.5,0) : vec3(0,.5,1)) * abs(c.w) * 4.;\n    //col.xyz = mix(vec3(0,.5,0), vec3(1,0,1), smoothstep(-1.,1.,c.w*1.));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//forces, viscosity, & interaction\nvoid mainImage(out vec4 val, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    val = iA(pos);\n    \n    vec4 r = iA(pos+ivec2(1,0));\n    vec4 u = iA(pos+ivec2(0,1));\n    vec4 l = iA(pos-ivec2(1,0));\n    vec4 d = iA(pos-ivec2(0,1));\n    \n    vec4 ch = vec4(0);\n\n    //change the speed according to the gradient of the pressure\n    ch.xy += vec2(r.z, u.z) - val.z;\n    \n    //convective force\n    ch.y += ((val.w+u.w)*3.\n          - (l.w-r.w-d.w)\n          - iA(pos+ivec2(2, 0)).w\n          - iA(pos+ivec2(1, 1)).w\n          - iA(pos+ivec2(1,-1)).w) * .01;\n    \n    //diffusion\n    ch += ((r+u+l+d) - val*4.) * diffusion;\n    \n    //integrate\n    val += ch*dt;\n    \n    //interaction\n    if(iMouse.z > .5 && distance(iMouse.xy, _pos) < 10.) {\n        val.w = 1.;\n    }\n    \n    //boundary conditions\n    ivec2 cpos = clamp(pos, ivec2(2), ires-2);\n    if(pos != cpos) val = iA(cpos);\n    if(pos.y < 2) {val.y = 0.; val.w = 1.;}\n    if(pos.y >= ires.y-2) {val.y = 0.; val.w = -1.;}\n    if(pos.x < 2) {val.x = 0.; val.w = 0.;}\n    if(pos.x >= ires.x-2) {val.x = 0.; val.w = 0.;}\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy\n#define ires ivec2(res)\n\n//params\n#define dt .3\n#define diffusion (vec2(.00, .1).xxxy)\n#define pressureloss .999\n#define numsteps 4\n\n//helpers\n#define iA(pos) texelFetch(iChannel0, pos, 0)\n#define iB(pos) texelFetch(iChannel1, pos, 0)\n\n#define fA(pos) texture(iChannel0, (pos) / res)\n#define fB(pos) texture(iChannel1, (pos) / res)\n", "buffer_b_code": "//pressure\nvoid mainImage(out vec4 val, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    val = iA(pos);\n    \n    vec4 l = iA(pos-ivec2(1,0));\n    vec4 d = iA(pos-ivec2(0,1));\n    \n    //change the pressure according to the divergence of velocity\n    val.z += (val.x - l.x + val.y - d.y) * dt * 2.;\n    \n    //idk if this is needed but ill keep this anyway\n    val.z *= pressureloss;\n    \n    //boundary conditions\n    ivec2 cpos = clamp(pos, ivec2(2), ires-2);\n    if(pos != cpos) val = iA(cpos);\n    if(pos.y < 2) {val.y = 0.; val.w = 1.;}\n    if(pos.y >= ires.y-2) {val.y = 0.; val.w = -1.;}\n    if(pos.x < 2) {val.x = 0.; val.w = 0.;}\n    if(pos.x >= ires.x-2) {val.x = 0.; val.w = 0.;}\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//smoothed velocity field (to be used in bufc)\nvoid mainImage(out vec4 val, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    \n    //compute a smoothed velocity field (to be used in buf c)\n    val = iA(pos) * 1.;\n    val += iA(pos+ivec2(1,0));\n    val += iA(pos+ivec2(0,1));\n    val += iA(pos-ivec2(1,0));\n    val += iA(pos-ivec2(0,1));\n    val /= 5.;\n    \n    //boundary conditions\n    ivec2 cpos = clamp(pos, ivec2(2), ires-2);\n    if(pos != cpos) val = iA(cpos);\n    if(pos.y < 2) {val.y = 0.; val.w = 1.;}\n    if(pos.y >= ires.y-2) {val.y = 0.; val.w = -1.;}\n    if(pos.x < 2) {val.x = 0.; val.w = 0.;}\n    if(pos.x >= ires.x-2) {val.x = 0.; val.w = 0.;}\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 371, 371, 829]], "test": "untested"}
{"id": "WttSRS", "name": "fn psych 1", "author": "anttikan", "description": "Composition using randomly generated functions mapping x, y, and time to color values.", "tags": ["2d", "abstract"], "likes": 3, "viewed": 288, "published": 3, "date": "1581199890", "time_retrieved": "2024-07-30T21:25:10.782382", "image_code": "\nfloat pixelfunc1(float x, float y, float iTime) {\n\treturn sin(sin(sin(log(abs(exp((exp((sqrt(pow((sin(iTime/50.0)),2.0)+pow((x),2.0))))-(pow((cos(((log(abs(abs(((sin(iTime/50.0))-((y)*(sin(iTime/50.0))))) - floor(abs(((sin(iTime/50.0))-((y)*(sin(iTime/50.0)))))))+0.0001)*(sin(iTime/50.0)))-(sign(sin(sin(log(abs((sin(iTime/50.0)))+0.0001))))-sign((sqrt(pow(cos((x)),2.0)+pow(exp(sin((y))),2.0)))))))-sqrt(abs((sin(iTime/50.0))))),2.0)/ (abs(abs(log(abs(sin(pow((pow(abs((sqrt(pow(sin((y)),2.0)+pow((0.9740085302659387),2.0)))) - floor(abs((sqrt(pow(sin((y)),2.0)+pow((sin(iTime/50.0)),2.0))))),2.0)/ (abs(sin((x)))+0.0001)),2.0)))+0.0001)) - floor(abs(log(abs(sin(pow((pow(abs((sqrt(pow(sin((y)),2.0)+pow((sin(iTime/50.0)),2.0)))) - floor(abs((sqrt(pow(sin((y)),2.0)+pow((sin(iTime/50.0)),2.0))))),2.0)/ (abs(sin((x)))+0.0001)),2.0)))+0.0001))))+0.0001)))))+0.0001))));\n}\n\nfloat pixelfunc2(float x, float y, float iTime) {\n    return cos(pow(log(abs(sin(((sqrt(pow((y),2.0)+pow((x),2.0)))-(sin(iTime/50.0)))))+0.0001),3.0));\n}\n\n\nfloat pixelfunc4(float x, float y, float iTime) {\n\treturn (pow((sign((abs(log(abs(log(abs(((x)/ (abs(((sqrt(pow(pow(sin(log(abs(sqrt(abs(sin((sin(iTime/3.0))))))+0.0001)),2.0),2.0)+pow(sign(pow(exp(sin(cos((sin(iTime/23.0))))),3.0)),2.0)))*(sin(sin((x)))+log(abs(((sin(iTime/43.0))))+0.0001))))+0.0001)))+0.0001))+0.0001)) - floor(abs(log(abs(log(abs(((x)/ (abs(((sqrt(pow(pow(sin(log(abs(sqrt(abs(sin((sin(iTime/99.0))))))+0.0001)),2.0),2.0)+pow(sign(pow(exp(sin(cos((sin(iTime/50.0))))),3.0)),2.0)))*(sin(sin((x)))+log(abs(((sin(iTime/50.0)) + 0.7777742932635703))+0.0001))))+0.0001)))+0.0001))+0.0001)))*((sqrt(pow((sin(iTime/9.3)),2.0)+pow(pow(exp(sin(cos((x)))),2.0),2.0)))/ (abs(sign((y)))+0.0001))))*(y)),2.0)-cos((((sin(iTime/12.0))+log(abs(log(abs((cos(cos(((sin(log(abs(sin((y)))+0.0001))*pow(pow((pow(sin((x)),2.0)*((sqrt(pow(((sin(iTime/82.0))),2.0)+pow((y),2.0)))+(x))),3.0),2.0))*pow(log(abs((y))+0.0001),2.0))))+abs(pow(log(abs(sin(pow(log(abs(sin((log(abs(((sin(iTime/54.0))))+0.0001)/ (abs(sqrt(abs((x))))+0.0001))))+0.0001),3.0)))+0.0001),3.0)) - floor(abs(pow(log(abs(sin(pow(log(abs(sin((log(abs(((sin(iTime/19.0))))+0.0001)/ (abs(sqrt(abs((x))))+0.0001))))+0.0001),3.0)))+0.0001),3.0)))))+0.0001))+0.0001))+sign(sin((log(abs((y))+0.0001)-(sqrt(abs((sin(iTime/50.0))))-(x))))))));\n}\n\n\n\nfloat pixelfunc3(float x, float y, float iTime) {\n    return cos((((sqrt(pow(sign((abs((sqrt(pow(abs(log(abs(pow(((y)+((sqrt(pow(log(abs((y))+0.0001),2.0)+pow(exp((0.6504765371794483)),2.0)))*(x))),2.0))+0.0001)) - floor(abs(log(abs(pow(((y)+((sqrt(pow(log(abs((y))+0.0001),2.0)+pow(exp((0.04764667859459348)),2.0)))*(x))),2.0))+0.0001))),2.0)+pow(sin((cos((log(abs((sqrt(pow((sqrt(pow((y),2.0)+pow((sin(iTime/50.0)),2.0))),2.0)+pow((sqrt(pow(sin((x)),2.0)+pow(((x)*(0.8673575468060508)),2.0))),2.0))))+0.0001)/ (abs((sin(iTime/50.0)))+0.0001)))-(sqrt(pow(sin(pow((y),3.0)),2.0)+pow(exp(cos(abs(sin((sqrt(pow((0.8322902951206665),2.0)+pow((y),2.0))))) - floor(abs(sin((sqrt(pow((0.3968041457977698),2.0)+pow((y),2.0)))))))),2.0))))),2.0)))) - floor(abs((sqrt(pow(abs(log(abs(pow(((y)+((sqrt(pow(log(abs((y))+0.0001),2.0)+pow(exp((0.8178348996915921)),2.0)))*(x))),2.0))+0.0001)) - floor(abs(log(abs(pow(((y)+((sqrt(pow(log(abs((y))+0.0001),2.0)+pow(exp((0.7066221237987398)),2.0)))*(x))),2.0))+0.0001))),2.0)+pow(sin((cos((log(abs((sqrt(pow((sqrt(pow((y),2.0)+pow((sin(iTime/50.0)),2.0))),2.0)+pow((sqrt(pow(sin((x)),2.0)+pow(((x)*(0.18088153561781883)),2.0))),2.0))))+0.0001)/ (abs((sin(iTime/50.0)))+0.0001)))-(sqrt(pow(sin(pow((y),3.0)),2.0)+pow(exp(cos(abs(sin((sqrt(pow((0.20980616617980674),2.0)+pow((y),2.0))))) - floor(abs(sin((sqrt(pow((0.5199379468707619),2.0)+pow((y),2.0)))))))),2.0))))),2.0)))))/ (abs(exp(pow(sin(cos((y))),2.0)))+0.0001))),2.0)+pow(pow((log(abs(((sin(iTime/50.0))+sqrt(abs(sin((((sin(iTime/50.0))+(pow((((0.645013938513374)/ (abs((sin(iTime/50.0)))+0.0001))*log(abs((y))+0.0001)),2.0)+sin(pow(((sin(iTime/50.0))-(0.67468411323543)),3.0))))-log(abs(pow((y),2.0))+0.0001)))))))+0.0001)-((y)+log(abs((sqrt(pow(log(abs((((((x)/ (abs((log(abs((y))+0.0001)/ (abs(sign((sin(iTime/50.0))))+0.0001)))+0.0001))/ (abs(sqrt(abs((((sin(iTime/50.0))-(x))/ (abs((sqrt(pow((x),2.0)+pow((x),2.0))))+0.0001)))))+0.0001))/ (abs((x))+0.0001))-(0.1765825918759809)))+0.0001),2.0)+pow(abs((sin(iTime/50.0))) - floor(abs((sin(iTime/50.0)))),2.0))))+0.0001))),2.0),2.0)))/ (abs(((x)+exp(sqrt(abs(sin((abs((0.4677294447060407)) - floor(abs((0.5508777906941824)))-(pow((sin(iTime/50.0)),3.0)-log(abs(log(abs((log(abs(sin(sqrt(abs(pow((0.4811068184551617),3.0)))))+0.0001)/ (abs(pow((0.14052102986686088),2.0))+0.0001)))+0.0001))+0.0001)))))))))+0.0001))/ (abs(sqrt(abs(pow(pow(sqrt(abs(sqrt(abs((pow(sin((sqrt(pow((pow(sign(log(abs(((x)+(0.8656798029803934)))+0.0001)),2.0)-abs((x)) - floor(abs((x)))),2.0)+pow(sign(log(abs((0.3391320298928444))+0.0001)),2.0)))),2.0)/ (abs(pow((exp(abs(sign(sign((sqrt(pow(((y)-(y)),2.0)+pow((0.3592247742818151),2.0)))))) - floor(abs(sign(sign((sqrt(pow(((y)-(y)),2.0)+pow((0.7200213323597715),2.0))))))))/ (abs((0.1431772443507151))+0.0001)),3.0))+0.0001)))))),3.0),2.0))))+0.0001)));   \n}\n\nfloat pixelfunc5(float x, float y, float iTime) {\n    return (pow(log(abs((((sin(iTime/50.0))-(((sqrt(pow((0.7035442116208261),2.0)+pow(sign((abs((y)) - floor(abs((y)))*(y))),2.0)))/ (abs(log(abs((0.45474232626833255))+0.0001))+0.0001))+(x)))/ (abs((sin(iTime/50.0)))+0.0001)))+0.0001),3.0)*(y));    \n}\n\n\nfloat pixelfunc6(float x, float y, float iTime) {\n\treturn sign(((x)+sin(pow(pow((cos(pow((pow(sign(pow(pow(exp(abs(pow((sin(iTime/50.0)),3.0)) - floor(abs(pow((sin(iTime/50.0)),3.0)))),3.0),2.0)),3.0)*((y)/ (abs((sin(iTime/50.0)))+0.0001))),3.0))*sign(sin(sign(((x)+sin(sin(log(abs(pow((((0.011494319310108247)+(y))-pow((x),2.0)),2.0))+0.0001)))))))),3.0),2.0))));    \n}\n\n\nfloat pixelfunc7(float x, float y, float iTime) {\n\treturn sign(((x)+sin(pow(pow((cos(pow((pow(sign(pow(pow(exp(abs(pow((0.2551045723848604),3.0)) - floor(abs(pow((0.3151917658637282),3.0)))),3.0),2.0)),3.0)*((y)/ (abs((0.0176144938387357))+0.0001))),3.0))*sign(sin(sign(((x)+sin(sin(log(abs(pow((((0.011494319310108247)+(y))-pow((x),2.0)),2.0))+0.0001)))))))),3.0),2.0))));\n}\n\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float r = pixelfunc1((2.0+sin(iTime*0.32))*(uv.x-0.5) + sin(iTime*0.1), 2.0*(uv.y-0.5), iTime*0.1);\n    float g = pixelfunc2((2.0+sin(iTime*0.2))*(uv.x-0.5) + sin(iTime*0.1), 2.0*(uv.y-0.5), iTime*0.2);\n    float b = pixelfunc3((2.0+sin(iTime*0.1))*(uv.x-0.5) + sin(iTime*0.1), 2.0*(uv.y-0.5), iTime*0.07);\n    //vec3 col = vec3(map(r,-1.0, 1.0, 0.0, 1.0), map((g + r +b)/3.0,-2.0, 2.0, 0.0, 1.0), map(b-r,-2.0, 2.0, 0.0, 1.0));\n    \n    float shade = pixelfunc4(2.0*(uv.x-0.5) + sin(iTime*0.1), (10.0+9.5*sin(iTime*0.1))*(uv.y-0.5), iTime*4.0+22.0);\n    shade = map(-shade,-2.0, 2.0, 0.0, 1.0);\n    \n    float rmapped = map(r,-1.0, 1.0, 0.0, 1.0);\n    float gmapped = map((g + r +b)/3.0,-2.0, 2.0, 0.0, 1.0);\n    float bmapped = map(b-r,-2.0, 2.0, 0.0, 1.0);\n    \n    vec3 col = vec3(0.05*rmapped + 0.15 + 0.8*shade*rmapped, 0.05*bmapped + 0.95*shade*gmapped, 0.2 + 0.8*shade*bmapped);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 50, 50, 873], [875, 875, 924, 924, 1028], [1031, 1031, 1080, 1080, 2333], [2337, 2337, 2386, 2386, 5167], [5169, 5169, 5218, 5218, 5471], [5474, 5474, 5523, 5523, 5844], [5847, 5847, 5896, 5896, 6222], [6226, 6226, 6298, 6298, 6382], [6384, 6384, 6441, 6491, 7522]], "test": "untested"}
{"id": "tltXDN", "name": "Infinite Icing Donut", "author": "xjorma", "description": "Homer Simpson dream !\nInspired by Matt Taylor https://www.instagram.com/p/BuWBEloHiSw/\nUse the mouse to turn around.", "tags": ["donut", "reproduction", "cineshader", "timhorton", "icing", "dunkin", "sugarrush"], "likes": 25, "viewed": 9400, "published": 3, "date": "1581198893", "time_retrieved": "2024-07-30T21:25:11.553321", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n\nconst float\tlayerThickness\t= 0.02;\nconst int\tnbLayers \t\t= 7;\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nvec2 map(in vec3 p)\n{\n    float slide = iTime / 1.;\n    float fr = fract(slide);\n    int   fl = int(floor(slide));    \n    vec2  vd = vec2(100., -1.);\n    float cnoise = noise(p * 2. + iTime / 8.) / 3.;\n    float o = 100.0f;\n    for( int i = 0; i < nbLayers; i++)\n    {\n        float m = mod(float(i + fl), float(nbLayers));\n        float r = 0.6 - m * layerThickness + ( 1. - fr) * layerThickness;\n        float d = sdTorus( p, vec2(1, r)) ;\n        d = d - layerThickness / 2.;\n        float o =  - 4. * fract( (iTime + float(i)) / float(nbLayers));\n        float n = 1.5 + p.x  + o + cnoise;\n\t\td = max(d, n);\n \t\tvd = minVecSelect(vec2(d, float(i)), vd);        \n    }   \n    return vd;\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy*h).x + \n                      k.yyx * map(p + k.yyx*h).x + \n                      k.yxy * map(p + k.yxy*h).x + \n                      k.xxx * map(p + k.xxx*h).x );\n}\n\n// From IQ\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/12.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return saturate(1.0 - 4. * occ);    \n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float t = 0.5;\n    float d;\n    float m = 0.;\n    for( int i=0; i<1024; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        vec2\th = map(p);\n        t += h.x*0.7;\n        d = dot(t*rd,cd);\n        m = h.y;\n        if( abs(h.x)<0.0001 || d>dist ) break;\n    }\n\n    vec3 col = vec3(0.3);\n\n    if( d<dist )\n    {\n        vec3 light = vec3(0.,4.,2.);\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 v = normalize(ro-p);\n        vec3 l = normalize(light-p);\n        vec3 h = normalize(l+v);\n        \n        vec3 diffcol = normalize(vec3(1. + sin(m * 0.7 + 1.3) / 2., 1. + sin(m * 1.3 + 4.45) / 2., 1. + sin(m * 1.9 + 2.3) / 2.)); \n        vec3 speccol = vec3(1.,1.,1.);\n        vec3 ambcol = diffcol;\n\t\tfloat ao = calcAO(p, n);\n        \n        col = saturate(dot(n,l)) * diffcol;\n        col+= pow(saturate(dot(n,h)),40.) * speccol * 0.5;\n        col+= 0.2 * ambcol;\n        col*= ao;\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.1;\n        float phi\t= radians(45.) + radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.7*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3(0, -0.2, 0);\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],20.);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n    tot = pow(tot, vec3(1./2.2));\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[225, 225, 258, 258, 313], [316, 316, 341, 341, 370], [373, 373, 408, 408, 434], [436, 436, 459, 459, 498], [500, 500, 526, 526, 931], [933, 933, 954, 954, 1623], [1626, 1626, 1651, 1651, 1919], [1921, 1932, 1974, 1974, 2266], [2269, 2269, 2318, 2318, 3249], [3251, 3251, 3329, 3329, 3401], [3403, 3403, 3445, 3445, 3609], [3611, 3611, 3655, 3655, 3754], [3756, 3756, 3796, 3796, 3866]], "test": "untested"}
{"id": "tt3XRB", "name": "Caustic Patience", "author": "wyatt", "description": "All good things take time. \nPart 1 - simulate a wave for 500 frames\nPart 2 - simulate photons passing through the wave field make a nice caustic", "tags": ["wave", "light", "caustic"], "likes": 15, "viewed": 583, "published": 3, "date": "1581192352", "time_retrieved": "2024-07-30T21:25:12.375123", "image_code": "Main {\n\tQ = 5e-4*B(U)/(float(1+iFrame-O))*(R.y*R.x);\n    \n    if (iFrame < O)\n        Q = 0.5+.05*(A(U).yyyy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define O 500\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Main void mainImage (out vec4 Q, vec2 U) \n// Dave H\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "Main {\n\tif (iFrame >= O) discard;\n    Q = A(U);\n    Neighborhood\n    \n    Q.x += m.y-Q.y;\n    Q.y += .4*Q.x;\n    Q.zw = 0.25*vec2(e.y-w.y,n.y-s.y);\n    if (iFrame < 1)\n   \tQ = vec4(0,0,0,0);\n    vec2 M = 0.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    Q.y += 7e-4*R.x*sin(float(iFrame)/70.)*10.*exp(-3.*dot(U-M,U-M)/R.x);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 P (vec2 U, vec3 p) {\n\treturn exp(-0.5*dot(U-p.xy,U-p.xy))*max(cos(p.z*6.2+vec4(1,2,3,4)),0.);\n}\nMain {\n    \n    if (iFrame < O) Q = vec4(0);\n    else {\n    Q = B(U);\n    #define N 250\n    for (int i = 0; i < N; i++) {\n        int I = (iFrame-O)*N+i;\n        vec4 h = hash44(vec4(U,i,iFrame));\n    \tvec3 p = 0.5*vec3(\n            (I%int(2.*R.x)),\n            (I/int(2.*R.x))%int(2.*R.y),\n            2.*h.x\n        );p.xy += h.xy*2.-1.;\n        vec2 g = A(p.xy).zw;\n        p.xy += 30.*g*(1.+p.z);\n        Q += P(U,p.xyz);\n    }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    \n\tif (iFrame >= O) discard;\n\tQ = A(U);\n    Neighborhood\n    Q.x += m.y-Q.y;\n    Q.y += .4*Q.x;\n    Q.zw = 0.25*vec2(e.y-w.y,n.y-s.y);\n    if (iFrame < 1)\n   \tQ = vec4(0,0,0,0);\n    vec2 M = 0.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    Q.y += 7e-4*R.x*sin(float(iFrame)/30.)*10.*exp(-3.*dot(U-M,U-M)/R.x);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tif (iFrame >= O) discard;\n\tQ = A(U);\n    Neighborhood\n    Q.x += m.y-Q.y;\n    Q.y += .4*Q.x;\n    Q.zw = 0.25*vec2(e.y-w.y,n.y-s.y);\n    if (iFrame < 1)\n   \tQ = vec4(0,0,0,0);\n    vec2 M = 0.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    Q.y += 7e-4*R.x*sin(float(iFrame)/8.)*10.*exp(-3.*dot(U-M,U-M)/R.x);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlcXRS", "name": "Basic : Voronoi Tracking 1buff", "author": "FabriceNeyret2", "description": "Variant of Gijs' [url]https://shadertoy.com/view/WltSz7[/url]\nusing one single buffer, with only 2 small zones used for particles and Voronoi buffer. ( #iRes1/2 in Common)\nCan also choose the length of closest lists stored ( #LIST in Common ). default: 2", "tags": ["2d", "voronoi", "simulation", "particles", "voronoiparticlestracking"], "likes": 40, "viewed": 1632, "published": 3, "date": "1581184885", "time_retrieved": "2024-07-30T21:25:13.140078", "image_code": "// Fork of Gijs' https://shadertoy.com/view/WltSz7\n// using one single buffer (  with only 2 small zones used for particles and Voronoi buffer: #iRes1/2 in Common)\n// Can also choose the length of closest lists stored ( #LIST in Common )\n// (see discussion for limits).\n\n// === Display\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = getClosestS(ivec2(fragCoord));\n    \n    //draw the particles\n        for(int i = 0; i < 4; i++){\n            //get the particles position\n            int id = ids[i];\n            vec2 pos = getParticle(id).xy;\n\n            //get the distance to the particle\n            float d = distance(fragCoord,pos);\n\n            //color it\n            fragColor += .3/(d*d);\n        }\n    \n    //draw voronoi outlines\n        //get the position of the closest particle\n    \tvec2  p1 = getParticle(ids.x).xy;\n        //get the position of the second closest particle\n\t\tvec2  p2 = getParticle(ids.y).xy;\n        //get the distance to voronoi edge\n        float r = dot(fragCoord-(p1+p2)/2.,normalize(p2-p1));\n        fragColor += smoothstep(2.,0.,abs(r))*.3;\n    \n    //fragColor += vec4(ids/float(PARTICLES));\n    \n    vec2  _m0 = fragCoord-iResolution1, _m = fragCoord-ofs2-iResolution2;  // display maps\n    if ( max(_m0.x,_m0.y) < 0. || ( fragCoord.x>iResolution1.x && max(_m.x,_m.y) < 0.) )\n        fragColor += (1.-fragColor.a) * .5*texelFetch(iChannel0, ivec2(fragCoord), 0) \n                                            / ( fragCoord.x < ofs2.x ? .2*iResolution.x: float(PARTICLES) )\n                     + vec4(0,0,.3,0);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// one single buffer Fork of Gijs' https://shadertoy.com/view/WltSz7\n\n// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n\n//amount of particles\nconst int PARTICLES = 1000; \n\n//percentage of maximum allowed speed\nconst float SPEED = 1.;\n\n\n#define iResolution1 (iResolution.xy/4.)  // slot allocated for Particle Buffer \n#define iResolution2 (iResolution.xy/4.)  // slot allocated for Voronoi Buffer\n#define ofs2     vec2(iResolution1.x,0)\n// --- chose length of closest LIST\n//#define LIST xxxx    //  1 (not enough for repulsion & draw voronoi)\n  #define LIST xyyy    //  2\n//#define LIST xyzz    //  3\n//#define LIST xyzw    //  4\n\n// --- Particle Buffer part:\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\n// --- Voronoi Buffer part:\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n\n//returns the ids of the four closest particles from the input\n//    if (xy != ivec2(clamp(vec2(xy),vec2(0),iResolution2)) ) return ivec4(0);\n#define getClosest(xy) /* xy: location within Voronoi Buffer */ \\\n    ivec4(texelFetch(iChannel0, ivec2(ofs2+vec2(xy)), 0).LIST) // was channel1\n\n#define getClosestS(pos) getClosest(ivec2(vec2(pos)/iResolution.xy*iResolution2))\n        \n//returns the location of the particle within the particle buffer corresponding with the input id \n#define locFromID(id) ivec2( (id) % int(iResolution1.x), (id) / int(iResolution1.x))\n\n//get the particle corresponding to the input id\n#define getParticle(id) texelFetch(iChannel0, locFromID(id), 0)\n\n\n\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n", "buffer_a_code": "// one single buffer Fork of Gijs' https://shadertoy.com/view/WltSz7\n\nfloat distance2Particle(int id, vec2 worldCoord){ // screen coords\n    if(id==-1) return 1e20;\n    vec2 delta = getParticle(id).xy-worldCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n    i = i.LIST; d = d.LIST;\n}\n\n// =========================================================\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n\n// === main Particle Buffer part\nvec2 _m = fragCoord.xy-iResolution1; if (max(_m.x,_m.y)<0.) {\n        \n    //we only simulate PARTICLES amount of particles\n    int id = iFragCoord.x + iFragCoord.y*int(iResolution1.x);\n    if(id>=PARTICLES) return;\n    \n    vec4 prev = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec2 pos = prev.xy;   // screen coords\n    vec2 vel = prev.zw;\n     \n    if(iFrame==0){\n       \t//pick a \"random\" starting position\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        pos = vec2(h1,h2)*iResolution.xy;  // screen coordinates\n        //fragColor = vec4(pos, 0,0); return;\n    }\n\n    //gather forces\n    vec2 force = vec2(0);\n    \n        //friction\n        force -= vel*0.2;\n\n        //interaction\n        if(iMouse.z > 0.){\n            vec2 delta = pos-iMouse.xy;\n            float dis = length(delta);\n            force += delta/(dis*dis) * 10.;\n        }\n\n       //repulsion from others\n        ivec4 closest = getClosest(ivec2(pos/iResolution.xy*iResolution2)); // conv to voronoi coord\n        for(int i = 0; i < 4; i++){\n            int cid = closest[i];\n            if(cid==id) continue; // not always working ? (but for list length<3)\n            \n            vec2 delta = pos-getParticle(cid).xy;\n            float dis = length(delta)+1e-5; // was sometime 0 !\n            force += delta /(dis*dis*dis) * 30.;\n        }\n    \n    \t//repulsion from walls\n    \tvec2 dis = max(iResolution.xy-pos, vec2(1));\n    \tforce -= 1./(dis*dis) * 10.;\n    \t     dis = max(pos, vec2(1));\n    \tforce += 1./(dis*dis) * 10.;\n\n    //integrate forces\n    vel += force;\n    \n    //cap velocity at max speed\n    float dv = length(vel);\n    if(dv>SPEED) vel *= SPEED/dv;\n    \n    //integrate velocity\n    pos += vel;\n    \n    fragColor = vec4(pos,vel); return;\n}\n\n// === main Voronoi Buffer part\n_m = fragCoord.xy-ofs2-iResolution2; if (fragCoord.x>=iResolution1.x && max(_m.x,_m.y)<0.) {   \n    \n    //if(iFrame==0){ fragColor = vec4(0); return; }\n    ivec2 iFragCoord = ivec2(fragCoord-ofs2);\n    vec2 worldCoord = (fragCoord-ofs2)/iResolution2 * iResolution.xy;\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    //get all known closest particles from old self and neighbours\n    ivec4 old   = getClosest( iFragCoord + ivec2( 0, 0) );            \n    ivec4 east  = getClosest( iFragCoord + ivec2( 1, 0) );\n\tivec4 north = getClosest( iFragCoord + ivec2( 0, 1) );\n    ivec4 west  = getClosest( iFragCoord + ivec2(-1, 0) );\n    ivec4 south = getClosest( iFragCoord + ivec2( 0,-1) );\n    //collect them in a array so we can loop over it\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++){\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, worldCoord); // to screen\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution2.x) + \n            iFrame*int(iResolution2.x*iResolution2.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, worldCoord) );\n    }\n    \n    fragColor = vec4(new);   \n}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 340, 340, 1716]], "test": "untested"}
{"id": "wl3XRS", "name": "Day 51", "author": "jeyko", "description": "buffer feedback stuff", "tags": ["mdtmjvm"], "likes": 21, "viewed": 563, "published": 3, "date": "1581179486", "time_retrieved": "2024-07-30T21:25:13.938942", "image_code": "void mainImage( out vec4 C, in vec2 U )\n{\n    float m = sin(iTime);\n \tC = sin(T(U)*150.2 + vec4(1.05 + m*0.1,1.,1.0+ sin(iTime + U.x/R.x)*0.0,1));\n    C = pow(abs(C), vec4(5.));\n    C = smoothstep(0.,1.,C);\n    U -= R*0.5;\n    U /= R.y;\n    C.xyz *= 1. + vec3(9.1 - length(U)*5.9 ,2.2,1.4)*(length(U )*0.4)*0.1;\n    U *= 0.94;\n    C *= 1. - pow(length(U), 1.)*0.9;\n    C *= 1.9;\n    C *= smoothstep(0., 1., iTime*0.5);\n    //C *= 1. - dot(U, U)*2.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nfloat blur(in vec2 p){\n    #define bcomp x\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1./iResolution.xy;\n\tfloat res = 0.0;\n\tres += T(p + e.xx*px ).bcomp + T(p + e.xz*px ).bcomp + T(p + e.zx*px ).bcomp + T(p + e.zz*px ).bcomp;\n    res += (T(p + e.xy*px ).bcomp + T(p + e.yx*px ).bcomp + T(p + e.yz*px ).bcomp + T(p + e.zy*px ).bcomp)*2.;\n\tres += T(p + e.yy*px ).bcomp*4.;\n    return res/16.;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    #define grad(i) vec2(e.i - w.i, n.i - s.i)\n    #define div(i) (e.i - w.i + n.i - s.i)\n    \n    #define curl(i) (n.i-e.i-s.i+w.i)\n    \n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    Neighbors;\n    U -= 0.5*R;\n    vec2 Q = U;\n    U *= rot(-0.0019*(sin(iMouse.x*3.14)) );\n    U *= 0.9991;\n    U *= 1. + dot(U/R.y, U/R.y)*0.003;\n    U += 0.5*R;\n \n    U += grad(y)*0.8;\n    U -= div(y)*40.;\n    C = T(U)*1.0;\n    \n    \n    C.x += div(y)*0.025;\n    C.x -= curl(x)*0.09;\n    vec2 g = grad(x);\n    g *= rot(-0.1);\n    //g.y *= -1.;\n    C.xy -= g*0.06;\n    C = mix(C, m - C, 0.01);\n    C = sin(C );\n    Q *= rot(iTime*6.);\n    if(iMouse.z > 0.){\n    \t//C = mix(C, vec4(1,1,1,1)*(sin(Q.xyyx*0.2))*0.1, smoothstep(0.04,0.035,length(iMouse.xy/R.x - U/R.x)) );\n    }\n    if (iFrame < 3){\n    \tC = (sin(U.xyyx*0.2))*40.;\n    }\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n\n\n#define Neighbors vec4 n = T(U + vec2(0,1)); vec4 s = T(U - vec2(0,1)); vec4 e = T(U + vec2(1,0)); vec4 w = T(U - vec2(1,0)); vec4 m = 0.25*(n + w + e + s);\n\n\n", "buffer_b_code": "\n\nfloat blur(in vec2 p){\n    #define bcomp x\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1./iResolution.xy;\n\tfloat res = 0.0;\n\tres += T(p + e.xx*px ).bcomp + T(p + e.xz*px ).bcomp + T(p + e.zx*px ).bcomp + T(p + e.zz*px ).bcomp;\n    res += (T(p + e.xy*px ).bcomp + T(p + e.yx*px ).bcomp + T(p + e.yz*px ).bcomp + T(p + e.zy*px ).bcomp)*2.;\n\tres += T(p + e.yy*px ).bcomp*4.;\n    return res/16.;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    #define grad(i) vec2(e.i - w.i, n.i - s.i)\n    #define div(i) (e.i - w.i + n.i - s.i)\n    \n    #define curl(i) (n.i-e.i-s.i+w.i)\n    \n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    Neighbors;\n    U -= 0.5*R;\n    vec2 Q = U;\n    U *= rot(-0.0019*(sin(iMouse.x*3.14)) );\n    U *= 0.9991;\n    U *= 1. + dot(U/R.y, U/R.y)*0.003;\n    U += 0.5*R;\n \n    U += grad(y)*0.8;\n    U -= div(y)*40.;\n    C = T(U)*1.0;\n    \n    \n    C.x += div(y)*0.025;\n    C.x -= curl(x)*0.09;\n    vec2 g = grad(x);\n    g *= rot(-0.1);\n    //g.y *= -1.;\n    C.xy -= g*0.06;\n    C = mix(C, m - C, 0.01);\n    C = sin(C );\n    Q *= rot(iTime*6.);\n    if(iMouse.z > 0.){\n    \t//C = mix(C, vec4(1,1,1,1)*(sin(Q.xyyx*0.2))*0.1, smoothstep(0.04,0.035,length(iMouse.xy/R.x - U/R.x)) );\n    }\n    if (iFrame < 3){\n    \tC = (sin(U.xyyx*0.2))*40.;\n    }\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 450]], "test": "untested"}
{"id": "3tdXDM", "name": "fizzlefade", "author": "hanabi", "description": "implemented as Feistel Network, 8 bits\n\nhttp://fabiensanglard.net/fizzlefade/index.php\nhttp://antirez.com/news/113", "tags": ["fizzlefade", "fizzle", "feistelnetwork"], "likes": 3, "viewed": 327, "published": 3, "date": "1581168295", "time_retrieved": "2024-07-30T21:25:14.701902", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tfragColor = vec4(mix(texture(iChannel0, uv).rgb,\n                         texture(iChannel1, uv).rgb,\n                         texture(iChannel1, uv).a\n                        ), 0.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    int l = iFrame;\n\n    int r = l >> 4 & 0xf;\n    l = l & 0xf;\n    for (int i = 0; i < 8; i++) {\n        int nl = r;\n        int F =(((r * 13) + (r >> 2) + 7 * 7) ^ r) & 0xf;\n        r = l ^ F;\n        l = nl;\n    }\n    l = ((r<<4)|l) & 0xff;\n\n    ivec2 coords = ivec2(fragCoord / (iResolution.xy / 16.));\n    \n    if (coords.x + coords.y * 16 == l)\n        fragColor = vec4(0, 1, 0, 0.5);\n    \n    if (iFrame % 260 == 0)\n        fragColor = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 291]], "test": "untested"}
{"id": "Wt3XzS", "name": "Phasor noise figure 3 (variant)", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/3lS3Dm[/url] ( Procedural Phasor Noise [url]https://hal.archives-ouvertes.fr/hal-02118508[/url] )\nSPACE to display the phasor noise ( = oscillator * phasor ) \nMouse.x : sine  direction  Mouse.y : sine  freq\n", "tags": ["noise"], "likes": 2, "viewed": 520, "published": 3, "date": "1581158186", "time_retrieved": "2024-07-30T21:25:15.465859", "image_code": "// Fork of  https://shadertoy.com/view/3lS3Dm\n// ( add noise display on SPACE press , Mouse.y controls )\n\n# define M_PI 3.14159265358979323846\n\n//phasor noise parameters\nfloat _f = 25.0;\nfloat _b = 10.0;\nfloat _o = 1.0;\nfloat _kr;\nint _impPerKernel = 16;\nint _seed = 1;\n\nvec2 uv;\n\nvec2 phasor(vec2 x, float f, float b, float o, float phi)\n{\n    \n    float a = exp(-M_PI * (b * b) * ((x.x * x.x) + (x.y * x.y)));\n    float s = sin (2.0* M_PI * f  * (x.x*cos(o) + x.y*sin(o))+phi);\n    float c = cos (2.0* M_PI * f  * (x.x*cos(o) + x.y*sin(o))+phi);\n    return vec2(a*c,a*s);\n}\n\n///////////////////////////////////////////////\n//prng\n///////////////////////////////////////////////\n\nint N = 15487469;\nint x_;\nvoid seed(int s){x_ = s;}\nint next() { x_ *= 3039177861; x_ = x_ % N;return x_; }\nfloat uni_0_1() {return  float(next()) / float(N);}\nfloat uni(float min, float max){ return min + (uni_0_1() * (max - min));}\n\n\nint morton(int x, int y)\n{\n  int z = 0;\n  for (int i = 0 ; i < 32* 4 ; i++) {\n    z |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));\n  }\n  return z;\n}\n\n\nvoid init_noise()\n{\n    _kr = sqrt(-log(0.05) / M_PI) / _b;\n}\n\n\nvec2 cell(ivec2 ij, vec2 uv, float f, float b, float o)\n{\n\tint s= morton(ij.x,ij.y) + 333;\n\ts = s==0? 1: s +_seed;\n\tseed(s);\n\tint impulse  =0;\n\tint nImpulse = _impPerKernel;\n\tfloat  cellsz = 2.0 * _kr;\n\tvec2 noise = vec2(0.0);\n\twhile (impulse <= nImpulse){\n\t\tvec2 impulse_centre = vec2(uni_0_1(),uni_0_1());\n\t\tvec2 d = (uv - impulse_centre) *cellsz;\n\t\tfloat rp = uni(0.0,2.0*M_PI);\n\t\tnoise += phasor(d, f, b ,o,rp );\n\t\timpulse++;\n\t}\n\treturn noise;\n}\n\nvec2 eval_noise(vec2 uv, float f, float b, float o)\n{   \n\tfloat cellsz = 2.0 *_kr;\n\tvec2 _ij = uv / cellsz;\n\tivec2  ij = ivec2(_ij);\n\tvec2  fij = _ij - vec2(ij);\n\tvec2 noise = vec2(0.0);\n\tfor (int j = -2; j <= 2; j++) {\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tivec2 nij = ivec2(i, j);\n\t\t\tnoise += cell(ij + nij , fij - vec2(nij),f,b,o );\n\t\t}\n\t}\n    return noise;\n}\n\nfloat PWM(float x, float r)\n{\n\treturn mod(x,2.0*M_PI)> 2.0*M_PI *r ? 1.0 : 0.0; \n}\n\nfloat square(float x)\n{\n  return PWM(x,0.5);   \n}\n\nfloat sawTooth(float x)\n{\n\treturn mod(x,2.0*M_PI)/(2.0*M_PI);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  uv = fragCoord/iResolution.y;\n  uv.y=-uv.y;\n  init_noise();\n  vec2 M = iMouse.xy/iResolution.xy;\n  float o = M.x * 2.0*M_PI;\n  if (iMouse.z>0.) _f *=  2.*M.y;; // _b *= .4 + 2.*M.y;\n  vec2 phasorNoise = eval_noise(uv,_f,_b,o);\n  vec2 dir = vec2(cos(o),sin(o));\n  float phi = atan(phasorNoise.y,phasorNoise.x);\n  float I = length(phasorNoise);\n  vec3 phasorfield  = keyClick(32) \n         ? vec3(sin(phi)*0.3 +0.5)                              //figure3 a\n         : hsv2rgb(vec3(phi/(2.*M_PI)-_f*dot(uv,dir), .8, .8)); //figure3 b\n  //phasorfield  = vec3(mod(phi/(2.0*M_PI)-_f*dot(uv,dir),1.0));//figure3 c\n  //phasorfield = vec3(I);\n  fragColor = vec4(phasorfield,1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 340, 340, 575], [707, 707, 724, 724, 732], [733, 733, 745, 745, 788], [789, 789, 806, 806, 840], [841, 841, 873, 873, 914], [917, 917, 943, 943, 1074], [1077, 1077, 1096, 1096, 1138], [1141, 1141, 1198, 1198, 1590], [1592, 1592, 1645, 1645, 1953], [1955, 1955, 1984, 1984, 2037], [2039, 2039, 2062, 2062, 2088], [2090, 2090, 2115, 2115, 2153], [2155, 2155, 2177, 2177, 2346], [2415, 2415, 2472, 2472, 3147]], "test": "untested"}
{"id": "WlcXRS", "name": "Smooth Crystal Bunny", "author": "BrunoLevy", "description": "Mesh AABB raytracer with multiple refractions. This version has vertex attributes (here smooth normals).\nSlower than 'flat shading' version (https://www.shadertoy.com/view/3ltSzM) because of dependent texture reads.\nComing next: mesh bunny meets SDF.\n", "tags": ["raytracing", "aabb", "mesh"], "likes": 36, "viewed": 1768, "published": 3, "date": "1581153705", "time_retrieved": "2024-07-30T21:25:17.730804", "image_code": "// Default settings\n#if 1\nconst float refract_index = 1.3;  // 1.0: no refraction   1.3: water\nconst float extinction = 0.3;     // the higher, the darker (in function of thicness) \nconst float reflect_coeff = 0.75; // 0.0: no reflection   1.0: shiny reflections\nconst vec3  core_color = vec3(0,0.5,0.5); \n#endif \n\n// Show mesh thickness\n#if 0\nconst float refract_index = 1.0;  \nconst float extinction = 0.3;     \nconst float reflect_coeff = 0.0; \nconst vec3  core_color = vec3(0,0,0); \n#define WHITE_BACKGROUND\n#endif \n\n// Smooth normals or per-facet normals.\nconst bool smooth_shading = true;\n\n// Gets x,y,z, coordinates packed in a single 32 bits int (10 bits per coordinate)\nint get_compressed_point(in int v) {\n    return get_data(points_offset, v);\n}\n\n// Converts a single-int 10 bits per components packed point into a standard vec3.\nvec3 uncompress_point(in int xyz) {\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return bbox_min + (bbox_max - bbox_min) * vec3(XYZ) / 1023.0;\n}\n\n// Gets a point from a vertex index\nvec3 get_point(int v) {\n   return uncompress_point(get_compressed_point(v));\n}\n\n// Gets a normal from a vertex index\nvec3 get_normal(int v) {\n   int xyz = get_data(normals_offset, v);\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return vec3(-1) + vec3(XYZ) / 512.0;    \n}\n\n// Gets an AABB node from a node index.\n// An AABB node can be either an internal node (bbox + axis + number of subnodes \n//  in left subtree) or a leaf node (single triangle, with indives of its tree vertices)\nivec3 get_AABB_node(in int n) {\n    return ivec3(\n        get_data(AABB_offset,3*n),\n        get_data(AABB_offset,3*n+1),\n        get_data(AABB_offset,3*n+2)\n    );\n}\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Intersection {\n   float t;\n   vec3 P;\n   vec3 N;\n   int id; // index of latest intersected triangle, used to avoid finding the point\n           //  where you started from when computing multiple bounces.\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   I.id = -1; \n   return I;\n}\n\nRay reflect_ray(in Ray R, in Intersection I) {\n    return Ray(I.P, reflect(R.Dir, I.N));\n}\n\nRay refract_ray(in Ray R, in Intersection I, in float n1, in float n2) {\n    return Ray(I.P, refract(normalize(R.Dir), I.N, n1/n2));\n}\n\n// Branchless ray-triangle intersection that gives, for free, as by-products:\n//   Normal N\n//   Barycentric coordinates (1-u-v, u, v)\n// (slightly modified Moller-Trumbore algorithm)\n// References and explanations here:\n// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d/42752998#42752998\nbool intersect_triangle(\n    in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t, \n    out float u, out float v, out vec3 N\n) { \n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n         N = cross(E1,E2);\n   float det = -dot(R.Dir, N);\n   float invdet = 1.0/det;\n   vec3 AO  = R.Origin - A;\n   vec3 DAO = cross(AO, R.Dir);\n   u =  dot(E2,DAO) * invdet;\n   v = -dot(E1,DAO) * invdet;\n   t =  dot(AO,N)   * invdet;\n   return (abs(det) >= 1e-6 && t >= 0.0 && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0);\n}\n\n// Computes ray-triangle intersection from node index (i)\n// Returns true if there was an intersection.\n// Note: normal is not normalized\nbool triangle(in Ray R, in int i, inout Intersection I) {\n   ivec3 T = get_AABB_node(i);\n   vec3 A = get_point(T.x);\n   vec3 B = get_point(T.y);\n   vec3 C = get_point(T.z);    \n   float t,u,v;\n   vec3 N;\n   if(intersect_triangle(R, A,B,C, t, u, v, N) && t < I.t) {\n      I.t = t;\n      I.P = R.Origin + t*R.Dir;\n      I.id = i;\n      if(smooth_shading) {\n         vec3 N1 = get_normal(T.x);\n         vec3 N2 = get_normal(T.y);\n         vec3 N3 = get_normal(T.z);       \n         I.N = (1.0-u-v)*N1 + u*N2 + v*N3;\n      } else {\n         I.N = N;\n      }\n      return true;\n   }\n   return false;\n}\n \n// Good explanations here:\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax,\n  in float t \n) {  \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2);\n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);\n}\n\n// The stack used for recursive traversal of the AABB\n// Traversal context is just the bounds b,e of the [b,e[ \n// sequence of AABB nodes that correspond to a subtree.\n\nint stack_top = -1;\nint stack_b[10];\nint stack_e[10];\n\nbool stack_empty() {\n  return (stack_top < 0);\n}\n\nvoid stack_push(in int b, in int e) {\n  stack_top++;\n  stack_b[stack_top] = b;\n  stack_e[stack_top] = e;  \n}\n\nvoid stack_pop(out int b, out int e) {\n  b = stack_b[stack_top];\n  e = stack_e[stack_top];\n  --stack_top;\n}\n\n// AABB walkthrough\n// (C++ code to convert .obj file into AABB at the end\n//  of Buffer A, in a big comment)\n// Some inspiration taken from Terdiman's OpCode:\n//   http://www.codercorner.com/Opcode.htm\nbool mesh_AABB(in Ray R, inout Intersection I) {\n    int prev_id = I.id; // index of latest intersected triangle\n    bool result = false;\n    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);\n    stack_push(0, AABB_data_size/3);\n    while(!stack_empty()) {\n        int b,e;\n        stack_pop(b,e);\n        ivec3 node = get_AABB_node(b);\n        vec3 bbox_min = uncompress_point(node.x);\n        vec3 bbox_max = uncompress_point(node.y);\n        if(!segment_box_intersection(R.Origin, invDir, bbox_min, bbox_max, I.t)) {\n            continue;\n        }\n        b++;\n        if(node.z == -1) {   // Node is a leaf, intersect full sequence of triangles\n           for(int i=b; i<e; ++i) {\n              if(i == prev_id) { continue; } // skip latest triangle\n              bool t_isect = triangle(R, i, I);\n              result = result || t_isect;\n          }\n        } else { // Node is internal, decode splitting coord and nb in left child\n          int coord = node.z & 3;\n          int nb    = node.z >> 2; \n          int m     = b + nb;  \n          // Traverse nearest first (so that pruning can occur, thanks @iq for the tips)  \n          if(R.Dir[coord] < 0.0) {\n             stack_push(b,m);\n             stack_push(m,e);                  \n          } else {\n             stack_push(m,e);\n             stack_push(b,m); // positive -> process this child first                                    \n          } \n        }\n    }\n    if(result) { I.N = normalize(I.N); }\n    return result;\n}  \n\n// Modifies ray and intersection, returns total length of traversed matter.\nfloat multi_refract(inout Ray R, inout Intersection I) {\n    float result = 0.0;\n    for(int i=0; i<10; ++i) {\n        if(dot(R.Dir,I.N) > 0.0) { // Exiting matter\n            result += I.t;\n            vec3 old_dir = R.Dir;\n            I.N = -I.N;\n            R = refract_ray(R, I, refract_index, 1.0);\n            if(R.Dir == vec3(0)) { \n               //R.Dir = reflect(old_dir, I.N); // total reflection (what I should do I think) \n               R.Dir = old_dir; // I do that instead (not correct but looks better).\n            }\n        } else { // Entering matter\n            R = refract_ray(R, I, 1.0, refract_index);\n            R.Dir = normalize(R.Dir); // Needs to be unit, so that on exit, I.t is distance\n        }\n        I.t = FARAWAY;\n        if(!mesh_AABB(R, I)) { break; }  \n    }\n    return result;\n}\n\nvec3 sky(in Ray R) {\n#ifdef WHITE_BACKGROUND\n   return vec3(1);\n#else\n   return vec3(textureLod(iChannel1, R.Dir, 0.0));\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef DEBUG_DATA    \n   fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n   return; \n#endif    \n   float alpha = iTime;\n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(20.0*c, 20.0*s, 1.5),\n       vec3(0.0, 0.0, 0.0),\n       30.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n   mesh_AABB(R, I);\n \n   if(I.t == FARAWAY) {\n      fragColor.xyz = sky(R); \n    } else {        \n      float fresnel = 1.0 + dot(R.Dir,I.N) / length(R.Dir);\n      fresnel = clamp(fresnel, 0.0, 1.0); \n      fragColor.xyz = reflect_coeff * fresnel * sky(reflect_ray(R,I)); \n       \n      float l = multi_refract(R,I);\n      float d = exp(-l * extinction);\n      fragColor.xyz += mix(core_color, sky(R), d);\n    }\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//  A version of https://www.shadertoy.com/view/3ltSzM (Crystal Bunny)\n// with smooth normals.\n//  \n//  Sources of the \"mesh compiler\" as a big comment in the end of Buffer A\n// (used to generate the AABB and encode it as GLSL sources).\n\n// Mesh data description: bbox and number of AABB nodes, points and normals\nconst vec3 bbox_min = 10.0*vec3(-0.253035,-0.340497,-0.346693);\nconst vec3 bbox_max = 10.0*vec3(0.252403,0.340004,0.345965);\nconst int AABB_data_size = 6399;\nconst int points_data_size = 1024;\nconst int normals_data_size = 1024;\n\n \n// Reads a 32 bits integer encoded in a pixel of BufferA\n// (implementation of get_data(), do not call directly)\nint get_data_raw(in sampler2D channel, in int width, in int index) {\n   vec4 col = 255.0*vec4(texelFetch(channel, ivec2(index%width,index/width), 0));\n   return (int(col.r)      ) | \n          (int(col.g) << 8 ) |\n          (int(col.b) << 16) |\n          (int(col.a) << 24) ;\n}\n\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n//  offset: one of RESOLUTION_OFFSET, MESH_DATA_OFFSET\n//  index: the index of the data to be read\n#define get_data(offset, index) \\\n    get_data_raw(iChannel0, int(iChannelResolution[0].x), (offset)+(index))\n\n// In BufferA, data is organized in four sections\n// - resolution: stores width and height of window, to detect resize/fullscreen\n// - AABB: the mixed AABB-nodes + mesh triangles structure\n// - points: compressed vertices coordinates  (xyz quantized in 10 bits packed in an int)\n// - normals: compressed per-vertices normals (xyz quantized in 10 bits packed in an int)\nconst int resolution_offset=0;\nconst int resolution_data_size=2;\nconst int AABB_offset =resolution_offset+resolution_data_size;\nconst int points_offset = AABB_offset+AABB_data_size;\nconst int normals_offset = points_offset+points_data_size;", "buffer_a_code": "#pragma optimize(off) // this pragma is unfortunately ignored by most WebGL implementations\n\n// mesh data in big arrays encoded in huge switch statements, send to Buffer A on the\n// first frame.\n// Sounds stupid, but I did not find a better way of sending a large array to ShaderToy\n// (some WebGL implementations, like Angle, do not like big static arrays).\n// This data is generated by the C++ code included as comments at the end of this file.\n\nivec4 AABB_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;\n  ivec4 r;\n  switch(i) {\nR(0x0000,0x00000000,0x3fffffff,0x00001565,0x00000000)R(0x0001,0x3ff837ff,0x000009ca,0x00009c3b,0x20682b85)R(0x0002,0x000005b6,0x00024c5e,0x0e182b80,0x00000258)R(0x0003,0x0002585e,0x0db81207,0x0000014c,0x00744c5e)R(0x0004,0x0d38117d,0x000000ee,0x00744c8a,0x0708117d)R(0x0005,0xffffffff,0x000003d9,0x000003f5,0x000003f4)R(0x0006,0x000003b2,0x000003da,0x000003d9,0x000003da)R(0x0007,0x000003db,0x000003d9,0x000003b3,0x000003da)R(0x0008,0x000003b2,0x000003db,0x000003f5,0x000003d9)R(0x0009,0x000003f5,0x000003f8,0x000003f4,0x000003b5)R(0x000a,0x000003db,0x000003da,0x000003b4,0x000003da)R(0x000b,0x000003b3,0x000003db,0x000003f6,0x000003f5)R(0x000c,0x000003b5,0x000003da,0x000003b4,0x000003f7)R(0x000d,0x000003f8,0x000003f5,0x00000380,0x000003b3)R(0x000e,0x0000037f,0x000003f6,0x000003f7,0x000003f5)R(0x000f,0x000003b5,0x000003dc,0x000003db,0x00000380)\nR(0x0010,0x000003b4,0x000003b3,0x000003dc,0x000003f6)R(0x0011,0x000003db,0x000003e0,0x000003f8,0x000003f7)R(0x0012,0x00000383,0x000003b5,0x000003b4,0x000003b6)R(0x0013,0x000003dc,0x000003b5,0x00000383,0x000003b6)R(0x0014,0x000003b5,0x00000382,0x000003b4,0x00000380)R(0x0015,0x000003de,0x000003f7,0x000003f6,0x000003e0)R(0x0016,0x000003f7,0x000003df,0x000003dd,0x000003f6)R(0x0017,0x000003dc,0x00000383,0x000003b4,0x00000382)R(0x0018,0x000003df,0x000003f7,0x000003de,0x000003b7)R(0x0019,0x000003dc,0x000003b6,0x000003de,0x000003f6)R(0x001a,0x000003dd,0x000003b7,0x000003dd,0x000003dc)R(0x001b,0x00000384,0x000003b6,0x00000383,0x000003ba)R(0x001c,0x000003e0,0x000003df,0x00000346,0x00000383)R(0x001d,0x00000382,0x00000384,0x000003b7,0x000003b6)R(0x001e,0x00000346,0x00000384,0x00000383,0x000003b9)R(0x001f,0x000003df,0x000003de,0x000003ba,0x000003df)\nR(0x0020,0x000003b9,0x000003bf,0x000003de,0x000003dd)R(0x0021,0x000003b8,0x000003dd,0x000003b7,0x00000347)R(0x0022,0x00000384,0x00000346,0x000003b9,0x000003de)R(0x0023,0x000003bb,0x00000385,0x000003b7,0x00000384)R(0x0024,0x000003bb,0x000003de,0x000003bf,0x000003bf)R(0x0025,0x000003dd,0x000003b8,0x00000347,0x00000385)R(0x0026,0x00000384,0x00000387,0x000003ba,0x000003b9)R(0x0027,0x00000385,0x000003b8,0x000003b7,0x000003b9)R(0x0028,0x000003bb,0x00000388,0x00000353,0x00000385)R(0x0029,0x00000347,0x00000387,0x000003b9,0x00000388)R(0x002a,0x000003bb,0x000003bf,0x0000038d,0x00000390)R(0x002b,0x000003b8,0x00000385,0x00000391,0x000003bf)R(0x002c,0x000003b8,0x00000388,0x000003bb,0x0000038d)R(0x002d,0x00000353,0x00000390,0x00000385,0x0000038d)R(0x002e,0x000003bf,0x00000391,0x00000391,0x000003b8)R(0x002f,0x00000390,0x00000387,0x00000388,0x0000034b)\nR(0x0030,0x0000034c,0x00000387,0x0000034b,0x0645285e)R(0x0031,0x0d381161,0xffffffff,0x00000309,0x00000348)R(0x0032,0x000002fe,0x00000309,0x00000354,0x00000353)R(0x0033,0x00000309,0x00000353,0x00000348,0x000002fe)R(0x0034,0x00000348,0x000002fd,0x00000348,0x00000353)R(0x0035,0x00000347,0x000002fd,0x00000348,0x00000347)R(0x0036,0x000002fd,0x00000347,0x000002fc,0x00000297)R(0x0037,0x000002fd,0x000002fc,0x000002fc,0x00000347)R(0x0038,0x00000346,0x00000297,0x000002fc,0x000002fb)R(0x0039,0x000002fc,0x00000346,0x00000345,0x000002fc)R(0x003a,0x00000345,0x000002fb,0x00000346,0x00000382)R(0x003b,0x00000345,0x000002fb,0x00000345,0x00000344)R(0x003c,0x00000345,0x00000382,0x00000381,0x000002fb)R(0x003d,0x00000344,0x000002fa,0x00000345,0x00000381)R(0x003e,0x00000344,0x00000381,0x00000382,0x00000380)R(0x003f,0x000002fa,0x00000344,0x00000343,0x00000344)\nR(0x0040,0x00000381,0x00000343,0x00000342,0x00000381)R(0x0041,0x00000380,0x000002fa,0x00000343,0x000002f9)R(0x0042,0x00025930,0x0db7a207,0xffffffff,0x000003fb)R(0x0043,0x000003fc,0x000003fa,0x000003e6,0x000003fc)R(0x0044,0x000003fb,0x000003fa,0x000003fc,0x000003f9)R(0x0045,0x000003e2,0x000003fa,0x000003e1,0x000003e1)R(0x0046,0x000003fa,0x000003f9,0x000003e7,0x000003fc)R(0x0047,0x000003e6,0x000003f9,0x000003fc,0x000003f3)R(0x0048,0x000003bd,0x000003e2,0x000003e1,0x000003e1)R(0x0049,0x000003f9,0x000003f8,0x000003f3,0x000003fc)R(0x004a,0x000003e7,0x000003f8,0x000003f9,0x000003f4)R(0x004b,0x000003f4,0x000003f9,0x000003f3,0x000003c6)R(0x004c,0x000003e7,0x000003e6,0x000003d8,0x000003f4)R(0x004d,0x000003f3,0x000003d7,0x000003f3,0x000003e7)R(0x004e,0x000003d8,0x000003f3,0x000003d7,0x000003e1)R(0x004f,0x000003f8,0x000003e0,0x000003d9,0x000003f4)\nR(0x0050,0x000003d8,0x000003bd,0x000003e1,0x000003bc)R(0x0051,0x000003c7,0x000003e7,0x000003c6,0x000003d7)R(0x0052,0x000003e7,0x000003c7,0x000003bc,0x000003e1)R(0x0053,0x000003e0,0x0000038a,0x000003bd,0x000003bc)R(0x0054,0x000003b2,0x000003d9,0x000003d8,0x000003b1)R(0x0055,0x000003d8,0x000003d7,0x00000399,0x000003c7)R(0x0056,0x000003c6,0x000003b0,0x000003d7,0x000003c7)R(0x0057,0x000003b2,0x000003d8,0x000003b1,0x0000038a)R(0x0058,0x000003bc,0x00000389,0x000003bc,0x000003e0)R(0x0059,0x000003ba,0x000003b1,0x000003d7,0x000003b0)R(0x005a,0x0000034d,0x0000038a,0x00000389,0x00000389)R(0x005b,0x000003bc,0x000003ba,0x0000034d,0x00000389)R(0x005c,0x0000034c,0x00000389,0x000003ba,0x00000387)R(0x005d,0x0000034c,0x00000389,0x00000387,0x0000039a)R(0x005e,0x000003c7,0x00000399,0x000003b0,0x000003c7)R(0x005f,0x0000039a,0x0000037f,0x000003b2,0x000003b1)\nR(0x0060,0x0000037e,0x000003b1,0x000003b0,0x0000037f)R(0x0061,0x000003b3,0x000003b2,0x00000361,0x0000039a)R(0x0062,0x00000399,0x0000037e,0x000003b0,0x0000039a)R(0x0063,0x0000037f,0x000003b1,0x0000037e,0x00000362)R(0x0064,0x0000039a,0x00000361,0x0000037e,0x0000039a)R(0x0065,0x00000362,0x00000341,0x0000037f,0x0000037e)R(0x0066,0x00000342,0x00000380,0x0000037f,0x00000342)R(0x0067,0x0000037f,0x00000341,0x00000340,0x0000037e)R(0x0068,0x00000362,0x00000341,0x0000037e,0x00000340)R(0x0069,0x00000340,0x00000362,0x0000031c,0x000002f8)R(0x006a,0x00000342,0x00000341,0x00000343,0x00000381)R(0x006b,0x00000342,0x000002f8,0x00000343,0x00000342)R(0x006c,0x000002f7,0x00000341,0x00000340,0x000002f8)R(0x006d,0x00000341,0x000002f7,0x000002f6,0x00000340)R(0x006e,0x0000031c,0x000002f7,0x00000340,0x000002f6)R(0x006f,0x000002f6,0x0000031c,0x000002bd,0x000002f9)\nR(0x0070,0x00000343,0x000002f8,0x00000294,0x000002f8)R(0x0071,0x000002f7,0x000002c9,0x000002f6,0x000002bd)R(0x0072,0x00000294,0x000002f9,0x000002f8,0x00000293)R(0x0073,0x000002f7,0x000002f6,0x00024dcd,0x0e182b80)R(0x0074,0x000001b0,0x00024dcd,0x0d381af2,0x000000ee)R(0x0075,0x000255d6,0x03681af0,0xffffffff,0x000003c6)R(0x0076,0x000003e5,0x000003c5,0x000003c6,0x000003e6)R(0x0077,0x000003e5,0x00000399,0x000003c6,0x000003c5)R(0x0078,0x000003c5,0x000003e5,0x000003c4,0x00000399)R(0x0079,0x000003c5,0x00000398,0x00000398,0x000003c5)R(0x007a,0x000003c4,0x000003e5,0x000003e6,0x000003e4)R(0x007b,0x000003c4,0x000003e5,0x000003c3,0x000003c3)R(0x007c,0x000003e5,0x000003e4,0x00000398,0x000003c4)R(0x007d,0x00000397,0x000003e6,0x000003fb,0x000003e4)R(0x007e,0x00000396,0x000003c4,0x000003c3,0x00000397)R(0x007f,0x000003c4,0x00000396,0x000003c3,0x000003e4)\nR(0x0080,0x000003c2,0x000003e4,0x000003fb,0x000003e3)R(0x0081,0x00000396,0x000003c3,0x00000395,0x000003c2)R(0x0082,0x000003e4,0x000003e3,0x00000395,0x000003c3)R(0x0083,0x000003c2,0x0000035f,0x00000397,0x00000396)R(0x0084,0x000003e3,0x000003fb,0x000003fa,0x0000035d)R(0x0085,0x00000396,0x00000395,0x0000035f,0x00000396)R(0x0086,0x0000035d,0x00000395,0x000003c2,0x00000394)R(0x0087,0x000003c2,0x000003e3,0x000003c1,0x0000035e)R(0x0088,0x00000395,0x00000394,0x0000035e,0x00000394)R(0x0089,0x0000035c,0x0000035d,0x00000395,0x0000035e)R(0x008a,0x00000317,0x0000035e,0x0000035c,0x00000394)R(0x008b,0x000003c2,0x000003c1,0x0000035d,0x0000035e)R(0x008c,0x00000317,0x00000318,0x0000035f,0x0000035d)R(0x008d,0x00000318,0x0000035d,0x00000317,0x000003e3)R(0x008e,0x000003fa,0x000003e2,0x00000394,0x000003c1)R(0x008f,0x00000392,0x000003c1,0x000003e3,0x000003c0)\nR(0x0090,0x000003c0,0x000003e3,0x000003e2,0x00000392)R(0x0091,0x000003c1,0x0000038f,0x0000038f,0x000003c1)R(0x0092,0x000003c0,0x000003c0,0x000003e2,0x000003be)R(0x0093,0x0000038f,0x000003c0,0x0000038e,0x000003be)R(0x0094,0x000003e2,0x000003bd,0x0000038e,0x000003c0)R(0x0095,0x000003be,0x00000352,0x0000038f,0x0000038e)R(0x0096,0x0000038e,0x000003be,0x0000038b,0x0000038b)R(0x0097,0x000003be,0x000003bd,0x00000352,0x0000038e)R(0x0098,0x00000351,0x0000038b,0x000003bd,0x0000038a)R(0x0099,0x00000351,0x0000038e,0x0000038b,0x00000308)R(0x009a,0x00000352,0x00000351,0x0000034e,0x0000038b)R(0x009b,0x0000038a,0x00000351,0x0000038b,0x0000034e)R(0x009c,0x0000034e,0x0000038a,0x0000034d,0x00000308)R(0x009d,0x00000351,0x00000307,0x00000307,0x00000351)R(0x009e,0x0000034e,0x00000305,0x0000034e,0x0000034d)R(0x009f,0x00000307,0x0000034e,0x00000305,0x000002a7)\nR(0x00a0,0x00000308,0x00000307,0x000002ff,0x00000308)R(0x00a1,0x000002a7,0x02124dcd,0x0d34e2f2,0xffffffff)R(0x00a2,0x00000265,0x000002ca,0x00000264,0x00000361)R(0x00a3,0x00000399,0x00000398,0x00000264,0x000002ca)R(0x00a4,0x000002c9,0x00000360,0x00000398,0x00000397)R(0x00a5,0x00000361,0x00000398,0x00000360,0x000001fc)R(0x00a6,0x00000265,0x000001fb,0x000001fb,0x00000265)R(0x00a7,0x00000264,0x000001a0,0x000001fc,0x0000019f)R(0x00a8,0x00000360,0x00000397,0x0000035f,0x00000264)R(0x00a9,0x000002c9,0x000002bd,0x0000031b,0x00000361)R(0x00aa,0x00000360,0x0000019f,0x000001fc,0x000001fb)R(0x00ab,0x0000031b,0x00000362,0x00000361,0x000001fb)R(0x00ac,0x00000264,0x00000257,0x00000264,0x000002bd)R(0x00ad,0x00000257,0x0000031b,0x00000360,0x0000031a)R(0x00ae,0x0000031a,0x00000360,0x0000035f,0x0000031c)R(0x00af,0x00000362,0x0000031b,0x000002bd,0x0000031c)\nR(0x00b0,0x000002bc,0x000002bc,0x0000031c,0x0000031b)R(0x00b1,0x00000257,0x000002bd,0x000002bc,0x0000019f)R(0x00b2,0x000001fb,0x000001ed,0x000002bc,0x0000031b)R(0x00b3,0x000002bb,0x000001fb,0x00000257,0x000001ed)R(0x00b4,0x000002bb,0x0000031b,0x0000031a,0x000002b8)R(0x00b5,0x00000318,0x00000317,0x00000257,0x000002bc)R(0x00b6,0x00000256,0x0000031a,0x0000035f,0x00000319)R(0x00b7,0x00000319,0x0000035f,0x00000318,0x00000256)R(0x00b8,0x000002bc,0x000002bb,0x000001ed,0x00000257)R(0x00b9,0x00000256,0x000002bb,0x0000031a,0x00000319)R(0x00ba,0x0000019f,0x000001ed,0x00000193,0x000002b9)R(0x00bb,0x00000318,0x000002b8,0x000002b9,0x00000319)R(0x00bc,0x00000318,0x00000256,0x000002bb,0x000002ba)R(0x00bd,0x000002bb,0x00000319,0x000002ba,0x000001ed)R(0x00be,0x00000256,0x00000255,0x00000253,0x000002b9)R(0x00bf,0x000002b8,0x00000193,0x000001ed,0x000001ec)\nR(0x00c0,0x00000256,0x000002ba,0x00000255,0x000001ed)R(0x00c1,0x00000255,0x000001ec,0x000002ba,0x00000319)R(0x00c2,0x000002b9,0x00000254,0x000002ba,0x000002b9)R(0x00c3,0x00000255,0x000002ba,0x00000254,0x00000254)R(0x00c4,0x000002b9,0x00000253,0x000001ec,0x00000255)R(0x00c5,0x00000254,0x00139eb4,0x0e182b80,0x00000132)R(0x00c6,0x00139eb6,0x07082b80,0xffffffff,0x00000316)R(0x00c7,0x0000035c,0x0000035b,0x00000317,0x0000035c)R(0x00c8,0x00000316,0x0000035c,0x00000393,0x0000035b)R(0x00c9,0x0000035c,0x00000394,0x00000393,0x00000316)R(0x00ca,0x0000035b,0x00000315,0x000002b7,0x00000317)R(0x00cb,0x00000316,0x000002b7,0x00000316,0x00000315)R(0x00cc,0x0000035b,0x00000393,0x0000035a,0x00000393)R(0x00cd,0x00000394,0x00000392,0x00000315,0x0000035b)R(0x00ce,0x0000035a,0x000002b8,0x00000317,0x000002b7)R(0x00cf,0x0000035a,0x00000393,0x00000359,0x00000359)\nR(0x00d0,0x00000393,0x00000392,0x000002b7,0x00000315)R(0x00d1,0x000002b6,0x00000315,0x0000035a,0x00000314)R(0x00d2,0x000002b6,0x00000315,0x00000314,0x00000252)R(0x00d3,0x000002b8,0x000002b7,0x00000252,0x000002b7)R(0x00d4,0x000002b6,0x00000313,0x0000035a,0x00000359)R(0x00d5,0x00000314,0x0000035a,0x00000313,0x00000359)R(0x00d6,0x00000392,0x00000358,0x000002b6,0x00000314)R(0x00d7,0x000002b5,0x00000253,0x000002b8,0x00000252)R(0x00d8,0x00000252,0x000002b6,0x00000251,0x00000251)R(0x00d9,0x000002b6,0x000002b5,0x00000358,0x00000392)R(0x00da,0x0000038f,0x00000313,0x00000359,0x00000312)R(0x00db,0x000002b4,0x00000314,0x00000313,0x000002b5)R(0x00dc,0x00000314,0x000002b4,0x00000312,0x00000359)R(0x00dd,0x00000358,0x000001ea,0x00000253,0x00000252)R(0x00de,0x000001ea,0x00000252,0x00000251,0x00000251)R(0x00df,0x000002b5,0x0000024f,0x0000024f,0x000002b5)\nR(0x00e0,0x000002b4,0x000002b4,0x00000313,0x000002b3)R(0x00e1,0x000002b3,0x00000313,0x00000312,0x000001ea)R(0x00e2,0x00000251,0x000001e9,0x00000358,0x0000038f)R(0x00e3,0x00000352,0x00000312,0x00000358,0x00000311)R(0x00e4,0x000001e9,0x00000251,0x0000024f,0x0000024f)R(0x00e5,0x000002b4,0x0000024e,0x0000024e,0x000002b4)R(0x00e6,0x000002b3,0x000002b3,0x00000312,0x00000311)R(0x00e7,0x00000311,0x00000358,0x00000352,0x000001e9)R(0x00e8,0x0000024f,0x000001e7,0x000001e7,0x0000024f)R(0x00e9,0x0000024e,0x0000024e,0x000002b3,0x0000024d)R(0x00ea,0x000002b3,0x00000311,0x000002b2,0x00000190)R(0x00eb,0x000001e9,0x000001e7,0x000001e7,0x0000024e)R(0x00ec,0x0000024d,0x00000311,0x00000352,0x00000310)R(0x00ed,0x0000024d,0x000002b3,0x000002b2,0x000002b2)R(0x00ee,0x00000311,0x00000310,0x000001e7,0x0000024d)R(0x00ef,0x000001e8,0x00000190,0x000001e7,0x0000018f)\nR(0x00f0,0x00000310,0x00000352,0x00000308,0x0000024d)R(0x00f1,0x000002b2,0x00000250,0x000001e7,0x000001e8)R(0x00f2,0x0000018f,0x0000024d,0x00000250,0x000001e8)R(0x00f3,0x000002b2,0x00000310,0x000002b0,0x00000250)R(0x00f4,0x000002b2,0x000002b0,0x0000018f,0x000001e8)R(0x00f5,0x000001e6,0x000001e8,0x00000250,0x0000024c)R(0x00f6,0x000001e8,0x0000024c,0x000001e6,0x000002ff)R(0x00f7,0x00000310,0x00000308,0x000002b0,0x00000310)R(0x00f8,0x000002af,0x000002b0,0x000002b1,0x00000250)R(0x00f9,0x00000250,0x000002b1,0x0000024c,0x000002af)R(0x00fa,0x00000310,0x000002ff,0x0000018f,0x000001e6)R(0x00fb,0x0000018e,0x000001e6,0x0000024c,0x000001e5)R(0x00fc,0x0000024c,0x000002b1,0x0000024b,0x0000018e)R(0x00fd,0x000001e6,0x000001e5,0x0000024a,0x000002b1)R(0x00fe,0x000002b0,0x00000249,0x000002b0,0x000002af)R(0x00ff,0x05e3cab4,0x0e17df39,0xffffffff,0x00000151)\nR(0x0100,0x0000019f,0x00000193,0x00000151,0x00000193)R(0x0101,0x00000146,0x00000193,0x000001ec,0x00000192)R(0x0102,0x00000146,0x00000193,0x00000192,0x000001ec)R(0x0103,0x00000254,0x000001eb,0x000001eb,0x00000254)R(0x0104,0x00000253,0x00000192,0x000001ec,0x000001eb)R(0x0105,0x000001eb,0x00000253,0x000001ea,0x00000146)R(0x0106,0x00000192,0x00000145,0x00000192,0x000001eb)R(0x0107,0x00000191,0x00000191,0x000001eb,0x000001ea)R(0x0108,0x00000191,0x000001ea,0x000001e9,0x00000145)R(0x0109,0x00000192,0x00000191,0x00000191,0x000001e9)R(0x010a,0x00000190,0x00000145,0x00000191,0x00000144)R(0x010b,0x00000144,0x00000191,0x00000190,0x00000107)R(0x010c,0x00000145,0x00000144,0x00000144,0x00000190)R(0x010d,0x00000143,0x00000107,0x00000144,0x00000106)R(0x010e,0x00000143,0x00000190,0x0000018f,0x00000106)R(0x010f,0x00000144,0x00000143,0x00000143,0x0000018f)\nR(0x0110,0x00000142,0x00000106,0x00000143,0x00000105)R(0x0111,0x00000142,0x0000018f,0x0000018e,0x00000105)R(0x0112,0x00000143,0x00000142,0x000000d1,0x00000106)R(0x0113,0x00000105,0x000000d1,0x00000105,0x00000104)R(0x0114,0x0a709c3b,0x20681b85,0x00000211,0x0b009d26)R(0x0115,0x1fc49385,0x000000e8,0x0b109d26,0x1f74927a)R(0x0116,0xffffffff,0x000002be,0x000002ce,0x0000026a)R(0x0117,0x0000026a,0x000002cd,0x00000269,0x0000026a)R(0x0118,0x000002ce,0x000002cd,0x0000028d,0x000002ce)R(0x0119,0x000002be,0x0000028c,0x000002be,0x00000259)R(0x011a,0x00000269,0x000002cd,0x00000268,0x000002ce)R(0x011b,0x000002f3,0x000002cd,0x0000028d,0x000002be)R(0x011c,0x0000028c,0x0000028e,0x000002ce,0x0000028d)R(0x011d,0x0000028e,0x000002f3,0x000002ce,0x000002cd)R(0x011e,0x000002f3,0x000002cc,0x00000268,0x000002cd)R(0x011f,0x000002cc,0x0000021d,0x0000028d,0x0000028c)\nR(0x0120,0x0000021e,0x0000028e,0x0000028d,0x0000028f)R(0x0121,0x000002f3,0x0000028e,0x000002f3,0x000002f4)R(0x0122,0x000002cc,0x0000021e,0x0000028d,0x0000021d)R(0x0123,0x0000028f,0x000002f4,0x000002f3,0x00000268)R(0x0124,0x000002cc,0x000002cb,0x0000021f,0x0000028f)R(0x0125,0x0000028e,0x0000021f,0x0000028e,0x0000021e)R(0x0126,0x000002f4,0x000002f5,0x000002cc,0x000001b9)R(0x0127,0x0000021e,0x0000021d,0x00000291,0x000002f4)R(0x0128,0x0000028f,0x000002cb,0x000002cc,0x000002ca)R(0x0129,0x00000221,0x0000028f,0x0000021f,0x000001ba)R(0x012a,0x0000021f,0x0000021e,0x000002cc,0x000002f5)R(0x012b,0x000002ca,0x00000291,0x000002f5,0x000002f4)R(0x012c,0x00000221,0x00000291,0x0000028f,0x000001ba)R(0x012d,0x0000021e,0x000001b9,0x00000265,0x000002cb)R(0x012e,0x000002ca,0x000001bc,0x00000221,0x0000021f)R(0x012f,0x000001bc,0x0000021f,0x000001ba,0x00000292)\nR(0x0130,0x000002f5,0x00000291,0x00000222,0x00000291)R(0x0131,0x00000221,0x00000165,0x000001ba,0x000001b9)R(0x0132,0x000002ca,0x000002f5,0x000002c9,0x00000222)R(0x0133,0x00000292,0x00000291,0x000001bd,0x00000221)R(0x0134,0x000001bc,0x000002c9,0x000002f5,0x00000292)R(0x0135,0x000001bd,0x00000222,0x00000221,0x00000167)R(0x0136,0x000001bc,0x000001ba,0x00000167,0x000001ba)R(0x0137,0x00000165,0x00000168,0x000001bd,0x000001bc)R(0x0138,0x00000223,0x00000292,0x00000222,0x00000168)R(0x0139,0x000001bc,0x00000167,0x00000293,0x000002c9)R(0x013a,0x00000292,0x000001be,0x00000222,0x000001bd)R(0x013b,0x00000120,0x00000167,0x00000165,0x00000223)R(0x013c,0x00000293,0x00000292,0x00000293,0x000002f6)R(0x013d,0x000002c9,0x000001be,0x00000223,0x00000222)R(0x013e,0x00000168,0x000001be,0x000001bd,0x00000121)R(0x013f,0x00000168,0x00000167,0x00000121,0x00000167)\nR(0x0140,0x00000120,0x00000223,0x00000294,0x00000293)R(0x0141,0x0b009e3d,0x1fc48b85,0xffffffff,0x00000266)R(0x0142,0x000002cb,0x00000265,0x00000258,0x000002be)R(0x0143,0x0000026a,0x00000268,0x000002cb,0x00000267)R(0x0144,0x00000259,0x000002be,0x00000258,0x00000267)R(0x0145,0x000002cb,0x00000266,0x000001fc,0x00000266)R(0x0146,0x00000265,0x000001ff,0x00000269,0x00000268)R(0x0147,0x00000200,0x0000026a,0x00000269,0x000001ff)R(0x0148,0x00000268,0x00000267,0x00000258,0x0000026a)R(0x0149,0x00000200,0x000001ef,0x00000259,0x00000258)R(0x014a,0x00000200,0x00000269,0x000001ff,0x000001fd)R(0x014b,0x00000267,0x00000266,0x000001fd,0x00000266)R(0x014c,0x000001fc,0x000001ef,0x00000258,0x000001ee)R(0x014d,0x000001ee,0x00000258,0x00000200,0x000001ff)R(0x014e,0x00000267,0x000001fe,0x000001fe,0x00000267)R(0x014f,0x000001fd,0x000001a0,0x000001fd,0x000001fc)\nR(0x0150,0x000001a3,0x00000200,0x000001ff,0x00000195)R(0x0151,0x000001ef,0x000001ee,0x00000195,0x000001f0)R(0x0152,0x000001ef,0x000001ee,0x00000200,0x000001a4)R(0x0153,0x000001a3,0x000001ff,0x000001fe,0x00000151)R(0x0154,0x000001a0,0x0000019f,0x000001a4,0x00000200)R(0x0155,0x000001a3,0x000001a1,0x000001fe,0x000001fd)R(0x0156,0x000001a1,0x000001fd,0x000001a0,0x00000195)R(0x0157,0x000001ee,0x00000194,0x00000194,0x000001ee)R(0x0158,0x000001a4,0x000001a3,0x000001fe,0x000001a2)R(0x0159,0x00000152,0x000001a0,0x00000151,0x000001a2)R(0x015a,0x000001fe,0x000001a1,0x00000155,0x000001a4)R(0x015b,0x000001a3,0x00000148,0x00000195,0x00000194)R(0x015c,0x00000152,0x000001a1,0x000001a0,0x00000148)R(0x015d,0x00000196,0x00000195,0x00000194,0x000001a4)R(0x015e,0x00000155,0x00000155,0x000001a3,0x000001a2)R(0x015f,0x00000110,0x00000152,0x00000151,0x00000148)\nR(0x0160,0x00000194,0x00000147,0x00000153,0x000001a2)R(0x0161,0x000001a1,0x00000149,0x00000196,0x00000148)R(0x0162,0x00000147,0x00000194,0x00000155,0x00000153)R(0x0163,0x000001a1,0x00000152,0x00000155,0x000001a2)R(0x0164,0x00000154,0x0000010a,0x00000149,0x00000148)R(0x0165,0x0000010a,0x00000148,0x00000147,0x00000154)R(0x0166,0x000001a2,0x00000153,0x00000111,0x00000152)R(0x0167,0x00000110,0x00000111,0x00000153,0x00000152)R(0x0168,0x00000147,0x00000155,0x00000113,0x00000113)R(0x0169,0x00000155,0x00000154,0x0000010a,0x00000147)R(0x016a,0x00000109,0x0000010a,0x0000014a,0x00000149)R(0x016b,0x000000d5,0x0000010b,0x0000010a,0x000000a9)R(0x016c,0x000000d5,0x000000d4,0x00000109,0x00000147)R(0x016d,0x00000113,0x0000014a,0x00000197,0x00000149)R(0x016e,0x000000d5,0x0000010a,0x00000109,0x00000112)R(0x016f,0x00000154,0x00000153,0x0000010b,0x0000014a)\nR(0x0170,0x0000010a,0x00000112,0x00000153,0x00000111)R(0x0171,0x000000d5,0x00000109,0x000000d4,0x00000113)R(0x0172,0x00000154,0x00000112,0x00000109,0x00000113)R(0x0173,0x000000db,0x000000d4,0x00000109,0x000000db)R(0x0174,0x000000da,0x00000112,0x00000111,0x000000db)R(0x0175,0x00000113,0x00000112,0x000000d4,0x000000db)R(0x0176,0x000000ad,0x000000db,0x00000112,0x000000da)R(0x0177,0x000000ad,0x000000db,0x000000da,0x0a73c03b)R(0x0178,0x20681b85,0x00000130,0x0a73c03b,0x20681989)R(0x0179,0x000000b8,0x0a75403b,0x20681902,0xffffffff)R(0x017a,0x000002a8,0x00000309,0x000002fe,0x000002a9)R(0x017b,0x00000309,0x000002a8,0x00000297,0x000002fb)R(0x017c,0x00000296,0x00000298,0x000002fe,0x000002fd)R(0x017d,0x00000298,0x000002fd,0x00000297,0x000002a8)R(0x017e,0x000002fe,0x00000299,0x00000227,0x00000297)R(0x017f,0x00000296,0x00000299,0x000002fe,0x00000298)\nR(0x0180,0x00000227,0x00000298,0x00000297,0x00000227)R(0x0181,0x00000296,0x00000226,0x00000290,0x000002a8)R(0x0182,0x00000299,0x00000228,0x00000298,0x00000227)R(0x0183,0x00000228,0x00000299,0x00000298,0x00000240)R(0x0184,0x000002a8,0x00000290,0x000001c1,0x00000227)R(0x0185,0x00000226,0x000001c1,0x00000228,0x00000227)R(0x0186,0x00000229,0x00000299,0x00000228,0x00000290)R(0x0187,0x00000299,0x00000229,0x00000240,0x00000290)R(0x0188,0x0000022a,0x000001c1,0x00000226,0x000001c0)R(0x0189,0x000001c2,0x00000228,0x000001c1,0x000001c2)R(0x018a,0x00000229,0x00000228,0x00000220,0x00000290)R(0x018b,0x00000229,0x0000022a,0x00000290,0x00000220)R(0x018c,0x0000016b,0x000001c1,0x000001c0,0x0000016b)R(0x018d,0x000001c2,0x000001c1,0x000001c3,0x00000229)R(0x018e,0x000001c2,0x00000220,0x00000229,0x000001c3)R(0x018f,0x0000016b,0x000001c0,0x0000016a,0x0000016c)\nR(0x0190,0x000001c2,0x0000016b,0x0000016c,0x000001c3)R(0x0191,0x000001c2,0x000001bb,0x00000220,0x000001c3)R(0x0192,0x000001c4,0x00000220,0x000001bb,0x00000123)R(0x0193,0x0000016b,0x0000016a,0x00000123,0x0000016c)R(0x0194,0x0000016b,0x0000016d,0x000001c3,0x0000016c)R(0x0195,0x000001bb,0x000001c3,0x0000016d,0x00000124)R(0x0196,0x0000016d,0x0000016c,0x00000124,0x0000016c)R(0x0197,0x00000123,0x00000166,0x000001bb,0x0000016d)R(0x0198,0x00000166,0x0000016d,0x00000124,0x000000e7)R(0x0199,0x00000124,0x00000123,0x0000011f,0x00000166)R(0x019a,0x00000124,0x0000011f,0x00000124,0x000000e7)R(0x019b,0x000000e4,0x0000011f,0x000000e7,0x0aa3c0e3)R(0x019c,0x20066589,0xffffffff,0x00000294,0x000002f7)R(0x019d,0x00000293,0x00000296,0x000002fb,0x000002fa)R(0x019e,0x00000295,0x000002fa,0x000002f9,0x00000295)R(0x019f,0x000002f9,0x00000294,0x00000296,0x000002fa)\nR(0x01a0,0x00000295,0x00000224,0x00000295,0x00000294)R(0x01a1,0x00000224,0x00000294,0x00000223,0x00000225)R(0x01a2,0x00000296,0x00000295,0x00000225,0x00000295)R(0x01a3,0x00000224,0x00000226,0x00000296,0x00000225)R(0x01a4,0x000001be,0x00000224,0x00000223,0x000001bf)R(0x01a5,0x00000225,0x00000224,0x000001c0,0x00000226)R(0x01a6,0x00000225,0x000001bf,0x00000224,0x000001be)R(0x01a7,0x000001c0,0x00000225,0x000001bf,0x00000168)R(0x01a8,0x000001bf,0x000001be,0x0000016a,0x000001c0)R(0x01a9,0x000001bf,0x0000016a,0x000001bf,0x00000169)R(0x01aa,0x00000169,0x000001bf,0x00000168,0x00000122)R(0x01ab,0x0000016a,0x00000169,0x00000121,0x00000169)R(0x01ac,0x00000168,0x00000123,0x0000016a,0x00000122)R(0x01ad,0x00000122,0x00000169,0x00000121,0x000000e7)R(0x01ae,0x00000123,0x00000122,0x000000e5,0x00000122)R(0x01af,0x00000121,0x000000e7,0x00000122,0x000000e6)\nR(0x01b0,0x000000e6,0x00000122,0x000000e5,0x000000e5)R(0x01b1,0x00000121,0x00000120,0x0bd3db03,0x2007db85)R(0x01b2,0xffffffff,0x000000a9,0x000000d4,0x000000a8)R(0x01b3,0x000000da,0x00000111,0x000000d9,0x000000a8)R(0x01b4,0x000000d4,0x000000ad,0x000000d9,0x00000111)R(0x01b5,0x00000110,0x00000110,0x00000151,0x00000146)R(0x01b6,0x000000ad,0x000000da,0x000000ac,0x00000083)R(0x01b7,0x000000a9,0x000000a8,0x000000ac,0x000000da)R(0x01b8,0x000000d9,0x000000d9,0x00000110,0x00000108)R(0x01b9,0x00000110,0x00000146,0x00000108,0x000000a8)R(0x01ba,0x000000ad,0x00000085,0x00000085,0x000000ad)R(0x01bb,0x000000ac,0x00000083,0x000000a8,0x00000082)R(0x01bc,0x00000082,0x000000a8,0x00000085,0x000000ac)R(0x01bd,0x000000d9,0x000000d3,0x00000108,0x00000146)R(0x01be,0x00000145,0x000000d9,0x00000108,0x000000d3)R(0x01bf,0x00000085,0x000000ac,0x000000a7,0x0000005f)\nR(0x01c0,0x00000083,0x00000082,0x000000ac,0x000000d3)R(0x01c1,0x000000a7,0x00000082,0x00000085,0x00000061)R(0x01c2,0x00000108,0x00000145,0x00000107,0x000000d3)R(0x01c3,0x00000108,0x00000107,0x00000085,0x000000a7)R(0x01c4,0x00000081,0x0000005f,0x00000082,0x00000061)R(0x01c5,0x00000061,0x00000085,0x00000081,0x000000a7)R(0x01c6,0x000000d3,0x000000a6,0x00000081,0x000000a7)R(0x01c7,0x000000a6,0x000000d3,0x00000107,0x000000d2)R(0x01c8,0x0000005f,0x00000061,0x00000043,0x000000a6)R(0x01c9,0x000000d3,0x000000d2,0x00000061,0x00000081)R(0x01ca,0x0000005e,0x00000042,0x0000005f,0x00000043)R(0x01cb,0x000000d2,0x00000107,0x00000106,0x00000043)R(0x01cc,0x00000061,0x0000005e,0x00000081,0x000000a6)R(0x01cd,0x00000080,0x0000005e,0x00000081,0x00000080)R(0x01ce,0x000000a6,0x000000d2,0x000000a5,0x00000080)R(0x01cf,0x000000a6,0x000000a5,0x000000d2,0x00000106)\nR(0x01d0,0x000000d1,0x00000042,0x00000043,0x0000002b)R(0x01d1,0x000000a5,0x000000d2,0x000000d1,0x00000043)R(0x01d2,0x0000005e,0x00000041,0x0000005e,0x00000080)R(0x01d3,0x0000005d,0x00000080,0x000000a5,0x0000007f)R(0x01d4,0x000000a5,0x000000d1,0x000000d0,0x0000002b)R(0x01d5,0x00000043,0x00000041,0x0000005d,0x00000080)R(0x01d6,0x0000007f,0x00000041,0x0000005e,0x0000005d)R(0x01d7,0x1d100000,0x3ff837ff,0x0000058e,0x1d102cc2)R(0x01d8,0x313837ff,0x00000278,0x1d105cc2,0x31383672)R(0x01d9,0x0000011a,0x1d105cc6,0x2888366c,0x00000081)R(0x01da,0x1e205d36,0x2884c66c,0xffffffff,0x000002bf)R(0x01db,0x000002f2,0x0000028a,0x0000028a,0x000002f2)R(0x01dc,0x00000289,0x0000028b,0x000002bf,0x0000028a)R(0x01dd,0x00000259,0x000002bf,0x0000028c,0x0000021b)R(0x01de,0x0000028a,0x00000289,0x0000028c,0x000002bf)R(0x01df,0x0000028b,0x0000021c,0x0000028b,0x0000028a)\nR(0x01e0,0x0000021c,0x0000028a,0x0000021b,0x0000021d)R(0x01e1,0x0000028c,0x0000028b,0x0000021d,0x0000028b)R(0x01e2,0x0000021c,0x000001b7,0x0000021c,0x0000021b)R(0x01e3,0x000001b8,0x0000021d,0x0000021c,0x000001b8)R(0x01e4,0x0000021c,0x000001b7,0x000001b9,0x0000021d)R(0x01e5,0x000001b8,0x00000163,0x000001b8,0x000001b7)R(0x01e6,0x00000164,0x000001b9,0x000001b8,0x00000163)R(0x01e7,0x000001b7,0x00000162,0x00000164,0x000001b8)R(0x01e8,0x00000163,0x00000165,0x000001b9,0x00000164)R(0x01e9,0x0000011c,0x00000163,0x00000162,0x0000011d)R(0x01ea,0x00000164,0x00000163,0x0000011e,0x00000165)R(0x01eb,0x00000164,0x0000011d,0x00000163,0x0000011c)R(0x01ec,0x0000011e,0x00000164,0x0000011d,0x00000120)R(0x01ed,0x00000165,0x0000011e,0x000000e1,0x0000011d)R(0x01ee,0x0000011c,0x000000e2,0x0000011e,0x0000011d)R(0x01ef,0x000000e5,0x00000120,0x0000011e,0x000000e2)\nR(0x01f0,0x0000011d,0x000000e1,0x000000e3,0x0000011e)R(0x01f1,0x000000e2,0x000000e5,0x0000011e,0x000000e3)R(0x01f2,0x1d144cc6,0x2798366c,0xffffffff,0x000000e8)R(0x01f3,0x0000011f,0x000000e4,0x000000b6,0x000000e7)R(0x01f4,0x000000e6,0x000000e4,0x000000e7,0x000000b6)R(0x01f5,0x000000b5,0x000000e6,0x000000e5,0x000000b6)R(0x01f6,0x000000e6,0x000000b5,0x000000b4,0x000000e4)R(0x01f7,0x000000b6,0x000000b5,0x000000e5,0x000000e3)R(0x01f8,0x000000b7,0x000000e4,0x000000b4,0x0000008c)R(0x01f9,0x000000b6,0x000000b5,0x000000b4,0x000000b6)R(0x01fa,0x0000008c,0x000000b5,0x000000e3,0x000000b3)R(0x01fb,0x0000008c,0x000000b5,0x000000b3,0x0000008b)R(0x01fc,0x000000b4,0x0000008c,0x000000b3,0x000000e3)R(0x01fd,0x000000e2,0x0000008c,0x000000b3,0x0000008a)R(0x01fe,0x00000068,0x0000008c,0x0000008a,0x0000008b)R(0x01ff,0x0000008c,0x00000068,0x0000008a,0x000000b3)\nR(0x0200,0x000000b2,0x000000b3,0x000000e2,0x000000b2)R(0x0201,0x00000068,0x0000008a,0x00000066,0x00000066)R(0x0202,0x0000008a,0x00000089,0x0000008a,0x000000b2)R(0x0203,0x00000089,0x00000046,0x00000065,0x00000064)R(0x0204,0x00000046,0x00000066,0x00000065,0x000000b2)R(0x0205,0x000000e2,0x000000e1,0x00000067,0x0000008b)R(0x0206,0x00000068,0x00000066,0x00000089,0x00000065)R(0x0207,0x00000048,0x00000068,0x00000066,0x00000048)R(0x0208,0x00000066,0x00000046,0x00000065,0x00000088)R(0x0209,0x00000064,0x00000065,0x00000089,0x00000088)R(0x020a,0x00000067,0x00000068,0x00000048,0x00000089)R(0x020b,0x000000b2,0x000000b1,0x0000002f,0x00000048)R(0x020c,0x00000046,0x000000b2,0x000000e1,0x000000b1)R(0x020d,0x00000089,0x000000b1,0x00000088,0x25c0a0c2)R(0x020e,0x31356672,0x000000a9,0x25c0a0c2,0x3132b272)R(0x020f,0xffffffff,0x000002e4,0x00000338,0x00000334)\nR(0x0210,0x00000335,0x00000338,0x000002e4,0x000002e2)R(0x0211,0x00000334,0x00000333,0x000002e4,0x00000334)R(0x0212,0x000002e2,0x000002e2,0x00000333,0x000002e1)R(0x0213,0x000002e3,0x00000335,0x000002e4,0x000002e3)R(0x0214,0x00000336,0x00000335,0x0000027f,0x000002e4)R(0x0215,0x000002e2,0x000002e3,0x000002e4,0x0000027f)R(0x0216,0x0000027e,0x000002e2,0x000002e1,0x0000027f)R(0x0217,0x000002e2,0x0000027e,0x0000027e,0x000002e1)R(0x0218,0x0000027d,0x0000027f,0x000002e5,0x000002e3)R(0x0219,0x000002e5,0x00000337,0x000002e3,0x00000210)R(0x021a,0x0000027f,0x0000027e,0x0000020f,0x0000027e)R(0x021b,0x0000027d,0x00000280,0x000002e5,0x0000027f)R(0x021c,0x00000210,0x00000280,0x0000027f,0x00000210)R(0x021d,0x0000027e,0x0000020f,0x000002e6,0x00000337)R(0x021e,0x000002e5,0x0000020f,0x0000027d,0x0000020e)R(0x021f,0x000001b0,0x00000210,0x0000020f,0x00000281)\nR(0x0220,0x000002e5,0x00000280,0x00000211,0x00000280)R(0x0221,0x00000210,0x000001b0,0x00000211,0x00000210)R(0x0222,0x00000281,0x000002e6,0x000002e5,0x00000162)R(0x0223,0x000001b7,0x000001b6,0x00000162,0x000001b6)R(0x0224,0x000001b0,0x000001b6,0x00000211,0x000001b0)R(0x0225,0x00000211,0x00000281,0x00000280,0x000001b7)R(0x0226,0x0000021b,0x000001b6,0x000001b6,0x0000021a)R(0x0227,0x00000211,0x0000021a,0x00000281,0x00000211)R(0x0228,0x000001b6,0x0000021b,0x0000021a,0x00000281)R(0x0229,0x000002e7,0x000002e6,0x0000021a,0x00000288)R(0x022a,0x00000281,0x0000021b,0x00000289,0x0000021a)R(0x022b,0x00000288,0x000002e7,0x00000281,0x0000021a)R(0x022c,0x00000289,0x00000288,0x00000288,0x000002ee)R(0x022d,0x000002e7,0x00000289,0x000002f0,0x00000288)R(0x022e,0x273269ad,0x31356669,0xffffffff,0x000001b0)R(0x022f,0x0000020f,0x000001af,0x000001af,0x0000020f)\nR(0x0230,0x0000020e,0x0000020e,0x00000219,0x000001b5)R(0x0231,0x00000162,0x000001b0,0x0000015e,0x000001af)R(0x0232,0x0000020e,0x000001b5,0x0000015e,0x000001b0)R(0x0233,0x000001af,0x000001af,0x000001b5,0x00000161)R(0x0234,0x0000011c,0x00000162,0x0000015e,0x0000015e)R(0x0235,0x000001af,0x00000161,0x00000161,0x000001b5)R(0x0236,0x000001b4,0x00000161,0x000001b4,0x000001b3)R(0x0237,0x0000015e,0x00000161,0x0000011b,0x0000011c)R(0x0238,0x0000015e,0x00000119,0x00000161,0x000001b3)R(0x0239,0x00000160,0x00000119,0x0000015e,0x0000011b)R(0x023a,0x0000011b,0x00000161,0x00000160,0x000000e1)R(0x023b,0x0000011c,0x00000119,0x00000160,0x000001b3)R(0x023c,0x000001b2,0x0000011b,0x00000160,0x0000011a)R(0x023d,0x00000119,0x0000011b,0x000000e0,0x000000e0)R(0x023e,0x0000011b,0x0000011a,0x000000e1,0x00000119)R(0x023f,0x000000df,0x0000011a,0x00000160,0x0000015f)\nR(0x0240,0x000000df,0x00000119,0x000000e0,0x00000160)R(0x0241,0x000001b2,0x0000015f,0x000000e0,0x0000011a)R(0x0242,0x00000117,0x000000e0,0x00000117,0x000000de)R(0x0243,0x0000011a,0x0000015b,0x00000117,0x00000117)R(0x0244,0x0000015a,0x00000118,0x0000011a,0x0000015f)R(0x0245,0x0000015b,0x000000b1,0x000000e1,0x000000df)R(0x0246,0x000000df,0x000000e0,0x000000b0,0x000000b0)R(0x0247,0x000000e0,0x000000de,0x00000117,0x0000015b)R(0x0248,0x0000015a,0x0000015a,0x0000015d,0x00000118)R(0x0249,0x0000015f,0x000001b2,0x000001b1,0x000000b1)R(0x024a,0x000000df,0x000000b0,0x0000015f,0x000001aa)R(0x024b,0x0000015b,0x0000015b,0x000001a9,0x0000015a)R(0x024c,0x0000015a,0x000001a9,0x0000015d,0x0000015f)R(0x024d,0x000001b1,0x000001aa,0x00000088,0x000000b1)R(0x024e,0x000000b0,0x0000015b,0x000001aa,0x000001a9)R(0x024f,0x1e002e30,0x3107f3ff,0x00000184,0x1e002e30)\nR(0x0250,0x3107f35a,0x000000a5,0x1e002e30,0x3101ab4f)R(0x0251,0xffffffff,0x000001ef,0x0000025a,0x00000259)R(0x0252,0x00000196,0x000001f0,0x00000195,0x000001f0)R(0x0253,0x0000025a,0x000001ef,0x0000025a,0x000002bf)R(0x0254,0x00000259,0x00000196,0x000001f2,0x000001f0)R(0x0255,0x000001f0,0x0000025b,0x0000025a,0x0000025a)R(0x0256,0x000002c0,0x000002bf,0x000001f2,0x0000025b)R(0x0257,0x000001f0,0x0000025b,0x000002c0,0x0000025a)R(0x0258,0x000002c0,0x000002f2,0x000002bf,0x000001f2)R(0x0259,0x0000025d,0x0000025b,0x0000025b,0x000002c2)R(0x025a,0x000002c0,0x0000025d,0x000002c1,0x0000025b)R(0x025b,0x000002c2,0x000002f2,0x000002c0,0x000002c1)R(0x025c,0x000002c2,0x0000025b,0x0000025d,0x000002c4)R(0x025d,0x000002c1,0x000002f1,0x000002f2,0x000002c2)R(0x025e,0x000002c1,0x0000031d,0x000002c2,0x00000289)R(0x025f,0x000002f2,0x000002f1,0x000002c2,0x0000031d)\nR(0x0260,0x000002f1,0x000002c4,0x0000031d,0x000002c1)R(0x0261,0x00000289,0x000002f1,0x000002f0,0x000002f1)R(0x0262,0x0000031d,0x000002f0,0x000002c4,0x0000031e)R(0x0263,0x0000031d,0x000002c4,0x0000031f,0x0000031e)R(0x0264,0x0000031d,0x0000033f,0x000002f0,0x0000031e)R(0x0265,0x0000033f,0x0000031d,0x0000031f,0x00000320)R(0x0266,0x0000031e,0x000002f0,0x0000033f,0x000002ef)R(0x0267,0x00000288,0x000002f0,0x000002ef,0x00000322)R(0x0268,0x0000033f,0x0000031e,0x00000320,0x00000322)R(0x0269,0x0000031e,0x000002ef,0x0000033f,0x00000322)R(0x026a,0x00000288,0x000002ef,0x000002ee,0x000002d0)R(0x026b,0x00000322,0x00000320,0x000002d0,0x00000320)R(0x026c,0x000002c8,0x000002ef,0x00000322,0x00000321)R(0x026d,0x000002ef,0x00000321,0x000002ee,0x00000321)R(0x026e,0x00000322,0x000002d0,0x0000026b,0x000002d0)R(0x026f,0x000002c8,0x1e23de36,0x30e7f35a,0xffffffff)\nR(0x0270,0x00000060,0x00000083,0x0000005f,0x00000042)R(0x0271,0x00000060,0x0000005f,0x00000083,0x000000aa)R(0x0272,0x000000a9,0x0000002a,0x00000042,0x0000002b)R(0x0273,0x00000060,0x00000084,0x00000083,0x00000084)R(0x0274,0x000000aa,0x00000083,0x00000044,0x00000060)R(0x0275,0x00000042,0x0000002c,0x00000042,0x0000002a)R(0x0276,0x0000002c,0x00000044,0x00000042,0x00000062)R(0x0277,0x00000084,0x00000060,0x00000084,0x000000ab)R(0x0278,0x000000aa,0x00000044,0x00000062,0x00000060)R(0x0279,0x000000ab,0x000000d7,0x000000aa,0x00000062)R(0x027a,0x00000086,0x00000084,0x00000086,0x000000ab)R(0x027b,0x00000084,0x0000002c,0x00000045,0x00000044)R(0x027c,0x00000044,0x00000063,0x00000062,0x000000ab)R(0x027d,0x000000d8,0x000000d7,0x00000045,0x00000063)R(0x027e,0x00000044,0x0000002d,0x00000045,0x0000002c)R(0x027f,0x00000062,0x00000087,0x00000086,0x00000063)\nR(0x0280,0x00000087,0x00000062,0x00000086,0x000000ae)R(0x0281,0x000000ab,0x00000045,0x00000064,0x00000063)R(0x0282,0x000000ae,0x000000d8,0x000000ab,0x0000002d)R(0x0283,0x00000046,0x00000045,0x00000064,0x00000087)R(0x0284,0x00000063,0x00000046,0x00000064,0x00000045)R(0x0285,0x00000087,0x000000af,0x00000086,0x00000086)R(0x0286,0x000000af,0x000000ae,0x00000064,0x00000088)R(0x0287,0x00000087,0x00000088,0x000000af,0x00000087)R(0x0288,0x000000ae,0x000000dc,0x000000d8,0x00000088)R(0x0289,0x000000b0,0x000000af,0x000000dc,0x0000010f)R(0x028a,0x000000d8,0x000000af,0x000000dd,0x000000ae)R(0x028b,0x000000b0,0x000000dd,0x000000af,0x000000ae)R(0x028c,0x000000dd,0x000000dc,0x000000dc,0x00000114)R(0x028d,0x0000010f,0x000000b0,0x000000de,0x000000dd)R(0x028e,0x000000dd,0x00000115,0x000000dc,0x000000dc)R(0x028f,0x00000115,0x00000114,0x000000de,0x00000116)\nR(0x0290,0x000000dd,0x000000dd,0x00000116,0x00000115)R(0x0291,0x00000115,0x00000157,0x00000114,0x00000117)R(0x0292,0x00000118,0x000000de,0x000000de,0x00000118)R(0x0293,0x00000116,0x00000114,0x00000157,0x00000156)R(0x0294,0x00000116,0x00000158,0x00000115,0x00000115)R(0x0295,0x00000158,0x00000157,0x00000118,0x00000159)R(0x0296,0x00000116,0x00000157,0x000001a6,0x00000156)R(0x0297,0x00000116,0x00000159,0x00000158,0x00000158)R(0x0298,0x000001a6,0x00000157,0x1e008f16,0x3104abff)R(0x0299,0x000000f6,0x1e008f16,0x28c4abff,0xffffffff)R(0x029a,0x0000025d,0x000002c5,0x000002c4,0x0000025c)R(0x029b,0x0000025d,0x000001f2,0x000002c3,0x000002c5)R(0x029c,0x0000025d,0x0000025c,0x000002c3,0x0000025d)R(0x029d,0x000001f1,0x0000025c,0x000001f2,0x0000025e)R(0x029e,0x000002c3,0x0000025c,0x000002c3,0x000002c6)R(0x029f,0x000002c5,0x000001f1,0x000001f2,0x00000196)\nR(0x02a0,0x0000025f,0x000002c3,0x0000025e,0x000001f3)R(0x02a1,0x0000025e,0x0000025c,0x000001f3,0x0000025c)R(0x02a2,0x000001f1,0x0000025f,0x000002c6,0x000002c3)R(0x02a3,0x000001f5,0x0000025f,0x0000025e,0x000001f5)R(0x02a4,0x0000025e,0x000001f3,0x00000197,0x000001f1)R(0x02a5,0x00000196,0x00000260,0x000002c6,0x0000025f)R(0x02a6,0x00000197,0x000001f3,0x000001f1,0x000001f6)R(0x02a7,0x0000025f,0x000001f5,0x000001f4,0x000001f5)R(0x02a8,0x000001f3,0x000001f6,0x00000260,0x0000025f)R(0x02a9,0x00000149,0x00000197,0x00000196,0x00000198)R(0x02aa,0x000001f3,0x00000197,0x00000198,0x000001f4)R(0x02ab,0x000001f3,0x0000019a,0x000001f6,0x000001f5)R(0x02ac,0x000001f7,0x00000260,0x000001f6,0x0000019a)R(0x02ad,0x000001f5,0x000001f4,0x0000014a,0x00000198)R(0x02ae,0x00000197,0x0000019a,0x000001f7,0x000001f6)R(0x02af,0x00000199,0x000001f4,0x00000198,0x0000019a)\nR(0x02b0,0x000001f4,0x00000199,0x0000014b,0x00000198)R(0x02b1,0x0000014a,0x0000014b,0x00000199,0x00000198)R(0x02b2,0x0000019b,0x000001f7,0x0000019a,0x0000010b)R(0x02b3,0x0000014b,0x0000014a,0x0000019c,0x000001f7)R(0x02b4,0x0000019b,0x0000014d,0x0000019a,0x00000199)R(0x02b5,0x0000014d,0x0000019b,0x0000019a,0x0000014c)R(0x02b6,0x00000199,0x0000014b,0x0000010c,0x0000014b)R(0x02b7,0x0000010b,0x0000014e,0x0000019c,0x0000019b)R(0x02b8,0x0000014d,0x00000199,0x0000014c,0x000000d6)R(0x02b9,0x0000010b,0x000000d5,0x0000010c,0x0000014c)R(0x02ba,0x0000014b,0x0000014f,0x0000019c,0x0000014e)R(0x02bb,0x0000014e,0x0000019b,0x0000014d,0x000000d6)R(0x02bc,0x0000010c,0x0000010b,0x0000010d,0x0000014d)R(0x02bd,0x0000014c,0x0000010d,0x0000014e,0x0000014d)R(0x02be,0x0000010d,0x0000014c,0x0000010c,0x000000a9)R(0x02bf,0x000000d6,0x000000d5,0x0000010e,0x0000014f)\nR(0x02c0,0x0000014e,0x0000010e,0x0000014e,0x0000010d)R(0x02c1,0x0000010f,0x0000014f,0x0000010e,0x000000d7)R(0x02c2,0x0000010c,0x000000d6,0x000000d7,0x0000010d)R(0x02c3,0x0000010c,0x000000d7,0x0000010e,0x0000010d)R(0x02c4,0x000000aa,0x000000d6,0x000000a9,0x000000d8)R(0x02c5,0x0000010f,0x0000010e,0x000000aa,0x000000d7)R(0x02c6,0x000000d6,0x000000d8,0x0000010e,0x000000d7)R(0x02c7,0x26b09316,0x310417ff,0xffffffff,0x00000156)R(0x02c8,0x000001a6,0x000001a5,0x000002c5,0x0000031f)R(0x02c9,0x000002c4,0x0000026b,0x000002c8,0x00000263)R(0x02ca,0x00000201,0x0000026b,0x00000263,0x000002c8)R(0x02cb,0x00000320,0x000002c7,0x000002c7,0x00000320)R(0x02cc,0x0000031f,0x00000114,0x00000156,0x00000150)R(0x02cd,0x00000114,0x00000150,0x0000010f,0x000001a5)R(0x02ce,0x00000201,0x000001fa,0x00000263,0x000002c8)R(0x02cf,0x000002c7,0x00000156,0x000001a5,0x0000019e)\nR(0x02d0,0x00000201,0x00000263,0x000001fa,0x000002c6)R(0x02d1,0x0000031f,0x000002c5,0x00000156,0x0000019e)R(0x02d2,0x00000150,0x000001a5,0x000001fa,0x0000019e)R(0x02d3,0x000002c7,0x0000031f,0x000002c6,0x0000010f)R(0x02d4,0x00000150,0x0000014f,0x00000263,0x000002c7)R(0x02d5,0x00000261,0x000001fa,0x00000263,0x00000262)R(0x02d6,0x00000150,0x0000019e,0x0000019d,0x00000261)R(0x02d7,0x000002c7,0x000002c6,0x0000019e,0x000001fa)R(0x02d8,0x000001f9,0x00000262,0x00000263,0x00000261)R(0x02d9,0x00000150,0x0000019d,0x0000014f,0x000001fa)R(0x02da,0x00000262,0x000001f9,0x0000019e,0x000001f9)R(0x02db,0x0000019d,0x00000261,0x000002c6,0x00000260)R(0x02dc,0x0000014f,0x0000019d,0x0000019c,0x000001f8)R(0x02dd,0x00000262,0x00000261,0x000001f9,0x00000262)R(0x02de,0x000001f8,0x0000019d,0x000001f9,0x0000019c)R(0x02df,0x000001f8,0x00000261,0x00000260,0x0000019c)\nR(0x02e0,0x000001f9,0x000001f8,0x000001f8,0x00000260)R(0x02e1,0x000001f7,0x0000019c,0x000001f8,0x000001f7)R(0x02e2,0x2f400000,0x3ff7af50,0x00000379,0x2f400000)R(0x02e3,0x3d149f50,0x000001e8,0x2fc00000,0x3d12656d)R(0x02e4,0x00000134,0x2fe00000,0x3d11d8db,0xffffffff)R(0x02e5,0x00000338,0x00000373,0x00000334,0x00000334)R(0x02e6,0x00000373,0x00000372,0x00000374,0x00000379)R(0x02e7,0x00000338,0x00000338,0x00000379,0x00000373)R(0x02e8,0x00000373,0x000003a7,0x00000372,0x00000379)R(0x02e9,0x000003a8,0x00000373,0x00000374,0x000003a9)R(0x02ea,0x00000379,0x00000373,0x000003a8,0x000003a7)R(0x02eb,0x00000372,0x000003a7,0x000003a6,0x00000374)R(0x02ec,0x000003aa,0x000003a9,0x00000372,0x000003a6)R(0x02ed,0x00000371,0x00000379,0x000003ad,0x000003a8)R(0x02ee,0x000003a9,0x000003ad,0x00000379,0x000003a8)R(0x02ef,0x000003d0,0x000003a7,0x000003a7,0x000003d0)\nR(0x02f0,0x000003a6,0x00000371,0x000003a6,0x000003a5)R(0x02f1,0x000003ad,0x000003d1,0x000003a8,0x000003aa)R(0x02f2,0x000003d3,0x000003a9,0x000003a8,0x000003d1)R(0x02f3,0x000003d0,0x000003a6,0x000003d0,0x000003cf)R(0x02f4,0x000003a9,0x000003d2,0x000003ad,0x00000371)R(0x02f5,0x000003a5,0x00000370,0x000003a6,0x000003cf)R(0x02f6,0x000003a5,0x000003ab,0x000003d3,0x000003aa)R(0x02f7,0x000003a9,0x000003d3,0x000003d2,0x000003d1)R(0x02f8,0x000003ee,0x000003d0,0x000003ad,0x000003d6)R(0x02f9,0x000003d1,0x000003d0,0x000003ee,0x000003cf)R(0x02fa,0x000003d2,0x000003d6,0x000003ad,0x00000370)R(0x02fb,0x000003a5,0x000003a4,0x000003a5,0x000003cf)R(0x02fc,0x000003ce,0x000003ab,0x000003d4,0x000003d3)R(0x02fd,0x00000370,0x000003a4,0x0000036f,0x000003cf)R(0x02fe,0x000003ee,0x000003ed,0x000003d1,0x000003ef)R(0x02ff,0x000003ee,0x000003d6,0x000003ef,0x000003d1)\nR(0x0300,0x000003a5,0x000003ce,0x000003a4,0x000003d3)R(0x0301,0x000003f1,0x000003d2,0x000003cf,0x000003ed)R(0x0302,0x000003ce,0x000003d2,0x000003f0,0x000003d6)R(0x0303,0x000003d4,0x000003f1,0x000003d3,0x000003ee)R(0x0304,0x000003ff,0x000003ed,0x0000036f,0x000003a4)R(0x0305,0x000003a3,0x000003ef,0x000003ff,0x000003ee)R(0x0306,0x000003d2,0x000003f1,0x000003f0,0x000003d5)R(0x0307,0x000003e8,0x000003d4,0x000003a4,0x000003ce)R(0x0308,0x000003cd,0x000003d6,0x000003f2,0x000003ef)R(0x0309,0x000003ca,0x000003e8,0x000003d5,0x000003ce)R(0x030a,0x000003ed,0x000003ec,0x000003e8,0x000003f1)R(0x030b,0x000003d4,0x000003f0,0x000003f2,0x000003d6)R(0x030c,0x000003a4,0x000003cd,0x000003a3,0x000003ed)R(0x030d,0x000003ff,0x000003ec,0x000003ce,0x000003ec)R(0x030e,0x000003cd,0x000003fe,0x000003ff,0x000003ef)R(0x030f,0x000003cb,0x000003e9,0x000003ca,0x000003ca)\nR(0x0310,0x000003e9,0x000003e8,0x000003f1,0x000003fd)R(0x0311,0x000003f0,0x000003f2,0x000003fe,0x000003ef)R(0x0312,0x000003a3,0x000003cc,0x000003cb,0x000003e8)R(0x0313,0x000003fd,0x000003f1,0x000003ec,0x000003ff)R(0x0314,0x000003fe,0x000003a3,0x000003cd,0x000003cc)R(0x0315,0x000003f0,0x000003fd,0x000003f2,0x000003cc)R(0x0316,0x000003e9,0x000003cb,0x000003e9,0x000003fd)R(0x0317,0x000003e8,0x000003cd,0x000003ec,0x000003ea)R(0x0318,0x000003ec,0x000003fe,0x000003ea,0x000003cd)R(0x0319,0x000003ea,0x000003cc,0x000003eb,0x000003fe)R(0x031a,0x000003f2,0x000003f2,0x000003fd,0x000003eb)R(0x031b,0x000003eb,0x000003fd,0x000003e9,0x000003cc)R(0x031c,0x000003eb,0x000003e9,0x000003ea,0x000003fe)R(0x031d,0x000003eb,0x000003ea,0x000003eb,0x000003cc)R(0x031e,0x2fc0089f,0x3b22656d,0xffffffff,0x00000335)R(0x031f,0x00000374,0x00000338,0x00000334,0x00000372)\nR(0x0320,0x00000333,0x00000336,0x00000375,0x00000335)R(0x0321,0x00000335,0x00000375,0x00000374,0x000002e1)R(0x0322,0x00000333,0x00000332,0x000002e1,0x00000332)R(0x0323,0x000002e0,0x00000333,0x00000372,0x00000371)R(0x0324,0x00000333,0x00000371,0x00000332,0x00000375)R(0x0325,0x000003aa,0x00000374,0x00000336,0x00000377)R(0x0326,0x00000375,0x000002e0,0x00000332,0x00000331)R(0x0327,0x00000376,0x00000377,0x00000336,0x00000332)R(0x0328,0x00000371,0x00000331,0x00000377,0x000003aa)R(0x0329,0x00000375,0x000002e0,0x00000331,0x000002df)R(0x032a,0x00000376,0x000003a2,0x00000377,0x00000331)R(0x032b,0x00000371,0x00000370,0x00000377,0x000003ab)R(0x032c,0x000003aa,0x000002df,0x00000331,0x00000330)R(0x032d,0x000003a2,0x000003ac,0x00000377,0x00000331)R(0x032e,0x00000370,0x00000330,0x000002df,0x00000330)R(0x032f,0x0000032e,0x00000377,0x000003ac,0x000003ab)\nR(0x0330,0x000003a2,0x000003c9,0x000003ac,0x0000039f)R(0x0331,0x000003c9,0x000003a2,0x00000330,0x0000036d)R(0x0332,0x0000032e,0x00000330,0x00000370,0x0000036f)R(0x0333,0x0000032e,0x0000036d,0x0000036c,0x000003ac)R(0x0334,0x000003d5,0x000003ab,0x00000330,0x0000036f)R(0x0335,0x0000036d,0x0000036c,0x000003a0,0x0000039f)R(0x0336,0x000003c9,0x000003d5,0x000003ac,0x000003a0)R(0x0337,0x000003c9,0x0000039f,0x000003ab,0x000003d5)R(0x0338,0x000003d4,0x0000036d,0x000003a1,0x0000036c)R(0x0339,0x0000036c,0x000003a1,0x000003a0,0x0000036f)R(0x033a,0x000003a1,0x0000036d,0x000003a0,0x000003ca)R(0x033b,0x000003c9,0x000003ca,0x000003d5,0x000003c9)R(0x033c,0x0000036f,0x000003a3,0x000003a1,0x000003a1)R(0x033d,0x000003cb,0x000003a0,0x000003a0,0x000003cb)R(0x033e,0x000003ca,0x000003a3,0x000003cb,0x000003a1)R(0x033f,0x2f40853d,0x38c49f50,0x000000e4,0x2f40853d)\nR(0x0340,0x38c49e38,0xffffffff,0x0000039f,0x000003a2)R(0x0341,0x0000036e,0x00000378,0x000003a2,0x00000376)R(0x0342,0x0000036e,0x000003a2,0x00000378,0x0000036c)R(0x0343,0x0000039f,0x0000036e,0x00000337,0x00000378)R(0x0344,0x00000376,0x00000337,0x00000376,0x00000336)R(0x0345,0x00000339,0x00000378,0x00000337,0x0000036e)R(0x0346,0x00000378,0x0000033e,0x000002e3,0x00000337)R(0x0347,0x00000336,0x0000033e,0x00000378,0x00000339)R(0x0348,0x000002e6,0x00000339,0x00000337,0x0000036c)R(0x0349,0x0000036e,0x0000032f,0x000002e7,0x00000339)R(0x034a,0x000002e6,0x0000032f,0x0000036e,0x0000033e)R(0x034b,0x000002ec,0x00000339,0x000002e7,0x000002ec)R(0x034c,0x0000033e,0x00000339,0x0000032e,0x0000036c)R(0x034d,0x0000032f,0x0000032f,0x0000033e,0x000002ed)R(0x034e,0x000002ed,0x0000033e,0x000002ec,0x0000032e)R(0x034f,0x0000032f,0x000002de,0x000002de,0x0000032f)\nR(0x0350,0x000002ed,0x00000286,0x000002ed,0x000002ec)R(0x0351,0x000002df,0x0000032e,0x000002de,0x000002de)R(0x0352,0x000002ed,0x00000287,0x00000287,0x000002ed)R(0x0353,0x00000286,0x0000027c,0x000002de,0x00000287)R(0x0354,0x0000027c,0x000002df,0x000002de,0x00000218)R(0x0355,0x00000287,0x00000286,0x0000027c,0x000002e0)R(0x0356,0x000002df,0x0000027d,0x000002e1,0x000002e0)R(0x0357,0x0000027c,0x00000287,0x00000219,0x0000027d)R(0x0358,0x000002e0,0x0000027c,0x00000219,0x00000287)R(0x0359,0x00000218,0x0000020e,0x0000027d,0x0000027c)R(0x035a,0x0000020e,0x0000027c,0x00000219,0x000001b5)R(0x035b,0x00000219,0x00000218,0x000001b5,0x00000218)R(0x035c,0x00000217,0x000001b5,0x00000217,0x000001b4)R(0x035d,0x000001b4,0x00000217,0x00000216,0x00000217)R(0x035e,0x0000026f,0x00000216,0x000001b4,0x00000216)R(0x035f,0x00000215,0x000001b4,0x00000215,0x000001b3)\nR(0x0360,0x0000026f,0x00000272,0x00000216,0x00000216)R(0x0361,0x00000285,0x00000215,0x00000207,0x00000272)R(0x0362,0x0000026f,0x00000272,0x00000285,0x00000216)R(0x0363,0x000001b3,0x00000215,0x00000214,0x00000215)R(0x0364,0x00000285,0x00000214,0x00000272,0x000002d4)R(0x0365,0x00000285,0x00000207,0x00000273,0x00000272)R(0x0366,0x000001b3,0x00000214,0x000001b2,0x00000214)R(0x0367,0x00000285,0x00000284,0x00000208,0x00000273)R(0x0368,0x00000207,0x00000272,0x000002d5,0x000002d4)R(0x0369,0x00000285,0x000002d4,0x00000284,0x00000273)R(0x036a,0x000002d5,0x00000272,0x2f40ca15,0x36548b50)R(0x036b,0xffffffff,0x000002cf,0x00000321,0x000002d0)R(0x036c,0x000002ee,0x00000321,0x000002d1,0x000002d1)R(0x036d,0x00000321,0x000002cf,0x000002e7,0x000002ee)R(0x036e,0x000002ec,0x000002cf,0x000002d0,0x0000026b)R(0x036f,0x000002ec,0x000002ee,0x000002d1,0x00000286)\nR(0x0370,0x000002ec,0x000002d1,0x0000026e,0x000002d1)R(0x0371,0x000002cf,0x0000026c,0x000002cf,0x0000026b)R(0x0372,0x00000286,0x000002d1,0x0000026e,0x0000026e)R(0x0373,0x000002cf,0x0000026c,0x00000201,0x0000026c)R(0x0374,0x0000026b,0x0000026d,0x00000286,0x0000026e)R(0x0375,0x00000218,0x00000286,0x0000026d,0x00000203)R(0x0376,0x0000026e,0x0000026c,0x0000026d,0x0000026e)R(0x0377,0x00000203,0x00000202,0x0000026c,0x00000201)R(0x0378,0x00000218,0x0000026d,0x00000217,0x00000203)R(0x0379,0x0000026c,0x00000202,0x0000026d,0x0000026f)R(0x037a,0x00000217,0x000001a5,0x00000202,0x00000201)R(0x037b,0x00000204,0x0000026d,0x00000203,0x00000204)R(0x037c,0x0000026f,0x0000026d,0x000001a7,0x00000203)R(0x037d,0x00000202,0x000001a8,0x00000204,0x00000203)R(0x037e,0x00000207,0x0000026f,0x00000204,0x000001a6)R(0x037f,0x00000202,0x000001a5,0x000001a8,0x00000203)\nR(0x0380,0x000001a7,0x000001a7,0x00000202,0x000001a6)R(0x0381,0x000001ab,0x00000207,0x00000204,0x000001ab)R(0x0382,0x00000204,0x000001a8,0x00000159,0x000001a8)R(0x0383,0x000001a7,0x0000015c,0x000001ab,0x000001a8)R(0x0384,0x00000158,0x000001a7,0x000001a6,0x000001ab)R(0x0385,0x00000208,0x00000207,0x0000015c,0x000001a8)R(0x0386,0x00000159,0x00000159,0x000001a7,0x00000158)R(0x0387,0x0000015c,0x000001ac,0x000001ab,0x00000118)R(0x0388,0x0000015c,0x00000159,0x000001ac,0x00000208)R(0x0389,0x000001ab,0x2f4430a6,0x3ff7ae63,0x00000158)R(0x038a,0x334540a6,0x3ff7ad87,0x000000a0,0x366638a6)R(0x038b,0x3ff7ad20,0xffffffff,0x00000323,0x0000032d)R(0x038c,0x000002dd,0x000002dd,0x0000032d,0x0000032c)R(0x038d,0x00000324,0x00000363,0x00000323,0x00000323)R(0x038e,0x00000363,0x0000032d,0x000002e8,0x0000033a)R(0x038f,0x00000324,0x0000033a,0x00000363,0x00000324)\nR(0x0390,0x0000032d,0x0000036a,0x0000032c,0x0000032c)R(0x0391,0x00000369,0x0000032b,0x00000363,0x0000036b)R(0x0392,0x0000032d,0x000002e8,0x0000033b,0x0000033a)R(0x0393,0x0000032c,0x0000036a,0x00000369,0x0000032d)R(0x0394,0x0000036b,0x0000036a,0x0000033a,0x0000037a)R(0x0395,0x00000363,0x00000363,0x0000037a,0x0000036b)R(0x0396,0x0000032b,0x00000369,0x00000368,0x0000033b)R(0x0397,0x0000037b,0x0000033a,0x0000033a,0x0000037b)R(0x0398,0x0000037a,0x0000036b,0x0000039e,0x0000036a)R(0x0399,0x0000037a,0x0000039e,0x0000036b,0x0000036a)R(0x039a,0x0000039d,0x00000369,0x0000033d,0x0000037c)R(0x039b,0x0000033b,0x00000369,0x0000039d,0x00000368)R(0x039c,0x0000033b,0x0000037c,0x0000037b,0x0000036a)R(0x039d,0x0000039e,0x0000039d,0x0000037b,0x000003ae)R(0x039e,0x0000037a,0x0000037a,0x000003ae,0x0000039e)R(0x039f,0x0000037c,0x000003ae,0x0000037b,0x0000033d)\nR(0x03a0,0x0000037d,0x0000037c,0x000003ae,0x000003c8)R(0x03a1,0x0000039e,0x0000039e,0x000003c8,0x0000039d)R(0x03a2,0x00000368,0x0000039d,0x00000367,0x0000037c)R(0x03a3,0x000003af,0x000003ae,0x000003af,0x000003c8)R(0x03a4,0x000003ae,0x0000037d,0x000003af,0x0000037c)R(0x03a5,0x0000039d,0x000003c8,0x0000039c,0x00000367)R(0x03a6,0x0000039d,0x0000039c,0x0000039b,0x000003af)R(0x03a7,0x0000037d,0x0000039b,0x000003c8,0x000003af)R(0x03a8,0x0000039c,0x000003c8,0x0000039b,0x334540ea)R(0x03a9,0x3ff7ad87,0xffffffff,0x00000212,0x00000282)R(0x03aa,0x00000271,0x00000212,0x00000283,0x00000282)R(0x03ab,0x00000271,0x000002d3,0x000002d2,0x00000282)R(0x03ac,0x000002d3,0x00000271,0x000002d2,0x000002dd)R(0x03ad,0x0000027b,0x0000027b,0x000002dc,0x0000027a)R(0x03ae,0x0000027b,0x000002dd,0x000002dc,0x000002d3)R(0x03af,0x00000323,0x000002d2,0x000002d2,0x00000323)\nR(0x03b0,0x000002dd,0x0000027a,0x000002dc,0x000002db)R(0x03b1,0x00000282,0x000002e8,0x000002d3,0x00000283)R(0x03b2,0x000002e9,0x00000282,0x000002d3,0x00000324)R(0x03b3,0x00000323,0x000002dd,0x0000032c,0x000002dc)R(0x03b4,0x000002e8,0x00000324,0x000002d3,0x00000283)R(0x03b5,0x000002ea,0x000002e9,0x000002dc,0x0000032b)R(0x03b6,0x000002db,0x00000282,0x000002e9,0x000002e8)R(0x03b7,0x000002dc,0x0000032c,0x0000032b,0x000002db)R(0x03b8,0x0000032a,0x000002da,0x000002db,0x0000032b)R(0x03b9,0x0000032a,0x000002ea,0x0000033c,0x000002e9)R(0x03ba,0x000002e9,0x0000033b,0x000002e8,0x000002da)R(0x03bb,0x0000032a,0x000002d9,0x0000033c,0x0000033d)R(0x03bc,0x000002e9,0x0000032b,0x00000368,0x0000032a)R(0x03bd,0x000002e9,0x0000033d,0x0000033b,0x00000325)R(0x03be,0x00000364,0x0000033c,0x000002d9,0x0000032a)R(0x03bf,0x00000329,0x0000033c,0x00000364,0x0000033d)\nR(0x03c0,0x0000032a,0x00000368,0x00000329,0x000002d9)R(0x03c1,0x00000329,0x00000328,0x00000364,0x0000037d)R(0x03c2,0x0000033d,0x00000326,0x00000365,0x00000364)R(0x03c3,0x00000329,0x00000368,0x00000367,0x00000329)R(0x03c4,0x00000367,0x00000328,0x00000365,0x0000037d)R(0x03c5,0x00000364,0x00000328,0x00000366,0x00000327)R(0x03c6,0x00000327,0x00000366,0x00000365,0x00000328)R(0x03c7,0x00000367,0x00000366,0x00000365,0x0000039b)R(0x03c8,0x0000037d,0x00000366,0x0000039b,0x00000365)R(0x03c9,0x00000367,0x0000039c,0x00000366,0x00000366)R(0x03ca,0x0000039c,0x0000039b,0x2f44314a,0x3ee74263)R(0x03cb,0x000000b5,0x2f44314e,0x3d360663,0xffffffff)R(0x03cc,0x00000118,0x0000015d,0x0000015c,0x000001aa)R(0x03cd,0x00000205,0x000001a9,0x000001b1,0x00000206)R(0x03ce,0x000001aa,0x000001b2,0x00000213,0x000001b1)R(0x03cf,0x000001aa,0x00000206,0x00000205,0x000001a9)\nR(0x03d0,0x000001ae,0x0000015d,0x000001b2,0x00000214)R(0x03d1,0x00000213,0x000001a9,0x00000205,0x000001ae)R(0x03d2,0x000001b1,0x00000212,0x00000206,0x0000015d)R(0x03d3,0x000001ad,0x0000015c,0x000001b1,0x00000213)R(0x03d4,0x00000212,0x0000015d,0x000001ae,0x000001ad)R(0x03d5,0x0000015c,0x000001ad,0x000001ac,0x00000214)R(0x03d6,0x00000284,0x00000213,0x000001ae,0x0000020b)R(0x03d7,0x000001ad,0x00000213,0x00000283,0x00000212)R(0x03d8,0x00000213,0x00000284,0x00000283,0x000001ad)R(0x03d9,0x0000020b,0x0000020a,0x000001ad,0x00000209)R(0x03da,0x000001ac,0x000001ad,0x0000020a,0x00000209)R(0x03db,0x0000020b,0x00000277,0x0000020a,0x000001ac)R(0x03dc,0x00000209,0x00000208,0x00000284,0x000002ea)R(0x03dd,0x00000283,0x000002d4,0x000002eb,0x00000284)R(0x03de,0x00000284,0x000002eb,0x000002ea,0x00000209)R(0x03df,0x00000274,0x00000208,0x0000020a,0x00000277)\nR(0x03e0,0x00000276,0x00000208,0x00000274,0x00000273)R(0x03e1,0x0000020a,0x00000275,0x00000209,0x000002d5)R(0x03e2,0x000002eb,0x000002d4,0x0000020a,0x00000276)R(0x03e3,0x00000275,0x00000209,0x00000275,0x00000274)R(0x03e4,0x00000273,0x000002d6,0x000002d5,0x00000274)R(0x03e5,0x000002d6,0x00000273,0x000002eb,0x0000033c)R(0x03e6,0x000002ea,0x000002d5,0x00000325,0x000002eb)R(0x03e7,0x00000275,0x000002d7,0x00000274,0x000002d6)R(0x03e8,0x00000325,0x000002d5,0x00000325,0x0000033c)R(0x03e9,0x000002eb,0x00000274,0x000002d7,0x000002d6)R(0x03ea,0x00000275,0x000002d8,0x000002d7,0x000002d6)R(0x03eb,0x00000326,0x00000325,0x000002d7,0x00000326)R(0x03ec,0x000002d6,0x00000326,0x00000364,0x00000325)R(0x03ed,0x32158d4a,0x3ee741f0,0xffffffff,0x00000206)R(0x03ee,0x00000270,0x00000205,0x00000205,0x0000020d)R(0x03ef,0x000001ae,0x00000212,0x00000271,0x00000206)\nR(0x03f0,0x00000205,0x00000270,0x0000020d,0x00000206)R(0x03f1,0x00000271,0x00000270,0x000001ae,0x0000020d)R(0x03f2,0x0000020c,0x000001ae,0x0000020c,0x0000020b)R(0x03f3,0x00000270,0x0000027b,0x0000020d,0x00000271)R(0x03f4,0x000002d2,0x00000270,0x0000020d,0x0000027a)R(0x03f5,0x0000020c,0x00000270,0x000002d2,0x0000027b)R(0x03f6,0x0000020c,0x00000278,0x0000020b,0x0000020d)R(0x03f7,0x0000027b,0x0000027a,0x0000020c,0x00000279)R(0x03f8,0x00000278,0x0000020c,0x0000027a,0x00000279)R(0x03f9,0x0000020b,0x00000278,0x00000277,0x00000278)R(0x03fa,0x00000279,0x00000277,0x0000027a,0x000002db)R(0x03fb,0x00000279,0x00000279,0x000002da,0x00000277)R(0x03fc,0x00000279,0x000002db,0x000002da,0x00000277)R(0x03fd,0x000002da,0x00000276,0x00000276,0x000002da)R(0x03fe,0x000002d9,0x00000276,0x000002d8,0x00000275)R(0x03ff,0x00000276,0x000002d9,0x000002d8,0x000002d8)\nR(0x0400,0x00000327,0x000002d7,0x000002d7,0x00000327)R(0x0401,0x00000326,0x000002d9,0x00000328,0x000002d8)R(0x0402,0x000002d8,0x00000328,0x00000327,0x00000327)R(0x0403,0x00000365,0x00000326,0x00970c3b,0x290fff8e)R(0x0404,0x000006f2,0x00972c3e,0x13dfff88,0x0000040d)R(0x0405,0x00972c3e,0x13ac8f88,0x000001d8,0x01172c3e)R(0x0406,0x13ac7e2d,0x0000011a,0x01174487,0x057c5a2d)R(0x0407,0x00000090,0x01174c87,0x057c3d2d,0xffffffff)R(0x0408,0x00000388,0x0000038d,0x00000350,0x0000034b)R(0x0409,0x00000388,0x00000350,0x0000038d,0x00000391)R(0x040a,0x0000038c,0x00000355,0x00000391,0x00000390)R(0x040b,0x00000350,0x0000038d,0x0000038c,0x0000038c)R(0x040c,0x00000391,0x00000357,0x00000357,0x00000391)R(0x040d,0x00000355,0x0000034b,0x00000350,0x00000306)R(0x040e,0x00000350,0x0000038c,0x0000034f,0x00000306)R(0x040f,0x00000350,0x0000034f,0x00000386,0x0000038c)\nR(0x0410,0x00000357,0x0000030d,0x00000357,0x00000355)R(0x0411,0x0000034f,0x0000038c,0x00000386,0x00000356)R(0x0412,0x00000357,0x0000030d,0x00000356,0x00000386)R(0x0413,0x00000357,0x00000306,0x0000034f,0x0000034a)R(0x0414,0x0000034f,0x00000386,0x0000034a,0x00000306)R(0x0415,0x0000034a,0x00000302,0x0000030e,0x00000356)R(0x0416,0x0000030d,0x00000349,0x00000386,0x00000356)R(0x0417,0x0000034a,0x00000386,0x00000349,0x00000302)R(0x0418,0x0000034a,0x00000301,0x0000030f,0x00000356)R(0x0419,0x0000030e,0x00000349,0x00000356,0x0000030f)R(0x041a,0x00000301,0x0000034a,0x00000349,0x000002ad)R(0x041b,0x0000030f,0x0000030e,0x00000301,0x00000349)R(0x041c,0x00000300,0x00000300,0x00000349,0x0000030f)R(0x041d,0x000002ae,0x0000030f,0x000002ad,0x00000300)R(0x041e,0x0000030f,0x000002ae,0x0000029f,0x00000301)R(0x041f,0x00000300,0x000002a0,0x00000300,0x000002ae)\nR(0x0420,0x0000029f,0x00000300,0x000002a0,0x0000029f)R(0x0421,0x000002a0,0x00000236,0x00000236,0x000002a0)R(0x0422,0x00000248,0x01374507,0x033c5a2d,0xffffffff)R(0x0423,0x00000304,0x0000034d,0x0000034c,0x00000305)R(0x0424,0x0000034d,0x00000304,0x00000303,0x0000034c)R(0x0425,0x0000034b,0x00000304,0x0000034c,0x00000303)R(0x0426,0x000002a4,0x00000305,0x00000304,0x00000303)R(0x0427,0x0000034b,0x00000306,0x000002a3,0x00000304)R(0x0428,0x00000303,0x000002a4,0x00000304,0x000002a3)R(0x0429,0x00000303,0x00000306,0x000002a5,0x000002a3)R(0x042a,0x00000303,0x000002a5,0x0000023b,0x000002a4)R(0x042b,0x000002a3,0x000002a3,0x000002a5,0x0000023c)R(0x042c,0x000002a5,0x00000306,0x00000302,0x0000023b)R(0x042d,0x000002a3,0x0000023c,0x0000023c,0x000002a5)R(0x042e,0x000002a1,0x000002a5,0x00000302,0x000002a1)R(0x042f,0x0000023b,0x0000023c,0x000001d5,0x0000023c)\nR(0x0430,0x000002a1,0x00000239,0x000002a1,0x00000302)R(0x0431,0x00000301,0x000001d5,0x0000023c,0x00000239)R(0x0432,0x00000239,0x000002a1,0x00000238,0x000002a1)R(0x0433,0x00000301,0x0000029f,0x000001d5,0x00000239)R(0x0434,0x000001d4,0x00000238,0x000002a1,0x0000029f)R(0x0435,0x000001d4,0x00000239,0x00000238,0x00000180)R(0x0436,0x000001d5,0x000001d4,0x00000238,0x0000029f)R(0x0437,0x00000237,0x000001d4,0x00000238,0x000001d3)R(0x0438,0x000001d3,0x00000238,0x00000237,0x00000237)R(0x0439,0x0000029f,0x00000236,0x00000180,0x000001d4)R(0x043a,0x0000017f,0x0000017f,0x000001d4,0x000001d3)R(0x043b,0x03772c3e,0x13ac7d00,0xffffffff,0x00000354)R(0x043c,0x00000390,0x00000353,0x00000240,0x000002a9)R(0x043d,0x000002a8,0x0000030a,0x00000354,0x00000309)R(0x043e,0x000002a9,0x0000030a,0x00000309,0x00000355)R(0x043f,0x00000390,0x00000354,0x00000241,0x000002a9)\nR(0x0440,0x00000240,0x0000030c,0x00000354,0x0000030a)R(0x0441,0x0000030c,0x00000355,0x00000354,0x000001db)R(0x0442,0x00000241,0x00000240,0x000002aa,0x0000030a)R(0x0443,0x000002a9,0x00000241,0x000002aa,0x000002a9)R(0x0444,0x0000030b,0x0000030c,0x0000030a,0x0000030d)R(0x0445,0x00000355,0x0000030c,0x000002aa,0x0000030b)R(0x0446,0x0000030a,0x000001db,0x00000242,0x00000241)R(0x0447,0x00000242,0x000002aa,0x00000241,0x000002ac)R(0x0448,0x0000030c,0x0000030b,0x000002ac,0x0000030d)R(0x0449,0x0000030c,0x000002ab,0x0000030b,0x000002aa)R(0x044a,0x00000243,0x000002aa,0x00000242,0x000002ac)R(0x044b,0x0000030e,0x0000030d,0x000002ac,0x0000030b)R(0x044c,0x000002ab,0x00000243,0x000002ab,0x000002aa)R(0x044d,0x000001dc,0x00000243,0x00000242,0x000002ad)R(0x044e,0x0000030e,0x000002ac,0x00000245,0x000002ac)R(0x044f,0x000002ab,0x000001dd,0x00000243,0x000001dc)\nR(0x0450,0x00000244,0x000002ab,0x00000243,0x00000245)R(0x0451,0x000002ad,0x000002ac,0x00000245,0x000002ab)R(0x0452,0x00000244,0x000001dd,0x00000244,0x00000243)R(0x0453,0x00000246,0x000002ad,0x00000245,0x000001df)R(0x0454,0x00000245,0x00000244,0x00000246,0x000002ae)R(0x0455,0x000002ad,0x000001de,0x00000244,0x000001dd)R(0x0456,0x000001df,0x00000246,0x00000245,0x000001df)R(0x0457,0x00000244,0x000001de,0x00000247,0x000002ae)R(0x0458,0x00000246,0x000002a0,0x000002ae,0x00000247)R(0x0459,0x00000187,0x000001de,0x000001dd,0x000001e0)R(0x045a,0x00000246,0x000001df,0x000001e0,0x00000247)R(0x045b,0x00000246,0x00000248,0x000002a0,0x00000247)R(0x045c,0x00000188,0x000001df,0x000001de,0x00000188)R(0x045d,0x000001de,0x00000187,0x00000188,0x000001e0)R(0x045e,0x000001df,0x009731f8,0x13ac8f88,0x0000013a)R(0x045f,0x009731f8,0x05bc8f7a,0x00000070,0x01174df8)\nR(0x0460,0x02ec8eca,0xffffffff,0x000002a6,0x00000307)R(0x0461,0x00000305,0x000002a7,0x00000307,0x000002a6)R(0x0462,0x000002a6,0x00000305,0x000002a4,0x0000023e)R(0x0463,0x000002a7,0x000002a6,0x000002a2,0x000002a6)R(0x0464,0x000002a4,0x0000023e,0x000002a6,0x000002a2)R(0x0465,0x000002a2,0x000002a4,0x0000023b,0x0000023e)R(0x0466,0x000002a2,0x0000023d,0x0000023a,0x000002a2)R(0x0467,0x0000023b,0x000001d9,0x0000023e,0x0000023d)R(0x0468,0x0000023d,0x000002a2,0x0000023a,0x0000023a)R(0x0469,0x0000023b,0x000001d5,0x000001d6,0x0000023d)R(0x046a,0x0000023a,0x000001d9,0x0000023d,0x000001d7)R(0x046b,0x000001d6,0x0000023a,0x000001d5,0x000001d7)R(0x046c,0x0000023d,0x000001d6,0x000001d8,0x000001d9)R(0x046d,0x000001d7,0x00000180,0x000001d6,0x000001d5)R(0x046e,0x00000181,0x000001d7,0x000001d6,0x00000181)R(0x046f,0x000001d8,0x000001d7,0x00000182,0x000001d8)\nR(0x0470,0x00000181,0x00000181,0x000001d6,0x00000180)R(0x0471,0x0000017d,0x00000182,0x00000181,0x00000136)R(0x0472,0x00000182,0x0000017d,0x00000135,0x00000181)R(0x0473,0x00000180,0x00000135,0x00000180,0x0000017f)R(0x0474,0x0000017d,0x00000181,0x00000135,0x009732a4)R(0x0475,0x05bc5f7a,0xffffffff,0x000001e5,0x0000024c)R(0x0476,0x0000024b,0x000002af,0x000002ff,0x0000029a)R(0x0477,0x0000024a,0x000002b0,0x00000249,0x0000024b)R(0x0478,0x000002b1,0x0000024a,0x0000029a,0x000002ff)R(0x0479,0x000002a7,0x00000249,0x000002af,0x0000029a)R(0x047a,0x000001e5,0x0000024b,0x000001e4,0x000001e3)R(0x047b,0x0000024b,0x0000024a,0x000001e4,0x0000024b)R(0x047c,0x000001e3,0x000001e2,0x0000024a,0x00000249)R(0x047d,0x0000029a,0x000002a7,0x0000023f,0x00000249)R(0x047e,0x0000029a,0x0000022b,0x000001e3,0x0000024a)R(0x047f,0x000001e2,0x000001e2,0x00000249,0x0000022b)\nR(0x0480,0x0000022b,0x0000029a,0x0000023f,0x0000018b)R(0x0481,0x000001e4,0x000001e3,0x0000023f,0x000002a7)R(0x0482,0x0000023e,0x0000018c,0x000001e4,0x0000018b)R(0x0483,0x0000018a,0x000001e3,0x000001e2,0x0000018b)R(0x0484,0x000001e3,0x0000018a,0x000001e2,0x0000022b)R(0x0485,0x000001c6,0x0000022b,0x0000023f,0x000001da)R(0x0486,0x0000013f,0x0000018c,0x0000018b,0x000001da)R(0x0487,0x0000023f,0x0000023e,0x0000018a,0x000001e2)R(0x0488,0x000001c6,0x000001c6,0x0000022b,0x000001da)R(0x0489,0x0000013e,0x0000018b,0x0000018a,0x0000013f)R(0x048a,0x0000018b,0x0000013e,0x000001da,0x0000023e)R(0x048b,0x000001d9,0x0000018a,0x000001c6,0x00000170)R(0x048c,0x0000013e,0x0000018a,0x00000170,0x00000100)R(0x048d,0x0000013f,0x0000013e,0x000001c6,0x000001da)R(0x048e,0x00000183,0x00000170,0x000001c6,0x00000183)R(0x048f,0x00000183,0x000001da,0x000001d9,0x00000100)\nR(0x0490,0x0000013e,0x00000127,0x0000013e,0x00000170)R(0x0491,0x00000127,0x00000183,0x000001d9,0x000001d8)R(0x0492,0x00000170,0x00000183,0x00000137,0x00000100)R(0x0493,0x00000127,0x000000eb,0x00000127,0x00000170)R(0x0494,0x00000137,0x00000183,0x000001d8,0x00000182)R(0x0495,0x00000137,0x00000183,0x00000182,0x000000eb)R(0x0496,0x00000127,0x000000f9,0x00000127,0x00000137)R(0x0497,0x000000f9,0x00000137,0x00000182,0x00000136)R(0x0498,0x000000f9,0x00000137,0x00000136,0x000000f9)R(0x0499,0x00000136,0x000000f8,0x03b762c1,0x13ac8788)R(0x049a,0xffffffff,0x000000a5,0x000000d0,0x000000a4)R(0x049b,0x00000105,0x00000142,0x00000103,0x000000d1)R(0x049c,0x00000104,0x000000d0,0x00000104,0x00000105)R(0x049d,0x00000103,0x00000142,0x0000018e,0x00000141)R(0x049e,0x00000103,0x00000142,0x00000141,0x000000a4)R(0x049f,0x000000d0,0x000000cf,0x000000d0,0x00000104)\nR(0x04a0,0x000000cf,0x0000018e,0x000001e5,0x0000018d)R(0x04a1,0x00000141,0x0000018e,0x0000018d,0x000000ce)R(0x04a2,0x00000104,0x00000103,0x000000a4,0x000000cf)R(0x04a3,0x000000a3,0x0000018d,0x000001e5,0x000001e4)R(0x04a4,0x000000cf,0x00000104,0x000000ce,0x00000103)R(0x04a5,0x00000141,0x00000102,0x000000ce,0x00000103)R(0x04a6,0x00000102,0x00000141,0x0000018d,0x00000140)R(0x04a7,0x000000a3,0x000000cf,0x000000a2,0x0000018d)R(0x04a8,0x000001e4,0x0000018c,0x000000a2,0x000000cf)R(0x04a9,0x000000ce,0x00000102,0x00000141,0x00000140)R(0x04aa,0x00000140,0x0000018d,0x0000018c,0x0000007d)R(0x04ab,0x000000a3,0x000000a2,0x000000ce,0x00000102)R(0x04ac,0x000000cd,0x000000a2,0x000000ce,0x000000cd)R(0x04ad,0x00000102,0x00000140,0x00000101,0x000000cd)R(0x04ae,0x00000102,0x00000101,0x00000140,0x0000018c)R(0x04af,0x0000013f,0x0000007d,0x000000a2,0x0000007c)\nR(0x04b0,0x000000a2,0x000000cd,0x000000a1,0x00000101)R(0x04b1,0x00000140,0x0000013f,0x0000007c,0x000000a2)R(0x04b2,0x000000a1,0x000000cd,0x00000101,0x000000cc)R(0x04b3,0x000000a1,0x000000cd,0x000000cc,0x00000101)R(0x04b4,0x0000013f,0x00000100,0x000000cc,0x00000101)R(0x04b5,0x000000cb,0x000000cb,0x00000101,0x00000100)R(0x04b6,0x0000007c,0x000000a1,0x0000007b,0x000000a1)R(0x04b7,0x000000cc,0x000000a0,0x00000059,0x0000007c)R(0x04b8,0x0000007b,0x000000a0,0x000000cc,0x000000cb)R(0x04b9,0x0000007b,0x000000a1,0x000000a0,0x000000cb)R(0x04ba,0x00000100,0x000000eb,0x000000a0,0x000000cb)R(0x04bb,0x000000ba,0x00000059,0x0000007b,0x0000006e)R(0x04bc,0x000000cb,0x000000eb,0x000000ba,0x0000007b)R(0x04bd,0x000000a0,0x00000091,0x0000007b,0x00000091)R(0x04be,0x0000006e,0x000000a0,0x000000ba,0x00000091)R(0x04bf,0x000000ba,0x000000eb,0x000000c5,0x000000eb)\nR(0x04c0,0x000000f9,0x000000c5,0x00000091,0x000000ba)R(0x04c1,0x0000009a,0x0000006e,0x00000091,0x0000006d)R(0x04c2,0x000000ba,0x000000c5,0x0000009a,0x0000004d)R(0x04c3,0x0000006e,0x0000006d,0x00000091,0x0000009a)R(0x04c4,0x00000076,0x0000006d,0x00000091,0x00000076)R(0x04c5,0x000000c5,0x000000f9,0x000000f8,0x0000009a)R(0x04c6,0x000000c5,0x000000c4,0x000000c5,0x000000f8)R(0x04c7,0x000000c4,0x01abf482,0x13dfff33,0x00000135)R(0x04c8,0x01abf482,0x13de2333,0x000000a8,0x01bbf482)R(0x04c9,0x129e2213,0xffffffff,0x0000013c,0x00000188)R(0x04ca,0x00000187,0x00000189,0x000001e0,0x00000188)R(0x04cb,0x0000013d,0x00000188,0x0000013c,0x0000013d)R(0x04cc,0x00000189,0x00000188,0x000001e1,0x00000247)R(0x04cd,0x000001e0,0x00000189,0x000001e1,0x000001e0)R(0x04ce,0x000000fe,0x0000013d,0x0000013c,0x000001cb)R(0x04cf,0x000001e1,0x00000189,0x00000175,0x00000189)\nR(0x04d0,0x0000013d,0x000001cc,0x00000230,0x000001cb)R(0x04d1,0x00000175,0x000001cb,0x00000189,0x000001cb)R(0x04d2,0x00000230,0x0000022f,0x000001e1,0x00000248)R(0x04d3,0x00000247,0x00000175,0x000001cc,0x000001cb)R(0x04d4,0x000001cb,0x0000022f,0x000001e1,0x00000230)R(0x04d5,0x0000029e,0x0000022f,0x0000012c,0x0000013d)R(0x04d6,0x000000fe,0x00000176,0x000001cc,0x00000175)R(0x04d7,0x0000022f,0x00000248,0x000001e1,0x0000012c)R(0x04d8,0x00000175,0x0000013d,0x0000022f,0x0000029e)R(0x04d9,0x0000029d,0x0000012c,0x00000176,0x00000175)R(0x04da,0x0000022f,0x0000029c,0x00000248,0x0000022f)R(0x04db,0x0000029d,0x0000029c,0x000000ef,0x0000012c)R(0x04dc,0x000000fe,0x00000248,0x0000029c,0x00000236)R(0x04dd,0x0000029c,0x0000029d,0x00000235,0x00000236)R(0x04de,0x0000029c,0x00000235,0x00000235,0x0000029d)R(0x04df,0x00000234,0x000001d2,0x00000236,0x00000235)\nR(0x04e0,0x000001d2,0x00000237,0x00000236,0x000001d1)R(0x04e1,0x00000235,0x00000234,0x000001d2,0x00000235)R(0x04e2,0x000001d1,0x000001d3,0x00000237,0x000001d2)R(0x04e3,0x0000017e,0x000001d2,0x000001d1,0x0000017e)R(0x04e4,0x000001d3,0x000001d2,0x0000017e,0x000001d1)R(0x04e5,0x0000017c,0x0000017f,0x000001d3,0x0000017e)R(0x04e6,0x00000134,0x0000017e,0x0000017c,0x00000134)R(0x04e7,0x0000017f,0x0000017e,0x00000134,0x0000017c)R(0x04e8,0x00000132,0x01ac05fc,0x13de2333,0xffffffff)R(0x04e9,0x00000135,0x0000017f,0x00000134,0x00000133)R(0x04ea,0x0000017d,0x00000135,0x00000136,0x0000017d)R(0x04eb,0x00000133,0x000000f7,0x00000135,0x00000134)R(0x04ec,0x00000133,0x00000135,0x000000f7,0x000000f8)R(0x04ed,0x00000136,0x00000133,0x000000f7,0x00000134)R(0x04ee,0x00000132,0x000000f6,0x00000133,0x000000f7)R(0x04ef,0x000000f8,0x00000133,0x000000f6,0x000000f7)\nR(0x04f0,0x00000132,0x000000f5,0x000000c4,0x000000f8)R(0x04f1,0x000000f6,0x000000f6,0x000000f7,0x000000c3)R(0x04f2,0x000000c3,0x000000f7,0x000000f5,0x000000c4)R(0x04f3,0x000000f6,0x000000c2,0x000000c2,0x000000f6)R(0x04f4,0x000000c3,0x000000c3,0x000000f5,0x000000c1)R(0x04f5,0x00000099,0x000000c4,0x000000c2,0x0000009a)R(0x04f6,0x000000c4,0x00000099,0x000000c2,0x000000c3)R(0x04f7,0x00000097,0x00000097,0x000000c3,0x000000c1)R(0x04f8,0x00000099,0x000000c2,0x00000098,0x00000076)R(0x04f9,0x0000009a,0x00000099,0x00000098,0x000000c2)R(0x04fa,0x00000097,0x00000075,0x00000099,0x00000098)R(0x04fb,0x00000076,0x00000099,0x00000075,0x00000074)R(0x04fc,0x00000098,0x00000097,0x00000075,0x00000098)R(0x04fd,0x00000074,0x00000074,0x00000097,0x00000093)R(0x04fe,0x00000054,0x00000076,0x00000075,0x0000006d)R(0x04ff,0x00000076,0x00000054,0x00000053,0x00000075)\nR(0x0500,0x00000074,0x00000074,0x00000093,0x00000070)R(0x0501,0x00000054,0x00000075,0x00000053,0x02dd9cd8)R(0x0502,0x12cffe78,0x000000ae,0x02dd9cd8,0x0c5ffa37)R(0x0503,0xffffffff,0x000001cd,0x00000230,0x000001cc)R(0x0504,0x000001cd,0x00000231,0x00000230,0x00000231)R(0x0505,0x0000029e,0x00000230,0x000001cd,0x00000232)R(0x0506,0x00000231,0x0000029b,0x0000029e,0x00000231)R(0x0507,0x0000029d,0x0000029e,0x0000029b,0x00000232)R(0x0508,0x00000233,0x00000231,0x00000233,0x0000029b)R(0x0509,0x00000231,0x000001cf,0x00000233,0x00000232)R(0x050a,0x00000234,0x0000029d,0x0000029b,0x0000022e)R(0x050b,0x0000029b,0x00000233,0x00000234,0x0000029b)R(0x050c,0x0000022e,0x0000022c,0x00000233,0x000001cf)R(0x050d,0x0000022e,0x00000233,0x0000022d,0x0000022d)R(0x050e,0x00000233,0x0000022c,0x000001d0,0x00000234)R(0x050f,0x0000022e,0x000001d1,0x00000234,0x000001d0)\nR(0x0510,0x000001ca,0x0000022e,0x0000022d,0x000001c9)R(0x0511,0x0000022d,0x0000022c,0x000001d0,0x0000022e)R(0x0512,0x000001ca,0x000001c9,0x0000022c,0x000001c8)R(0x0513,0x000001ca,0x0000022d,0x000001c9,0x0000017c)R(0x0514,0x000001d1,0x000001d0,0x0000017b,0x000001d0)R(0x0515,0x000001ca,0x00000173,0x000001c9,0x000001c8)R(0x0516,0x00000174,0x000001ca,0x000001c9,0x0000017c)R(0x0517,0x000001d0,0x0000017b,0x00000174,0x000001c9)R(0x0518,0x00000173,0x0000017b,0x000001ca,0x00000174)R(0x0519,0x00000132,0x0000017c,0x0000017b,0x0000012b)R(0x051a,0x00000174,0x00000173,0x00000131,0x0000017b)R(0x051b,0x00000174,0x0000012b,0x00000173,0x0000012a)R(0x051c,0x00000132,0x0000017b,0x00000131,0x00000131)R(0x051d,0x00000174,0x0000012b,0x000000ee,0x0000012b)R(0x051e,0x0000012a,0x000000f4,0x00000131,0x0000012b)R(0x051f,0x000000f5,0x00000132,0x00000131,0x000000f4)\nR(0x0520,0x0000012b,0x000000ee,0x000000f5,0x00000131)R(0x0521,0x000000f4,0x000000c1,0x000000f4,0x000000ee)R(0x0522,0x000000c1,0x000000f5,0x000000f4,0x0a8dd0dd)R(0x0523,0x12cffe78,0xffffffff,0x00000177,0x000001cd)R(0x0524,0x000001cc,0x00000177,0x000001cc,0x00000176)R(0x0525,0x00000177,0x000001ce,0x000001cd,0x000001ce)R(0x0526,0x00000232,0x000001cd,0x0000012d,0x00000177)R(0x0527,0x00000176,0x00000178,0x000001ce,0x00000177)R(0x0528,0x0000012d,0x00000178,0x00000177,0x0000012d)R(0x0529,0x00000176,0x0000012c,0x0000017a,0x000001ce)R(0x052a,0x00000178,0x000001cf,0x00000232,0x000001ce)R(0x052b,0x000000f0,0x0000012d,0x0000012c,0x0000012e)R(0x052c,0x00000178,0x0000012d,0x0000017a,0x000001cf)R(0x052d,0x000001ce,0x000000f0,0x0000012c,0x000000ef)R(0x052e,0x00000130,0x0000017a,0x00000178,0x000000f0)R(0x052f,0x0000012e,0x0000012d,0x00000130,0x00000178)\nR(0x0530,0x0000012e,0x000001c7,0x000001cf,0x0000017a)R(0x0531,0x00000179,0x0000017a,0x00000130,0x000000f1)R(0x0532,0x0000012e,0x000000f0,0x000000f3,0x00000130)R(0x0533,0x0000012e,0x00000179,0x000001c7,0x0000017a)R(0x0534,0x000000bf,0x000000f1,0x000000f0,0x000000f3)R(0x0535,0x0000012e,0x000000f1,0x000001c7,0x0000022c)R(0x0536,0x000001cf,0x0000012f,0x00000179,0x00000130)R(0x0537,0x0000012f,0x00000130,0x000000f3,0x00000171)R(0x0538,0x000001c7,0x00000179,0x000000c0,0x000000f3)R(0x0539,0x000000f1,0x00000171,0x00000179,0x0000012f)R(0x053a,0x000001c8,0x0000022c,0x000001c7,0x000000f2)R(0x053b,0x0000012f,0x000000f3,0x000000f2,0x000000f3)R(0x053c,0x000000c0,0x00000171,0x000001c8,0x000001c7)R(0x053d,0x00000128,0x00000171,0x0000012f,0x00000128)R(0x053e,0x0000012f,0x000000f2,0x000000ec,0x000000f2)R(0x053f,0x000000c0,0x00000172,0x000001c8,0x00000171)\nR(0x0540,0x00000128,0x00000172,0x00000171,0x000000ec)R(0x0541,0x00000128,0x000000f2,0x000000bb,0x000000c0)R(0x0542,0x00000096,0x000000bb,0x000000ec,0x000000c0)R(0x0543,0x00000173,0x000001c8,0x00000172,0x000000ec)R(0x0544,0x00000129,0x00000128,0x00000129,0x00000172)R(0x0545,0x00000128,0x00000092,0x000000bb,0x00000096)R(0x0546,0x000000bb,0x000000ed,0x000000ec,0x000000ed)R(0x0547,0x00000129,0x000000ec,0x0000012a,0x00000173)R(0x0548,0x00000172,0x0000012a,0x00000172,0x00000129)R(0x0549,0x000000bd,0x000000ed,0x000000bb,0x000000ed)R(0x054a,0x0000012a,0x00000129,0x00000092,0x000000bd)R(0x054b,0x000000bb,0x000000ee,0x0000012a,0x000000ed)R(0x054c,0x000000bd,0x000000ee,0x000000ed,0x000000bc)R(0x054d,0x000000bd,0x00000092,0x000000c1,0x000000ee)R(0x054e,0x000000bd,0x000000bc,0x000000c1,0x000000bd)R(0x054f,0x00000093,0x000000bc,0x00000092,0x00000097)\nR(0x0550,0x000000c1,0x000000bc,0x00000097,0x000000bc)R(0x0551,0x00000093,0x10370c3b,0x290ea38e,0x00000298)R(0x0552,0x10470c3b,0x290ea22a,0x0000011e,0x10470c3b)R(0x0553,0x1ccea21b,0x0000009c,0x10470c3b,0x1ccd20c7)R(0x0554,0xffffffff,0x0000016e,0x000001bb,0x00000166)R(0x0555,0x000001c4,0x0000022a,0x00000220,0x0000016e)R(0x0556,0x000001c4,0x000001bb,0x00000125,0x0000016e)R(0x0557,0x00000166,0x000001c5,0x0000022a,0x000001c4)R(0x0558,0x000001db,0x00000240,0x0000022a,0x0000016f)R(0x0559,0x000001c4,0x0000016e,0x00000126,0x0000016e)R(0x055a,0x00000125,0x000001db,0x0000022a,0x000001c5)R(0x055b,0x0000016f,0x000001c5,0x000001c4,0x00000126)R(0x055c,0x0000016f,0x0000016e,0x00000184,0x000001c5)R(0x055d,0x0000016f,0x00000184,0x000001db,0x000001c5)R(0x055e,0x00000138,0x0000016f,0x00000126,0x000001dc)R(0x055f,0x00000242,0x000001db,0x00000138,0x00000184)\nR(0x0560,0x0000016f,0x00000184,0x000001dc,0x000001db)R(0x0561,0x000000ff,0x00000138,0x00000126,0x00000139)R(0x0562,0x00000184,0x00000138,0x00000185,0x000001dc)R(0x0563,0x00000184,0x000000fa,0x00000138,0x000000ff)R(0x0564,0x00000139,0x00000185,0x00000184,0x000000fa)R(0x0565,0x00000139,0x00000138,0x00000185,0x000001dd)R(0x0566,0x000001dc,0x0000013a,0x00000185,0x00000139)R(0x0567,0x00000186,0x000001dd,0x00000185,0x000000fb)R(0x0568,0x00000139,0x000000fa,0x0000013a,0x00000186)R(0x0569,0x00000185,0x000000fb,0x0000013a,0x00000139)R(0x056a,0x00000187,0x000001dd,0x00000186,0x0000013b)R(0x056b,0x00000186,0x0000013a,0x0000013b,0x00000187)R(0x056c,0x00000186,0x000000fc,0x0000013a,0x000000fb)R(0x056d,0x000000fc,0x0000013b,0x0000013a,0x000000c7)R(0x056e,0x000000fc,0x000000fb,0x0000013c,0x00000187)R(0x056f,0x0000013b,0x000000fd,0x0000013b,0x000000fc)\nR(0x0570,0x000000fd,0x0000013c,0x0000013b,0x10ec9ca2)R(0x0571,0x1c8ea21b,0xffffffff,0x000000c8,0x000000fd)R(0x0572,0x000000fc,0x000000c8,0x000000fc,0x000000c7)R(0x0573,0x000000fe,0x0000013c,0x000000fd,0x000000c9)R(0x0574,0x000000fd,0x000000c8,0x000000c9,0x000000fe)R(0x0575,0x000000fd,0x0000009d,0x000000c8,0x000000c7)R(0x0576,0x0000009e,0x000000c9,0x000000c8,0x0000009e)R(0x0577,0x000000c8,0x0000009d,0x000000ef,0x000000fe)R(0x0578,0x000000c9,0x000000be,0x000000c9,0x0000009e)R(0x0579,0x000000be,0x000000ef,0x000000c9,0x00000079)R(0x057a,0x0000009e,0x0000009d,0x000000bf,0x000000f0)R(0x057b,0x000000ef,0x000000bf,0x000000ef,0x000000be)R(0x057c,0x00000094,0x000000be,0x0000009e,0x00000094)R(0x057d,0x0000009e,0x00000079,0x00000095,0x000000bf)R(0x057e,0x000000be,0x00000095,0x000000be,0x00000094)R(0x057f,0x00000071,0x00000094,0x00000079,0x000000c0)\nR(0x0580,0x000000f1,0x000000bf,0x00000096,0x000000bf)R(0x0581,0x00000095,0x00000096,0x000000c0,0x000000bf)R(0x0582,0x00000072,0x00000095,0x00000094,0x00000072)R(0x0583,0x00000094,0x00000071,0x00000073,0x00000096)R(0x0584,0x00000095,0x00000073,0x00000095,0x00000072)R(0x0585,0x00000051,0x00000072,0x00000071,0x00000092)R(0x0586,0x00000096,0x00000073,0x00000052,0x00000073)R(0x0587,0x00000072,0x00000052,0x00000072,0x00000051)R(0x0588,0x1b17508e,0x290e362a,0x000000c1,0x1b67508e)R(0x0589,0x290b5a11,0xffffffff,0x00000125,0x00000166)R(0x058a,0x0000011f,0x000000ea,0x00000126,0x00000125)R(0x058b,0x000000ff,0x00000126,0x000000ea,0x000000fa)R(0x058c,0x000000ff,0x000000ca,0x000000e8,0x00000125)R(0x058d,0x0000011f,0x000000ea,0x00000125,0x000000e8)R(0x058e,0x000000e9,0x000000ff,0x000000ea,0x000000ca)R(0x058f,0x000000ff,0x000000e9,0x000000b9,0x000000ea)\nR(0x0590,0x000000e8,0x000000e9,0x000000ea,0x000000b9)R(0x0591,0x000000b7,0x000000e8,0x000000e4,0x000000ca)R(0x0592,0x000000e9,0x000000b8,0x000000b9,0x000000e8)R(0x0593,0x000000b7,0x0000009f,0x000000ca,0x000000b8)R(0x0594,0x000000b8,0x000000e9,0x000000b9,0x0000008f)R(0x0595,0x000000b9,0x000000b7,0x000000b8,0x000000b9)R(0x0596,0x0000008f,0x0000009f,0x000000b8,0x0000008e)R(0x0597,0x0000008d,0x000000b7,0x000000b4,0x0000008f)R(0x0598,0x000000b7,0x0000008d,0x00000090,0x000000b8)R(0x0599,0x0000008f,0x0000008e,0x000000b8,0x00000090)R(0x059a,0x0000008d,0x000000b4,0x0000008b,0x0000006b)R(0x059b,0x0000008f,0x0000008d,0x0000006b,0x00000090)R(0x059c,0x0000008f,0x0000008e,0x00000090,0x0000006c)R(0x059d,0x0000006a,0x0000008e,0x0000006c,0x00000069)R(0x059e,0x0000008d,0x0000008b,0x0000006c,0x00000090)R(0x059f,0x0000006b,0x0000006b,0x0000008d,0x00000069)\nR(0x05a0,0x00000069,0x0000008b,0x00000067,0x0000006a)R(0x05a1,0x0000006c,0x0000004c,0x0000004b,0x0000006c)R(0x05a2,0x0000006b,0x0000004b,0x0000006b,0x00000069)R(0x05a3,0x00000047,0x00000067,0x00000048,0x0000004c)R(0x05a4,0x0000006c,0x0000004b,0x00000049,0x00000069)R(0x05a5,0x00000067,0x0000004b,0x00000069,0x00000049)R(0x05a6,0x00000049,0x00000067,0x00000047,0x0000001e)R(0x05a7,0x00000033,0x0000001d,0x00000033,0x0000004c)R(0x05a8,0x00000032,0x00000032,0x0000004c,0x0000004b)R(0x05a9,0x00000030,0x00000049,0x00000047,0x00000032)R(0x05aa,0x0000004b,0x00000049,0x0000001d,0x00000033)R(0x05ab,0x00000032,0x00000032,0x00000049,0x00000030)R(0x05ac,0x0000001d,0x00000032,0x00000030,0x1b1ac08f)R(0x05ad,0x284e362a,0xffffffff,0x000000c6,0x000000fa)R(0x05ae,0x000000ca,0x0000004a,0x0000004c,0x00000033)R(0x05af,0x000000c6,0x000000ca,0x0000009f,0x0000004a)\nR(0x05b0,0x0000006a,0x0000004c,0x0000007a,0x0000009f)R(0x05b1,0x0000008e,0x0000007a,0x0000008e,0x0000006a)R(0x05b2,0x000000c6,0x000000fb,0x000000fa,0x00000031)R(0x05b3,0x00000033,0x0000001e,0x00000031,0x0000004a)R(0x05b4,0x00000033,0x0000009b,0x000000c6,0x0000009f)R(0x05b5,0x0000009b,0x0000009f,0x0000007a,0x00000058)R(0x05b6,0x0000006a,0x0000004a,0x0000001c,0x00000031)R(0x05b7,0x0000001e,0x00000058,0x0000007a,0x0000006a)R(0x05b8,0x000000c7,0x000000fb,0x000000c6,0x0000003c)R(0x05b9,0x0000004a,0x00000031,0x0000009b,0x000000c7)R(0x05ba,0x000000c6,0x0000003c,0x00000058,0x0000004a)R(0x05bb,0x00000077,0x0000009b,0x0000007a,0x00000024)R(0x05bc,0x00000031,0x0000001c,0x00000077,0x0000007a)R(0x05bd,0x00000058,0x00000024,0x0000003c,0x00000031)R(0x05be,0x0000009c,0x000000c7,0x0000009b,0x00000077)R(0x05bf,0x0000009c,0x0000009b,0x00000055,0x00000058)\nR(0x05c0,0x0000003c,0x00000055,0x00000077,0x00000058)R(0x05c1,0x0000003a,0x0000003c,0x00000024,0x0000009d)R(0x05c2,0x000000c7,0x0000009c,0x00000078,0x0000009c)R(0x05c3,0x00000077,0x0000003a,0x00000055,0x0000003c)R(0x05c4,0x00000055,0x00000078,0x00000077,0x00000023)R(0x05c5,0x0000003a,0x00000024,0x00000078,0x0000009d)R(0x05c6,0x0000009c,0x0000003a,0x00000057,0x00000055)R(0x05c7,0x00000057,0x00000078,0x00000055,0x00000023)R(0x05c8,0x0000003b,0x0000003a,0x00000079,0x0000009d)R(0x05c9,0x00000078,0x00000056,0x00000057,0x0000003a)R(0x05ca,0x00000057,0x00000079,0x00000078,0x0000003b)R(0x05cb,0x00000056,0x0000003a,0x00000056,0x00000071)R(0x05cc,0x00000057,0x00000071,0x00000079,0x00000057)R(0x05cd,0x00000051,0x00000056,0x0000003b,0x00000051)R(0x05ce,0x00000071,0x00000056,0x103721ef,0x28fe878e)R(0x05cf,0x0000013a,0x103761ef,0x1e4e878e,0x000000c5)\nR(0x05d0,0x105762ea,0x1e4c6b8e,0xffffffff,0x0000007f)R(0x05d1,0x000000a5,0x000000a4,0x0000005d,0x0000007f)R(0x05d2,0x0000005c,0x0000007f,0x000000a4,0x0000007e)R(0x05d3,0x00000041,0x0000005d,0x00000040,0x0000002b)R(0x05d4,0x00000041,0x00000029,0x0000005c,0x0000007f)R(0x05d5,0x0000007e,0x00000040,0x0000005d,0x0000005c)R(0x05d6,0x0000007e,0x000000a4,0x000000a3,0x00000029)R(0x05d7,0x00000041,0x00000040,0x0000005c,0x0000007e)R(0x05d8,0x0000005b,0x00000040,0x0000005c,0x0000003f)R(0x05d9,0x0000007e,0x000000a3,0x0000007d,0x00000029)R(0x05da,0x00000040,0x00000028,0x0000003f,0x0000005c)R(0x05db,0x0000005b,0x0000005b,0x0000007e,0x0000007d)R(0x05dc,0x00000028,0x00000040,0x0000003f,0x00000015)R(0x05dd,0x00000029,0x00000028,0x0000005b,0x0000007d)R(0x05de,0x0000005a,0x0000003f,0x0000005b,0x0000003e)R(0x05df,0x00000028,0x0000003f,0x00000027,0x0000003e)\nR(0x05e0,0x0000005b,0x0000005a,0x00000015,0x00000028)R(0x05e1,0x00000014,0x00000027,0x0000003f,0x0000003e)R(0x05e2,0x0000005a,0x0000007d,0x0000007c,0x00000014)R(0x05e3,0x00000028,0x00000027,0x00000007,0x00000015)R(0x05e4,0x00000014,0x0000003e,0x0000005a,0x0000003d)R(0x05e5,0x0000005a,0x0000007c,0x00000059,0x00000027)R(0x05e6,0x0000003e,0x00000026,0x00000014,0x00000027)R(0x05e7,0x00000026,0x0000003d,0x0000005a,0x00000059)R(0x05e8,0x00000026,0x0000003e,0x0000003d,0x00000007)R(0x05e9,0x00000014,0x00000013,0x00000014,0x00000026)R(0x05ea,0x00000013,0x00000026,0x0000003d,0x00000035)R(0x05eb,0x0000003d,0x00000059,0x0000004e,0x00000013)R(0x05ec,0x00000026,0x0000001f,0x0000003d,0x0000004e)R(0x05ed,0x00000035,0x00000059,0x0000006e,0x0000004e)R(0x05ee,0x00000026,0x00000035,0x0000001f,0x00000013)R(0x05ef,0x0000001f,0x0000000e,0x00000035,0x0000004e)\nR(0x05f0,0x00000034,0x0000004e,0x0000006e,0x0000004d)R(0x05f1,0x0000001f,0x00000035,0x00000034,0x0000000e)R(0x05f2,0x0000001f,0x00000010,0x00000034,0x0000004e)R(0x05f3,0x0000004d,0x0000001f,0x00000034,0x00000022)R(0x05f4,0x0000001f,0x00000022,0x00000010,0x103c09ef)R(0x05f5,0x1d5e8733,0xffffffff,0x0000006f,0x00000092)R(0x05f6,0x00000073,0x0000006f,0x00000073,0x00000052)R(0x05f7,0x00000038,0x00000052,0x00000051,0x0000006f)R(0x05f8,0x00000093,0x00000092,0x0000004f,0x0000006f)R(0x05f9,0x00000052,0x0000004f,0x00000052,0x00000038)R(0x05fa,0x00000070,0x00000093,0x0000006f,0x0000004f)R(0x05fb,0x00000070,0x0000006f,0x00000036,0x0000004f)R(0x05fc,0x00000038,0x00000036,0x00000038,0x00000021)R(0x05fd,0x00000050,0x00000070,0x0000004f,0x00000036)R(0x05fe,0x00000050,0x0000004f,0x00000020,0x00000036)R(0x05ff,0x00000021,0x00000053,0x00000074,0x00000070)\nR(0x0600,0x00000053,0x00000070,0x00000050,0x00000037)R(0x0601,0x00000050,0x00000036,0x00000020,0x00000037)R(0x0602,0x00000036,0x00000039,0x00000053,0x00000050)R(0x0603,0x00000039,0x00000050,0x00000037,0x00000022)R(0x0604,0x00000037,0x00000020,0x00000010,0x00000022)R(0x0605,0x00000020,0x00000022,0x00000039,0x00000037)R(0x0606,0x00000039,0x00000054,0x00000053,0x00000034)R(0x0607,0x00000039,0x00000022,0x0000004d,0x00000054)R(0x0608,0x00000039,0x00000034,0x0000004d,0x00000039)R(0x0609,0x0000004d,0x0000006d,0x00000054,0x1b8721f5)R(0x060a,0x28fe3726,0xffffffff,0x0000002f,0x00000046)R(0x060b,0x0000002d,0x00000018,0x0000002d,0x0000002c)R(0x060c,0x00000018,0x0000002c,0x0000002a,0x00000047)R(0x060d,0x00000048,0x0000002f,0x0000002a,0x0000002b)R(0x060e,0x00000016,0x0000001a,0x0000002f,0x0000002d)R(0x060f,0x0000001a,0x0000002d,0x00000018,0x00000018)\nR(0x0610,0x0000002a,0x00000017,0x00000016,0x0000002b)R(0x0611,0x00000029,0x00000017,0x0000002a,0x00000016)R(0x0612,0x0000002e,0x00000047,0x0000002f,0x0000002e)R(0x0613,0x0000002f,0x0000001a,0x0000000a,0x0000001a)R(0x0614,0x00000018,0x0000000a,0x00000018,0x00000017)R(0x0615,0x00000016,0x00000029,0x00000015,0x00000030)R(0x0616,0x00000047,0x0000002e,0x00000008,0x00000017)R(0x0617,0x00000016,0x00000019,0x0000002e,0x0000001a)R(0x0618,0x00000019,0x0000001a,0x0000000a,0x00000009)R(0x0619,0x00000016,0x00000015,0x0000000a,0x00000017)R(0x061a,0x00000008,0x00000008,0x00000016,0x00000009)R(0x061b,0x0000001b,0x00000030,0x0000002e,0x0000001b)R(0x061c,0x0000002e,0x00000019,0x00000009,0x00000015)R(0x061d,0x00000007,0x00000002,0x0000000a,0x00000008)R(0x061e,0x0000000b,0x00000019,0x0000000a,0x00000008)R(0x061f,0x00000009,0x00000001,0x0000001d,0x00000030)\nR(0x0620,0x0000001b,0x0000000b,0x0000001b,0x00000019)R(0x0621,0x00000002,0x0000000b,0x0000000a,0x00000002)R(0x0622,0x00000008,0x00000001,0x00000001,0x00000009)R(0x0623,0x00000007,0x0000000d,0x0000001b,0x0000000b)R(0x0624,0x0000000d,0x0000001d,0x0000001b,0x00000001)R(0x0625,0x00000007,0x00000004,0x00000003,0x0000000b)R(0x0626,0x00000002,0x00000000,0x00000002,0x00000001)R(0x0627,0x00000007,0x00000013,0x0000000e,0x00000003)R(0x0628,0x0000000d,0x0000000b,0x00000001,0x00000004)R(0x0629,0x00000000,0x00000000,0x00000003,0x00000002)R(0x062a,0x0000000d,0x0000001e,0x0000001d,0x00000007)R(0x062b,0x0000000e,0x00000004,0x0000000c,0x0000000d)R(0x062c,0x00000003,0x00000004,0x00000005,0x00000000)R(0x062d,0x0000001c,0x0000001e,0x0000000d,0x00000004)R(0x062e,0x0000000e,0x00000005,0x00000000,0x00000006)R(0x062f,0x00000003,0x0000000c,0x0000001c,0x0000000d)\nR(0x0630,0x00000006,0x0000000c,0x00000003,0x00000005)R(0x0631,0x00000006,0x00000000,0x0000000e,0x00000010)R(0x0632,0x00000005,0x00000011,0x0000001c,0x0000000c)R(0x0633,0x00000006,0x00000011,0x0000000c,0x00000005)R(0x0634,0x0000000f,0x00000006,0x00000005,0x00000010)R(0x0635,0x0000000f,0x00000011,0x00000024,0x0000001c)R(0x0636,0x00000006,0x00000012,0x00000011,0x0000000f)R(0x0637,0x00000012,0x00000006,0x00000010,0x00000020)R(0x0638,0x0000000f,0x00000023,0x00000024,0x00000011)R(0x0639,0x00000012,0x00000023,0x00000011,0x0000000f)R(0x063a,0x00000021,0x00000012,0x00000020,0x00000021)R(0x063b,0x0000000f,0x00000012,0x00000025,0x00000023)R(0x063c,0x00000021,0x00000025,0x00000012,0x00000025)R(0x063d,0x0000003b,0x00000023,0x00000021,0x00000038)R(0x063e,0x00000025,0x00000038,0x0000003b,0x00000025)R(0x063f,0x00000038,0x00000051,0x0000003b,0x00000000)\n  }\n  return r;\n}\nivec4 points_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;\n  ivec4 r;\n  switch(i) {\nR(0x0000,0x219b3ec1,0x203a82ec,0x23ba66ca,0x24bb3a9d)R(0x0001,0x1e7b1add,0x1f3beac5,0x228c1e91,0x1cda5eff)R(0x0002,0x21e9b2ef,0x1e79bf09,0x25197ebf,0x266a7a90)R(0x0003,0x25abbe6b,0x279b0656,0x1cab7afb,0x1efcaaa5)R(0x0004,0x1c5c42ea,0x242c9251,0x213cfa6e,0x1b8acf1f)R(0x0005,0x1bb9f728,0x1c596314,0x1f68d30c,0x22b8dae8)R(0x0006,0x24a86abf,0x2749a283,0x26c8ba87,0x286a1e48)R(0x0007,0x265c122a,0x28ea8605,0x27eb5a11,0x19fb9b25)R(0x0008,0x1bccfec1,0x1d5d6680,0x192c6afb,0x227d3e22)R(0x0009,0x24bcc1fd,0x1f5d8a46,0x199a9b59,0x19e9c364)R(0x000a,0x1ac9173f,0x1be88f26,0x2167f2f1,0x1e47db1b)R(0x000b,0x23777ac4,0x25b7c683,0x28491e43,0x27781e41)R(0x000c,0x28f995fc,0x26bc05da,0x290a25b6,0x284b19c4)R(0x000d,0x16fc0b2d,0x179b4753,0x1a0db292,0x18ad26d3)R(0x000e,0x1b8dfe47,0x159cd2fa,0x220d59ce,0x1f5dce0a)R(0x000f,0x24bca1a8,0x162a8771,0x1799bf7e,0x1868fb79)\nR(0x0010,0x19685f4a,0x1a57d737,0x20070303,0x1c670730)R(0x0011,0x22e6aad9,0x24e6fe8f,0x26672241,0x285895f8)R(0x0012,0x274799f5,0x28a919ae,0x26cbbd8b,0x2859b971)R(0x0013,0x282ac57b,0x13ac1b31,0x144b575a,0x17ae1667)R(0x0014,0x168d9aae,0x1bce35f8,0x183e5a1b,0x132d52ce)R(0x0015,0x122cb70b,0x225d1174,0x1eade5c8,0x1f6dad85)R(0x0016,0x249c4956,0x121a9378,0x1429b386,0x1598eb8e)R(0x0017,0x16d83f6e,0x17c7c342,0x19073345,0x1e26372c)R(0x0018,0x2115f309,0x1a765345,0x23d5a6d6,0x25163eae)R(0x0019,0x2646466c,0x2696462c,0x2656b9ee,0x279815aa)R(0x001a,0x262719a3,0x2788a568,0x263b5943,0x26995534)R(0x001b,0x270a593b,0x103c0b33,0x107b4f57,0x144e523c)R(0x001c,0x13ddee86,0x1bbe2da0,0x187e6dc8,0x14ee85ef)R(0x001d,0x104d9a9b,0x0f8ceee1,0x0d7c4714,0x21fcb125)R(0x001e,0x1f5d653c,0x1c4de94f,0x23abdd11,0x0e2aaf66)R(0x001f,0x1059d378,0x12790388,0x14285380,0x1507b348)\nR(0x0020,0x15f74b37,0x17067749,0x1c458f51,0x1f752336)R(0x0021,0x22453303,0x18a58f66,0x24c54ecc,0x26058694)R(0x0022,0x2745664e,0x26c5c5f2,0x25962dab,0x25d7ad64)R(0x0023,0x24469160,0x25385d2a,0x24cae103,0x23f928f3)R(0x0024,0x2549f900,0x0c7b8745,0x10ee760c,0x107e2260)R(0x0025,0x18ce416e,0x152e7999,0x123e95c0,0x0c3dde78)R(0x0026,0x0d1d52b2,0x0b5cc2e3,0x09cc0712,0x20ac30e3)R(0x0027,0x1efce4f8,0x1c3d7105,0x192de91d,0x220b40db)R(0x0028,0x0a5ac351,0x0cd9db69,0x0e59076a,0x11487f70)R(0x0029,0x1237db44,0x12676323,0x13a6d33b,0x1515e75c)R(0x002a,0x1bb4bf69,0x1ec43751,0x2134a72d,0x23d50710)R(0x002b,0x15351b77,0x18348b83,0x270516eb,0x27653695)R(0x002c,0x2904e657,0x2794f60b,0x26a521be,0x24c58180)R(0x002d,0x23776126,0x2265b145,0x21668518,0x223834f1)R(0x002e,0x22ca2cd6,0x217910cc,0x086b4f32,0x104e9dda)R(0x002f,0x0d9e423b,0x0dce6e0d,0x15be3143,0x12ce6967)\nR(0x0030,0x11cea19b,0x0a9e1637,0x09ad32a1,0x083d925f)R(0x0031,0x080c86cd,0x069bd2f6,0x1e7bb4b7,0x1c8c9cc7)R(0x0032,0x192d4cd4,0x160db8f7,0x1f5ac0b8,0x06ea7332)R(0x0033,0x097a0753,0x0a793b55,0x0b588f39,0x0e984f41)R(0x0034,0x0f97b719,0x0df77f07,0x10070329,0x11b5f34f)R(0x0035,0x1b83db75,0x1e035f60,0x2013ef50,0x22e47355)R(0x0036,0x2604ab43,0x11e4e76a,0x14e42b85,0x17d39385)R(0x0037,0x29849315,0x2a44c6ba,0x2bd49669,0x28d48e11)R(0x0038,0x2b545e22,0x27344dd7,0x25a47d96,0x2334c562)R(0x0039,0x206750ee,0x2004bd36,0x1f75ad16,0x1dc664e7)R(0x003a,0x1f282cc6,0x1ff9d4bc,0x1dd910b6,0x05bb170a)R(0x003b,0x106ef9d1,0x0e1ed9ff,0x0b6e9e1f,0x129e1122)R(0x003c,0x110e4132,0x11de8163,0x119f05a0,0x11df016a)R(0x003d,0x08ce5a2c,0x06edd62f,0x05ecee92,0x04bd2e4e)R(0x003e,0x04ec5ec1,0x03bba6df,0x1c1ae88f,0x1b1bd09a)R(0x003f,0x18bc9ca2,0x158d20ba,0x121d8ce5,0x1cca009e)\nR(0x0040,0x054a3315,0x06e98336,0x0818c333,0x09380308)R(0x0041,0x0c37df08,0x0a478af3,0x0bd70717,0x0e165339)R(0x0042,0x0f456b40,0x1b22fb6e,0x1d72a760,0x1eb33b64)R(0x0043,0x2083cf71,0x228403a7,0x24f42789,0x2884175a)R(0x0044,0x0ef46b46,0x11a3db6b,0x14b33f7c,0x17c29f70)R(0x0045,0x2c140f3b,0x2ca476f2,0x2e246eaa,0x2d547236)R(0x0046,0x2f447663,0x297405eb,0x2d444e0e,0x2c43f5fd)R(0x0047,0x27538dcc,0x2523a9ad,0x22b3d970,0x1d175cca)R(0x0048,0x1f73c94c,0x1c743d26,0x1c653d08,0x1a75e0e3)R(0x0049,0x1b26a8cc,0x1c6848b0,0x1b99288e,0x034ad6fe)R(0x004a,0x107fa5b5,0x0eff7de5,0x0c5f6204,0x098f1615)R(0x004b,0x0f5dd50c,0x0f9e6d10,0x112ec934,0x114fa17f)R(0x004c,0x10ff753e,0x06be9219,0x04adbe13,0x032cc291)R(0x004d,0x02ed0a11,0x022c8e50,0x023c2ac4,0x018b32eb)R(0x004e,0x1a09f470,0x18bac871,0x17cbb87f,0x153c7090)R(0x004f,0x119cd8af,0x0e9d48d4,0x029a0b27,0x05099b31)\nR(0x0050,0x06b8ff30,0x07984f1b,0x08077af7,0x0886ff07)R(0x0051,0x0a26572a,0x0c45c328,0x0cc4ff16,0x1b02234f)R(0x0052,0x1db1d731,0x1e422b4d,0x1e52a770,0x1f232b91)R(0x0053,0x20a3a7bb,0x22239be3,0x2483cbd6,0x2783b7ab)R(0x0054,0x2b33b37e,0x0ca41308,0x0ee36f39,0x11c2df56)R(0x0055,0x14b25b5d,0x1741b33b,0x2ee3df56,0x2f443f1f)R(0x0056,0x306456e2,0x30d43e93,0x2f14ba2f,0x2e94be0b)R(0x0057,0x31b45a5d,0x3134ea2f,0x2b0331db,0x2ec499e7)R(0x0058,0x2df409f5,0x2e1361f6,0x2882a5cb,0x24e2ddbe)R(0x0059,0x2242f995,0x1ef2f968,0x1b67789f,0x1b93513e)R(0x005a,0x1823c128,0x19549d0f,0x182548f0,0x176590c8)R(0x005b,0x1935fcad,0x1a36a893,0x1ae83c74,0x19a90458)R(0x005c,0x016a5712,0x0f3ff199,0x0ddfd1d2,0x0aefa9e5)R(0x005d,0x07ef35ec,0x0c8d70f0,0x0dbdf8f9,0x0d3ea4e6)R(0x005e,0x0f9f2d0d,0x0fffd95f,0x0eefa52a,0x055e89e8)R(0x005f,0x036dc5d7,0x01ac4a99,0x020cfdc1,0x01bc59fc)\nR(0x0060,0x016bba2d,0x015bd27d,0x014b96ca,0x010a8ef0)R(0x0061,0x16f9d04f,0x156ac05d,0x143b946f,0x116c1482)R(0x0062,0x0dac7c9d,0x0b6cf4d2,0x01697342,0x02f92359)R(0x0063,0x0568f74f,0x06686b46,0x06e7ab22,0x0606df18)R(0x0064,0x07063f23,0x0895af1c,0x0ae53701,0x0b24a2d5)R(0x0065,0x1b415f1e,0x1e113af6,0x1f716726,0x1ef1df71)R(0x0066,0x1f125fa8,0x206317d6,0x22c2cfef,0x24734ff3)R(0x0067,0x27e327e7,0x2a935fba,0x2dd35b8d,0x0b03cab8)R(0x0068,0x0d131ef2,0x0fd27f1d,0x1311e730,0x15013f00)R(0x0069,0x18310304,0x30636f50,0x30e40f1c,0x31a3fed0)R(0x006a,0x31f3ea7e,0x30b551fa,0x305555d3,0x33740a4e)R(0x006b,0x34348a37,0x33951217,0x3305c9f0,0x2da2d5e2)R(0x006c,0x2bf269d3,0x30e529ad,0x30046dca,0x2f73bdeb)R(0x006d,0x30533606,0x2ff2ea02,0x29c1e5dc,0x25c1fdd1)R(0x006e,0x223231c7,0x1f2239a0,0x1bc26974,0x19873c62)R(0x006f,0x1872c550,0x15531d3c,0x1403e92f,0x15b4b514)\nR(0x0070,0x157540f1,0x148568af,0x1675bc7e,0x18165868)R(0x0071,0x1898004d,0x16e8d046,0x00f9b71f,0x0daffd68)R(0x0072,0x0c3ff9a8,0x092fb9b2,0x066f25b0,0x097d2ce1)R(0x0073,0x0b3dd0dd,0x0aeea0df,0x0d2f3cfd,0x0c2fb932)R(0x0074,0x047e6d9e,0x02dd9d88,0x01ecc972,0x01ec25a9)R(0x0075,0x01bb71d7,0x013ab9ff,0x022b1a4f,0x023b1686)R(0x0076,0x011b22bd,0x020a56b6,0x0179bee7,0x13a9083e)R(0x0077,0x130a144c,0x112b0c5a,0x0e5ba876,0x0aabac7e)R(0x0078,0x09bc44ae,0x084c94e3,0x00e8df56,0x01989b72)R(0x0079,0x03b87774,0x0457db66,0x04b71f3b,0x03d6433d)R(0x007a,0x02d6af35,0x05e5a72f,0x06d54312,0x087522f3)R(0x007b,0x09e4daca,0x09b46e81,0x1b40dadd,0x1e00e2b4)R(0x007c,0x1fc0c2e3,0x20312b69,0x21b0af2a,0x202177b1)R(0x007d,0x20a22bd2,0x2261b3df,0x25321bf3,0x26b2a7ff)R(0x007e,0x29a27be7,0x2bd2e7c4,0x2f02c386,0x0a538667)R(0x007f,0x0ba2e2a3,0x0e4246d3,0x1151b2ed,0x134112b9)\nR(0x0080,0x1730b6be,0x30f28f42,0x31c35f09,0x32333ead)R(0x0081,0x3293865b,0x322605c4,0x3215f59c,0x34e3e627)R(0x0082,0x36547e19,0x36f50a09,0x36955de8,0x34258df0)R(0x0083,0x344671c6,0x33d6a1ae,0x2f72b1d1,0x2d8285c0)R(0x0084,0x2cf225bd,0x2c11d9de,0x3345b174,0x32c4e190)R(0x0085,0x324431bb,0x31739ded,0x3293660d,0x3172fe23)R(0x0086,0x3182921f,0x30e29df2,0x2b114e01,0x271139f7)R(0x0087,0x22f179ec,0x1f5185e3,0x1bc19dae,0x1831e185)R(0x0088,0x16c70c47,0x14c24d67,0x1202fd55,0x1053c958)R(0x0089,0x1184a933,0x12953117,0x126558e9,0x10f58ca7)R(0x008a,0x1305bc74,0x14e64055,0x1537f43b,0x00c90326)R(0x008b,0x0a8fd96e,0x07ef8579,0x05feed63,0x069d1cec)R(0x008c,0x08fdf4d8,0x089ec4f8,0x0acf4507,0x089f6134)R(0x008d,0x044e2150,0x030d3d3f,0x02ac392d,0x01bbf55d)R(0x008e,0x01eb4178,0x016a91b0,0x024a5230,0x0219c5f8)R(0x008f,0x0189ddb2,0x02ea3677,0x02a93ea4,0x0238eeeb)\nR(0x0090,0x1197e840,0x1028b043,0x10499045,0x0eca584d)R(0x0091,0x0c5b005b,0x08eae066,0x077b8490,0x06abf4cd)R(0x0092,0x053c3cfc,0x00a82b50,0x00f80f71,0x0227f77a)R(0x0093,0x02973757,0x01766344,0x01f5b368,0x03e56764)R(0x0094,0x0136c73c,0x0574f745,0x05a4931b,0x0694e2e7)R(0x0095,0x07c4dab4,0x08d4c686,0x08d46a4f,0x09d3ea36)R(0x0096,0x1aa0a294,0x1e20d26c,0x1fd09a9f,0x227042e4)R(0x0097,0x21f0db80,0x24208f3f,0x22211fbd,0x25115bd0)R(0x0098,0x2811dfe3,0x2b41b7b6,0x2cd24bb3,0x2f01df74)R(0x0099,0x0b033214,0x0ba29a50,0x0d622687,0x1001869c)R(0x009a,0x11612259,0x14b0c27a,0x17709e5f,0x3101ab1f)R(0x009b,0x32026aee,0x3202d25a,0x32122e98,0x32f35e31)R(0x009c,0x3376b58b,0x33e68d65,0x35a3e9f7,0x37b475f0)R(0x009d,0x38e519e8,0x398591d8,0x3925c9b2,0x36a5d1a9)R(0x009e,0x34e61dc3,0x35c6b18a,0x35071d82,0x34d73969)R(0x009f,0x324271b2,0x2fa27d93,0x2e222984,0x2e11a578)\nR(0x00a0,0x2d31adc2,0x2d9169f0,0x35f6313d,0x3565615d)R(0x00a1,0x35549d8e,0x3433edd4,0x3241f638,0x32c229f9)R(0x00a2,0x2d510633,0x2870b630,0x2460ba1d,0x20f11a1a)R(0x00a3,0x1e710624,0x1b6109ee,0x180135be,0x14c19197)R(0x00a4,0x13270443,0x11923581,0x0f02f586,0x0d73c589)R(0x00a5,0x0db49156,0x0f255133,0x0f059102,0x0d35d0bc)R(0x00a6,0x0f260079,0x11065852,0x0178330b,0x066ea521)R(0x00a7,0x041cf50e,0x04fdc513,0x071e08ee,0x01bb4d29)R(0x00a8,0x038b9900,0x015a755f,0x02a96a4c,0x02b921bb)R(0x00a9,0x0298d20e,0x0279a16e,0x02686268,0x02681ab8)R(0x00aa,0x0ee72c49,0x0d38184b,0x0cc9304d,0x0b0a3054)R(0x00ab,0x070a086e,0x057ad487,0x045b38bb,0x00977f28)R(0x00ac,0x00b73344,0x01476b60,0x00b6673b,0x00c59f68)R(0x00ad,0x01b50b80,0x0364c374,0x04344f53,0x03e3eb1c)R(0x00ae,0x04843eda,0x0594baa1,0x0704ce6f,0x07444245)R(0x00af,0x08c3de1b,0x0a53a9f8,0x1b00b63d,0x2100a255)\nR(0x00b0,0x22703e93,0x25703efa,0x25502eb0,0x2490e79a)R(0x00b1,0x28509316,0x2740db62,0x28c13fa5,0x2cc1437a)R(0x00b2,0x2f412b41,0x0c6321cd,0x0d324e07,0x0e81c645)R(0x00b3,0x10816a04,0x1420da28,0x17a0c60b,0x31816acc)R(0x00b4,0x3030d2f9,0x3171766d,0x34f7414a,0x35c70d2c)R(0x00b5,0x36c451b9,0x38c49dbd,0x3a6529ba,0x3b55b9b4)R(0x00b6,0x3c1605a0,0x3b763d79,0x3866516b,0x36f7294d)R(0x00b7,0x3657853a,0x36679520,0x34a1f1b6,0x34c2296b)R(0x00b8,0x32526564,0x2ff22d49,0x2f01c132,0x2f412158)R(0x00b9,0x2f21351c,0x2e8155a8,0x2ff139d6,0x30214215)R(0x00ba,0x3856b907,0x3905f927,0x37b5415a,0x38b4e585)R(0x00bb,0x32017e1f,0x33c1b5f2,0x30411a53,0x2ea0ae89)R(0x00bc,0x2b20a272,0x27e05679,0x24d05e54,0x14611ddf)R(0x00bd,0x11c19dbd,0x0f2239c3,0x0b13b9b9,0x0aa43d7f)R(0x00be,0x09750169,0x0be55d55,0x0c05b93b,0x0b15dcfc)R(0x00bf,0x08e618c7,0x0b563893,0x0d16a85e,0x018772eb)\nR(0x00c0,0x020afcde,0x018a9907,0x0279fd2a,0x02f8b171)R(0x00c1,0x029835c6,0x0257d221,0x03391d25,0x01c74e72)R(0x00c2,0x0106eeb8,0x0a77705e,0x09986c5d,0x0959605a)R(0x00c3,0x06790076,0x0399648d,0x038a2c88,0x027a9ca1)R(0x00c4,0x0076a30b,0x0055d333,0x00451b60,0x0094bf78)R(0x00c5,0x01846f73,0x0213f74e,0x01d3ab12,0x0213cacd)R(0x00c6,0x0304269f,0x04f48a76,0x0593fa4c,0x06d3ba13)R(0x00c7,0x0893bde6,0x29006ac6,0x2bd08700,0x2af0ef4f)R(0x00c8,0x2e20ab26,0x3060caaa,0x2ef072dd,0x36e79101)R(0x00c9,0x37c75cec,0x3b054d86,0x3cb5dd87,0x3db63d7b)R(0x00ca,0x3e467963,0x3d66a541,0x3a46cd30,0x38d7750e)R(0x00cb,0x3837acf3,0x3897a4d7,0x36a1a16d,0x35d16da2)R(0x00cc,0x36d1cd21,0x34a22117,0x32422513,0x30c1ccf5)R(0x00cd,0x2fe148db,0x2fc0e501,0x3100f541,0x31310593)R(0x00ce,0x3020ecc2,0x32512de1,0x3a373cc1,0x3b56a4ea)R(0x00cf,0x3ab5994e,0x3c863917,0x340149d3,0x2ca07ebe)\nR(0x00d0,0x0833edae,0x07447d81,0x07655161,0x0935c15a)R(0x00d1,0x0935e938,0x07f5f0ff,0x06c60cce,0x07067cab)R(0x00d2,0x0976c07f,0x019a4cbe,0x0239dcec,0x0308112b)R(0x00d3,0x02b7a17d,0x026745d6,0x0146f227,0x023910e5)R(0x00d4,0x021834ec,0x00a67a74,0x0055eecd,0x06c73c8a)R(0x00d5,0x0688107d,0x03788496,0x01d9c099,0x01a8d09e)R(0x00d6,0x00350311,0x00244b48,0x00841b5b,0x00c3bb32)R(0x00d7,0x00c39eec,0x0143caa0,0x00b3c2b0,0x0323be7f)R(0x00d8,0x05234a37,0x05132207,0x0653a5dc,0x396788c1)R(0x00d9,0x3d35fd51,0x3ee6714a,0x3f86a539,0x3f76d51a)R(0x00da,0x3d2714f9,0x3ae780d7,0x3b2788b8,0x3af77cae)R(0x00db,0x37c1094e,0x38414926,0x35d0f586,0x38c154d9)R(0x00dc,0x36a1c8cd,0x33f1d8c3,0x31916ca8,0x31310c8b)R(0x00dd,0x3120d0aa,0x31c0e0f5,0x3390c95f,0x34f0a519)R(0x00de,0x33f0d998,0x3210e46f,0x3bf758a6,0x3cc718b3)R(0x00df,0x3e56c8d8,0x3f168514,0x0553e1a3,0x04f49d6c)\nR(0x00e0,0x0645293d,0x07b5d141,0x069590fa,0x05256cc4)R(0x00e1,0x05061cad,0x0466c8a2,0x016964b7,0x02c70138)R(0x00e2,0x02074cf4,0x02869d92,0x015669e1,0x00c62e2a)R(0x00e3,0x014878bc,0x011790c3,0x00b58e72,0x0014f2b6)R(0x00e4,0x0387a49f,0x0177cca9,0x001422f0,0x0043c317)R(0x00e5,0x0043c6bc,0x00839a97,0x01533e81,0x0332ee5a)R(0x00e6,0x03629630,0x02a281f7,0x042315d0,0x3ff6c907)R(0x00e7,0x3fd6e8f4,0x3e3734c5,0x3d4750ab,0x3730993d)R(0x00e8,0x390074fa,0x3990c8eb,0x35a0854b,0x3af0c09f)R(0x00e9,0x39315c8d,0x36c1a07d,0x3431786d,0x32a1305f)R(0x00ea,0x33910c40,0x33e0d464,0x3430d4b8,0x370068d9)R(0x00eb,0x36f03d07,0x34e0f42d,0x3e1728b1,0x3f86e8d9)R(0x00ec,0x02b345a5,0x02540978,0x02145d54,0x04349d33)R(0x00ed,0x0474dcee,0x0254c4cc,0x02e558ae,0x0215f0a5)R(0x00ee,0x01c6d0a4,0x01f65d02,0x02961150,0x00e6a4d2)R(0x00ef,0x01b5b1a0,0x006591e2,0x00e5561e,0x0116bcb3)\nR(0x00f0,0x00549e59,0x00141296,0x00336a7d,0x0092ce67)R(0x00f1,0x01828252,0x01725627,0x00b259f3,0x0182a1c6)R(0x00f2,0x3f2710c8,0x381038fa,0x3a700cb4,0x3b2044ac)R(0x00f3,0x3cc07c68,0x3be10054,0x39a16840,0x36e1702b)R(0x00f4,0x35314825,0x3691380f,0x3790dc37,0x3730b484)R(0x00f5,0x3950349f,0x393008c2,0x3891180a,0x00e34d96)R(0x00f6,0x00c42168,0x01045d30,0x02247105,0x011490df)R(0x00f7,0x01451cb3,0x0105c8ac,0x00b5b8ce,0x01659919)R(0x00f8,0x0155455f,0x0054c9ab,0x00348604,0x00039e40)R(0x00f9,0x0022b243,0x00925e33,0x00326df8,0x0072b5be)R(0x00fa,0x3b500087,0x3c402476,0x3d00d830,0x3d10903c)R(0x00fb,0x3bf13419,0x39a1640a,0x38315c03,0x3a113c00)R(0x00fc,0x3b30bc29,0x3af05065,0x3c40e017,0x00738d8a)R(0x00fd,0x00844d5c,0x00a4810f,0x00c4f4ca,0x0094f505)R(0x00fe,0x0074a554,0x0043f192,0x0013bddd,0x0002e604)R(0x00ff,0x002305bc,0x3ca0584f,0x3c810015,0x3af14803)\nR(0x0100,0x00000000,0x00000000,0x00000000,0x00000000)  }\n  return r;\n}\nivec4 normals_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;\n  ivec4 r;\n  switch(i) {\nR(0x0000,0x2cfaf3aa,0x29fa97c8,0x316a0798,0x336ad76a)R(0x0001,0x2d4a0fbd,0x307a8397,0x308bb36f,0x303987ac)R(0x0002,0x2e690bc3,0x27a97be6,0x36483f6d,0x38997337)R(0x0003,0x36ab9b14,0x3bca4ecc,0x34295782,0x2fbc3761)R(0x0004,0x2f3b7f85,0x357ccadd,0x302d371f,0x3779734d)R(0x0005,0x39e87729,0x2f38ebbd,0x2bb87fda,0x3197bbaa)R(0x0006,0x3736bf55,0x3ba7fefe,0x3b56a2f8,0x3e386ea1)R(0x0007,0x3a8c0676,0x3f693232,0x3d8aee36,0x2ffb4f84)R(0x0008,0x2c5cf35c,0x2d4dcf16,0x29cc8786,0x332e1e76)R(0x0009,0x37ed421d,0x2dfe6ecc,0x31da2b90,0x3668336b)R(0x000a,0x38072b4b,0x2db873cc,0x32276fa2,0x2d2853d1)R(0x000b,0x37975755,0x3b5636ed,0x3ea6ee7e,0x3df6067c)R(0x000c,0x3fc76223,0x3b8c05ea,0x3fb869ca,0x3e2a85d5)R(0x000d,0x274c9392,0x28bb77b6,0x289e5715,0x26ed5b6a)R(0x000e,0x2a1f0eae,0x240d6772,0x339e45da,0x2eaefe4b)R(0x000f,0x381d15ae,0x24ba67e1,0x28795fe4,0x31d6739c)\nR(0x0010,0x3205b78b,0x2a2847e3,0x31d8b3a4,0x2bd8cfd7)R(0x0011,0x36893b60,0x3c089af2,0x3f07266c,0x3f263e13)R(0x0012,0x3ea5c601,0x3f46adc2,0x3b7ba58a,0x3de79d4e)R(0x0013,0x3da9cd68,0x20ec7ba6,0x219ba7c5,0x23cf36d1)R(0x0014,0x223e5335,0x29df8e2f,0x252fb26d,0x1dbe3f3c)R(0x0015,0x1d4d936b,0x348dc57e,0x2e7f19e1,0x301eb59c)R(0x0016,0x383c5d4b,0x1e3a37ea,0x1f6943f8,0x24373ff8)R(0x0017,0x2a93e794,0x260553d7,0x22a8b3fb,0x2e29c7bb)R(0x0018,0x33398b8b,0x2709cbe4,0x37194f56,0x3a79730e)R(0x0019,0x3e095e95,0x3fa91205,0x3fb765d0,0x3e05a5a7)R(0x001a,0x3dc5e181,0x3c660d38,0x3a4ab916,0x3a26d8e2)R(0x001b,0x3b58c0fb,0x1cdc8ba0,0x1dab9bc6,0x207f92a0)R(0x001c,0x1eded707,0x2a9f75be,0x25bfd9ef,0x220fea36)R(0x001d,0x1c9e4f34,0x1b4e0747,0x1a6d5b70,0x341cdd09)R(0x001e,0x304e1935,0x2b5f055d,0x363b20cc,0x1a39efe7)R(0x001f,0x19987ff3,0x18e75bf0,0x1c53a7a8,0x1e82cb82)\nR(0x0020,0x1b081bf8,0x1f9a1bec,0x2b0a37ca,0x2fe9e3a9)R(0x0021,0x313b4378,0x245a9fdd,0x2d6e5edc,0x3b2a56df)R(0x0022,0x3dbaea19,0x3f1945af,0x3e180153,0x3af57920)R(0x0023,0x3a364cf0,0x37d5d0c8,0x36c9aca9,0x35367c8d)R(0x0024,0x37a7dca8,0x19fbdfb4,0x1fbfb683,0x1e1f1ee4)R(0x0025,0x25df9d86,0x234fd9b2,0x234ff207,0x197e8315)R(0x0026,0x1b5e1343,0x189db352,0x15fcfb6d,0x314b588a)R(0x0027,0x2f0d0cc5,0x2bbde8df,0x262ef116,0x3189a861)R(0x0028,0x1669bbda,0x186833f0,0x1655a7cf,0x1493e38e)R(0x0029,0x1602b35b,0x17673fe9,0x1c1a97df,0x1e3adfdb)R(0x002a,0x2b19abd2,0x2ca96fcc,0x23cc73a3,0x213eeafd)R(0x002b,0x1cea43e7,0x24694bf3,0x2a4f2a98,0x30ceb246)R(0x002c,0x324e69ac,0x3d2a897d,0x3d68cd3e,0x39d7ccd2)R(0x002d,0x3685a8b5,0x34d67488,0x3405c88b,0x3335c880)R(0x002e,0x30b8444b,0x2e16d83a,0x121b379b,0x2ebdcf03)R(0x002f,0x1c5f62b8,0x25ee0f3e,0x22ef6545,0x256f8d71)\nR(0x0030,0x3beb965e,0x1a7e0345,0x160deb2f,0x145e3b04)R(0x0031,0x150d634d,0x128c4f74,0x2e69f448,0x2c3c0874)R(0x0032,0x272da0a7,0x21ae8cdc,0x2e686c37,0x0ea937a6)R(0x0033,0x13d83bd8,0x15c607d3,0x18a35f90,0x15730b6b)R(0x0034,0x15735f7d,0x18a9d7e3,0x1b1b1bd0,0x193a33df)R(0x0035,0x298837e7,0x28184bed,0x170c4397,0x16fe86ff)R(0x0036,0x26ce970a,0x13a92bd1,0x1a584bf6,0x22a713f9)R(0x0037,0x2b4eb2d4,0x2cef462e,0x28cfa1d0,0x31ad50ff)R(0x0038,0x27eec912,0x395910cf,0x3866e4bd,0x33c6cc75)R(0x0039,0x30d5c464,0x2e35e849,0x2f75845c,0x2ce57049)R(0x003a,0x2cc64038,0x2b978c23,0x2cd7082f,0x101a879c)R(0x003b,0x39094332,0x30b9afa5,0x278a9bd3,0x212eccf4)R(0x003c,0x336b94b0,0x3dba0d7a,0x3df98294,0x3f691dc9)R(0x003d,0x1c6ab7dd,0x140c737b,0x162e3319,0x0e6de2c8)R(0x003e,0x184d2373,0x179b97b4,0x2e68d03a,0x2b1a6039)R(0x003f,0x276bdc50,0x208d5c84,0x1e9df8ad,0x30677c4a)\nR(0x0040,0x181a97d2,0x1317dfd3,0x18349bbd,0x1e238ba7)R(0x0041,0x18e35f91,0x1bb8fbf6,0x1a5b93bf,0x19796feb)R(0x0042,0x11183fc4,0x25d62be8,0x1f454be0,0x089b5f12)R(0x0043,0x09cd6280,0x166f0aba,0x262ee6ed,0x29de6f01)R(0x0044,0x0b97ef89,0x113737c2,0x18b613e2,0x20f4bbd2)R(0x0045,0x24aeeaf4,0x26af8e7c,0x280fb612,0x185fbde0)R(0x0046,0x22afb280,0x2bbbd869,0x0dcd20f9,0x243bb840)R(0x0047,0x2af8cc21,0x3495e490,0x31655875,0x2ee5d850)R(0x0048,0x2be54845,0x27b56c2a,0x29152038,0x2d340479)R(0x0049,0x3504f0b3,0x34f6ec83,0x3717d09e,0x1b9b4bcc)R(0x004a,0x372c3adf,0x317b3776,0x262c2ba7,0x1a3c9b97)R(0x004b,0x23dcf473,0x34c7a07b,0x3bd86907,0x3b5c1e10)R(0x004c,0x39ab712f,0x0edbe75f,0x091bd703,0x10ae52c2)R(0x004d,0x04bbae7e,0x03abaa1f,0x132c8f6d,0x12ab5b9b)R(0x004e,0x30d8c44f,0x2a19b026,0x26ba7025,0x210bdc40)R(0x004f,0x1e1ce46d,0x1bdd8494,0x21bc2bb3,0x271b9fb9)\nR(0x0050,0x2da897cc,0x3205cb8c,0x2eb70bc1,0x1e6b5fce)R(0x0051,0x1ae937f2,0x16b5bfd3,0x0a26ab6b,0x2393d7b0)R(0x0052,0x1fe2db87,0x071452da,0x0207aab2,0x032a8a95)R(0x0053,0x08dcd6a7,0x14fc238f,0x265e6321,0x29ae9eef)R(0x0054,0x26cecaf5,0x05a6df18,0x0a06135e,0x10651795)R(0x0055,0x18a413ad,0x1db2df86,0x299df72e,0x247f46c4)R(0x0056,0x2b9f6a2a,0x2fdee62e,0x126e86c7,0x07bd31fe)R(0x0057,0x2c2d4f48,0x1e6de757,0x27c9fc20,0x0549c8fd)R(0x0058,0x0f480c4b,0x26290c0e,0x24478805,0x29861826)R(0x0059,0x2f943488,0x2be3fc6f,0x3a4624f5,0x2664883d)R(0x005a,0x2035441e,0x22350825,0x24c3a059,0x2c214939)R(0x005b,0x35a32d28,0x3a051918,0x390768c3,0x3118ac51)R(0x005c,0x10cba77f,0x294f923f,0x252ee6f2,0x188ebef5)R(0x005d,0x0e2dc2d1,0x235af427,0x2fc70847,0x2d08742d)R(0x005e,0x32ca307a,0x2d0f0987,0x26ce78e9,0x06dc4e9a)R(0x005f,0x03db7266,0x031b4a3b,0x0119f622,0x00796603)\nR(0x0060,0x00084a0a,0x0017cddf,0x0149aa5d,0x0017d5dd)R(0x0061,0x27296c15,0x24d9f415,0x225ad022,0x1eabc43d)R(0x0062,0x1b2c9864,0x170cbc7d,0x134bf78a,0x23ec1bb1)R(0x0063,0x2fdaef91,0x3757ab5b,0x3785df3c,0x2ec863c4)R(0x0064,0x253987ee,0x2194cfd3,0x1652fb6e,0x0565caf5)R(0x0065,0x24926b66,0x1da1631c,0x08034a9a,0x02455654)R(0x0066,0x02b76acb,0x0848e352,0x1627a3e5,0x20baafe1)R(0x0067,0x2afc3b8b,0x2aadbf36,0x307c3359,0x02e65eb8)R(0x0068,0x062542f5,0x0b03f71f,0x12a2df49,0x1511a700)R(0x0069,0x1df1671f,0x3a19bb11,0x393be6bc,0x3dbad22f)R(0x006a,0x3d7a667b,0x0e5dcad2,0x046be1b8,0x3668736a)R(0x006b,0x2c8b4fa3,0x276d0f79,0x1a6d6b6c,0x25dc2054)R(0x006c,0x1dc86c01,0x07383cbc,0x0dd5e070,0x17f47c45)R(0x006d,0x28543451,0x320bcca7,0x2244e029,0x21d51423)R(0x006e,0x2763d45b,0x2b73009c,0x27434873,0x35b65498)R(0x006f,0x22c3e44a,0x1ce4d42c,0x1725f425,0x19e4e032)\nR(0x0070,0x1ea10107,0x21a06165,0x2ac1d0ed,0x31246892)R(0x0071,0x2cf7a82c,0x2688900c,0x0028ba1b,0x1fefd199)R(0x0072,0x1bbfd648,0x111eea5b,0x083d463b,0x1e581800)R(0x0073,0x28572c14,0x1d7ac021,0x222cfc71,0x1aaee90f)R(0x0074,0x047c0e06,0x028b0ddf,0x00c961be,0x00083dfa)R(0x0075,0x002895d8,0x00475a36,0x00f6724c,0x01961999)R(0x0076,0x0156b188,0x01d6e562,0x01b70166,0x20989c01)R(0x0077,0x21c96408,0x209a7819,0x1deb9438,0x195c0452)R(0x0078,0x138cf0a3,0x128af457,0x01f9569a,0x181acbce)R(0x0079,0x2bf963d1,0x31d59f8b,0x31347f6f,0x2bcad7b6)R(0x007a,0x2a069bdc,0x32789b9e,0x36846f19,0x2351631a)R(0x007b,0x13915acc,0x03553e90,0x2490b2c2,0x1df03a72)R(0x007c,0x0cb21a9c,0x0683423f,0x0d41d27d,0x071456dc)R(0x007d,0x0c36d38a,0x166557c9,0x1e0593e5,0x2327ebfc)R(0x007e,0x2eb743c2,0x31da0393,0x38584b49,0x0195aa33)R(0x007f,0x0454a68e,0x09034ec0,0x0dd252d5,0x11613e8e)\nR(0x0080,0x1ad05a7d,0x3cf77ed5,0x3ef8ba73,0x3fd83a1c)R(0x0081,0x3e069293,0x087cf68a,0x039a3944,0x385452e8)R(0x0082,0x35d73370,0x2a2c039a,0x234e5b30,0x2f0c775b)R(0x0083,0x2eec336a,0x0dcd72ea,0x24ff795e,0x11eddcf7)R(0x0084,0x03b84d10,0x14a42065,0x0a373c8b,0x1124e867)R(0x0085,0x19332477,0x21225896,0x2ca1a514,0x38e4f101)R(0x0086,0x3d1b01ab,0x32ee65d4,0x22d2489b,0x2213146c)R(0x0087,0x1ea31c6a,0x279208c0,0x285260ad,0x2392f076)R(0x0088,0x27e67c19,0x1d039058,0x13951c4d,0x10d59058)R(0x0089,0x15159038,0x15e248bf,0x19c049a1,0x17f09570)R(0x008a,0x1d61d0bd,0x23b49834,0x2287d001,0x01079582)R(0x008b,0x156f69a6,0x0c3e35c0,0x071cc59d,0x12484c31)R(0x008c,0x1928b80d,0x111c2090,0x179d84a6,0x0f3df12c)R(0x008d,0x04ab997e,0x036a414c,0x05297cfa,0x002885d8)R(0x008e,0x001885ff,0x001891eb,0x00e70a69,0x00b68234)R(0x008f,0x00f605f7,0x001765f4,0x0037e5c4,0x01778969)\nR(0x0090,0x1d37c802,0x1ca81002,0x1df89402,0x1e690804)R(0x0091,0x1cfa881d,0x167a2c2b,0x117c6c9a,0x0dccb4db)R(0x0092,0x0db9a469,0x00082deb,0x0567af1b,0x21b62ff0)R(0x0093,0x26c3efaa,0x212ba7c6,0x25eb9fbd,0x318a2b93)R(0x0094,0x1ca52fdb,0x3a171f20,0x3b440a4f,0x34b1fa38)R(0x0095,0x22702255,0x12811a8f,0x12c23318,0x04044a49)R(0x0096,0x23501225,0x1f5009cf,0x10b0f9fd,0x1560965c)R(0x0097,0x13c0ee8b,0x1fc072a9,0x1881e332,0x23a2ab77)R(0x0098,0x2873f7a3,0x2f23f770,0x34868b7c,0x37858732)R(0x0099,0x039491a6,0x0493ddf5,0x0822da57,0x0b821a70)R(0x009a,0x0ed13e0d,0x15a07223,0x1d9009e4,0x3cd5eaad)R(0x009b,0x3f77624a,0x3fc765e4,0x3fc73609,0x38c2f20f)R(0x009c,0x03bbb5e7,0x05e850d7,0x32c191cd,0x38f412c3)R(0x009d,0x37a6df4e,0x25cd576f,0x1d2ed305,0x2c9d5343)R(0x009e,0x369af332,0x352b8336,0x2ded4f36,0x0c8e1a6b)R(0x009f,0x2dbf360d,0x1b9f916e,0x079c012f,0x0176618e)\nR(0x00a0,0x04f4417b,0x1790bd56,0x0e25ec6c,0x14c48057)R(0x00a1,0x1ef26492,0x256188de,0x3fa80640,0x389cda63)R(0x00a2,0x25c0d131,0x25e13104,0x1cb1d0bf,0x1bd1a8ce)R(0x00a3,0x23b0b138,0x2711111a,0x21d168de,0x1ae214b0)R(0x00a4,0x1f46d005,0x11435ca7,0x0b14ccb6,0x0ed40ca1)R(0x00a5,0x14750849,0x1363ac82,0x1610899f,0x1670a976)R(0x00a6,0x162204d1,0x1b74b432,0x01788d6a,0x091c210f)R(0x00a7,0x09990898,0x082a74d0,0x0d3a407b,0x011999a9)R(0x00a8,0x0a6c08ed,0x003739e2,0x00180220,0x0066c1e9)R(0x00a9,0x0007e9f5,0x0145f1c3,0x0018b1fd,0x00792dd1)R(0x00aa,0x1ac6f40b,0x1a57bc08,0x1b381005,0x1a089c0a)R(0x00ab,0x1518541f,0x123ae858,0x0dcd04f0,0x00c8f19f)R(0x00ac,0x01375685,0x13c48fa2,0x0288febb,0x095a7344)R(0x00ad,0x229927f7,0x3106d3a9,0x34a3c317,0x3471e227)R(0x00ae,0x36d289b1,0x31b159ee,0x24a0cacf,0x2972a75b)R(0x00af,0x1d3102f3,0x0ad20dcb,0x24b0399f,0x16d0e943)\nR(0x00b0,0x178061b0,0x24104a76,0x224005ed,0x23a0bacd)R(0x00b1,0x24e08aa6,0x26009eaa,0x27c17309,0x2c32532d)R(0x00b2,0x35f3fb0b,0x07d4151f,0x07635d73,0x095259f2)R(0x00b3,0x0d91cd77,0x160085a5,0x1f306561,0x3e95c225)R(0x00b4,0x39c3c282,0x3d94fa02,0x037a2d47,0x08a66caf)R(0x00b5,0x2a916515,0x354211cf,0x3a644aa3,0x39169f2f)R(0x00b6,0x20ee8327,0x1e2ed308,0x296d8f4d,0x320c633a)R(0x00b7,0x2b4e6ef2,0x0f7ed1db,0x37ecca8f,0x31fe9229)R(0x00b8,0x22cfd9ad,0x125e9d46,0x045ad54a,0x0c91a61d)R(0x00b9,0x00f699a7,0x0d3181f6,0x18404227,0x238015d2)R(0x00ba,0x0fe43c8c,0x1ab3406b,0x21529087,0x2ad1bcf4)R(0x00bb,0x3692d692,0x3c183af1,0x3011558c,0x27609d63)R(0x00bc,0x26706d7e,0x2710599c,0x1f307d4e,0x17b0f931)R(0x00bd,0x10b2150d,0x0a336118,0x1301a11a,0x17b3287e)R(0x00be,0x19b57c23,0x1515583c,0x14d11147,0x18d041c0)R(0x00bf,0x1970b944,0x156214d2,0x15d47851,0x0149a19c)\nR(0x00c0,0x05dbd95f,0x002741f1,0x0165a1ef,0x0017e5de)R(0x00c1,0x001851e4,0x005919df,0x00378630,0x00f9f1f0)R(0x00c2,0x0109f1e1,0x15468826,0x16778818,0x16e7dc14)R(0x00c3,0x13c77c27,0x14f77420,0x13d8d029,0x0b6b94c2)R(0x00c4,0x0048ede9,0x00288a20,0x0048763a,0x07b77f4b)R(0x00c5,0x249417b7,0x2931af14,0x2ab08638,0x303145a2)R(0x00c6,0x36023a11,0x34335b06,0x35a4a734,0x32820aa7)R(0x00c7,0x1f9005df,0x25e02615,0x20403a7a,0x2310bace)R(0x00c8,0x27f126e6,0x38a2f9cc,0x28c05211,0x0588e8e5)R(0x00c9,0x0a6510b7,0x3562419e,0x3a13a664,0x3ab69709)R(0x00ca,0x210ef6f8,0x20cf06f1,0x280df33b,0x2dddc712)R(0x00cb,0x280f8671,0x178f455d,0x3a8be687,0x3be7caf7)R(0x00cc,0x359dde19,0x28ef8daa,0x1a6f6555,0x0eedd527)R(0x00cd,0x043ac148,0x13f09a1c,0x17b04a24,0x16a06a42)R(0x00ce,0x02d59171,0x21d05e96,0x11b350a5,0x1a4248a4)R(0x00cf,0x2a11f0da,0x26b18ce4,0x3353330b,0x21d011c3)\nR(0x00d0,0x1f1140ed,0x20d3a452,0x2c040070,0x1d138459)R(0x00d1,0x1cf021ae,0x2720599d,0x3002dcd6,0x1a535869)R(0x00d2,0x13744868,0x002899da,0x0116e26f,0x00387632)R(0x00d3,0x001855e1,0x00a931bd,0x013a05cd,0x02182eb4)R(0x00d4,0x021882b2,0x006931ea,0x001895ed,0x1475b439)R(0x00d5,0x1346f42e,0x14f72c22,0x08f8889e,0x0ba7a075)R(0x00d6,0x00084a06,0x0017ba25,0x0ce39b2b,0x1ae0a6b9)R(0x00d7,0x1c700de2,0x30f23ee3,0x26602ddd,0x3514ef49)R(0x00d8,0x39049ae7,0x3892edd7,0x30617975,0x0b66b480)R(0x00d9,0x3311e184,0x38e3021f,0x3b8a42d6,0x25cf46bb)R(0x00da,0x281ebeef,0x2bcefaa1,0x28cfae06,0x1e6e64ce)R(0x00db,0x3c16dee7,0x3c3b4e70,0x32e31309,0x38bcf63f)R(0x00dc,0x2d7f2dc8,0x1b5f694f,0x0ecdf135,0x04aa0117)R(0x00dd,0x1d0009f9,0x1b701606,0x15807623,0x1330ade6)R(0x00de,0x20507aac,0x0f31f137,0x1774e43c,0x1b9220aa)R(0x00df,0x24f174e3,0x30118962,0x2bd2e4a6,0x2e6288d9)\nR(0x00e0,0x38f34d94,0x3592916e,0x3973a17c,0x33b410c4)R(0x00e1,0x29b5dc2b,0x1e26b407,0x0038363b,0x00288229)R(0x00e2,0x0218aab1,0x0088e9b8,0x01a9d591,0x0018a1ec)R(0x00e3,0x00786a51,0x00c89a67,0x00286dd8,0x001875ee)R(0x00e4,0x16e72417,0x0d17c063,0x0007c606,0x01958a23)R(0x00e5,0x01d55a16,0x1dc29375,0x2b23fb93,0x3334474a)R(0x00e6,0x35c2565d,0x3251b987,0x3412dd1e,0x3b9415c3)R(0x00e7,0x32ae5259,0x2b1f4274,0x2d4ec558,0x32c2fb04)R(0x00e8,0x38b4ff04,0x3d596eb3,0x1d806298,0x39fbd2a8)R(0x00e9,0x32ce623d,0x23afd1aa,0x166f315e,0x0ced6522)R(0x00ea,0x08f79c9c,0x1d2015c7,0x191035d9,0x0f117589)R(0x00eb,0x0f9121e7,0x19111d12,0x28234c76,0x30e2610b)R(0x00ec,0x2d23848f,0x2b037082,0x2b50d574,0x31e179b3)R(0x00ed,0x35128163,0x2b6260c4,0x28454431,0x20472c02)R(0x00ee,0x1837f00f,0x01c9129a,0x00c9b613,0x01989299)R(0x00ef,0x01ea1591,0x007939d7,0x0018a212,0x01c84959)\nR(0x00f0,0x0038d9eb,0x0007edff,0x00a6da46,0x0e93833e)R(0x00f1,0x28a2173b,0x29605e20,0x2050417c,0x2b8240cf)R(0x00f2,0x398c5178,0x2d31caf2,0x3382eaf0,0x3bf7aaf5)R(0x00f3,0x3c5a12c3,0x354d7e90,0x2a3f8e0f,0x1d4fc998)R(0x00f4,0x119e1512,0x13960039,0x19509d59,0x14e0b58d)R(0x00f5,0x0e61f546,0x1310c1b7,0x1be1c4c4,0x25838061)R(0x00f6,0x24624c9e,0x1d803592,0x2a80a98c,0x16614119)R(0x00f7,0x1924c837,0x05f7d0d5,0x0058ca34,0x01da3a5e)R(0x00f8,0x01eab601,0x007935d4,0x0018aa0a,0x00082a05)R(0x00f9,0x0076e632,0x0d31d27d,0x0175a5e3,0x0ee300db)R(0x00fa,0x1890b551,0x3b145686,0x3b2be263,0x3c64d987)R(0x00fb,0x308eca2a,0x249fd9c5,0x199dfcbd,0x2004d429)R(0x00fc,0x1a3164ec,0x13d15d2d,0x21d2748f,0x04b5c11c)R(0x00fd,0x01d5e596,0x012609c6,0x00c7259e,0x0079421b)R(0x00fe,0x005919ef,0x001805da,0x00083df0,0x0007c1f9)R(0x00ff,0x00377dcb,0x1e5158e3,0x36580091,0x2b8d3cac)\nR(0x0100,0x00000000,0x00000000,0x00000000,0x00000000)  }\n  return r;\n} \n \nivec4 resolution_data(in int i) {\n  return ivec4(int(iResolution.x), int(iResolution.y), 0, 0);\n}\n\nvec4 encode_int(in int x) {\n    ivec4 col = (ivec4(x)>>ivec4(0,8,16,24))&255;\n    return vec4(col)/255.0;\n}\n\n#define lookup(offset, size, FUNC)                      \\\n    if(index >= offset && index < offset + size) {      \\\n        fragColor = encode_int(FUNC((index-offset)/4)[(index-offset)%4]); \\\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Test whether data should be sent. Data is sent if:\n    //  this is the first frame or\n    //  rendering area was resized (previous width/height stored in first pixel)\n    bool reset = (iFrame < 10);\n    reset = reset || (get_data(resolution_offset,0) != int(iChannelResolution[0].x));\n    reset = reset || (get_data(resolution_offset,1) != int(iChannelResolution[0].y));\n    if(reset) {  \n       ivec2 uv = ivec2(fragCoord); \n       int index = uv.x + uv.y * int(iResolution.x); \n       fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n       lookup(resolution_offset, resolution_data_size, resolution_data);\n       lookup(AABB_offset,       AABB_data_size,       AABB_data);\n       lookup(points_offset,     points_data_size,     points_data);\n       lookup(normals_offset,    normals_data_size,    normals_data);\n    } else {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n}\n\n\n/*\n\n// MeshCompiler [Bruno Levy Jan 2020]\n// Converts a .obj (Alias|Wavefront) tri mesh into an AABB, encoded in GLSL, for ShaderToy.\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\n// -------- GLSL-compatible types (in 20 lines) -----------------------------------------------------------------------------------------------\n\ntemplate <class T> class gvec3 {\npublic:\n    gvec3() {  }\n    gvec3(T x_in, T y_in, T z_in) : x(x_in), y(y_in), z(z_in) {  }\n    T& operator[](int i)             { return (&x)[i]; }\n    const T& operator[](int i) const { return (&x)[i]; }\n    T x,y,z;\n};\ntypedef gvec3<double> vec3; typedef gvec3<int> ivec3;\ntemplate <class T> inline gvec3<T> operator+(gvec3<T> u, gvec3<T> v) { return gvec3<T>(u.x+v.x,u.y+v.y,u.z+v.z); }\ntemplate <class T> inline gvec3<T> operator-(gvec3<T> u, gvec3<T> v) { return gvec3<T>(u.x-v.x,u.y-v.y,u.z-v.z); }\ntemplate <class T> inline gvec3<T> operator*(T s, gvec3<T> u) { return gvec3<T>(s*u.x, s*u.y, s*u.z); }\ntemplate <class T> inline gvec3<T> min(gvec3<T> u, gvec3<T> v) { return gvec3<T>(std::min(u.x,v.x),std::min(u.y,v.y),std::min(u.z,v.z)); }\ntemplate <class T> inline gvec3<T> max(gvec3<T> u, gvec3<T> v) { return gvec3<T>(std::max(u.x,v.x),std::max(u.y,v.y),std::max(u.z,v.z)); }\ninline double dot(vec3 u, vec3 v) { return u.x*v.x + u.y*v.y + u.z*v.z; }\ninline vec3 cross(vec3 u, vec3 v) { return vec3(u.y*v.z-u.z*v.y, u.z*v.x-u.x*v.z, u.x*v.y-u.y*v.x); }\ninline double length(vec3 u)      { return ::sqrt(dot(u,u)); }\ninline vec3 normalize(vec3 u)     { return (1.0 / length(u)) * u; }\n\n// -------- Encode/Decode ------------------------------------------------------------------------------------------------------------------\n\n  int encode_vertex(ivec3 p) { return p.x | (p.y << 10) | (p.z << 20); }\nivec3 decode_vertex(int xyz) { return ivec3(xyz & 1023, (xyz >> 10) & 1023, (xyz >> 20) & 1023); }\n\nint encode_vertex(vec3 p, vec3 bbox_min, vec3 bbox_max) {\n    double x = (p.x - bbox_min.x) / (bbox_max.x - bbox_min.x);\n    double y = (p.y - bbox_min.y) / (bbox_max.y - bbox_min.y);\n    double z = (p.z - bbox_min.z) / (bbox_max.z - bbox_min.z);\n    int ix = int(x * 1023.0); int iy = int(y * 1023.0); int iz = int(z * 1023.0);\n    return ix | (iy << 10) | (iz << 20);\n}\n\nivec3 encode_facet(vec3 p1, vec3 p2, vec3 p3, vec3 bbox_min, vec3 bbox_max) {\n    return ivec3(\n\tencode_vertex(p1, bbox_min, bbox_max),\n\tencode_vertex(p2, bbox_min, bbox_max),\n\tencode_vertex(p3, bbox_min, bbox_max)\t    \n    );\n}\n\n// -------- Mesh geometry //----------------------------------------------------------------------------------------------------------\n\nivec3 facet_center(ivec3 f) { return decode_vertex(f.x) + decode_vertex(f.y) + decode_vertex(f.z); }\n\n// Computes the (floating-point) bbox of a pointset\nvoid get_bbox(const std::vector<vec3>& pts, vec3& bbox_min, vec3& bbox_max) { \n    bbox_min = pts[0]; bbox_max = pts[0]; \n    for(int i=1; i<pts.size(); ++i) {\n\tbbox_min = min(bbox_min, pts[i]); bbox_max = max(bbox_max, pts[i]);\t\n    }\n}\n\n// Computes the (integer) bbox of a triangle\nvoid get_facet_bbox(ivec3 f, ivec3& bbox_min, ivec3& bbox_max) {\n    bbox_min = decode_vertex(f.x); bbox_max = decode_vertex(f.x);\n     ivec3 p = decode_vertex(f.y); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);\n           p = decode_vertex(f.z); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);\n}\n\n// -------- I/O //-------------------------------------------------------------------------------------------------------------------\n\nstd::string format(double x) { static char buff[300]; sprintf(buff,\"%-6.6f\",x); return std::string(buff); } // 6.6 digits\nstd::string format_int(int x) { static char buff[300]; sprintf(buff,\"0x%08x\",x); return buff; }             // hexa, 8 digits\nstd::string format_small_int(int x) { static char buff[300]; sprintf(buff,\"0x%04x\",x); return buff; }       // hexa, 4 digits\n\n// Generates a GLSL function that encodes an array of ivec3, as a (huge) switch statement\n// (It is stupid, I know, but this is the only way I found to send a big array to ShaderToy).\nvoid gen_ivec4_func(std::ostream& out, int* data, int nb, std::string name) {\n    out << \"const int \" << name << \"_size = \" << nb << \";\" << std::endl;\n    out << \"ivec4 \" << name << \"(in int i) {\" << std::endl;\n    out << \"#  ifdef R\"   << std::endl;\n    out << \"#    undef R\" << std::endl;\n    out << \"#  endif\"     << std::endl;\n    out << \"#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;\" << std::endl;\n    out << \"  ivec4 r;\" << std::endl;\n    out << \"  switch(i) {\" << std::endl;\n    for(int i=0; i<=nb/4; ++i) {\n\tint a = ((i*4)   < nb) ? data[i*4  ] : 0 ;\n\tint b = ((i*4+1) < nb) ? data[i*4+1] : 0 ;\n\tint c = ((i*4+2) < nb) ? data[i*4+2] : 0 ;\n\tint d = ((i*4+3) < nb) ? data[i*4+3] : 0 ;\n\tout << \"R(\" << format_small_int(i) << \",\"\n\t    << format_int(a) << \",\" << format_int(b) << \",\" << format_int(c) << \",\" << format_int(d) << \")\";\n       if(!((i+1)%16)) { out << std::endl; }\n    }\n    out << \"  }\" << std::endl;\n    out << \"  return r;\" << std::endl;\n    out << \"}\" << std::endl;\n}\n\n// Loads a mesh from a .obj (Alias|Wavefront) file. Gets the point coordinates and triangle vertex indices.\nbool load_mesh(const std::string& filename, std::vector<vec3>& points, std::vector<ivec3>& triangles) {\n    points.clear();\n    triangles.clear();\n    FILE* F = fopen(filename.c_str(),\"r\");\n    if(!F) { return false;  }\n    char* line=nullptr;\n    size_t linelen=0;\n    int lineno = 0;\n    while(getline(&line,&linelen,F) >= 0) {\n\t++lineno;\n\tswitch(line[0]) {\n\t    case 'v': {\n\t\tfloat x,y,z;\n\t\tbool ok = (sscanf(line+1, \"%f %f %f\", &x, &y, &z) == 3);\n\t\tif(!ok) {\n\t\t    std::cerr << lineno << \": malformed vertex\" << std::endl;\n\t\t    std::cerr << line << std::endl;\n\t\t    return false;\n\t\t}\n\t\tpoints.push_back(vec3(double(x),double(y),double(z)));\n\t    } break;\n\t    case 'f': {\n\t\tint v1 =-1,v2 =-1,v3 =-1;\n\t\tint vt1=-1,vt2=-1,vt3=-1;\n\t\tint vn1=-1,vn2=-1,vn3=-1;\n\t\tbool ok = false;\n\t\tok = ok || (sscanf(line+1,\"%d %d %d\",                   &v1,&v2,&v3                              ) == 3);\n\t\tok = ok || (sscanf(line+1,\"%d/%d %d/%d %d/%d\",          &v1,&vn1,&v2,&vn2,&v3,&vn3               ) == 6);\n\t\tok = ok || (sscanf(line+1,\"%d/%d/%d %d/%d/%d %d/%d/%d\", &v1,&vn1,&vt1,&v2,&vn2,&vt2,&v3,&vn3,&vt3) == 9);\n\t\tok = ok || (sscanf(line+1,\"%d//%d %d//%d %d//%d\",       &v1,&vt1,&v2,&vt2,&v3,&vt3               ) == 6);\n\t\tif(!ok || v1<1 || v2<1 || v3<1) {\n\t\t    std::cerr << lineno << \": malformed facet\" << std::endl;\n\t\t    std::cerr << line << std::endl;\n\t\t    return false;\n\t\t}\n\t\ttriangles.push_back(ivec3(v1-1,v2-1,v3-1));\n\t    } break;\n\t}\n    }\n    free(line);\n    fclose(F);\n    return true;\n}\n\n// -----------------------------------------------------------------------------------------------------------------------\n\nclass Mesh {\npublic:\n    // indirect=false, triangle contain encoded vertex geometries\n    // indirect=true,  triangle contain vertices indices   \n    bool load(const std::string& filename, bool indirect_in) {\n\tindirect = indirect_in; \n\tstd::vector<vec3> fpoints;\n\tif(!load_mesh(filename, fpoints, triangles)) { return false; }\n\t::get_bbox(fpoints, fbbox_min, fbbox_max);\n\tif(indirect) {\n\t    points.resize(fpoints.size());\n\t    for(int v=0; v<points.size(); ++v) {\n\t\tpoints[v] = encode_vertex(fpoints[v], fbbox_min, fbbox_max);\n\t    }\n\t    std::vector<vec3> fnormals(points.size(), vec3(0.0, 0.0, 0.0));\n\t    for(int t=0; t<triangles.size(); ++t) {\n\t\tivec3 T = triangles[t];\n\t\tvec3 p1 = fpoints[T.x];\n\t\tvec3 p2 = fpoints[T.y];\n\t\tvec3 p3 = fpoints[T.z];\n\t\tvec3 N = cross(p2-p1, p3-p1);\n\t    fnormals[T.x] = fnormals[T.x]+N;\n\t\tfnormals[T.y] = fnormals[T.y]+N;\n\t\tfnormals[T.z] = fnormals[T.z]+N;\t\n\t    }\n\t    normals.resize(fnormals.size());\n\t    for(int v=0; v<points.size(); ++v) {\n\t\tvec3 N = normalize(fnormals[v]);\n\t\tnormals[v] = encode_vertex(N, vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0));\n\t    }\n\t} else {\n\t    for(int t=0; t<triangles.size(); ++t) {\n\t\tivec3 T = triangles[t];\n\t\ttriangles[t] = ivec3(\n\t\t    encode_vertex(fpoints[T.x], fbbox_min, fbbox_max),\n\t\t    encode_vertex(fpoints[T.y], fbbox_min, fbbox_max),\n\t\t    encode_vertex(fpoints[T.z], fbbox_min, fbbox_max)\n\t\t);\n\t    }\n\t}\n\tinit_AABB(0, triangles.size()); \t\n\treturn true;\n    }\n\n    void show_AABB() { show_AABB(0, AABB.size(), 0); }\n\n    void generate_GLSL(std::ostream& out) {\n       out << \"const vec3 bbox_min = vec3(\" << fbbox_min.x << \",\" << fbbox_min.y << \",\" << fbbox_min.z << \");\" << std::endl;\n       out << \"const vec3 bbox_max = vec3(\" << fbbox_max.x << \",\" << fbbox_max.y << \",\" << fbbox_max.z << \");\" << std::endl;\n\n       gen_ivec4_func(out, &AABB[0].x, AABB.size()*3, \"AABB_data\");\n       //gen_ivec3_func(out, AABB, \"AABB_data\");\t\n       if(indirect) {\n\t   gen_ivec4_func(out, points.data(), points.size(), \"points_data\");\n\t   gen_ivec4_func(out, normals.data(), normals.size(), \"normals_data\");\n       }\n    }\n   \nprotected:\n\n    void show_AABB(int b, int e, int level) {\n\tfor(int i=0; i<3*level; ++i) {\n\t    std::cerr << ' ';\n\t}\n\tivec3 node = AABB[b];\n\tif(node.z == -1) {\n\t    std::cerr << b << \"-\" << e << \" :leaf size=\" << (e-b-1) << std::endl;\n\t} else {\n\t    int coord = node.z & 3;\n\t    int nb = node.z >> 2;\n\t    std::cerr << b << \"-\" << e << \" : \" << coord << \" \" << nb << std::endl;\n\t    b++;\n\t    int m = b + nb;\n\t    show_AABB(b,m,level+1);\n\t    show_AABB(m,e,level+1);\n\t}\n    }\n    \n    void init_AABB(int b, int e) {\n\tivec3 bbox_min, bbox_max;\n\tget_bbox(b, e, bbox_min, bbox_max);\n\tint nb,coord;\n\tif(sort_SAH(b, e, nb, coord)) {\n\t    int m = b + nb;\n\t    int node = AABB.size();\n\t    AABB.push_back(ivec3());\n\t    init_AABB(b, m);\n\t    int new_m = AABB.size();\n\t    init_AABB(m, e);\n\t    AABB[node] = ivec3(encode_vertex(bbox_min), encode_vertex(bbox_max), coord | ((new_m-node-1) << 2));\n\t} else {\n\t    AABB.push_back(ivec3(encode_vertex(bbox_min), encode_vertex(bbox_max), -1));\n\t    for(int i=b; i<e; ++i) {\n\t\tAABB.push_back(triangles[i]);\n\t    }\n\t}\n    }\n    \n    \n    ivec3 triangle(ivec3 F) const { return indirect ? ivec3(points[F.x],points[F.y],points[F.z]) : F; }\n    ivec3 triangle(int f) const { return triangle(triangles[f]); }\n    \n    void sort(int b, int e, int coord) {\n\tstd::sort(\n\t    triangles.begin() + b, triangles.begin() + e,\n\t    [coord,this](ivec3 F1, ivec3 F2) {\n\t\treturn (facet_center(triangle(F1))[coord] < facet_center(triangle(F2))[coord]);\n\t    }\n\t);\n    }\n\n    void get_bbox(int b, int e, ivec3& bbox_min, ivec3& bbox_max) const {\n\tget_facet_bbox(triangle(b), bbox_min, bbox_max);\n\tfor(int i=b+1; i<e; ++i) {\n\t    ivec3 cur_bbox_min, cur_bbox_max;\n\t    get_facet_bbox(triangle(i), cur_bbox_min, cur_bbox_max);\n\t    bbox_min = min(bbox_min, cur_bbox_min); bbox_max = max(bbox_max, cur_bbox_max);\n\t}\n    }\n\n    double bbox_area(ivec3 bbox_min, ivec3 bbox_max) {\n\tdouble l1 = (double(bbox_max.x) - double(bbox_min.x)) * (fbbox_max.x - fbbox_min.x) / 1023.0;\n\tdouble l2 = (double(bbox_max.y) - double(bbox_min.y)) * (fbbox_max.y - fbbox_min.y) / 1023.0;\n\tdouble l3 = (double(bbox_max.z) - double(bbox_min.z)) * (fbbox_max.z - fbbox_min.z) / 1023.0;\n\treturn l1*l2 + l2*l3 + l3*l1;\n    }\n\n    // Returns true if node should be split\n    // split_nb: number of facets in left subtree\n    // split_coord: coordinate along which bbox is split\n    bool sort_SAH(int b, int e, int& split_nb, int& split_coord) {\n\tconst double c_t = 30.0; // Cost of traversing a node\n\tconst double c_i = 1.0;  // Cost of computing an intersection\n\n\t// bbox of sequence [b..i-b[\n\tstd::vector<ivec3> bbox_min_1(e-b);\n\tstd::vector<ivec3> bbox_max_1(e-b);\n\n\t// bbox of sequence [i..e[\n\tstd::vector<ivec3> bbox_min_2(e-b);\n\tstd::vector<ivec3> bbox_max_2(e-b);\n    \n\tdouble best_c = 1e30;\n\tint best_coord = -1;\n\tint best_m = -1;\n\tfor(int coord=0; coord<3; ++coord) {\n\t    sort(b, e, coord);\n\t    get_facet_bbox(triangle(b), bbox_min_1[0], bbox_max_1[0]);\n\t    for(int i=b+1; i<e; ++i) {\n\t\tivec3 cur_bbox_min, cur_bbox_max;\n\t\tget_facet_bbox(triangle(i), cur_bbox_min, cur_bbox_max);\n\t\tbbox_min_1[i-b] = min(bbox_min_1[i-1-b], cur_bbox_min);\n\t\tbbox_max_1[i-b] = max(bbox_max_1[i-1-b], cur_bbox_max);\t\n\t    }\n\t    get_facet_bbox(triangle(e-1), bbox_min_2[e-1-b], bbox_max_2[e-1-b]);\n\t    for(int i=e-2; i>=b; --i) {\n\t\tivec3 cur_bbox_min, cur_bbox_max;\n\t\tget_facet_bbox(triangle(i), cur_bbox_min, cur_bbox_max);\n\t\tbbox_min_2[i-b] = min(bbox_min_2[i+1-b], cur_bbox_min);\n\t\tbbox_max_2[i-b] = max(bbox_max_2[i+1-b], cur_bbox_max);\t\n\t    }\n\t    double Sparent = bbox_area(bbox_min_1[e-b-1], bbox_max_1[e-b-1]);\n\t    for(int i=b+1; i<e-1; ++i) {\n\t\tdouble Sleft  = bbox_area(bbox_min_1[i-1-b], bbox_max_1[i-1-b]);\n\t\tdouble Sright = bbox_area(bbox_min_2[i-b],   bbox_max_2[i-b]  );\n\t\tdouble c = c_t + (Sleft  / Sparent) * double(i-b)*c_i + (Sright / Sparent) * double(e-i)*c_i ;\n\t\tif(c < best_c) { best_c = c; best_coord = coord; best_m = i; }\n\t    }\n\t}\n\tif(best_coord != 2) { sort(b, e, best_coord); }\n\tsplit_coord = best_coord; split_nb = best_m - b;\n\treturn (best_c < double(e-b)*c_i);\n    }\n\n    \n    vec3 fbbox_min;\n    vec3 fbbox_max;\n    std::vector<ivec3> triangles;\n    bool indirect;\n    std::vector<int> points;\n    std::vector<int> normals;\n    std::vector<ivec3> AABB;\n};\n\nint main(int argc, char** argv) {\n    std::string filename;\n    bool indirect = false;\n    bool show = false;\n    for(int i=1; i<argc; ++i) {\n       if(argv[i][0] == '-') {\n\t   if(!strcmp(argv[i],\"-indirect\")) {\n\t       indirect = true;\n\t   } else if(!strcmp(argv[i],\"-show\")) {\n\t       show = true;\n\t   } else {\n\t     std::cerr << argv[0] << \" \" \n\t               << argv[i] \n\t               << \": invalid option\" \n\t               << std::endl;\n\t     return -1;\n\t  }\n       } else {\n\t  filename = argv[i];\n       }\n    }\n   \n    if(filename == \"\") {\n\tstd::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n\treturn -1;\n    }\n\n    Mesh M;\n    if(!M.load(filename,indirect)) {\n\treturn -1;\n    }\n\n    if(show) { M.show_AABB(); }\n\n    M.generate_GLSL(std::cout);\n \n    return 0;\n}\n\n*/\n\n ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 679, 715, 715, 756], [758, 841, 876, 876, 1005], [1007, 1043, 1066, 1066, 1121], [1123, 1160, 1184, 1184, 1334], [1336, 1547, 1578, 1578, 1713], [1907, 1907, 1970, 1970, 2268], [2270, 2270, 2307, 2307, 2410], [2628, 2628, 2657, 2657, 2724], [2726, 2726, 2772, 2772, 2816], [2818, 2818, 2890, 2890, 2952], [2954, 3286, 3416, 3416, 3772], [3774, 3912, 3969, 3969, 4508], [4511, 4611, 4727, 4727, 5015], [5241, 5241, 5261, 5261, 5289], [5291, 5291, 5328, 5328, 5399], [5401, 5401, 5439, 5439, 5508], [5510, 5713, 5761, 5761, 7212], [7216, 7292, 7348, 7348, 8111], [8113, 8113, 8133, 8133, 8246], [8248, 8248, 8305, 8305, 9073]], "test": "untested"}
{"id": "wlGGRD", "name": "by the water", "author": "zxxuan1001", "description": "water, sky, nice sunshine, and stuff.", "tags": ["reflection", "water", "transparent"], "likes": 12, "viewed": 664, "published": 3, "date": "1581150332", "time_retrieved": "2024-07-30T21:25:18.496756", "image_code": "#define EPSILON 0.0001\n#define SUN_COLOR vec3(1.2, 1.1, 0.8) \n#define SUN_POS vec3(500.0, 160.0, 400.0)\n#define SUN_DIR vec3(0.0,0.8,0.0)\n#define SUN_GLOW vec3(1.2,0.6,0.3)\n#define SKY_COLOR vec3(0.5,0.7,1.0)\n#define OCEAN_COLOR vec3(0.04, 0.2, 0.6)\n#define CLOUD_COLOR vec3(1.0)\n#define MAX_STEP 60\n#define MAX_DIST 30.0\n#define AA 1\n\nfloat noise(in vec2 uv) {\n    return texture(iChannel0, uv/64.0).r;\n}\n\nfloat smoothNoise(in vec2 uv) {\n    vec2 luv = fract(uv); //range from 0.0 to 1.0\n    vec2 id = floor(uv); //the integer part of uv, 0, 1, 2\n    luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n    \n    //get values from the cordinates of a square\n    float bl = noise(id);\n    float br = noise(id + vec2(1.0, 0.0));\n    float tl = noise(id + vec2(0.0, 1.0));\n    float tr = noise(id + vec2(1.0, 1.0));\n    \n    float b = mix(bl, br, luv.x); //interpolate between bl and br\n    float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n    \n    return mix(b, t, luv.y);\n}\n\nfloat fbm4(in vec2 uv) {\n    float amp = 0.5;\n    float f = 2.0;\n    float h = 0.0;\n    float a = 0.0;\n    for (int i = 0; i < 4; i++){\n        h += amp * smoothNoise(uv*f);\n        a += amp;\n        amp *= 0.5;\n        f *= 2.0;\n    }\n    \n    h /= a;\n    return h;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat displacement (vec3 p) \n{\n    return sin(-p.y*0.8);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nconst vec3 SCALE = vec3(18.0, 12.0, 15.0);\nvec4 stuff(vec3 p) {\n    float t = sin(iTime*0.5 + p.x * 0.22 + p.z * 0.13 + p.y * 0.15);\n    p = p - vec3(6.0, 0.8+t*t, 6.0);\n    //vec3 q = p - SCALE * clamp(round(p/SCALE), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    //vec2 id = vec2(floor(q.x/5.0 - 2.5),floor(q.z/5.0 - 2.5));\n    //float fid = id.x*13.3 + id.y*5.7;\n    //float wr = 1.2+0.5*sin(fid);\n    \n    float wr = 1.2;\n    float d = sphereSDF(p, wr) + displacement(p);\n    d *= 0.5;\n    return vec4(d, 3.0, 0.0, 1.0);\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nfloat wave(in vec3 p) \n{\n    float t = iTime * 0.5;\n    float hi = 0.0;\n    hi += 0.15*smoothNoise(vec2(p.x*3.0 + t, p.z*2.5 + t));\n    hi += 0.13*smoothNoise(vec2(p.x*2.2 - 1.5*t, 0.0));\n    hi += 0.11*smoothNoise(vec2(p.x*2.2 - t, p.z*3.2 - t));\n    //hi += 0.001*texture(iChannel0, p.xz*3.0).r;\n    return hi;\n}\n\nvec4 water(in vec3 p, float h) {\n    \n    float hi = wave(p);\n    h += 0.15*hi;\n    float d = p.y - h;\n    return vec4(d, 1.0, 1.0, 0.0);\n}\n\nvec2 rot2D(in vec2 xy, float d)\n{\n    float c = cos(d);\n    float s = sin(d);\n    return vec2(xy.x * c - xy.y * s, xy.x * s + xy.y * c);\n}\n\nvec4 land(in vec3 p, float h) {\n    float hi = 0.0;\n    float wave = 0.8*sin(-p.x*0.1) + 0.8*sin(-p.z*0.17);\n    \n    vec2 xy = rot2D(p.xz, -0.8); \n    //hi += 0.005*smoothNoise(vec2(xy.x*17.37, xy.y*5.5)); //a bit of a sand pattern\n    \n    h += wave ;\n    h += hi;\n    h -= 0.008*texture(iChannel1, p.xz*0.7).r; \n    float d = p.y - h;\n    return vec4(d, 2.0, 0.0, 0.0);\n}\n\nvec4 map(in vec3 p) {\n    vec4 res = vec4(0.0); //distance, material, reflect, refract\n    //p.z -= 1.5;\n    vec4 d0 = land(p, -0.5);\n    vec4 d1 = stuff(p);\n    vec4 d2 = water(p, -0.4);\n    res = sdUnion(d0, d1);\n    res = sdUnion(res, d2); \n    \n    return res;\n}\n\nfloat castRayB(in vec3 ro, in vec3 rd) {\n   float t = 0.01;\n   for ( int i = 0; i < 30; ++i )\n   {\n       vec3 pos = ro + t * rd;\n       vec4 h = stuff( pos );\n       if ( h.x < EPSILON) return t;\n       t += h.x;\n       if (t > MAX_DIST) return MAX_DIST;\n   } \n   return MAX_DIST;\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd)\n{\n   float t = 0.01;\n   vec3 m = vec3(0.0);\n   float tMax = MAX_DIST;\n\n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t * rd;\n       vec4 h = map( pos );\n       m = h.yzw;\n       if ( h.x < EPSILON * t ||  t > tMax)\n       {\n           break;\n       }\n       t += h.x;\n   } \n    \n   if ( t>tMax )\n   {\n       m = vec3(-1.0);\n   }\n   return vec4(t,m);\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n\nvec3 sky2D(vec3 skyColor, vec3 cloudColor, vec2 uv) {\n    vec3 col = vec3(0.0);\n    float t = iTime * 0.1;\n    float n1 = fbm4(vec2(uv.x + t, uv.y - t));\n    col = mix( skyColor, cloudColor, smoothstep(0.2, 0.8, n1));\n    return col;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.16*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.8;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcSky(vec3 ro, vec3 rd) {\n    //from IQ.\n    const float SC = 1e5;\n    //Trace out to a distant XZ plane.\n    float dist = (SC - ro.y)/rd.y; \n    vec2 p = (ro + dist*rd).xz;\n    \n    vec3 sunDir = normalize(SUN_POS - ro);\n    float sun = max(dot(sunDir, rd), 0.0);\n    float core = smoothstep(0.98, 1.0, sun);\n    \n    vec3 skyCol = vec3(0.0);\n    vec3 cloudCol = CLOUD_COLOR;\n    \n    \n    skyCol += 0.5*SUN_COLOR*pow(core, 64.0);\n    skyCol += 0.8*SUN_GLOW*pow(sun, 32.0);\n    skyCol += mix(SUN_GLOW, SKY_COLOR, 2.0*abs(rd.y));//horizontal brightness\n       \n    skyCol = sky2D(skyCol, cloudCol, p*1.2/SC);\n    float grad = smoothstep(0.0, 0.1, rd.y);\n    skyCol = mix(SUN_GLOW, skyCol, grad);\n    return skyCol;\n}\n\nvec3 calcLighting(in vec3 ro, in vec3 rd, in vec4 hit) {\n    vec3 outCol = vec3(0.0);\n    vec3 hitPoint = ro + hit.x * rd;\n    vec3 sunDir = normalize(SUN_POS - ro);\n    vec3 nor = getNormal(hitPoint);\n    \n    // draw water color \n    vec3 waterCol = vec3(0.0);\n    \n    // water reflection\n    vec3 refDir = normalize(reflect(rd, nor));\n    vec3 reflectCol = calcSky(hitPoint, refDir);\n    \n    // water specular\n    vec3 H = normalize(sunDir - rd);\n    float RN = max(dot(H, nor), 0.0);\n    float spec = 0.8*pow(RN, 32.0);\n    vec3 specCol = (SUN_COLOR + SUN_GLOW) * spec; \n    \n    // water flare \n    float rnd = 2.0*noise(vec2(hitPoint.x * 3.4738, hitPoint.z * 7.7319));\n    rnd *= 1.0-exp(-0.2*hit.x);\n    specCol +=  rnd * spec;\n     \n    // water diffuse \n    float diff = max(dot(sunDir, nor), 0.0); \n    vec3 diffCol = SUN_COLOR  * OCEAN_COLOR;\n    \n    // fresnel\n    float fresnel = 1.0 - max(dot(nor,-rd),0.0);\n    fresnel = pow(fresnel,3.0);\n    waterCol = mix(diffCol, specCol + reflectCol, fresnel); \n    \n    // land\n    vec3 landDiff = SUN_GLOW * diff;\n    \n    //refract \n    float refractRatio = 0.75;\n    vec3 refractDir = normalize(refract(rd, nor, refractRatio));\n    vec3 refractCol = calcSky(hitPoint, refractDir);\n    \n    //reflect\n    float t = castRayB(hitPoint, refDir);\n    if (t < MAX_DIST) {\n        waterCol *= vec3(1.0, 0.92, 0.92); //fake reflection\n    }\n    \n    \n    if (hit.y == 1.0) {\n        outCol = waterCol;\n    } else {\n        // wet area\n        float w0 = smoothstep(-0.3, -0.15-0.1*rnd, hitPoint.y);\n        outCol = mix(landDiff*0.5, landDiff, w0);\n\n        float w1 = smoothstep(-0.4, -0.2, hitPoint.y);\n        outCol = mix(waterCol, outCol, w1);\n    }  \n    \n    outCol = mix(outCol, refractCol , hit.w);\n    return outCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n    vec2 mouse = vec2(0.0);\n    mouse = iMouse.xy/iResolution.xy;\n   \n    //define camera\n    float t = iTime * 0.1;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(cos(mouse.x * 6.28 + t), mouse.y*2.0, sin(mouse.x * 6.28 + t));\n    mat3 cam = getCamera(ro, ta, 0.0);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    rd = normalize(rd);\n    vec3 bgCol = calcSky(ro, rd);\n \tvec3 outCol = vec3(0.0);\n    outCol = bgCol;\n    \n    vec4 hit = castRay(ro, rd);\n    vec3 pos = ro + hit.x * rd;\n    vec3 nor = getNormal(pos);\n    \n    if (hit.x < MAX_DIST) {\n        outCol = calcLighting(ro, rd, hit);\n        // fog\n        outCol = mix( outCol, SUN_GLOW, 1.0 - exp( -0.008 * hit.x * hit.x ) );\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixCol = vec3(0.0);\n    vec2 offset = vec2(0.0);\n    \n#if AA>1\n    for (float y = 0.0; y < float(AA); ++y)\n    {\n        for (float x = 0.0; x < float(AA); ++x)\n        {\n            offset = -0.5 + vec2(x, y) / float(AA);\n\n        \tpixCol += render(fragCoord+offset);\n        }\n    }\n    pixCol /= float(AA*AA);\n#else\n    pixCol += render(fragCoord);\n#endif\n    \n    // tone mapping\n   \t//float exposure = 1.0;\n    //pixCol = 1.0 - exp(-pixCol * exposure);\n    \n    // gamma\n    pixCol = pow( pixCol, vec3(0.4546));\n    \n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    pixCol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.3);\n    fragColor = vec4(pixCol, 1.0);\n    \n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 361, 361, 405], [407, 407, 438, 438, 988], [990, 990, 1014, 1014, 1258], [1260, 1260, 1311, 1311, 1411], [1413, 1413, 1443, 1443, 1471], [1473, 1473, 1507, 1507, 1535], [1580, 1580, 1600, 1600, 2064], [2066, 2066, 2098, 2098, 2131], [2133, 2133, 2157, 2157, 2447], [2449, 2449, 2481, 2481, 2588], [2590, 2590, 2623, 2623, 2728], [2730, 2730, 2761, 2761, 3104], [3106, 3106, 3127, 3127, 3372], [3374, 3374, 3414, 3414, 3657], [3659, 3659, 3697, 3697, 4069], [4071, 4071, 4095, 4095, 4386], [4389, 4389, 4442, 4442, 4624], [4626, 4626, 4674, 4674, 4957], [4959, 4959, 4991, 5006, 5682], [5684, 5684, 5740, 5740, 7464], [7466, 7466, 7518, 7518, 7696], [7698, 7698, 7730, 7730, 8619], [8621, 8621, 8678, 8678, 9383]], "test": "untested"}
{"id": "wltXDM", "name": "Raytracing Test v1", "author": "Xaymar", "description": "This is actual Ray Tracing with no acceleration, purely in a pixel shader. Very slow, not recommended.\n\nControls:\n- WS/AD/QE: Move\n- Space + Mouse LMB: Turn\n- Shift/Alt: Speed Up/Down", "tags": ["raytracing"], "likes": 1, "viewed": 240, "published": 3, "date": "1581131206", "time_retrieved": "2024-07-30T21:25:19.633716", "image_code": "// Known Bugs:\n// - Box Side detection is just straight up broken.\n//   - Box UVs as a result of that are also broken.\n//   - Both are likely a result of not calulating things in local space.\n// - Shapes have floating point accuracy errors near edges where the GPU optimized \n//     one part of the texel group to have \"hit\" while the rest did not. No known\n//     solutions.\n// - This is incredibly wasteful, why are you looking at this? Look at more talented\n//     people doing this with ray marching in less than the processing power than\n//     this takes.\n//\n// Known \"Solutions\":\n// - This can be made drastically faster by resolving geometry in a rasterization step, and only doing raytracing when needed.\n//   - Prevents the use of Fisheye cameras - but who needs those?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ----------------------------------------------------------------------------\n// Math\n// ----------------------------------------------------------------------------\nbool solve_quadratic(float a, float b, float c, out float x0, out float x1) \n{ \n\tfloat discr = b * b - 4. * a * c; \n\tif (discr < 0.) {\n\t\treturn false; \n\t} else if (discr == 0.) {\n\t\tx0 = x1 = - 0.5 * b / a; \n\t} else { \n\t\tfloat q = (b > 0.) ? \n\t\t-0.5 * (b + sqrt(discr)) : \n\t\t-0.5 * (b - sqrt(discr)); \n\t\tx0 = q / a; \n\t\tx1 = c / q; \n\t} \n\n\tif (x0 > x1) {\n\t\tfloat tmp = x1;\n\t\tx1 = x0;\n\t\tx0 = tmp;\n\t}\n\n\treturn true; \n}\n\n\n// ----------------------------------------------------------------------------\n// Line <-> X Intersection\n// ----------------------------------------------------------------------------\n\nbool intersect_line_aabb(float3 aabb_min, float3 aabb_max, float3 line, float3 inv_dir,\n                            out float2 depth) {\n    float tx1 = (aabb_min.x - line.x) * inv_dir.x;\n    float tx2 = (aabb_max.x - line.x) * inv_dir.x;\n    float ty1 = (aabb_min.y - line.y) * inv_dir.y;\n    float ty2 = (aabb_max.y - line.y) * inv_dir.y;\n    float tz1 = (aabb_min.z - line.z) * inv_dir.z;\n    float tz2 = (aabb_max.z - line.z) * inv_dir.z;\n \n    float tmin = min(tx1, tx2);\n    float tmax = max(tx1, tx2); \n    tmin = max(tmin, min(ty1, ty2));\n    tmax = min(tmax, max(ty1, ty2));\n    tmin = max(tmin, min(tz1, tz2));\n    tmax = min(tmax, max(tz1, tz2));\n    \n    depth = float2(tmin, tmax);\n\treturn (tmax >= tmin) && (tmin > 0.);\n}\n\nbool intersect_line_sphere(float3 pos, float3 rot, float radius, \n                           float3 line, float3 dir, out float2 depth) {\n    // OPTIMIZATION: Is a Line-AABB test cheaper to do than the full solving?\n    // if (!intersect_line_aabb(ray, 1.0 / ray_dir, -radius.xxx, radius.xxx)) return false;\n    \n\tfloat t0, t1; // solutions for t if the ray intersects \n\tfloat radius2 = radius * radius;\n\n\t// analytic solution\n\tfloat3 L = line - pos; \n\tfloat a = dot(dir, dir); \n\tfloat b = 2. * dot(dir, L); \n\tfloat c = dot(L, L) - radius2; \n\n\tif (!solve_quadratic(a, b, c, t0, t1)) {\n        depth = float2(0., 0.);\n        return false;\n\t}\n\n\tif (t0 > t1) {\n\t\tfloat tmp = t0;\n\t\tt0 = t1;\n\t\tt1 = tmp;\n\t}\n\n\tif (t0 < 0.) { \n\t\tt0 = t1; // if t0 is negative, let's use t1 instead \n\t\tif (t0 < 0.) {\n            depth = float2(0., 0.);\n\t\t\treturn false; // both t0 and t1 are negative\n\t\t}\n\t} \n\n\tdepth = float2(t0, t1);\n    return true;\n}\n\nfloat3 normal_to_side_normal(float3 normal) {\n    float3 absnm = abs(normal);\n    float x_sc = (absnm.x - absnm.y) + (absnm.x - absnm.z);\n    float y_sc = (absnm.y - absnm.x) + (absnm.y - absnm.z);\n    float z_sc = (absnm.z - absnm.x) + (absnm.z - absnm.y);\n\n    if ((x_sc > y_sc) && (x_sc > z_sc)) {\n        return float3(1., 0., 0.) * sign(normal);\n    } else if ((y_sc > x_sc) && (y_sc > z_sc)) {\n        return float3(0., 1., 0.) * sign(normal);\n    } else {\n        return float3(0., 0., 1.) * sign(normal);\n    }\n}\n\nfloat3 normal_to_side_and_normal(float3 normal, out int side) {\n    float3 norm = normal_to_side_normal(normal);\n    float3 anorm = abs(norm);\n    if (anorm.x > 0.) {\n        if (sign(norm.x) > 0.) {\n            side = SIDE_RIGHT;\n        } else {\n            side = SIDE_LEFT;\n        }\n    } else if (anorm.y > 0.) {\n        if (sign(norm.y) > 0.) {\n            side = SIDE_UP;\n        } else {\n            side = SIDE_DOWN;\n        }        \n    } else {\n        if (sign(norm.z) > 0.) {\n            side = SIDE_FRONT;\n        } else {\n            side = SIDE_BACK;\n        }        \n    }\n    \n    return norm;\n}\n\n\n// ----------------------------------------------------------------------------\n// Raytracing\n// ----------------------------------------------------------------------------\n\n// Material Info (PBR?)\n// - Color\n// - Normal\n// - Specular\n// - Roughness\n// - Metallic\n// - Emissive Color\n// - Translucency?\n// - Index of Refraction\n\nstruct material_data {\n    float3 color; // Unlit Color\n    float3 emissive; // Emissive Color\n    float3 normal; // World Normal\n    float3 spec_rough_metal; // Specular, Roughness, Metalness\n    float opacity;\n    float index_of_refraction;\n};\n\nvoid material_initialize(out material_data mat) {\n    mat.color = float3(0., 0., 0.);\n    mat.emissive = float3(0., 0., 0.);\n    mat.spec_rough_metal = float3(.5, 1., 0.);\n    mat.normal = float3(0., 0., 1.);\n    mat.opacity = 0.;\n    mat.index_of_refraction = 1.;    \n}\n\nstruct ray_hit_data {\n    bool hit;\n    int id;\n    \n    material_data material;\n    \n};\n\nstruct ray_data {\n    // Ray Information\n    float3 pos;\n    float3 dir;\n    float3 inv_dir;\n    float depth;\n    int id_filter;\n    \n    // Hit Information\n    bool hit;\n    int hit_id;\n    float3 hit_normal;\n    float3 hit_pos;\n    float3 hit_uvw;\n    \n    //ray_hit_data bounces[MAX_BOUNCES];\n    //ray_hit_data refractions[MAX_BOUNCES];\n};\n    \nvoid ray_initialize(float2 uv, out ray_data ray) {\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    float3 camera_position = read_camera_position(iChannel3);\n    \n    float3 r_camera = read_camera_rotation(iChannel3);\n    float3x3 m_camera =        \n        axisang_to_float3x3(float3(1.0, 0.0, 0.0), r_camera.x)\n    \t* axisang_to_float3x3(float3(0.0, 1.0, 0.0), r_camera.y)\n    \t* axisang_to_float3x3(float3(0.0, 0.0, 1.0), r_camera.z);\n    float2 suv = (uv * 2.) - 1.;\n    \n    #ifdef CAM_FISHEYE\n    // Fisheye - Curved surface that extends outwards.    \n    float2 view_uv = suv * .5 * camera_fieldofview;\n    float3x3 mview = \n        axisang_to_float3x3(float3(1.0, 0.0, 0.0), -view_uv.y / aspect)\n    \t* axisang_to_float3x3(float3(0.0, 1.0, 0.0), view_uv.x);\n    \n    ray.dir = float3(0., 0., 1.) * mview * m_camera;    \n    ray.pos = camera_position + ray.dir * camera_range.x;\n    #else\n    #ifdef CAM_PERSPECTIVE\n    // Perspective - Flat plane that extends outwards, but respects field of view.\n    \n    // This is interesting to create, as it is actually different to a real camera.\n    // First we calculate the two offsets for the far plane (+X and +Y),\n    // then using these offset we interpolate an actual direction,\n    // which is also used to give the offset to the camera position.\n    // In a sense, perspective isn't truly perspective, but it is closest to what our brain thinks we see.\n    \n    float3 forward = float3(0., 0., 1.);\n    float half_fov = camera_fieldofview * .5;\n    \n    float3x3 m_down = axisang_to_float3x3(float3(-1., 0., 0.), half_fov / aspect);\n    float3x3 m_up = axisang_to_float3x3(float3(1., 0., 0.), half_fov / aspect);\n    float3x3 m_right = axisang_to_float3x3(float3(0., 1., 0.), half_fov);\n    float3x3 m_left = axisang_to_float3x3(float3(0., -1., 0.), half_fov);\n    \n    float3 tl = forward * m_up * m_left;\n    float3 tr = forward * m_up * m_right;\n    float3 bl = forward * m_down * m_left;\n    float3 br = forward * m_down * m_right;\n    \n    ray.dir = lerp(lerp(tl, tr, uv.x), lerp(bl, br, uv.x), uv.y) * m_camera;\n    ray.pos = camera_position;// + (dir * camera_range.x);\n    #else\n    // Orthographic - Flat plane that extends outwards, field of view is used as scale.    \n    ray.dir = float3(0., 0., 1.) * m_camera;\n    ray.pos = camera_position \n        + (float3(suv.x * aspect, suv.y, camera_range.x) * camera_size) * m_camera;    \n    #endif\n    #endif\n    \n    // Ray Data\n    ray.pos = ray.pos;\n    ray.dir = ray.dir;\n    ray.inv_dir = 1. / ray.dir;\n    ray.depth = LARGE_VALUE;\n    ray.id_filter = 0;\n    \n    // Hit\n    ray.hit = false;\n    ray.hit_id = 0;\n    ray.hit_pos = float3(0., 0., 0.);\n    ray.hit_normal = float3(0., 0., 1.);\n    ray.hit_uvw = float3(0., 0., 0.);\n}\n\nvoid ray_initialize_reflect(in ray_data ray_orig, out ray_data ray_new) {    \n    // Ray Data\n    ray_new.dir = reflect(ray_orig.dir, ray_orig.hit_normal);\n    ray_new.pos = ray_orig.hit_pos;// + ray_new.dir * RAY_ERROR_MARGIN;\n    ray_new.inv_dir = 1. / ray_orig.dir;\n    ray_new.depth = LARGE_VALUE;\n    ray_new.id_filter = ray_orig.hit_id;\n    \n    // Hit\n    ray_new.hit = false;\n    ray_new.hit_id = 0;\n    ray_new.hit_pos = float3(0., 0., 0.);\n    ray_new.hit_normal = float3(0., 0., 1.);\n    ray_new.hit_uvw = float3(0., 0., 0.);\n}\n\nbool ray_test_box(inout ray_data ray,\n                  in float3 position, in float3 rotation, in float3 size) {\n    // Steps to actually get an intersection:\n    // 1. Turn everything so that the box is aligned.\n    // 2. Do the ray test with the box.\n    // 3. ???\n    // 4. Profit.\n    \n    float3x3 mrot = axisang_to_float3x3(float3(1.0, 0.0, 0.0), rotation.x);\n    mrot *= axisang_to_float3x3(float3(0.0, 1.0, 0.0), rotation.y);\n    mrot *= axisang_to_float3x3(float3(0.0, 0.0, 1.0), rotation.z);\n    \n    float3 vray = (ray.pos - position) * mrot;\n    float3 vray_dir_inv = 1.0 / (ray.dir * mrot);\n    float3 aabb = size;\n    float2 depth = float2(ray.depth, ray.depth);\n    if (intersect_line_aabb(-aabb, +aabb, vray, vray_dir_inv, depth) && (min(depth.x, depth.y) < ray.depth)) {\n        ray.depth = min(depth.x, depth.y);\n        \n        ray.hit = true;\n        ray.hit_pos = ray.dir * ray.depth + ray.pos;\n\n        int side;\n        float3 rel_pos = (ray.hit_pos - position) / size;\n        ray.hit_normal = normal_to_side_and_normal(rel_pos, side);\n        \n        if (side == SIDE_LEFT) {\n            ray.hit_uvw = float3(rel_pos.zy * float2(-1., 1.), 1.);\n        } else if (side == SIDE_FRONT) {\n            ray.hit_uvw = float3(rel_pos.xy * float2(-1., 1.), 1.);\n        } else if (side == SIDE_RIGHT) {\n            ray.hit_uvw = float3(rel_pos.zy * float2(1., 1.), 1.);\n        } else if (side == SIDE_BACK) {\n            ray.hit_uvw = float3(rel_pos.xy * float2(1., 1.), 1.);\n        } else if (side == SIDE_UP) {\n            ray.hit_uvw = float3(rel_pos.xz * float2(1., 1.), 1.);\n        } else if (side == SIDE_DOWN) {\n            ray.hit_uvw = float3(rel_pos.xz * float2(1., 1.), 1.);\n        }\n        ray.hit_uvw *= .5;\n        ray.hit_uvw += .5;\n        \n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool ray_test_cube(inout ray_data ray,\n                  in float3 position, in float3 rotation, in float size) {\n    return ray_test_box(ray, position, rotation, float3(size));\n}\n\nbool ray_test_sphere(inout ray_data ray,\n                     in float3 position, in float3 rotation, in float size) {\n    return false;\n}\n\n#define SCENE_MIRROR_0 1000\n#define SCENE_MIRROR_1 1001\n#define SCENE_CUBE_1 2001\n\nvoid scene(inout ray_data ray, out bool bounced) {\n    if ((ray.id_filter != SCENE_MIRROR_0) && ray_test_box(ray, float3(0., 0., -100.), float3(0., 0., 0.), float3(LARGE_VALUE, LARGE_VALUE, .01))) {\n        ray.hit_id = SCENE_MIRROR_0;\n        ray.hit_normal = normalize(ray.hit_normal\n                                   + float3(\n                                       (texture(iChannel2, ray.hit_uvw.xy * LARGE_VALUE / 16.).yx - .5) * .1,\n                                       .01)\n                                  );\n    }\n    if ((ray.id_filter != SCENE_MIRROR_1) && ray_test_box(ray, float3(0., 10., 0.), float3(0., iTime, iTime * 2.), float3(1., 10., 10.))) {\n        ray.hit_id = SCENE_MIRROR_1;\n        ray.hit_normal = normalize(ray.hit_normal\n                                   + float3(\n                                       (texture(iChannel1, ray.hit_uvw.xy * 2.).yx - .5) * .1,\n                                       .01)\n                                  );\n    }\n    if ((ray.id_filter != SCENE_CUBE_1) && ray_test_box(ray, float3(0., 0, 0.), float3(cos(iTime), 0., 0.), float3(50., 1., 50.))) {\n        ray.hit_id = SCENE_CUBE_1;\n        \n    }\n    \n    bounced = false;\n    switch (ray.hit_id) {\n        case SCENE_MIRROR_0:\n        case SCENE_MIRROR_1:\n            ray_data ref_ray;\n            ray_initialize_reflect(ray, ref_ray);\n        \tray = ref_ray;\n        \tbounced = true;\n        \tbreak;\n    }\n}\n\nfloat4 solve(float2 uv) {\n    // Initialize Ray\n    ray_data ray;    \n    ray_initialize(uv, ray);\n    \n    // Raytracing requires additional solving.\n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {\n    \tbool bounced = false;\n        scene(ray, bounced);\n        \n        if (!bounced)\n            break;\n    }\n    \n    if (ray.hit) {\n   \t\treturn texture(iChannel1, ray.hit_uvw.xy);\n    } else {\n        return texture(iChannel0, ray.dir);\n    }    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = solve(fragCoord/iResolution.xy);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ----------------------------------------------------------------------------\n// HLSL Type/Function redefines\n// ----------------------------------------------------------------------------\n#define float2\t\tvec2\n#define float3\t\tvec3\n#define float4\t\tvec4\n#define float3x3\tmat3x3\n#define float3x4\tmat3x4\n#define float4x3\tmat4x3\n#define float4x4\tmat4x4\n#define int2\t\tivec2\n#define int3\t\tivec3\n#define int4\t\tivec4\n#define lerp\t\tmix\n\n#define PI\t\t\t3.1415926535897932384626433832795\n#define PI2\t\t\t6.2831853071795864769252867665590\n#define _1_BY_PI\t.31830988618379067153776752674503\n#define _1_BY_PI2\t.15915494309189533576888376337251\n#define PI_BY_180\t.01745329251994329576923690768489\n#define PI_BY_360   .00872664625997164788461845384244\n#define _180_BY_PI  57.295779513082320876798154814105\n#define _360_BY_PI  114.59155902616464175359630962821\n#define LARGE_VALUE\t32768.0\n\n#define TO_RAD(v) (v * PI_BY_180)\n#define TO_DEG(v) (v * _180_BY_PI)\n\n// ----------------------------------------------------------------------------\n// Options (only modify this)\n// ----------------------------------------------------------------------------\n\n/// Settings\n#define CAM_SPEED\t\t\t20.0\n#define CAM_SPEED_SHIFT\t\t5.0 // Multiplier\n#define CAM_SPEED_CONTROL \t0.1 // Multiplier\n#define CAM_TURN_SPEED\t\t180.0 // In Degrees\n#define MAX_BOUNCES\t\t\t5\n\n/// Camera Modes\n//#define CAM_FISHEYE\t\t\t// Fisheye/Pinhole camera, curved near and far.\n#define CAM_PERSPECTIVE\t\t// Perspective camera, flat near and far, but uses fieldofview to determine far plane.\n//#define CAM_ORTHOGRAPHIC\t\t// Orthographic camera, flat near and far. (Default if nothing is defined)\n\n/// Camera Settings\nconst float2 camera_range = float2(1., 1000.);\nconst float camera_fieldofview = TO_RAD(90.0); // Perspective and Fisheye, horizontal dominant.\nconst float camera_size = 10.0; // Orthographic\n\n/// Debug Mode\n\n// ----------------------------------------------------------------------------\n// Keyboard\n// ----------------------------------------------------------------------------\n#define KEY_RESERVED_0 0 // All Media Keys happen here.\n#define KEY_RESERVED_1 1\n#define KEY_RESERVED_2 2\n#define KEY_RESERVED_3 3\n#define KEY_RESERVED_4 4\n#define KEY_RESERVED_5 5\n#define KEY_RESERVED_6 6\n#define KEY_RESERVED_7 7\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_RESERVED_10 10\n#define KEY_RESERVED_11 11\n#define KEY_CLEAR 12 // Numpad 5 without NumLock\n#define KEY_ENTER 13\n#define KEY_RESERVED_14 14\n#define KEY_RESERVED_15 15\n#define KEY_SHIFT 16\n#define KEY_CONTROL 17\n#define KEY_ALT 18\n#define KEY_PAUSE 19\n#define KEY_CAPSLOCK 20\n#define KEY_RESERVED_21 21\n#define KEY_RESERVED_22 22\n#define KEY_RESERVED_23 23\n#define KEY_RESERVED_24 24\n#define KEY_RESERVED_25 25\n#define KEY_RESERVED_26 26\n#define KEY_ESCAPE 27\n#define KEY_RESERVED_28 28\n#define KEY_RESERVED_29 29\n#define KEY_RESERVED_30 30\n#define KEY_RESERVED_31 31\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_POS1 36\n#define KEY_ARROW_LEFT 37\n#define KEY_ARROW_UP 38\n#define KEY_ARROW_RIGHT 39\n#define KEY_ARROW_DOWN 40\n#define KEY_RESERVED_41 41\n#define KEY_RESERVED_42 42\n#define KEY_RESERVED_43 43\n#define KEY_RESERVED_44 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_RESERVED_47 47\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_RESERVED_58 58\n#define KEY_BRACKET_LEFT 59 //  (German)\n#define KEY_INTL_BACKLASH 60 // < (German)\n#define KEY_RESERVED_61 61\n#define KEY_RESERVED_62 62\n#define KEY_MINUS 63 //  (German)\n#define KEY_RESERVED_64 64\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_OS 91\n#define KEY_RESERVED_92 92\n#define KEY_MENU 93\n#define KEY_RESERVED_94 94\n#define KEY_RESERVED_95 95\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_MULTIPLY 106\n#define KEY_NUMPAD_ADD 107\n#define KEY_RESERVED_108 108\n#define KEY_NUMPAD_SUBTRACT 109\n#define KEY_NUMPAD_COMMA 110\n#define KEY_NUMPAD_DIVIDE 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_F13 124\n#define KEY_F14 125\n#define KEY_F15 126\n#define KEY_F16 127\n#define KEY_F17 128\n#define KEY_F18 129\n#define KEY_F19 130\n#define KEY_F20 131\n#define KEY_F21 132\n#define KEY_F22 133\n#define KEY_F23 134\n#define KEY_F24 135\n#define KEY_NUMPAD 144\n#define KEY_SCROLLOCK 145\n#define KEY_BACKQUOTE 160 // ^ (German)\n#define KEY_RESERVED_161 161\n#define KEY_RESERVER_162 162\n#define KEY_BACKSLAHS 163 // # (German)\n#define KEY_BRACKET_RIGHT 171 // + (German)\n#define KEY_RESERVED_172 172\n#define KEY_SLASH 173 // - (German)\n#define KEY_AUDIO_VOLUME_MUTE 181\n#define KEY_AUDIO_VOLUME_DOWN 182\n#define KEY_AUDIO_VOLUME_UP 183\n#define KEY_COMMA 188\n#define KEY_PERIOD 190\n#define KEY_RESERVED_191 191\n#define KEY_EQUAL 192 //  (German)\n#define KEY_SEMICOLON 192 //  (German)\n#define KEY_QUOTE 222 //  (German)\n\nbool key_down(int key, sampler2D tex) {\n    return texelFetch(tex, int2(key, 0), 0).x > .5;    \n}\n\nbool key_hit(int key, sampler2D tex) {\n    return texelFetch(tex, int2(key, 1), 0).x > .5;    \n}\n\nbool key_toggled(int key, sampler2D tex) {\n    return texelFetch(tex, int2(key, 2), 0).x > .5;    \n}\n\n// ----------------------------------------------------------------------------\n// Buffer D States\n// ----------------------------------------------------------------------------\n#define SET_CAMERA_POSITION int2(0, 0)\n#define SET_CAMERA_ROTATION int2(1, 0)\n#define SET_FRAMETIME int2(0, 1)\n\nfloat3 read_camera_position(sampler2D sampler) {\n    return texelFetch(sampler, SET_CAMERA_POSITION, 0).xyz;\n}\n\nfloat3 read_camera_rotation(sampler2D sampler) {\n    return texelFetch(sampler, SET_CAMERA_ROTATION, 0).xyz;\n}\n\nfloat read_weighted_frametime(sampler2D sampler) {\n    return texelFetch(sampler, SET_FRAMETIME, 0).x;\n}\n\n\n// ----------------------------------------------------------------------------\n// Axis-Angle Math\n// ----------------------------------------------------------------------------\nfloat3x3 axisang_to_float3x3(float3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return float3x3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat3 axisang_rotate_float3(float3 v, float3 axis, float angle) {\n    \n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return (float4(v,1.) * float4x4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0)).xyz;    \n}\n\n// ----------------------------------------------------------------------------\n// Math Stuff\n// ----------------------------------------------------------------------------\n#define SIDE_LEFT 0\n#define SIDE_FRONT 1\n#define SIDE_RIGHT 2\n#define SIDE_BACK 3\n#define SIDE_DOWN 4\n#define SIDE_UP 5\n", "buffer_d_code": "// Input Handler & other stuff\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float2 ruv = floor(fragCoord);\n    int2 xy = int2(ruv.x, ruv.y);\n    float time_delta = read_weighted_frametime(iChannel0);\n    \n    if (xy == SET_CAMERA_POSITION) {\n        float3 pos = read_camera_position(iChannel0);\n        float3 rot = read_camera_rotation(iChannel0);\n        \n        float3x3 m_rot = \n            axisang_to_float3x3(float3(1., 0., 0.), rot.x)\n            * axisang_to_float3x3(float3(0., 1., 0.), rot.y)\n            * axisang_to_float3x3(float3(0., 0., 1.), rot.z);\n        \n        float3 fw = float3(0., 0., 1.) * m_rot;\n        float3 rg = float3(1., 0., 0.) * m_rot;\n        float3 up = float3(0., 1., 0.) * m_rot;\n        float3 delta = float3(0.);\n        \n        if (key_down(KEY_A, iChannel1)) {\n            delta -= rg;\n        } else if (key_down(KEY_D, iChannel1)) {\n            delta += rg;\n        }        \n        if (key_down(KEY_S, iChannel1)) {\n            delta -= fw;\n        } else if (key_down(KEY_W, iChannel1)) {\n            delta += fw;\n        }        \n        if (key_down(KEY_Q, iChannel1)) {\n            delta -= up;\n        } else if (key_down(KEY_E, iChannel1)) {\n            delta += up;\n        }\n        \n        if (length(delta) > 0.1) {\n        \tdelta = normalize(delta) * CAM_SPEED;\n            if (key_down(KEY_SHIFT, iChannel1)) {\n                delta *= CAM_SPEED_SHIFT;\n            }\n            if (key_down(KEY_ALT, iChannel1)) {\n                delta *= CAM_SPEED_CONTROL;\n            }\n        \tpos += delta * time_delta;\n        }\n        \n        fragColor.rgb = pos;\n    } else if (xy == SET_CAMERA_ROTATION) {\n        float3 rot = read_camera_rotation(iChannel0);\n        \n        if (key_down(KEY_SPACE, iChannel1)) {\n            //float2 delta = iMouse.xy - iMouse.zw;\n            float2 delta = (iMouse.xy / iResolution.xy) - .5;\n            float2 deltasign = sign(delta);\n            delta = delta * delta;\n            delta *= iResolution.xy * deltasign;\n        \t\n            float speed = TO_RAD(CAM_TURN_SPEED) * time_delta;\n        \n        \trot.x += -(float(delta.y) / float(iResolution.y)) * 2. * speed;\n        \trot.y += (float(delta.x) / float(iResolution.x)) * 2. * speed;\n        }\n        \n        fragColor.rgb = rot;\n    } else if (xy == SET_FRAMETIME) {\n        if (iTime <= 1.) {\n            fragColor.r = iTimeDelta;\n        } else {\n            fragColor.r = read_weighted_frametime(iChannel0) * 0.9 + iTimeDelta * 0.1;\n        }        \n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 781, 838, 888, 999]], "test": "untested"}
{"id": "WltXDM", "name": "Glittering orb", "author": "Ref", "description": "Glittering orb", "tags": ["raymarching", "orb", "fresnel", "glitter"], "likes": 11, "viewed": 843, "published": 3, "date": "1581129867", "time_retrieved": "2024-07-30T21:25:20.411636", "image_code": "#define STEPS 100\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\nmat3 rotY(float angle)\n{\n    return mat3\n        (\n            cos(angle),\t\t0,\t\tsin(angle),\n            0,\t\t\t\t1.0,\t0,\n            -sin(angle),\t0,\t\tcos(angle)\n        );\n}\n\nfloat lambert(vec3 normal, vec3 lightPos)\n{\n\treturn max(dot(normal, lightPos), 0.05);\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\nvec3 sdSphereNormal(vec3 pos, vec3 center, float radius)\n{\n\tconst vec2 eps = vec2(0.01, 0.0);\n    return normalize\n\t(\tvec3\n     \t(\tsdSphere(pos + eps.xyy, center, radius) - sdSphere(pos - eps.xyy, center, radius),\n\t\t\tsdSphere(pos + eps.yxy, center, radius) - sdSphere(pos - eps.yxy, center, radius),\n\t\t\tsdSphere(pos + eps.yyx, center, radius) - sdSphere(pos - eps.yyx, center, radius)\n\t\t)\n\t);\n}\n\nfloat sdSphereRender(vec3 pos, vec3 center, float radius, vec3 lightPos)\n{\n\tvec3 normal = sdSphereNormal(pos, center, radius);\n\treturn lambert(normal, lightPos);\n}\n\nfloat sdSphereRaymarch(vec3 pos, vec3 dir, vec3 center, float radius, int steps, float minDist, float maxDist)\n{\n    float curDist = minDist;\n\tfor(int i = 0; i < steps; i++)\n\t{\n\t\tfloat dist = sdSphere(pos + curDist * dir, center, radius);\n\t\tif(dist < EPSILON) return curDist;\n\t\tcurDist += dist;\n\t}\n\treturn maxDist;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float res = min(iResolution.x, iResolution.y);\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / res;\n    vec2 um = (iMouse.xy - 0.5 * iResolution.xy) / res;\n    \n    float a = 0.6 - 0.35 * iTime - um.x * 6.0;\n\tvec3 cam = vec3(0.0, 1.0, 5.5) * rotY(a);\n    vec3 tgt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize(tgt - cam);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 ray = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\t\n    vec3 center = vec3(0, 0, 0);\n    float radius = 1.5;\n    vec3 light = normalize(vec3(2.0, 4.0, 3.0));\n\t\n    float d = sdSphereRaymarch(cam, ray, center, radius, STEPS, MIN_DIST, MAX_DIST);\n    vec3 sphere = cam + ray * d;\n    float f = sdSphereRender(sphere, center, radius, light);\n    vec3 n = sdSphereNormal(sphere, center, radius);\n    \n    float fresnel = pow(1.0 + dot(n, ray), 0.75);\n    float sparkles = pow(max(dot(normalize(textureLod(iChannel0, sphere * 2.0, 0.0).rgb - 0.5), ray), 0.0), 250.0);\n\t\n    vec3 sphereColor = vec3(0.0, 0.7, 1.0);\n    vec3 emissiveColor = vec3(0.3, 0.0, 1.0);\n    vec3 skyColor = vec3(0.04, 0.05, 0.15);\n    \n    vec3 col = mix(sphereColor, emissiveColor, fresnel);\n    col += sparkles * (1.0 - clamp(fresnel, 0.0, 1.0));    \n    col = mix(col * f, skyColor, step(MAX_DIST - EPSILON, d));\n    //col = mix(textureLod(iChannel0, sphere * 2.0, 0.0).rgb, skyColor, step(MAX_DIST - EPSILON, d));\n    //col = mix(n, skyColor, step(MAX_DIST - EPSILON, d));\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 110, 110, 256], [258, 258, 301, 301, 345], [347, 347, 400, 400, 444], [446, 446, 504, 504, 840], [842, 842, 916, 916, 1005], [1007, 1007, 1119, 1119, 1323], [1326, 1326, 1381, 1381, 2948]], "test": "untested"}
{"id": "wttXDM", "name": "Experimental Math", "author": "wyatt", "description": "Infinite Geometry experiment number 10 or 11?", "tags": ["blackmagic"], "likes": 8, "viewed": 402, "published": 3, "date": "1581125907", "time_retrieved": "2024-07-30T21:25:21.180580", "image_code": "Main {\n    vec4 a = A(U);\n    Q = sin(a.z*1000.+vec4(1,2,3,4));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n// Dave H :\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}", "buffer_a_code": "Main {\n    U -= 0.5*R;\n    float a = .01;\n    U *= 0.99*mat2(cos(a),-sin(a),sin(a),cos(a));\n    U += 0.5*R;\n    Neighborhood;\n    Q = m;\n    vec2 grad = 0.25*vec2(e.z-w.z,n.z-s.z);\n    vec2 strs = 0.25*vec2(n.w-s.w,w.z-e.z);\n \tfloat div = 0.25*(n.y+e.x-s.y-w.x);\n    float cur = 0.25*(n.x-e.y-s.x+w.y);\n    Q.z = mix(Q.z,-div,.001);\n    Q.w = mix(Q.w,-cur,.001);\n    Q.xy = grad*1e-3*(0.5+0.5*sin(.13*iTime))\n        +10.*sin(.763*iTime)*grad*strs\n        +10.*sin(.134*iTime)*vec2(grad.x*strs.x-grad.y*strs.y,grad.x*strs.y+grad.y*strs.x);\n    if (length(Q.xy)>0.)\n    \tQ.xy=mix(Q.xy,normalize(Q.xy),.1+100.*abs(Q.z)); \n    \n    \n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<40.) Q.zw *= 0.;\n    \n    if (iFrame < 1||length(Q.xy)<1e-3) Q = .001*(hash42(U)*2.-1.);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WltSD7", "name": "cos(acos(x)/3)", "author": "iq", "description": "Computes cos(acos(x)/3), which shows up in the solution to cubic equations. I am getting 1.6x performance at equivalent accuracy than the direct GPU implementation. Details: [url]http://iquilezles.org/articles/trisect/trisect.htm[/url]", "tags": ["2d", "acos", "cubic", "third"], "likes": 19, "viewed": 1483, "published": 3, "date": "1581120618", "time_retrieved": "2024-07-30T21:25:21.944538", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing cos(acos(x)/3) to equivalent accuracy to the\n// direct GLSL implementation, but faster. cos(acos(x)/3)\n// shows up in cubic equations with three real roots.\n//\n// Details: https://iquilezles.org/articles/trisect\n\n\n// 0: graph and difference (blue<1e-7, green<1e-6, yellow<1e-5, red<1e-4)\n// 1: performance measure\n#define MODE 0\n\n// 0: speed of light : Err n/a       MSE n/a       Perf 3.1\n// 1: 1 SQRT + 3 FMA : Err 1.03e-03  MSE 5.40e-07  Perf 2.2\n// 2: 1 SQRT + 4 FMA : Err 9.65e-05  MSE 4.73e-09  Perf 1.8\n// 3: 1 SQRT + 5 FMA : Err 1.65e-05  MSE 3.86e-11  Perf 1.6\n// 4: 1 SQRT + 5 FMA : Err 1.10e-05  MSE 5.72e-11  Perf 1.6\n// 5: rational polynomials, found in https://www.shadertoy.com/view/Md3XD4\n// 6: pow based      : Err \n// 7: GLSL 4.5 refer : Err 1.15e-05  MSE 3.25e-11  Perf 1.0\n#define APPROX 4\n        \n        \nfloat f( in float x ) { return cos(acos(x)/3.0); }\nfloat g( in float x )\n{\n    #if APPROX==0\n    return sqrt(x);\n\t#endif    \n    \n    #if APPROX==1\n\tx = sqrt(0.5+0.5*x);\n    return x*(-0.064916*x+0.564916)+0.5;\n    #endif\n    \n    #if APPROX==2\n\tx = sqrt(0.5+0.5*x);\n    return x*(x*(x*0.021340-0.096564)+0.575224)+0.5;\n    #endif\n\n    #if APPROX==3\n\tx = sqrt(0.5+0.5*x);\n    return x*(x*(x*(x*-0.008590+0.038236)-0.106509)+0.576869)+0.5; \n    #endif\n    \n    #if APPROX==4\n\tx = sqrt(0.5+0.5*x);\n    return x*(x*(x*(x*-0.008972+0.039071)-0.107074)+0.576975)+0.5; \n    #endif\n    \n    #if APPROX==5\n    return (0.866017+1.25203*x+0.431996*x*x+0.0161423*x*x*x) / (1.0+1.25325*x+0.312933*x*x);\n    #endif\n\n    #if APPROX==6\n    x = 0.5+0.5*x;\n    x = pow(x,0.455);\n    x = 0.5+0.5*x;\n    return x;\n    #endif\n\n    #if APPROX==7\n\treturn f(x);\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n// display    \n#if MODE==0\n    float dx = 1.0/iResolution.y;\n\tvec2  p = fragCoord/iResolution.xy;\n\n    p.x = 2.0*p.x-1.0;\n    p.y = 0.5+0.5*p.y;\n    \n    vec3 col = vec3( 0.2 + 0.02*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n     \n    float a = f(p.x);\n    float b = g(p.x);\n\n\n    { // yellow: reference\n        float y = a;\n        float dy = dFdx(y);\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);\n        col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 1.0, di ) );\n    }\n\n    { // blue: approximation\n        float y = b;\n        float dy = dFdx(y);\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);\n        col = mix( col, vec3(0.0,0.4,0.8), 1.0-smoothstep( 0.0, 1.0, di ) );\n    }\n    \n    if( p.y<0.51)\n    {\n        float d = abs(a-b);\n             if( d<1e-7) col=vec3(0.0,0.0,1.0);\n        else if( d<1e-6) col=vec3(0.0,1.0,0.0);\n        else if( d<1e-5) col=vec3(1.0,1.0,0.0);\n        else if( d<1e-4) col=vec3(1.0,0.5,0.0);\n        else             col=vec3(1.0,0.0,0.0);\n    }\n    \n#else\n\t// measure performance\n    float x = 0.9*fragCoord.x/iResolution.x + min(iTime,0.1);\n    vec3 col = vec3(0.0);\n    float f = 0.0;\n    uint num = 20000u+min(uint(iFrame),0u);\n    for( uint i=0u; i<num; i++ )\n    {\n        float y = x+f*0.0000001;\n        f += g(y);\n        f += g(y+f*0.001);\n    }\n    col.x = f/float(num);\n#endif\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSD7.jpg", "access": "api", "license": "mit", "functions": [[1919, 1919, 1942, 1942, 1969], [1970, 1970, 1993, 1993, 2770], [2773, 2773, 2830, 2846, 4214]], "test": "untested"}
{"id": "wldXWM", "name": "Day 50 ", "author": "jeyko", "description": "vortex stuff", "tags": ["mdtmjvm"], "likes": 9, "viewed": 471, "published": 3, "date": "1581116363", "time_retrieved": "2024-07-30T21:25:22.823188", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor.g *= 1. + dot(fragColor.xyz*0.5,fragColor.xyz*0.5);\n\n    fragColor*=0.5;\n    fragColor.r *= 1.7;\n    fragColor.b *= 1. + length(uv)*(1.9+sin(iTime))*1.3;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime (iTime + 17.)\n#define rot(x) mat2(cos(x))\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define mx (iTime*5. + 10.*iMouse.x/iResolution.x)\n\nvec3 path(float z){\n    z*= 0.2;\n\treturn vec3(\n    \tcos(z),\n    \tsin(z),\n    \t0.\n    )*0.4;\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 i = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0,1,0), i));\n    vec3 u = normalize(cross(i, r));\n\treturn normalize(\n    \ti + r*uv.x + u*uv.y\n    );\n}\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    p -= path(p.z);\n    \n    d.x = min(d.x, -(length(p.xy) - 1.));\n    \n\treturn d;\n}\nvec3 glow = vec3(0);\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\thit = false;\n    t = 0.;\n    p = ro;\n    for(int i = 0; i < 250; i++){\n    \td = map(p);\n        glow += exp(-d.x*10.);\n        \n        if (d.x < 0.009){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nfloat r11(float i){\n    return fract(sin(i*123.4123)*421.412);\n\treturn texture(iChannel0,vec2(i*3.)).y;\n}\n\nfloat valueNoise(float i){\n    float fl = floor(i);\n\tfloat fr = fract(i);\n    float rA = r11(fl);\n    float rB = r11(fl + 1.);\n    return mix(rA,rB, smoothstep(0.,1.,fr));\n}\n\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - length(uv)*0.4;\n    vec3 col = vec3(0);\n\tcol = pal(0.4,0.5,vec3(1.9,3.5,0.7),9.9,2.9)*0.1;\n\n\tvec3 ro = vec3(0);\n    ro.z += mx;\n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 5.);\n    \n    lookAt += path(lookAt.z);\n    \n    vec3 p = ro;\n    float t; bool hit;\n    //vec3 rd = normalize(vec3(uv,1));\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    ro += valueNoise(iTime*25.)*0.15;\n\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if(hit){\n    \t//col += 1.;\n        col += glow*0.002;\n    \t\n        vec3 pc = vec3(atan(p.y, p.x), length(p.xy), p.z);\n        \n        for(float j = 0.; j < 70.; j++){\n            vec3 q = pc;\n            float i = j*5.;\n            \n            float nA = valueNoise(q.x*990. + i + iTime*2000.);\n            q.z += nA*0.2;\n            p.x += nA*0.2*4.;\n            \n        \tvec2 coords = vec2(r11(i),r11(i+1.));\n        \tvec2 size = vec2(r11(i+2.),r11(i+3.));\n\t\t\tfloat speed = r11(i+4.);\n            \n            size.x *= 1.;\n            size.y *= 6.;\n            speed = max(0.2, speed*0.5 );\n            \n            float n = valueNoise(i);\n            coords.y += sin(mx*speed + n) + cos(mx*speed*n) - cos(mx*speed + nA)*0.11;\n            coords.x += sin(mx*speed + n*5.)*0.1;\n            \n            coords.y *= 15.;\n            coords.y += mx;\n            coords.x *= 6.14;\n\n            \n            q.x = mod(q.x + pi, tau);\n            \n            q.xz -= coords;\n            \n            \n            q.xz = abs(q.xz) - size;\n            \n            float me = max(q.x, q.z);\n            \n            //col -= col;\n            //col += pc.x/pi + 1.;\n            float sj = sin(j);\n            vec3 p = pal(0.8,vec3(0.7),vec3(4.,3.,2.7), 1. + sin(j)*0.2, 9. + sin(j)*0.1)*0.9;\n            col += smoothstep(0.99,1.,1. - me)*p;\n        }\n\t\t\n        \n        //col += pc.z;\n        \n        \n    } else {\n\t\t    \n    \n    }\n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 curr = texture(iChannel1, fragCoord/iResolution.xy);\n    vec4 A = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 blur = texture(iChannel0, fragCoord/iResolution.xy,7.);\n    //fragColor = mix(curr ,A*0.9+ blur*1.5,0.07);\n    fragColor = mix(curr ,A*0.9+ blur*0.,0.07  + sin(iTime*2.)*0.04);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 357]], "test": "untested"}
{"id": "tltXWM", "name": "Procgen Planet", "author": "kchnkrml", "description": "Procedural generation of a gas-like planet using fbm / domain warping.", "tags": ["procedural", "noise", "fbm", "planet", "domainwarping", "procgen"], "likes": 77, "viewed": 4540, "published": 3, "date": "1581113273", "time_retrieved": "2024-07-30T21:25:23.668927", "image_code": "// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// https://iquilezles.org/articles/warp\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(1.0, 1.0, 1.0);\n    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n    vec3 col_mid2 = vec3(0.7, 0.4, 0.3);\n    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    color *= (P + w*t).z * 2.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1042, 1116, 1137, 1137, 1204], [1206, 1206, 1227, 1227, 1810], [1812, 1812, 1831, 1831, 2007], [2279, 2279, 2302, 2302, 2318], [2319, 2319, 2349, 2349, 2380], [2382, 2457, 2513, 2513, 2787], [2789, 2821, 2842, 2842, 2880], [2882, 2882, 2921, 2958, 5496], [5498, 5498, 5554, 5554, 6040]], "test": "untested"}
{"id": "tttSWM", "name": "Differential Star Field", "author": "wyatt", "description": "Black magic infinite explorable starfield. ", "tags": ["blackmagic"], "likes": 12, "viewed": 558, "published": 3, "date": "1581108545", "time_retrieved": "2024-07-30T21:25:24.539599", "image_code": "Main {\n\tQ = vec4(0);\n    for (float x = -20.; x <=20.; x++) {\n    \tQ+= A(U+vec2(x,x))*exp(-.02*x*x);\n    \tQ+= A(U+vec2(x,-x))*exp(-.02*x*x);\n    \tQ+= A(U+1.5*vec2(x,0))*exp(-.01*x*x);\n    \tQ+= A(U+1.5*vec2(0,x))*exp(-.01*x*x);\n    }\n    Q *= .005;\n    float z = .3*length(B(U).xy);\n    Q += (1.+Q)*.02*(1.-z)*sin(iTime+z+vec4(1,2,3,4));\n\tQ = .8*atan(Q);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n// Dave H :\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}", "buffer_a_code": "Main {\n    vec2 M = 0.5*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n    U = U - M;\n    U *= 0.99-.2*dot(U,U)/R.x/R.y;\n    U = U + M;\n    Q = A(U);\n    Neighborhood;\n    float div = 0.25*(n.y+e.x-s.y-w.x);\n    float cur = 0.25*(n.x-e.y-s.x+w.y);\n    Q.w = -div;\n    Q.z = -cur;\n    Q = mix(Q,m,.93);\n    \n    if (iFrame < 1||length(Q.xy)<1e-3) Q = hash42(U);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    vec2 grad = 0.25*vec2(e.z-w.z,n.z-s.z);\n    vec2 strs = 0.25*vec2(n.w-s.w,w.z-e.z);\n \t\n    Q.xy = grad+strs;\n    float o = 100.*abs(Q.z);\n    if (length(Q.xy)>0.)\n    Q.xy=mix(Q.xy,normalize(Q.xy),clamp(o,0.,100.));\n    Q = mix(Q,m,.7);\n    \n    if (iFrame < 1) Q = hash42(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tfloat z = A(U).z;\n    \n    Q = max(abs(sin(5.1*z+vec4(1,2,3,40)))*\n            atan(exp(.3*z*z)/30.-1.)*30.\n            -1.,0.);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ttXW7", "name": "Black Hole Marching", "author": "Txoka", "description": "https://www.shadertoy.com/view/llGXWm but cleaned up and without the 5000 chars that apparently do absolutely nothing. (i know this can be cleaned and shortened much more, but i wont now).", "tags": ["blackhole"], "likes": 3, "viewed": 437, "published": 3, "date": "1581102562", "time_retrieved": "2024-07-30T21:25:25.301563", "image_code": "//https://www.shadertoy.com/view/llGXWm but cleaned up and without the 5000 chars that do absolutely nothing. (i know this can be cleaned and shortened much more, but i wont now).\n\n//just controlls size of black holes, has nothing to do with \"photon mass\" XD\nconst float photonMass =0.1;\n//iterator steps of the tracer\nconst int steps = 256;\n\nconst float rayMarcherStepLengthFactor=0.25;\n\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\n\nvec4 readData(int x, int y){return texelFetch(iChannel1,ivec2(x,y),0);}\n\n\nvec3 inv(vec3 v){return normalize(v)/dot(v,v);}\nvec3 map(vec3 p){return inv(-p)+inv(vec3(4.*cos(iTime*.3),0.,4.*sin(iTime*.3))-p);}\n\nvec2 trace(inout Ray r){\n    float totalForce = 0.;\n    float totalGD = 0.0;\n    float fd;\n    for(int i=0;i<steps;i++){\n        vec3 res=map(r.o);\n        float force=length(res);\n        if(i>0)totalGD+=force-fd;\n        fd=force;\n        totalForce+=force;\n        float dt=rayMarcherStepLengthFactor/(1.+force);\n        float integral=(photonMass*rayMarcherStepLengthFactor)*.1;\n        \n        r.d=normalize(r.d+integral*res);\n        r.o+=dt*r.d;\n    }\n    return vec2(totalGD,totalForce/float(steps)*0.2);\n}\nvec4 getColor(Ray ray)\n{\n    return texture(iChannel0,ray.d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 uv = vec3((fragCoord*2.-iResolution.xy)/iResolution.y,-1);\n\n    vec4 m=readData(0,1).xyzw;\n\n    vec3 ro=vec3(readData(0,0).xyz*0.1);\n    vec3 rd=normalize(uv);\n    rd.zy=vec2(dot(rd.zy,-m.zw),dot(rd.zy,m.wz*vec2(-1,1)));\n    rd.xz=vec2(dot(rd.xz,-m.xy),dot(rd.xz,m.yx*vec2(1,-1)));\n    Ray r=Ray(ro,rd);\n    \n    vec2 f=trace(r);\n\n    fragColor=getColor(r);\n    float ft=1./(1.+f.y);\n    fragColor.rgb *= ft;\n\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//https://www.shadertoy.com/view/llGXWm but without the 5333 chars that do absolutely nothing.\n\nconst float PI = 3.14159265359;\n//width of the camera plane\n\nint kA=65,kD=68,kE=69,kQ=81,kS=83,kW=87;\nint kSpace=32,kCtrl=17;\n\n#define key(id) if(texelFetch(iChannel0,ivec2(id,0),0).x>0.)\nvec4 readData(int x, int y){return texelFetch(iChannel1,ivec2(x,y),0);}\n\nvoid mainImage(out vec4 Q, in vec2 U){\n    float speed=readData(0,6).r;\n    int id=int(U.y);\n    vec4 self = texelFetch(iChannel1,ivec2(U),0);\n    Q=vec4(0);\n    if(U.x==0.5){\n\t\tif(iFrame==0){\n    \t   if(id==0)self=vec4(0,0,20,0);\n    \t   if(id==6)self.r=0.1;\n    \t}\n    \tif(id==0){\n            vec4 m = readData(0, 1);\n            vec3 rd=vec3(0,0,1);\n            \n            rd.zy=vec2(dot(rd.zy,-m.zw),dot(rd.zy,m.wz*vec2(-1,1)));\n    \t\trd.xz=vec2(dot(rd.xz,-m.xy),dot(rd.xz,m.yx*vec2(1,-1)));\n    \t    \n            vec3 fw=rd;\n            \n    \t    key(kW)self-=vec4(fw*speed,0);\n    \t    key(kS)self+=vec4(fw*speed,0);\n            key(kA)self-=vec4(cross(fw,vec3(0,1,0))*speed,0);\n    \t    key(kD)self+=vec4(cross(fw,vec3(0,1,0))*speed,0);\n    \t    key(kSpace)self-=vec4(cross(fw,cross(fw,vec3(0,1,0)))*speed,0);\n    \t    key(kCtrl)self+=vec4(cross(fw,cross(fw,vec3(0,1,0)))*speed,0);\n    \t    \n    \t}else if(id==1){\n    \t    vec3 lmp = readData(0, 2).xyw;\n            float p = (lmp.x / iResolution.x) * PI * 2.0;\n    \t    float t = (lmp.y / iResolution.y) * PI;\n    \t    float x = sin(p);\n    \t\tfloat y = cos(p);\n            float z = sin(t);\n            float w = cos(t);\n\t\t\tself=vec4(x,y,z,w);\n    \t} \n    \telse if(id==2){\n    \t    vec4 lmp = readData(0, 3).xyzw;\n    \t    if(lmp.w > 0.0){\n    \t        if(lmp.z <= 0.0)\n    \t            lmp.xy = iMouse.xy;\n    \t        self.xy+=vec2(iMouse.x-lmp.x,iMouse.y-lmp.y)/2.;\n    \t        self.y = clamp(self.y, 0.0, iResolution.y);\n    \t        self.a = 1.0;\n    \t    }else{\n    \t        self.a=0.0;\n    \t    }\n    \t}else if(id==3){\n    \t    if(iMouse.z>0.0){\n    \t        self=vec4(iMouse.x,iMouse.y, 1.0, 1.0);\n    \t    }else{\n    \t        self.a=0.0;\n    \t    }\n    \t}else if(id==6){\n    \t\tkey(kE)self.r=min(50.0,self.r*1.1);\n    \t\tkey(kQ)self.r=max(0.005,self.r/1.1);\n    \t}\n    \tQ = self;\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 429, 457, 457, 500], [503, 503, 520, 520, 550], [551, 551, 568, 568, 634], [636, 636, 660, 660, 1151], [1152, 1152, 1176, 1176, 1215], [1217, 1217, 1273, 1273, 1691]], "test": "untested"}
{"id": "ttcSD4", "name": "[TWITCH] The reaper's gallows", "author": "evvvvil", "description": "\"Les potences de la faucheuse\" (The reaper's gallows)\nResult of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["clouds", "demoscene", "light", "landscape", "tree", "fresnel", "point", "death", "twitch", "improv", "gloomy", "desolate", "reaper", "gallow"], "likes": 17, "viewed": 928, "published": 3, "date": "1581091586", "time_retrieved": "2024-07-30T21:25:26.247034", "image_code": "// \"Les potences de la faucheuse\" (The reaper's gallows)\n// Result of an improvised live coding session on Twitch\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Managing Grimsby Town Football Club makes me feel like Mary Poppins!\" - Ian Holloway, comical genius and current manager of Grimsby Town FC\n\n// ABRASIVE COMMENTS ARE BACK BY POPULAR DEMAND! (good to hear)\n// Those offended by swearing or shit jokes can go sit on a bag of sharp & pointy dicks!\n\nvec2 z,v,e=vec2(.035,-.035);float t,tt,g,bz,by,bb,tn;vec3 po,no,ld,al,np,bp,pp; //global vars: same old garbage brought to you in less that 3 characters\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive, because all you need is a box, a sphere, some sudafed pills and a fire proof trailer\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function, whether it's meth or pasta sauce, there ain't no cooking without stirring\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} // \"Smoothing out the merge\" just like when corporations takeover small companies but only fire the working class. (adds geomtry together with smooth blend)\nfloat smax(float d1,float d2,float k){float h=clamp(0.5-0.5*(d2+d1)/k,0.,1.);return mix(d2,-d1,h)+k*h*(1.0-h);}// \"Smoothing out the gape\" helps ease the pain of getting fucked by corporation above. (removes geometry from another with smooth blend)\nfloat noi(vec3 p){ // Noise function. Just like your manhood, it is rather small. (easy I know but I'm clutching at straws at this point. Wait... \"clutching at straws\"... Talking about your dick again? haha, get it?)\n  vec3 f=floor(p),s=vec3(7,157,113); //I don't really understand any of this, I'm too busy buying expensive vaporizers and pretenting to be that one hot girl match on your tinder\n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nfloat branch(vec3 p,float s,float y){ // we make trees out of branches, just like god made hipsters out of spite for the 90s\n  float t=length(p.xz)-0.6+y;//Make a branch out of an infinite cylinder (length(p.xz)-radius gives you a cylinder innit)\n  t=max(t,bo(p,vec3(10,s,10)));//Crop out the infinite cylinder into normal cylinder. Yeah, I could use a cylinder primitive function, but no I didn't memorize it. Some paths are best not taken drunk, such as cylinders.\n  return t;//No matter the scale, this branch is always bigger than your dick (ALWAYS end on a penis joke. Try it at your next family reunion...)\n}\nvec2 tree(vec3 p){ //Make tree with new position bp by pushing it in a loop. Then at different iterations moving, rotating, splitting. No joke on this line. This is a serious thing, unlike Manchester United football club.\n  bp=abs(p*.4-vec3(0,-7,10))-vec3(12,0,4); // Create new position bp to stick in da loop, we already abs symetery clone it to make 4 trees and shift the whole fucking thing a bit to be \"snug around the hole\" (thats' what she said)\n  vec2 h=vec2(1000,3); //setup the tree shape in vec2 to pass material id 3 = black colour. h.x should be, like me, and at all times, pretty fucking high.\n  for(int i=0;i<6;i++){ //loop da loop each iteration making new branch  and turning bit if i>1 then splitting as well. Nothing crazy clever just some pseudo fractal bullshit, but at least it's desolate.\n    h.x=min(h.x,branch(bp,2.3,p.y*.016)); //Draw one branch each iter 2.3 is length of branch\n    bp.y-=2.3; //2.3 is lngth of branch, fuck knows how i got there but this is prob to shift rotation axis point or branch center point\n    if(i>1) bp.x=abs(bp.x); //After second branch we start splitting, much like a good religious schism but without the drama of secatarian massacres\n    bp.xy*=r2(-0.2-float(i)*.1); //rotate exponentially each iteration. Look at me using big words like \"exponentionally\" without actually understanding them. Just like at my wedding bruv: completely fucking winging it.\n    bp.yz*=r2(0.1); bp.xz*=r2(0.1+float(i)*0.7); //Couple more rotates to make it more random tree-like, twisteroo the fuckeroo basically\n    bp.y-=2.2; //2.2 is length of branch little smaller to remove lines due to noise and junction shifting but still fuck knows how i got there but this is prob to shift rotation axis point or branch center point\n  }\n  return h;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}// We miss you on Twitch Luna... Sending some love.\nvec2 mp( vec3 p )\n{\n  p.z=mod(p.z+tt*10.,200.)-100.;  // Make it all infinite & moving forward, one liner desolate trains are go. Easier than convincing your flatmate it wasn't you singing \"Hit me baby one more time\" in the shower\n  tn=texNoise(0.07*vec2(p.z,dot(p.xy,vec2(.5)))).r;//Texture based noise to add layer of really nice detail to overall 3d noise from function which we gonna add to overall position, bare with me homeboy\n  pp=p; // remember the position at this point before adding the noise, in hindsight should have done it other way round but hey, hindsight is a bitch and you're still looking at my fake pic on tinder. Reality is also a bitch, I agree.\n  p+=noi(p)*.5+noi(p*.5)*.5+noi(p*.1)*4.+tn*.8+noi(p*0.05)*7.; //Adding all sorts of 3d noise from noise function the key is to add noise calls at different scales to make it natural terrain /rock like. The final touch is the texture based noise which costs but adds details tricky to recreate with just 3d noise\n  np=p;np.y*=0.7; //TERRAIN: we create a new position np based on noised out p for the three spheres (mountains) on the left hand side of terrain. What's better than a couple of balls? A trio of dangly frippy balls my friend.\n  np.xz-=vec2(60,20)+sin(p.z)*.4; // shift whole group of dangly balls, it's like teabagging but with numbers instead of your tongue (less fun, I know)\n  by=sin(p.y*.3-.5); //\"by\" is to deform balls along the y axis with sin, simple subtle displacement shit, unlike ageing which is a more complex displacement problem and cannot be avoided. Gravity is a bitch\n  vec2 h,t=vec2(length(np)-(15.-1.2*by),5); //Draw first ball on left. Don't worry, more balls incoming, we'll take it way past inuendo.\n  np-=vec3(-5,-7,20.); //shift the second ball back right and up a bit. With numbers I said, and just like when British people kiss: no tongues! (yeah the french are always right when it comes to love making)\n  t.x=smin(length(np)-(13.-1.*by),t.x,5.);//One more ball because we all are born with two, whether it's tits or balls.\n  np-=vec3(-10,4,20);//Shift again the last ball, this time with your tongue. Numbers ain't never gonna get you laid, no matter what the academia tries to prove.\n  t.x=smin(length(np)-(15.-1.6*by),t.x,5.); //third ball, yeah my virility complex is pushing me over the edge, a third ball is required. I should consider making babies, instagram could do with more posers.\n  bb=by-sin(p.z*.25);//Combo both \"by\" y-axis displacement and a new z-axis displacement into one variable bb to apply to all terrain objects.\n  t.x=smin(length(p+vec3(20,90,-30))-(80.-bb),t.x,5.); //Another sphere this time in the middle, ready to be pounded into a hole. What a slut!\n  t.x=smin(t.x,p.y+55.,25.); //We add an overall plane to the terrain to merge all the spheres together into a sexy surface, one so sexy that you might give up your innocence only just to touch it\n  t.x=smax(length(p.xz-vec2(-5,15))-(20.-bb),t.x,15.); //Dig a fucking hole into the terrain for the cave hole thing, smooth that shit out so that it doesn't hurt\n  t.x=smin(length(p+vec3(80,50,-100))-(80.-bb),t.x,5.); //one more Sphere mountain, right at back this time\n  t.x=smin(length(abs(p+vec3(0,65,-50))-vec3(70,0,0))-(55.-bb),t.x,5.); //Couple of mounts on the side of the hole. Man do i even need to make a dirty joke here? re-read the sentence, it's filthy. This shader is disgusting I'm not sure what you're still doing here.\n  t.x*=0.45; //Helps remove the artifact due to too much disortion. Yeah, I know, it's a bit much 0.45, I ain't gonna lie. But it looks shit otherwise and you should really have a decent gpu... Despite living at your parents, you're not a student anymore.\n  h=tree(p); t=t.x<h.x?t:h; //Yeah we make fucking trees. I know I couldn't make my children better looking but at least I can make desolate trees.\n  pp-=vec3(1,-5,40)+tn;//GALLOWS start here \"pp\" is gonna be the gallows' position of the gallows. \"Gallows start here\" good name for a post-brexit punk album.\n  pp.xz*=r2(2.5); //yeah we rotate gallows a bit because they ain't nuttin' like facing death head on\n  h=vec2(bo(pp,vec3(1.5,16,1.5)),3); //First tall box for gallows, like the excitement of laying the first stone of a cathedral, but it's for killing people, i know i know, still exciting.\n  h.x=min(h.x,bo(pp+vec3(0,-15,-5.5),vec3(1.5,1.5,7))); //Long box at top of gallows, pointing forward even though clearly, the only moving you're gonna do is dangling from the noose!\n  pp-=vec3(0,11,5); bp=pp;bp.yz*=r2(-0.788); //make new \"bp\" position and rotate that 45 degrees to make the underside 45 degree bit of gallows, \n  h.x=0.7*min(h.x,bo(bp,vec3(1.,1.,6))); //draw the underside of gallows call it the final piece to the reaper's christmas stocking\n  t=t.x<h.x?t:h; //Merge gallows and terrain together while retaining material ID (colour), like a company rebrand but with more colours and without \"Judgemental Jenny\" getting fired\n  pp-=vec3(0,-5,6.5)+tn+sin(p.y*30.)*0.02+sin(p.y*.1+tt)*(1.-abs(sin(p.y*.05))); // position for the rope, we make it sway with sin but taper out the influence so it is not moving at top, using this: (1.-abs(sin(p.y*.05))\n  h=vec2(0.7*bo(pp,vec3(0.2,10,0.2)),6); //ROPE: we draw the rope, has a bit of displacement to make it ropey, unlike your mad uncle who is a ropey geezer by default.\n  t=t.x<h.x?t:h; //Merge rope + gallows + terrain while retaining material ID. Like having sex with someone of different skin colour but the babies come out two tone as they retain material ID\n  h=vec2(0.3*length(p-vec3(-5,-60,15)-sin(p.z))-5.,6); //GLOWY CORE, \"Push a sphere inside the hole and make it glow!\" said the porn producer with a clipboard to the 2 bemused performers...\n  h.x=min(h.x,length(pp+vec3(0,10,0))); //DANGLY LITTLE GLOW SPHERE AT END OF ROPE: Because an actual bell-end wasn't subtle enough...\n  g+=0.1/(0.1+h.x*h.x*(.2-0.02*abs(sin(p.y*.2+tt*5.)))); //MAKE IT GLOW! Glow trick from Balkhan via Flopine & lsdLive. Big up Balkhan, flopine and lsdLive. Push object distance field into global \"g\" variable like this and add at the end see line 127\n  t=t.x<h.x?t:h; //Merge glowy bits with rest... Hey when you finally move out of your parents house, don't forget to retain material-fucking-ID, yeah?\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started there were no craft beer shops and boating shoes were for sailors.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft (get distance to geom)\n    if(h.x<.001||t.x>500.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>500.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime*1.25,56.4)+81.75; //MAin time variable, it's modulo'ed to avoid ugly artifact. Holding time in my hand: playing god is nearly as good as this crystal meth bag\n  vec3 ro=vec3(sin(tt*.1+0.9)*5.,7,-20)*mix(vec3(1),vec3(-3,-2,2),ceil(sin(tt*.5))),//Ro=ray origin=camera position\n  cw=normalize(vec3(0,cos(tt*.1)*5.,0)-ro), //cw camera forward?      \n  cu=normalize(cross(cw,vec3(0,1,0))), \t\t//cv camera up??\n  cv=normalize(cross(cu,cw)), \t\t\t\t//cu camera left vector??? Not sure broh, just like Greta Thunberg, I didn't go to school.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,lp; //rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  lp=vec3(0); lp.z=mod(lp.z-tt*10.,200.)-100.; //MODULO'ed POINT LIGHT. Best trick of this shader: make light pos modulo on z axis and to stop it from suddendly shifting pos, we make a light switch using sin of trime (line 120)\n  lp+=vec3(0,-20,15); //\"Stick the point light inside the hole!\" shouted the porn producer again, still holding his clipboard, to the even more baffled performers\n  v=vec2(abs(atan(rd.y-1.1,rd.x)),rd.z+tt*0.04); //Background spherical UVs to create cheap fake pseudo volumterics. Nice cheap dirty trick this, bit like your mad uncle trying to steal ice cream from kids.\n  co=fo=vec3(.1)+texNoise(0.4*v).r*.2-length(uv)*.14; //YA YA we make some pseudo cloud from noise texture function call. It's like reinventing the steam engine but without having to hang out with boring engineering nerds.\n  z=tr(ro,rd);t=z.x;//Trace the trace in the loop de loop. Aka sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you during your last bar fight\n    po=ro+rd*t; //Get da ray pos    \n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I ponder how likeable Holly Willoughby really is.\n    al=vec3(.7); //by default albedo is greyish\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    ld=normalize(lp-po);   //Point light direction shit \n    float ll=length(lp-po), attn=1.0-pow(min(1.0,ll/(100.*abs(sin(tt/6.3662)))),4.0); //abs(sin(tt/6.3662)) is light Switch - 6.3662 = 20/PI + 200/15 * PI * 0.01\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from Shane\n    co=mix(sp*.5+al*(a(.1)*a(1.)+0.1)*(dif+s(.4)),fo,min(fr,.4))*attn; //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0000005*t*t*t));//Fog soften things, and makes pseudo volumetrics, still though it won't save your marriage. Fucking your partner will.\n  }  \n  fragColor = vec4(pow(co+g*.1,vec3(0.45)),1);// Naive gamma correction, naive yes, but very small... LIKE YOUR DICK! (Told you to always end on a dick joke, no matter how cheap it is)\n} //Thank you and good night brooooooski", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[605, 678, 702, 702, 743], [744, 846, 863, 863, 906], [907, 1000, 1036, 1036, 1101], [1102, 1259, 1297, 1297, 1370], [1370, 1508, 1526, 1724, 2085], [2086, 2086, 2123, 2210, 2700], [2701, 2701, 2719, 2922, 4482], [4483, 4594, 4617, 4617, 4821], [4821, 4873, 4892, 4892, 11121], [11122, 11122, 11204, 11204, 11972], [12062, 12062, 12191, 12191, 15401]], "test": "untested"}
{"id": "WldXDM", "name": "Noise sphere", "author": "benj_carrier", "description": "Ray marching ", "tags": ["raymarching", "noise"], "likes": 3, "viewed": 350, "published": 3, "date": "1581091209", "time_retrieved": "2024-07-30T21:25:27.096762", "image_code": "vec3 u_lPos ;\nvec3 u_transform ;\nvec2 u_scale ;\n\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat map_the_world(in vec3 p)\n{\n    // float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n    float displacement = cnoise(p+u_transform);\n    float sphere_0 = distance_from_sphere(p, vec3(0.0), u_scale.x);\n\n    return sphere_0 + displacement;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec4 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        float distance_to_closest = map_the_world(current_position);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = calculate_normal(current_position);\n\n            vec3 light_position = u_lPos;\n\n            vec3 direction_to_light = normalize(current_position - light_position);\n\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n            vec3 rockon = vec3(1.0, 1.0, 1.0) * diffuse_intensity;\n            return vec4(rockon, 1.0);\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec4(0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n     u_lPos = vec3(7.3, -5, 3);\n\t u_transform = vec3(0,1, iTime);\n\t u_scale = vec2(1.6,1);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec3 camera_position = vec3(-3.0, -4.0, -7.0);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv, 1.0);\n\n    vec4 shaded_color = ray_march(ro, rd);\n\n    // Output to screen\n    fragColor =shaded_color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 104, 125, 125, 162], [163, 163, 190, 190, 238], [239, 239, 258, 258, 294], [296, 296, 317, 317, 2589], [2591, 2591, 2650, 2650, 2682], [2684, 2684, 2716, 2801, 2956], [2958, 2958, 2992, 2992, 3420], [3422, 3422, 3462, 3462, 4467], [4471, 4471, 4528, 4528, 4932]], "test": "untested"}
{"id": "tl3Sz7", "name": "[]Kurogane", "author": "Catzpaw", "description": "\"Kurogane\"\nComposed by Catzpaw 2020\n\n\n2020-02-22 VR support", "tags": ["raymarching", "music", "dof", "vr"], "likes": 43, "viewed": 1652, "published": 3, "date": "1581084735", "time_retrieved": "2024-07-30T21:25:28.182858", "image_code": "//---Kurogane\n// by Catzpaw 2020\n\n//Image:post effects and sound indicator\n\n//GRAPHIC\nfloat circle(vec2 p,vec2 s,float r,float w){\n    float d=1./iResolution.y,v=(s.x+s.y)*.5,l=length(p);\n    r+=v*r+.01;w+=r;\n    v=clamp((s.x+s.y)*3.,0.,1.);\n    return v>0.?min(smoothstep(r,r+d,l),smoothstep(w+d,w,l))*v:0.;\n}\n\n//TEXTURE\nvec4 tx0(vec2 uv,bool vr){\n    if(vr){\n        return texture(iChannel0,uv);\n    }else{\n        vec4 c=texture(iChannel0,uv);\n        c.g=texture(iChannel0,.99*(uv-.5)+.5).g;\n        c.r=texture(iChannel0,.98*(uv-.5)+.5).r;\n        return c;\n    }\n}\nvec4 tx1(int x){\n    return texture(iChannel1,vec2((float(x)+.5)/iResolution.x,.5/iResolution.y))*2.-1.;\n}\n\n//MAIN\nvoid render(out vec4 fragColor,vec2 uv,bool vr){\n  //hsync noise\n    uv.x+=fract(sin(floor(uv.y*64.+iTime*100.)*43.)*47.777)<.01?sin(floor(uv.y*100.+iTime))*.02:0.;\n  //DOF filter\n    vec2 fp=vr?vec2(.25,.5):vec2(.5);\n    mat2 vel=rot(1.);\n    vec2 mul=vec2(0,iResolution.x/iResolution.y),ang=vec2(0,1)*mul;\n    vec4 acc=vec4(0,0,0,1),tgt=vec4(1),c=tx0(uv,vr);\n    float foc=min(.4,tx0(fp,vr).w),bok=abs(c.w-foc),rad=0.,dis=0.;\n    for(int j=ZERO;j<100;j++){\n        rad+=.01;\n        tgt=tx0(uv+ang*rad*.03,vr);dis=tgt.w;tgt.w=1.;\n        acc+=(((dis<c.w)&&(abs(dis-foc)>=rad))||(bok>=rad))?tgt:vec4(0);\n        ang*=vel;\n    }\n    c.rgb+=acc.rgb;c/=acc.w;\n    if(!vr){\n    //sound indicator\n      uv-=.5;uv.x*=mul.y;\n      float vol=tx1(0).x*.5+.5;\n      if(length(uv)<.55){\n          for(int i=ZERO;i<6;i++){\n              c.rgb+=pow(circle(uv+vec2(0,-.35*vol)*rot(iTime+float(i)*1.047),tx1(i+1).xy*vol,.06,.02),.5);\n          }\n      }\n    //vignette\n      c.rgb-=length(uv)*.1;\n      c.w=1.;\n    }\n    fragColor=c;\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    render(fragColor,uv,(texture(iChannel0,vec2(0))==vec4(1,0,1,0)));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//---Kurogane\n// by Catzpaw 2020\n\n//BufferA:animation\n\n//SETTINGS\n#define ITER 64\n#define EPS 1e-4\n#define NEAR .1\n#define FAR 40.\n\n//SOUND SYNC\nfloat stime=0.;\nfloat vol=0.;\n#define LATENCY .0\n\n//TEXTURE\nvec4 tx1(int x){\n    return texture(iChannel1,vec2((float(x)+.5)/iResolution.x,.5/iResolution.y))*2.-1.;\n}\n\n//SDF\nfloat sdSphere(vec3 p,float r){return length(p)-r;}\nfloat sdCube(vec3 p,float r){p=abs(p)-r;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),.0)-.06;}\nfloat sdBox(vec3 p,vec3 b){p=abs(p)-b;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.)-.06;}\n\n//MODULATOR\nfloat distsaw(float t){return min(clamp(mod(t*2.,2.),0.,1.),1.-clamp(mod(t*8.,8.)-7.,0.,1.));}\nfloat beatsin(float t){return sin(t*6.283*200.)*clamp(.5-fract(t),0.,.5);}\n\n//SCENE\nfloat map(vec3 p){\n    float d=FAR,t=stime,v=vol,b=t*bpm/30.,m=sign(-sin(b*6.283/128.))+1.;\n    p.yz+=mod(floor(p.x*.1),2.)==0.?5.:0.;\n    p=mod(p,10.)-5.;\n    p.xz*=rot(t*.698);\n    p.xy*=rot(t*.742);\n    vec3 q=abs(p);\n    d=min(d,sdSphere(q-2.35,.5+beatsin(b)*.5*v));\n    p.xz*=rot(iTime*1.047+beatsin(b*.50)*0.15*v+sin(b*6.283)*.1*m*v);\n    p.xy*=rot(iTime*0.698-distsaw(b*.25)*1.20*v);\n    q=p;\n    for(int i=ZERO;i<6;i++){\n        q.x =abs(q.x );q.z+=.1;q.xy*=rot(t*.37-float(i)*.3);\n        q.yz=abs(q.zy);q.x+=.1;q.xz*=rot(t*.23-float(i)*.3);\n    }\n    return min(min(d,sdCube(q,2.4)),min(sdBox(q-.2,vec3(3.0,0.1,2.9)),sdBox(q+.2,vec3(3.5,2.6,0.2))));\n}\n\n//RAYMARCHING\nvec3 trace(vec3 ro,vec3 rd){\n    float t=NEAR;\n    for(int i=ZERO;i<ITER;i++){float d=map(ro+rd*t);if(abs(d)<EPS||t>FAR)break;t+=d;}\n    return ro+rd*t;\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n\tvec2 d=vec2(1,-1),e=d*EPS;\n    return normalize(d.xyy*map(p+e.xyy)+d.yxy*map(p+e.yxy)+d.yyx*map(p+e.yyx)+d.xxx*map(p+e.xxx));\n}\n\n//AMBIENT OCCULUSION\nfloat ao(vec3 p,vec3 no){\n\tfloat o=1.,s=1.;\n    for(float i=1.;i<4.;i++){float r=.2*i;o+=(map(no*r+p)-r)*s;s*=.5;}\n    return clamp(o,.2,1.);\n}\n\n//LIGHT\nvec3 light(vec3 ld,vec3 rd,vec3 v,vec3 c,vec3 no){\n    float ph=pow(max(dot(reflect(ld,no),-rd),0.),7.);\n    return v*(c*pow(.5+dot(no,-ld)*.5,2.)+ph)+pow(ph,10.);\n}\n\n//MATERIAL\nvec3 material(vec3 p,vec3 ro,vec3 rd){\n    vec3 no=normal(p);\n    return mix(\n        ao(p,no)*(\n            light(vec3(-.57),rd,vec3(.7,.7,.65),vec3(.6),no)+\n            light(vec3( .57),rd,vec3(.5,.6,.70),vec3(.5),no))*\n            (pow(texture(iChannel0,reflect(rd,no)).g+.5,3.)+.25),\n        vec3(0),\n        clamp(length(p-ro)*.04-.5,0.,1.));    \n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  //sound sync\n    float t=iTime-LATENCY;\n    t=t<bpm*start/120.?0.:t-bpm*start/120.;\n    stime=t;\n    vol=tx1(0).x*.5+.5;\n  //camera\n    vec3 ro=vec3(0);ro.z=-5.+mod(ro.z+iTime*6.,10.);\n    vec3 rd=vec3(uv,-.5);rd.xz*=rot(iTime*.13);rd.xy*=rot(iTime*.3);rd=normalize(rd);\n  //raymarching\n    vec3 p=trace(ro,rd);\n  //color\n    fragColor=clamp(vec4(material(p,ro,rd),length(p-ro)/FAR),0.,1.);\n}\n\n//VR\nvoid mainVR(out vec4 fragColor,in vec2 fragCoord,in vec3 fragRayOri,in vec3 fragRayDir){\n    vec2 uv=(fragCoord.xy-vec2(.25,.5)*iResolution.xy)/iResolution.y;\n  //sound sync\n    float t=iTime-LATENCY;\n    t=t<bpm*start/120.?0.:t-bpm*start/120.;\n    stime=t;\n    vol=tx1(0).x*.5+.5;\n  //camera\n    vec3 ro=fragRayOri;ro.z=-5.+mod(ro.z+iTime*2.,10.);\n    vec3 rd=fragRayDir;\n    rd=normalize(rd);\n  //raymarching\n    vec3 p=trace(ro,rd);\n  //color\n    fragColor=clamp(vec4(material(p,ro,rd),length(p-ro)/FAR),0.,1.);\n    fragColor=(fragCoord.x<1.)&&(fragCoord.y<1.)?vec4(1,0,1,0):fragColor;\n}\n", "buffer_a_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//---Kurogane\n// by Catzpaw 2020\n\n//Common:utilities & music\n\n//UTIL\n#define ZERO min(0,iFrame)\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n//vec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//---Scale Sequencer 2 by Catzpaw 2020\n//https://www.shadertoy.com/view/3tVGz3\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =80.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=2175.;\nconst float noteseed=2695.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\n/*\nint key=0; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=7;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n*/\nint scalenote(int y){\n    return y<0?-999:((0xca775530>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x39011171u,0x49012172u,0x39011773u,  //00-   melody\n    0x39054c95u,0x37054394u,0x47226166u,0x37617167u,\n    0x37028168u,0x37019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x37001434u,0x37001491u,0x37001022u,0x37001022u,  //0C-0F backing\n    0x10000000u,0x24143143u,0x34147147u,0x24153153u,  //10-13 chord\n    0x44504789u,0x4461a890u,0x44143327u,0x44957631u,  //14-17 bass\n    0xfa9ab9ebu,0xf99b79efu,0xe79fe79fu,0xe79de797u,  //18-1B sd+hh+bd\n    0x00010001u,0x01010101u,0x01212121u,0x55555555u); //1C-1F bd2\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x21000118u,0x21188119u,0x21188118u,0x21188119u,\n    0x21000118u,0x21188119u,0x21188118u,0x21188119u,\n    0x211a8118u,0x211a811bu,0x2119811au,0x21188119u,\n    0x211a8118u,0x211a811bu,0x2119811au,0x21188119u);\nconst uint[16] seq2=uint[]( //bassdrum+cymbal\n    0x2100011cu,0x2100011cu,0x211d611cu,0x211dc11fu,\n    0x2100011cu,0x2100011cu,0x211d611cu,0x211dc11fu,\n    0x211e811du,0x211e611cu,0x211ee11cu,0x211ec11fu,\n    0x211e811du,0x211e611cu,0x211ee11cu,0x211ec11fu);\nconst uint[16] seq3=uint[]( //bass\n    0x11000114u,0x11000114u,0x11000314u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000314u,0x11000114u,\n    0x21000114u,0x21000114u,0x21000314u,0x21148516u,\n    0x21000114u,0x21000414u,0x21000214u,0x21148117u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000110u,0x11000110u,0x11000310u,0x11000110u,\n    0x11000110u,0x11000110u,0x11000310u,0x11000110u,\n    0x11000411u,0x11000111u,0x11000312u,0x11000513u,\n    0x11000111u,0x11000411u,0x11000212u,0x11000113u);\nconst uint[16] seq5=uint[]( //backing\n    0x1100010cu,0x1100010eu,0x1100030cu,0x191d810eu,\n    0x1100010cu,0x1100010eu,0x1100030cu,0x111d810fu,\n    0x1100040cu,0x1100010eu,0x1100030cu,0x172d850eu,\n    0x1100010cu,0x1100040eu,0x1100020cu,0x112d810fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000101u,0x11000102u,0x11000303u,0x11000104u,\n    0x11000101u,0x11000102u,0x11000303u,0x11000105u,\n    0x11000406u,0x11000107u,0x11000308u,0x11000509u,\n    0x11000106u,0x11000407u,0x1100020Au,0x1100010Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return sign(i)*pow(clamp(abs(i*p.x),0.,1.),vec2(1./p.y))*p.z;}\n\n//FOLDBACK DISTORTION (input,threshould,ratio)\nfloat fbdist(float v,float t,float f){return abs(v)>t?sign(v)+(t-v)*f:v;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//FM INSTRUMENTS (freq,time)\n//float fmbass(float f,float x){f*=6.283;return fbdist(sin(f*2.03)+sin(f*2.+sin(f+sin(f*7.51)*env_d(x,.07))*env_d(x,.2)),1.,.8)*env_d(x,.5);}\n//float fmharpsi(float f,float x){f*=6.283;return (sin(f+sin(f*5.+sin(f*9.))))*env_d(x,.7);}\n//float fmvibe(float f,float x){f*=6.283;return (sin(f+sin(f*9.)))*env_d(x,.9);}\n//float fmep(float f,float x){f*=6.283;return (sin(f+sin(f*15.)*env_d(x,.5)*.6))*env_d(x,.7);}\n//float fmmarimba(float f,float x){f*=6.283;return (sin(f+sin(f*3.99+sin(f*5.3)*env_d(x,.08))*env_d(x,.3)))*env_d(x,.4);}\n//float fmguitar(float f,float x){f*=6.283;return fbdist(sin(f+sin(f*3.01+sin(f*3.49)*env_d(x,.4))*env_d(x,.7)*.6)*1.3*env_d(x,.9));}\n//float fmpad(float f,float x){f*=6.283;return sin(f+sin(f*1.01))*(.9+sin(x*60.)*.1);}\n\n//PERCUSSION INSTRUMENTS (time)\nfloat bd(float x){return sin(x*freq(84./(1.+x*.7)))*env_d(x,.5);}\nfloat sd(float x){return (osc_nesnoise(x,10)*.8*env_d(x,.4)+sin(x*freq(82./(1.+x*.05)))*env_d(x,.5));}\n//float hh(float x,float d){return osc_nesnoise(x,3)*env_d(x,d);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\n//vec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\n//vec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),3),osc_c30(f*(1.+detune),3))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,5)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(2./(x*.5+.08),.5)*env_d(x,.2);}\n//float neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\n//float neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n//SAW-TRI MORPH (note,time,progression)\n//float sawtri(float n,float x,float a){x=mod(freq(n)*x,1.);a=clamp(a*.5,1e-5,1.-1e-5);return min(x/a,(x-1.)/(a-1.))*2.-1.;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 snaredrum,closehh,kickdrum\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?sd(n.x)*.7:0.;\n    o+=(n.y==2.)?neshh(n.x,.1)*.5:0.;\n    o+=(n.y==3.)?bd(n.x)*.7:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 bassdrum,cymbal\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.55:0.;\n    o+=(n.y==2.)?neshh(n.x+.001,.4)*.3:0.;\n//    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*vec2(.4):vec2(0);\n    o+=(n.y>=0.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/180.)*.3+.34,.92)*vec2(.27)*env_d(n.x,.6):vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?(\n        c30chord(freq(n.y+60.03)*n.x,n.x)+\n        c30chord(freq(n.z+48.02)*n.x,n.x)+\n        c30chord(freq(n.w+48.01)*n.x,n.x)\n    )*.2:vec2(0);\n    o+=(n.y>=0.)?lpfsaw(n.w+48.,n.x,sin(t*bpm*6.283/60.)*.3+.45,.95)*vec2(.1)*env_d(n.x,.45):vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 backing\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+84.05)*n.x,n.x)*.15:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 melody\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?tri4lead(freq(n.y+60.)*n.x,n.x)*.5:vec2(0);\n    o+=(n.y>=0.)?lpfc30(n.y+48.,n.x,sin(t*bpm*3.142/30.)*.35+.4,.95,3)*vec2(.6)*env_d(n.x,.6):vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    vec4  n=vec4(0);  //chord info x:gate yzw:notes\n    o+=e?track1(t,l,s):vec2(0); //TRACK 1 snaredrum,closehh,kickdrum\n    o+=  track2(t,l,s);         //TRACK 2 bassdrum\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 backing\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.4\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    5\n#define DELAY_WET       0.3\n#define DELAY_FEEDBACK  0.9\n#define DELAY_TIME      0.07\nfloat mvol=0.; //for indicator\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n        o+=a*d;\n    }\n    mvol=vol;\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_code": "// see \"Common\" tab", "sound_inputs": [], "buffer_b_code": "//---Scale Sequencer 2 by Catzpaw 2020\n//https://www.shadertoy.com/view/3tVGz3\n\n//BufferB:samples for level indicator\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 p=fragCoord;\n    int x=int(p.x),y=int(p.y);\n    if((x>6)||(y>0))discard;\n    vec2 o=vec2(0);\n    float t=iTime,l=steps/bpm,vol=1.;\n    if(t>sec-fade){vol=(sec-min(t,sec))/fade;}\n    t-=start*60./bpm;\n    if(t>0.){\n        int s=int(t/l);\n        if(x==0){o=vec2(vol,0);}\n        if(x==1){o=track1(t,l,s)*.5+.5;}\n        if(x==2){o=track2(t,l,s)*.5+.5;}\n        if(x==3){o=track3(t,l,s)*.5+.5;}\n        if(x==4){o=track4(t,l,s)*.5+.5;}\n        if(x==5){o=track5(t,l,s)*.5+.5;}\n        if(x==6){o=track6(t,l,s)*.5+.5;}\n    }    \n    vec2 b=texture(iChannel1,fragCoord/iResolution.xy).xy;\n    fragColor = vec4(o,b);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3Sz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 86, 130, 130, 310], [312, 322, 348, 348, 571], [680, 687, 735, 751, 1708], [1710, 1717, 1770, 1770, 1880]], "test": "untested"}
{"id": "wlKGz3", "name": "von kock fractal", "author": "DolfinShark", "description": "creating the von kock snowflake fractal", "tags": ["fractal"], "likes": 3, "viewed": 325, "published": 3, "date": "1581081191", "time_retrieved": "2024-07-30T21:25:28.955791", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float angle = (iTime * 0.2) / 3.1416;\n    angle = (angle - round(angle)) * 3.1416;\n    angle = 3.1416 / -6.;\n    \n    uv.x += .5;\n    float scale = 1.;\n    for(int i = 0; i < 25; i++) {\n        scale *= 3.;\n        uv *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        \n        //angle += cos(iTime * 0.05) * 6.2832;\n        //angle *= 2. * sin(iTime * 0.1);\n   \n        vec2 n = vec2(cos(angle), sin(angle));\n        uv -= 2. * n * min(0., dot(uv, n));\n    }\n    \n    float d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    \n    \n    \n    d = smoothstep(1. / iResolution.y, 0., d / scale);\n    fragColor = vec4(d, d, d, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 802]], "test": "untested"}
{"id": "3ltSWM", "name": "Standard library for GLSL OO way", "author": "dmitrykolesnikovich", "description": "Here I am trying to finalize all ideas on applying Object-Oriented culture to GLSL. See first comment for details.", "tags": ["glsl", "oop", "stdlib"], "likes": 2, "viewed": 437, "published": 3, "date": "1581080877", "time_retrieved": "2024-07-30T21:25:29.717754", "image_code": "class BouncingCircle extends Circle {    \n    \n    init() \n \n    vec2 position = vec2(-0.2, -0.4);\n    vec4 color = BLUE;\n    float radius = 0.02;    \n    \n    onDraw() {\n       \tfloat movement = abs(sin(t * 3.14) * 0.5);\n        float pulsing =  pow(radius, sin(t * PI + PI / 2.0) * 0.25 + 0.75);\n    \tfloat sortOfHeartBeating = mix(pulsing, movement, abs(sin(t * 3.14)));\n        position += sortOfHeartBeating;\n    \tradius += sortOfHeartBeating;\n    }\n\n   \tsuper(position, radius, color); \n}\n\n/*override*/ void onResize(vec2 size) {\n    uv = (2.0 * uv - size) / size.y; // normalize uv from -1 to 1\n}\n\n/*override*/ void onDrawCanvas() { \n    drawCircle(vec2(0, 0.6), 0.2, RED * (sin(t * PI * 100.0) * 0.3 + 0.7));\n    Parabola(vec2(-1.4, -0.2), 0.5, GREEN);    \n\tLine(vec2(-0.2, -0.2), vec2(-0.5, -0.5), VIOLET); \n    Rectangle(vec2(-0.9, -0.1), vec2(.2), RED);\n    Rhombus(vec2(1.2, 0.4), vec2(0.6, 0.3), GREEN);\n    BouncingCircle();      \n    Triangle(vec2(-1.1, -0.9),  vec2(0, -0.9), vec2(-0.5, -0.6), YELLOW);\n    Pentagon(vec2(0.8, -0.5), 0.3, 0.1, VIOLET);\n    Star(vec2(-0.37, 0.33), .25, .5, YELLOW);\n    Cross(vec2(0, 0), vec2(0.25, 0.1), 0.0, RED);\n    RoundedCross(vec2(0, -0.6), 0.2, 0.05, RED);\n    Polygon(vec2(0, 0), vec2[3](vec2(-0.9, -0.9), vec2(0.2, -0.9), vec2(-0.3, -0.6)), RED);\n}\n\nflush()", "image_inputs": [], "common_code": "/** \n * Project render settings. \n * \n * Tweak freely to meet your needs.\n */\n\n// TODO parametrize blending\n#define isPlay false\n#define useSRGB true\n#define PI 3.14\n#define AA 0.005 // anti-aliasing TODO find better name\n#define POLYGON_CAPACITY 3 // TODO parametrize somehow instead of using constant\n#define backgroundColor vec4(0)\n\n\n/** \n * Standard library that contains standard \"classes\" like Circle, Rectangle, etc.\n * \n * Not for tweaking. Hardcoded in a stone.\n * \n * Reference: https://iquilezles.org/articles/distfunctions2d\n */\n\n/*private*/ vec4 canvas = backgroundColor; \n/*private*/ vec2 uv;\n\n#define RED vec4(1, 0, 0, 1)\n#define GREEN vec4(0, 1, 0, 1)\n#define BLUE vec4(0, 0, 1, 1)\n#define VIOLET vec4(0.8, 0.8, 1, 1)\n#define YELLOW vec4(1, 1, 0, 1)\n#define t isPlay ? iTime : 0.0\n#define drawDistance(distance) 1. - smoothstep(-AA, AA, distance)\n#define ndot(a, b) a.x*b.x - a.y*b.y\n#define flush() void mainImage(out vec4 fragColor, vec2 fragCoord) { uv = fragCoord; onResize(iResolution.xy); onDrawCanvas(); flushCanvas(fragColor); }\n\nvoid blend(vec4 color) {\n\tcanvas = mix(canvas, vec4(color.rgb, 1), color.a);\n}\n\nvoid flushCanvas(out vec4 fragColor) {\n\tif(useSRGB) canvas.rgb = pow(canvas.rgb, vec3(1.0/2.2));\n    fragColor = canvas;\n}\n\nvoid drawCircle(vec2 position, float radius, vec4 color) {\n    vec2 p = uv - position;\n    float geometry = length(p) - radius;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Line(vec2 a, vec2 b, vec4 color) {\n    vec2 pa = uv - a; \n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float geometry = length(pa - ba*h);    \n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Rectangle(vec2 position, vec2 size, vec4 color) {\n    vec2 p = uv - position;\n    vec2 d = abs(p) - size;\n    float geometry = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Rhombus(vec2 position, vec2 b, vec4 color) {\n    vec2 p = uv - position;\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    float geometry = d * sign(q.x*b.y + q.y*b.x - b.x*b.y);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Triangle(vec2 p0, vec2 p1, vec2 p2, vec4 color) {\n    vec2 p = uv;\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    float geometry = -sqrt(d.x)*sign(d.y);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Pentagon(vec2 position, float radius, float innerRadius, vec4 color) {\n    vec2 p = uv - position;\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-radius*k.z,radius*k.z),radius);    \n    float geometry = length(p)*sign(p.y);\n    if (innerRadius>0.0) geometry = abs(geometry) - innerRadius;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Star(vec2 position, float r, float rf, vec4 color) {\n    vec2 p = uv - position;\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    float geometry = length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\n\nvoid Cross(vec2 position, vec2 b, float r, vec4 color) {\n    vec2 p = uv - position;\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    float geometry = sign(k)*length(max(w,0.0)) + r;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid RoundedCross(vec2 position, float w, float radius, vec4 color) {\n    vec2 p = uv - position;\n    p = abs(p);\n    float geometry = length(p-min(p.x+p.y,w)*0.5) - radius;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\n// TODO parametrize size of v (now it's constant value POLYGON_CAPACITY = 3)\nvoid Polygon(vec2 position, vec2[POLYGON_CAPACITY] v, vec4 color) {\n    vec2 p = uv - position;\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    int N = v.length();\n    for(int i=0, j=N-1; i<N; j=i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    float geometry = s*sqrt(d);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Parabola(vec2 position, float k, vec4 color) {   \n\tvec2 pos = uv - position;    \n    pos.x = abs(pos.x);    \n    float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n    float q = -abs(pos.x)/(4.0*k*k);    \n    float h = q*q + p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) :\n        2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n    float geometry = length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\n/*OO support*/\n\nbool isDrawCircle = false;\n#define class void\n#define extends /*extends*/\n#define Circle () { isDrawCircle = true;\n#define init() /*init*/ }\n#define onDraw() /*ASD*/\n\nvoid super(vec2 position, float radius, vec4 color) {\n\tdrawCircle(position, radius, color);\n}\n\nvoid super(float radius, vec4 color) {\n\t// TODO\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 535, 535, 603], [618, 618, 639, 639, 1306]], "test": "untested"}
{"id": "WltSWM", "name": "Indented glass", "author": "luluco250", "description": "Simple trick with coordinates, I wanna try and do some lighting shading later.", "tags": ["2d", "distortion", "filter", "glass"], "likes": 12, "viewed": 741, "published": 3, "date": "1581074053", "time_retrieved": "2024-07-30T21:25:30.479717", "image_code": "void mainImage(out vec4 color, vec2 coord) {\n    vec2 mouse = mix(\n        vec2(iTime * 100.0),\n        iMouse.xy,\n        step(0.0, iMouse.z)) * 0.01;\n    \n    vec2 glass_offset = sin(coord * 0.1 - mouse) * 10.0;\n    vec2 glass_coord = coord + glass_offset;\n    \n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    vec2 glass_uv = glass_coord * ps;\n    \n    color = texture(iChannel0, glass_uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 423]], "test": "untested"}
{"id": "tlcXD7", "name": "Panspermia Incoming", "author": "dr2", "description": "The invasion is coming", "tags": ["symmetry", "virus"], "likes": 9, "viewed": 374, "published": 3, "date": "1581070859", "time_retrieved": "2024-07-30T21:25:31.241680", "image_code": "// \"Panspermia Incoming\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // optional antialising\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec4 qrHit;\nvec3 ltDir, bGrid, cId, obRnd, obDisp;\nvec2 obRotCs[2];\nfloat tCur, dstFar;\nbool cOcc;\nconst float pi = 3.14159;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\nvec3 SymCom (vec3 p, vec2 cs, vec2 w)\n{\n  vec2 f;\n  float a;\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    f.y = dot (p.yz, vec2 (cs.x, - cs.y));\n    if (f.y > 0.) {\n      f.x = dot (p.yz, cs.yx);\n      p.yz = vec2 (dot (f, vec2 (cs.y, - cs.x)), dot (f, cs));\n    }\n    if (j < 3) p.xy = Rot2Cs (p.xy, w);\n  }\n  return vec3 (p.xy, - p.z);\n}\n\nvec3 IcosSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * acos (sqrt (5.) / 3.));\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), vec2 (cs.x, - cs.y));\n  return SymCom (p, cs, CosSin (-2. * pi / 3.));\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * atan (2.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), cs);\n  p.xy = Rot2Cs (p.xy, CosSin (- pi / 10.));\n  return SymCom (p, cs, CosSin (-2. * pi / 5.));\n}\n\nvoid ObjState ()\n{\n  obRnd = Hashv3v3 (cId);\n  obDisp = bGrid * (cId + 0.5) + (0.1 + 0.05 * bGrid.x * obRnd.x) *\n     vec3 (CosSin (obRnd.z * tCur + obRnd.x), 0.).xzy;\n  obRotCs[0] = CosSin ((obRnd.y - 0.5) * 0.7 * tCur );\n  obRotCs[1] = CosSin ((obRnd.z - 0.5) * 0.7 * tCur);\n  cOcc = (obRnd.x * step (2., length (cId.xz)) > 0.7);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, q1, q2;\n  float d, d1, d2, ds, r1, r2, len, s;\n  d = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.xz = Rot2Cs (p.xz, obRotCs[0]);\n    p.xy = Rot2Cs (p.xy, obRotCs[1]);\n    len = 0.3;\n    q1 = IcosSym (p);\n    q1.z += 0.18 + len;\n    s = 0.5 * (1. - q1.z / len);\n    r1 = 0.03 * (1. + 5. * s * s);\n    d1 = PrCylAnDf (q1, r1, 0.016 * (1. - 0.7 * s), len);\n    q2 = DodecSym (p);\n    q2.z += 0.18 + len;\n    s = 0.5 * (1. - q2.z / len);\n    r2 = 0.03 * (1. + 5. * s * s);\n    d2 = PrCylAnDf (q2, r2, 0.016 * (1. - 0.7 * s), len);\n    if (d1 < d2) {\n      d = d1;\n      qrHit = vec4 (q1, r1);\n    } else {\n      d = d2;\n      qrHit = vec4 (q2, r2);\n    }\n    q = p;\n    ds = PrSphDf (q, 0.2);\n    if (ds < d) {\n      d = SmoothMin (d, ds, 0.02);\n      qrHit = vec4 (q, 0.);\n    }\n    d *= 0.8;\n  }\n  return d;\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += 0.2 * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 220; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  cIdP = vec3 (-999.);\n  for (int j = 0; j < 20; j ++) {\n    p = ObjCell (ro + d * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 2.) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 3.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return 1.5 * mix (vec3 (0.25, 0.6, 1.), vec3 (0., 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.8 + 0.2 * rd.y) * (1. + 0.25 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, p;\n  float dstObj, sh;\n  bGrid = vec3 (2.);\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    p = ObjCell (ro);\n    ObjState ();\n    vn = ObjNf (p);\n    if (length (p - obDisp) > 0.21) col = (length (qrHit.xy) < qrHit.w) ?\n       vec3 (1., 0.4, 0.4) * (0.6 + 0.4 * smoothstep (-0.1, 0.1, sin (15. * atan (qrHit.y, qrHit.x)))) :\n       vec3 (0.4, 1., 0.4) * (0.6 + 0.4 * smoothstep (-0.1, 0.1, sin (15. * 2. * pi * qrHit.z)));\n    else col = vec3 (1., 1., 0.4);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.1 * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, 0.3 + 0.7 * smoothstep (0.4, 1., dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.6 * pi * mPtr.y;\n  } else {\n    az = 0.02 * pi * tCur;\n    el = 0.1 * pi + 0.2 * pi * sin (0.01 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.5);\n  ltDir = vuMat * normalize (vec3 (1., 1., -2.));\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 4.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcXD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[645, 645, 684, 684, 997], [999, 999, 1022, 1022, 1191], [1193, 1193, 1217, 1217, 1402], [1404, 1404, 1422, 1422, 1737], [1739, 1739, 1761, 1761, 2580], [2582, 2582, 2605, 2605, 2735], [2737, 2737, 2770, 2770, 3335], [3337, 3337, 3358, 3358, 3606], [3608, 3608, 3645, 3645, 4003], [4005, 4005, 4027, 4027, 4431], [4433, 4433, 4468, 4468, 5355], [5357, 5357, 5410, 5410, 6396], [6398, 6398, 6431, 6431, 6458], [6460, 6460, 6513, 6513, 6574], [6576, 6576, 6598, 6598, 6636], [6638, 6638, 6683, 6683, 6786], [6788, 6788, 6824, 6824, 7030], [7032, 7032, 7062, 7062, 7120], [7122, 7122, 7153, 7153, 7217], [7251, 7251, 7275, 7275, 7335], [7337, 7337, 7361, 7361, 7479]], "test": "untested"}
{"id": "wt3XD7", "name": "array bounds compatibility test", "author": "FabriceNeyret2", "description": "out of bound don't fail compilation.\nstill, on OpenGL the result is as expected (index clamped -> 4 bands)\nwhile on windows/angle the result is 0 out of bounds (indeed, NaN)... or sometime 1... or gradient. i.e. undetermined.", "tags": ["glsl", "bug", "array"], "likes": 2, "viewed": 400, "published": 3, "date": "1581067151", "time_retrieved": "2024-07-30T21:25:32.092405", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    float a[] = float[](.3,.6,.8,1.);\n  //O = vec4(a[-1]); return;      // to test static access\n    O = vec4(0);\n    \n    float v, i = 10.*(U.x-.5)+2.; // bounds from -3 to 7\n    if (U.y>.5) i = floor(i);     // extra test: int( vs int(floor\n\n    O = vec4( a[int(i)]);         // access array.\n  //O = vec4(isnan(O));           // check for isNaN\n#if 0\n    if (abs(U.y-.5)<.25) O *= 1.01;  // try one or the other: same\n  //O *= 1.01;\n#endif\n\n   // if (U.y < .2 && isnan(O.x)) O.x = 1.; // bottom: red if NaN [side effect prevent test to work]\n#if 0\n    if (U.y > .9) O = vec4(0);              // top: black for ref\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3t3SW7", "name": "rounded rect version 3", "author": "dmitrykolesnikovich", "description": "In my imaginary world any object is drawn in following steps: coordinates, geometry, graphics, coloring. Each step has it's math and tweaks. Some tweaks are optional and some do actual job. And that's why GLSL is hard for me: not all tweaks are optional.", "tags": ["rect", "rounded"], "likes": 1, "viewed": 490, "published": 3, "date": "1581026199", "time_retrieved": "2024-07-30T21:25:32.855365", "image_code": "// Here I am trying to find intuition behind known \n// formulas by giving all variables human-readable names.\n\n/*\nIn my imaginary world any object is drawn in following steps:\n\tcoordinates\n\tgeometry\n\tgraphics\n\tcoloring\n\nEach step has it's math and tweaks. Some tweaks are optional and some do actual job. \nAnd that's why GLSL is hard for me: not all tweaks are optional.\n\nAll objects are added to canvas with +=. Canvas itself is init with vec4(0).\n*/\n\n/*standard*/\n\n#define normalization(p) (2.*p - iResolution.xy) / iResolution.y\n\n/*support*/\n\n#define radius 0.1\n#define size vec2(1)\n#define quadrantSize size / 2. \n#define center vec2(.2)\n#define VIOLET vec4(0.8, 0.8, 1, 1)\n#define bounceAnimation sin(iTime * .4) * .1 - .1\n\n/*objects*/\n\nvec4 RoundBox(vec2 p) {\n    // coordinates\n    p = abs(p - center); // translate to center with simmetry tweak\n    p -= quadrantSize; // translate to quadrant corner\n    p += radius; // tweak to fix result value without any beatiful conceptual explanation\n\n    // geometry\n    float dist = length(max(p, 0.)); // convert cs from cortesian to polar with required tweakery that does the job\n    float geometry = smoothstep(0., 0.01, dist - radius);\n    \n    vec4 graphics = vec4(1. - geometry);\n    \n    vec4 coloring = graphics * VIOLET;\n    return coloring;\n}\n\n/*canvas*/\n\nvoid mainImage(out vec4 canvas, in vec2 pixel) {\n    vec2 p = normalization(pixel);\n    canvas = vec4(0);\n    canvas += RoundBox(p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3SW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[742, 742, 765, 784, 1301], [1315, 1315, 1363, 1363, 1449]], "test": "untested"}
{"id": "3t3XW7", "name": "Day 49", "author": "jeyko", "description": "kinda broken and theres some old code snippet in there", "tags": ["mdtmjvm"], "likes": 5, "viewed": 373, "published": 3, "date": "1581024553", "time_retrieved": "2024-07-30T21:25:33.627301", "image_code": "#define iTime (iTime + 16.)\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define dmin(a,b) (a.x < b.x) ? a : b\n\n#define pi acos(-1.)\n/*\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}*/\n\nfloat random(vec2 u){\n\treturn fract(sin(u.y*4125.1 + u.x *125.625)*225.5235);\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.125 + u.z*525.5215)*115.125235);\n} \nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 6; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\nfloat fbm(vec3 p){\n\n    float n = 0.;\n    p *= 0.1;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*1.4);\n    float i = valueNoise(p*5.4 + q*2.);\n    float z = valueNoise(p*f*1.4);\n    \n    n += f*1.8 + q*0.5 + z*0.2 + i*0.3;\n    //n += f*1.8 + q*0.5 + z*0.5 + i*0.3;\n    \n\treturn n;\n}\nvec3 carToPol(vec3 p) { \n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat Noise(vec2 p) {\n\tvec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    gv = smoothstep(0.,1.,gv);\n    \n    float b = mix(random(id+vec2(0,0)), random(id+vec2(1, 0)), gv.x);\n    float t = mix(random(id+vec2(0,1)), random(id+vec2(1, 1)), gv.x);\n    \n    return mix(b, t, gv.y);\n}\n\n\nvec3 colourBackground(vec3 p, vec3 ro, vec3 rd){\n\tvec3 col = vec3(0.);\n    \n    vec3 rayNormal = normalize(p - ro);\n    // ---- stardust----// uses bounding circle  and polar coordinates\n    vec3 q = vec3(0) + rd ;\n    q.xz *= rot(-0.4);\n    q.zy*= rot(0.5*pi);\n    vec3 pC;\n    pC = carToPol(q);\n    \n    //return abs(sin( (pC.x + pC.y ) *20. ))*vec3(1);\n    \n    pC.y += 0.2;\n    float k = fbm(vec2(pC.y, pC.z)); \n    k = abs(k);\n    k = pow(k, 5.);\n    k *= 4.;\n    float k2= fbm(vec2(pC.y, pC.z)*10.4); \n    float k3= fbm(vec2(pC.y, pC.z) + 14.4); \n    vec3 c;\n    c.x = k*k2;\n    c.y = k*k3;\n    c.z = k*(sin(pC.z)*0.5 + 1.);\n    \n    col += c;\n    // ---- stars2 ---- //\n    \n    vec2 t = vec2(pC.y, pC.z);\n    \n    \n    // ---- stars ---- //\n   \n    //float nA = Noise(t*200.14);\n    float nA = Noise(t*200.14);\n    float nB = Noise(t*944.14);\n    col += pow(nA*nB, 10.);\n    \n    \n    // ---- sun ---- //\n    \n    vec3 pSun = vec3 (14,15, 40.);\n    float powSun = dot(normalize(pSun - ro)*1.01, rayNormal);\n    vec3 sunCol = vec3(40,30, 40)/100.;\n    powSun = pow(powSun, 100.) ;\n    vec3 fSun = powSun * sunCol;\n    fSun.r = pow(fSun.r, 2.);\n    fSun.g *= 0.3*powSun*fSun.b;\n    //if(length(fSun)>0.1){col = vec3(0.);}\n    //col += fSun;\n    //col = pC;\n    return col;\n}\nfloat total;\n\nfloat mountainNoise = 0.;\nfloat noiseOther = 0.;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\n    p.z -= 2.;\n    \n    d = dmin(d, vec2(length(p) - 0.1, 2.));\n    \n    #define mWidth 29.\n    #define mountain vec3(0.9,1,0.)\n    p.y += 0.;\n    p.x += mWidth;\n    //float n = fbm(q*2.3);\n\t//float asdgasd = r31(p*0.1);\n    \n    float nA = fbm(p.xz*0.2);\n    mountainNoise = nA;\n    \n    float v = valueNoise(vec3(p.xz*0.4, 4.));\n    noiseOther = v;\n\n    vec3 q = p;\n\tq = p;    \n    q.xz += iTime*0.2;\n    q.y += iTime*0.7;\n    float n = fbm(q*1.3)*2.;\n    \n    //d = dmin(d, vec2(dMountains, 3.));\n    \n    float dGround = p.y + 0.1;\n    dGround -= n*0.595;\n    dGround -= sin(p.z + p.x*1.4 + n*20.)*0.17;\n    dGround -= v*2.;\n    d = dmin(d, vec2(dGround, 1.));\n    \n    //d.x *= 0.4;\n    d.x *= (0.24 + smoothstep(0.,1.,total*0.004));\n\treturn d;\n}\n\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\t//t = 0.99;\n    t = 1.1;\n    hit = false;\n    p = ro + rd*t;\n    for(int i = 0;i < 171; i++){\n    \td = map(p);\n        \n    \ttotal = t;\n        if(d.x < 0.004){\n        \thit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return max(vec3(.0), min(vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e) ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    \n    uv *= 1. + length(uv)*0.4;\n\n    \n    ro.z += mx + iTime;\n    ro.y += 4.5;\n    vec3 lookAt = ro + vec3(0,0,17);\n    lookAt.y = 0.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xz *= rot(-0.4 + sin(iTime*0.2)*0.7);\n    vec3 p; float t; bool hit;\n    \n    //rd.xz *= rot(mx*0.1 + 0.1);\n\tvec2 d = march(ro, rd, p, t, hit);\n    vec3 background = colourBackground(p, ro, rd);\n    background.g *= 2.8;\n    if(hit){\n        \n        vec3 l = normalize(vec3(-0.2,0.8,-0.6));\n    \tvec3 n = getNormal(p);\n        vec3 h = normalize(l - rd);\n        vec3 lightCol = vec3(0.7,0.3,0.9)*0.1;\n        \n        float diff = max(dot(l, n),0.);\n    \tfloat spec = pow(max(dot(h, n),0.), 5.);\n    \tfloat fres = pow(1. - max(dot(-rd, n),0.), 5.);\n        \n        vec3 albedo = vec3(1);\n        \n        if (d.y == 1.){\n            //\\ro = p;\n            rd = reflect(rd, n);\n            background = colourBackground(p, ro, rd);\n\t\t\tbackground *= 0.3;\n            col += background*fres;\n            col += background*spec;   \n            \n        } else if (d.y == 3.){\n            //col += 0.6;\n            //albedo = vec3(0.4,0.2,0.8)*0.05;\n            albedo = vec3(0.16,0.12,0.18)*0.01;\n            spec *= pow(spec, 3.);\n        \tcol += mix(diff*albedo, (fres + spec)*lightCol, 0.7 - mountainNoise*0.7);\n        } else {\n            col += mix(diff*albedo, (fres + spec)*lightCol, 0.3);\n        }\n    } else {\n    \t\n        background *= 0.3;\n    \tcol += background;\n    }\n    \n    if(!hit){\n    \t//t = 500;\n        t = 500.;\n        p = ro + rd * 40.;\n    }\n    \n    float tt = t*0.018;\n    p.y -= 3.5;\n    p.y *= 0.9;\n    col = mix(col, vec3(0.), smoothstep(0.,1.,tt*( 0.2*exp(-p.y*1.)) ));\n    col *= 0.7;\n    \n    //col += 0.004;\n    col = pow(col, vec3(0.4545));\n    col *= 0.7;\n    col = ACESFilm(col);\n    float md=sin(valueNoise(vec3(p.xz*2., iTime*0.1)));\n    float mdB=sin(valueNoise(vec3(p.xz*0.2, iTime*0.1)));\n    if(!hit){\n        col.g *= 1.1 - md*0.3;\n        col.r *= 1. + md;\n    \n    } else {\n        col.b *= 1.1 - mdB*0.8;\n        col.r *= 1. + mdB;\n    \tcol *= 0.8 ;\n    }\n    \n    uv *= 0.7;\n    col *= 1. - dot(uv,uv)*0.4;\n    \n    col *= 1.4;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 251, 251, 309], [312, 312, 333, 333, 611], [613, 613, 631, 631, 705], [707, 707, 733, 733, 1418], [1420, 1420, 1439, 1439, 1589], [1590, 1590, 1608, 1608, 1894], [1895, 1895, 1918, 1918, 2034], [2086, 2086, 2107, 2107, 2368], [2371, 2371, 2419, 2419, 3651], [3715, 3715, 3732, 3732, 4507], [4509, 4509, 4579, 4579, 4880], [4882, 4882, 4924, 4924, 5100], [5101, 5101, 5124, 5124, 5263], [5265, 5265, 5290, 5290, 5463], [5464, 5464, 5521, 5521, 7836]], "test": "untested"}
{"id": "Wt3XW7", "name": "Down the bunny hole", "author": "hanabi", "description": "wanted to test scaling texture...\nI should have called it Bond...", "tags": ["tunnel"], "likes": 2, "viewed": 314, "published": 3, "date": "1581023134", "time_retrieved": "2024-07-30T21:25:34.398240", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.14159265358\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = vec2(0.1) + 0.8 * fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) * 0.91;\n    \n    vec2 center = (iResolution.xy) / 2.;\n    float t = M_PI / 180. * float(iFrame*2);\n    vec2 foci = center + vec2(cos(1.2*t), sin(1.1-t)) * 10.;\n    float r = iResolution.y / 20.;\n\n    if (distance(fragCoord, foci) < r)\n    \tfragColor = vec4(1., 0.1, 0.2, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "Wl3SDM", "name": "filtering hue 2", "author": "FabriceNeyret2", "description": "Hue, as all angular quantities, is not easy to interpolate and filter.\nWIP tests based on unwrapped-diffusion ( better use acceleration -cf plugin )\n- local extrema vanish (left)\n- only poles (and sources) can \"attach\" colors\n- diffusion does a good job", "tags": ["hue", "interpolation", "phasor", "chrominance"], "likes": 7, "viewed": 483, "published": 3, "date": "1581022716", "time_retrieved": "2024-07-30T21:25:35.162197", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    vec4 BG = vec4(0);\n    \n    O = hue( texture(iChannel0,U).x ); \n    \n    // hue\n    if keyToggle(32) {\n      //O = vec4( .5+ texture(iChannel0,U).x );                        // B&W\n      //O = vec4( .5+.5* sin(50.*texture(iChannel0,U).x ));            // isovals\n        O = vec4( .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x )); // phasor\n     // O *=      .5+.5* sin(300.*U.x+6.283*texture(iChannel0,U).x );  // phasor (color)\n        BG = vec4(0,1,0,1);\n    }\n    \n    if (int(u) == int(R)/2  ) O = BG;\n    if (int(u) == int(R*.83)) O = BG; \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define T(d)        texture(iChannel0,U+d/R)\n  #define T(d) fract( texture(iChannel0,U+d/R) - T + .5 )-.5 + T\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= R;\n    \n    //O = texture(iChannel0,U,1.);    // linear diffusion\n    \n#if 0\n    vec2 d = vec2(1,0);               // --- unwrapped diffusion (cross pattern)\n    vec4 T  = texture(iChannel0,U),   // first unwrap the neighborhood\n         T1 = T( d),                  // to never filter cross-wrap.\n         T2 = T(-d),\n         T3 = T( d.yx),\n         T4 = T(-d.yx);\n    O = ( T1+T2+T3+T4 ) / 4.;\n#else\n    O-=O; int N = 5;                  // --- unwrapped diffusion (NxN filter)\n    vec4 T  = texture(iChannel0,U);   // first unwrap the neighborhood\n    for (int k=0; k < N*N; k++)       // to never filter cross-wrap.\n        O += T(vec2( k%N -N/2, k/N -N/2 ));\n  //O = fract( O - T + .5 )-.5 + T;\n    O /= float(N*N);\n  //O = fract( O - T + .5 )-.5 + T;\n#endif\n    \n  //O = .5 + sign(O-.5)*sqrt(2.*abs(O-.5));\n  //O = .5*sin(6.263*O);\n    \n    if (iChannelResolution[2].x < 10.) { O-=O; return; } // wait texture\n    if (iFrame < 1 || texelFetch(iChannel0,ivec2(0),0)==vec4(0) ) { // --- init state\n        float  k = 1.;\n        k = U.x<.5 ? .5+8.*(.5-U.x) : U.x-.5<.33 ? 1. : 3.;\n        \n      //O.x = 3.*rgb2hls(texture(iChannel1,U)).x; return; // hue from true image\n      //T = texture(iChannel2,U,0.); O.x = T.a > .9 ? T.x : .3*T.x; return; // isolated random dots      \n      //O.x = abs(U.y-.5)>.25 ? U.x : 2.*U.x; return; // 1 vs 2 rainbow -> bipole\n      //U -= .5; O.x = 20.*length(U); return;         // concentric, no pole\n      //U -= .5; O.x = 4.5*atan(U.x,-U.y); return;    // radial, 1 pole + bad cycling\n\n        vec2 V = texture(iChannel2,U,5.).xy - .5;     // dir field from rand texture\n      //k = 8.*U.x;\n        if (U.x<.5) { O.x = k*8.*V.x; return; }       // left: no pole\n      //if (U.x<.5) { O.x = 9.*U.x;  if (U.y>.5) O.x += .5;return; }  // left: gradiant + PI-jump\n      //V *= sin(20.*U.x);                            // strip modulation\n        \n        O.x = atan(V.y,V.x);                          // dir = norm rand texture\n      //O.x = atan(dFdy(V.x),dFdx(V.x));              // gradients of rand texture.x\n      //O.x = atan(dFdx(V.x),-dFdy(V.x));             // isolines of rand texture.x\n        \n        O.x *= k/6.2816;                              // hue on [0,1]\n        return;\n    }\n    \n#if 0 // sources\n    if (length(U-.5) < .05 ) O.x = 1.;\n    if (length(U-vec2(.8,.3)) < .05 ) O.x = 1.;\n    if (length(U-.8) < .05 ) O.x = .5;\n    if (length(U-.3) < .05 ) O.x = .7;\n#endif\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvec4 rgb2hls(vec4 C) {\n    float r =C.r, g=C.g, b=C.b,\n        M = max(r,max(g,b)),\n        m = min(r,min(g,b)),\n        l = (M + m) / 2.,\n        d =  M - m;\n\n    if (M == m) return vec4(0,l,0,0);\n    \n    C.y = l;\n    C.z = .5* d / min(l, 1.-l);\n    C.x =  r > max(g,b) ? (g - b) / d + (g < b ? 6. : 0.)\n         : g > b        ? (b - r) / d + 2.\n         :                (r - g) / d + 4.;\n    C.x /= 6.;\n    return C;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3SDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tcXDM", "name": "Multi Triangle Video Player", "author": "BackwardsCap", "description": "An example for a friend!\nA video player that can display 4 different videos in a square.", "tags": ["tutorial", "triangles", "videoplayer"], "likes": 2, "viewed": 383, "published": 3, "date": "1581018797", "time_retrieved": "2024-07-30T21:25:35.935131", "image_code": "#define PI 3.1415927\n\n//our rotation matrix\nmat2 rot(float x)\n{\n    float s = sin(x);\n    float c = cos(x);\n    return mat2(c,-s,s,c);\n}\n\n//calculate a square. if we know its at a point in space and we know its width/height\n//then if the absolute value of the distance from the point is less than our width/height\n//we know we are in the square. apply to x and y, the overlapping section is our square\nfloat sq(vec2 p, float d)\n{\n    p=smoothstep(3./iResolution.y,.0,abs(p)-d-.1);\n    return  p.x*p.y;\n}\n\nvec3 videoTriangle(vec2 uv, sampler2D video, vec2 dimensions, float rotation)\n{\n    //rotate our canvas space\n    uv*=rot((PI/2.0)*rotation);\n    \n    //we are going to take 2 squares that fit the dimensions of the screen\n    //rotate one of them 45 degrees then move it down until its corners are flush with the other's edge\n    //calculate the overlapping segment and voila! a triangle to sample our videos from\n    float sq1 = sq(uv, .9);                         // \\/ adjust this to change the spacing between the videos\n    float sq2 = sq((uv+vec2(0,sqrt(2.0)))*rot(PI/4.0),.895);\n    \n    //move the video to be center(ish) of our triangle and scale it up\n    uv.x+=sqrt(2.0);\n    uv.y-=.25;\n    uv/=2.0;\n    \n    //make sure our texture sample is aspect-ratio correct\n    uv.x*=(dimensions.y/dimensions.x);\n    \n    //sample our video, and apply our mask\n    return texture(video,fract(uv)).rgb * (sq1*sq2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalize our uv coordinates\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    //add the video triangles to our output color\n    vec3 col  = videoTriangle(uv, iChannel0, iChannelResolution[0].xy, 0.0);\n    \t col += videoTriangle(uv, iChannel1, iChannelResolution[1].xy, 1.0);\n       \t col += videoTriangle(uv, iChannel2, iChannelResolution[2].xy, 2.0);\n    \t col += videoTriangle(uv, iChannel3, iChannelResolution[3].xy, 3.0);\n    \n    //add a white border to the sides\n    if(sq(uv,.905)==0.)col=vec3(1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 44, 63, 63, 136], [138, 402, 429, 429, 503], [505, 505, 584, 614, 1421], [1423, 1423, 1480, 1515, 2069]], "test": "untested"}
{"id": "wttXD4", "name": "bifurcation diagram", "author": "ich", "description": "bifurcation diagram towards chaos", "tags": ["bifurcationdiagramchaoslogisticmap"], "likes": 4, "viewed": 378, "published": 3, "date": "1580992340", "time_retrieved": "2024-07-30T21:25:36.705072", "image_code": "#define L 128\n\nfloat foo(float y, float r)\n{\n\treturn (r * y) * (1. - y);\n}\n\nfloat bifurcation(float y, float r, int it)\n{\n\tfor (int i = 0; i < it; ++i) {\n        y = foo(y, r);\n    }\n    return y;\n}\n\nfloat[L] bifurcation(float a, float r)\n{\n    float y[L];\n    y[0] = a;\n    for (int i = 1; i < L; ++i) {\n    \ty[i] = foo(y[i - 1], r);\n    }\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 c = vec3(0);\n    \n    // animated\n    float p = 1. - abs(pow(mod(iTime * .05, 2.) - 1., 3.));\n    // mouse\n    //float p = m.x;\n    \n    // position\n    c.b += smoothstep(.005, .0, abs(dot(uv - vec2(p, 0), vec2(1, 0))));\n    \n    // f(x)\n    c.r += smoothstep(.01, .0, abs(uv.y - bifurcation(.5, p * 4., int(fragCoord.x))));\n\n    // what f(x) 'converges' towards\n    float b[L] = bifurcation(.5, uv.x * 4.);\n    for (int i = L / 2; i < L; ++i) {\n    \tc.g += .3 * smoothstep(.005, .0, abs(uv.y - b[i]));\n    }\n    \n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 44, 44, 74], [76, 76, 121, 121, 198], [358, 358, 415, 415, 1048]], "test": "untested"}
{"id": "WltXWN", "name": "Fluid Sim Advancement", "author": "wyatt", "description": "I learned something new today! There is a correction to my fluid algorithm that really makes an important difference. It isn't any faster or simpler, but now it is completely conservative and does not lose matter when intermolecular forces are applied.", "tags": ["wave", "fluid"], "likes": 18, "viewed": 644, "published": 3, "date": "1580968022", "time_retrieved": "2024-07-30T21:25:37.477008", "image_code": "void mainImage( out vec4 Q, vec2 U )\n{\n    Q = A(U);\n    Neighborhood;\n    vec3 no = normalize(vec3(n.w-s.w+n.z-s.z,e.w-w.w+e.z-w.z,.25)),\n         re = reflect(no,vec3(0,0,1)),\n         ra = refract(no,vec3(0,0,1),.5);\n    Q = sin(2.*Q.w+Q.z*vec4(1,2,3,4));\n    Q *= 0.5+0.5*texture(iChannel2,re);\n    Q *= 0.5+0.5*texture(iChannel2,ra);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w); \n", "buffer_a_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    Q.z += 0.25*(w.x-e.x+s.y-n.y);\n    Q.zw += vec2(-.25,1)*(Q.w)*0.25*(w.w*w.x-e.w*e.x+s.w*s.y-n.w*n.y);\n    n = D(U+vec2(0,1)), e = D(U+vec2(1,0)), s = D(U-vec2(0,1)), w = D(U-vec2(1,0));\n\tQ.z += 0.25*(w.x-e.x+s.y-n.y);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    // Gradient of Pressure\n    vec4 d = D(U);\n    Q.xy += d.xy/(1.+3.*Q.w);\n\tQ.y -= 5e-4*Q.w;\n    // Boundary conditions :\n    if (iMouse.z>0.) {\n    \tif (length(iMouse.xy-U)<10.)\n            Q.xyw = vec3(0.2,0,1);\n    }else if (length(U-vec2(0.2,0.8)*R)<4.) Q = vec4(0.2,-0.3,Q.z,1);\n    if (iFrame < 1) {\n    \tif (length(0.5*R-U)<10.)\n            Q.xyw = vec3(0,0.5,1);\n    }\n    if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n        Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    U-=0.25*A(U).xy;\n    U-=0.25*A(U).xy;\n    U-=0.25*A(U).xy;\n    U-=0.25*A(U).xy;\n\tQ = A(U);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tNeighborhood;\n    Q.xy=0.25*vec2(w.z-e.z,s.z-n.z);\n    Q.zw=0.25*vec2(w.w-e.w,s.w-n.w);\n    if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n        Q *= 0.;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 340]], "test": "untested"}
{"id": "3ttXWN", "name": "Curvey Porcelain Tile", "author": "hzhou17", "description": "Tilable pattern with porcelain feel", "tags": ["tile", "porcelain"], "likes": 7, "viewed": 491, "published": 3, "date": "1580966368", "time_retrieved": "2024-07-30T21:25:38.240966", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\tvec2 uv = 30. * fragCoord / iResolution.y; \n\n  \tvec3 color = vec3(0, 0.1, 0.3);\n\n    \n    for (int i = 1; i < 24; i++)\n    {\n       uv +=  sin(uv.yx);\n    }\n    \n\n  \n    color += sin(uv.y * 0.4 + 0.5 );\n\n\n\n  \tfragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 301]], "test": "untested"}
{"id": "3tdSWN", "name": "Target Color Transition", "author": "hzhou17", "description": "Transitioning the color of the Target logo.", "tags": ["target"], "likes": 1, "viewed": 420, "published": 3, "date": "1580964988", "time_retrieved": "2024-07-30T21:25:39.005920", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 color_white = vec3(1,1,1);\n\n    vec3 color_red = vec3(1,0,0);\n\n    float pct = distance(uv,vec2(0.89, 0.5));\n\n    float inner = 1.0 - step(0.13, pct);\n\n    float middle = 1.0 - step(0.2825, pct);\n\n    float outter = 1.0 - step(0.4, pct);\n\n    float target_shape = (outter - middle + inner);\n\n    float target_shape_inverse = 1.0 - target_shape;\n\n    vec3 target_A =\n    mix(color_white, color_red, target_shape);\n\n    vec3 target_B =\n    mix(color_white, color_red, target_shape_inverse);\n\n    vec3 color = mix(target_A, target_B, sin(iTime));\n\n\t  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 746]], "test": "untested"}
{"id": "3ttSW4", "name": "2 graphics from single geometry", "author": "dmitrykolesnikovich", "description": "here I develop my style of writing shaders in OOP way.\nthis shader demonstrates that 2 different graphics (circle and ring) that are build from 1 geometry of ring.\nand a little bit animation for fun\nto stop animation uncomment 14th line `#define time 0.`", "tags": ["circle", "glsl", "oop"], "likes": 1, "viewed": 316, "published": 3, "date": "1580949881", "time_retrieved": "2024-07-30T21:25:39.766886", "image_code": "/*\nThe idea here is to demonstrate that like in SQL tables are designed in order to\nplays nicely with specific queries in GLSL geometry is also designed specifically\nto further graphics procedure to use in.\n\nI mean that circle graphics is based on ring geometry not circle geometry.\n\nSo, in real life geometry and graphics are tight coupled unfortunately\n(https://en.wikipedia.org/wiki/Loose_coupling)\n*/\n\n/*support*/\n\n// #define time 0.\n#define time iTime\n#define RED vec3(1, 0, 0)\n#define BLUE vec3(0, 0, 1)\n#define BOUNCE1 abs(sin(time * 3.))\n#define BOUNCE2 abs(sin(time * 10.))\nvec2 normalization(vec2 p) { return (2. * p - iResolution.xy)/ iResolution.y; }\n\n/*objects*/\n\n// below is Circle constructor that defines new circle instance in following steps:\n//   origin in Cartesian\n//   converts Cartesian to polar \n//   geometry in polar \n//   graphics in polar \n//   coloring \n//   one to one mapping to instance without post-production effects\nvec3 Circle(vec2 p, vec3 color) \n{\n\tvec2 origin = vec2(0);\n    float radius = .3;\n    float antialiasing = .05 + BOUNCE1 * .4;\n    p -= origin;\t\t\t\t       // define origin in Cartesian cs\t\n    float polarCoordinate = length(p); // transform Cartesian cs to polar cs\n    \n    // define ring geometry in polar cs by mapping [0..Inf] to [radius..radius * 1.025]\n    float ringGeometry = smoothstep(radius, radius * (1. + antialiasing), polarCoordinate); \n    \n    // \"graphics query\" as I call it that defines circle graphics based on ring geometry\n    vec3 smoothCircleGraphics = vec3(1. - ringGeometry);\n    \n    vec3 coloring = smoothCircleGraphics * color; \n    \n    vec3 instance = coloring; // no post-production effects\n    return instance; // the nice little thing here is that I semantically return new instance of object like it's not glsl function but real constructor in real programming language\n}\n\nvec3 Ring(vec2 p, vec3 color) \n{\n\tvec2 origin = vec2(0);\n    float radius = .4 + BOUNCE2 * .02;\n    p -= origin;\t\t\t\t       \n    float polarCoordinate = length(p); \n    float ringGeometryOutside = smoothstep(radius, radius * 1.05, polarCoordinate); \n    float ringGeometryInside = 1. - smoothstep(radius * 0.95, radius, polarCoordinate); \n    float ringGeometry = ringGeometryInside + ringGeometryOutside;\n    vec3 smoothCircleGraphics = vec3(1. - ringGeometry);\n    vec3 coloring = smoothCircleGraphics * color; \n    vec3 instance = coloring;\n    return instance;\n}\n\n/*canvas*/\n\nvoid mainImage(out vec4 canvas, in vec2 pixel)\n{\n\n    vec2 p = normalization(pixel); // normalization\n    canvas = vec4(0); // init\t\n    canvas += vec4(Circle(p, RED), 1); // append Circle\n    canvas += vec4(Ring(p, BLUE), 1); // append Ring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 583, 611, 611, 662], [677, 951, 985, 985, 1857], [1859, 1859, 1891, 1891, 2424], [2438, 2438, 2486, 2486, 2681]], "test": "untested"}
{"id": "WldXW4", "name": "Japanese flag", "author": "l0lcube", "description": "i made this by accident. it kind of looks like the japanese battle flag", "tags": ["flag", "japan", "accidental"], "likes": 2, "viewed": 319, "published": 3, "date": "1580949411", "time_retrieved": "2024-07-30T21:25:40.617611", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 res = iResolution;\n    vec3 crimsonRed = vec3(0.73725490196, 0., 0.17647058823);\n   \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/min(res.x, res.y);\n    \n    vec3 col = vec3(1.,1.,1.);\n    \n    float r = 0.4 + 2.* smoothstep(0.0,0.1,sin(atan(uv.y, uv.x)*16. - iTime*3.));\n\n    col *= crimsonRed + smoothstep(r, r+0.01, length(uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 436]], "test": "untested"}
{"id": "tl3XWN", "name": "Pacman Ghost", "author": "hanabi", "description": "cheap thrills", "tags": ["pacman"], "likes": 2, "viewed": 318, "published": 3, "date": "1580938964", "time_retrieved": "2024-07-30T21:25:41.492273", "image_code": "#define M_PI 3.14159265358\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 center = iResolution.xy / 2.;\n    float r = iResolution.y / 4.;\n\n    fragColor = vec4(0.35, 0.9, 1, 1);\n    \n    // round part\n    if (distance(fragCoord, center) < r && fragCoord.y > center.y - 1.)\n        fragColor = vec4(.9, 0, 0, 1);\n    // rectangle part\n    float r2 = r / 1.5;\n    float r_bottom = center.y - r2;\n    if (distance(fragCoord.x, center.x) < r && fragCoord.y > r_bottom && fragCoord.y < center.y + 1.)\n        fragColor = vec4(.9, 0, 0, 1);\n    // flappy part\n    if (distance(fragCoord.x, center.x) < r && fragCoord.y < r_bottom) {\n\t\tif (fragCoord.y > (r_bottom - r2)\n            + r2 * 0.25 * sin(M_PI / 180. * (float(iFrame * 5) - (fragCoord.x - center.x) * 5.)))\n        \tfragColor = vec4(.9, 0, 0, 1);\n    }\n    \n    // eyes\n    vec2 eye_pos_1 = center;\n    eye_pos_1.y += r / 4.;\n    eye_pos_1.x -= r - r / 3. - r / 100.;\n    vec2 eye_pos_2 = eye_pos_1;\n    eye_pos_2.y -= r / 1.8;\n    if (distance(fragCoord, eye_pos_1) + distance(fragCoord, eye_pos_2) <\n        distance(eye_pos_1, eye_pos_2) + r / 4.)\n        fragColor = vec4(1);\n    if (distance(fragCoord, eye_pos_2 - vec2(r/12.,-r/6. + 5. * sin(M_PI / 180. * float(iFrame)))) < r / 6.)\n        fragColor = vec4(0, 0, 1, 1);\n    \n    eye_pos_1 = center;\n    eye_pos_1.y += r / 4.;\n    eye_pos_2 = eye_pos_1;\n    eye_pos_2.y -= r / 1.8;\n    if (distance(fragCoord, eye_pos_1) + distance(fragCoord, eye_pos_2) <\n        distance(eye_pos_1, eye_pos_2) + r / 4.)\n        fragColor = vec4(1);\n    if (distance(fragCoord, eye_pos_2 - vec2(r/12.,-r/6. + 5. * sin(M_PI / 180. * float(iFrame)))) < r / 6.)\n        fragColor = vec4(0, 0, 1, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtcXD4", "name": "XEYES", "author": "hanabi", "description": "trick is to press on canvas, move mouse outside, release it, then hover back on canvas again...", "tags": ["eyes"], "likes": 4, "viewed": 326, "published": 3, "date": "1580934314", "time_retrieved": "2024-07-30T21:25:42.348982", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 center = (iResolution / 2.).xy;\n\tfloat eye_size = iResolution.y / 4.;\n    float eye_border = eye_size / 10.;\n    vec2 eye_pos = vec2(eye_size * 1.5, 0);\n    vec2 eye_pos_l = center - eye_pos;\n    vec2 eye_pos_r = center + eye_pos;\n    \n    fragColor = vec4(0.8, 0.8, 0, 1);\n    float d_l = distance(eye_pos_l, fragCoord);\n    float d_r = distance(eye_pos_r, fragCoord);\n    if (d_l < (eye_size + eye_border) || d_r < (eye_size + eye_border))\n        if (d_l > eye_size && d_r > eye_size)\n        \tfragColor = vec4(0);\n        else\n\t\t\tfragColor = vec4(1);\n    \n    vec2 eye_ball_l = eye_pos_l - ((eye_pos_l - iMouse.xy) / iResolution.xy) * (eye_size - eye_border) / 1.2;\n    if (distance(eye_ball_l, fragCoord.xy) < eye_size / 3.)\n        fragColor = vec4(0);\n\n    vec2 eye_ball_r = eye_pos_r - ((eye_pos_r - iMouse.xy) / iResolution.xy) * (eye_size - eye_border) / 1.2;\n    if (distance(eye_ball_r, fragCoord.xy) < eye_size / 3.)\n        fragColor = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1090]], "test": "untested"}
{"id": "wt3XW4", "name": "Super Hexagon (Bonus Stage)", "author": "cook1ee", "description": "Shader inspired by the game \"Super Hexagon\" (last stage). Hope you like it :)\nYou can control the arrow with your mouse.", "tags": ["game", "superhexagon"], "likes": 6, "viewed": 442, "published": 3, "date": "1580924541", "time_retrieved": "2024-07-30T21:25:43.109947", "image_code": "#define SHAPE(N) cos(round(a / (pi * 2. / float(N))) * (pi * 2. / float(N)) - a) * dist\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926535;\n    \n    float rot = mod(iTime, 5.) > 4.5 ? (pi * 4. * (mod(iTime, 5.) - 4.5)) : 0.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = 3. * 2. * (uv - vec2(.5, .5));\n    coord.x *= iResolution.x / iResolution.y;\n    float a = mod(atan(coord.y, coord.x) + rot, pi * 2.);\n    float dist = length(coord);\n\tfloat r = pi * 2. / float(6);\n    \n    vec3 col = vec3(0.);\n    \n    float ma = mod(atan(iMouse.y - iResolution.y / 2.,\n                       (iMouse.x - iResolution.x / 2.)), pi * 2.);\n    float pw = 0.1 - (dist - 1.5) * 0.75;\n    if(dist > 1.5 && dist < 1.65 && ma > a - pw / 2. && ma < a + pw / 2.)\n    {\n        col = vec3(1.);\n    }\n    \n    float cOff = 0.1 * sin(iTime * pi * 2.);\n    \n    for(int i = 0; i < 5; i++)\n    {\n        float spd = 3.;\n        float spawn_spd = .6;\n    \tif(SHAPE(6) > .8 + spd - spd / spawn_spd * mod(iTime, spawn_spd) + float(i) * spd \n           && SHAPE(6) < 1. + spd - spd / spawn_spd * mod(iTime, spawn_spd) + float(i) * spd)\n    \t{\n            int num = i + int(floor(iTime / spawn_spd));\n            for(int j = 1; j <= 6; j++)\n            {\n                float sine = sin(float(num) * float(j) * 100.);\n                \n                int all_white = 1;\n                for(int s = 1; s <= 6; s++)\n            \t{\n                    if(sine < .5)\n                    {\n                    \tall_white = 0;\n                    }\n                }\n                \n                int seg = int(floor((a + r * 0.5) / r));\n                if(a < r / 2.) seg = 6;\n                int clear_seg = 1 + int(round(2.5 + 2.5 * sin(float(num) * 100.)));\n                if(seg == j && sine < .5)\n                {\n                    if(j != clear_seg && all_white == 0)\n                    {\n        \t\t\t\tcol = vec3(1.);\n                    }\n                }\n            }\n    \t}\n    }\n    if(SHAPE(6) > .8 + cOff && SHAPE(6) < 1. + cOff)\n    {\n        col = vec3(1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 146, 146, 2161]], "test": "untested"}
{"id": "WtcSW4", "name": "Day 48", "author": "jeyko", "description": "just fyi the code is not very tidy.", "tags": ["mdtmjvm"], "likes": 22, "viewed": 824, "published": 3, "date": "1580921230", "time_retrieved": "2024-07-30T21:25:43.871910", "image_code": "vec3 glow = vec3(0);\n    \n#define iTime (iTime + 10.)\n#define mx (iTime*0.9 + 20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n#define dmin(a, b) a.x < b.x ? a : b\n#define pmod(a,x) mod(a,x) - x*0.5\n\nvec3 path(float z){\n    z *= 0.4;\n\treturn vec3(\n    \tsin(z + cos(z)*0.6),\n    \tcos(z + sin(z*0.8)*0.5),\n    \t0.\n    )*1.;\n}\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1)/k,0.,1.);\n    return mix(d2, d1, h) - k*h*(1. - h);  \n}\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\n\nfloat modu;\nfloat moduB;\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    vec2 n = normalize(p.xy);\n    #define modDist 1.\n    #define tunnW 0.7\n    #define pipeW 0.04\n    \n    vec3 g = p;\n    p.z = pmod(p.z, modDist);\n    \n    vec3 o = p;\n    //p.xy *= rot(0.4 + p.z*(0.1 + sin(iTime*0.1) )+ iTime*0.3);\n    vec2 pC = vec2(atan(p.y,p.x), length(p.xy));\n    \n    vec3 q = vec3(pC, p.z);\n\n    \n    // hex\n    //vec4 hc = HexCoords(vec2(pC.x, z)*20.);\n    vec4 hc = HexCoords(vec2(pC.x, p.z*2.)*1.);\n    \n    float dHex = hc.y - 0.1 + sin(o.z)*0.06;\n    dHex = max(dHex, -length(o.xy*1.) + tunnW*0.6);\n    //dHex = max(dHex, length(o.xy*1.) - tunnW*0.97);\n    //d = dmin(d, vec2(dHex, 2.));    \n    \n    q.y -= tunnW*1.;\n    \n    q.x = pmod(q.x*4.,1.);\n    q.z = pmod(q.z,0.2);\n        \n    // pipes\n    float dPipes = min(length(q.xy) - pipeW,length(q.zy) - pipeW );\n    \n    // dots\n    #define pi acos(-1.)\n    q = vec3(pC, g.z);\n    q.z = pmod(q.z, 0.14);\n    \n    q.x = pmod(q.x*3.*pi + 0.5, 1.);\n    \n    q.y -= tunnW*0.9;\n    q.y *= 15.;\n    q.z *= 8.;\n    float dDots = length(q) - 0.4;\n    //dDots *= 0.7;\n    \n    \n    // mod\n    float mm = sin(iTime*0.5 + g.z*0.5 + p.z);\n    modu = (mm/sqrt(0.02 + mm*mm ))*0.5 + 0.5;\n    float mmB = sin(iTime*1.25 + g.z*0.25 + p.z*0.8 + p.y);\n    moduB = (mmB/sqrt(0.01 + mmB*mmB ))*0.5 + 0.5;\n    //moduB = 1. - moduB;\n    moduB *= 0.16;\n    //modu = 1.;\n    \n    // thing\n    dPipes = mix(dPipes,dDots,moduB*0.7  + 0.);\n    \n    float dThing = mix(\n    \tdHex, dPipes, modu*1. + 0.3\n    );\n    d = dmin(d, vec2(dThing, 2.));\n    \n    // tunnel\n    float dTunn = -length(o.xy*1.) + tunnW;\n    dTunn = max(length(o.xy*1.) - tunnW - 0.02, dTunn);\n    dTunn = max(dTunn, -dThing);\n    d = dmin(d, vec2(dTunn, 10.));\n    \n    \n    \n    d.x *= 0.14;\n\treturn d;\n}\n\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\thit = false;\n    p = ro;\n    t = 0.;\n    vec2 d;\n    for(int i = 0; i < 200; i++){\n    \td = map(p);\n        if (d.y < 10.){\n            glow += mix(\n                mix(\n                    exp(-d.x*5.)*pal(1.3,0.7,vec3(1.8+modu*0.5,0.4,0.8), 3.9 +modu*0.2 + sin(p.z)*0.5,2. + t*0.1)*2.,\n                    exp(-d.x*0.01)*pal(2.8,1.4,vec3(5.8,2.4+modu*0.2,0.8+ sin(p.y + iTime)*.09), 6.9 +modu*0.2 + sin(p.z)*.5,0.5 + t*0.5)*2.,\n                    moduB\n                ),exp(-d.x*20.)*pal(0.8,0.7,vec3(1.8+modu*0.5,0.4,0.8), 3.9 +modu*0.2 + sin(p.z)*0.5,1.9 - t*0.1)*2.\n                , 1. - modu\n            );\n        \t\n        \n        } else {\n        \tglow += exp(-d.x*2.)*pal(0.2,1.9,vec3(1.8,0.4,0.8), 5.6 ,2.- t*0.1)*0.4;\n        }\n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv,uv)*0.2;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    ro += path(ro.z);\n    vec3 lookAt = ro + vec3(0,0,4);\n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    float t; bool hit;\n    vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n        //vec3 N = getNormal\n\t\tcol += 0.04;\n    }\n        \n    col *= 0.4;\n    col = pow(col,vec3(0.45));\n    \n    col += glow*0.011;\n    uv *= 0.8;\n    col *= 1. - dot(uv,uv);\n    //col *= 1. - t*0.2;    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 287, 287, 391], [392, 392, 442, 442, 540], [541, 595, 618, 618, 715], [718, 718, 743, 743, 1006], [1085, 1085, 1102, 1102, 2874], [2876, 2876, 2946, 2946, 3833], [3835, 3835, 3877, 3877, 4031], [4032, 4032, 4089, 4089, 4723]], "test": "untested"}
{"id": "3ltXR8", "name": "A cup of coffee (Progressive)", "author": "PixelPhil", "description": "An experiment of photorealism and progressive rendering on a still life subject.\n- Drag the mouse for interactive mode\n- Press 'S' or reset timer to restart slideshow mode (It needs to be manually restarted when going fullscreen)\nMore infos in comments.", "tags": ["coffee", "refraction", "bokeh", "sampling", "ibl", "pbr", "progressive", "ashtray"], "likes": 69, "viewed": 1819, "published": 3, "date": "1580909132", "time_retrieved": "2024-07-30T21:25:45.199361", "image_code": "//\n// A cup of coffee by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Music: A cup of coffee - DJ Okawari\n\n// For this shader, I started with music as an inspiration. I wanted to present a\n// still life scene with as much photorealism I could cram in a shader. I started with\n// a porcelain cup reusing the PBR stuff I coded for my Piranah Plant shader, then came\n// the metal jug and the ashtray. Because the ashtray looked silly I tried to make it\n// transparent. That's the moment I fell into the rabbit hole... It proved to be a much harder\n// problem to solve and my first implementation with true refraction (quasi unlimited glass\n// layer traversal) ended up compiling in over two minutes on my laptop (which is my benchmark\n// for lousy performances). I ended up hacking things up and simplifying it down to 20s by\n// removing everything unnecessary from the SDF. The big Aha! moment was when I realized\n// that things improved dramatically when tracing opaque objects and transparent ones\n// separately and compositing the result afterward. Although it feels like more work\n// it compiles much faster and, to my surprise, also performs better as well.\n// To reach < 10s I had to sacrifice a few instances of nice Voronoise for some ugly\n// texture noise... oh well...\n\n// I seized the opportunity of rendering a 'static' scene to implement a progressive\n// rendering scheme and rely heavily on jittering for anything from soft shadows to\n// anti-aliasing or glossy reflexions.\n\n// The meat of the code is all in buffer A. If you feel like toying, you will find there\n// defines to play with.\n\n//\n// DISCLAIMER: Smoking is a bad habit that may cause cancer and many health issue\n// it is neither advised nor encouraged by this shader.  ;)\n//\n\n\n// This buffer does only final frame compositing\n\n#define KEN_BURNS_ZOOM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fetch the secret top ixel and determine if slideshow mode is on\n    vec4 mixData = texture(iChannel0, vec2(0,0));\n    bool SlideShow = (mixData.z > 0.0);\n    \n    float fade = 1.0;\n    \n    vec2 uvs = fragCoord.xy / iResolution.xy;\n    \n    if (SlideShow)\n    {\n        // For a better thumbnail the time is offset by 5s\n        float time = iTime;\n        if (iResolution.x <= 300.0) time -= 5.0;  \n            \n        // In slideshow mode determine the moment in the slide we are in\n        float frameTime = time * 0.1;\n        float frameRatio = 1.0 - fract(frameTime);\n        \n        // Add a fade to black to hide the integration under the rug\n        fade  = smoothstep(0.01, 0.15, frameRatio);\n        fade *= smoothstep(0.99, 0.95, frameRatio);\n        \n        \n        // Add a Ken burns zoom for a bit of dynamism\n        #ifdef KEN_BURNS_ZOOM\n        float zoom = 1.0 - frameRatio * frameRatio * 0.1;\n        uvs = vec2(0.5) + (uvs - vec2(0.5)) * zoom;\n        #endif\n    }\n\n\t// The image is read in the buffer in linear space\n    // it is only encoded into gamma space before being presented\n    vec4 linearImage = textureLod(iChannel1, uvs, 0.0);\n    vec3 col = pow(linearImage.rgb * fade,vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21117, "src": "https://soundcloud.com/juailes/dj-okawari-a-cup-of-coffee", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "\n#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\nvec2 combineMax(vec2 a, vec2 b)\n{\n    return (a.x > b.x)? a : b;\n}\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://iquilezles.org/articles/voronoise\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\nfloat Voronoi( in vec2 x, float u)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float va = 1000.0;\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = sqrt(d);\n        va = min(va, w);\n    }\n\n    return va;\n}\n\n\n\n// A 2d Noise\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    //diff = smoothstep(vec2(0), vec2(1), diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n\n", "buffer_a_code": "\n#define  PROGRESSIVE_RENDERING\n\n// Uncomment one of those lines to focus on a different target in interactive mode\n//#define  ASHTRAY\n//#define  CENTER\n\n// Uncomment this line for a different artistic statement\n//#define MATCAP\n\n// Yan can play with that quantity for a smoother or sharper DOF\n#define BOKEH 0.02\n\n\n\n#define MAX_DST 200.0\n#define MIN_DST 0.004\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define TABLE\t\t \t0.0\n#define COFEE\t\t\t2.0\n#define STEEL\t\t\t3.0\n#define BURNT_TIP\t\t4.0\n#define ASH\t\t\t\t5.0\n#define SUGAR\t\t\t6.0\n#define MILK\t\t\t7.0\n#define CIGARETTE1\t\t8.0\n#define CIGARETTE2\t\t9.0\n#define PAPER\t\t\t10.0\n\n#define GLASS \t\t\t11.0\n\n\n\n// all matrices and offsets that needs to be pre-computed\n// in order to keep the SDF relatively straightforward\nstruct SceneSetup\n{\n    mat4 cup;\n    mat4 spoon;\n    mat4 ashtray;\n    mat4 cig1;\n    mat4 cig2;\n    mat4 jug;\n    mat4 sugar;\n    \n    vec3 noise;\n};\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec4 albedo;\n    float metalness;\n    float roughness;\n    float occlusion;\n};\n\n    \n// Procedural wood veins with optionnal grain\nvoid WoodMaterial(vec3 pos, out PBRMat mat, bool simpler)\n{\n    vec2 p = (pos.xz + pos.yy);\n    float wood = VoroNoise(p * vec2(0.01, 0.08), 0.5, 1.0);\n    \n    wood = fract(wood * 3.0);\n    \n    float wood2 = fract(wood * 10.0);\n    \n    p *= vec2(3.0, 6.0);\n    \n    float noise = 0.5;\n    \n    if (!simpler)\n    {\n        noise = (Noise2(p) + Noise2(p * 2.0)) * 0.5;\n    }\n    \n    wood = wood * 0.5 + wood2 * 0.3 +  noise * 0.2;\n    \n    vec3 woodColor = mix(vec3(0.52, 0.38, 0.25), vec3(0.7, 0.58, 0.4), wood);\n    \n    mat = PBRMat(vec4(woodColor, 1.0), 0.4, noise * 0.3, 1.0); \n}\n\n// Ash material\nvoid AshMaterial(vec3 pos, out PBRMat mat, bool simpler)\n{\n    float noise = VoroNoise(pos.xz * 4.0, 1.0, 0.3);\n    noise = 1.0 - (noise * noise) * 0.75;\n    \n    if (!simpler)\n    {\n       noise -= VoroNoise(pos.xz * 10.0, 1.0, 0.3) * 0.2;\n    }\n    \n    mat = PBRMat(vec4(vec3(noise), 1.0), 0.0, 1.0, 1.0); \n}\n\n// Cigarette material\nvoid CigMaterial(vec3 pos, mat4 cigMat, out PBRMat mat, bool simpler)\n{\n\tvec3 cigPos = (cigMat * vec4(pos, 1.0)).xyz;\n    \n    if (cigPos.y < 4.5) // At the filter\n    {   \n        vec3 filterColor = vec3(0.9, 0.55, 0.01);\n        \n        if (!simpler) // in reflexions the dots are not computed\n        {\n            // Get the cylindrical texture coordinates\n            float angle = atan(-cigPos.z, cigPos.x); \n            vec2 uv = vec2(angle, -cigPos.y);\n            \n            // Add some noise to the domain for more irregular shapes\n            uv = uv * 1.5 + vec2(VoroNoise(uv * 3.0, 1.0, 1.0) * 0.6, 0);\n\n\t\t\t// Threshold a voronoi distance to prodice dots\n            float noise = S(0.2, 0.21, Voronoi(uv, 1.0));\n\n            // Blend two colors\n            filterColor = mix(vec3(0.98, 0.7, 0.01), vec3(0.9, 0.55, 0.01), noise);\n        }\n        \n        mat = PBRMat(vec4(filterColor, 1.0), 0.2, 0.7, 1.0); \n    }\n    else if (cigPos.y < 4.7)\n    {\n        // This is the golden ring of the filter\n    \tmat = PBRMat(vec4(1, 0.7, 0, 1.0), 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        // Te rest is white\n\t\tmat = PBRMat(vec4(0.95, 0.95, 0.95, 1.0), 0.0, 0.5, 1.0); \n    }\n}\n\nvoid CofeeMaterial(vec3 pos, out PBRMat mat, SceneSetup setup)\n{\n    vec3 cofeeCol = vec3(0.15, 0.01, 0.1);\n    \n    pos = (setup.cup * vec4(pos, 1.0)).xyz;\n    \n\tif (pos.y > 5.25)\n    { \n\t\t// Foam\n        float fl = max(0.0, length(pos.xz + vec2(-1.8, 1.5)));\n\n        float foam = S(3.0, 6.0, fl);\n        float foam2 = S(10.0, 3.0, fl);\n        \n        vec3 foamHue = mix(vec3(0.9, 0.7, 0.4), vec3(0.9, 0.8, 0.75) * 0.8, foam2);\n        \n        vec3 foamColor = mix(cofeeCol, foamHue, foam);;\n        \n        mat = PBRMat(vec4(foamColor, 1.0), 0.5, foam, 1.0);\n    }\n    else\n    {\n    \tmat = PBRMat(vec4(cofeeCol, 1.0), 0.5, 0.0, 1.0);\n    }\n}\n\n// Computes a PBR Material from material ID and world position\nvoid GetMaterial(float id, vec3 pos, SceneSetup setup, out PBRMat mat, bool simpler)\n{   \n\n    mat = PBRMat(vec4(1, 0, 0, 1.0), 0.6, 1.0, 0.5); // Default material is red plastic\n    #ifdef MATCAP\n    return;\n    #else\n    \n    \n    if \t\t(id == TABLE\t\t) { WoodMaterial(pos, mat, simpler); } \n    //else if (id == PORCELAIN\t) { mat = PBRMat(vec4(0.9, 0.9, 0.9, 1.0), 0.7, 0.0, 4.0); }\n    else if (id == COFEE\t\t) { CofeeMaterial(pos, mat, setup); }\n    else if (id == STEEL\t\t) { mat = PBRMat(vec4(0.75, 0.75, 0.75, 1.0), 0.95, 0.0, 1.0); }\n    else if (id == GLASS \t\t) { mat = PBRMat(vec4(0, 0, 0, 0.05), 2.0, 0.0, 1.0); }\n    else if (id == ASH\t\t\t) { AshMaterial(pos, mat, simpler); }\n    else if (id == SUGAR\t\t) { mat = PBRMat(vec4(0.8, 0.8, 0.8, 1.0), 0.2, 0.9, 6.0); }\n    else if (id == MILK\t\t\t) { mat = PBRMat(vec4(1, 1, 1, 1.0), 0.0, 0.0, 3.0); }\n    else if (id == CIGARETTE1\t) { CigMaterial(pos, setup.cig1, mat, simpler); }\n    else if (id == CIGARETTE2\t) { CigMaterial(pos, setup.cig2, mat, simpler); }\n    else if (id == PAPER\t\t) { mat = PBRMat(vec4(1, 1, 1, 1.0), 0.3, 1.0, 1.0); }\n    else if (id == BURNT_TIP\t) { mat = PBRMat(vec4(0, 0, 0, 1.0), 0.2, 1.0, 1.0); }\n    \n    #endif\n    \n  \treturn;\t\n}\n\n// Build all the matrices and offsets necessary to compute the SDF\n// leaving all that in would lead to bad perfs and insane compile times\nvoid buildSetup(out SceneSetup res, vec3 target)\n{\n\n    res.cup = translate(target);\n    \n    res.spoon = rotationX(-1.5) *\n        \t\trotationY(-1.0) *\n                translate(vec3(2.0, -0.48, 9.0)) * res.cup;\n    \n    res.ashtray = rotationY(-0.5) * \n        \t\t  translate(vec3(-10.0, -5.0, -20.0)) * res.cup; \n \n    res.cig1 =  rotationX(1.8)*\n                translate(vec3(0.0, 1.0, 10.0)) *\n                res.ashtray;\n\n    mat4 swizzle = \tmat4( 1, 0, 0, 0,\n                          0, 0, 1, 0,\n                          0, 1, 0, 0,\n                          0, 0, 0, 1);\n    \n    res.cig2 =  rotationZ(-2.5)*\n                translate(vec3(-3, -4.0, 3.5)) *\n        \t\tswizzle *\n                res.ashtray;\n    \n    res.jug =  rotationY(3.5) * translate(vec3(18.0, -0.6, -8)) * res.cup;\n        \n    res.sugar = rotationY(2.0) * translate(vec3(-6.2, -0.4, 4.3)) * res.cup;\n}\n\n// A cigarete ditance function with material ids\nvec2 dstCigarette(vec3 pos, float len, float id)\n{\n    vec2 cig = vec2(length(pos.xz) - 0.8, id); // infinite cylinder\n    \n    cig = combineMax(cig, vec2(-pos.y, PAPER)); // cut at the tip of the filter with paper material\n    \n     // cut irregularly at the end with burt black material\n    cig = combineMax(cig, vec2(pos.y - len + (sin(pos.x * 10.0) + sin(pos.y * pos.z)) * 0.029, BURNT_TIP));\n    \n    return cig;\n}\n\n// I use the noise texture mainly to reduce compile time under 10s on my less capable computer\nvec3 TextureNoise(vec2 uvs)\n{\n    return textureLod(iChannel3, uvs, 0.0).rgb;\n}\n\n// SDF of the scene\n// There is a neat trick here to bring back compile time from 30 to 10s\n// When OpaqueOnly is set to true only the opaque obects are returned\n// When it is set to false only glass is returned\n// This produces two simpler SDFs that end up being much more efficient to trace\n// on their own and doing compositing afterward rather than tracing a more complicated\n// one that would include both\nvec2 SDF(vec3 pos, SceneSetup setup, bool opaqueOnly)\n{\n    vec2 res;\n    \n\n    vec3 cupPos = (setup.cup * vec4(pos, 1.0)).xyz;\n    \n    // cup starts with the coumpound of a round cylinder and round cone\n    float cup = sdRoundedCylinder(cupPos, 2.0, 0.25, 0.0);\n    float cupsp = sdRoundCone(cupPos - vec3(0, 4.5,0), 6.2, 7.4, 10.0 );\n   \tcup = smin(cup, cupsp, 1.0);\n    \n    \n    // is a reduced version of the cup's hull cut at a level\n    float coffee = cup + 0.5;\n\tcoffee = smax(coffee, cupPos.y - 5.5, 0.3);\n    \n    // Cup is hollowed with onioning and cut open\n    cup = abs(cup) - 0.5; \n    cup = smax(cup, cupPos.y - 8.0, 0.6) * 0.5;\n    \n    // The plate starts with a rounded cylinder stretched in x and z\n    vec3 platePos = cupPos * vec3(0.35, 1.0, 0.35);\n    float plate = sdRoundedCylinder(platePos  - vec3(0, 1.0,0), 2.0, 2.0, 0.0);\n    \n    // hollowed with onioning and cut \n    plate = abs(plate) - 0.1;\n    plate = smax(plate, cupPos.y - (1.0), 0.4);\n    \n    // a torus is added at the base of the cup for extra detail\n    plate = smin(plate, sdTorus(cupPos - vec3(0, -0.8, 0), vec2(5.1, 0.3)), 0.6);\n    plate *= 0.35; // Adjusts for ray tracing misses\n    \n    \n    // Then handle is an elongated torus that is scaled along x on the liower left quarter  \n    vec3 handlePos = cupPos.xzy - vec3(8.1, 0.0, 4.5);\n    float scale = 1.0;\n    \n    if (handlePos.x < 0.0 && handlePos.z < 0.0)\n    {\n        scale = 0.6;\n        handlePos.x *= scale;\n    }\n    handlePos.y = max(0.0, abs(handlePos.y) - 0.5);\n    float handle = sdTorus(handlePos, vec2(2.2, 0.45));\n    \n     \n    res = vec2(coffee, COFEE); // combine coffee in the final result\n    \n    // The table is a rounded cylinder\n    vec3 tablePos = cupPos - vec3(-15.0, -3.0, 43.0);\n    float table = sdRoundedCylinder(tablePos, 30.0, 1.0, 1.0);\n    \n    // It has a foot (check it out ;) ) that is an infinite cylinder cut a level\n    float tablefoot = max(tablePos.y, length(tablePos.xz) - 4.5);\n    \n    res = combineMin(res, vec2(table, TABLE)); // table is combines in the final result\n    \n\n\n    vec3 sponPos = (setup.spoon * vec4(pos, 1.0)).xyz;\n    \n    // The spoon starts with a 2D disk sdf with a top half stretched\n    if (sponPos.y > 0.0) sponPos.y *= 0.7;\n    sponPos.x *= 1.1;\n    float len = length(sponPos.xy);\n    float spoon = len - 2.8; \n    \n    // The handle starts with a trapezoid sdf with it's tip smoothly clamped\n   \tif (sponPos.y < 0.0)\n    {\n        float handle = abs(sponPos.x) - 0.5 + sponPos.y * 0.04;\n        handle = smax(handle,  -16.0 - sponPos.y, 1.0);\n        \n        spoon = smin(spoon, handle, 1.5);\n    }\n    \n    // That resulting 2D shape is the used to stencil cut a combination of distances\n    // function to describe the curvature of the handle and the spoon itself\n    float d = (len / 3.0);\n    d = smin(d * d, 1.0, 0.2);\n    \n    float k = abs(sponPos.x);\n    \n    float bend = S(-1.8, -4.5, sponPos.y);\n    k = k* k * 0.2;\n    k *= bend;\n    \n    spoon = smax(spoon, -0.1 + abs(sponPos.z -  bend * 0.5 - d + k), 0.05);\n    \n    // It is super non-euclidean and honestly I couldn't believe I would get away with it\n    // but it turned out that just adjusting the ray marching step a bit produced a clean result\n    spoon *= 0.5;\n    \n\n    vec3 ashtrayPos = (setup.ashtray * vec4(pos, 1.0)).xyz; \n    \n    \n\t// Ashtray, like many other things, starts with a rounded cylinder\n    float ashtray = sdRoundedCylinder(ashtrayPos - vec3(0, -0.7,0), 4.5, 0.6, 4.0);\n    \n\n   \tif (ashtray - 4.0 > 0.0) //Bounding volume optimisation for the ashtray\n   \t{\n        ashtray = ashtray - 3.5;\n    }\n    else\n    {\n\t\t// The cigarette holder holes are cut with an infinite cylingder\n        // elongated on y with a central domain symmetry\n        \n        vec3 cylPos = abs(ashtrayPos);\n        if (cylPos.x > cylPos.z) cylPos.xz = cylPos.zx;\n        cylPos.y = max(0.0, abs(cylPos.y) - 1.0);\n        float cyl = length(cylPos.yx) - 1.0;    \n        \n        ashtray = abs(ashtray) - 0.8;\t\t\t\t// Hollwed with onioning\n        ashtray = smax(ashtray, ashtrayPos.y, 0.5); // Cut open\n        ashtray = smax(ashtray, -cyl, 0.35);\t\t// Removed holder holes\n        \n        // The ash level is a combination of the squared central ditance to the ashtray\n        // and some arbitrary sines\n        float l = length(ashtrayPos.xz) / 5.0;\n        l = l * l * 0.7;\n        float ash = ashtrayPos.y + 3.5 + sin(ashtrayPos.x * 0.3 - 0.4)  + sin(ashtrayPos.z * 0.76) * 0.25 + l;\n        ash = smax(ash, -ashtrayPos.y - 4.75, 0.25);\n        \n        if (ash - 1.0 > 0.0) // Do not compute details of the ash unless very close\n        {\n            ash -= 0.5;\n        }\n        else\n        {\n            // VoroNoise is more pleasing to the eyes but adds 2s to compile time on my PC Laptop per call in the SDF\n        \t// ash += VoroNoise(ashtrayPos.xz * 2.5, 1.0, 0.55) * 0.6;\n            ash += TextureNoise(ashtrayPos.xz * 2.5 / 64.0).r * 0.9;\n        \tash *= 0.6;\n        }\n        \n        \n        vec3 cig2Pos = (setup.cig2 * vec4(pos, 1.0)).xyz;\n\n        // The second cigarette is crushed, so I mess with it's domain\n        cig2Pos.x += abs(sin(pos.x)) * 0.3;\n            \n        vec2 cig2 = dstCigarette(cig2Pos, 6.0, CIGARETTE2);\n        \n        // Put all that trash together\n        res = combineMin(res, vec2(ash, ASH));\n        res = combineMin(res, cig2);\n    }\n    \n    \n    // Leave the first cigarette out of the Ashtray bound optimisation as it is on the edge\n    // and prone to raycast misses\n    vec3 cig1Pos = (setup.cig1 * vec4(pos, 1.0)).xyz;\n\tvec2 cig1 = dstCigarette(cig1Pos, 14.0, CIGARETTE1);\n    res = combineMin(res, cig1);\n   \n\n    // See comments on top of the function\n    // When opaqueOnly is set to false, ignore the glass entierly\n    // The compiler will strip it out\n    if (!opaqueOnly)\n    {\n        cup = smin(handle,cup, 0.5);\n        cup = min(ashtray,cup);\n        cup = min(plate,cup);\n\n        // When opaqueOnly is set to true, just return the glass\n        // The compiler will strip out all dead code and produce a lightweight SDF\n        return vec2(cup, GLASS);\n    }\n\n\n    \n    vec3 jugPos = (setup.jug * vec4(pos, 1.0)).xyz;\n    //jugPos -= vec3(-18, 0.6, 8);\n    //jugPos = (rotationY(3.5) * vec4(jugPos, 0.0)).xyz;  \n    \n    float jug = sdRoundCone( jugPos - vec3(0, 0, 0), 4.0, 3.0, 10.0 );\n    \n    \n    if (jug - 7.0 > 0.0) // Bounding box optimisations for the milk jug\n    {\n        jug = jug - 4.3;\n    }\n    else\n    {\n        // The spout is an infinite cylinder bent and scale on the x axis\n        vec2 spoutPos = jugPos.xz;\n        spoutPos.x *= 0.7;\n        spoutPos.x += jugPos.y * 0.23;\n\n        // combines with the jug body\n        jug = smin(jug, length(spoutPos) - 1.0, 0.2);\n\n        jug = smax(jug, -jugPos.y - 1.5, 1.0); // cut below\n\n        jug = abs(jug) - 0.1;  // hollowed with onioning\n\n        jug = smax(jug, jugPos.y - 8.5, 0.1); // cut above\n        jug *= 0.8; // adjust for raycast misses\n\n\t\t// The Handle is an elongated, hollowed cylinder bent with some domain distortion\n        vec3 jugHandlePos = jugPos - vec3(5.0, 4.5, 0);\n\n        //jugHandlePos.x -= jugHandlePos.y * 0.1;\n        jugHandlePos = max(vec3(0.0), abs(jugHandlePos) -vec3(jugPos.y * 0.1 + 0.25, 2.3, 0.0));\n\n        float jughandle = abs(length(jugHandlePos.xy) - 0.6) - 0.1;\n\n        jughandle = smax(jughandle, abs(jugHandlePos.z) - 0.6, 0.1);\n\n        jug = min(jug, jughandle);\n\n        // Got milk?\n        float milk = sdRoundedCylinder(jugPos - vec3(0.0, 4.0, 0), 1.5, 0.35, 0.0);\n        res = combineMin(res, vec2(milk, MILK));\n    }\n\n    // Integrate everything steel in the final result\n    res = combineMin(res, vec2(min(min(spoon, jug), tablefoot), STEEL));\n    \n    // Sugar is a rounded bow with added noise\n    vec3 sugarPos = (setup.sugar * vec4(pos, 1.0)).xyz;\n    float sugar = sdRoundBox(sugarPos, vec3(1.8, 0.6, 0.9), 0.3);\n    \n    if (sugar - 0.5 < 0.0)\n    {\n        // Changed to bring back compile time under 10s on my laptop\n        //sugar += VoroNoise((sugarPos.xz + sugarPos.yx)  * 6.0, 1.0, 0.5) * 0.1;   \n        sugar += TextureNoise((sugarPos.xz + sugarPos.yx)  * 8.0 / 64.0).r * 0.1;\n        sugar *= 0.7;\n    }\n    \n\tres = combineMin(res, vec2(sugar, SUGAR)); // Finally add sugar :D\n\n\treturn res;\n}\n\n\n// Like the SDF, normals can be computed with glass or solid objects\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos, SceneSetup ps, bool opaqueOnly)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, ps, opaqueOnly).x;\n    }\n    return normalize(n);\n}\n\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst, SceneSetup ps, bool opaqueOnly)\n{\n    vec2 dst = vec2(5.0, 0.0);\n\n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, ps, opaqueOnly);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\nfloat shadow(vec3 pos, vec3 normal, vec3 lPos, SceneSetup ps)\n{       \n#ifdef PROGRESSIVE_RENDERING\n    lPos += ps.noise * 8.0; // In progressive mode, the light position is jittered for smooth shadows\n#endif\n    \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += normal * MIN_DST * 40.0;\n    \n    \n    vec2 ray =  castRay(pos, dir, MAX_DST, MIN_DST * 10.0, ps, true);\n    if (ray.x < MAX_DST) return 0.0; // if it crosses something opage shadow is full\n    \n    ray =  castRay(pos, dir, MAX_DST, MIN_DST * 10.0, ps, false);\n    if (ray.x < MAX_DST) return 0.45; // if it crosses something transparent shadow is partial\n    \n    // No shadow\n    return 1.0;\n}\n\n// Convert the St Peters Basilica red ambiance to something more blueinsh and desaturated\nvec3 AmbianceLight(vec3 texColor)\n{\n    vec3 color = texColor.bgr; // swizzle to change red to blue\n    float gs = dot(color, vec3(0.33)); // grayscale value\n    color = mix(color, vec3(gs), 0.5); // desaturate\n    return color * color; // convert to linear space\n}\n\nvec3 SkyDomeBlurry(vec3 rayDir, float lod)\n{\n    rayDir.z = -rayDir.z;\n    return AmbianceLight(textureLod(iChannel2, rayDir.xyz,  lod).rgb);\n}\n\nvec3 SkyDomeSharp(vec3 rayDir)\n{\n    rayDir.z = -rayDir.z;\n    return AmbianceLight(textureLod(iChannel2, rayDir.xyz,  0.0).rgb);\n}\n\n// Simplified render within reflection\nvec3 ReflectionLight(vec3 pos, vec3 n, float matId, vec3 rayDir, SceneSetup setup)\n{\n     PBRMat mat;\n     \n     GetMaterial(matId, pos, setup, mat, true); // Comput material\n     mat.albedo.rgb *= mat.albedo.rgb; \n\n     // Fresnel\n     float fresnel = pow(1.0 - sat(dot(n, -rayDir)), 1.0);\n\n     // Just some basic facing ratio and environment lighting\n     vec3 col = fresnel * mat.albedo.rgb;\n    \n     if (mat.roughness < 0.5)\n     {\n         vec3 refDir = reflect(rayDir, n);\n         col += SkyDomeSharp(refDir) * fresnel * 0.6;\n     }\n    \n\t return col;\n}\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float lightRadius, float fresnel, SceneSetup ps, bool AddEnv)\n{\n    //Basic lambert shading stuff\n    \n    vec3 key_Dir = lightPos - pos;\n    float key_len = length(key_Dir);\n    \n    float atten = sat(1.0 - key_len / lightRadius);\n    atten *= atten;\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir)) * atten;\n    float key_shadow = shadow(pos, normal, lightPos, ps); \n    \n    float diffuseRatio = key_lambert * key_shadow;\n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo.rgb, mat.metalness);\n    \n    vec3 col = mat.albedo.rgb * key_diffuse * min(1.0, 2.0 - mat.metalness * 2.0);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * atten * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n    //Optionnal environment reflection (only for key light)\n    if (AddEnv)\n    {\n       vec3 hitPos = pos + normal * MIN_DST * 40.0;\n       \n#ifdef PROGRESSIVE_RENDERING\n       refDir = normalize(refDir + (ps.noise * mat.roughness * 0.5));\n#endif\n        \n       // Cast two rays\n       // One with only opage objects\n       vec2 hitOpaque = castRay(hitPos, refDir, MAX_DST, MIN_DST * 5.0, ps, true);\n       // One with oly transparent ones\n       vec2 hitGlass  = castRay(hitPos, refDir, MAX_DST * 0.5, MIN_DST * 5.0, ps, false);\n        \n       vec3 refCol;\n       \n       if (hitOpaque.x < MAX_DST)\n       {\n           // If opaque did hit we reflect that\n           vec3 refPos = hitPos + refDir * hitOpaque.x;\n           vec3 refN = calcNormal(refPos, ps, true);\n           refCol = ReflectionLight(refPos, refN, hitOpaque.y, refDir, ps);\n       }\n       else\n       {\n           // otherwise we reflect the skydome\n           refCol = SkyDomeSharp(refDir);\n       }\n        \n        \n       if (hitGlass.x < MAX_DST * 0.5 && hitGlass.x < hitOpaque.x)\n       {\n           // If the glass is before the solid hit then we reflect that too\n           vec3 refPos = hitPos + refDir * hitGlass.x;\n           vec3 refN = calcNormal(refPos, ps, false);\n           refCol += ReflectionLight(refPos, refN, hitGlass.y, refDir, ps);\n       }\n\n       col += f * refCol * specRatio;\n    }\n    \n    return max(vec3(0), col);\n}\n\n// Shades and integrate a surface point from its position, normal and material id\nvec3 IntegrateSurface(vec3 col, vec3 pos, vec3 n, float matId, vec3 rayDir, SceneSetup setup)\n{ \n     PBRMat mat;\n     \n     GetMaterial(matId, pos, setup, mat, false);\n     \n     mat.albedo.rgb *= mat.albedo.rgb; // Convert albedo to linear space\n\n     vec3 ambient = SkyDomeBlurry(n, 5.0);\n     ambient *= mat.occlusion * 0.5;\n    \n     col = mix(col, mat.albedo.rgb * ambient, mat.albedo.a);\n     \n     // Fresnel\n     float fresnel = pow(1.0 - sat(dot(n, -rayDir)), 1.0);\n\n     // Add both light contributions\n\t vec3 key_LightPos = vec3(10.0, 24.0, -13.0);\n     col += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(1.0), 1000.0, fresnel, setup, true);\n                  \n     vec3 fill_LightPos = vec3(-20.0, 15.0, 20.0);\n     col += PBRLight(pos, n, rayDir, mat, fill_LightPos, vec3(1.0), 1000.0, fresnel, setup, false);\n\n\treturn col;\n}\n\n\n// Render a ray including refraction of glass\nvec4 renderRefract(vec3 camPos, vec3 rayDir, SceneSetup setup)\n{\n\n    // Cast to rays on on solid things on on glass only\n    vec2 hitSolid = castRay(camPos, rayDir, MAX_DST, MIN_DST, setup, true);\n    vec2 hitGlass = castRay(camPos, rayDir, MAX_DST * 0.5, MIN_DST, setup, false);\n    \n    // I know it seems weird, but it's much more efficient to proceed this way and\n    // to trace both rays from the camera on two much simpler SDFs\n    \n    vec3 solidPos;\n    vec3 solidRayDir;\n    float solidMat;\n    \n    vec3 glassPos;\n    vec3 glassNormal;\n    bool needGlass = false;   \n    bool needSolid = false;\n    bool needSky = false;\n    \n    vec3 skyDir = rayDir;\n    \n    if (hitGlass.x < hitSolid.x && hitGlass.x < MAX_DST * 0.5)\n    {\n        // Glass is before anything solid\n        \n        // wee keep track of the glass surface\n        needGlass = true;\n        glassPos = camPos + rayDir * hitGlass.x;\n        glassNormal = calcNormal(glassPos, setup, false);\n        \n        // refract the ray and shoot again in the opage SDF\n        vec3 dir2 =  normalize(rayDir - glassNormal * 0.5);\n        \n        vec2 hitRefract = castRay(glassPos, dir2, MAX_DST, MIN_DST, setup, true);\n        \n        if (hitRefract.x < MAX_DST)\n        {\n            // Refraction hit! that's the opaque surface we'll shade\n            needSolid = true;\n            solidPos = glassPos + dir2 * hitRefract.x;\n            solidMat = hitRefract.y;\n        }\n        else\n        {\n            // It's a miss, we need to refract the sky dome\n            needSky = true;\n            skyDir = dir2;\n        }       \n    }\n    else\n    {\n        // No glass here\n        if (hitSolid.x < MAX_DST)\n        {\n            // a solid his si confirmed, we'll render that\n            needSolid = true;\n            solidPos = camPos + rayDir * hitSolid.x;\n            solidRayDir = rayDir;\n            solidMat = hitSolid.y;\n        }\n        else\n        {\n            // No hit, the skydome is straight ahead\n            needSky = true;\n            skyDir = rayDir;\n        }\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (needSky) // Render the skydome if needed\n    {\n        col =  SkyDomeBlurry(skyDir, 0.0); \n    }\n    \n\n    if (needSolid) // Render the opaque surfaces if needed\n    {\n        col = IntegrateSurface(col, solidPos, calcNormal(solidPos, setup, true), solidMat, rayDir, setup);\n    }\n\n\n    if (needGlass) // Render glass if needed\n    {\n        col = IntegrateSurface(col, glassPos, glassNormal, GLASS, rayDir, setup);\n    }\n\n  \n    return vec4(col, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(mouse.x<.001) mouse = vec2(0.37, 0.4);\n    \n    \n    // There's a hidden pixel in the corner of the frame that store\n    // xy: previous mouse position\n    // z: 0 -> Interactive Mode / 0.1 and above -> Slideshow frame tick\n    // w: Integration amount for progressive rendering convergence\n    vec4 mixData = texture(iChannel0, vec2(0,0));\n    \n    bool SlideShow = (mixData.z > 0.0);\n    \n    if (iTime < 0.1) // When time is reset we turn off progressive integration for a while\n    {\n        mixData.xy = mouse; // Set the mouse pos\n        mixData.a = 1.0;    // Integrate 100%\n        mixData.z = 0.1;    // Force SlideShow mode\n    }\n    \n    float finalMix = mixData.a;\n    \n    // Compute the index of the Slide of the diaporama we are showing\n    \n    float time = iTime;\n    if (iResolution.x <= 300.0) time -= 5.0; // For a better thumbnail the time is offset by 5s\n    \n    float frameTime = time * 0.1;\n    float frameId = floor(frameTime);\n        \n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        // We are rendering the secret control pixel\n        \n        // Update the pixel with up to date info\n        fragColor.xy = mouse;\n        fragColor.z = mixData.z;\n        \n        vec2 mouseDiff = mixData.xy - mouse;\n        \n        float diffSq = dot(mouseDiff, mouseDiff);\n        if (diffSq > 0.00001)\n        {\n            // If the mouse has moved\n           \tfragColor.a = finalMix = 1.0; // Restart integration\n            fragColor.z = 0.0; // Turn off Slideshow mode\n            \n        }\n        else\n        {\n            // For the mage integral to quickly converge to the average of all the computed \n            // frames the blending ratio must follow the sequence 1; 1/2; 1/3; 1/4 etc...\n#ifdef PROGRESSIVE_RENDERING\n            float div = 1.0 / finalMix; // current divisor\n            fragColor.a = max(0.01, 1.0 / (div + 1.0)); // new divisor (never less than 1%)\n            \n            if (SlideShow)\n            {\n                float frame = 0.1 + mod(frameId, 5.0) * 0.1; // Compute the slideshow 'tick'\n\n                if (abs(mixData.z - frame) > 0.01) // If we just chnanged Slide\n                {\n                    // Restart integration from scratch for the new frame to converge quickly\n                    fragColor.a = finalMix = 1.0;\n                    fragColor.z = frame; // Record the change for next frame\n                }       \n            }\n#else\n            fragColor.a = 1.0; // No integration when turned off\n#endif\n\n        }\n        \n        return;\n    }\n    \n    vec3 target;\n    vec2 viewAngle;\n        \n    if (SlideShow)\n    {\n\t\t// In slideshow mode\n        float viewPoint = mod(frameId, 3.0);\n        vec4 ranges;\n        \n        // Round robin on the 3 targets\n        if (viewPoint == 0.0)\n        {\n            // Coffee cup\n            target = vec3(0.0);\n            ranges = vec4(-1.3, 1.8, -0.2, -0.8);\n        }\n        else if (viewPoint == 1.0)\n        {\n            // Ashtray\n            target = vec3(10.0, 0.0, 20.0);\n            ranges = vec4(0.15, 2.0, -0.2, -1.2);\n        }\n        else\n        {\n            // Composition center\n            target = vec3(0.0, 0.6, 10);\n            ranges = vec4(-1.0, 1.8, -0.2, -0.5);\n        }\n        \n        \n        // Shuffle the view angle from pre-determined ranges\n        float v = mod(frameId + 1.0, 6.0) / 5.0;\n        float h = mod((frameId + 1.0) * 3.0, 7.0) / 6.0;\n        \n        float vert = mix(ranges.z, ranges.w, v);\n        float horiz = mix(ranges.x, ranges.y, h);\n\n        \n        viewAngle = vec2(horiz, vert);\n        // In slideshow mode the camera rotates very slowly to create some sort of subliminal parralax\n        viewAngle.x += fract(frameTime) * 0.06;\n    }\n    else\n    {\n        // In intergactive mode aim at a fixed point an orient the view with the mouse\n        target = vec3(0.0);\n    \n        #ifdef ASHTRAY\n        target = vec3(10.0, 0.0, 20.0);\n        #endif\n\n        #ifdef CENTER\n        target = vec3(0.0, 0.6, 10);\n        #endif\n        \n        viewAngle = vec2((-mouse.x - 0.6) * pi2, (mouse.y - 0.65) * halfPi);\n    }\n       \n    \n\n    SceneSetup setup;\n    \n    \n    // Build matrices\n    buildSetup(setup, target);\n    \n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y; \n\n    // Compute Camera\n    vec3 camPos = vec3(0.0, 2.0, -50.0);\n    \n    vec3 camDir = vec3(0.0, 0.0,  1.0);\n    \n    // Get some 3D noise to jitter some stuff\n    vec2 noiseUv = uv + vec2(mod(iTime, 45.0), 0.0);\n    setup.noise = hash3(noiseUv) - vec3(0.5); // vec3(n, n2, fract((n + n2) * 456.345));\n    \n    // Jitter the ray direction at sub-pixel level for perfect AA\n    #ifdef PROGRESSIVE_RENDERING\n    vec2 aa = setup.noise.xy * 0.5 / iResolution.y;\n    #else\n    vec2 aa = vec2(0);\n    #endif\n    \n    vec3 rayDir = camDir + vec3(uv * 0.45 + aa , 0.0) ;\n    \n    \n    \n   \tvec3 res = vec3(0.0);\n\n    // Slightly jitter the camera around the focal point for depth of field\n    #ifdef PROGRESSIVE_RENDERING\n    viewAngle += setup.noise.xy * BOKEH;\n    #endif\n    \n    \n    // Orient the camera\n    mat4 viewMat = rotationY(viewAngle.x) * rotationX(viewAngle.y);\n    \n    camPos = (viewMat * vec4(camPos, 1.0)).xyz;\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n    \n\n    // Render the pixel\n    res = renderRefract(camPos, rayDir, setup).rgb;\n\n    // Integrate the new pixel with the previous frame.\n    // The integration is done in linear space for the result to be gamma correct.\n    #ifdef PROGRESSIVE_RENDERING\n    vec3 prevFrame = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0).rgb;\n    res = mix(prevFrame, res, finalMix);\n    #endif\n    \n\n    // Output to buffer\n    fragColor = vec4(res.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This buffer backs up the current frame and litens to the 'S' key\n// To restart the slideshow. That's about it\n\n#define KEY_S 83.0\n\n\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel1, uv).r;\n\n        return key > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 inputTex =  textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0);\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        // In the secret pixel\n        \n        if (isPressed(KEY_S))\n        {\n            inputTex.z = 0.1; // Restart slideshow\n            inputTex.a = 1.0; // Reset integration\n        }\n        \n        if (iResolution.x <= 300.0 && inputTex.z == 0.0)\n        {\n            inputTex.z = 0.1; // Force Slideshow mode in the thumbnail\n        }\n    }\n    \n    fragColor = inputTex;\n}\n\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1935, 1935, 1992, 2063, 3260]], "test": "untested"}
{"id": "3t3SD4", "name": "OOP + GLSL = LOVE", "author": "dmitrykolesnikovich", "description": "What I am doing is trying to apply object-oriented culture to GLSL.", "tags": ["experiment", "glsl", "oop"], "likes": 3, "viewed": 880, "published": 3, "date": "1580908511", "time_retrieved": "2024-07-30T21:25:45.990247", "image_code": "//\n// Below is attempt to apply object-oriented culture to GLSL.\n//\n// Any shader I can think of consists of canvas and objects\n// \n// canvas\n//   normalization\n//   init\n//   append objects with `+=`\n// \n// object\n//   coordinates\n//   geometry\n// \t graphics\n//\t coloring\n//   invoke standard constructor\n// \n\n/*standard*/\n\n#define constructor(geometry, graphics, coloring) geometry ? graphics * coloring : vec3(0.)\n\n/*support*/\n\n#define normalizeCoordinates(p) (p.xy / iResolution.xx * 4. - .1) * 3.\n#define RED vec3(1, 0, 0)\n#define GREEN vec3(0, 1, 0)\n#define BLUE vec3(0, 0, 1)\nvec2 rotate(vec2 v, float a) { a = a / 180. * 3.14; float s = sin(a); float c = cos(a); mat2 m = mat2(c, -s, s, c); return m * v; }\nfloat parity(vec2 id) { return mod(id.x + id.y, 2.); }\n\n/*object*/\n\nvec3 Object(vec2 p, vec2 m, vec3 coloring)\n{\n    vec2 center = p - m; // coordinates\n \tbool geometry = center.x * center.x + center.y * center.y < 1.; // geometry\n    float graphics = parity(rotate(p, -45.)); // graphics\n    coloring.b *= sin(p.x * 2.); // coloring\n    return constructor(geometry, graphics, coloring); // invoke standard constructor\n}\n\n\n/*canvas*/\n\nvoid mainImage(out vec4 canvas, in vec2 pixel)\n{\n    // normalization\n    vec2 p = normalizeCoordinates(pixel);\n    vec2 m = normalizeCoordinates(iMouse);\n    \n    // init\n    canvas = vec4(0);\n    \n    // append objects with `+=`\n    canvas += vec4(Object(p, m, RED), 1);\n    canvas += vec4(Object(p, m + vec2(.95, 1.7), GREEN), 1);\n    canvas += vec4(Object(p, m + vec2(2, 0), BLUE), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3SD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 583, 613, 613, 714], [715, 715, 738, 738, 769], [783, 783, 827, 827, 1135], [1150, 1150, 1198, 1219, 1541]], "test": "untested"}
{"id": "wttXDH", "name": "Whoosh", "author": "Arseny", "description": "Whoosh", "tags": ["2d"], "likes": 1, "viewed": 286, "published": 3, "date": "1580898700", "time_retrieved": "2024-07-30T21:25:46.750214", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n\nfloat DirLineDst(vec2 A, vec2 B, vec2 C){\n    vec2 tmp = vec2(-(A - B).y, (A - B).x);\n    return dot(tmp, C - B) / length(tmp);\n}\n\nconst float r = 0.4;\nconst int k = 7;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    // Output to screen\n    vec2 cntr = vec2(iResolution.x / iResolution.y / 2., 0.5);\n    float t = 0.2 + 0.1*sin(iTime) + 0.5;\n    //float t = iTime;\n    if (length(uv - cntr) < r){\n    \tfragColor = vec4(vec3(1),1.0);\n    } else {\n        fragColor = vec4(vec3(0),1.0);            \n    }\n    /*vec2 spec = vec2(r / 2., 0.) + vec2(r / 2., 0.) * rot(pi * t);\n    \n    for (int i = 0; i < k; i++){\n        vec3 col = vec3(1. - float(i) / float(k), float(i) / float(k), 0.0);\n        float dst1 = DirLineDst(cntr + vec2(r, 0.) * rot(2. * pi * float(i) / float(k)), cntr + spec * rot(2. * pi * float(i) / float(k)), uv);\n        float dst2 = DirLineDst(cntr + spec * rot(2. * pi * float(i) / float(k)), cntr + vec2(r, 0.) * rot(2. * pi / float(k) * (float(i) + 2. * t)), uv);\n        \n        if (dst1 > 0. && dst2 > 0. && length(cntr - uv) < r){\n            fragColor = vec4(col,1.0);\n           \treturn;\n        }        \n    }*/\n    vec2 spec = vec2(r / 2., 0.) * rot(pi * t / 2. - pi) + vec2(r / 2., 0.);\n    vec2 base = vec2(r, 0.);\n    float baseDst = length(spec - base);\n    for (int i = 0; i < k; i++){\n    \tvec3 col = vec3(1. - float(i) / float(k - 1), float(i) / float(k - 1), 0.0);\n        float dst1 = length(cntr + spec * rot(2. * pi / float(k) * float(i)) - uv);\n        //float dst2 = length(cntr + spec * rot(2. * pi / float(k) * float(i)) - base);\n        vec2 speccntr = vec2(r / sqrt(2.), 0.) * rot(2. * pi / float(k) * float(i + 1) - pi / 4.);\n        vec2 specpoint = vec2(r, 0.) * rot(2. * pi / float(k) * float(i) + sqrt(2. * t));\n        if (length(uv - cntr) < r  && dst1 > baseDst && length(specpoint - speccntr) > length(cntr + speccntr - uv)){\n            fragColor = vec4(col,1.0);\n        }\n    }\n    if (fragColor.g > 0.99){\n        vec3 col = vec3(1. - float(0.) / float(k), float(0.) / float(k), 0.0);\n        float dst1 = length(cntr + spec * rot(2. * pi / float(k) * float(0.)) - uv);\n        //float dst2 = length(cntr + spec * rot(2. * pi / float(k) * float(i)) - base);\n        vec2 speccntr = vec2(r / sqrt(2.), 0.) * rot(2. * pi / float(k) * float(1.) - pi / 4.);\n        vec2 specpoint = vec2(r, 0.) * rot(2. * pi / float(k) * float(0.) + sqrt(2. * t));\n        if (length(uv - cntr) < r  && dst1 > baseDst && length(specpoint - speccntr) > length(cntr + speccntr - uv)){\n            fragColor = vec4(col,1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 113, 113, 201], [242, 242, 299, 349, 2849]], "test": "untested"}
{"id": "tttSDH", "name": "exploring Logistic Map attractor", "author": "FabriceNeyret2", "description": "use mouse in the inset to explore the Logistic Map attractor.\n+ - : changes zoom level", "tags": ["2d", "fractal", "map", "chaos", "logistic", "bifurcation", "short", "logisticmap"], "likes": 15, "viewed": 1092, "published": 3, "date": "1580897354", "time_retrieved": "2024-07-30T21:25:47.516166", "image_code": "// inspired from Txoka's https://www.shadertoy.com/view/tt3XDr\n// https://en.wikipedia.org/wiki/Logistic_map\n\nvoid mainImage( out vec4 O, vec2 u ){\n    \n    float z = STATE.x,              // zoom factor\n          k = 5.,                   // tune blur ( < 2 ) vs noise ( > 2 )\n          v, y, f = 0.;             // convergence tracker ( when > 0)\n\n    vec2 R = iResolution.xy,\n         U = u/R,\n         M = length(iMouse.xy) < 10.// demo mode or mouse control \n                 ? vec2(.87)*.33 : iMouse.xy/R,\n         V = max(U.x,U.y)<.33       // full view or inset\n                ? U/.33 : M/.33+(U-.5)/z;\n\n    \n    for( float y0 = .1; y0 < 1.; y0+=.1 ) {\n        y = y0 + .1*sin(iTime)/2.;  // sample initial state space\n        for( int i=0 ; ++i<256; ) { // --- test convergence\n            y *= 4.*V.x *(1.-y);\n            v  = y - V.y;\n            f += exp(-3e5*k*k*v*v); // diagram is where v converges towards 0, i.e. y converges to U.y\n        }\n    } f /= 10.;\n\n    O = vec4(1.-.2*k*f);\n    \n    if ( max(U.x,U.y)<.33 ) {       // --- inset coloring\n        U = abs(M-U)/.33;\n        max(U.x,U.y) < .5/z ? O.gb -= .3 : O.rg -= .07; \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// persistant states ( key tuning )\n\n#define keyDown(a)  ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U != vec2(.5) ) discard;\n    \n    if ( iFrame < 1 )           // --- init\n        O = vec4( 10, 0,0,0);   // O.x: zoom value \n    \n    else {\n        O = STATE;\n        if (   keyDown(187)               // '+'  ( true ascii: 43 )\n            || keyDown(107) ) O.x *= 1.2; // numpad\n        if (   keyDown( 54)               // '-' azerty ( true ascii: 45 )\n            || keyDown(189)               //     qwerty\n            || keyDown(109) ) O.x /= 1.2; // numpad\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define STATE texelFetch(iChannel0,ivec2(0),0) // 4 persistant states", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 147, 147, 1155]], "test": "untested"}
{"id": "wltSWH", "name": "The Nautilus, Part 3", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\"; part 3 of a series.", "tags": ["submarine", "sciencefiction", "verne"], "likes": 9, "viewed": 388, "published": 3, "date": "1580894782", "time_retrieved": "2024-07-30T21:25:48.472609", "image_code": "// \"The Nautilus, Part 3\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"; part 3 of a series.\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl;\nint idObj;\nbool bmOn;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nfloat WakeFac (vec3 p)\n{\n  vec2 tw;\n  tw = Rot2D (p.xz - sbPos.xz, sbRot);\n  tw.y += 6.5;\n  return (1. - smoothstep (0.3, 0.6, abs (tw.x) + 0.1 * tw.y)) * clamp (1. - 2. * tw.y, 0., 0.2) *\n     smoothstep (-5., -2., tw.y);\n}\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.3, -1.);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n    col4.rgb *= 0.5;\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rob[2], rdb[2], bgCol, ltVec, roo, row, vnw;\n  vec2 lbDist;\n  float dstObj, dstObjO, dstCave, dstWat, sh, atten, wkFac, s;\n  bool waterRefl;\n  dstObj = ObjRay (ro, rd);\n  dstCave = CaveRay (ro, rd);\n  if (dstCave < min (dstObj, dstFar)) {\n    dstObj = dstCave;\n    idObj = idCav;\n  }\n  sh = 1.;\n  atten = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  roo = ro;\n  dstObjO = dstObj;\n  bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);\n  waterRefl = false;\n  if (rd.y < 0. && ro.y + rd.y * dstObj < 0.) {\n    dstWat = - ro.y / rd.y;\n    waterRefl = (dstWat < min (dstObj, dstFar) && ro.y + rd.y * dstWat < 0.001);\n  } else {\n    dstWat = dstFar;\n  }\n  if (waterRefl) {\n    ro += dstWat * rd;\n    row = ro;\n    vnw = VaryNf (0.2 * ro, vec3 (0., 1., 0.), 0.1);\n    wkFac = WakeFac (row);\n    if (wkFac > 0.) vnw = VaryNf (8. * row, vnw, 16. * wkFac);\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstCave = CaveRay (ro, rd);\n    if (dstCave < min (dstObj, dstFar)) {\n      dstObj = dstCave;\n      idObj = idCav;\n    }\n    if (bmOn) {\n      rob[1] = ro;\n      rdb[1] = rd;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    ltVec = roo + ltPos - ro;\n    s = length (ltVec);\n    atten = (1. - smoothstep (0.1, 0.6, s / dstFar)) / (1. + 0.002 * pow (s, 1.5));\n    ltVec /= s;\n    if (idObj == idCav) {\n      vn = CaveNf (ro);\n      col4 = vec4 (mix (vec3 (0.55, 0.5, 0.5), vec3 (0.3, 0.4, 0.2),\n         smoothstep (0.5, 0.8, vn.y)), 0.5);\n      sh = min (CaveSShadow (ro, ltVec), CaveAO (ro, vn));\n      vn = VaryNf (ro, vn, 12.);\n    } else {\n      vn = ObjNf (ro);\n      col4 = NautColN (ro, vn);\n      sh = ObjSShadow (ro, ltVec);\n    }\n    if (col4.a >= 0.) col = col4.rgb * sh * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n    col = mix (col, bgCol, smoothstep (0.45, 0.99, dstObj / dstFar)) * atten;\n  } else col = bgCol;\n  if (waterRefl) col = mix (vec3 (0.1, 0.2, 0.3) * (0.2 + 0.8 * atten), col, 0.5);\n  if (waterRefl && wkFac > 0.) {\n    s = Fbm3 (16. * row);\n    col = mix (col, vec3 (0.7), 4. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n  }\n  if (bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    if (lbDist.x < min (min (dstObjO, dstWat), dstFar))\n       col = mix (col, vec3 (1., 1., 0.7), 0.7 * (1. - lbDist.y));\n    if (waterRefl) {\n      lbDist = LBeamRay (rob[1], rdb[1]);\n      if (lbDist.x < min (min (dstObj, dstWat), dstFar))\n         col = mix (col, vec3 (0.8, 1., 0.7), 0.4 * (1. - lbDist.y));\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, dVu;\n  uv = fCoord;\n  cvSize = 7.;\n  bmOn = true;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  fpF = TrackPathCv (t + 0.1);\n  fpB = TrackPathCv (t - 0.1);\n  sbPos = 0.5 * (fpF + fpB);\n  sbPos.y = 0.09;\n  vd = fpF - fpB;\n  sbRot = atan (vd.x, vd.z);\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n  t += 20. * dVu;\n  fpF = TrackPathCv (t + 0.1 * sign (dVu));\n  fpB = TrackPathCv (t - 0.1 * sign (dVu));\n  ro = 0.5 * (fpF + fpB);\n  ro.x += 2. * (1. - abs (dVu));\n  ro.y = 2. + 2. * (1. - abs (dVu));\n  vd = sbPos - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  dstFar = 50. * cvSize;\n  zmFac = 1.4;\n  ltPos = vuMat * vec3 (0., 1., 1.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fCol = col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSWH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1282, 1282, 1310, 1310, 1409], [1411, 1411, 1434, 1434, 1695], [1697, 1697, 1731, 1731, 1936], [1938, 1938, 1971, 1971, 2162], [2164, 2164, 2186, 2186, 2442], [2444, 2444, 2482, 2482, 2728], [2730, 2730, 2754, 2754, 2954], [2956, 2956, 2979, 2979, 5860], [5862, 5862, 5884, 5884, 6044], [6046, 6046, 6079, 6079, 6262], [6264, 6264, 6285, 6285, 6540], [6542, 6542, 6579, 6579, 6820], [6822, 6822, 6845, 6845, 7181], [7183, 7183, 7217, 7217, 7439], [7441, 7441, 7464, 7464, 7723], [7725, 7725, 7764, 7764, 10423], [10425, 10425, 10460, 10460, 13175], [13177, 13177, 13222, 13222, 14216], [14218, 14218, 14274, 14274, 14747], [14749, 14749, 14782, 14782, 14871], [14873, 14873, 14919, 14919, 14966], [14968, 14968, 15001, 15001, 15028], [15030, 15030, 15072, 15072, 15123], [15125, 15125, 15184, 15184, 15315], [15317, 15317, 15370, 15370, 15431], [15433, 15433, 15479, 15479, 15536], [15538, 15538, 15560, 15560, 15598], [15600, 15600, 15636, 15636, 15842], [15844, 15844, 15889, 15889, 15992], [15994, 15994, 16051, 16051, 16134], [16136, 16136, 16166, 16166, 16279], [16313, 16313, 16337, 16337, 16390], [16392, 16392, 16416, 16416, 16546], [16548, 16548, 16572, 16572, 16635], [16637, 16637, 16661, 16661, 16881], [16883, 16883, 16908, 16908, 17094], [17096, 17096, 17121, 17121, 17346], [17348, 17348, 17373, 17373, 17694], [17696, 17696, 17721, 17721, 17867], [17869, 17869, 17891, 17891, 18045], [18047, 18047, 18068, 18068, 18223], [18225, 18225, 18246, 18246, 18401], [18403, 18403, 18432, 18432, 18644], [18646, 18646, 18685, 18685, 18870]], "test": "untested"}
{"id": "wldSWH", "name": "Coming Alive II", "author": "NinaFranziska", "description": "static but alive, mesmerizing and alienating", "tags": ["cineshader"], "likes": 9, "viewed": 26522, "published": 3, "date": "1580894197", "time_retrieved": "2024-07-30T21:25:49.242551", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n   uv -= vec2(0.5,0.5); //we make the whole thing black\n   uv *= 2.0; //we remap the coordinates to become between -1 and 1\n float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n\n   fragColor = vec4(color, color, color, color); \n}\n\n\n//trippy 1\n  /* float distance = sin(length(uv));\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime)*6.0;\n   fragColor = color*vec4(1.0, 1.0, 1.0, 1.0); \n\n//real beautiful trippy\n  float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime)*6.0;\n   fragColor = color*vec4(1.0, 1.0, 1.0, 1.0); \n\n\n//trippy variation (using *iTime-iTime) (for instagram)\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n   fragColor = vec4(color, color, color, 1.0); \n\n//crazy trippy (when multiplying time with a high number - you get many cycles/arms\n   float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*20.0*iTime)*cos(angle+distance*iTime)*6.0;\n   fragColor = color*vec4(1.0, 1.0, 1.0, 1.0);\n}\n\n\n//trippy in colours\n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n\tfloat color2 =  sin(angle+distance*10.0*iTime)\n   fragColor = vec4(color, color2, 1.0, 1.0); \n\n//trippy in rainbow colours\n    float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n\tfloat color2 =  sin(angle+distance*10.0+iTime)*cos(angle+distance*iTime - iTime);\n    float color3 =  sin(angle+distance*10.0+iTime)*cos(angle+distance*iTime)*3.0;\n   fragColor = vec4(color, color2, color3, 1.0); \n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 478]], "test": "untested"}
{"id": "tldSWH", "name": "Coming Alive", "author": "NinaFranziska", "description": "static but alive, mesmerizing and alienating", "tags": ["cineshader"], "likes": 2, "viewed": 16779, "published": 3, "date": "1580894026", "time_retrieved": "2024-07-30T21:25:50.023463", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n   uv -= vec2(0.5,0.5); //we make the whole thing black\n   uv *= -0.05; //we remap the coordinates to become between -1 and 1\n float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*1000.0)*cos(angle+distance*iTime - iTime)*100.0;\n\n   fragColor = vec4(color, color, color, color); \n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Coming Alive\",\n\t\"description\": \"static but alive, mesmerizing and alienating\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 484]], "test": "untested"}
{"id": "ttdXD8", "name": "Airsolid Glitch color 02", "author": "airsolid", "description": "video glitch color", "tags": ["color", "glitch", "02", "airsolid"], "likes": 34, "viewed": 2104, "published": 3, "date": "1580892983", "time_retrieved": "2024-07-30T21:25:50.792407", "image_code": "\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat blockyNoise(vec2 uv, float threshold, float scale, float seed)\n{\n\tfloat scroll = floor(iTime + sin(11.0 *  iTime) + sin(iTime) ) * 0.77;\n    vec2 noiseUV = uv.yy / scale + scroll;\n    float noise2 = texture(iChannel1, noiseUV).r;\n    \n    float id = floor( noise2 * 20.0);\n    id = noise(id + seed) - 0.5;\n    \n  \n    if ( abs(id) > threshold )\n        id = 0.0;\n\n\treturn id;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float rgbIntesnsity = 0.1 + 0.1 * sin(iTime* 3.7);\n    float displaceIntesnsity = 0.2 +  0.3 * pow( sin(iTime * 1.2), 5.0);\n    float interlaceIntesnsity = 0.01;\n    float dropoutIntensity = 0.1;\n\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n\tfloat displace = blockyNoise(uv + vec2(uv.y, 0.0), displaceIntesnsity, 25.0, 66.6);\n    displace *= blockyNoise(uv.yx + vec2(0.0, uv.x), displaceIntesnsity, 111.0, 13.7);\n    \n    uv.x += displace ;\n    \n    vec2 offs = 0.1 * vec2(blockyNoise(uv.xy + vec2(uv.y, 0.0), rgbIntesnsity, 65.0, 341.0), 0.0);\n    \n    float colr = texture(iChannel0, uv-offs).r;\n\tfloat colg = texture(iChannel0, uv).g;\n    float colb = texture(iChannel0, uv +offs).b;\n\n    \n    float line = fract(fragCoord.y / 3.0);\n\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.333)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n    \n    \n\tfloat maskNoise = blockyNoise(uv, interlaceIntesnsity, 90.0, iTime) * max(displace, offs.x);\n    \n    maskNoise = 1.0 - maskNoise;\n    if ( maskNoise == 1.0)\n        mask = vec3(1.0);\n    \n    float dropout = blockyNoise(uv, dropoutIntensity, 11.0, iTime) * blockyNoise(uv.yx, dropoutIntensity, 90.0, iTime);\n    mask *= (1.0 - 5.0 * dropout);\n\t\n    \n    fragColor = vec4(mask * vec3(colr, colg, colb), 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 22, 22, 60], [62, 62, 83, 83, 175], [177, 177, 247, 247, 560], [563, 563, 620, 620, 1925]], "test": "untested"}
{"id": "tttXD8", "name": "Airsolid glitch color", "author": "airsolid", "description": "video glitch color", "tags": ["color", "glitch", "airsolid"], "likes": 10, "viewed": 963, "published": 3, "date": "1580891529", "time_retrieved": "2024-07-30T21:25:51.625181", "image_code": "//Airsolid Test Glitch\n\nfloat rand(vec2 p)\n{\n    float t = floor(iTime * 50.) / 10.;  //speed \n    return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float blockiness)\n{   \n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    float n1 = rand(id);\n    float n2 = rand(id+vec2(1,0));\n    float n3 = rand(id+vec2(0,1));\n    float n4 = rand(id+vec2(1,1));\n    \n    vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n\n    return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n}\n\nfloat fbm(vec2 uv, int count, float blockiness, float complexity)\n{\n    float val = 0.0;\n    float amp = 0.5;\n    \n    while(count != 0)\n    {\n    \tval += amp * noise(uv, blockiness);\n        amp *= 0.5;\n        uv *= complexity;    \n        count--;\n    }\n    \n    return val;\n}\n\nconst float glitchAmplitude = 0.9; // increase this\nconst float glitchNarrowness = 400.0;\nconst float glitchBlockiness = 10000.0;\nconst float glitchMinimizer = 10.0; // decrease this\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = vec2(uv.x * (iResolution.x / iResolution.y), uv.y);\n    vec2 uv2 = vec2(a.x / iResolution.x, exp(a.y));\n\tvec2 id = floor(uv * 20.0);                           // size noise\n    //id.x /= floor(texture(iChannel0, vec2(id / 8.0)).r * 8.0);\n\n    // Generate shift amplitude\n    float shift = glitchAmplitude * pow(fbm(uv2, int(rand(id) * 6.), glitchBlockiness, glitchNarrowness), glitchMinimizer);\n    \n    // Create a scanline effect\n    float scanline = abs(cos(uv.y * 400.));      //scanline intensite\n    scanline = smoothstep(0.0, 2.0, scanline);\n    shift = smoothstep(0.00001, 0.2, shift);\n    \n    // Apply glitch and RGB shift\n    float colR = texture(iChannel0, vec2(uv.x + shift, uv.y)).r * (1. - shift) ;\n    float colG = texture(iChannel0, vec2(uv.x - shift, uv.y)).g * (1. - shift) + rand(id) * shift;\n    float colB = texture(iChannel0, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n    // Mix with the scanline effect\n    vec3 f = vec3(colR, colG, colB) - (0.1 * scanline); //scanline intensite\n    \n    // Output to screen\n    fragColor = vec4(f, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 171], [173, 173, 213, 213, 518], [520, 520, 587, 587, 799], [985, 985, 1042, 1092, 2212]], "test": "untested"}
{"id": "tltSW8", "name": "Triangulated Actors", "author": "wyatt", "description": "Seems like parallel particle simulations are finally getting cool! \nThis is a pretty fun way of doing it - neighboring particles are stored geometrically - good for massive scale\nHopefully shadertoy community keeps innovating in this area", "tags": ["particles", "triangulation"], "likes": 27, "viewed": 716, "published": 3, "date": "1580876113", "time_retrieved": "2024-07-30T21:25:52.415574", "image_code": "Main {\n    vec4 bb = B(U), cc = C(U), dd = D(U),\n         a = A(bb.xy), b = A(cc.xy);\n    float l = length(U-a.xy),\n        j = smoothstep(5.,4.,l);\n   \tQ = vec4(j)*max(0.6+0.4*sin(.3+(.1*cc.x/R.x+cc.y+1./(1.+10.*length(dd.zw))*vec4(1,2,3,4))),0.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "// Information Storage\nMain {\n\tQ = A(U);\n    if (iMouse.z>0.) {\n        vec2 r = (iMouse.xy-Q.xy);\n        Q.zw -= r/dot(r,r);\n    }\n   \tif (iFrame > 10) \n    Q.zw -= D(Q.xy).zw;\n    //Q.w -= 3e-3;\n    if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n    Q.xy += Q.zw;\n    \n\n    if (Q.x<5.) {Q.x = 5.; Q.z *= -1.;}\n    if (R.x-Q.x<5.) {Q.x = R.x-5.; Q.z *= -1.;}\n    if (Q.y<5.) {Q.y = 5.; Q.w *= -1.;}\n    if (R.y-Q.y<5.) {Q.y = R.y-5.; Q.w *= -1.;Q.z*=0.;}\n    \n    if (init)\n    {\n    \tU = floor(U/15.+0.5)*15.;\n        Q = vec4(clamp(U,vec2(3),R-3.),0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, inout vec4 a, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, vec2 U, float r) {\n\t X(Q,a,U,vec2(r,0));\n     X(Q,a,U,vec2(0,r));\n     X(Q,a,U,vec2(0,-r));\n     X(Q,a,U,vec2(-r,0));\n}\nMain {\n\tQ = B(U);\n    vec4 a = A(Q.xy);\n    Xr(Q,a,U,1.);\n    Xr(Q,a,U,2.);\n    Xr(Q,a,U,3.);\n    Xr(Q,a,U,4.);\n   \tInit {\n    \tQ.xy = A(U).xy;\n        Q.zw = vec2(0.);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Nearest Normalized Bisector\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, vec2 r) {\n    vec4 Qn = C(U+r), qn = B(U+r), na = A(qn.xy), nb = A(Qn.xy);\n   \tfloat l = mp(U,a.xy,b.xy);\n    \n    if (mp(U,a.xy,na.xy)<l) {\n    \tQ = qn;\n        b = na;\n    }\n    if (mp(U,a.xy,nb.xy)<l) {\n        Q = Qn;\n        b = nb;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, float r) {\n\t X(Q,a,b,U,vec2(r,0));\n     X(Q,a,b,U,vec2(0,r));\n     X(Q,a,b,U,vec2(0,-r));\n     X(Q,a,b,U,vec2(-r,0));\n}\nMain {\n\tQ = C(U);\n    vec4 q = B(U),\n         a = A(q.xy),\n         b = A(Q.xy);\n    Xr (Q,a,b,U,1.);\n    Xr (Q,a,b,U,2.);\n    Xr (Q,a,b,U,3.);\n    Xr (Q,a,b,U,4.);\n    \n    vec2 r = b.xy - a.xy;\n    if (length(r)>0.&&length(b.xy)>0.) \n        Q.zw = -r/dot(r,r)+10.*r/dot(r,r)/length(r) \n        - 0.1*abs(dot(b.zw-a.zw,r))*(b.zw-a.zw)*exp(-0.05*dot(r,r));\n    \n    Init {\n        Q = A(U);\n    \tQ.zw = vec2(0);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Sum the forces\nMain {\n\tQ = vec4(0);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n    \tvec2 r = vec2(x,y);\n        Q += C(U+r)*exp(-.5*dot(r,r));\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tGGWK", "name": "White and Green Boxes", "author": "hzhou17", "description": "a", "tags": ["a"], "likes": 1, "viewed": 293, "published": 3, "date": "1580873508", "time_retrieved": "2024-07-30T21:25:53.219425", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n\tfloat step2 = smoothstep(end + blur, end - blur, t);\n\n\treturn step1 * step2;\n\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n\t\n    return band1 * band2;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n\t//uv -= .5; \n    //uv.x *= iResolution.x/iResolution.y;\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n\n    uv.x = -uv.x;\n \n    vec3 col = vec3(0.);\n\n    \n\tfloat maskLeft = Rect(uv, -.3, .0, -0.2, .2, .00001);\n\n    float background = smoothstep(-0.00001, 0.,uv.x);\n    \n  \tfloat maskRight = Rect(uv, 0., .3, -0.2, .2, .00001);  \n    \n    \n    \n    col = vec3(0., .5, .2); \n    \n    col += vec3(1., 1., 1.) * maskLeft;\n    \n    col -= vec3(1., 1., 1.) * maskRight;\n    \n    \n    col += background;\n    \n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 199], [201, 201, 284, 284, 412], [416, 416, 473, 572, 1099]], "test": "untested"}
{"id": "wtcSWH", "name": "deepdiving", "author": "Del", "description": "deep diving \"Twisted Time\" by dr2 - https://www.shadertoy.com/view/XlsyWH\nI always wondered how he got the text to look so good, after stripping down the code, I now understand the technique!", "tags": ["raymarch", "font"], "likes": 6, "viewed": 449, "published": 3, "date": "1580846769", "time_retrieved": "2024-07-30T21:25:53.981388", "image_code": "// deep diving the  \"Twisted Time\" interesting (great looking) text technique by dr2 - https://www.shadertoy.com/view/XlsyWH\n// making this public incase anyone else wants to look at the stripped down code\n\nvec3 sunDir, vnCylIn;\nvec2   fntSize, qnFnt, qnTxt;\nfloat dstFar, rngBlk, bCylRad, bCylHt, dCylIn, dCylOut;\nint idTxt;\nconst float pi = 3.14159;\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvoid CylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  vnCylIn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.)\n  {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.)\n    {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.)\n        s = ro + dCylIn * rd;\n    else\n        s.y = bCylHt;\n    if (abs (s.y) < bCylHt)\n        vnCylIn.xz = s.xz / bCylRad;\n    else if (srdy * ro.y < - bCylHt)\n    {\n      dCylIn = - (srdy * ro.y + bCylHt) / abs (rd.y);\n      if (length (ro.xz + dCylIn * rd.xz) < bCylRad)\n          vnCylIn.y = - srdy;\n      else\n          dCylIn = dstFar;\n    }\n    else\n        dCylIn = dstFar;\n      \n    if (dCylIn < dstFar)\n    {\n      if (a > 0.)\n          s = ro + dCylOut * rd;\n      else\n          s.y = bCylHt;\n      if (abs (s.y) > bCylHt && srdy * ro.y < bCylHt)\n         dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n    }\n  }\n}\n\n//int GetTxChar (int _nc)\n//{\n//    if( _nc>8 ) return 0;\n//    return int[9](0x53,0x48,0x41,\n//                  0x44,0x45,0x52,\n//                  0x54,0x4f,0x59)[_nc];\n//}\n// resorted to this because of the iPhone :)\nint GetTxChar (int _nc)\n{\n    if(_nc==0) return(0x53);\n    if(_nc==1) return(0x48);\n    if(_nc==2) return(0x41);\n    if(_nc==3) return(0x44);\n    if(_nc==4) return(0x45);\n    if(_nc==5) return(0x52);\n    if(_nc==6) return(0x54);\n    if(_nc==7) return(0x4f);\n    if(_nc==8) return(0x59);\n    return 0;\n}\n\nfloat FontTexDf (vec2 p)\n{\n  vec3 tx;\n  float d;\n  ivec2 ip = ivec2 (floor (p));\n  int ic = GetTxChar(idTxt);\n  if (ic != 0)\n  {\n    tx = texture (iChannel0, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n    qnFnt = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  }\n    else d = 1.;\n  return d;\n}\n\n\n// raymarch the text...\nfloat RayMarchText (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, dLim, d;\n  //if (rd.x == 0.) rd.x = 0.001;\n  //if (rd.y == 0.) rd.y = 0.001;\n  //if (rd.z == 0.) rd.z = 0.001;\n  srd = - sign (rd.xy);\n  rdi = 1. / abs (rd.xyz);\n  dHit = 0.;\n  dLim = rngBlk;\n  ro.xy /= fntSize.x;\n  rd.xy /= fntSize.x;\n  ro.xy += 0.5;\n    \n  for (int j = 0; j < 150; j ++)\n  {\n    p = ro + dHit * rd;\n    p.y = mod(p.y,1.0);\t\t\t\t// repeat :)\n    h = rdi.xy * fract (srd * p.xy);\n    d = max (min (fntSize.x, 1.0) * FontTexDf (p.xy), abs (p.z) - 0.5 * fntSize.y);\n    dHit += min (d, 0.01 + fntSize.x * min (h.x, h.y));\n    if (d < 0.0001 || dHit > dLim)\n        break;\n  }\n  if (d >= 0.0001)\n      dHit = dstFar;\n  return dHit;\n}\n\n// box intersect\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n\n// either we check these for 0... or...\n//  if (rd.x == 0.) rd.x = 0.001;\n//  if (rd.y == 0.) rd.y = 0.001;\n//  if (rd.z == 0.) rd.z = 0.001;\n    \n  v = ro / rd;\n    \n  // ...use hacky \"solution\" to avoid propagating non-finite floats\n  v = clamp(v,-1e30, 1e30);\n    \n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df)\n  {\n    dMin = dn;\n    rngBlk = df - dn;\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n    \n  vec3 col, vn, qtTxt, tro, trd, trdd, q, qt, ds;\n  float dstTxt,  db, d, ang, angTxt, rad;\n  fntSize = vec2 (1.9, 1.);\n  dstTxt = dstFar;\n  tro = ro;\n  trd = rd;\n  rad = 7.;\n  bCylRad = rad + 0.6 * fntSize.x;\n  bCylHt = 3.0;\t\t\t\t\t\t// cylinder height\n  CylHit (ro, rd);\n\n  if (dCylIn < dstFar)\n  {\n    // run through 40 letters, marching each one... ouch!\n    for (float k = 0.; k < 40.; k ++)\n    {\n      idTxt = int (mod (k, 10.));\n      ang = 2. * pi * (1. - k / 40.);\n      qt = - vec3 (rad * sin (ang), 0., rad * cos (ang));\n      q = tro - qt;\n      q.xz = Rot2D (q.xz, ang);\n      trdd = trd;\n      trdd.xz = Rot2D (trdd.xz, ang);\n\n      db = BlkHit (q, trdd, vec3 (0.5 * fntSize.x, 3.0*(0.55 * fntSize.x), 0.55 * fntSize.y));\n      if (db < dstFar)\n      {\n        d = db + RayMarchText(q + db * trdd, trdd);\n        if (d < dstTxt)\n        {\n          dstTxt = d;\n          qtTxt = qt;\n          angTxt = ang;\n          qnTxt = qnFnt;\n        }\n      }\n    }\n  }\n    \n  // do the lighting...\n  col = vec3(0.2,0.3,0.2);\n  if (dstTxt < dstFar)\n  {\n    tro += trd * dstTxt;\n    ds = tro - qtTxt;\n    ds.xz = Rot2D (ds.xz, angTxt);\n    if (abs (ds.z) < 0.49 * fntSize.y)\n    {\n      vn = normalize (vec3 (qnTxt, 0.00001));\n      col = vec3 (0.7, 0.7, 0.7);      // extruded edges colour = grey\n    }\n    else\n    {\n      vn = vec3 (0., 0., sign (ds.z));\n      col = vec3 (1., 0.3, 0.3);      // front&back colour = red\n    }\n    vn.xz = Rot2D (vn.xz, - angTxt);\n    col = col * (0.2 + 0.8 * max (dot (sunDir, vn), 0.)) +\n       0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    //col = mix (col, BgCol (tro, reflect (rd, vn)), 0.7 - 0.5 * abs (dot (rd, vn)));\n  }\n\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    \n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = fract(iTime*0.1)*6.28;\n  el = sin(iTime)*0.1;\n  if (mPtr.z > 0.)\n  {\n    az = 2. * pi * mPtr.x;\n    el = 0.4 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.1));\n  ro = vuMat * vec3 (0., 0., -14.);\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  dstFar = 100.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 383, 383, 441], [443, 443, 475, 475, 1512], [1514, 1735, 1760, 1760, 2037], [2039, 2039, 2065, 2065, 2407], [2410, 2434, 2473, 2473, 3163], [3165, 3182, 3227, 3227, 3766], [3768, 3768, 3803, 3803, 5526], [5528, 5528, 5584, 5584, 6420]], "test": "untested"}
{"id": "tlcXD8", "name": "Motion Loop #001", "author": "lsdlive", "description": "Back to shaders.\nCritique & Comments are welcome.", "tags": ["2d", "loop", "motion", "ease"], "likes": 12, "viewed": 618, "published": 3, "date": "1580843755", "time_retrieved": "2024-07-30T21:25:54.807180", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #001\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_001.fs\n\nWith the help of https://thebookofshaders.com/examples/?chapter=motionToolKit\nWith the help of Flopine, FabriceNeyret2, Pixel Spirit Deck.\n\n*/\n\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\n#define bpm 120.\n#define speed .5\n#define ring_base_sz .0125\n#define ring_base_width .1\n\n#define AA 3.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat flip(float value, float percent) {\n\treturn mix(value, 1. - value, percent);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064320\nfloat easeInOutExpo(float t) {\n    if (t == 0. || t == 1.) {\n        return t;\n    }\n    if ((t *= 2.) < 1.) {\n        return .5 * exp2(10. * (t - 1.));\n    } else {\n        return .5 * (-exp2(-10. * (t - 1.)) + 2.);\n    }\n}\n\n// not used, but can be\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\n// not used, but can be\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t * t;\n    } else {\n        return .5 * ((t -= 2.) * t * t + 2.);\n    }\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064528\n/*float ring(vec2 p, float radius, float width) {\n  \treturn abs(length(p) - radius * 0.5) - width;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // rotation animation\n    float t = easeInOutExpo(fract(time));\n    uv *= r2d((pi / 2.) * (floor(time) + t));\n    \n    // ring size animation\n    float offs = .5;\n\tt = easeInOutExpo(fract(time + offs));\n    float anim_sz = .125 + .125 * sin(pi * .75 + pi * (floor(time + offs) + t));\n    \n    // old solution for anti-aliasing\n    /*\n\tfloat ring = ring(uv, ring_base_sz + anim_sz, ring_base_width);\n    float eps = abs(ring); // sharpen around the ring\n    float sdf = (2. * smoothstep(-eps, eps, uv.x) - 1.) * ring;\n    float mask = smoothedge(sdf, 3.); // cut sdf + AA\n\t*/\n    \n    // Better solution from pixel spirit deck\n    // pixelspiritdeck.com\n    float mask = flip(stroke(circle(uv, ring_base_sz + anim_sz), ring_base_width), fill(uv.x));\n    \n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcXD8.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[582, 582, 601, 601, 667], [669, 669, 690, 690, 747], [749, 882, 918, 918, 990], [992, 992, 1032, 1032, 1075], [1077, 1077, 1113, 1113, 1144], [1146, 1204, 1234, 1234, 1428], [1430, 1454, 1484, 1484, 1607], [1609, 1633, 1664, 1664, 1788], [1952, 1952, 2009, 2009, 2913]], "test": "untested"}
{"id": "tt3XDn", "name": "FWA logo", "author": "edankwan", "description": "Trace the FWA logo with capsule sdf. View this shader at [url]https://cineshader.com/view/tt3XDn[/url]", "tags": ["cineshader"], "likes": 27, "viewed": 254034, "published": 3, "date": "1580840342", "time_retrieved": "2024-07-30T21:25:55.577121", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, out vec3 idx)\n{\n    p = (p + 0.5 * c) / c;\n    vec3 floorP = floor(p);\n    vec3 fractP = fract(p);\n    idx = floorP;\n    return fractP * c - 0.5 * c;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 idx;\n    p = opRep(p, vec3(6.0, 3.0, 5.0), idx);\n    \n    vec2 res = vec2(0.0, 0.0);\n    float thickness = 0.275;\n    float fwaD = 100.0;\n    \n    float r = hash13(idx * 100.0 + floor(iTime * 2.14));\n    \n    if (r > 0.2 + step(dot(idx, idx), 0.5)) {\n        return vec2(0.75, 0.0);\n    }\n    \nfwaD = min(fwaD, sdCapsule(p, vec3(-2.1975012, 0, 0.0), vec3(-1.1325011999999999, 0, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-1.7825011499999996, -0.44249114999999994, 0.0), vec3(-1.7825011499999996, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.9700012499999998, 0.42000885000000004, 0.0), vec3(-1.7825011499999996, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.5375011499999998, -0.44249114999999994, 0.0), vec3(-0.9700012499999998, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.10000124999999968, 0.42000885000000004, 0.0), vec3(-0.5375011499999998, -0.44249114999999994, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.3274987500000003, -0.44249114999999994, 0.0), vec3(-0.10000124999999968, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.7749988500000001, 0.42000885000000004, 0.0), vec3(0.3274987500000003, -0.44249114999999994, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(1.7774988, 0.42000885000000004, 0.0), vec3(0.7749988500000001, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(1.7774988, -0.41249115, 0.0), vec3(1.7774988, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.9424987500000003, -0.41249115, 0.0), vec3(1.7774988, -0.41249115, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.9424741500000001, -0.012491100000000017, 0.0), vec3(0.9424987500000003, -0.41249115, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(2.2149741000000005, -0.015, 0.0), vec3(0.9424741500000001, -0.012491100000000017, 0.0), thickness));\n\t\n    res.x = fwaD;\n    res.y = step(0.24, p.z);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n    \n    float t = iTime * 0.2;\n    vec3 off0 = fract(vec3(t * 2.516 - 0.642, -t * 0.541 - 0.624, t * 0.532 - 0.74)) - 0.5;\n    vec3 off1 = fract(vec3(-t * 0.512 - 0.3412, t * 2.537 - 0.92, -t * 0.5327 - 0.24)) - 0.5;\n    vec3 off2 = fract(vec3(t * 0.47 - 0.835, t * 0.537 - 0.753, -t * 0.47 - 0.845)) - 0.5;\n    vec3 off3 = fract(vec3(t * 0.324 - 0.23, -t * 0.537 - 0.324, t * 2.5327 - 0.56)) - 0.5;\n    \n\tvec3 rayOri = vec3(0.0, 0.0, 3.0) + off0 * off2 * vec3(12.0, 12.0, 6.0);\n    vec3 target = vec3(rotate((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0), dot(off0, off1) * 3.0) * 6.0, 0.0) + off1 * off3 * vec3(12.0, 12.0, 6.0);\n\tvec3 rayDir = normalize(target - rayOri);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n    vec2 res;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tres = map(p);\n        depth += res.x;\n\t\tif (res.x < 1e-5) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(50.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = mix(vec3(0.5), vec3(1.0), b) * 1.75;\n    col *= exp((-depth + 0.5) * 0.15);\n    col *= max(smoothstep(0.1, 0.5, res.x) + 0.075 * b, res.y);\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 1.0) / 20.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"FWA logo\",\n\t\"description\": \"Trace the FWA logo with capsule sdf.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 177, 177, 280], [282, 282, 331, 331, 467], [468, 468, 499, 499, 586], [588, 588, 640, 640, 761], [763, 763, 800, 800, 883], [885, 885, 903, 903, 2938], [2940, 2940, 2970, 2970, 3260], [3262, 3262, 3292, 3292, 3376], [3378, 3378, 3435, 3435, 4742]], "test": "untested"}
{"id": "tl3XW8", "name": "delta mouse events dispersion", "author": "FabriceNeyret2", "description": "stat of mouse events: Try to click and shake the mouse long enough.\nred & green: histogram of | delta MouseX |, | delta MouseY |\nwhite:           histogram of || delta Mouse ||\n\nWhy ? because :-p (out of curiosity).\n", "tags": ["mouse", "experiment", "measure"], "likes": 3, "viewed": 401, "published": 3, "date": "1580837937", "time_retrieved": "2024-07-30T21:25:56.345068", "image_code": "// inspired from https://shadertoy.com/view/tlcSW8\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    O = step( U.y/20. , T(vec2(U.x*640.,0)) / T(vec2(1)).w );\n    O += O.b;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    if ( iMouse.z >= 0. ) {\n        vec2 D = abs( iMouse.xy - T(vec2(1)).xy );\n        float d = length( D );\n        if ( d > 0. ) {\n            if( U == vec2(1.5) )  O.w ++; \n            if ( int(U.x) == int(6.*d  ) ) O.b++;\n            if ( int(U.x) == int(6.*D.x) ) O.r++;\n            if ( int(U.x) == int(6.*D.y) ) O.g++;\n        }\n    }\n    \n    if(U==vec2(1.5))  O.xy = iMouse.xy;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch(iChannel0,ivec2(U),0)\n#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 90, 90, 186]], "test": "untested"}
{"id": "tlcSW8", "name": "framerate dispersion 2", "author": "FabriceNeyret2", "description": "red: histogram of iTimeDelta\ngreen: histogram of manual count time - prev_time.  Should be identical (i.e. yellow)\nBlue: 16.66 ms, corresponding to 60 fps.\nAt least on linux OpenGL, consistant Gaussian dispersion around 60fps (not shown in fps counter)", "tags": ["fps", "measure", "framerate", "experimentitimedelta"], "likes": 2, "viewed": 376, "published": 3, "date": "1580836235", "time_retrieved": "2024-07-30T21:25:57.157895", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    O = step(U.y , T(vec2(U.x*640.,0)) / float(iFrame) );\n    if ( int(u.x) == 333 ) O.b++;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    float t = T(vec2(0)).w;\n    if ( int(U.x) == int(20.*iTimeDelta/1e-3) ) O.r ++;\n    if ( int(U.x) == int(20.*(iTime- t)/1e-3) ) O.g ++;\n    if ( U==vec2(.5) ) O.w = iTime;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch(iChannel0,ivec2(U),0)\n#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 150]], "test": "untested"}
{"id": "WtcXD8", "name": "Day 47 - Isometric 2", "author": "jeyko", "description": "If you would like to the isometric framework, fill the sdMain(vec3 p, vec2 idD) function.\n", "tags": ["isometric", "mdtmjvm"], "likes": 36, "viewed": 926, "published": 3, "date": "1580826115", "time_retrieved": "2024-07-30T21:25:57.921852", "image_code": "// Fork of \"Day 45 - Isometric\" by jeyko. https://shadertoy.com/view/WltXR7\n// 2020-02-04 12:31:12\n\nvec3 glow = vec3(0);\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define pi acos(-1.)\n\n#define modDist vec2(1.42,1.)\n\n#define xOffs 0.71\n#define yOffs 0.7\n\n#define ZOOM 5.\n#define mx (50.*iMouse.x/iResolution.x)\n#define my (-iTime + 50.*iMouse.y/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n\tp = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\nfloat sdBoxIQ( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOcta(vec3 p, vec3 s, vec2 id){\n\tp = abs(p) - s;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d =  dot(p.xz + s.zx*0.5, normalize(vec2(1)));\n    \n    d = max(d, dot(p.xy + s.xy*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.xy*0.5, normalize(vec2(1))));\n    \n    return d;\n}\nfloat sdMain(vec3 p, vec2 idD){\n\tfloat d = 10e6;\n    vec3 q = p;\n    float steps = 5.;\n    float m = sin(iTime + idD.x + idD.y*4.);\n    for(float i = 0.; i < steps; i++){\n    \td = min(d,sdBoxIQ(p, vec3(0.51 - 0.5*i/steps)) - .02);\t\n        p.y -= 0.25 + m*0.15;\n    }\n    \n    vec3 s = vec3(0.77);\n    \n    d = max(d, -max(sdOcta(q, s, idD), q.y - 0.5));\n\treturn d;\n}\n\n\nvec2 id;\n\nfloat sdIso(vec3 p, vec2 id){\n\tfloat d = 10e6;\n    //p.z -= 0.;\n    vec3 q = p;\n    \n    // ME\n    p.x -= id.y*xOffs;\n    p.y += id.y*yOffs;\n    p.xz = pmod(p.xz, modDist);\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, id));\n    \n    vec2 idD = id;\n    \n    // BOTTOM\n    p = q;\n    idD.y += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0,0. - id.y), vec2(modDist.x,modDist.y*3.));\n    \n    if (p.x > 0.){\n        idD.x -= 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n\n    // RIGHT\n    p = q;\n    idD = id;\n    idD.x -= 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // LEFT\n    p = q;\n    idD = id;\n    idD.x += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // TOP\n    idD = id;\n    idD.y -= 1.;\n    p = q;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0.,-1. - id.y), vec2(modDist.x,modDist.y*3.));\n    if (p.x < 0.){\n      idD.x += 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n    \n\treturn d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    id = floor(p.xz/modDist);\n    id.x = floor((p.x - modDist.x*0.5*id.y)/modDist.x);\n    d.x = min(d.x, sdIso(p, id));\n    d.x *= 0.7;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tp = ro;\n    vec2 d;\n    hit = false;\n    for(int i = 0; i < 100 ;i++){\n    \td = map(p);\n        //glow += exp(-d.x*60.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        if(t > 10.){\n        \t//hit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro );\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro -= ZOOM*dir;\n\treturn dir + right*uv.x + up*uv.y;\n}\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    \n    ro += right*uv.x*ZOOM;\n    ro += up*uv.y*ZOOM;\n \treturn rd;\n\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.4, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 quv = uv;\n    uv.xy *= rot(0.7);\n    vec3 col = vec3(0.0);\n    vec3 lookAt = vec3(0,-1,-2);\n    \n    \n    vec3 ro = vec3(0,8,0);\n   \n    vec3 rd = getRdIsometric(ro, lookAt, uv); \n    //vec3 rd = getRd(ro, lookAt, uv); \n        \n    vec3 p;\n    \n    //ro.x += mx;\n    ro.z += my;\n    ro.y -= my*0.65;\n    //ro += rd*5.4;\n    \n    float t = 0.; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    vec3 l = normalize(vec3(1.9,1.,.7));\n    \n    if (hit){\n        vec3 n = getNormal(p);\n        n.y *= -1.;\n        n.g*=0.4;\n        n.xy *= rot(0.2 + sin(iTime)*0.2 + uv.x*0.6);\n        float s = calcSoftshadow(p,l,0.01,2.4, 0);\n    \tcol += 0.5 + n*0.6;\n        \n        col = clamp(col, 0., 1.);\n\n        \n        col *= s;\n    \t\n    } else {\n    \tcol = mix(\n            vec3(0.8,0.1,0.1)*1.9,\n            vec3(0.4,0.6,0.5)*1.7,    \n\t\t\tabs(sin(iTime*0.5))\n                 );\n        ;\n        col.xy *= rot(0.1 - uv.x*0.3);\n    }\n    \n    \n    //col -= glow*0.01;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    //col = pow(col, vec3(0.45));\n    col = pow(col, vec3(0.7));\n    \n    \n    //col = pow(col, vec3(1.7));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 406, 434, 434, 486], [487, 487, 520, 520, 607], [609, 609, 647, 647, 906], [907, 907, 938, 938, 1274], [1287, 1287, 1316, 1316, 2645], [2647, 2647, 2664, 2664, 2838], [2840, 2840, 2914, 2914, 3242], [3244, 3244, 3267, 3267, 3406], [3408, 3408, 3456, 3456, 3651], [3652, 3652, 3709, 3709, 3946], [3947, 3947, 4040, 4040, 4858], [4860, 4860, 4917, 4917, 6174]], "test": "untested"}
{"id": "WtcSWH", "name": "Living Truchet Tiles", "author": "joynes", "description": "Animated Truchet tiles", "tags": ["animated", "truchet", "circular", "tiles"], "likes": 6, "viewed": 310, "published": 3, "date": "1580825491", "time_retrieved": "2024-07-30T21:25:58.686807", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n  float PI = 3.14159265359;\n  vec2 t = (fragCoord - iResolution.xy/2.)/iResolution.y;\n  float zoom = 30.;\n  t *= zoom;\n  float b = floor(length(floor(t)));\n  t = fract(t)-.5;\n  float z = mod(iTime, b*2.)-b;\n  float a = (1. + sign(z))/2.;\n  float e = max(2.*fract(iTime)-1., 0.);\n  float rad = floor(abs(z))+e*a+(1.-e)*(1.-a);\n  rad = -rad * PI/2. - PI/4.;\n  t = mat2(cos(rad), sin(rad), -sin(rad), cos(rad))*t;\n  float r = zoom*1.5/iResolution.y/2.;\n  float c = smoothstep(-r, +r, t.y);\n  fragColor = vec4(vec3(c), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 582]], "test": "untested"}
{"id": "WttSzN", "name": "NASA 'the worm'", "author": "flemmingdjensen", "description": "Had the idea of creating NASAs old logo using small algorithms and a lot of symmetry.\n(There are some hacks and stuff - i know ;))\n\nNASA used the \"worm\" logo from 1975 until 1992.", "tags": ["2d", "logo", "worm", "symmetry", "nasa"], "likes": 10, "viewed": 827, "published": 3, "date": "1580825389", "time_retrieved": "2024-07-30T21:25:59.456749", "image_code": "/*\nNASA \"the worm\", 19751992\n\nIn 1974, as part of the Federal Graphics Improvement Program of the \nNational Endowment for the Arts, NASA hired Richard Danne and Bruce Blackburn \nto design a more modern logo. In 1975, the agency switched to the modernist \nNASA logotype, nicknamed \"the worm\", a red, stylized rendering of the letters \nN-A-S-A. The A's horizontal bar is removed in the worm logo. \n\nThe NASA logotype was retired from official use on Friday May 22, 1992.\n\nhttps://en.wikipedia.org/wiki/NASA_insignia\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    uv *= 2.15; uv.x += .05; uv.y += .2;\n\n    float col = 0.;\n    N(col, uv - vec2(-1.19, .13));\n    A(col, uv - vec2(-.31, 0.));\n    S(col, uv - vec2(.45, .128));\n    A(col, uv - vec2(1.26, 0.));\n    vec3 logoColor = vec3(col, .0, .15*col); \n    \n    float star = star(rotate(-iTime/8.)*(uv-vec2(1., .7)), 1.);\n    vec3 starColor = vec3(star*cos(iTime), .6*star, star*sin(iTime/.7));\n    \n    fragColor = vec4(logoColor + starColor, 1.);\n}", "image_inputs": [{"id": 21125, "src": "https://soundcloud.com/headphoneactivist/nasa", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define W .09\n#define B .005\n\n#define DEG .0174533\n#define _S smoothstep\n\nmat2 rotate(float angle) {\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid line(inout float col, vec2 uv, float len) {\n    if (abs(uv.y) <= len) {\n    \tcol = max(col, _S(-W, -W+B, uv.x) -\n                       _S(W-B, W, uv.x));\n    }\n}\n\nvoid arc(inout float col, vec2 uv, float r, float angle) {\n    if (atan(uv.x/uv.y) < angle && uv.y >= 0.) {\n    \tcol = max(col, _S(r+W, r+W-B, length(uv)) - \n                       _S(r-W+B, r-W, length(uv)));\n    }\n}\n\nvoid N(inout float col, vec2 uv) {\n    line(col, (vec2(-.0345, .1)-uv*sign(uv.y))*rotate(DEG*-19.), .15);\n    arc(col, (vec2(-.221, .194)-uv*sign(uv.y))*rotate(DEG*-180.), .146, DEG*71.);\n    line(col, (vec2(.367, .106)-uv*sign(uv.x+uv.y)), .3);\n}\n\nvoid A(inout float col, vec2 uv) {\n    uv.x = abs(uv.x); // Y-axis symmetry\n    \n    if (uv.y > -.29) {\n    \tline(col, (vec2(.28, .0)-uv)*rotate(DEG*-21.), .4);\n    \tarc(col, (vec2(0., .321)-uv)*rotate(DEG*-90.), .146, DEG*-20.);\n    }\n}\n\nvoid S(inout float col, vec2 uv) {\n    uv *= rotate(DEG * 90.);\n    uv.x = -uv.x; // X-axis flip\n    \n    line(col, (vec2(.0, .07)-uv*sign(uv.y)), .07);\n    arc(col, (vec2(-.166, .14)-uv*sign(uv.y))*rotate(DEG*-180.), .166, DEG*90.);\n    line(col, (vec2(.332, .105)-uv*sign(uv.x+uv.y)), .245);\n}\n\n// Star grabbed from BigWIngs Starfield shader\n// https://www.shadertoy.com/view/tlyGW3\nfloat star(vec2 uv, float flare) {\n\tfloat d = length(uv);\n    float m = .05/d;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= rotate(DEG*45.);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*.3*flare;\n    \n    m *= _S(1., .2, d);\n    return m;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 576, 576, 1078]], "test": "untested"}
{"id": "wldXWr", "name": "Corona Virus", "author": "BigWIngs", "description": "Use mouse to move. See comments.", "tags": ["coronavirus"], "likes": 62, "viewed": 3424, "published": 3, "date": "1580802117", "time_retrieved": "2024-07-30T21:26:00.218711", "image_code": "// \"Corona Virus\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Music: Xerxes - early-morning-crystals\n//\n// This effect depicts my idea of what a virus could\n// look like taking a huge artistic license. I started making what\n// I imagine to be a lipid bilayer and then realized.. a virus\n// doesn't have one! So then I just figured I'd make it look 'mean'\n// \n// At first I tried using sphere coordinates but they distort too \n// much and have poles, so I ended up with projected cubemap\n// coordinates instead. I think the function WorldToCube below\n// is extremely usefull if you want to bend stuff around a sphere\n// without too much distortion.\n//\n// As usual, the code could be a lot better and cleaner but I figure\n// that by the time its all clean, I've lost interest and the world\n// has moved on. Better ship it while its hot ;)\n//\n// uncomment the MODEL define to see once particle by itself\n// you can change the amount of particles by changing the\n// FILLED_CELLS define\n\n\n//#define MODEL\n#define FILLED_CELLS .3\n\n#define PI 3.1415\n#define TAU 6.2831\n\n#define MAX_STEPS 400\n#define MAX_DIST 40.\n#define SURF_DIST .01\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat N31(vec3 p) {\n\tvec3 a = fract(vec3(p) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a + 79.76);\n    return fract(a.x * a.y * a.z);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec3 SphereCoord(vec3 p) {\n\tfloat x = atan(p.x, p.z);\n    float y = atan(length(p.xz), p.y);\n    \n    return vec3(x/TAU, length(p), 2.*y/TAU);\n}\n\n// returns cubemap coordinates\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n    \n    // mattz' distortion correction\n    st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n       \n    return st;\n}\n\nfloat Lipid(vec3 p, float twist, float scale) {\n    vec3 n = sin(p*20.)*.2;\n    p *= scale;\n    \n\tp.xz*=Rot(p.y*.3*twist);\n    p.x = abs(p.x);\n    \n    float d = length(p+n)-2.;\n    \n    float y = p.y*.025;\n    float r = .05*scale;\n    float s = length(p.xz-vec2(1.5,0))-r+max(.4,p.y);\n    d = smin(d, s*.9,.4);\n    \n    return d/scale;\n}\n\nfloat sdTentacle(vec3 p) {\n    float offs = sin(p.x*50.)*sin(p.y*30.)*sin(p.z*20.);\n    \n    p.x += sin(p.y*10.+iTime)*.02;\n    p.y *= .2;\n    \n    float d = sdCapsule(p, vec3(0,0.1,0), vec3(0,.8,0), .04);\n    \n    p.xz = abs(p.xz);\n    \n    d = min(d, sdCapsule(p, vec3(0,.8,0), vec3(.1,.9,.1), .01));\n    d += offs*.01;\n    \n    return d;\n}\n\n\nfloat Particle(vec3 p, float scale, float amount) {  \n    float t = iTime;\n \n    vec3 st = WorldToCube(p);\n    vec3 cPos = vec3(st.x, length(p), st.y);\n    vec3 tPos = cPos;\n    \n    vec3 size = vec3(.05);\n  \t\n    cPos.xz *= scale;\n    vec2 uv = fract(cPos.xz)-.5;\n    vec2 id = floor(cPos.xz);\n    \n    uv = fract(cPos.xz)-.5;\n    id = floor(cPos.xz);\n    \n    \n    float n = N21(id);\n    \n    t = (t+st.z+n*123.32)*1.3;\n    float wobble = sin(t)+sin(1.3*t)*.4;\n    wobble /= 1.4;\n    \n    wobble *= wobble*wobble;\n    \n    wobble = wobble*amount/scale;\n    vec3 ccPos = vec3(uv.x, cPos.y, uv.y);\n    vec3 sPos = vec3(0, 3.5+wobble, .0);\n    \n    vec3 pos = ccPos-sPos;\n    \n    pos.y *= scale/2.;\n   \n    float r = 16./scale;\n    r/=sPos.y; // account for height\n    float d = length(pos)-r;\n    d = Lipid(pos, n, 10.)/scale;\n    \n    d = min(d, length(p)-.2*scale);\t// inside blocker\n    \n    \n    float tent = sdTentacle(tPos);\n    d = min(d, tent);\n    \n    return d;\n}\n\nfloat dCell(vec3 p, float size) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    \n    return max(0., size - d);\n}\n\nfloat GetDist(vec3 p) {\n\tfloat t = iTime;\n    \n    float scale=8.;\n    \n    #ifndef MODEL\n    p.z += t;\n    vec3 id = floor(p/10.);\n    p = mod(p, vec3(10))-5.;\n    float n = N21(id.xz);\n    p.xz *= Rot(t*.2*(n-.5));\n    p.yz *= Rot(t*.2*(N21(id.zx)-.5));\n    scale = mix(4., 16., N21(id.xz));//mod(id.x+id.y+id.z, 8.)*2.;\n    \n    n = N31(id);\n    if(n>FILLED_CELLS) {\t\t\t// skip certain cells\n        return dCell(p, 5.)+.1;\n    }\n    #endif\n    \n   \n    \n    p += sin(p.x+t)*.1+sin(p.y*p.z+t)*.05;\n    \n   \n    float surf = sin(scale+t*.2)*.5+.5;\n    surf *= surf;\n    surf *= 4.;\n    surf += 2.;\n    float d = Particle(p, scale, surf);\n    \n    p.xz *= Rot(.78+t*.08);\n    p.zy *= Rot(.5);\n    \n    d = smin(d, Particle(p, scale, surf), .02);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float cone = .0005;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST+dO*cone) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, vec3 up, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    if(m.x<-0.45&&m.y<-.45) m += .5;\n    \n    float t = iTime;\n    \n    vec3 col = vec3(0);\n    \n    #ifdef MODEL\n    vec3 ro = vec3(0, 0, -7);\n    //ro.y += sin(t*.1)*3.;\n    ro.yz *= Rot(-m.y*2.);\n    ro.xz *= Rot(iTime*.0-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,0,0), vec3(0,1,0), .5);\n    //ro += 3.;\n    #else\n    vec3 ro = vec3(0, 0, -1);\n    //ro.y += sin(t*.1)*3.;\n    ro.yz *= Rot(-m.y*2.);\n    ro.xz *= Rot(iTime*.0-m.x*6.2831);\n    \n    vec3 up = vec3(0,1,0);\n    up.xy *= Rot(sin(t*.1));\n    vec3 rd = R(uv, ro, vec3(0,0,0), up, .5);\n    \n    ro.x += 5.;\n    ro.xy *= Rot(t*.1);\n    ro.xy -= 5.;\n    #endif\n    \n    float d = RayMarch(ro, rd);\n    \n    float bg = rd.y*.5+.3;\n    float poleDist = length(rd.xz);\n    float poleMask = smoothstep(.5, 0., poleDist);\n    bg += sign(rd.y)*poleMask;\n    \n    float a = atan(rd.x, rd.z);\n    bg += (sin(a*5.+t+rd.y*2.)+sin(a*7.-t+rd.y*2.))*.2;\n    float rays = (sin(a*5.+t*2.+rd.y*2.)*sin(a*37.-t+rd.y*2.))*.5+.5;\n    bg *= mix(1., rays, .25*poleDist*(sin(t*.1)*.5+.5));//*poleDist*poleDist*.25;\n    col += bg;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n   \n    \tvec3 n = GetNormal(p);\n       \n        #ifndef MODEL\n        p = mod(p, vec3(10))-5.;\n        #endif\n        \n        float s = dot(n, normalize(p))-.4;\n        float f = -dot(rd, n);\n        \n        col += dot(n,-rd)*.5+.5;\n    \t//col += (1.-f*f)*s*1.5;\n        \n        col *= 0.;\n        float r = 3.7;\n        float ao = smoothstep(r*.8, r, length(p));\n        col += (n.y*.5+.5)*ao*2.;\n        //col *= 2.;\n        col *= smoothstep(-1., 6., p.y);\n        \n        //col += n*.5+.5;\n    }\n    \n    col = mix(col, vec3(bg), smoothstep(0., 40., d));\n    \n    //col *= vec3(1., .9, .8);\n    //col = 1.-col;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 21108, "src": "https://soundcloud.com/spiral-trax/xerxes-early-morning-crystals", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1236, 1236, 1255, 1255, 1331], [1333, 1333, 1374, 1374, 1465], [1467, 1467, 1517, 1517, 1685], [1687, 1687, 1706, 1706, 1831], [1833, 1833, 1852, 1852, 1987], [1989, 1989, 2015, 2015, 2133], [2135, 2237, 2263, 2263, 2653], [2655, 2655, 2702, 2702, 2993], [2995, 2995, 3021, 3021, 3337], [3340, 3340, 3391, 3391, 4314], [4316, 4316, 4349, 4349, 4441], [4443, 4443, 4466, 4466, 5214], [5216, 5216, 5250, 5250, 5497], [5499, 5499, 5523, 5523, 5713], [5716, 5716, 5767, 5767, 5953], [5957, 5957, 6014, 6014, 7904]], "test": "untested"}
{"id": "wldSWr", "name": "Real time path tracing (Tweak)", "author": "granito", "description": "All credit goes to -> loicvdb for his incredible shadertoy --> https://www.shadertoy.com/view/wtcXz4\nI simply tweaked it to animate and colorized it.", "tags": ["raymarching", "fractal", "gi", "globalillumination", "pathtracing", "depthoffield", "ao", "reprojection", "loicvdb"], "likes": 18, "viewed": 777, "published": 3, "date": "1580800506", "time_retrieved": "2024-07-30T21:26:01.267906", "image_code": "//second DoF pass\n\n#define dir normalize(vec2(1.0, -1.0))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    cam.aperture *= camfovanim(iTime) + 1.;\n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*cam.aperture)/iResolution.xy);\n        dr = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*cam.aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    uv = (uv - 0.5) * vec2(1.0, aspect);\n    float vignette = 1. - distance( uv, vec2(0.) );\n    \n    fragColor = vec4(ACESFilm(col.rgb * smoothstep(0., camfovanim(iTime) * 0.5 + 0.5 ,vignette) ), 1. );\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//increase this number for a better GI\n#define IndirectSamples 1\n\n//increase to remove more noise, but might make the result blurrier\n#define SamplesLimit 40\n\n//GI bounces\n#define Bounces 1\n\n\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .5\n\n\n\n#define Pi 3.14159265359\n\n#define MaxStepsDirect 128\n#define MaxStepsIndirect 32\n#define MaxShadowSteps 32\n#define MaxDist 4.\n#define MinDist .015\n\n#define DoFClamping .3\n#define DoFSamples 32\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat camfovanim( float time ) \n{\n    vec2 n = vec2(0.75,0.5);\n\tn = n*n*(3.0-2.0*n);\n\tn = n*n*(3.0-2.0*n);\n\tn = n*n*(3.0-2.0*n);\n\treturn iqnoise(vec2(time*0.45), n.x, n.y ) * 2. - 1.;\n}\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    vec3 rot = vec3(0., (sin(time*.75)+time*.75)/4., .3);\n    return Camera(vec3(0., 0., -20.) * rotationMatrix(rot), rot, 2.5 + camfovanim(time), 17.5, .04);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n    \n\nfloat sdf(vec3 position, float time){\n    float Scale = 5.5 + sin(time*0.25)*1.75;\n    float Radius = .45;// + cos(time*1.5)*0.2;\n    int Iterations = 4;\n    mat3 Rotation;\n    \n    time *= 0.25;\n    //float time = 75.;\n    //float time = 104.;\n    //float time = 120.;\n    \n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 3) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos, float time){\n  vec2 k = vec2(MinDist, 0);\n  return normalize(vec3(sdf(pos + k.xyy, time) - sdf(pos - k.xyy, time),\n\t  \t\t\t\t\tsdf(pos + k.yxy, time) - sdf(pos - k.yxy, time),\n  \t\t\t\t\t\tsdf(pos + k.yyx, time) - sdf(pos - k.yyx, time)));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "bool trace(inout vec3 pos, in vec3 dir, out vec3 normal){    \n    pos += dir*sdf(pos, iTime);\n    pos += dir*sdf(pos, iTime);\n    for(int i = 0; i < MaxStepsDirect; i++){\n        float dist = sdf(pos, iTime);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos, iTime);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    fragColor = vec4(0.);\n    vec3 pos = cam.pos, normal;\n    if(trace(pos, dir, normal)) fragColor = vec4(pos, 1.);\n}", "buffer_b_inputs": [], "buffer_c_code": "float seed;\n\nvec3 LightDir = vec3(.0, -1, .0);\nvec3 LightColor = vec3(.7, .5, .3) * 22.;\nfloat LightRadius = .05;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = sdf(pos, iTime);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\n\nvec3 background(vec3 dir){\n    vec3 col = texture(iChannel3, dir).rgb;\n    return col*col + col;\n}\n\n\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < MaxStepsIndirect; i++){\n        float dist = sdf(pos, iTime);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos, iTime);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir = getCosineWeightedSample(normal);\n    vec3 light = vec3(0.);\n    for(int i = 0; i < Bounces; i++){\n        if(!trace(pos, dir, normal)) return light+background(dir);\n        else light += directLight(pos, normal);\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MaxDist;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = MaxDist;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = .256435865*fragCoord.x+.316548465*fragCoord.y+sin(iTime)*16886.3158915;\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(background(uv2dir(cam, uv)) * vec3(0.1,0.3,1.4), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal = normalEstimation(hit.xyz, iTime);\n        vec3 color = hsv2rgb(vec3(fract(hit.x*0.1+normal.x*0.25+iTime*0.2),0.8,0.4));\n        \n        vec3 dLight = directLight(hit.xyz, normal);\n        dLight *= color;\n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        fragColor = previousSample(hit);\n        iLight *= color;\n        if(fragColor.a < 1.) iLight = clamp(iLight, vec3(.1), vec3(.4)); // clamp gi for low sample count\n        \n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        fragColor.rgb = mix(fragColor.rgb, iLight + dLight, 1.0/(fragColor.a));\n        #endif\n    }\n}", "buffer_c_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//first DoF pass\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    cam.aperture *= camfovanim(iTime) + 1.;\n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d, de;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        vec2 de = (fragCoord + d*iResolution.y*cam.aperture)/iResolution.xy;\n        p.rgb = texture(iChannel0, de).rgb;\n        p.a = length(texture(iChannel1, de).rgb - cam.pos);\n        dr = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*cam.aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 82, 82, 222], [225, 225, 281, 281, 1223]], "test": "untested"}
{"id": "wltSDn", "name": "Phi Noise", "author": "TinyTexel", "description": "Cheap, ALU-only blue noise based on the 2d Roberts sequence.\nNoise function in Buffer A.\n( http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/ )", "tags": ["noise", "dither", "blue", "dithering"], "likes": 24, "viewed": 1450, "published": 3, "date": "1580780429", "time_retrieved": "2024-07-30T21:26:02.040839", "image_code": "// Cheap, ALU-only blue noise based on the 2d Roberts sequence.\n// Noise function in Buffer A.\n// The basic idea is to use low-frequency white noise to blur out the spiky spectrum of high-frequency dither noise.\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        col = pow(vec3(n), vec3(1.0/2.2));\n        \n        #ifdef SHOW_1BITGRADIENT\n        if(q.y < 0.25)\n        col = vec3(n < q.x * 2.0 ? 0.0 : 1.0);\n        #endif\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define ANIMATE_NOISE\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#dither\nfloat PhiNoise(uvec2 uv)\n{\n    // flip every other tile to reduce anisotropy\n    if(((uv.x ^ uv.y) & 4u) == 0u) uv = uv.yx;\n\t//if(((uv.x       ) & 4u) == 0u) uv.x = -uv.x;// more iso but also more low-freq content\n    \n    // constants of 2d Roberts sequence rounded to nearest primes\n    const uint r0 = 3242174893u;// prime[(2^32-1) / phi_2  ]\n    const uint r1 = 2447445397u;// prime[(2^32-1) / phi_2^2]\n    \n    // h = high-freq dither noise\n    uint h = (uv.x * r0) + (uv.y * r1);\n    \n    // l = low-freq white noise\n    uv = uv >> 2u;// 3u works equally well (I think)\n    uint l = ((uv.x * r0) ^ (uv.y * r1)) * r1;\n    \n    // combine low and high\n    return float(l + h) * (1.0 / 4294967296.0);\n}\n\nfloat PhiNoise2(uvec2 uv)\n{\n    uvec2 uv0 = uv;\n    // flip every other tile to reduce anisotropy\n    if(((uv.x ^ uv.y) & 4u) == 0u) uv = uv.yx;\n\tif(((uv.x       ) & 4u) == 0u) uv.x = -uv.x;// more iso but also more low-freq content\n    \n    // constants of 2d Roberts sequence rounded to nearest primes\n    const uint r0 = 3242174893u;// prime[(2^32-1) / phi_2  ]\n    const uint r1 = 2447445397u;// prime[(2^32-1) / phi_2^2]\n    \n    // h = high-freq dither noise\n    uint h = (uv.x * r0) + (uv.y * r1);\n    \n    uint l;\n    {\n        uv = uv0 >> 2u;\n        //uv.x = -uv.x;\n        \n        if(((uv.x ^ uv.y) & 4u) == 0u) uv = uv.yx;\n        if(((uv.x       ) & 4u) == 0u) uv.x = -uv.x;\n\n        uint h = (uv.x * r0) + (uv.y * r1);\n\t\t\t h = h ^ 0xE2E17FDCu;\n        \n        l = h;\n        \n        {\n            uv = uv0 >> 4u;\n            if(((uv.x ^ uv.y) & 4u) == 0u) uv = uv.yx;\n            if(((uv.x       ) & 4u) == 0u) uv.x = -uv.x;\n\n            uint h = (uv.x * r0) + (uv.y * r1);\n                 h = h ^ 0x1B98264Du;\n\n            l += h;\n    \t}\n    }\n    \n    // combine low and high\n    return float(l + h*1u) * (1.0 / 4294967296.0);\n}\n\nfloat PhiNoise(uvec3 uvw)\n{\n    // flip every other tile to reduce anisotropy\n    if(((uvw.x ^ uvw.y ^ uvw.z) & 4u) == 0u) uvw = uvw.yzx;\n    \n    // constants of 3d Roberts sequence rounded to nearest primes\n    const uint r0 = 3518319149u;// prime[(2^32-1) / phi_3  ]\n    const uint r1 = 2882110339u;// prime[(2^32-1) / phi_3^2]\n    const uint r2 = 2360945581u;// prime[(2^32-1) / phi_3^3]\n    \n    // h = high-freq dither noise\n    uint h = (uvw.x * r0) + (uvw.y * r1) + (uvw.z * r2);\n    \n    // l = low-freq white noise\n    uvw = uvw >> 2u;// 3u works equally well (I think)\n    uint l = ((uvw.x * r0) ^ (uvw.y * r1) ^ (uvw.z * r2)) * r1;\n    \n    // combine low and high\n    return float(l + h) * (1.0 / 4294967296.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    uvec2 uv = uvec2(fragCoord);\n    \n    #ifdef ANIMATE_NOISE\n\tuv += uint(iFrame) * uvec2(2447445397u, 3242174893u);\n    #endif\n    \n    fragColor = vec4(vec3(PhiNoise(uv)), 1.0);\n    //fragColor = vec4(vec3(PhiNoise(uvec3(uv, iFrame).xzy)), 1.0);\n    \n   #if 0\n    {\n        vec2 uv0 = fragCoord - 0.5;\n        float ign = fract(52.9829189*fract(0.06711056*uv0.x + 0.00583715*uv0.y));\n        ign = fract((uv0.x*0.7548776662 + uv0.y*0.56984029));\n        ign = fract((uv0.x*0.7548776662 + uv0.y*0.56984029)*mix(0.8, 1.2, (iMouse.x/iResolution.x)));\n        ign = fract(uv0.x*0.6180339 + uv0.y*((iMouse.x/iResolution.x)*0.125*0.5+0.75));\n        ign = fract(uv0.x*0.6180339 + uv0.y*0.813333*0.125);\n        \n        ign = fract((uv0.x*0.798127 + uv0.y*0.602489)*0.945811);\n        \n        float ga = 3.14159265*(3.0-sqrt(5.0));\n        ign = fract((uv0.x*cos(ga) + uv0.y*sin(ga))*mix(0.9, 1.2,iMouse.x/iResolution.x));\n        \n        fragColor = vec4(vec3(ign), 1.0);\n    }\n   #endif\n}", "buffer_a_inputs": [], "common_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n  #define SHOW_1BITGRADIENT\n  #define SHOW_FOURIER\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\nconst float globalScale = 1.;\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tltSDn", "name": "Adaptive direction noise", "author": "michael0884", "description": "some experimental stuff for my adaptive distribution path tracer. I was trying to get a smooth in time and space blue noise distribution for the direction. Now I need to compute the probability distribution function for this to compensate the oversampling", "tags": ["noise"], "likes": 6, "viewed": 365, "published": 3, "date": "1580777528", "time_retrieved": "2024-07-30T21:26:02.812775", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec3 dir = pixelmm(ch0, (0.2*pos+s2d*0.4),(pos.x>s2d.x*0.5)?0.:0.).xyz;\n    \n    vec3 col = dir*0.5 + 0.5;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define pixelmm(a, p, m) texture(a, p/vec2(textureSize(a,0)),m)\n#define texel(a, p) texelFetch(a, ivec2(p),0)\n#define s2d iResolution.xy\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n", "buffer_a_code": "//smoothing in time\n#define str 0.05\n\n//noise radius\n#define rad 2\n\nvoid mainImage( out vec4 V, in vec2 pos )\n{\n    V = pixel(ch0, pos);\n    vec3 seed = vec3(pos,iTime);\n     vec2 dc= pos-s2d*0.5;\n    \n    //repulsion from neighbor directions\n    vec3 F = vec3(0.);\n    for(int i = -rad; i <= rad; i++)\n    {\n        for(int j = -rad; j <= rad; j++)\n    \t{\n            if(i!=0 && j!=0)\n            {\n                vec2 ij = vec2(i,j)/float(rad);\n                vec3 ndir = pixel(ch0, pos+ij).xyz;\n          \t    vec3 dV = V.xyz - ndir;\n                vec3 d0 = 2.*(hash33(seed+vec3(i,j,0))-0.5);\n            \tF += d0*exp(-1.*dot(dV,dV)+0.2*dot(ij,ij));\n            }\n    \t}\n    }\n    \n    //redistribution depending on external factors\n    F += 10.*exp(-0.01*dot(dc,dc))*(vec3(2.,0,1)-V.xyz) + //light direction\n         1.6*(vec3(0,0,1)-V.xyz); //normal direction\n    \n    V.xyz = normalize(V.xyz + str*F);\n    \n    if(iFrame < 1)\n    {\n        V.xyz = vec3(1,0,0);\n        V.w = 1.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 224]], "test": "untested"}
{"id": "3dKXzy", "name": "Volumetric light", "author": "Txoka", "description": "volumetric", "tags": ["volumetric"], "likes": 7, "viewed": 527, "published": 3, "date": "1580774240", "time_retrieved": "2024-07-30T21:26:03.591693", "image_code": "struct ray{\n    vec3 ro;\n\tvec3 rd;\n};\nfloat gamma=1.8;\nconst float pi=4.*atan(1.);\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat suc(ray r,float l,vec3 center,float radius){\n    vec3 o=r.ro-center;\n    \n    float a=dot(o,o);\n    float b=dot(r.rd,o);\n    float c=dot(r.rd,r.rd);\n    \n    float k=sqrt(a*c-b*b);\n    float w=b+c*l;\n    //integral =radius*atan(w/k)/k\n    float integ=radius*(atan(w,k)-atan(b,k))/k;\n    return integ;\n}\n\nvec3 render(ray r){\n    vec3 res=vec3(0.);\n    \n    float n1=clamp(0.,1.,suc(r,100.,vec3(2,0,0),0.2));\n    float n2=clamp(0.,1.,suc(r,100.,vec3(0,2,0),0.1));\n    float n3=clamp(0.,1.,suc(r,100.,vec3(0,0,2),0.05));\n    float n4=clamp(0.,1.,suc(r,100.,vec3(0,0,-2),0.2));\n    float n5=clamp(0.,1.,suc(r,100.,vec3(0,-2,0),0.3));\n    float n6=clamp(0.,1.,suc(r,100.,vec3(-2,0,0),0.1));\n    float n7=clamp(0.,1.,suc(r,100.,vec3(0,0,0),0.03));\n    \n    //only need hue but does not matter, its 60+fps anyway\n\tres+=pow(n1*hsv2rgb(vec3(iTime,1,1))\t\t,vec3(gamma));\n    res+=pow(n2*hsv2rgb(vec3(iTime+0.1,1,1))\t,vec3(gamma));\n    res+=pow(n3*hsv2rgb(vec3(iTime+0.2,1,1))\t,vec3(gamma));\n    \n    if(iTime>2.){\n    \tres+=pow(n4*hsv2rgb(vec3(iTime+0.3,1,1))\t,vec3(gamma));\n    \tres+=pow(n5*hsv2rgb(vec3(iTime+0.4,1,1))\t,vec3(gamma));\n    \tres+=pow(n6*hsv2rgb(vec3(iTime+0.5,1,1))\t,vec3(gamma));\n    \tres+=pow(n7*hsv2rgb(vec3(iTime+0.6,1,1))\t,vec3(gamma));\n    }\n    return vec3(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //ray origin and dir\n    vec3 uv = vec3((fragCoord*2.-iResolution.xy)/iResolution.y,-3);\n    \n    \n    vec2 m=(iMouse.xy*2.-iResolution.xy)/iResolution.xy;\n    m*=vec2(1,0.5)*pi;\n\n    if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    #ifdef eyes\n    vec3 ro=vec3(-0.2,0,-4);\n    if(uv.x<0.)ro.x=0.2;\n    uv.xy+=ro.xy*5.;\n    #else\n    vec3 ro=vec3(0,0,-4.);\n    #endif\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    vec3 rd=normalize(uv-ro);\n   \t\n    ray r=ray(ro,rd);\n    \n    vec3 col=render(r);\n    \n    fragColor=vec4(pow(col,vec3(1./gamma)),1);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 106, 106, 275], [276, 276, 326, 326, 584], [586, 586, 605, 605, 1558], [1560, 1560, 1616, 1641, 2353]], "test": "untested"}
{"id": "tldXWn", "name": "Accidental_z2", "author": "hanabi", "description": "confused...", "tags": ["accidental"], "likes": 2, "viewed": 263, "published": 3, "date": "1580773277", "time_retrieved": "2024-07-30T21:26:04.440423", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "ttXSWX", "name": "api testing", "author": "vitasa", "description": "Learning", "tags": ["learning"], "likes": 0, "viewed": 289, "published": 3, "date": "1580771847", "time_retrieved": "2024-07-30T21:26:05.208370", "image_code": "vec2 random2( vec2 p ) {\n    float x = fract(sin(dot(p*23.4,vec2(12.9898,78.233))) * 3.947629);\n    float y = fract(sin(dot(p,vec2(24.43532,78.233))) * 43.5453123);\n    return vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy - 0.5 * iResolution.xy )/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 3.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Draw cell center\n    color += 1.-step(.02, m_dist);\n\n    fragColor = vec4(iMouse.x/iResolution.x);\n    //fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 188], [190, 190, 247, 247, 1350]], "test": "untested"}
{"id": "tldSWn", "name": " - Quicky#020", "author": "totetmatt", "description": "Blop, Blop, Blop, Blop, Blop, Blop", "tags": ["quicky"], "likes": 3, "viewed": 295, "published": 3, "date": "1580769056", "time_retrieved": "2024-07-30T21:26:06.063085", "image_code": "mat2 r(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat bump(vec2 uv,float offset) {\n uv *=r(iTime+offset);\n return smoothstep(0.,4.,abs(cos(iTime+2.*atan(uv.x,uv.y))))/8.;\n}\nfloat circl(vec2 uv,float r,float offset) {\n    return smoothstep(\n    0.09-(length(uv)*.05),\n    0.1,\n    length(uv)-r- \n    bump(uv,offset)\n    );\n}\nfloat fig(vec2 uv, float offset) {\n\nreturn max(circl(uv,.33,offset) , 1.-circl(uv,.3,offset));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy )/ iResolution.y;\n      vec2 uuv = uv;  \n      uv*=2.;\n      \n      vec2 gid = floor(uv);\n      uv *= r(atan(uv.x,uv.y));\n      uv *=r(iTime*.123);\n      \n      uv = fract(+iTime*.124+uv*length(0.1*cos(uv+iTime)*10.))-.5;\n    \n    float d = min(fig(uv,0.) ,fig(uv,3.15/4.)) ;\n  \n    vec3 col = vec3(0.);\n    col.r = fig(uv,0.+sin(-iTime+gid.x*11.));\n    col.g = fig(uv,0.3-cos(iTime-gid.y*47.));\n    col.b = fig(uv,-0.3+tan(sin(length(gid)+iTime)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 59], [61, 61, 95, 95, 185], [186, 186, 229, 229, 336], [337, 337, 371, 371, 433], [434, 434, 489, 489, 1018]], "test": "untested"}
{"id": "wltSWn", "name": "Codebase Lightning", "author": "codebasealpha", "description": "Developed on stream at https://twitch.tv/codebasealpha", "tags": ["2d"], "likes": 24, "viewed": 964, "published": 3, "date": "1580767496", "time_retrieved": "2024-07-30T21:26:06.926776", "image_code": "vec2 hash (in vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n   \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                         dot (b, hash (i + o)),\n                         dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm)\n{\n    vec2 offset = vec2(cos(tm), 0.0);\n    float aggr = 0.0;\n    \n    aggr += noise(pos);\n    aggr += noise(pos + offset) * 0.5;\n    aggr += noise(pos + offset.yx) * 0.25;\n    aggr += noise(pos - offset) * 0.125;\n    aggr += noise(pos - offset.yx) * 0.0625;\n    \n    aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n    return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset)\n{\n    vec3 col = vec3(0.0);\n    vec2 f = vec2(0.0, -iTime * 0.25 );\n    \n    for (int i = 0; i < 3; i++)\n    {\n        float time = iTime +float(i);\n        float d1 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 3.0, time)));\n        float d2 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 2.0, 0.9 * time + 10.0)));\n        col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n        col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n    }\n    \n    return col;\n}\n\n/*\nfloat distanceCodebaseAlpha(vec2 pos)\n{\n    ivec2 siz = textureSize(iChannel0, 0);\n    pos.x *= float(siz.y)/float(siz.x);\n    pos.y *= -1.0;\n    pos += vec2(0.5);\n    vec4 col = texture(iChannel0, pos);\n    float d = col.x + col.y/256.0 + col.z/(256.0 * 256.0);\n    \n    return -2.0 * d + 1.0;\n}\n*/\n\nfloat distanceCodebaseAlpha(vec2 pos)\n{\n    return length(pos) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 0.5;\n    //float dist = length(uv) - 0.25;\n    float dist = distanceCodebaseAlpha(uv);\n    \n    vec3 n = lightning(uv, dist + 0.4);\n    vec3 col = vec3(0.0);\n    \n    col += n;\n    col += 0.5 * smoothstep(0.01, -0.01, dist) * sqrt(smoothstep(0.25, -0.5, dist));\n    col += 0.25 * smoothstep(0.1, 0.0, dist);\n    \n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 160], [162, 162, 187, 187, 664], [666, 666, 697, 697, 1048], [1050, 1050, 1090, 1090, 1543], [1849, 1849, 1888, 1888, 1920], [1922, 1922, 1979, 1979, 2437]], "test": "untested"}
{"id": "WltSDr", "name": "Accidental_z1", "author": "hanabi", "description": "This wasn't what I had in my mind...\n\nhsv2rgb: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl", "tags": ["accidental"], "likes": 1, "viewed": 289, "published": 3, "date": "1580760769", "time_retrieved": "2024-07-30T21:26:07.736610", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "3ltSDn", "name": "Caged Kryptonite", "author": "dr2", "description": "Stay away Superman", "tags": ["voronoi", "raymarch"], "likes": 9, "viewed": 741, "published": 3, "date": "1580752045", "time_retrieved": "2024-07-30T21:26:08.503560", "image_code": "// \"Caged Kryptonite\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Object shape based on varying Voronoi displacements.\n  Motivated by Shane's \"Geometric Cellular Surfaces\", but with a lot less work,\n  so no need for texture storage.\n*/\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\n\nvec3 ltDir;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, g, w, wm;\n  float s, sm, d, wo;\n  ip = floor (p);\n  fp = fract (p);\n  wo = 0.2 * sin (0.4 * tCur);\n  sm = 4.;\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        g = vec3 (gx, gy, gz);\n        w = g + 0.5 * Hashv3v3 (ip + g) + wo - fp;\n        s = dot (w, w);\n        if (s < sm) {\n          sm = s;\n          wm = w;\n        }\n      }\n    }\n  }\n  d = 4.;\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        g = vec3 (gx, gy, gz);\n        w = g + 0.5 * Hashv3v3 (ip + g) + wo - fp - wm;\n        s = dot (w, w);\n        if (s > 1e-3) d = SmoothMin (d, dot (0.5 * (w + 2. * wm), w / sqrt (s)), 0.15);\n      }\n    }\n  }\n  return d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d, dh, w;\n  dMin = dstFar;\n  d = length (p) - 1.;\n  if (d < 0.5) {\n    w = (0.1 + 0.9 * SmoothBump (0.1, 0.9, 0.05, mod (0.05 * tCur, 1.))) *\n       VPoly (3. * normalize (p));\n    dh = SmoothMin (d + 0.1, SmoothMax (d - 0.2, 0.08 - w, 0.1) +\n       0.1 * (1. - 0.7 * smoothstep (0.1, 0.4, w)), 0.1);\n    d = SmoothMax (abs (d), w, 0.05) - 0.05;\n    DMIN (1);\n    d = dh + 0.01 * Noisefv3 (64. * p);\n    DMIN (2);\n  } else dMin = d;\n  return 0.5 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec2 f;\n  f = mod (16. * vec2 (atan (rd.z, - rd.x), asin (rd.y)) / pi, 1.);\n  return 0.5 * mix (vec3 (0.2, 0.3, 0.6), vec3 (0.7, 0.7, 0.4),\n     max (SmoothBump (0.47, 0.53, 0.01, f.x), SmoothBump (0.47, 0.53, 0.01, f.y))) *\n     (0.7 + 0.3 * rd.y);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 dirGlow;\n  float dstGlow, brGlow;\n  brGlow = 0.;\n  dirGlow = - ro;\n  dstGlow = length (ro);\n  dirGlow /= dstGlow;\n  if (dstGlow < dstObj) brGlow = 5. * pow (max (dot (rd, dirGlow), 0.), 128.) / dstGlow;\n  return clamp (brGlow * SmoothBump (0.1, 0.9, 0.05, mod (0.05 * tCur, 1.)), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstObj, sh, vv;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.8, 0.4, 0.2, 0.2);\n    else if (idObj == 2) col4 = vec4 (mix (vec3 (0.1, 0.5, 0.2),\n       vec3 (0.5, 0.5, 0.1), 0.3 * step (0.5, Noisefv3 (4. * ro +\n       4. * Fbm1 (2. * tCur)))), -1.);\n    vv = max (dot (vn, ltDir), 0.);\n    sh = ObjSShadow (ro, ltDir);\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.8 * sh * vv * vv) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col = mix (col, BgCol (reflect (rd, vn)), 0.3);\n    } else {\n      vv = max (- dot (vn, rd), 0.);\n      col = (0.5 + 0.5 * sh) * col4.rgb * (0.8 + 0.3 * Fbm1 (6.5 * tCur)) *\n         (0.6 + 0.4 * vv * vv);\n    }\n  } else col = 0.3 * BgCol (rd);\n  col = mix (col, vec3 (0.3, 1., 0.8), GlowCol (roo, rd, dstObj));\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.002 * pi * tCur;\n    el -= 0.05 * pi * sin (0.001 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -8.);\n  zmFac = 6.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[714, 714, 736, 736, 1558], [1560, 1560, 1582, 1582, 2052], [2054, 2054, 2087, 2087, 2264], [2266, 2266, 2287, 2287, 2484], [2486, 2486, 2523, 2523, 2745], [2747, 2747, 2769, 2769, 3023], [3025, 3025, 3073, 3073, 3371], [3373, 3373, 3408, 3408, 4382], [4426, 4426, 4482, 4482, 5523], [5525, 5525, 5561, 5561, 5767], [5769, 5769, 5799, 5799, 5912], [5914, 5914, 5959, 5959, 6062], [6064, 6064, 6109, 6109, 6147], [6149, 6149, 6206, 6206, 6289], [6323, 6323, 6347, 6347, 6400], [6402, 6402, 6426, 6426, 6619], [6621, 6621, 6645, 6645, 6865], [6867, 6867, 6892, 6892, 7038], [7040, 7040, 7065, 7065, 7290], [7292, 7292, 7314, 7314, 7468]], "test": "untested"}
{"id": "tt3XDr", "name": "Logistic Map Bifurcation 2", "author": "Txoka", "description": "Bifurcation diagram for the Logistic Map.", "tags": ["2d", "fractal", "map", "chaos", "logistic", "bifurcation", "logisticmap"], "likes": 7, "viewed": 529, "published": 3, "date": "1580746027", "time_retrieved": "2024-07-30T21:26:09.374232", "image_code": "void mainImage( out vec4 Q, in vec2 U ){\n    Q=texture(iChannel0,U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 Q,in vec2 U){\n    float k=U.y/iResolution.y;\n    float x=U.x/iResolution.x*4.;\n    float f=0.;\n    \n    //float y=U.y/iResolution.y;\n    float y=sin(iTime/5.)*0.5+0.5;\n    \n    for(int i=0;i<256;i++){\n   \t\ty=x*y*(1.-y);\n        f+=exp(-3e5*(y-k)*(y-k));//0.25*... (makes the chaos more clear)\n        //f+=0.5*exp(-1e3*abs(y-k));\n    }\n    Q=mix(texture(iChannel0,U/iResolution.xy),vec4(1.-0.5*f),0.1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 85]], "test": "untested"}
{"id": "3l3XDr", "name": "shad3r", "author": "xvart", "description": "was again a checker board, not anymore still", "tags": ["cineshader"], "likes": 6, "viewed": 25243, "published": 3, "date": "1580709639", "time_retrieved": "2024-07-30T21:26:10.210995", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w1 = 41.0;\n    float w2 = 23.0;\n    float speedMultiplier = 18.0f;\n    \n    vec3 col = vec3(0.0f,0.0f,0.0f);\n    float d = 0.0f;\n    int modular = 10;\n    float moveOffset = iTime/speedMultiplier;\n    \n\n    int uvY100 = int(round((uv.y + moveOffset) * 100.0));\n    int aStepY100 =  uvY100 % modular;\n   \n    float aStepY = (float(aStepY100)/float(modular - 1));\n    float dStepY = round(aStepY);\n\n    \n    int uvX100 = int(round((uv.x + moveOffset) * 100.0));\n    int aStepX100 =  uvX100 % modular;\n    float aStepX = (float(aStepX100)/float(modular - 1));\n    float dStepX = round(aStepX);\n    \n    \n    float dStepXY = dStepX * dStepY;\n    \n    col = vec3(dStepX,dStepX,dStepX);\n    \n    float blockHeight = dStepXY/2.0;\n    float xRipple = 0.5 * cos((uv.x + iTime/w1) * iTime/(w2*10.0));\n    // float yRipple = 0.5 * sin((uv.y + iTime/w2) * iTime/(w1*10.0));\n\tfloat yRipple = 0.5 * sin((iTime/(w1*100.0)));\n    \n    d = (xRipple + yRipple) * blockHeight;\n    // d = blockHeight * (1.0 - uv.x) * (1.0 - uv.y);\n    // d = blockHeight * (1.0 - length(uv - 0.5) * 2.0);\n    // d = blockHeight;\n    \n\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"shad3r\",\n\t\"description\": \"was again a checker board, not anymore still\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3XDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wt3XDr", "name": "sha2er", "author": "xvart", "description": "was a checker board, not anymore again", "tags": ["cineshader"], "likes": 2, "viewed": 13152, "published": 3, "date": "1580709591", "time_retrieved": "2024-07-30T21:26:11.114579", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w1 = 41.0;\n    float w2 = 23.0;\n    float speedMultiplier = 18.0f;\n    \n    vec3 col = vec3(0.0f,0.0f,0.0f);\n    float d = 0.0f;\n    int modular = 10;\n    float moveOffset = iTime/speedMultiplier;\n    \n\n    int uvY100 = int(round((uv.y + moveOffset) * 100.0));\n    //int aStepY100 =  uvY100 % modular;\n    int aStepY100 =  uvY100 % modular + int(round(iTime/100.0));\n    float aStepY = (float(aStepY100)/float(modular - 1));\n    float dStepY = round(aStepY);\n\n    \n    int uvX100 = int(round((uv.x + moveOffset) * 100.0));\n    int aStepX100 =  uvX100 % modular;\n    float aStepX = (float(aStepX100)/float(modular - 1));\n    float dStepX = round(aStepX);\n    \n    \n    float dStepXY = dStepX * dStepY;\n    \n    col = vec3(dStepXY,dStepXY,dStepXY);\n    \n    float blockHeight = dStepXY/2.0;\n    float xRipple = 0.5 * cos((uv.x + iTime/w1) * iTime/(w2*10.0));\n    //float yRipple = 0.5 * sin((uv.y + iTime/w2) * iTime/(w1*10.0));\n\tfloat yRipple = 0.5 * sin((iTime/(w1*200.0)));\n    d = (xRipple + yRipple) * blockHeight / 5.0;\n    \n\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"sha2er\",\n\t\"description\": \"was a checker board, not anymore again\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3t3XDr", "name": "sha1er", "author": "xvart", "description": "was a checker board, not anymore.\n\nhttps://cineshader.com/view/3t3XDr", "tags": ["cineshader"], "likes": 3, "viewed": 15933, "published": 3, "date": "1580709529", "time_retrieved": "2024-07-30T21:26:11.963309", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w1 = 41.0;\n    float w2 = 23.0;\n    float speedMultiplier = 18.0f;\n    \n    vec3 col = vec3(0.0f,0.0f,0.0f);\n\tfloat modular = 10.0f;\n    float moveOffset = iTime/speedMultiplier;  \n    \n    float w = 100./modular/iResolution.y;\n    vec2 aStep =fract(((uv + moveOffset) * 100.) / modular),\n         dStep = smoothstep(-w,w,abs(aStep-.5)-.25);\n    \n    float dStepXY = dStep.x * dStep.y;\n    \n    col = vec3(dStepXY,dStepXY,dStepXY);\n       \n    float blockHeight = dStepXY/2.0;\n\n    fragColor = vec4(col, blockHeight);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"sha1er\",\n\t\"description\": \"was a checker board, not anymore. Improved by Fabrice Neyret\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 685]], "test": "untested"}
{"id": "tldXR7", "name": "Parallel", "author": "hanabi", "description": "Like GNU Parallel's logo http://www.gnu.org/software/parallel/ \nright-end isn't correct.", "tags": ["parallelillusion"], "likes": 3, "viewed": 323, "published": 3, "date": "1580678696", "time_retrieved": "2024-07-30T21:26:12.830990", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = iResolution.x / 16.;\n    float h = iResolution.y / 15.;\n\n    float j = mod(fragCoord.y / h, 4.);\n\n    float xPos = fragCoord.x;\n    if (j > 3.)\n        xPos -= 10.;\n    else if (j > 2.)\n        xPos -= 20.;\n    else if (j > 1.)\n        xPos -= 10.;\n    \n    float i = mod(floor(xPos / w), 2.);\n\n    fragColor = vec4(1);\n    if (i >= 1.0) {\n        fragColor = vec4(0);\n    }\n\n    float ij = mod(fragCoord.y, h);\n    if (ij < 1.)\n        if (i >= 1.)\n        \tfragColor = vec4(1);\n        else\n            fragColor = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 599]], "test": "untested"}
{"id": "tltSzM", "name": "neon business", "author": "loicvdb", "description": "Another experiment with real time path tracing", "tags": ["raymarching", "fractal", "gi", "globalillumination", "pathtracing", "depthoffield", "ao", "reprojection"], "likes": 16, "viewed": 727, "published": 3, "date": "1580672578", "time_retrieved": "2024-07-30T21:26:13.886168", "image_code": "//second DoF pass\n\n#define dir normalize(vec2(1.0, -1.0))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n/*\n//better but way slower bloom\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel1, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom - vec3(threshold), vec3(0));\n}*/\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel1, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*cam.aperture)/iResolution.xy);\n        dr = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*cam.aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.08 * iResolution.y, .0, fragCoord) * .13;\n    \n    fragColor = vec4(ACESFilm(col.rgb + bloomSum), 1.);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//increase this number for a better GI\n#define IndirectSamples 1\n\n//increase to remove more noise, but might make the result blurrier\n#define SamplesLimit 80\n\n//GI bounces\n#define Bounces 1\n\n\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .5\n\n\n\n#define Pi 3.14159265359\n\n#define MaxStepsDirect 128\n#define MaxStepsIndirect 32\n#define MaxShadowSteps 32\n#define MaxDist 4.\n#define MinDist .01\n\n#define DoFClamping .25\n#define DoFSamples 32\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    vec3 rot = vec3(cos(time*.4)/6., 4.75 + sin(time*.2)/4., .5);\n    return Camera(vec3(0., 0., -20.) * rotationMatrix(rot), rot, 2., 17.5, .04);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n\nfloat sdf(vec3 position, out vec3 diffuseColor, out vec3 emissionColor){\n    diffuseColor = vec3(1.);\n    emissionColor = vec3(0.);\n    float Scale = 2.25;\n    float Radius = .25;\n    int Iterations = 6;\n    mat3 Rotation;\n    \n    float time = 104.;\n    \n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz*Rotation, 1.0), p0 = p;\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 3) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n    diffuseColor = fract(p0.x)<.1 ? vec3(0.) : vec3(1.);\n    emissionColor = fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.);\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat sdf(vec3 position){\n    vec3 dc, ec;\n    return sdf(position, dc, ec);\n}\n\nvec3 normalEstimation(vec3 pos){\n  vec2 k = vec2(MinDist, 0);\n  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),\n\t  \t\t\t\t\tsdf(pos + k.yxy) - sdf(pos - k.yxy),\n  \t\t\t\t\t\tsdf(pos + k.yyx) - sdf(pos - k.yyx)));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "bool trace(inout vec3 pos, in vec3 dir){\n    pos += dir*sdf(pos);\n    pos += dir*sdf(pos);\n    for(int i = 0; i < MaxStepsDirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            pos -= (2.*MinDist-dist) * dir;\n            pos -= (2.*MinDist-sdf(pos)) * dir;\n            pos -= (2.*MinDist-sdf(pos)) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    fragColor = vec4(0.);\n    vec3 pos = cam.pos;\n    if(trace(pos, dir)) fragColor = vec4(pos, 1.);\n}", "buffer_b_inputs": [], "buffer_c_code": "float seed;\n\nvec3 LightDir = normalize(vec3(.0, .0, -1));\nvec3 LightColor = vec3(.3, .5, .7) * 10.;\nfloat LightRadius = .05;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    //return vec3(0.);\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\n\nvec3 background(vec3 dir){\n    return vec3(0.);\n}\n\n\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < MaxStepsIndirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir = getCosineWeightedSample(normal);\n    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;\n    for(int i = 0; i < Bounces; i++){\n        if(!trace(pos, dir, normal)) return light + abso*background(dir);\n        sdf(pos, dc, ec);\n        light += abso * (ec + dc*directLight(pos, normal));\n        abso *= dc;\n        dir = getCosineWeightedSample(normal);\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MaxDist;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = MaxDist;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = .256435865*fragCoord.x+.316548465*fragCoord.y+sin(iTime)*16886.3158915;\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(background(uv2dir(cam, uv)), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal = normalEstimation(hit.xyz);\n        \n        vec3 dLight = directLight(hit.xyz, normal);\n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        vec3 dc, ec;\n        sdf(hit.xyz, dc, ec);\n        dLight = ec + dc*dLight;\n        iLight *= dc;\n        \n        fragColor = previousSample(hit);\n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        iLight = clamp(iLight, vec3(.0), vec3(fragColor.a/5.)); // clamp gi for low sample count\n        fragColor.rgb = mix(fragColor.rgb, iLight + dLight, 1.0/(fragColor.a/float(IndirectSamples)));\n        #endif\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//first DoF pass\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d, de;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        vec2 de = (fragCoord + d*iResolution.y*cam.aperture)/iResolution.xy;\n        p.rgb = texture(iChannel0, de).rgb;\n        p.a = length(texture(iChannel1, de).rgb - cam.pos);\n        dr = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*cam.aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 82, 82, 222], [769, 769, 826, 826, 1131], [1134, 1134, 1190, 1190, 1951]], "test": "untested"}
{"id": "WltXR7", "name": "Day 45 - Isometric", "author": "jeyko", "description": "Wrote an isometric engine.\nIf you would like to use it, you can fill up the sdMain() function with your code.\nThe sdIso() function is where the repetition magic happens, it's a heavy read.", "tags": ["isometric", "mdtmjvm"], "likes": 6, "viewed": 381, "published": 3, "date": "1580670666", "time_retrieved": "2024-07-30T21:26:14.647134", "image_code": "vec3 glow = vec3(0);\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define pi acos(-1.)\n\n#define iTime 0.5*(iTime + 1.*pi/2.)\n#define modDist vec2(1.42,1.)\n\n#define xOffs 0.71\n#define yOffs 0.7\n\n#define ZOOM 5.\n#define mx (50.*iMouse.x/iResolution.x)\n#define my (-iTime + 50.*iMouse.y/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n\tp = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\n\n\nfloat sdBoxIQ( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOcta(vec3 p, vec3 s, vec2 id){\n\tp = abs(p) - s;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d =  dot(p.xz + s.zx*0.5, normalize(vec2(1)));\n    \n    d = max(d, dot(p.xy + s.xy*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.xy*0.5, normalize(vec2(1))));\n    \n    return d;\n}\n\nfloat sdRuby(vec3 p, vec3 s){\n\tp = abs(p) - s*0.9;\n    float d = max(p.x, max(p.y, p.z));\n\t//p = abs(p);\n    //p.xy *= rot(0.125*pi);\n    d = max(d, dot(p.xz + s.xz*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.zy*0.5, normalize(vec2(1))));\n    //d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1))));\n    \n    return d;\n\n\n}\nfloat sdMain(vec3 p, vec2 idD){\n\tfloat d = 10e6;\n    \n    \n    \n    //p.xz *= rot(0. + iTime);\n    \n    d = sdBox(p, vec3(0.51));\n    //p.zy *= rot(-0.2565*pi );\n    //p.xy *= rot(-0.25*pi);\n    \n    #define tau (2.*pi)\n    float T = 7.*iTime/tau;\n    \n    \n    \n    vec3 s = vec3(0.5 + sin(iTime)*0.7);\n    \n    if(mod(floor(iTime/tau), 2.) == 1.){\n        for(int i = 0; i < 4; i++){\n            p = abs(p);\n\n            p.xy  *= rot(1.5*pi + sin(iTime)*0. + idD.x*pi);\n            p.xz *= rot(0.99);\n            //p.x -= 0.02;\n        }\n    \ts = vec3(0.5 + sin(iTime)*0.35);\n    }\n    //p = abs(p);\n    \n    d = min(d, sdOcta(p, s, idD));\n    \n    //d = max(d, -sdOcta(p, vec3(0.4 + sin(iTime)*0.5), idD));\n    //d = min(d, sdOcta(p, vec3(0.4 + sin(iTime)*0.5), idD));\n    \n    \n    \n\treturn d;\n}\n\n\nvec2 id;\n\nfloat sdIso(vec3 p, vec2 id){\n\tfloat d = 10e6;\n    //p.z -= 0.;\n    vec3 q = p;\n    \n    // ME\n    p.x -= id.y*xOffs;\n    p.y += id.y*yOffs;\n    p.xz = pmod(p.xz, modDist);\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, id));\n    \n    vec2 idD = id;\n    \n    // BOTTOM\n    p = q;\n    idD.y += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0,0. - id.y), vec2(modDist.x,modDist.y*3.));\n    \n    if (p.x > 0.){\n        idD.x -= 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n\n    // RIGHT\n    p = q;\n    idD = id;\n    idD.x -= 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // LEFT\n    p = q;\n    idD = id;\n    idD.x += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // TOP\n    idD = id;\n    idD.y -= 1.;\n    p = q;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0.,-1. - id.y), vec2(modDist.x,modDist.y*3.));\n    if (p.x < 0.){\n      idD.x += 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n    \n\treturn d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    p.x += 0.5;\n    id = floor(p.xz/modDist);\n    id.x = floor((p.x - modDist.x*0.5*id.y)/modDist.x);\n    \n    d.x = min(d.x, sdIso(p, id));\n    \n    d.x *= 0.55;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tp = ro;\n    vec2 d;\n    hit = false;\n    for(int i = 0; i < 280 ;i++){\n    \td = map(p);\n        glow += exp(-d.x*6.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro );\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro -= ZOOM*dir;\n\treturn dir + right*uv.x + up*uv.y;\n}\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    \n    ro += right*uv.x*ZOOM;\n    ro += up*uv.y*ZOOM;\n \treturn rd;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0.0);\n    vec3 lookAt = vec3(0,-1,-2);\n    \n    \n    vec3 ro = vec3(0,8,0);\n   \n    vec3 rd = getRdIsometric(ro, lookAt, uv); \n    //vec3 rd = getRd(ro, lookAt, uv); \n        \n    vec3 p;\n    \n    //ro.x += mx;\n    ro.z += my;\n    ro.y -= my*0.65;\n    //ro += rd*5.4;\n    \n    float t = 0.; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if (hit){\n        vec3 n =-getNormal(p);\n        n.g*=0.4;\n        \n    \tcol += 0.8 + n*0.5;\n    \t\n    } else {\n    \n    }\n    \n    \n    col += glow*0.02;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    \n    \n    col = pow(col, vec3(1.7));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 371, 371, 423], [426, 426, 459, 459, 546], [548, 548, 586, 586, 845], [847, 847, 876, 876, 1184], [1185, 1185, 1216, 1216, 1984], [1997, 1997, 2026, 2026, 3355], [3357, 3357, 3374, 3374, 3575], [3577, 3577, 3651, 3651, 3903], [3905, 3905, 3928, 3928, 4067], [4069, 4069, 4117, 4117, 4312], [4313, 4313, 4370, 4370, 4607], [4609, 4609, 4666, 4666, 5416]], "test": "untested"}
{"id": "WtyGzV", "name": "first attempt at rendering water", "author": "maksy", "description": "first attempt at rendering water\n\nUPDATE: Added caustics\nUPDATE: Added fog for atmosphere", "tags": ["water"], "likes": 4, "viewed": 784, "published": 3, "date": "1580670082", "time_retrieved": "2024-07-30T21:26:15.426051", "image_code": "/*\n * Resources:\n * https://www.shadertoy.com/view/llsXD2\n * https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n * https://medium.com/@evanwallace/rendering-realtime-caustics-i\n * https://www.shadertoy.com/view/MttBRS\n * https://www.shadertoy.com/view/MldfDn\n */\n\n#define PI 3.141592\n#define MAX_STEPS 250\n#define MAX_DIST 250.0\n#define SURF_DIST .001\n\n#define WATER 0\n#define SKY 1\n\n#define LIGHT_POS vec3(0, 5, 25)\n\nstruct Obj {\n\tint type;\n    float d;\n    vec3 hitPos;\n};\n    \nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value noise from the book of shader\nfloat noise(in vec2 uv) {\n     \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves) {\n    \n    // Initial values\n    float value = 0.0;\n    float amplitude = .1;\n    float frequency = 0.;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// --- analytically triangle-filtered checkerboard by iq ---\nvec3 pri(in vec3 x) {    \n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri(in vec3 p, in vec3 ddx, in vec3 ddy) {\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.1 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec3 floorColor(in vec3 pos) {\n\n\tvec3 uvw = 1.2 * pos;\n\n\t// calc texture sampling footprint\t\t\n\tvec3 ddx_uvw = dFdx( uvw ); \n    vec3 ddy_uvw = dFdy( uvw );\n    vec3 color = vec3(checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw));\n  \n    return color;\n}\n\nObj getDistance(vec3 p) {\t\n       \n    float height = fbm(vec2(p.x, p.z) + (iTime/3.), 2);\n    float waterDist = p.y - height;\n    \n    Obj obj = Obj(WATER, waterDist, p);\n    \n    return obj;\n}\n\n// Basic raymarching loop\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.;\n    \n    Obj hitObj = Obj(SKY, t, ro + rd);\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        \n        hitObj = getDistance(p);\n        t += hitObj.d*0.35;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(SKY, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.d) < SURF_DIST) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.d = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getWaterNormal(vec3 p) {\n\tfloat d = getDistance(p).d;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(.5, 0);\n    vec3 n = d - vec3(\n        getDistance(p-e.xyy).d,\n        getDistance(p-e.yxy).d,\n        getDistance(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\n// calculates the intersection of the given plane and ray\nvec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {\n    \n    vec3 planeNormal = vec3(0, 1, 0);\n    \n\tfloat a = dot(dir, planeNormal);\n   \n    float distToPlane = dot(ori-planePos, planeNormal);\n    vec3 intersectPt = ori + dir*abs(distToPlane/a);\n    \n    return intersectPt;\n}\n\n// calculates specular lighting\nfloat specular(vec3 n, vec3 l, vec3 rd, float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(rd, n), l),0.0), s) * nrm;\n}\n\nvec3 getSkyColor(vec3 rd, vec3 light) {\n    \n    vec3 col = vec3(0.4);\n   \t// sun\n   \tfloat sundot = clamp(dot(rd, normalize(light)),0.0,1.0);\n   \t// sun scatter\n\tcol += 0.6*vec3(1.0,0.7,0.3) * pow(sundot, 8.0);\n   \tcol += 0.25*vec3(1.0,0.7,0.4) * pow(sundot, 5.0);\n\tcol += 0.25*vec3(1.0,0.8,0.6) * pow(sundot, 64.0);\n\tcol += 0.2*vec3(1.0,0.8,0.6) * pow(sundot, 512.0);\n    \n    return col;\n}\n\nvec3 getWaterColor(vec3 p, vec3 n, vec3 rd, vec3 distToP) {  \n    \n    // Fresnel is an exponential that gets bigger when the angle between the water\n    // surface normal and camera ray is smaller. It is used to calculate \n    // the amount of reflected vs. refracted light.\n    float fresnel = 1.0 - max(dot(n, -rd), 0.0);\n    fresnel = fresnel*fresnel*fresnel * 0.25;                        \n        \n    // Bounces the camera ray towards the sky and gets its color\n    vec3 reflected = getSkyColor(reflect(rd, n), normalize(LIGHT_POS));    \n    \n    // Calculates refraction effect based on angle between the light and surface normal \n     vec3 refractDir = refract(rd, n, 1.0/1.3);\n     vec3 refractedPos = intersectPlane(p, refractDir, vec3(0.0, -1.0, 0.0));\n    // floor color at the position hit by the refracted ray\n    vec3 refracted = floorColor(refractedPos);\n    \n    // Blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted, reflected, fresnel);\n    \n  \t// Add specular hilight\n    color += vec3(specular(n, normalize(LIGHT_POS), rd, 100.0));    \n    \n    return color;\n}\n\nfloat caustics(vec3 waterHitPos, vec3 lightPos) {\n    \n    vec3 ray = normalize(waterHitPos - lightPos);\n    \n    // Calculate the intersection of the light and the non-deformed water plane\n    vec3 surfacePlaneNormal = vec3(0.0, 1.0, 0.0);    \n    vec3 planePos = vec3(0, 0, 0);\n        \n    vec3 surfacePlaneHitPos = rayMarch(lightPos, ray).hitPos;\n    float height = fbm(vec2(surfacePlaneHitPos.x, surfacePlaneHitPos.z) + (iTime/3.), 2);\n    surfacePlaneHitPos += vec3(0., height, 0.);\n    \n    // Calculate the intersection of the refracted ray and bottom plane   \n    vec3 refractDir = refract(ray, surfacePlaneNormal, 1.0/1.3);   \n    vec3 bottomPlanePos = vec3(0.0, 1.0, 0.0);\n    vec3 beforePos = intersectPlane(surfacePlaneHitPos, refractDir, bottomPlanePos);\n  \tbeforePos += surfacePlaneHitPos;\n    \n  \t// Calculate the intersection of the light and deformed water surface\n    vec3 deformedPlaneHitPos = rayMarch(lightPos, ray).hitPos;\n   \tvec3 normal = getWaterNormal(deformedPlaneHitPos);\n    \n    // Calculate the intersection of the refracted ray and bottom plane   \n    refractDir = refract(ray, normal, 1.0/1.3);\n    vec3 afterPos = intersectPlane(deformedPlaneHitPos, refractDir, bottomPlanePos);\n    afterPos += deformedPlaneHitPos;\n       \n    float beforeArea = length(dFdx(beforePos)) * length(dFdy(beforePos));\n    float afterArea = length(dFdx(afterPos)) * length(dFdy(afterPos));\n    return max(beforeArea / afterArea, .001);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 col = vec3(.05, .25, 0.5);   \n       \n    // camera\n    vec3 ro = vec3(.5, 2, -8);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    Obj hitObj = rayMarch(ro, rd);   \n       \n    if (hitObj.type == SKY) {\n\n\t\tcol = getSkyColor(rd, LIGHT_POS-vec3(0., 3, 0.));\n        \n    } else if (hitObj.type == WATER) {\n    \n   \t\tvec3 normal = getWaterNormal(hitObj.hitPos);       \n        col += getWaterColor(hitObj.hitPos, normal, rd, hitObj.hitPos - ro)*0.6;\n    \tcol *= caustics(hitObj.hitPos, LIGHT_POS);\n        float fogAmount = pow(1.0 - pow(rd.y,2.0), 200.0);\n        col = mix(col, getSkyColor(rd, LIGHT_POS-vec3(0., 3, 0.)), fogAmount);     \n    }\n        \t\n    col = pow(col,vec3(.454545));\n \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 561, 561, 643], [645, 684, 709, 709, 1097], [1099, 1335, 1371, 1398, 1652], [1654, 1715, 1736, 1736, 1812], [1814, 1814, 1881, 1881, 2104], [2106, 2106, 2136, 2136, 2354], [2356, 2356, 2381, 2381, 2550], [2552, 2578, 2610, 2610, 3263], [3265, 3265, 3294, 3294, 3550], [3552, 3610, 3666, 3666, 3892], [3894, 3926, 3976, 3976, 4080], [4082, 4082, 4121, 4121, 4474], [4476, 4476, 4535, 4751, 5615], [5617, 5617, 5666, 5666, 7068], [7070, 7070, 7125, 7205, 8002]], "test": "untested"}
{"id": "wttSRM", "name": "More fire on Camera 2", "author": "ManuManu", "description": "Still addign some fire from red color on camera, but with a very sensitive red detection.\nSo your skin is probably red enough for the fire :)\n( depending on your webcam )\n\nLittle brother of this one, with less fire : https://www.shadertoy.com/view/WltSzN", "tags": ["fire", "red", "webcam"], "likes": 5, "viewed": 801, "published": 3, "date": "1580664636", "time_retrieved": "2024-07-30T21:26:16.309689", "image_code": "vec3 fireGrad(float x)\n{\n    vec3 a = vec3(0.0,0.0,0.0);\n    vec3 b = vec3(1.0,0.0,0.0);\n    vec3 c = vec3(1.0,1.0,0.0);\n    vec3 d = vec3(1.0,1.0,1.0);\n    vec3 col;\n    col = mix(a,b,smoothstep(0.0,0.6,x));\n    col = mix(col,c,smoothstep(0.6,0.9,x));\n    col = mix(col,d,smoothstep(0.9,1.0,x));\n    \n    return col;\n}\n\n\n\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nvec3 greyCamera(vec2 uv)\n{\n    // Use a grey camera as the background :\n    float grey = dot(vec3(texture(iChannel1, uv)), vec3(0.299, 0.587, 0.114) );\n\n    vec3 col;\n     // board + vignetting\n    {\n        col = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( 2.*(uv-.5) ));\n        col *= 1.0 - 0.1*smoothstep( 0.0,1.0,sin(uv.x*320.0)*sin(uv.y*320.0))*(1.0 - smoothstep( 1.0, 1.01, abs(uv.x) ) );\n    }\n    return col + vec3(grey * .5);\n}\n\n\nvec4 shapeToFlame(vec2 uv, float n, float c )\n{\n    float c1 = n * c * (1.5-pow(1.5*uv.y,.9));\n//\tfloat c1 = n * c * (1.5-pow(2.50*uv.y,4.));\n\tc1=clamp(c1,0.,1.);\n\n    float boostRed = 1.6;\n\tvec4 col = vec4(boostRed*c1, boostRed*c1*c1*c1, c1*c1*c1*c1*c1*c1,c1);\n    \n#ifdef TRY_SMOKE\n    float blackAdded = 1.- distance( c1, 0.3 );\n    blackAdded = clamp( blackAdded, 0.,1.);\n    blackAdded = pow( blackAdded, 20.0);\n    \n    vec4 blackCol = vec4(0., 0.,0.,1.);\n    col = mix ( col, blackCol, blackAdded-noise(uv+vec2(0, iTime))*0.5);\n#endif // TRY_SMOKE    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //vec3 origColor = vec3( texture(iChannel0, uv));\n    float strength = floor(uv.x+1.);\n\tfloat T3 = max(3.,1.25*strength)*iTime;\n\n    float n= fbm( uv * strength *5. - vec2(0,T3) );\n    \n    float flameShape = vec3( texture(iChannel0, uv)).r;\n    //flameShape = 10.0;\n    float maxVal = 1.5;\n    flameShape = clamp(flameShape, 0.,maxVal);\n    \n    if ( isDebug()> .5 )\n    {\n        if ( uv.x > 0.9 )\n            flameShape = ( 1.-uv.y) * maxVal;\n    }\n    \n    flameShape = pow(flameShape/maxVal, 0.8)*maxVal;\n    \n    \n    if ( isDebug()> .5 )\n    {\n        if ( uv.x > 0.8 && uv.x < 0.9 )\n            flameShape = ( 1.-uv.y) * maxVal;\n    }    \n    vec4 colFire = shapeToFlame( uv, n, flameShape );\n    \n    \n    \n    //vec3 color = fireGrad(n*origColor*2.2);\n    //color = col;\n    // Output to screen\n    \n    vec3 col;// = colFire;\n    \n    //col += greyCamera(uv);\n    col += texture(iChannel1, uv).rgb;\n    col = mix( texture(iChannel1, uv).rgb, colFire.rgb, colFire.a);\n    \n\t//if ( uv.x > 0.9 )\n      //  col = vec3(1.-uv.y);\n\n\n    \n    //col = vec3(n);\n    //col = vec3(flameShape);\n    \n    // for test :\n    //col = vec3( texture(iChannel2, uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DEBUG_MODE 1\n\n\nfloat isDebug()\n{\n    return .0;\n}\n\n\nfloat lotsOfRed()\n{\n    return 1.0;\n}", "buffer_a_code": "float isRedColorRGB( vec3 color )\n{\n    vec3 wantedColor=  vec3( 1.0, .0, .0 );\n    float distToColor = distance( color.rgb, wantedColor ) ;\n    return distToColor;\n}\n\nfloat isRedColor( vec3 color )\n{\n    return isRedColorRGB(color);\n}\n\n\nconst float threshold = .6;\nvec3 onlyRedImage2( vec3 color )\n{\n    float isRed = isRedColor( color );\n\n    vec3 resColor = vec3(0.);\n    if ( isRed  < threshold )\n        resColor = color;\n    return resColor;\n}\n\n\nvec3 onlyRedImage1( vec3 col )\n{\n\tfloat maxgb = max( col.g, col.b );\n    float k = clamp( (col.r-maxgb)*5.0, 0.0, 1.0 );\n    return mix( vec3(0.), col, k);\n}\n\nvec3 onlyRedImage( vec3 col )\n{\n    if (lotsOfRed() > 0.5)\n        return onlyRedImage1(col);\n\treturn onlyRedImage2(col);\n}\n\n\nfloat HorizontalLine( vec2 uv, float size )\n{\n    uv = uv /  vec2( size, .02);\n    vec2 absUV = abs(uv);\n    \n    return 1.-step( 1., max(absUV.x, absUV.y) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origColor = vec3( texture(iChannel0, uv));\n    \n    \n    // get red color from camera :\n\tvec3 color = onlyRedImage( origColor );\n    \n    // to help debug without camera :)\n    if (iMouse.z > .5 )\n    {\n        vec2 mouseUV = iMouse.xy / iResolution.xy;\n        mouseUV.x = (mouseUV.x);\n        \n        float m = HorizontalLine( uv - mouseUV, .05);\n        const vec3 redColor = vec3(1., .0, .0);\n    \tcolor = mix( color, redColor, m );\n    }\n    \n    if ( isDebug()> .5 )\n    {\n        float m = HorizontalLine( uv - vec2( .1, .1), .05);\n        const vec3 redColor = vec3(1., .0, .0);\n        color = mix( color, redColor, m );\n    }\n\n    fragColor = vec4(color, .1);\n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origColor = vec3( texture(iChannel0, uv));\n\n    vec2 pix = 1.0 / iResolution.xy;\n    \n    /*\n     float lastVal = \n        \ttexture(iChannel0, uv - vec2(0.0, pix.y)).r + \n        \ttexture(iChannel0, uv - vec2(0.0, pix.y*2.0)).r +\n        \ttexture(iChannel0, uv - vec2(pix.x, pix.y)).r +\n        \ttexture(iChannel0, uv - vec2(-pix.x, pix.y)).r;\n*/    \n/*\n    vec3 fireColor = \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y)).rgb + \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*2.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-pix.x, pix.y)).rgb;\n\tfireColor *= 0.248;  // cold phase\n*/\n    vec3 fireColor = \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y)).rgb + \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*2.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*3.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(2.*pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-2.*pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-pix.x, pix.y)).rgb;\n\tfireColor *= 0.14;  // cold phase\n\n    // Output to screen\n    fragColor = vec4(fireColor + origColor,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 319], [324, 352, 373, 373, 492], [494, 494, 520, 520, 978], [980, 980, 1000, 1000, 1230], [1232, 1232, 1258, 1303, 1664], [1667, 1667, 1714, 1714, 2243], [2246, 2246, 2303, 2303, 3546]], "test": "untested"}
{"id": "WldXz7", "name": "Ellipse Code Golf", "author": "BeardThings", "description": "Simple ellipse code golf sketch", "tags": ["code", "ellipse", "onetweet", "golf"], "likes": 1, "viewed": 459, "published": 3, "date": "1580664149", "time_retrieved": "2024-07-30T21:26:17.196318", "image_code": "void mainImage( out vec4 c, vec2 f )\n{\n    vec2 v=f/iResolution.xy*2.-1.,a=.4*vec2(sin(iTime),cos(iTime));\n    c=vec4(distance(v,a)+distance(v,-a)<.84);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 154]], "test": "untested"}
{"id": "WldSz7", "name": "YUV / YCbCr", "author": "FabriceNeyret2", "description": "which is the \"true one\" ?\nwhat about gimp IUT-R470 ?\nwhen applying final gamma or not ?\nwhat are the valid ranges ?", "tags": ["rgb", "colorspace", "yuv"], "likes": 4, "viewed": 600, "published": 3, "date": "1580660813", "time_retrieved": "2024-07-30T21:26:18.065993", "image_code": "// refs: https://en.wikipedia.org/wiki/YUV\n//       https://en.wikipedia.org/wiki/YCbCr\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 Y = vec3( .5, ( 2.*U/iResolution.xy - 1.) *.33 );\n                                                          // gimp IUT-R470 ? \n  //O.rgb = mat3(1,1,1,  0,-.39,2.03,  1.14,-0.58,0) * Y  // BT.601 (flat ?)\n  //O.rgb = mat3(1,1,1,  0,-.34,1.73,  1.37,-0.70,0) * Y; // ITU-R BT.601\n  //                               + vec3(-.75,.46,-.93); // ? \n  //O.rgb = mat3(1,1,1,  0,-.21,2.13,  1.28,-0.38,0) * Y; // BT.709 (flat ?)\n    O.rgb = mat3(1,1,1,  0,-.34,1.77,  1.40,-0.72,0) * Y; // JPEG\n\n  //O = pow(O, vec4(1./2.2));                             // gamma conversion\n\n    O = fract(O);                                         // to check overshoots\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 127, 127, 785]], "test": "untested"}
{"id": "3ltSzM", "name": "Crystal bunny", "author": "BrunoLevy", "description": "Rendering a mesh with a transparent material using an AABB\nAABB code, mesh compiler and references here: https://www.shadertoy.com/view/tl3XRN", "tags": ["raytracing", "aabb", "mesh"], "likes": 54, "viewed": 2898, "published": 3, "date": "1580658683", "time_retrieved": "2024-07-30T21:26:19.350558", "image_code": "// mesh compiler and references here: https://www.shadertoy.com/view/tl3XRN\n\n// Default settings\n#if 1\nconst float refract_index = 1.3;  // 1.0: no refraction   1.3: water\nconst float extinction = 0.25;     // the higher, the darker (in function of thicness) \nconst float reflect_coeff = 0.75; // 0.0: no reflection   1.0: shiny reflections\nconst vec3  core_color = vec3(0,0.5,0.5); \n#endif \n\n// Show mesh thickness\n#if 0\nconst float refract_index = 1.0;  \nconst float extinction = 0.3;     \nconst float reflect_coeff = 0.0; \nconst vec3  core_color = vec3(0,0,0); \n#define WHITE_BACKGROUND\n#endif \n\nivec3 get_facet(in int f) {\n    return ivec3(\n        get_data(MESH_DATA_OFFSET,3*f),\n        get_data(MESH_DATA_OFFSET,3*f+1),\n        get_data(MESH_DATA_OFFSET,3*f+2)\n    );\n}\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Intersection {\n   float t;\n   vec3 P;\n   vec3 N;\n   int id;\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   I.id = -1; // index of latest intersected triangle\n   return I;\n}\n\nRay reflect_ray(in Ray R, in Intersection I) {\n    return Ray(I.P, reflect(R.Dir, I.N));\n}\n\nRay refract_ray(in Ray R, in Intersection I, in float n1, in float n2) {\n    return Ray(I.P, refract(normalize(R.Dir), I.N, n1/n2));\n}\n\nbool intersect_triangle(\n    in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t, \n    out float u, out float v, out vec3 N\n) { \n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n         N = cross(E1,E2);\n   float det = -dot(R.Dir, N);\n   float invdet = 1.0/det;\n   vec3 AO  = R.Origin - A;\n   vec3 DAO = cross(AO, R.Dir);\n   u =  dot(E2,DAO) * invdet;\n   v = -dot(E1,DAO) * invdet;\n   t =  dot(AO,N)   * invdet;\n   return (abs(det) >= 1e-6 && t >= 0.0 && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0);\n}\n\nbool triangle(in Ray R, vec3 A, vec3 B, vec3 C, inout Intersection I) {\n   float t,u,v;\n   vec3 N;\n   if(intersect_triangle(R, A,B,C, t, u, v, N) && t < I.t) {\n      I.t = t;\n      I.P = R.Origin + t*R.Dir;\n      I.N = N;\n      return true;\n   }\n   return false;\n}\n \nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax,\n  in float t \n) {  \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2);\n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);\n}\n\nint stack_top = -1;\nint stack_b[10];\nint stack_e[10];\n\nbool stack_empty() {\n  return (stack_top < 0);\n}\n\nvoid stack_push(in int b, in int e) {\n  stack_top++;\n  stack_b[stack_top] = b;\n  stack_e[stack_top] = e;  \n}\n\nvoid stack_pop(out int b, out int e) {\n  b = stack_b[stack_top];\n  e = stack_e[stack_top];\n  --stack_top;\n}\n\nvec3 decode_vertex(int xyz) {\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return bbox_min + (bbox_max - bbox_min) * vec3(XYZ) / 1023.0;\n}\n\nvec3 min3(in vec3 p1, in vec3 p2, in vec3 p3) {\n    return min(min(p1,p2),p3);\n}\n\nvec3 max3(in vec3 p1, in vec3 p2, in vec3 p3) {\n    return max(max(p1,p2),p3);\n}\n\nbool mesh_AABB(in Ray R, inout Intersection I) {\n    int prev_id = I.id; // index of latest intersected triangle\n    bool result = false;\n    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);\n    stack_push(0, AABB_data_size);\n    while(!stack_empty()) {\n        int b,e;\n        stack_pop(b,e);\n        ivec3 node = get_facet(b);\n        vec3 bbox_min = decode_vertex(node.x);\n        vec3 bbox_max = decode_vertex(node.y);\n        if(!segment_box_intersection(R.Origin, invDir, bbox_min, bbox_max, I.t)) {\n            continue;\n        }\n        b++;\n        if(node.z == -1) {\n           for(int i=b; i<e; ++i) {\n              if(i == prev_id) { continue; } // skip latest triangle\n              ivec3 F = get_facet(i);\n              vec3 p1 = decode_vertex(F.x);\n              vec3 p2 = decode_vertex(F.y);\n              vec3 p3 = decode_vertex(F.z);\n              bool t_isect = triangle(R, p1, p2, p3, I);\n              if(t_isect) { I.id = i; }\n              result = result || t_isect;\n          }\n        } else {\n          int coord = node.z & 3;\n          int nb    = node.z >> 2; \n          int m     = b + nb;  \n          if(R.Dir[coord] < 0.0) {\n             stack_push(b,m);\n             stack_push(m,e);                  \n          } else {\n             stack_push(m,e);\n             stack_push(b,m); // positive -> process this child first                                    \n          } \n        }\n    }\n    if(result) {\n        I.N = normalize(I.N);\n    }\n    return result;\n}  \n\n// Modifies ray and intersection, returns total length of traversed matter.\nfloat multi_refract(inout Ray R, inout Intersection I) {\n    float result = 0.0;\n    for(int i=0; i<10; ++i) {\n        if(dot(R.Dir,I.N) > 0.0) { // Exiting matter\n            result += I.t;\n            vec3 old_dir = R.Dir;\n            I.N = -I.N;\n            R = refract_ray(R, I, refract_index, 1.0);\n            if(R.Dir == vec3(0)) { \n               //R.Dir = reflect(old_dir, I.N); // total reflection (what I should do I think) \n               R.Dir = old_dir; // I do that instead (not correct but looks better).\n            }\n        } else { // Entering matter\n            R = refract_ray(R, I, 1.0, refract_index);\n            R.Dir = normalize(R.Dir); // Needs to be unit, so that on exit, I.t is distance\n        }\n        I.t = FARAWAY;\n        if(!mesh_AABB(R, I)) { break; }  \n    }\n    return result;\n}\n\nvec3 sky(in Ray R) {\n#ifdef WHITE_BACKGROUND\n   return vec3(1);\n#else\n   return vec3(textureLod(iChannel1, R.Dir, 0.0));\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float alpha = iTime + iMouse.x/100.0;\n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(20.0*c, 20.0*s, 1.5),\n       vec3(0.0, 0.0, 0.0),\n       30.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n   mesh_AABB(R, I);\n \n   if(I.t == FARAWAY) {\n      fragColor.xyz = sky(R); \n    } else { \n      fragColor.xyz = vec3(0); \n       \n      float fresnel = 1.0 + dot(R.Dir,I.N) / length(R.Dir);\n      fresnel = clamp(fresnel, 0.0, 1.0); \n      fragColor.xyz += reflect_coeff * fresnel * sky(reflect_ray(R,I)); \n       \n      float l = multi_refract(R,I);\n      float d = exp(-l * extinction);\n      fragColor.xyz += mix(core_color, sky(R), d);\n    }\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Mesh data description: bbox and number of facets\n\nconst vec3 bbox_min = 10.0*vec3(-0.253035,-0.340497,-0.346693);\nconst vec3 bbox_max = 10.0*vec3(0.252403,0.340004,0.345965);\nconst int AABB_data_size = 2133;\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n// (implementation of get_data(), do not call directly)\nint get_data_raw(in sampler2D channel, in int width, in int index) {\n   vec4 col = 255.0*vec4(texelFetch(channel, ivec2(index%width,index/width), 0));\n   return (int(col.r)      ) | \n          (int(col.g) << 8 ) |\n          (int(col.b) << 16) |\n          (int(col.a) << 24) ;\n}\n\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n//  offset: one of RESOLUTION_OFFSET, MESH_DATA_OFFSET\n//  index: the index of the data to be read\n#define get_data(offset, index) \\\n    get_data_raw(iChannel0, int(iChannelResolution[0].x), (offset)+(index))\n\n// In BufferA, data is organized in sections\n// RESOLUTION_OFFSET: 2 integers (previous width and height, used to detect win resize)\n// MESH_DATA_OFFSET: facets_data_size * 3 integers. Each integer encores the x,y,z \n//                    coordinates of a vertex (x:10 bits, y:10 bits, z:10 bits). \nconst int RESOLUTION_OFFSET=0;\nconst int MESH_DATA_OFFSET=2;\n", "buffer_a_code": "// mesh compiler and references here: https://www.shadertoy.com/view/tl3XRN\n\n// unfortunately, this pragma is ignored by most WebGL implementations \n// (and compilation takes ages...)\n\n#pragma optimize(off)\n \nivec3 AABB_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c) case i: r=ivec3(a,b,c); break;\n  ivec3 r;\n  switch(i) {\n    R(0x0000,0x00000000,0x3fffffff,0x00001565)    R(0x0001,0x00000000,0x3ff837ff,0x000009ca)    R(0x0002,0x00009c3b,0x20682b85,0x000005b6)    R(0x0003,0x00024c5e,0x0e182b80,0x00000258)    R(0x0004,0x0002585e,0x0db81207,0x0000014c)    R(0x0005,0x00744c5e,0x0d38117d,0x000000ee)    R(0x0006,0x00744c8a,0x0708117d,0xffffffff)    R(0x0007,0x01045d30,0x00a4810f,0x00844d5c)    R(0x0008,0x02145d54,0x02247105,0x01045d30)    R(0x0009,0x02247105,0x011490df,0x01045d30)\n    R(0x000a,0x04349d33,0x02247105,0x02145d54)    R(0x000b,0x011490df,0x00a4810f,0x01045d30)    R(0x000c,0x00a4810f,0x0074a554,0x00844d5c)    R(0x000d,0x0254c4cc,0x011490df,0x02247105)    R(0x000e,0x0474dcee,0x02247105,0x04349d33)    R(0x000f,0x011490df,0x00c4f4ca,0x00a4810f)    R(0x0010,0x0254c4cc,0x02247105,0x0474dcee)    R(0x0011,0x0094f505,0x0074a554,0x00a4810f)    R(0x0012,0x0645293d,0x04349d33,0x04f49d6c)    R(0x0013,0x00c4f4ca,0x0094f505,0x00a4810f)\n    R(0x0014,0x0254c4cc,0x01451cb3,0x011490df)    R(0x0015,0x0645293d,0x0474dcee,0x04349d33)    R(0x0016,0x01451cb3,0x00c4f4ca,0x011490df)    R(0x0017,0x0155455f,0x0074a554,0x0094f505)    R(0x0018,0x05256cc4,0x0254c4cc,0x0474dcee)    R(0x0019,0x02e558ae,0x01451cb3,0x0254c4cc)    R(0x001a,0x05256cc4,0x02e558ae,0x0254c4cc)    R(0x001b,0x069590fa,0x0474dcee,0x0645293d)    R(0x001c,0x00b5b8ce,0x0094f505,0x00c4f4ca)    R(0x001d,0x0155455f,0x0094f505,0x01659919)\n    R(0x001e,0x0105c8ac,0x00c4f4ca,0x01451cb3)    R(0x001f,0x05256cc4,0x0474dcee,0x069590fa)    R(0x0020,0x01659919,0x0094f505,0x00b5b8ce)    R(0x0021,0x0215f0a5,0x01451cb3,0x02e558ae)    R(0x0022,0x00b5b8ce,0x00c4f4ca,0x0105c8ac)    R(0x0023,0x0215f0a5,0x0105c8ac,0x01451cb3)    R(0x0024,0x05061cad,0x02e558ae,0x05256cc4)    R(0x0025,0x02961150,0x0155455f,0x01659919)    R(0x0026,0x06c60cce,0x05256cc4,0x069590fa)    R(0x0027,0x05061cad,0x0215f0a5,0x02e558ae)\n    R(0x0028,0x06c60cce,0x05061cad,0x05256cc4)    R(0x0029,0x01f65d02,0x01659919,0x00b5b8ce)    R(0x002a,0x02961150,0x01659919,0x01f65d02)    R(0x002b,0x0116bcb3,0x00b5b8ce,0x0105c8ac)    R(0x002c,0x01c6d0a4,0x0105c8ac,0x0215f0a5)    R(0x002d,0x07067cab,0x05061cad,0x06c60cce)    R(0x002e,0x01f65d02,0x00b5b8ce,0x00e6a4d2)    R(0x002f,0x0466c8a2,0x0215f0a5,0x05061cad)    R(0x0030,0x00e6a4d2,0x00b5b8ce,0x0116bcb3)    R(0x0031,0x0116bcb3,0x0105c8ac,0x01c6d0a4)\n    R(0x0032,0x07067cab,0x0466c8a2,0x05061cad)    R(0x0033,0x02c70138,0x02961150,0x01f65d02)    R(0x0034,0x0466c8a2,0x01c6d0a4,0x0215f0a5)    R(0x0035,0x01f65d02,0x00e6a4d2,0x02074cf4)    R(0x0036,0x06c73c8a,0x0466c8a2,0x07067cab)    R(0x0037,0x02c70138,0x01f65d02,0x02074cf4)    R(0x0038,0x00e6a4d2,0x0116bcb3,0x011790c3)    R(0x0039,0x0387a49f,0x01c6d0a4,0x0466c8a2)    R(0x003a,0x0177cca9,0x0116bcb3,0x01c6d0a4)    R(0x003b,0x02074cf4,0x00e6a4d2,0x011790c3)\n    R(0x003c,0x06c73c8a,0x0387a49f,0x0466c8a2)    R(0x003d,0x011790c3,0x0116bcb3,0x0177cca9)    R(0x003e,0x0177cca9,0x01c6d0a4,0x0387a49f)    R(0x003f,0x02c70138,0x02074cf4,0x0308112b)    R(0x0040,0x02b7a17d,0x02c70138,0x0308112b)    R(0x0041,0x0645285e,0x0d381161,0xffffffff)    R(0x0042,0x0a77705e,0x0976c07f,0x0d16a85e)    R(0x0043,0x0a77705e,0x0688107d,0x06c73c8a)    R(0x0044,0x0a77705e,0x06c73c8a,0x0976c07f)    R(0x0045,0x0d16a85e,0x0976c07f,0x0b563893)\n    R(0x0046,0x0976c07f,0x06c73c8a,0x07067cab)    R(0x0047,0x0b563893,0x0976c07f,0x07067cab)    R(0x0048,0x0b563893,0x07067cab,0x08e618c7)    R(0x0049,0x0d35d0bc,0x0b563893,0x08e618c7)    R(0x004a,0x08e618c7,0x07067cab,0x06c60cce)    R(0x004b,0x0d35d0bc,0x08e618c7,0x0b15dcfc)    R(0x004c,0x08e618c7,0x06c60cce,0x07f5f0ff)    R(0x004d,0x08e618c7,0x07f5f0ff,0x0b15dcfc)    R(0x004e,0x06c60cce,0x069590fa,0x07f5f0ff)    R(0x004f,0x0b15dcfc,0x07f5f0ff,0x0935e938)\n    R(0x0050,0x07f5f0ff,0x069590fa,0x07b5d141)    R(0x0051,0x0b15dcfc,0x0935e938,0x0c05b93b)    R(0x0052,0x07f5f0ff,0x07b5d141,0x0935e938)    R(0x0053,0x07b5d141,0x069590fa,0x0645293d)    R(0x0054,0x0c05b93b,0x0935e938,0x0935c15a)    R(0x0055,0x0935e938,0x07b5d141,0x0935c15a)    R(0x0056,0x07655161,0x07b5d141,0x0645293d)    R(0x0057,0x0c05b93b,0x0935c15a,0x0be55d55)    R(0x0058,0x00025930,0x0db7a207,0xffffffff)    R(0x0059,0x0002e604,0x002305bc,0x0013bddd)\n    R(0x005a,0x00326df8,0x002305bc,0x0002e604)    R(0x005b,0x0013bddd,0x002305bc,0x0043f192)    R(0x005c,0x00348604,0x0013bddd,0x0054c9ab)    R(0x005d,0x0054c9ab,0x0013bddd,0x0043f192)    R(0x005e,0x0072b5be,0x002305bc,0x00326df8)    R(0x005f,0x0043f192,0x002305bc,0x00738d8a)    R(0x0060,0x006591e2,0x00348604,0x0054c9ab)    R(0x0061,0x0054c9ab,0x0043f192,0x0074a554)    R(0x0062,0x00738d8a,0x002305bc,0x0072b5be)    R(0x0063,0x0074a554,0x0043f192,0x00844d5c)\n    R(0x0064,0x00844d5c,0x0043f192,0x00738d8a)    R(0x0065,0x00b259f3,0x0072b5be,0x00326df8)    R(0x0066,0x00c42168,0x00844d5c,0x00738d8a)    R(0x0067,0x00e34d96,0x00738d8a,0x0072b5be)    R(0x0068,0x00c42168,0x00738d8a,0x00e34d96)    R(0x0069,0x0054c9ab,0x0074a554,0x0155455f)    R(0x006a,0x01045d30,0x00844d5c,0x00c42168)    R(0x006b,0x006591e2,0x0054c9ab,0x01b5b1a0)    R(0x006c,0x0182a1c6,0x0072b5be,0x00b259f3)    R(0x006d,0x00e34d96,0x0072b5be,0x0182a1c6)\n    R(0x006e,0x01b5b1a0,0x0054c9ab,0x0155455f)    R(0x006f,0x015669e1,0x006591e2,0x01b5b1a0)    R(0x0070,0x02145d54,0x01045d30,0x00c42168)    R(0x0071,0x02540978,0x00c42168,0x00e34d96)    R(0x0072,0x02a281f7,0x0182a1c6,0x00b259f3)    R(0x0073,0x02b345a5,0x00e34d96,0x0182a1c6)    R(0x0074,0x02145d54,0x00c42168,0x02540978)    R(0x0075,0x015669e1,0x01b5b1a0,0x02869d92)    R(0x0076,0x01b5b1a0,0x0155455f,0x02961150)    R(0x0077,0x02540978,0x00e34d96,0x02b345a5)\n    R(0x0078,0x026745d6,0x015669e1,0x02869d92)    R(0x0079,0x02869d92,0x01b5b1a0,0x02961150)    R(0x007a,0x026745d6,0x02869d92,0x02b7a17d)    R(0x007b,0x02869d92,0x02961150,0x02c70138)    R(0x007c,0x02b7a17d,0x02869d92,0x02c70138)    R(0x007d,0x042315d0,0x0182a1c6,0x02a281f7)    R(0x007e,0x02b345a5,0x0182a1c6,0x042315d0)    R(0x007f,0x04f49d6c,0x02145d54,0x02540978)    R(0x0080,0x0553e1a3,0x02540978,0x02b345a5)    R(0x0081,0x04f49d6c,0x04349d33,0x02145d54)\n    R(0x0082,0x05132207,0x042315d0,0x02a281f7)    R(0x0083,0x0553e1a3,0x02b345a5,0x042315d0)    R(0x0084,0x04f49d6c,0x02540978,0x0553e1a3)    R(0x0085,0x0653a5dc,0x042315d0,0x05132207)    R(0x0086,0x0553e1a3,0x042315d0,0x0653a5dc)    R(0x0087,0x07447d81,0x04f49d6c,0x0553e1a3)    R(0x0088,0x07655161,0x0645293d,0x04f49d6c)    R(0x0089,0x07655161,0x04f49d6c,0x07447d81)    R(0x008a,0x0833edae,0x0553e1a3,0x0653a5dc)    R(0x008b,0x07447d81,0x0553e1a3,0x0833edae)\n    R(0x008c,0x0833edae,0x0653a5dc,0x0893bde6)    R(0x008d,0x09750169,0x07655161,0x07447d81)    R(0x008e,0x0935c15a,0x07b5d141,0x07655161)    R(0x008f,0x09750169,0x0935c15a,0x07655161)    R(0x0090,0x0aa43d7f,0x07447d81,0x0833edae)    R(0x0091,0x09750169,0x07447d81,0x0aa43d7f)    R(0x0092,0x0b13b9b9,0x0833edae,0x0893bde6)    R(0x0093,0x0aa43d7f,0x0833edae,0x0b13b9b9)    R(0x0094,0x0b13b9b9,0x0893bde6,0x0a53a9f8)    R(0x0095,0x0be55d55,0x0935c15a,0x09750169)\n    R(0x0096,0x0db49156,0x09750169,0x0aa43d7f)    R(0x0097,0x0c6321cd,0x0b13b9b9,0x0a53a9f8)    R(0x0098,0x0db49156,0x0be55d55,0x09750169)    R(0x0099,0x0d73c589,0x0aa43d7f,0x0b13b9b9)    R(0x009a,0x00024dcd,0x0e182b80,0x000001b0)    R(0x009b,0x00024dcd,0x0d381af2,0x000000ee)    R(0x009c,0x000255d6,0x03681af0,0xffffffff)    R(0x009d,0x00b259f3,0x00925e33,0x01725627)    R(0x009e,0x00b259f3,0x00326df8,0x00925e33)    R(0x009f,0x02a281f7,0x00b259f3,0x01725627)\n    R(0x00a0,0x01725627,0x00925e33,0x01828252)    R(0x00a1,0x02a281f7,0x01725627,0x03629630)    R(0x00a2,0x03629630,0x01725627,0x01828252)    R(0x00a3,0x00925e33,0x00326df8,0x0022b243)    R(0x00a4,0x01828252,0x00925e33,0x0092ce67)    R(0x00a5,0x0092ce67,0x00925e33,0x0022b243)    R(0x00a6,0x03629630,0x01828252,0x0332ee5a)    R(0x00a7,0x00326df8,0x0002e604,0x0022b243)    R(0x00a8,0x01533e81,0x01828252,0x0092ce67)    R(0x00a9,0x0332ee5a,0x01828252,0x01533e81)\n    R(0x00aa,0x0092ce67,0x0022b243,0x00336a7d)    R(0x00ab,0x0022b243,0x0002e604,0x00039e40)    R(0x00ac,0x01533e81,0x0092ce67,0x00839a97)    R(0x00ad,0x00336a7d,0x0022b243,0x00039e40)    R(0x00ae,0x00839a97,0x0092ce67,0x00336a7d)    R(0x00af,0x0323be7f,0x0332ee5a,0x01533e81)    R(0x00b0,0x00039e40,0x0002e604,0x0013bddd)    R(0x00b1,0x0143caa0,0x01533e81,0x00839a97)    R(0x00b2,0x0323be7f,0x01533e81,0x0143caa0)    R(0x00b3,0x00839a97,0x00336a7d,0x0043c6bc)\n    R(0x00b4,0x00336a7d,0x00039e40,0x00141296)    R(0x00b5,0x00b3c2b0,0x00839a97,0x0043c6bc)    R(0x00b6,0x00b3c2b0,0x0043c6bc,0x00c39eec)    R(0x00b7,0x0143caa0,0x00839a97,0x00b3c2b0)    R(0x00b8,0x0213cacd,0x00b3c2b0,0x00c39eec)    R(0x00b9,0x0043c6bc,0x00336a7d,0x00141296)    R(0x00ba,0x0143caa0,0x00b3c2b0,0x0213cacd)    R(0x00bb,0x0304269f,0x0323be7f,0x0143caa0)    R(0x00bc,0x0304269f,0x0143caa0,0x0213cacd)    R(0x00bd,0x00039e40,0x0013bddd,0x00348604)\n    R(0x00be,0x0043c6bc,0x00141296,0x001422f0)    R(0x00bf,0x00141296,0x00039e40,0x00549e59)    R(0x00c0,0x00549e59,0x00039e40,0x00348604)    R(0x00c1,0x001422f0,0x00141296,0x0014f2b6)    R(0x00c2,0x0014f2b6,0x00141296,0x00549e59)    R(0x00c3,0x00549e59,0x00348604,0x00e5561e)    R(0x00c4,0x0014f2b6,0x00549e59,0x00b58e72)    R(0x00c5,0x00e5561e,0x00348604,0x006591e2)    R(0x00c6,0x00b58e72,0x00549e59,0x00e5561e)    R(0x00c7,0x0055eecd,0x0014f2b6,0x00b58e72)\n    R(0x00c8,0x00b58e72,0x00e5561e,0x00c62e2a)    R(0x00c9,0x00c62e2a,0x00e5561e,0x006591e2)    R(0x00ca,0x0055eecd,0x00b58e72,0x00a67a74)    R(0x00cb,0x00c62e2a,0x006591e2,0x015669e1)    R(0x00cc,0x00a67a74,0x00b58e72,0x00c62e2a)    R(0x00cd,0x0106eeb8,0x0055eecd,0x00a67a74)    R(0x00ce,0x0146f227,0x00c62e2a,0x015669e1)    R(0x00cf,0x00a67a74,0x00c62e2a,0x0146f227)    R(0x00d0,0x0146f227,0x015669e1,0x026745d6)    R(0x00d1,0x0106eeb8,0x00a67a74,0x01c74e72)\n    R(0x00d2,0x01c74e72,0x00a67a74,0x0146f227)    R(0x00d3,0x0257d221,0x0146f227,0x026745d6)    R(0x00d4,0x01c74e72,0x0146f227,0x0257d221)    R(0x00d5,0x02681ab8,0x0106eeb8,0x01c74e72)    R(0x00d6,0x018772eb,0x0106eeb8,0x02681ab8)    R(0x00d7,0x02124dcd,0x0d34e2f2,0xffffffff)    R(0x00d8,0x0ba29a50,0x0d324e07,0x0b033214)    R(0x00d9,0x05132207,0x02a281f7,0x03629630)    R(0x00da,0x0b033214,0x0d324e07,0x0c6321cd)    R(0x00db,0x05234a37,0x03629630,0x0332ee5a)\n    R(0x00dc,0x05132207,0x03629630,0x05234a37)    R(0x00dd,0x0ba2e2a3,0x0ba29a50,0x0a538667)    R(0x00de,0x0a538667,0x0ba29a50,0x0b033214)    R(0x00df,0x0d131ef2,0x0ba2e2a3,0x0b03cab8)    R(0x00e0,0x05234a37,0x0332ee5a,0x0323be7f)    R(0x00e1,0x0b033214,0x0c6321cd,0x0a53a9f8)    R(0x00e2,0x06d3ba13,0x05132207,0x05234a37)    R(0x00e3,0x0b03cab8,0x0ba2e2a3,0x0a538667)    R(0x00e4,0x06d3ba13,0x0653a5dc,0x05132207)    R(0x00e5,0x0a538667,0x0b033214,0x09d3ea36)\n    R(0x00e6,0x0b033214,0x0a53a9f8,0x09d3ea36)    R(0x00e7,0x06d3ba13,0x05234a37,0x0593fa4c)    R(0x00e8,0x0593fa4c,0x05234a37,0x0323be7f)    R(0x00e9,0x0893bde6,0x0653a5dc,0x06d3ba13)    R(0x00ea,0x0a53a9f8,0x0893bde6,0x08c3de1b)    R(0x00eb,0x08c3de1b,0x0893bde6,0x06d3ba13)    R(0x00ec,0x09d3ea36,0x0a53a9f8,0x08c3de1b)    R(0x00ed,0x0b03cab8,0x0a538667,0x09b46e81)    R(0x00ee,0x08c3de1b,0x06d3ba13,0x07444245)    R(0x00ef,0x0a538667,0x09d3ea36,0x09b46e81)\n    R(0x00f0,0x07444245,0x06d3ba13,0x0593fa4c)    R(0x00f1,0x04843eda,0x0304269f,0x0213cacd)    R(0x00f2,0x09d3ea36,0x08c3de1b,0x08d46a4f)    R(0x00f3,0x0593fa4c,0x0323be7f,0x04f48a76)    R(0x00f4,0x04f48a76,0x0323be7f,0x0304269f)    R(0x00f5,0x08d46a4f,0x08c3de1b,0x07444245)    R(0x00f6,0x09b46e81,0x09d3ea36,0x08d46a4f)    R(0x00f7,0x07444245,0x0593fa4c,0x04f48a76)    R(0x00f8,0x0b03cab8,0x09b46e81,0x0b24a2d5)    R(0x00f9,0x0594baa1,0x0304269f,0x04843eda)\n    R(0x00fa,0x0594baa1,0x04f48a76,0x0304269f)    R(0x00fb,0x08d46a4f,0x07444245,0x0704ce6f)    R(0x00fc,0x07444245,0x04f48a76,0x0704ce6f)    R(0x00fd,0x09b46e81,0x08d46a4f,0x08d4c686)    R(0x00fe,0x0694e2e7,0x0594baa1,0x04843eda)    R(0x00ff,0x0b24a2d5,0x09b46e81,0x09e4daca)    R(0x0100,0x08d46a4f,0x0704ce6f,0x08d4c686)    R(0x0101,0x09b46e81,0x08d4c686,0x09e4daca)    R(0x0102,0x0704ce6f,0x04f48a76,0x0594baa1)    R(0x0103,0x07c4dab4,0x0704ce6f,0x0594baa1)\n    R(0x0104,0x08d4c686,0x0704ce6f,0x07c4dab4)    R(0x0105,0x07c4dab4,0x0594baa1,0x0694e2e7)    R(0x0106,0x09e4daca,0x08d4c686,0x07c4dab4)    R(0x0107,0x00139eb4,0x0e182b80,0x00000132)    R(0x0108,0x00139eb6,0x07082b80,0xffffffff)    R(0x0109,0x01d3ab12,0x00c39eec,0x00c3bb32)    R(0x010a,0x0213cacd,0x00c39eec,0x01d3ab12)    R(0x010b,0x00c39eec,0x0043c317,0x00c3bb32)    R(0x010c,0x00c39eec,0x0043c6bc,0x0043c317)    R(0x010d,0x01d3ab12,0x00c3bb32,0x0213f74e)\n    R(0x010e,0x03e3eb1c,0x0213cacd,0x01d3ab12)    R(0x010f,0x03e3eb1c,0x01d3ab12,0x0213f74e)    R(0x0110,0x00c3bb32,0x0043c317,0x00841b5b)    R(0x0111,0x0043c317,0x0043c6bc,0x001422f0)    R(0x0112,0x0213f74e,0x00c3bb32,0x00841b5b)    R(0x0113,0x04843eda,0x0213cacd,0x03e3eb1c)    R(0x0114,0x00841b5b,0x0043c317,0x00244b48)    R(0x0115,0x00244b48,0x0043c317,0x001422f0)    R(0x0116,0x03e3eb1c,0x0213f74e,0x04344f53)    R(0x0117,0x0213f74e,0x00841b5b,0x01846f73)\n    R(0x0118,0x04344f53,0x0213f74e,0x01846f73)    R(0x0119,0x05a4931b,0x04843eda,0x03e3eb1c)    R(0x011a,0x05a4931b,0x03e3eb1c,0x04344f53)    R(0x011b,0x0094bf78,0x00841b5b,0x00244b48)    R(0x011c,0x01846f73,0x00841b5b,0x0094bf78)    R(0x011d,0x00244b48,0x001422f0,0x00350311)    R(0x011e,0x04344f53,0x01846f73,0x0364c374)    R(0x011f,0x0694e2e7,0x04843eda,0x05a4931b)    R(0x0120,0x05a4931b,0x04344f53,0x0574f745)    R(0x0121,0x0574f745,0x04344f53,0x0364c374)\n    R(0x0122,0x00350311,0x001422f0,0x0014f2b6)    R(0x0123,0x0094bf78,0x00244b48,0x00451b60)    R(0x0124,0x01b50b80,0x01846f73,0x0094bf78)    R(0x0125,0x0364c374,0x01846f73,0x01b50b80)    R(0x0126,0x00451b60,0x00244b48,0x00350311)    R(0x0127,0x06d54312,0x0694e2e7,0x05a4931b)    R(0x0128,0x06d54312,0x05a4931b,0x0574f745)    R(0x0129,0x0574f745,0x0364c374,0x03e56764)    R(0x012a,0x03e56764,0x0364c374,0x01b50b80)    R(0x012b,0x01b50b80,0x0094bf78,0x00c59f68)\n    R(0x012c,0x00c59f68,0x0094bf78,0x00451b60)    R(0x012d,0x06d54312,0x0574f745,0x05e5a72f)    R(0x012e,0x00350311,0x0014f2b6,0x0055eecd)    R(0x012f,0x00451b60,0x00350311,0x0055d333)    R(0x0130,0x05e5a72f,0x0574f745,0x03e56764)    R(0x0131,0x03e56764,0x01b50b80,0x01f5b368)    R(0x0132,0x01f5b368,0x01b50b80,0x00c59f68)    R(0x0133,0x00c59f68,0x00451b60,0x0055d333)    R(0x0134,0x0055d333,0x00350311,0x0055eecd)    R(0x0135,0x05e5a72f,0x03e56764,0x03d6433d)\n    R(0x0136,0x03d6433d,0x03e56764,0x01f5b368)    R(0x0137,0x01f5b368,0x00c59f68,0x01766344)    R(0x0138,0x00c59f68,0x0055d333,0x00b6673b)    R(0x0139,0x07063f23,0x05e5a72f,0x03d6433d)    R(0x013a,0x03d6433d,0x01f5b368,0x01766344)    R(0x013b,0x0055d333,0x0055eecd,0x0076a30b)    R(0x013c,0x01766344,0x00c59f68,0x00b6673b)    R(0x013d,0x00b6673b,0x0055d333,0x0076a30b)    R(0x013e,0x03d6433d,0x01766344,0x02d6af35)    R(0x013f,0x07063f23,0x03d6433d,0x0606df18)\n    R(0x0140,0x0076a30b,0x0055eecd,0x0106eeb8)    R(0x0141,0x01766344,0x00b6673b,0x0136c73c)    R(0x0142,0x03d6433d,0x02d6af35,0x0606df18)    R(0x0143,0x01766344,0x0136c73c,0x02d6af35)    R(0x0144,0x00b6673b,0x0076a30b,0x00b73344)    R(0x0145,0x0136c73c,0x00b6673b,0x00b73344)    R(0x0146,0x0606df18,0x02d6af35,0x04b71f3b)    R(0x0147,0x02d6af35,0x0136c73c,0x02973757)    R(0x0148,0x02d6af35,0x02973757,0x04b71f3b)    R(0x0149,0x018772eb,0x0076a30b,0x0106eeb8)\n    R(0x014a,0x00b73344,0x0076a30b,0x00977f28)    R(0x014b,0x00b73344,0x01476b60,0x0136c73c)    R(0x014c,0x0136c73c,0x01476b60,0x02973757)    R(0x014d,0x00977f28,0x0076a30b,0x018772eb)    R(0x014e,0x0606df18,0x04b71f3b,0x06e7ab22)    R(0x014f,0x04b71f3b,0x02973757,0x0457db66)    R(0x0150,0x02973757,0x01476b60,0x0227f77a)    R(0x0151,0x06e7ab22,0x04b71f3b,0x0457db66)    R(0x0152,0x00f80f71,0x01476b60,0x00b73344)    R(0x0153,0x00a82b50,0x00b73344,0x00977f28)\n    R(0x0154,0x05e3cab4,0x0e17df39,0xffffffff)    R(0x0155,0x0ca41308,0x0b03cab8,0x0b24a2d5)    R(0x0156,0x0ca41308,0x0b24a2d5,0x0cc4ff16)    R(0x0157,0x0b24a2d5,0x09e4daca,0x0ae53701)    R(0x0158,0x0cc4ff16,0x0b24a2d5,0x0ae53701)    R(0x0159,0x09e4daca,0x07c4dab4,0x087522f3)    R(0x015a,0x087522f3,0x07c4dab4,0x0694e2e7)    R(0x015b,0x0ae53701,0x09e4daca,0x087522f3)    R(0x015c,0x087522f3,0x0694e2e7,0x06d54312)    R(0x015d,0x0cc4ff16,0x0ae53701,0x0c45c328)\n    R(0x015e,0x0ae53701,0x087522f3,0x0895af1c)    R(0x015f,0x0895af1c,0x087522f3,0x06d54312)    R(0x0160,0x0895af1c,0x06d54312,0x05e5a72f)    R(0x0161,0x0c45c328,0x0ae53701,0x0895af1c)    R(0x0162,0x0895af1c,0x05e5a72f,0x07063f23)    R(0x0163,0x0c45c328,0x0895af1c,0x0a26572a)    R(0x0164,0x0a26572a,0x0895af1c,0x07063f23)    R(0x0165,0x0e165339,0x0c45c328,0x0a26572a)    R(0x0166,0x0a26572a,0x07063f23,0x0886ff07)    R(0x0167,0x0e165339,0x0a26572a,0x0bd70717)\n    R(0x0168,0x0886ff07,0x07063f23,0x0606df18)    R(0x0169,0x0bd70717,0x0a26572a,0x0886ff07)    R(0x016a,0x0886ff07,0x0606df18,0x08077af7)    R(0x016b,0x0bd70717,0x0886ff07,0x0a478af3)    R(0x016c,0x08077af7,0x0606df18,0x06e7ab22)    R(0x016d,0x0a478af3,0x0886ff07,0x08077af7)    R(0x016e,0x0df77f07,0x0bd70717,0x0a478af3)    R(0x016f,0x0df77f07,0x0a478af3,0x0c37df08)    R(0x0170,0x0a709c3b,0x20681b85,0x00000211)    R(0x0171,0x0b009d26,0x1fc49385,0x000000e8)\n    R(0x0172,0x0b109d26,0x1f74927a,0xffffffff)    R(0x0173,0x1b00b63d,0x17a0c60b,0x17709e5f)    R(0x0174,0x17709e5f,0x1420da28,0x14b0c27a)    R(0x0175,0x17709e5f,0x17a0c60b,0x1420da28)    R(0x0176,0x1b6109ee,0x17a0c60b,0x1b00b63d)    R(0x0177,0x1e710624,0x1b00b63d,0x1e20d26c)    R(0x0178,0x14b0c27a,0x1420da28,0x11612259)    R(0x0179,0x17a0c60b,0x14611ddf,0x1420da28)    R(0x017a,0x1b6109ee,0x1b00b63d,0x1e710624)    R(0x017b,0x180135be,0x17a0c60b,0x1b6109ee)\n    R(0x017c,0x180135be,0x14611ddf,0x17a0c60b)    R(0x017d,0x1420da28,0x14611ddf,0x10816a04)    R(0x017e,0x11612259,0x1420da28,0x10816a04)    R(0x017f,0x1f5185e3,0x1b6109ee,0x1e710624)    R(0x0180,0x1bc19dae,0x180135be,0x1b6109ee)    R(0x0181,0x14c19197,0x14611ddf,0x180135be)    R(0x0182,0x14611ddf,0x11c19dbd,0x10816a04)    R(0x0183,0x1bc19dae,0x1b6109ee,0x1f5185e3)    R(0x0184,0x14c19197,0x11c19dbd,0x14611ddf)    R(0x0185,0x11612259,0x10816a04,0x0e81c645)\n    R(0x0186,0x1831e185,0x14c19197,0x180135be)    R(0x0187,0x1831e185,0x180135be,0x1bc19dae)    R(0x0188,0x11c19dbd,0x0f2239c3,0x10816a04)    R(0x0189,0x1f2239a0,0x1bc19dae,0x1f5185e3)    R(0x018a,0x11923581,0x11c19dbd,0x14c19197)    R(0x018b,0x0e81c645,0x10816a04,0x0d324e07)    R(0x018c,0x14c24d67,0x14c19197,0x1831e185)    R(0x018d,0x1bc26974,0x1831e185,0x1bc19dae)    R(0x018e,0x10816a04,0x0f2239c3,0x0d324e07)    R(0x018f,0x11923581,0x0f2239c3,0x11c19dbd)\n    R(0x0190,0x14c24d67,0x11923581,0x14c19197)    R(0x0191,0x1bc26974,0x1bc19dae,0x1f2239a0)    R(0x0192,0x0ba29a50,0x0e81c645,0x0d324e07)    R(0x0193,0x1872c550,0x14c24d67,0x1831e185)    R(0x0194,0x1872c550,0x1831e185,0x1bc26974)    R(0x0195,0x0f02f586,0x0f2239c3,0x11923581)    R(0x0196,0x1202fd55,0x11923581,0x14c24d67)    R(0x0197,0x1ef2f968,0x1bc26974,0x1f2239a0)    R(0x0198,0x0d324e07,0x0f2239c3,0x0c6321cd)    R(0x0199,0x1202fd55,0x0f02f586,0x11923581)\n    R(0x019a,0x15531d3c,0x14c24d67,0x1872c550)    R(0x019b,0x0c6321cd,0x0f2239c3,0x0f02f586)    R(0x019c,0x15531d3c,0x1202fd55,0x14c24d67)    R(0x019d,0x1b93513e,0x1872c550,0x1bc26974)    R(0x019e,0x1b93513e,0x1bc26974,0x1ef2f968)    R(0x019f,0x1823c128,0x15531d3c,0x1872c550)    R(0x01a0,0x1053c958,0x0f02f586,0x1202fd55)    R(0x01a1,0x1823c128,0x1872c550,0x1b93513e)    R(0x01a2,0x0d73c589,0x0c6321cd,0x0f02f586)    R(0x01a3,0x1403e92f,0x1202fd55,0x15531d3c)\n    R(0x01a4,0x1f73c94c,0x1b93513e,0x1ef2f968)    R(0x01a5,0x1053c958,0x0d73c589,0x0f02f586)    R(0x01a6,0x0d73c589,0x0b13b9b9,0x0c6321cd)    R(0x01a7,0x1403e92f,0x1053c958,0x1202fd55)    R(0x01a8,0x1823c128,0x1403e92f,0x15531d3c)    R(0x01a9,0x1c743d26,0x1823c128,0x1b93513e)    R(0x01aa,0x1c743d26,0x1b93513e,0x1f73c94c)    R(0x01ab,0x1053c958,0x0db49156,0x0d73c589)    R(0x01ac,0x0b009e3d,0x1fc48b85,0xffffffff)    R(0x01ad,0x0d622687,0x0e81c645,0x0ba29a50)\n    R(0x01ae,0x1aa0a294,0x1b00b63d,0x17709e5f)    R(0x01af,0x11612259,0x0e81c645,0x1001869c)    R(0x01b0,0x1e20d26c,0x1b00b63d,0x1aa0a294)    R(0x01b1,0x1001869c,0x0e81c645,0x0d622687)    R(0x01b2,0x0ba2e2a3,0x0d622687,0x0ba29a50)    R(0x01b3,0x134112b9,0x14b0c27a,0x11612259)    R(0x01b4,0x1730b6be,0x17709e5f,0x14b0c27a)    R(0x01b5,0x134112b9,0x11612259,0x1001869c)    R(0x01b6,0x1aa0a294,0x17709e5f,0x1730b6be)    R(0x01b7,0x1e00e2b4,0x1e20d26c,0x1aa0a294)\n    R(0x01b8,0x1730b6be,0x14b0c27a,0x134112b9)    R(0x01b9,0x0e4246d3,0x1001869c,0x0d622687)    R(0x01ba,0x0e4246d3,0x0d622687,0x0ba2e2a3)    R(0x01bb,0x1e00e2b4,0x1aa0a294,0x1b40dadd)    R(0x01bc,0x1b40dadd,0x1aa0a294,0x1730b6be)    R(0x01bd,0x134112b9,0x1001869c,0x1151b2ed)    R(0x01be,0x1151b2ed,0x1001869c,0x0e4246d3)    R(0x01bf,0x0d131ef2,0x0e4246d3,0x0ba2e2a3)    R(0x01c0,0x15013f00,0x1730b6be,0x134112b9)    R(0x01c1,0x1e113af6,0x1e00e2b4,0x1b40dadd)\n    R(0x01c2,0x1e113af6,0x1fc0c2e3,0x1e00e2b4)    R(0x01c3,0x1b40dadd,0x1730b6be,0x18310304)    R(0x01c4,0x15013f00,0x134112b9,0x1151b2ed)    R(0x01c5,0x0ca41308,0x0d131ef2,0x0b03cab8)    R(0x01c6,0x18310304,0x1730b6be,0x15013f00)    R(0x01c7,0x0fd27f1d,0x1151b2ed,0x0e4246d3)    R(0x01c8,0x0fd27f1d,0x0e4246d3,0x0d131ef2)    R(0x01c9,0x1e113af6,0x1b40dadd,0x1b415f1e)    R(0x01ca,0x1b415f1e,0x1b40dadd,0x18310304)    R(0x01cb,0x15013f00,0x1151b2ed,0x1311e730)\n    R(0x01cc,0x0ee36f39,0x0d131ef2,0x0ca41308)    R(0x01cd,0x1311e730,0x1151b2ed,0x0fd27f1d)    R(0x01ce,0x1741b33b,0x18310304,0x15013f00)    R(0x01cf,0x1db1d731,0x1e113af6,0x1b415f1e)    R(0x01d0,0x0ee36f39,0x0fd27f1d,0x0d131ef2)    R(0x01d1,0x1db1d731,0x1f716726,0x1e113af6)    R(0x01d2,0x1b415f1e,0x18310304,0x1741b33b)    R(0x01d3,0x1741b33b,0x15013f00,0x1311e730)    R(0x01d4,0x0ef46b46,0x0ee36f39,0x0ca41308)    R(0x01d5,0x1db1d731,0x1b415f1e,0x1b02234f)\n    R(0x01d6,0x11c2df56,0x1311e730,0x0fd27f1d)    R(0x01d7,0x1e422b4d,0x1f716726,0x1db1d731)    R(0x01d8,0x1b02234f,0x1b415f1e,0x1741b33b)    R(0x01d9,0x11c2df56,0x0fd27f1d,0x0ee36f39)    R(0x01da,0x1741b33b,0x1311e730,0x14b25b5d)    R(0x01db,0x1d72a760,0x1e422b4d,0x1db1d731)    R(0x01dc,0x1d72a760,0x1db1d731,0x1b02234f)    R(0x01dd,0x14b25b5d,0x1311e730,0x11c2df56)    R(0x01de,0x11a3db6b,0x0ee36f39,0x0ef46b46)    R(0x01df,0x11a3db6b,0x11c2df56,0x0ee36f39)\n    R(0x01e0,0x1b02234f,0x1741b33b,0x17c29f70)    R(0x01e1,0x17c29f70,0x1741b33b,0x14b25b5d)    R(0x01e2,0x1d72a760,0x1b02234f,0x1b22fb6e)    R(0x01e3,0x1d72a760,0x1e52a770,0x1e422b4d)    R(0x01e4,0x1e035f60,0x1eb33b64,0x1d72a760)    R(0x01e5,0x1ec43751,0x1e035f60,0x1b83db75)    R(0x01e6,0x1b22fb6e,0x1b02234f,0x17c29f70)    R(0x01e7,0x1e52a770,0x1ef1df71,0x1e422b4d)    R(0x01e8,0x1e035f60,0x1d72a760,0x1b22fb6e)    R(0x01e9,0x14b33f7c,0x14b25b5d,0x11c2df56)\n    R(0x01ea,0x1eb33b64,0x1e52a770,0x1d72a760)    R(0x01eb,0x14b33f7c,0x11c2df56,0x11a3db6b)    R(0x01ec,0x1e035f60,0x1b22fb6e,0x1b83db75)    R(0x01ed,0x17c29f70,0x14b25b5d,0x14b33f7c)    R(0x01ee,0x1b22fb6e,0x17c29f70,0x17d39385)    R(0x01ef,0x1b83db75,0x1b22fb6e,0x17d39385)    R(0x01f0,0x14e42b85,0x14b33f7c,0x11a3db6b)    R(0x01f1,0x17d39385,0x17c29f70,0x14b33f7c)    R(0x01f2,0x1b83db75,0x17d39385,0x18348b83)    R(0x01f3,0x17d39385,0x14b33f7c,0x14e42b85)\n    R(0x01f4,0x18348b83,0x17d39385,0x14e42b85)    R(0x01f5,0x0a73c03b,0x20681b85,0x00000130)    R(0x01f6,0x0a73c03b,0x20681989,0x000000b8)    R(0x01f7,0x0a75403b,0x20681902,0xffffffff)    R(0x01f8,0x0ee72c49,0x0a77705e,0x0d16a85e)    R(0x01f9,0x0d38184b,0x0a77705e,0x0ee72c49)    R(0x01fa,0x0d35d0bc,0x0b15dcfc,0x0f059102)    R(0x01fb,0x0f260079,0x0d16a85e,0x0b563893)    R(0x01fc,0x0f260079,0x0b563893,0x0d35d0bc)    R(0x01fd,0x0ee72c49,0x0d16a85e,0x11065852)\n    R(0x01fe,0x10f58ca7,0x0d35d0bc,0x0f059102)    R(0x01ff,0x11065852,0x0d16a85e,0x0f260079)    R(0x0200,0x10f58ca7,0x0f260079,0x0d35d0bc)    R(0x0201,0x10f58ca7,0x0f059102,0x126558e9)    R(0x0202,0x13270443,0x0ee72c49,0x11065852)    R(0x0203,0x1305bc74,0x0f260079,0x10f58ca7)    R(0x0204,0x1305bc74,0x11065852,0x0f260079)    R(0x0205,0x1197e840,0x0ee72c49,0x13270443)    R(0x0206,0x148568af,0x10f58ca7,0x126558e9)    R(0x0207,0x148568af,0x1305bc74,0x10f58ca7)\n    R(0x0208,0x14e64055,0x11065852,0x1305bc74)    R(0x0209,0x13270443,0x11065852,0x14e64055)    R(0x020a,0x1197e840,0x13270443,0x1537f43b)    R(0x020b,0x148568af,0x126558e9,0x157540f1)    R(0x020c,0x1675bc7e,0x1305bc74,0x148568af)    R(0x020d,0x1675bc7e,0x14e64055,0x1305bc74)    R(0x020e,0x16c70c47,0x13270443,0x14e64055)    R(0x020f,0x1537f43b,0x13270443,0x16c70c47)    R(0x0210,0x176590c8,0x148568af,0x157540f1)    R(0x0211,0x176590c8,0x1675bc7e,0x148568af)\n    R(0x0212,0x18165868,0x14e64055,0x1675bc7e)    R(0x0213,0x16c70c47,0x14e64055,0x18165868)    R(0x0214,0x176590c8,0x157540f1,0x182548f0)    R(0x0215,0x1935fcad,0x1675bc7e,0x176590c8)    R(0x0216,0x1935fcad,0x18165868,0x1675bc7e)    R(0x0217,0x19873c62,0x16c70c47,0x18165868)    R(0x0218,0x1898004d,0x16c70c47,0x19873c62)    R(0x0219,0x1a75e0e3,0x176590c8,0x182548f0)    R(0x021a,0x1a75e0e3,0x1935fcad,0x176590c8)    R(0x021b,0x1a36a893,0x18165868,0x1935fcad)\n    R(0x021c,0x19873c62,0x18165868,0x1a36a893)    R(0x021d,0x1b26a8cc,0x1a36a893,0x1935fcad)    R(0x021e,0x1b26a8cc,0x1935fcad,0x1a75e0e3)    R(0x021f,0x1b67789f,0x19873c62,0x1a36a893)    R(0x0220,0x1b67789f,0x1a36a893,0x1b26a8cc)    R(0x0221,0x1dc664e7,0x1b26a8cc,0x1a75e0e3)    R(0x0222,0x1d175cca,0x1b67789f,0x1b26a8cc)    R(0x0223,0x1d175cca,0x1b26a8cc,0x1dc664e7)    R(0x0224,0x206750ee,0x1d175cca,0x1dc664e7)    R(0x0225,0x0aa3c0e3,0x20066589,0xffffffff)\n    R(0x0226,0x0db49156,0x0aa43d7f,0x0d73c589)    R(0x0227,0x0f059102,0x0b15dcfc,0x0c05b93b)    R(0x0228,0x0f255133,0x0c05b93b,0x0be55d55)    R(0x0229,0x0f255133,0x0be55d55,0x0db49156)    R(0x022a,0x0f059102,0x0c05b93b,0x0f255133)    R(0x022b,0x1184a933,0x0f255133,0x0db49156)    R(0x022c,0x1184a933,0x0db49156,0x1053c958)    R(0x022d,0x12953117,0x0f059102,0x0f255133)    R(0x022e,0x12953117,0x0f255133,0x1184a933)    R(0x022f,0x126558e9,0x0f059102,0x12953117)\n    R(0x0230,0x1403e92f,0x1184a933,0x1053c958)    R(0x0231,0x15b4b514,0x12953117,0x1184a933)    R(0x0232,0x157540f1,0x126558e9,0x12953117)    R(0x0233,0x15b4b514,0x1184a933,0x1403e92f)    R(0x0234,0x157540f1,0x12953117,0x15b4b514)    R(0x0235,0x1823c128,0x15b4b514,0x1403e92f)    R(0x0236,0x182548f0,0x157540f1,0x15b4b514)    R(0x0237,0x182548f0,0x15b4b514,0x19549d0f)    R(0x0238,0x19549d0f,0x15b4b514,0x1823c128)    R(0x0239,0x1c653d08,0x182548f0,0x19549d0f)\n    R(0x023a,0x1c743d26,0x19549d0f,0x1823c128)    R(0x023b,0x1a75e0e3,0x182548f0,0x1c653d08)    R(0x023c,0x1c653d08,0x19549d0f,0x1c743d26)    R(0x023d,0x1dc664e7,0x1a75e0e3,0x1c653d08)    R(0x023e,0x2004bd36,0x1c653d08,0x1c743d26)    R(0x023f,0x1dc664e7,0x1c653d08,0x1f75ad16)    R(0x0240,0x1f75ad16,0x1c653d08,0x2004bd36)    R(0x0241,0x2004bd36,0x1c743d26,0x1f73c94c)    R(0x0242,0x0bd3db03,0x2007db85,0xffffffff)    R(0x0243,0x1ec43751,0x1b83db75,0x1bb4bf69)\n    R(0x0244,0x14e42b85,0x11a3db6b,0x11e4e76a)    R(0x0245,0x1bb4bf69,0x1b83db75,0x18348b83)    R(0x0246,0x11e4e76a,0x11a3db6b,0x0ef46b46)    R(0x0247,0x0ef46b46,0x0ca41308,0x0cc4ff16)    R(0x0248,0x18348b83,0x14e42b85,0x15351b77)    R(0x0249,0x1f752336,0x1ec43751,0x1bb4bf69)    R(0x024a,0x15351b77,0x14e42b85,0x11e4e76a)    R(0x024b,0x11e4e76a,0x0ef46b46,0x0f456b40)    R(0x024c,0x0ef46b46,0x0cc4ff16,0x0f456b40)    R(0x024d,0x1bb4bf69,0x18348b83,0x18a58f66)\n    R(0x024e,0x18a58f66,0x18348b83,0x15351b77)    R(0x024f,0x1f752336,0x1bb4bf69,0x1c458f51)    R(0x0250,0x1c458f51,0x1bb4bf69,0x18a58f66)    R(0x0251,0x15351b77,0x11e4e76a,0x11b5f34f)    R(0x0252,0x0f456b40,0x0cc4ff16,0x0c45c328)    R(0x0253,0x11e4e76a,0x0f456b40,0x11b5f34f)    R(0x0254,0x18a58f66,0x15351b77,0x1515e75c)    R(0x0255,0x1e26372c,0x1f752336,0x1c458f51)    R(0x0256,0x15351b77,0x11b5f34f,0x1515e75c)    R(0x0257,0x1c458f51,0x18a58f66,0x1a765345)\n    R(0x0258,0x0f456b40,0x0c45c328,0x0e165339)    R(0x0259,0x11b5f34f,0x0f456b40,0x0e165339)    R(0x025a,0x18a58f66,0x1515e75c,0x17067749)    R(0x025b,0x1e26372c,0x1c458f51,0x1a765345)    R(0x025c,0x1a765345,0x18a58f66,0x17067749)    R(0x025d,0x1515e75c,0x11b5f34f,0x13a6d33b)    R(0x025e,0x17067749,0x1515e75c,0x13a6d33b)    R(0x025f,0x11b5f34f,0x0e165339,0x10070329)    R(0x0260,0x1e26372c,0x1a765345,0x1c670730)    R(0x0261,0x13a6d33b,0x11b5f34f,0x10070329)\n    R(0x0262,0x1a765345,0x17067749,0x19073345)    R(0x0263,0x20070303,0x1e26372c,0x1c670730)    R(0x0264,0x10070329,0x0e165339,0x0bd70717)    R(0x0265,0x1c670730,0x1a765345,0x19073345)    R(0x0266,0x17067749,0x13a6d33b,0x15f74b37)    R(0x0267,0x19073345,0x17067749,0x15f74b37)    R(0x0268,0x13a6d33b,0x10070329,0x12676323)    R(0x0269,0x15f74b37,0x13a6d33b,0x12676323)    R(0x026a,0x10070329,0x0bd70717,0x0df77f07)    R(0x026b,0x20070303,0x1c670730,0x1e47db1b)\n    R(0x026c,0x12676323,0x10070329,0x0df77f07)    R(0x026d,0x1c670730,0x19073345,0x1a57d737)    R(0x026e,0x19073345,0x15f74b37,0x17c7c342)    R(0x026f,0x15f74b37,0x12676323,0x1507b348)    R(0x0270,0x12676323,0x0df77f07,0x0f97b719)    R(0x0271,0x1e47db1b,0x1c670730,0x1a57d737)    R(0x0272,0x17c7c342,0x15f74b37,0x1507b348)    R(0x0273,0x1a57d737,0x19073345,0x17c7c342)    R(0x0274,0x1d100000,0x3ff837ff,0x0000058e)    R(0x0275,0x1d102cc2,0x313837ff,0x00000278)\n    R(0x0276,0x1d105cc2,0x31383672,0x0000011a)    R(0x0277,0x1d105cc6,0x2888366c,0x00000081)    R(0x0278,0x1e205d36,0x2884c66c,0xffffffff)    R(0x0279,0x2100a255,0x24d05e54,0x2460ba1d)    R(0x027a,0x2460ba1d,0x24d05e54,0x2870b630)    R(0x027b,0x20f11a1a,0x2100a255,0x2460ba1d)    R(0x027c,0x1e20d26c,0x2100a255,0x1e710624)    R(0x027d,0x271139f7,0x2460ba1d,0x2870b630)    R(0x027e,0x1e710624,0x2100a255,0x20f11a1a)    R(0x027f,0x22f179ec,0x20f11a1a,0x2460ba1d)\n    R(0x0280,0x22f179ec,0x2460ba1d,0x271139f7)    R(0x0281,0x1f5185e3,0x1e710624,0x20f11a1a)    R(0x0282,0x1f5185e3,0x20f11a1a,0x22f179ec)    R(0x0283,0x25c1fdd1,0x22f179ec,0x271139f7)    R(0x0284,0x223231c7,0x1f5185e3,0x22f179ec)    R(0x0285,0x223231c7,0x22f179ec,0x25c1fdd1)    R(0x0286,0x1f2239a0,0x1f5185e3,0x223231c7)    R(0x0287,0x24e2ddbe,0x223231c7,0x25c1fdd1)    R(0x0288,0x2242f995,0x1f2239a0,0x223231c7)    R(0x0289,0x24e2ddbe,0x25c1fdd1,0x2882a5cb)\n    R(0x028a,0x2242f995,0x223231c7,0x24e2ddbe)    R(0x028b,0x1ef2f968,0x1f2239a0,0x2242f995)    R(0x028c,0x27538dcc,0x24e2ddbe,0x2882a5cb)    R(0x028d,0x2523a9ad,0x2242f995,0x24e2ddbe)    R(0x028e,0x22b3d970,0x1ef2f968,0x2242f995)    R(0x028f,0x2523a9ad,0x24e2ddbe,0x27538dcc)    R(0x0290,0x22b3d970,0x2242f995,0x2523a9ad)    R(0x0291,0x1f73c94c,0x1ef2f968,0x22b3d970)    R(0x0292,0x27344dd7,0x2523a9ad,0x27538dcc)    R(0x0293,0x25a47d96,0x22b3d970,0x2523a9ad)\n    R(0x0294,0x2004bd36,0x1f73c94c,0x22b3d970)    R(0x0295,0x25a47d96,0x2523a9ad,0x27344dd7)    R(0x0296,0x2334c562,0x22b3d970,0x25a47d96)    R(0x0297,0x2004bd36,0x22b3d970,0x2334c562)    R(0x0298,0x1d144cc6,0x2798366c,0xffffffff)    R(0x0299,0x1f282cc6,0x1d175cca,0x206750ee)    R(0x029a,0x21668518,0x1dc664e7,0x1f75ad16)    R(0x029b,0x206750ee,0x1dc664e7,0x21668518)    R(0x029c,0x2265b145,0x1f75ad16,0x2004bd36)    R(0x029d,0x21668518,0x1f75ad16,0x2265b145)\n    R(0x029e,0x23776126,0x206750ee,0x21668518)    R(0x029f,0x2265b145,0x2004bd36,0x2334c562)    R(0x02a0,0x223834f1,0x206750ee,0x23776126)    R(0x02a1,0x24469160,0x21668518,0x2265b145)    R(0x02a2,0x23776126,0x21668518,0x24469160)    R(0x02a3,0x2265b145,0x2334c562,0x24c58180)    R(0x02a4,0x24469160,0x2265b145,0x24c58180)    R(0x02a5,0x25d7ad64,0x23776126,0x24469160)    R(0x02a6,0x24c58180,0x2334c562,0x25a47d96)    R(0x02a7,0x24469160,0x24c58180,0x25962dab)\n    R(0x02a8,0x262719a3,0x24469160,0x25962dab)    R(0x02a9,0x25d7ad64,0x24469160,0x262719a3)    R(0x02aa,0x25962dab,0x24c58180,0x26a521be)    R(0x02ab,0x24c58180,0x25a47d96,0x26a521be)    R(0x02ac,0x262719a3,0x25962dab,0x2656b9ee)    R(0x02ad,0x2656b9ee,0x25962dab,0x26c5c5f2)    R(0x02ae,0x25962dab,0x26a521be,0x26c5c5f2)    R(0x02af,0x26672241,0x2696462c,0x2646466c)    R(0x02b0,0x26672241,0x2656b9ee,0x2696462c)    R(0x02b1,0x26a521be,0x25a47d96,0x27344dd7)\n    R(0x02b2,0x279815aa,0x25d7ad64,0x262719a3)    R(0x02b3,0x2656b9ee,0x26c5c5f2,0x2696462c)    R(0x02b4,0x274799f5,0x262719a3,0x2656b9ee)    R(0x02b5,0x274799f5,0x2656b9ee,0x26672241)    R(0x02b6,0x2696462c,0x2745664e,0x2646466c)    R(0x02b7,0x2696462c,0x26c5c5f2,0x2745664e)    R(0x02b8,0x279815aa,0x262719a3,0x274799f5)    R(0x02b9,0x26c5c5f2,0x26a521be,0x2794f60b)    R(0x02ba,0x27781e41,0x274799f5,0x26672241)    R(0x02bb,0x26a521be,0x27344dd7,0x2794f60b)\n    R(0x02bc,0x26c5c5f2,0x2794f60b,0x2745664e)    R(0x02bd,0x25c0a0c2,0x31356672,0x000000a9)    R(0x02be,0x25c0a0c2,0x3132b272,0xffffffff)    R(0x02bf,0x2f21351c,0x3020ecc2,0x2fe148db)    R(0x02c0,0x2fc0e501,0x3020ecc2,0x2f21351c)    R(0x02c1,0x2f01c132,0x2fe148db,0x30c1ccf5)    R(0x02c2,0x2f21351c,0x2fe148db,0x2f01c132)    R(0x02c3,0x2f01c132,0x30c1ccf5,0x2ff22d49)    R(0x02c4,0x2f412158,0x2fc0e501,0x2f21351c)    R(0x02c5,0x2f412158,0x3100f541,0x2fc0e501)\n    R(0x02c6,0x2e11a578,0x2f21351c,0x2f01c132)    R(0x02c7,0x2f412158,0x2f21351c,0x2e11a578)    R(0x02c8,0x2e222984,0x2f01c132,0x2ff22d49)    R(0x02c9,0x2e11a578,0x2f01c132,0x2e222984)    R(0x02ca,0x2e222984,0x2ff22d49,0x2fa27d93)    R(0x02cb,0x2e11a578,0x2e8155a8,0x2f412158)    R(0x02cc,0x2e8155a8,0x31310593,0x2f412158)    R(0x02cd,0x2cf225bd,0x2e11a578,0x2e222984)    R(0x02ce,0x2d8285c0,0x2e222984,0x2fa27d93)    R(0x02cf,0x2d31adc2,0x2e8155a8,0x2e11a578)\n    R(0x02d0,0x2cf225bd,0x2d31adc2,0x2e11a578)    R(0x02d1,0x2cf225bd,0x2e222984,0x2d8285c0)    R(0x02d2,0x2ff139d6,0x31310593,0x2e8155a8)    R(0x02d3,0x2d8285c0,0x2fa27d93,0x2f72b1d1)    R(0x02d4,0x2bf269d3,0x2cf225bd,0x2d8285c0)    R(0x02d5,0x2d9169f0,0x2e8155a8,0x2d31adc2)    R(0x02d6,0x2c11d9de,0x2d31adc2,0x2cf225bd)    R(0x02d7,0x2bf269d3,0x2c11d9de,0x2cf225bd)    R(0x02d8,0x2d9169f0,0x2ff139d6,0x2e8155a8)    R(0x02d9,0x2882a5cb,0x25c1fdd1,0x29c1e5dc)\n    R(0x02da,0x2882a5cb,0x29c1e5dc,0x2bf269d3)    R(0x02db,0x29c1e5dc,0x2c11d9de,0x2bf269d3)    R(0x02dc,0x2c11d9de,0x2d9169f0,0x2d31adc2)    R(0x02dd,0x25c1fdd1,0x271139f7,0x29c1e5dc)    R(0x02de,0x29c1e5dc,0x2b114e01,0x2c11d9de)    R(0x02df,0x2b114e01,0x2d9169f0,0x2c11d9de)    R(0x02e0,0x29c1e5dc,0x271139f7,0x2b114e01)    R(0x02e1,0x2d9169f0,0x30214215,0x2ff139d6)    R(0x02e2,0x2b114e01,0x2d510633,0x2d9169f0)    R(0x02e3,0x271139f7,0x2870b630,0x2b114e01)\n    R(0x02e4,0x2d510633,0x30214215,0x2d9169f0)    R(0x02e5,0x2b114e01,0x2870b630,0x2d510633)    R(0x02e6,0x2d510633,0x30411a53,0x30214215)    R(0x02e7,0x2870b630,0x2b20a272,0x2d510633)    R(0x02e8,0x273269ad,0x31356669,0xffffffff)    R(0x02e9,0x2bf269d3,0x2d8285c0,0x2da2d5e2)    R(0x02ea,0x2da2d5e2,0x2d8285c0,0x2f72b1d1)    R(0x02eb,0x2f72b1d1,0x30e29df2,0x2ff2ea02)    R(0x02ec,0x2882a5cb,0x2bf269d3,0x2b0331db)    R(0x02ed,0x2da2d5e2,0x2f72b1d1,0x2ff2ea02)\n    R(0x02ee,0x2b0331db,0x2bf269d3,0x2da2d5e2)    R(0x02ef,0x2da2d5e2,0x2ff2ea02,0x2e1361f6)    R(0x02f0,0x27538dcc,0x2882a5cb,0x2b0331db)    R(0x02f1,0x2b0331db,0x2da2d5e2,0x2e1361f6)    R(0x02f2,0x2e1361f6,0x2ff2ea02,0x30533606)    R(0x02f3,0x2e1361f6,0x30533606,0x2f73bdeb)    R(0x02f4,0x2b0331db,0x2e1361f6,0x2c43f5fd)    R(0x02f5,0x27538dcc,0x2b0331db,0x297405eb)    R(0x02f6,0x2e1361f6,0x2f73bdeb,0x2df409f5)    R(0x02f7,0x297405eb,0x2b0331db,0x2c43f5fd)\n    R(0x02f8,0x2c43f5fd,0x2e1361f6,0x2df409f5)    R(0x02f9,0x27344dd7,0x27538dcc,0x297405eb)    R(0x02fa,0x2df409f5,0x2f73bdeb,0x30046dca)    R(0x02fb,0x2c43f5fd,0x2df409f5,0x2d444e0e)    R(0x02fc,0x297405eb,0x2c43f5fd,0x2b545e22)    R(0x02fd,0x2b545e22,0x2c43f5fd,0x2d444e0e)    R(0x02fe,0x27344dd7,0x297405eb,0x28d48e11)    R(0x02ff,0x2d444e0e,0x2df409f5,0x2ec499e7)    R(0x0300,0x28d48e11,0x297405eb,0x2b545e22)    R(0x0301,0x2df409f5,0x30046dca,0x2ec499e7)\n    R(0x0302,0x2b545e22,0x2d444e0e,0x2d547236)    R(0x0303,0x2b545e22,0x2d547236,0x2bd49669)    R(0x0304,0x2d444e0e,0x2e94be0b,0x2d547236)    R(0x0305,0x2d547236,0x2f14ba2f,0x2f447663)    R(0x0306,0x2d444e0e,0x2ec499e7,0x2e94be0b)    R(0x0307,0x2794f60b,0x27344dd7,0x28d48e11)    R(0x0308,0x28d48e11,0x2b545e22,0x2904e657)    R(0x0309,0x2904e657,0x2b545e22,0x2bd49669)    R(0x030a,0x2d547236,0x2e94be0b,0x2f14ba2f)    R(0x030b,0x2f14ba2f,0x3134ea2f,0x2f447663)\n    R(0x030c,0x2ec499e7,0x30046dca,0x30e529ad)    R(0x030d,0x2794f60b,0x28d48e11,0x2904e657)    R(0x030e,0x2ec499e7,0x305555d3,0x2e94be0b)    R(0x030f,0x2e94be0b,0x30b551fa,0x2f14ba2f)    R(0x0310,0x2f14ba2f,0x30b551fa,0x3134ea2f)    R(0x0311,0x2ec499e7,0x30e529ad,0x305555d3)    R(0x0312,0x2745664e,0x2794f60b,0x2904e657)    R(0x0313,0x2e94be0b,0x305555d3,0x30b551fa)    R(0x0314,0x1e002e30,0x3107f3ff,0x00000184)    R(0x0315,0x1e002e30,0x3107f35a,0x000000a5)\n    R(0x0316,0x1e002e30,0x3101ab4f,0xffffffff)    R(0x0317,0x1e00e2b4,0x1fd09a9f,0x1e20d26c)    R(0x0318,0x1f716726,0x1fc0c2e3,0x1e113af6)    R(0x0319,0x1fc0c2e3,0x1fd09a9f,0x1e00e2b4)    R(0x031a,0x1fd09a9f,0x2100a255,0x1e20d26c)    R(0x031b,0x1f716726,0x21b0af2a,0x1fc0c2e3)    R(0x031c,0x1fc0c2e3,0x227042e4,0x1fd09a9f)    R(0x031d,0x1fd09a9f,0x22703e93,0x2100a255)    R(0x031e,0x21b0af2a,0x227042e4,0x1fc0c2e3)    R(0x031f,0x227042e4,0x22703e93,0x1fd09a9f)\n    R(0x0320,0x22703e93,0x24d05e54,0x2100a255)    R(0x0321,0x21b0af2a,0x24208f3f,0x227042e4)    R(0x0322,0x227042e4,0x25502eb0,0x22703e93)    R(0x0323,0x24208f3f,0x25703efa,0x227042e4)    R(0x0324,0x25502eb0,0x24d05e54,0x22703e93)    R(0x0325,0x25703efa,0x25502eb0,0x227042e4)    R(0x0326,0x24208f3f,0x28509316,0x25703efa)    R(0x0327,0x27e05679,0x24d05e54,0x25502eb0)    R(0x0328,0x25703efa,0x29006ac6,0x25502eb0)    R(0x0329,0x2870b630,0x24d05e54,0x27e05679)\n    R(0x032a,0x25502eb0,0x29006ac6,0x27e05679)    R(0x032b,0x28509316,0x29006ac6,0x25703efa)    R(0x032c,0x2870b630,0x27e05679,0x2b20a272)    R(0x032d,0x27e05679,0x29006ac6,0x2b20a272)    R(0x032e,0x28509316,0x2bd08700,0x29006ac6)    R(0x032f,0x28509316,0x2af0ef4f,0x2bd08700)    R(0x0330,0x29006ac6,0x2ca07ebe,0x2b20a272)    R(0x0331,0x2bd08700,0x2ca07ebe,0x29006ac6)    R(0x0332,0x2af0ef4f,0x2e20ab26,0x2bd08700)    R(0x0333,0x2b20a272,0x2ca07ebe,0x2ea0ae89)\n    R(0x0334,0x2d510633,0x2b20a272,0x2ea0ae89)    R(0x0335,0x2ef072dd,0x2ca07ebe,0x2bd08700)    R(0x0336,0x2e20ab26,0x2ef072dd,0x2bd08700)    R(0x0337,0x2ea0ae89,0x2ca07ebe,0x2ef072dd)    R(0x0338,0x2d510633,0x2ea0ae89,0x30411a53)    R(0x0339,0x3030d2f9,0x2ef072dd,0x2e20ab26)    R(0x033a,0x3030d2f9,0x2e20ab26,0x2f412b41)    R(0x033b,0x2ea0ae89,0x2ef072dd,0x3060caaa)    R(0x033c,0x2ea0ae89,0x3060caaa,0x30411a53)    R(0x033d,0x3060caaa,0x2ef072dd,0x3030d2f9)\n    R(0x033e,0x3101ab1f,0x3030d2f9,0x2f412b41)    R(0x033f,0x1e23de36,0x30e7f35a,0xffffffff)    R(0x0340,0x2115f309,0x1f752336,0x1e26372c)    R(0x0341,0x20070303,0x2115f309,0x1e26372c)    R(0x0342,0x1f752336,0x2134a72d,0x1ec43751)    R(0x0343,0x2167f2f1,0x20070303,0x1e47db1b)    R(0x0344,0x2115f309,0x22453303,0x1f752336)    R(0x0345,0x22453303,0x2134a72d,0x1f752336)    R(0x0346,0x22e6aad9,0x2115f309,0x20070303)    R(0x0347,0x23777ac4,0x20070303,0x2167f2f1)\n    R(0x0348,0x23777ac4,0x22e6aad9,0x20070303)    R(0x0349,0x23d5a6d6,0x22453303,0x2115f309)    R(0x034a,0x22453303,0x23d50710,0x2134a72d)    R(0x034b,0x22e6aad9,0x23d5a6d6,0x2115f309)    R(0x034c,0x23d50710,0x22e47355,0x2134a72d)    R(0x034d,0x23d5a6d6,0x24c54ecc,0x22453303)    R(0x034e,0x24c54ecc,0x23d50710,0x22453303)    R(0x034f,0x23777ac4,0x24e6fe8f,0x22e6aad9)    R(0x0350,0x22e6aad9,0x25163eae,0x23d5a6d6)    R(0x0351,0x23d50710,0x2604ab43,0x22e47355)\n    R(0x0352,0x24e6fe8f,0x25163eae,0x22e6aad9)    R(0x0353,0x25b7c683,0x24e6fe8f,0x23777ac4)    R(0x0354,0x23d5a6d6,0x26058694,0x24c54ecc)    R(0x0355,0x25163eae,0x26058694,0x23d5a6d6)    R(0x0356,0x24c54ecc,0x270516eb,0x23d50710)    R(0x0357,0x24e6fe8f,0x2646466c,0x25163eae)    R(0x0358,0x270516eb,0x2604ab43,0x23d50710)    R(0x0359,0x25b7c683,0x26672241,0x24e6fe8f)    R(0x035a,0x2646466c,0x26058694,0x25163eae)    R(0x035b,0x26672241,0x2646466c,0x24e6fe8f)\n    R(0x035c,0x26058694,0x27653695,0x24c54ecc)    R(0x035d,0x24c54ecc,0x27653695,0x270516eb)    R(0x035e,0x2646466c,0x2745664e,0x26058694)    R(0x035f,0x2745664e,0x27653695,0x26058694)    R(0x0360,0x270516eb,0x29849315,0x2604ab43)    R(0x0361,0x2745664e,0x2904e657,0x27653695)    R(0x0362,0x29849315,0x2884175a,0x2604ab43)    R(0x0363,0x27653695,0x2a44c6ba,0x270516eb)    R(0x0364,0x2904e657,0x2a44c6ba,0x27653695)    R(0x0365,0x270516eb,0x2a44c6ba,0x29849315)\n    R(0x0366,0x29849315,0x2c140f3b,0x2884175a)    R(0x0367,0x2904e657,0x2bd49669,0x2a44c6ba)    R(0x0368,0x2a44c6ba,0x2ca476f2,0x29849315)    R(0x0369,0x29849315,0x2ca476f2,0x2c140f3b)    R(0x036a,0x2bd49669,0x2e246eaa,0x2a44c6ba)    R(0x036b,0x2a44c6ba,0x2e246eaa,0x2ca476f2)    R(0x036c,0x2ca476f2,0x2f443f1f,0x2c140f3b)    R(0x036d,0x2d547236,0x2f447663,0x2bd49669)    R(0x036e,0x2bd49669,0x2f447663,0x2e246eaa)    R(0x036f,0x2c140f3b,0x2f443f1f,0x2ee3df56)\n    R(0x0370,0x2e246eaa,0x306456e2,0x2ca476f2)    R(0x0371,0x2ca476f2,0x306456e2,0x2f443f1f)    R(0x0372,0x2f447663,0x30d43e93,0x2e246eaa)    R(0x0373,0x2f443f1f,0x30e40f1c,0x2ee3df56)    R(0x0374,0x2e246eaa,0x30d43e93,0x306456e2)    R(0x0375,0x306456e2,0x30e40f1c,0x2f443f1f)    R(0x0376,0x1e008f16,0x3104abff,0x000000f6)    R(0x0377,0x1e008f16,0x28c4abff,0xffffffff)    R(0x0378,0x24208f3f,0x2740db62,0x28509316)    R(0x0379,0x21f0db80,0x24208f3f,0x21b0af2a)\n    R(0x037a,0x2490e79a,0x2740db62,0x24208f3f)    R(0x037b,0x21f0db80,0x2490e79a,0x24208f3f)    R(0x037c,0x20312b69,0x21f0db80,0x21b0af2a)    R(0x037d,0x22211fbd,0x2490e79a,0x21f0db80)    R(0x037e,0x2490e79a,0x28c13fa5,0x2740db62)    R(0x037f,0x20312b69,0x21b0af2a,0x1f716726)    R(0x0380,0x25115bd0,0x2490e79a,0x22211fbd)    R(0x0381,0x202177b1,0x22211fbd,0x21f0db80)    R(0x0382,0x202177b1,0x21f0db80,0x20312b69)    R(0x0383,0x25115bd0,0x28c13fa5,0x2490e79a)\n    R(0x0384,0x2261b3df,0x25115bd0,0x22211fbd)    R(0x0385,0x2261b3df,0x22211fbd,0x202177b1)    R(0x0386,0x1ef1df71,0x20312b69,0x1f716726)    R(0x0387,0x2811dfe3,0x28c13fa5,0x25115bd0)    R(0x0388,0x1ef1df71,0x202177b1,0x20312b69)    R(0x0389,0x25321bf3,0x25115bd0,0x2261b3df)    R(0x038a,0x20a22bd2,0x2261b3df,0x202177b1)    R(0x038b,0x25321bf3,0x2811dfe3,0x25115bd0)    R(0x038c,0x1e422b4d,0x1ef1df71,0x1f716726)    R(0x038d,0x1f125fa8,0x202177b1,0x1ef1df71)\n    R(0x038e,0x1f125fa8,0x20a22bd2,0x202177b1)    R(0x038f,0x22c2cfef,0x25321bf3,0x2261b3df)    R(0x0390,0x26b2a7ff,0x2811dfe3,0x25321bf3)    R(0x0391,0x22c2cfef,0x2261b3df,0x20a22bd2)    R(0x0392,0x1e52a770,0x1f125fa8,0x1ef1df71)    R(0x0393,0x22c2cfef,0x26b2a7ff,0x25321bf3)    R(0x0394,0x206317d6,0x20a22bd2,0x1f125fa8)    R(0x0395,0x22c2cfef,0x20a22bd2,0x206317d6)    R(0x0396,0x1f232b91,0x1f125fa8,0x1e52a770)    R(0x0397,0x1f232b91,0x206317d6,0x1f125fa8)\n    R(0x0398,0x24734ff3,0x26b2a7ff,0x22c2cfef)    R(0x0399,0x1eb33b64,0x1f232b91,0x1e52a770)    R(0x039a,0x27e327e7,0x26b2a7ff,0x24734ff3)    R(0x039b,0x22239be3,0x22c2cfef,0x206317d6)    R(0x039c,0x22239be3,0x24734ff3,0x22c2cfef)    R(0x039d,0x20a3a7bb,0x206317d6,0x1f232b91)    R(0x039e,0x2083cf71,0x1f232b91,0x1eb33b64)    R(0x039f,0x2483cbd6,0x27e327e7,0x24734ff3)    R(0x03a0,0x22239be3,0x206317d6,0x20a3a7bb)    R(0x03a1,0x2013ef50,0x1eb33b64,0x1e035f60)\n    R(0x03a2,0x2083cf71,0x20a3a7bb,0x1f232b91)    R(0x03a3,0x2783b7ab,0x27e327e7,0x2483cbd6)    R(0x03a4,0x2483cbd6,0x24734ff3,0x22239be3)    R(0x03a5,0x2013ef50,0x2083cf71,0x1eb33b64)    R(0x03a6,0x228403a7,0x22239be3,0x20a3a7bb)    R(0x03a7,0x228403a7,0x2483cbd6,0x22239be3)    R(0x03a8,0x228403a7,0x20a3a7bb,0x2083cf71)    R(0x03a9,0x1ec43751,0x2013ef50,0x1e035f60)    R(0x03aa,0x24f42789,0x2783b7ab,0x2483cbd6)    R(0x03ab,0x24f42789,0x2483cbd6,0x228403a7)\n    R(0x03ac,0x2884175a,0x2783b7ab,0x24f42789)    R(0x03ad,0x22e47355,0x2083cf71,0x2013ef50)    R(0x03ae,0x22e47355,0x228403a7,0x2083cf71)    R(0x03af,0x22e47355,0x24f42789,0x228403a7)    R(0x03b0,0x2134a72d,0x2013ef50,0x1ec43751)    R(0x03b1,0x2604ab43,0x2884175a,0x24f42789)    R(0x03b2,0x2134a72d,0x22e47355,0x2013ef50)    R(0x03b3,0x2604ab43,0x24f42789,0x22e47355)    R(0x03b4,0x26b09316,0x310417ff,0xffffffff)    R(0x03b5,0x2ee3df56,0x30e40f1c,0x30636f50)\n    R(0x03b6,0x2740db62,0x2af0ef4f,0x28509316)    R(0x03b7,0x3101ab1f,0x2f412b41,0x2f01df74)    R(0x03b8,0x30f28f42,0x3101ab1f,0x2f01df74)    R(0x03b9,0x2f412b41,0x2e20ab26,0x2cc1437a)    R(0x03ba,0x2cc1437a,0x2e20ab26,0x2af0ef4f)    R(0x03bb,0x2c140f3b,0x2ee3df56,0x2b33b37e)    R(0x03bc,0x2c140f3b,0x2b33b37e,0x2884175a)    R(0x03bd,0x30636f50,0x30f28f42,0x2f02c386)    R(0x03be,0x2f01df74,0x2f412b41,0x2cc1437a)    R(0x03bf,0x2ee3df56,0x30636f50,0x2dd35b8d)\n    R(0x03c0,0x30f28f42,0x2f01df74,0x2f02c386)    R(0x03c1,0x28c13fa5,0x2af0ef4f,0x2740db62)    R(0x03c2,0x2ee3df56,0x2dd35b8d,0x2b33b37e)    R(0x03c3,0x30636f50,0x2f02c386,0x2dd35b8d)    R(0x03c4,0x2cc1437a,0x2af0ef4f,0x28c13fa5)    R(0x03c5,0x2884175a,0x2b33b37e,0x2783b7ab)    R(0x03c6,0x2f01df74,0x2cc1437a,0x2b41b7b6)    R(0x03c7,0x2f02c386,0x2f01df74,0x2cd24bb3)    R(0x03c8,0x2b33b37e,0x2dd35b8d,0x2a935fba)    R(0x03c9,0x2b41b7b6,0x2cc1437a,0x28c13fa5)\n    R(0x03ca,0x2dd35b8d,0x2f02c386,0x2bd2e7c4)    R(0x03cb,0x2cd24bb3,0x2f01df74,0x2b41b7b6)    R(0x03cc,0x2b33b37e,0x2a935fba,0x2783b7ab)    R(0x03cd,0x2f02c386,0x2cd24bb3,0x2bd2e7c4)    R(0x03ce,0x2dd35b8d,0x2bd2e7c4,0x2a935fba)    R(0x03cf,0x2b41b7b6,0x28c13fa5,0x2811dfe3)    R(0x03d0,0x2783b7ab,0x2a935fba,0x27e327e7)    R(0x03d1,0x29a27be7,0x2cd24bb3,0x2b41b7b6)    R(0x03d2,0x2bd2e7c4,0x2cd24bb3,0x29a27be7)    R(0x03d3,0x2a935fba,0x2bd2e7c4,0x27e327e7)\n    R(0x03d4,0x29a27be7,0x2b41b7b6,0x2811dfe3)    R(0x03d5,0x27e327e7,0x2bd2e7c4,0x29a27be7)    R(0x03d6,0x29a27be7,0x2811dfe3,0x26b2a7ff)    R(0x03d7,0x27e327e7,0x29a27be7,0x26b2a7ff)    R(0x03d8,0x2f400000,0x3ff7af50,0x00000379)    R(0x03d9,0x2f400000,0x3d149f50,0x000001e8)    R(0x03da,0x2fc00000,0x3d12656d,0x00000134)    R(0x03db,0x2fe00000,0x3d11d8db,0xffffffff)    R(0x03dc,0x3020ecc2,0x31310c8b,0x2fe148db)    R(0x03dd,0x2fe148db,0x31310c8b,0x31916ca8)\n    R(0x03de,0x3120d0aa,0x3210e46f,0x3020ecc2)    R(0x03df,0x3020ecc2,0x3210e46f,0x31310c8b)    R(0x03e0,0x31310c8b,0x32a1305f,0x31916ca8)    R(0x03e1,0x3210e46f,0x33910c40,0x31310c8b)    R(0x03e2,0x3120d0aa,0x33e0d464,0x3210e46f)    R(0x03e3,0x31310c8b,0x33910c40,0x32a1305f)    R(0x03e4,0x31916ca8,0x32a1305f,0x3431786d)    R(0x03e5,0x3120d0aa,0x3430d4b8,0x33e0d464)    R(0x03e6,0x31916ca8,0x3431786d,0x33f1d8c3)    R(0x03e7,0x3210e46f,0x34e0f42d,0x33910c40)\n    R(0x03e8,0x33e0d464,0x34e0f42d,0x3210e46f)    R(0x03e9,0x33910c40,0x35314825,0x32a1305f)    R(0x03ea,0x32a1305f,0x35314825,0x3431786d)    R(0x03eb,0x33f1d8c3,0x3431786d,0x36c1a07d)    R(0x03ec,0x34e0f42d,0x3691380f,0x33910c40)    R(0x03ed,0x3430d4b8,0x3730b484,0x33e0d464)    R(0x03ee,0x33910c40,0x3691380f,0x35314825)    R(0x03ef,0x3431786d,0x35314825,0x36e1702b)    R(0x03f0,0x33e0d464,0x3790dc37,0x34e0f42d)    R(0x03f1,0x33f1d8c3,0x36c1a07d,0x36a1c8cd)\n    R(0x03f2,0x3431786d,0x36e1702b,0x36c1a07d)    R(0x03f3,0x370068d9,0x3730b484,0x3430d4b8)    R(0x03f4,0x33e0d464,0x3730b484,0x3790dc37)    R(0x03f5,0x3691380f,0x38315c03,0x35314825)    R(0x03f6,0x34e0f42d,0x3891180a,0x3691380f)    R(0x03f7,0x35314825,0x38315c03,0x36e1702b)    R(0x03f8,0x3790dc37,0x3891180a,0x34e0f42d)    R(0x03f9,0x36a1c8cd,0x36c1a07d,0x39315c8d)    R(0x03fa,0x36c1a07d,0x36e1702b,0x39a16840)    R(0x03fb,0x370068d9,0x3950349f,0x3730b484)\n    R(0x03fc,0x36a1c8cd,0x39315c8d,0x38c154d9)    R(0x03fd,0x36e1702b,0x38315c03,0x39a1640a)    R(0x03fe,0x3691380f,0x3a113c00,0x38315c03)    R(0x03ff,0x3891180a,0x3a113c00,0x3691380f)    R(0x0400,0x36c1a07d,0x39a16840,0x39315c8d)    R(0x0401,0x3730b484,0x3af05065,0x3790dc37)    R(0x0402,0x36e1702b,0x39a1640a,0x39a16840)    R(0x0403,0x3790dc37,0x3b30bc29,0x3891180a)    R(0x0404,0x3950349f,0x3af05065,0x3730b484)    R(0x0405,0x38315c03,0x3af14803,0x39a1640a)\n    R(0x0406,0x38c154d9,0x39315c8d,0x3af0c09f)    R(0x0407,0x3a113c00,0x3af14803,0x38315c03)    R(0x0408,0x3790dc37,0x3af05065,0x3b30bc29)    R(0x0409,0x393008c2,0x3b500087,0x3950349f)    R(0x040a,0x39315c8d,0x39a16840,0x3be10054)    R(0x040b,0x3891180a,0x3c40e017,0x3a113c00)    R(0x040c,0x3a700cb4,0x3b500087,0x393008c2)    R(0x040d,0x39a16840,0x39a1640a,0x3bf13419)    R(0x040e,0x3b500087,0x3af05065,0x3950349f)    R(0x040f,0x3b30bc29,0x3c40e017,0x3891180a)\n    R(0x0410,0x39315c8d,0x3be10054,0x3af0c09f)    R(0x0411,0x39a1640a,0x3af14803,0x3bf13419)    R(0x0412,0x39a16840,0x3bf13419,0x3be10054)    R(0x0413,0x3c810015,0x3af14803,0x3a113c00)    R(0x0414,0x3b2044ac,0x3c402476,0x3a700cb4)    R(0x0415,0x3a700cb4,0x3c402476,0x3b500087)    R(0x0416,0x3af05065,0x3ca0584f,0x3b30bc29)    R(0x0417,0x3c40e017,0x3c810015,0x3a113c00)    R(0x0418,0x3af0c09f,0x3cc07c68,0x3b2044ac)    R(0x0419,0x3b500087,0x3ca0584f,0x3af05065)\n    R(0x041a,0x3bf13419,0x3af14803,0x3c810015)    R(0x041b,0x3af0c09f,0x3be10054,0x3cc07c68)    R(0x041c,0x3b30bc29,0x3ca0584f,0x3c40e017)    R(0x041d,0x3cc07c68,0x3c402476,0x3b2044ac)    R(0x041e,0x3c402476,0x3ca0584f,0x3b500087)    R(0x041f,0x3be10054,0x3bf13419,0x3d00d830)    R(0x0420,0x3bf13419,0x3c810015,0x3d00d830)    R(0x0421,0x3be10054,0x3d00d830,0x3cc07c68)    R(0x0422,0x3d10903c,0x3c810015,0x3c40e017)    R(0x0423,0x3c40e017,0x3ca0584f,0x3d10903c)\n    R(0x0424,0x3d10903c,0x3ca0584f,0x3c402476)    R(0x0425,0x3cc07c68,0x3d10903c,0x3c402476)    R(0x0426,0x3d00d830,0x3c810015,0x3d10903c)    R(0x0427,0x3d00d830,0x3d10903c,0x3cc07c68)    R(0x0428,0x2fc0089f,0x3b22656d,0xffffffff)    R(0x0429,0x2fc0e501,0x3120d0aa,0x3020ecc2)    R(0x042a,0x2fe148db,0x31916ca8,0x30c1ccf5)    R(0x042b,0x3100f541,0x31c0e0f5,0x2fc0e501)    R(0x042c,0x2fc0e501,0x31c0e0f5,0x3120d0aa)    R(0x042d,0x2ff22d49,0x30c1ccf5,0x32422513)\n    R(0x042e,0x2ff22d49,0x32422513,0x32526564)    R(0x042f,0x30c1ccf5,0x31916ca8,0x33f1d8c3)    R(0x0430,0x30c1ccf5,0x33f1d8c3,0x32422513)    R(0x0431,0x31c0e0f5,0x3430d4b8,0x3120d0aa)    R(0x0432,0x3100f541,0x34f0a519,0x31c0e0f5)    R(0x0433,0x32526564,0x32422513,0x34a22117)    R(0x0434,0x3390c95f,0x34f0a519,0x3100f541)    R(0x0435,0x32422513,0x33f1d8c3,0x34a22117)    R(0x0436,0x34f0a519,0x3430d4b8,0x31c0e0f5)    R(0x0437,0x32526564,0x34a22117,0x34c2296b)\n    R(0x0438,0x3390c95f,0x35a0854b,0x34f0a519)    R(0x0439,0x34a22117,0x33f1d8c3,0x36a1c8cd)    R(0x043a,0x34f0a519,0x370068d9,0x3430d4b8)    R(0x043b,0x34c2296b,0x34a22117,0x36d1cd21)    R(0x043c,0x35a0854b,0x36f03d07,0x34f0a519)    R(0x043d,0x34a22117,0x36a1c8cd,0x36d1cd21)    R(0x043e,0x34c2296b,0x36d1cd21,0x36a1a16d)    R(0x043f,0x34f0a519,0x36f03d07,0x370068d9)    R(0x0440,0x35a0854b,0x381038fa,0x36f03d07)    R(0x0441,0x3730993d,0x381038fa,0x35a0854b)\n    R(0x0442,0x36d1cd21,0x38414926,0x36a1a16d)    R(0x0443,0x36d1cd21,0x36a1c8cd,0x38c154d9)    R(0x0444,0x36a1a16d,0x38414926,0x37c1094e)    R(0x0445,0x36f03d07,0x393008c2,0x370068d9)    R(0x0446,0x36d1cd21,0x38c154d9,0x38414926)    R(0x0447,0x37c1094e,0x390074fa,0x3730993d)    R(0x0448,0x381038fa,0x393008c2,0x36f03d07)    R(0x0449,0x390074fa,0x381038fa,0x3730993d)    R(0x044a,0x370068d9,0x393008c2,0x3950349f)    R(0x044b,0x38414926,0x3990c8eb,0x37c1094e)\n    R(0x044c,0x37c1094e,0x3990c8eb,0x390074fa)    R(0x044d,0x38c154d9,0x3990c8eb,0x38414926)    R(0x044e,0x390074fa,0x3a700cb4,0x381038fa)    R(0x044f,0x3a700cb4,0x393008c2,0x381038fa)    R(0x0450,0x38c154d9,0x3af0c09f,0x3990c8eb)    R(0x0451,0x3990c8eb,0x3b2044ac,0x390074fa)    R(0x0452,0x390074fa,0x3b2044ac,0x3a700cb4)    R(0x0453,0x3af0c09f,0x3b2044ac,0x3990c8eb)    R(0x0454,0x2f40853d,0x38c49f50,0x000000e4)    R(0x0455,0x2f40853d,0x38c49e38,0xffffffff)\n    R(0x0456,0x3730993d,0x35a0854b,0x35d0f586)    R(0x0457,0x33f0d998,0x35a0854b,0x3390c95f)    R(0x0458,0x35d0f586,0x35a0854b,0x33f0d998)    R(0x0459,0x37c1094e,0x3730993d,0x35d0f586)    R(0x045a,0x31310593,0x33f0d998,0x3390c95f)    R(0x045b,0x31310593,0x3390c95f,0x3100f541)    R(0x045c,0x32512de1,0x33f0d998,0x31310593)    R(0x045d,0x35d0f586,0x33f0d998,0x340149d3)    R(0x045e,0x2f412158,0x31310593,0x3100f541)    R(0x045f,0x340149d3,0x33f0d998,0x32512de1)\n    R(0x0460,0x2ff139d6,0x32512de1,0x31310593)    R(0x0461,0x37c1094e,0x35d0f586,0x35d16da2)    R(0x0462,0x30214215,0x32512de1,0x2ff139d6)    R(0x0463,0x35d16da2,0x35d0f586,0x340149d3)    R(0x0464,0x32017e1f,0x32512de1,0x30214215)    R(0x0465,0x32017e1f,0x340149d3,0x32512de1)    R(0x0466,0x36a1a16d,0x37c1094e,0x35d16da2)    R(0x0467,0x35d16da2,0x340149d3,0x33c1b5f2)    R(0x0468,0x33c1b5f2,0x340149d3,0x32017e1f)    R(0x0469,0x36a1a16d,0x35d16da2,0x34a1f1b6)\n    R(0x046a,0x34a1f1b6,0x35d16da2,0x33c1b5f2)    R(0x046b,0x3241f638,0x33c1b5f2,0x32017e1f)    R(0x046c,0x34c2296b,0x36a1a16d,0x34a1f1b6)    R(0x046d,0x34a1f1b6,0x33c1b5f2,0x32c229f9)    R(0x046e,0x32c229f9,0x33c1b5f2,0x3241f638)    R(0x046f,0x324271b2,0x34a1f1b6,0x32c229f9)    R(0x0470,0x324271b2,0x34c2296b,0x34a1f1b6)    R(0x0471,0x3182921f,0x32c229f9,0x3241f638)    R(0x0472,0x324271b2,0x32526564,0x34c2296b)    R(0x0473,0x2fa27d93,0x2ff22d49,0x32526564)\n    R(0x0474,0x324271b2,0x32c229f9,0x30e29df2)    R(0x0475,0x2fa27d93,0x32526564,0x324271b2)    R(0x0476,0x30e29df2,0x32c229f9,0x3182921f)    R(0x0477,0x2f72b1d1,0x2fa27d93,0x324271b2)    R(0x0478,0x2f72b1d1,0x324271b2,0x30e29df2)    R(0x0479,0x2ff2ea02,0x30e29df2,0x3182921f)    R(0x047a,0x2ff2ea02,0x3182921f,0x3172fe23)    R(0x047b,0x2ff2ea02,0x3172fe23,0x30533606)    R(0x047c,0x30533606,0x3172fe23,0x3293660d)    R(0x047d,0x3172fe23,0x32f35e31,0x3293660d)\n    R(0x047e,0x30533606,0x3293660d,0x31739ded)    R(0x047f,0x30533606,0x31739ded,0x2f73bdeb)    R(0x0480,0x32f35e31,0x35a3e9f7,0x3293660d)    R(0x0481,0x3293660d,0x3433edd4,0x31739ded)    R(0x0482,0x34e3e627,0x35a3e9f7,0x32f35e31)    R(0x0483,0x35a3e9f7,0x3433edd4,0x3293660d)    R(0x0484,0x2f73bdeb,0x31739ded,0x324431bb)    R(0x0485,0x31739ded,0x3433edd4,0x324431bb)    R(0x0486,0x35a3e9f7,0x36c451b9,0x3433edd4)    R(0x0487,0x34e3e627,0x37b475f0,0x35a3e9f7)\n    R(0x0488,0x2f73bdeb,0x324431bb,0x30046dca)    R(0x0489,0x324431bb,0x3433edd4,0x35549d8e)    R(0x048a,0x36547e19,0x37b475f0,0x34e3e627)    R(0x048b,0x35a3e9f7,0x38c49dbd,0x36c451b9)    R(0x048c,0x3433edd4,0x36c451b9,0x35549d8e)    R(0x048d,0x37b475f0,0x38c49dbd,0x35a3e9f7)    R(0x048e,0x2f40ca15,0x36548b50,0xffffffff)    R(0x048f,0x31816acc,0x3060caaa,0x3030d2f9)    R(0x0490,0x30411a53,0x3060caaa,0x3171766d)    R(0x0491,0x3171766d,0x3060caaa,0x31816acc)\n    R(0x0492,0x30214215,0x30411a53,0x32017e1f)    R(0x0493,0x31816acc,0x3030d2f9,0x3101ab1f)    R(0x0494,0x32017e1f,0x30411a53,0x3171766d)    R(0x0495,0x3241f638,0x32017e1f,0x3171766d)    R(0x0496,0x32122e98,0x3171766d,0x31816acc)    R(0x0497,0x32026aee,0x31816acc,0x3101ab1f)    R(0x0498,0x3241f638,0x3171766d,0x32122e98)    R(0x0499,0x32122e98,0x31816acc,0x32026aee)    R(0x049a,0x30f28f42,0x32026aee,0x3101ab1f)    R(0x049b,0x3202d25a,0x3241f638,0x32122e98)\n    R(0x049c,0x3182921f,0x3241f638,0x3202d25a)    R(0x049d,0x32333ead,0x32122e98,0x32026aee)    R(0x049e,0x3202d25a,0x32122e98,0x32333ead)    R(0x049f,0x31c35f09,0x32026aee,0x30f28f42)    R(0x04a0,0x3182921f,0x3202d25a,0x3172fe23)    R(0x04a1,0x32333ead,0x32026aee,0x31c35f09)    R(0x04a2,0x3202d25a,0x32f35e31,0x3172fe23)    R(0x04a3,0x30636f50,0x31c35f09,0x30f28f42)    R(0x04a4,0x3293865b,0x3202d25a,0x32333ead)    R(0x04a5,0x3293865b,0x32f35e31,0x3202d25a)\n    R(0x04a6,0x31a3fed0,0x32333ead,0x31c35f09)    R(0x04a7,0x31f3ea7e,0x3293865b,0x32333ead)    R(0x04a8,0x34e3e627,0x32f35e31,0x3293865b)    R(0x04a9,0x30e40f1c,0x31c35f09,0x30636f50)    R(0x04aa,0x31f3ea7e,0x32333ead,0x31a3fed0)    R(0x04ab,0x31a3fed0,0x31c35f09,0x30e40f1c)    R(0x04ac,0x33740a4e,0x34e3e627,0x3293865b)    R(0x04ad,0x33740a4e,0x3293865b,0x31f3ea7e)    R(0x04ae,0x30d43e93,0x31f3ea7e,0x31a3fed0)    R(0x04af,0x31b45a5d,0x33740a4e,0x31f3ea7e)\n    R(0x04b0,0x306456e2,0x31a3fed0,0x30e40f1c)    R(0x04b1,0x33740a4e,0x36547e19,0x34e3e627)    R(0x04b2,0x31b45a5d,0x31f3ea7e,0x30d43e93)    R(0x04b3,0x30d43e93,0x31a3fed0,0x306456e2)    R(0x04b4,0x31b45a5d,0x34348a37,0x33740a4e)    R(0x04b5,0x2f447663,0x31b45a5d,0x30d43e93)    R(0x04b6,0x34348a37,0x36547e19,0x33740a4e)    R(0x04b7,0x2f4430a6,0x3ff7ae63,0x00000158)    R(0x04b8,0x334540a6,0x3ff7ad87,0x000000a0)    R(0x04b9,0x366638a6,0x3ff7ad20,0xffffffff)\n    R(0x04ba,0x36e79101,0x3897a4d7,0x36679520)    R(0x04bb,0x36679520,0x3897a4d7,0x3837acf3)    R(0x04bc,0x37c75cec,0x396788c1,0x36e79101)    R(0x04bd,0x36e79101,0x396788c1,0x3897a4d7)    R(0x04be,0x3856b907,0x3a373cc1,0x37c75cec)    R(0x04bf,0x3a373cc1,0x396788c1,0x37c75cec)    R(0x04c0,0x3897a4d7,0x3b2788b8,0x3837acf3)    R(0x04c1,0x3837acf3,0x3ae780d7,0x38d7750e)    R(0x04c2,0x396788c1,0x3af77cae,0x3897a4d7)    R(0x04c3,0x3856b907,0x3b56a4ea,0x3a373cc1)\n    R(0x04c4,0x3837acf3,0x3b2788b8,0x3ae780d7)    R(0x04c5,0x3897a4d7,0x3af77cae,0x3b2788b8)    R(0x04c6,0x3a373cc1,0x3bf758a6,0x396788c1)    R(0x04c7,0x396788c1,0x3bf758a6,0x3af77cae)    R(0x04c8,0x38d7750e,0x3ae780d7,0x3d2714f9)    R(0x04c9,0x3b56a4ea,0x3cc718b3,0x3a373cc1)    R(0x04ca,0x3a373cc1,0x3cc718b3,0x3bf758a6)    R(0x04cb,0x3af77cae,0x3d4750ab,0x3b2788b8)    R(0x04cc,0x3bf758a6,0x3d4750ab,0x3af77cae)    R(0x04cd,0x3b2788b8,0x3e3734c5,0x3ae780d7)\n    R(0x04ce,0x3c863917,0x3e56c8d8,0x3b56a4ea)    R(0x04cf,0x3ae780d7,0x3e3734c5,0x3d2714f9)    R(0x04d0,0x3b56a4ea,0x3e56c8d8,0x3cc718b3)    R(0x04d1,0x3b2788b8,0x3d4750ab,0x3e3734c5)    R(0x04d2,0x3cc718b3,0x3e1728b1,0x3bf758a6)    R(0x04d3,0x3bf758a6,0x3e1728b1,0x3d4750ab)    R(0x04d4,0x3e56c8d8,0x3e1728b1,0x3cc718b3)    R(0x04d5,0x3c863917,0x3f168514,0x3e56c8d8)    R(0x04d6,0x3e1728b1,0x3f2710c8,0x3d4750ab)    R(0x04d7,0x3d4750ab,0x3f2710c8,0x3e3734c5)\n    R(0x04d8,0x3d2714f9,0x3e3734c5,0x3f76d51a)    R(0x04d9,0x3e56c8d8,0x3f86e8d9,0x3e1728b1)    R(0x04da,0x3f86e8d9,0x3f2710c8,0x3e1728b1)    R(0x04db,0x3f168514,0x3f86e8d9,0x3e56c8d8)    R(0x04dc,0x3e3734c5,0x3f2710c8,0x3fd6e8f4)    R(0x04dd,0x3f76d51a,0x3e3734c5,0x3fd6e8f4)    R(0x04de,0x3ff6c907,0x3f86e8d9,0x3f168514)    R(0x04df,0x3ff6c907,0x3f2710c8,0x3f86e8d9)    R(0x04e0,0x3fd6e8f4,0x3f2710c8,0x3ff6c907)    R(0x04e1,0x334540ea,0x3ff7ad87,0xffffffff)\n    R(0x04e2,0x3345b174,0x35f6313d,0x33e68d65)    R(0x04e3,0x3345b174,0x3565615d,0x35f6313d)    R(0x04e4,0x33e68d65,0x35c70d2c,0x34f7414a)    R(0x04e5,0x35f6313d,0x35c70d2c,0x33e68d65)    R(0x04e6,0x34f7414a,0x36679520,0x34d73969)    R(0x04e7,0x34d73969,0x3657853a,0x35071d82)    R(0x04e8,0x34d73969,0x36679520,0x3657853a)    R(0x04e9,0x35c70d2c,0x36e79101,0x34f7414a)    R(0x04ea,0x34f7414a,0x36e79101,0x36679520)    R(0x04eb,0x35071d82,0x3657853a,0x36f7294d)\n    R(0x04ec,0x35f6313d,0x3856b907,0x35c70d2c)    R(0x04ed,0x3565615d,0x3905f927,0x35f6313d)    R(0x04ee,0x35c70d2c,0x37c75cec,0x36e79101)    R(0x04ef,0x36679520,0x3837acf3,0x3657853a)    R(0x04f0,0x3856b907,0x37c75cec,0x35c70d2c)    R(0x04f1,0x3565615d,0x37b5415a,0x3905f927)    R(0x04f2,0x3657853a,0x38d7750e,0x36f7294d)    R(0x04f3,0x35f6313d,0x3905f927,0x3856b907)    R(0x04f4,0x3657853a,0x3837acf3,0x38d7750e)    R(0x04f5,0x36f7294d,0x3a46cd30,0x3866516b)\n    R(0x04f6,0x36f7294d,0x38d7750e,0x3a46cd30)    R(0x04f7,0x37b5415a,0x3ab5994e,0x3905f927)    R(0x04f8,0x3905f927,0x3b56a4ea,0x3856b907)    R(0x04f9,0x3866516b,0x3a46cd30,0x3b763d79)    R(0x04fa,0x3ab5994e,0x3c863917,0x3905f927)    R(0x04fb,0x38d7750e,0x3d2714f9,0x3a46cd30)    R(0x04fc,0x3905f927,0x3c863917,0x3b56a4ea)    R(0x04fd,0x3b054d86,0x3d35fd51,0x3ab5994e)    R(0x04fe,0x3b763d79,0x3a46cd30,0x3d66a541)    R(0x04ff,0x3ab5994e,0x3d35fd51,0x3c863917)\n    R(0x0500,0x3a46cd30,0x3d2714f9,0x3d66a541)    R(0x0501,0x3b763d79,0x3d66a541,0x3e467963)    R(0x0502,0x3d35fd51,0x3f168514,0x3c863917)    R(0x0503,0x3cb5dd87,0x3ee6714a,0x3d35fd51)    R(0x0504,0x3d66a541,0x3d2714f9,0x3f76d51a)    R(0x0505,0x3d66a541,0x3f76d51a,0x3e467963)    R(0x0506,0x3ee6714a,0x3f168514,0x3d35fd51)    R(0x0507,0x3e467963,0x3f86a539,0x3db63d7b)    R(0x0508,0x3db63d7b,0x3f86a539,0x3ee6714a)    R(0x0509,0x3e467963,0x3f76d51a,0x3f86a539)\n    R(0x050a,0x3ee6714a,0x3ff6c907,0x3f168514)    R(0x050b,0x3f86a539,0x3ff6c907,0x3ee6714a)    R(0x050c,0x3f76d51a,0x3fd6e8f4,0x3f86a539)    R(0x050d,0x3f86a539,0x3fd6e8f4,0x3ff6c907)    R(0x050e,0x2f44314a,0x3ee74263,0x000000b5)    R(0x050f,0x2f44314e,0x3d360663,0xffffffff)    R(0x0510,0x2f447663,0x3134ea2f,0x31b45a5d)    R(0x0511,0x305555d3,0x322605c4,0x30b551fa)    R(0x0512,0x30e529ad,0x3215f59c,0x305555d3)    R(0x0513,0x30046dca,0x32c4e190,0x30e529ad)\n    R(0x0514,0x305555d3,0x3215f59c,0x322605c4)    R(0x0515,0x30b551fa,0x3305c9f0,0x3134ea2f)    R(0x0516,0x30046dca,0x324431bb,0x32c4e190)    R(0x0517,0x30b551fa,0x322605c4,0x3305c9f0)    R(0x0518,0x30e529ad,0x3345b174,0x3215f59c)    R(0x0519,0x3134ea2f,0x33951217,0x31b45a5d)    R(0x051a,0x30e529ad,0x32c4e190,0x3345b174)    R(0x051b,0x3134ea2f,0x3305c9f0,0x33951217)    R(0x051c,0x31b45a5d,0x33951217,0x34348a37)    R(0x051d,0x324431bb,0x35549d8e,0x32c4e190)\n    R(0x051e,0x3305c9f0,0x34258df0,0x33951217)    R(0x051f,0x32c4e190,0x3565615d,0x3345b174)    R(0x0520,0x32c4e190,0x35549d8e,0x3565615d)    R(0x0521,0x33951217,0x34258df0,0x36955de8)    R(0x0522,0x33951217,0x36f50a09,0x34348a37)    R(0x0523,0x33951217,0x36955de8,0x36f50a09)    R(0x0524,0x34258df0,0x36a5d1a9,0x36955de8)    R(0x0525,0x34348a37,0x36f50a09,0x36547e19)    R(0x0526,0x35549d8e,0x37b5415a,0x3565615d)    R(0x0527,0x36c451b9,0x38b4e585,0x35549d8e)\n    R(0x0528,0x35549d8e,0x38b4e585,0x37b5415a)    R(0x0529,0x36f50a09,0x38e519e8,0x36547e19)    R(0x052a,0x36955de8,0x36a5d1a9,0x3925c9b2)    R(0x052b,0x36547e19,0x38e519e8,0x37b475f0)    R(0x052c,0x36955de8,0x398591d8,0x36f50a09)    R(0x052d,0x38c49dbd,0x38b4e585,0x36c451b9)    R(0x052e,0x36955de8,0x3925c9b2,0x398591d8)    R(0x052f,0x36f50a09,0x398591d8,0x38e519e8)    R(0x0530,0x37b475f0,0x3a6529ba,0x38c49dbd)    R(0x0531,0x38e519e8,0x3a6529ba,0x37b475f0)\n    R(0x0532,0x38b4e585,0x3ab5994e,0x37b5415a)    R(0x0533,0x38c49dbd,0x3b054d86,0x38b4e585)    R(0x0534,0x398591d8,0x3b55b9b4,0x38e519e8)    R(0x0535,0x3a6529ba,0x3b054d86,0x38c49dbd)    R(0x0536,0x3b054d86,0x3ab5994e,0x38b4e585)    R(0x0537,0x38e519e8,0x3b55b9b4,0x3a6529ba)    R(0x0538,0x398591d8,0x3c1605a0,0x3b55b9b4)    R(0x0539,0x3a6529ba,0x3cb5dd87,0x3b054d86)    R(0x053a,0x3b55b9b4,0x3cb5dd87,0x3a6529ba)    R(0x053b,0x3cb5dd87,0x3d35fd51,0x3b054d86)\n    R(0x053c,0x32158d4a,0x3ee741f0,0xffffffff)    R(0x053d,0x3215f59c,0x3376b58b,0x322605c4)    R(0x053e,0x322605c4,0x33d6a1ae,0x3305c9f0)    R(0x053f,0x3345b174,0x33e68d65,0x3215f59c)    R(0x0540,0x322605c4,0x3376b58b,0x33d6a1ae)    R(0x0541,0x3215f59c,0x33e68d65,0x3376b58b)    R(0x0542,0x3305c9f0,0x33d6a1ae,0x344671c6)    R(0x0543,0x3305c9f0,0x344671c6,0x34258df0)    R(0x0544,0x3376b58b,0x34d73969,0x33d6a1ae)    R(0x0545,0x33e68d65,0x34f7414a,0x3376b58b)\n    R(0x0546,0x33d6a1ae,0x35071d82,0x344671c6)    R(0x0547,0x3376b58b,0x34f7414a,0x34d73969)    R(0x0548,0x344671c6,0x34e61dc3,0x34258df0)    R(0x0549,0x33d6a1ae,0x34d73969,0x35071d82)    R(0x054a,0x344671c6,0x35c6b18a,0x34e61dc3)    R(0x054b,0x344671c6,0x35071d82,0x35c6b18a)    R(0x054c,0x34258df0,0x34e61dc3,0x36a5d1a9)    R(0x054d,0x34e61dc3,0x35c6b18a,0x36a5d1a9)    R(0x054e,0x35071d82,0x36f7294d,0x35c6b18a)    R(0x054f,0x35c6b18a,0x3866516b,0x36a5d1a9)\n    R(0x0550,0x35c6b18a,0x36f7294d,0x3866516b)    R(0x0551,0x36a5d1a9,0x3866516b,0x3925c9b2)    R(0x0552,0x3925c9b2,0x3866516b,0x3b763d79)    R(0x0553,0x3925c9b2,0x3c1605a0,0x398591d8)    R(0x0554,0x3925c9b2,0x3b763d79,0x3c1605a0)    R(0x0555,0x3c1605a0,0x3db63d7b,0x3b55b9b4)    R(0x0556,0x3b55b9b4,0x3db63d7b,0x3cb5dd87)    R(0x0557,0x3b763d79,0x3e467963,0x3c1605a0)    R(0x0558,0x3c1605a0,0x3e467963,0x3db63d7b)    R(0x0559,0x3db63d7b,0x3ee6714a,0x3cb5dd87)\n    R(0x055a,0x00970c3b,0x290fff8e,0x000006f2)    R(0x055b,0x00972c3e,0x13dfff88,0x0000040d)    R(0x055c,0x00972c3e,0x13ac8f88,0x000001d8)    R(0x055d,0x01172c3e,0x13ac7e2d,0x0000011a)    R(0x055e,0x01174487,0x057c5a2d,0x00000090)    R(0x055f,0x01174c87,0x057c3d2d,0xffffffff)    R(0x0560,0x02074cf4,0x011790c3,0x021834ec)    R(0x0561,0x0308112b,0x02074cf4,0x021834ec)    R(0x0562,0x011790c3,0x0177cca9,0x014878bc)    R(0x0563,0x03788496,0x0177cca9,0x0387a49f)\n    R(0x0564,0x021834ec,0x011790c3,0x014878bc)    R(0x0565,0x014878bc,0x0177cca9,0x01a8d09e)    R(0x0566,0x01a8d09e,0x0177cca9,0x03788496)    R(0x0567,0x0308112b,0x021834ec,0x03391d25)    R(0x0568,0x021834ec,0x014878bc,0x023910e5)    R(0x0569,0x03391d25,0x021834ec,0x023910e5)    R(0x056a,0x016964b7,0x014878bc,0x01a8d09e)    R(0x056b,0x0399648d,0x01a8d09e,0x03788496)    R(0x056c,0x023910e5,0x014878bc,0x016964b7)    R(0x056d,0x01d9c099,0x01a8d09e,0x0399648d)\n    R(0x056e,0x01d9c099,0x016964b7,0x01a8d09e)    R(0x056f,0x03391d25,0x023910e5,0x0239dcec)    R(0x0570,0x023910e5,0x016964b7,0x0239dcec)    R(0x0571,0x03391d25,0x0239dcec,0x0279fd2a)    R(0x0572,0x038a2c88,0x01d9c099,0x0399648d)    R(0x0573,0x019a4cbe,0x016964b7,0x01d9c099)    R(0x0574,0x0239dcec,0x016964b7,0x019a4cbe)    R(0x0575,0x0279fd2a,0x0239dcec,0x018a9907)    R(0x0576,0x027a9ca1,0x01d9c099,0x038a2c88)    R(0x0577,0x019a4cbe,0x01d9c099,0x027a9ca1)\n    R(0x0578,0x018a9907,0x0239dcec,0x019a4cbe)    R(0x0579,0x057ad487,0x027a9ca1,0x038a2c88)    R(0x057a,0x018a9907,0x019a4cbe,0x020afcde)    R(0x057b,0x020afcde,0x019a4cbe,0x027a9ca1)    R(0x057c,0x045b38bb,0x027a9ca1,0x057ad487)    R(0x057d,0x020afcde,0x027a9ca1,0x045b38bb)    R(0x057e,0x01bb4d29,0x018a9907,0x020afcde)    R(0x057f,0x038b9900,0x020afcde,0x045b38bb)    R(0x0580,0x01bb4d29,0x020afcde,0x038b9900)    R(0x0581,0x01bb4d29,0x038b9900,0x02ac392d)\n    R(0x0582,0x02ac392d,0x038b9900,0x053c3cfc)    R(0x0583,0x01374507,0x033c5a2d,0xffffffff)    R(0x0584,0x029835c6,0x026745d6,0x02b7a17d)    R(0x0585,0x0257d221,0x026745d6,0x029835c6)    R(0x0586,0x02f8b171,0x02b7a17d,0x0308112b)    R(0x0587,0x029835c6,0x02b7a17d,0x02f8b171)    R(0x0588,0x0298d20e,0x0257d221,0x029835c6)    R(0x0589,0x02f8b171,0x0308112b,0x03391d25)    R(0x058a,0x02b921bb,0x029835c6,0x02f8b171)    R(0x058b,0x0298d20e,0x029835c6,0x02b921bb)\n    R(0x058c,0x02f8b171,0x03391d25,0x0279a16e)    R(0x058d,0x02b921bb,0x02f8b171,0x0279a16e)    R(0x058e,0x0219c5f8,0x0298d20e,0x02b921bb)    R(0x058f,0x02b921bb,0x0279a16e,0x0189ddb2)    R(0x0590,0x0279a16e,0x03391d25,0x0279fd2a)    R(0x0591,0x0219c5f8,0x02b921bb,0x0189ddb2)    R(0x0592,0x0189ddb2,0x0279a16e,0x015a755f)    R(0x0593,0x0279a16e,0x0279fd2a,0x015a755f)    R(0x0594,0x0219c5f8,0x0189ddb2,0x013ab9ff)    R(0x0595,0x0189ddb2,0x015a755f,0x016a91b0)\n    R(0x0596,0x015a755f,0x0279fd2a,0x018a9907)    R(0x0597,0x013ab9ff,0x0189ddb2,0x016a91b0)    R(0x0598,0x016a91b0,0x015a755f,0x01eb4178)    R(0x0599,0x015a755f,0x018a9907,0x01bb4d29)    R(0x059a,0x013ab9ff,0x016a91b0,0x01bb71d7)    R(0x059b,0x01eb4178,0x015a755f,0x01bb4d29)    R(0x059c,0x01bb71d7,0x016a91b0,0x01eb4178)    R(0x059d,0x016bba2d,0x013ab9ff,0x01bb71d7)    R(0x059e,0x01eb4178,0x01bb4d29,0x01bbf55d)    R(0x059f,0x01bb71d7,0x01eb4178,0x01ec25a9)\n    R(0x05a0,0x01ec25a9,0x01eb4178,0x01bbf55d)    R(0x05a1,0x01bbf55d,0x01bb4d29,0x02ac392d)    R(0x05a2,0x016bba2d,0x01bb71d7,0x01bc59fc)    R(0x05a3,0x01bc59fc,0x01bb71d7,0x01ec25a9)    R(0x05a4,0x03772c3e,0x13ac7d00,0xffffffff)    R(0x05a5,0x0688107d,0x0387a49f,0x06c73c8a)    R(0x05a6,0x1197e840,0x0d38184b,0x0ee72c49)    R(0x05a7,0x09986c5d,0x0688107d,0x0a77705e)    R(0x05a8,0x0d38184b,0x09986c5d,0x0a77705e)    R(0x05a9,0x03788496,0x0387a49f,0x0688107d)\n    R(0x05aa,0x1028b043,0x0d38184b,0x1197e840)    R(0x05ab,0x06790076,0x0688107d,0x09986c5d)    R(0x05ac,0x06790076,0x03788496,0x0688107d)    R(0x05ad,0x13a9083e,0x1028b043,0x1197e840)    R(0x05ae,0x0cc9304d,0x09986c5d,0x0d38184b)    R(0x05af,0x1028b043,0x0cc9304d,0x0d38184b)    R(0x05b0,0x0959605a,0x06790076,0x09986c5d)    R(0x05b1,0x0399648d,0x03788496,0x06790076)    R(0x05b2,0x0cc9304d,0x0959605a,0x09986c5d)    R(0x05b3,0x13a9083e,0x10499045,0x1028b043)\n    R(0x05b4,0x10499045,0x0cc9304d,0x1028b043)    R(0x05b5,0x070a086e,0x06790076,0x0959605a)    R(0x05b6,0x070a086e,0x0399648d,0x06790076)    R(0x05b7,0x0b0a3054,0x0959605a,0x0cc9304d)    R(0x05b8,0x0eca584d,0x0cc9304d,0x10499045)    R(0x05b9,0x070a086e,0x038a2c88,0x0399648d)    R(0x05ba,0x070a086e,0x0959605a,0x0b0a3054)    R(0x05bb,0x0eca584d,0x0b0a3054,0x0cc9304d)    R(0x05bc,0x130a144c,0x0eca584d,0x10499045)    R(0x05bd,0x057ad487,0x038a2c88,0x070a086e)\n    R(0x05be,0x08eae066,0x070a086e,0x0b0a3054)    R(0x05bf,0x112b0c5a,0x0eca584d,0x130a144c)    R(0x05c0,0x0c5b005b,0x0b0a3054,0x0eca584d)    R(0x05c1,0x08eae066,0x057ad487,0x070a086e)    R(0x05c2,0x08eae066,0x0b0a3054,0x0c5b005b)    R(0x05c3,0x112b0c5a,0x0c5b005b,0x0eca584d)    R(0x05c4,0x077b8490,0x057ad487,0x08eae066)    R(0x05c5,0x0aabac7e,0x08eae066,0x0c5b005b)    R(0x05c6,0x077b8490,0x045b38bb,0x057ad487)    R(0x05c7,0x0e5ba876,0x0c5b005b,0x112b0c5a)\n    R(0x05c8,0x0aabac7e,0x077b8490,0x08eae066)    R(0x05c9,0x0aabac7e,0x0c5b005b,0x0e5ba876)    R(0x05ca,0x06abf4cd,0x045b38bb,0x077b8490)    R(0x05cb,0x038b9900,0x045b38bb,0x06abf4cd)    R(0x05cc,0x116c1482,0x0e5ba876,0x112b0c5a)    R(0x05cd,0x09bc44ae,0x077b8490,0x0aabac7e)    R(0x05ce,0x09bc44ae,0x06abf4cd,0x077b8490)    R(0x05cf,0x053c3cfc,0x038b9900,0x06abf4cd)    R(0x05d0,0x0dac7c9d,0x0aabac7e,0x0e5ba876)    R(0x05d1,0x0dac7c9d,0x0e5ba876,0x116c1482)\n    R(0x05d2,0x0dac7c9d,0x09bc44ae,0x0aabac7e)    R(0x05d3,0x009731f8,0x13ac8f88,0x0000013a)    R(0x05d4,0x009731f8,0x05bc8f7a,0x00000070)    R(0x05d5,0x01174df8,0x02ec8eca,0xffffffff)    R(0x05d6,0x02686268,0x01c74e72,0x0257d221)    R(0x05d7,0x02681ab8,0x01c74e72,0x02686268)    R(0x05d8,0x02686268,0x0257d221,0x0298d20e)    R(0x05d9,0x02a93ea4,0x02681ab8,0x02686268)    R(0x05da,0x02a96a4c,0x02686268,0x0298d20e)    R(0x05db,0x02a93ea4,0x02686268,0x02a96a4c)\n    R(0x05dc,0x02a96a4c,0x0298d20e,0x0219c5f8)    R(0x05dd,0x02a93ea4,0x02a96a4c,0x02ea3677)    R(0x05de,0x024a5230,0x02a96a4c,0x0219c5f8)    R(0x05df,0x020a56b6,0x02a93ea4,0x02ea3677)    R(0x05e0,0x02ea3677,0x02a96a4c,0x024a5230)    R(0x05e1,0x024a5230,0x0219c5f8,0x013ab9ff)    R(0x05e2,0x022b1a4f,0x02ea3677,0x024a5230)    R(0x05e3,0x020a56b6,0x02ea3677,0x023b1686)    R(0x05e4,0x022b1a4f,0x024a5230,0x013ab9ff)    R(0x05e5,0x023b1686,0x02ea3677,0x022b1a4f)\n    R(0x05e6,0x011b22bd,0x020a56b6,0x023b1686)    R(0x05e7,0x016bba2d,0x022b1a4f,0x013ab9ff)    R(0x05e8,0x015bd27d,0x023b1686,0x022b1a4f)    R(0x05e9,0x015bd27d,0x011b22bd,0x023b1686)    R(0x05ea,0x014b96ca,0x011b22bd,0x015bd27d)    R(0x05eb,0x015bd27d,0x022b1a4f,0x016bba2d)    R(0x05ec,0x01ac4a99,0x014b96ca,0x015bd27d)    R(0x05ed,0x023c2ac4,0x014b96ca,0x01ac4a99)    R(0x05ee,0x022c8e50,0x015bd27d,0x016bba2d)    R(0x05ef,0x022c8e50,0x016bba2d,0x01bc59fc)\n    R(0x05f0,0x01ac4a99,0x015bd27d,0x022c8e50)    R(0x05f1,0x009732a4,0x05bc5f7a,0xffffffff)    R(0x05f2,0x0457db66,0x02973757,0x0227f77a)    R(0x05f3,0x00977f28,0x018772eb,0x0178330b)    R(0x05f4,0x00f80f71,0x00b73344,0x00a82b50)    R(0x05f5,0x0227f77a,0x01476b60,0x00f80f71)    R(0x05f6,0x0178330b,0x018772eb,0x02681ab8)    R(0x05f7,0x00a82b50,0x00977f28,0x0178330b)    R(0x05f8,0x0457db66,0x0227f77a,0x03b87774)    R(0x05f9,0x01989b72,0x0227f77a,0x00f80f71)\n    R(0x05fa,0x03b87774,0x0227f77a,0x01989b72)    R(0x05fb,0x00e8df56,0x00f80f71,0x00a82b50)    R(0x05fc,0x0178330b,0x02681ab8,0x0238eeeb)    R(0x05fd,0x00a82b50,0x0178330b,0x00c90326)    R(0x05fe,0x01989b72,0x00f80f71,0x00e8df56)    R(0x05ff,0x00e8df56,0x00a82b50,0x00c90326)    R(0x0600,0x00c90326,0x0178330b,0x0238eeeb)    R(0x0601,0x02f92359,0x03b87774,0x01989b72)    R(0x0602,0x0238eeeb,0x02681ab8,0x02a93ea4)    R(0x0603,0x0568f74f,0x03b87774,0x02f92359)\n    R(0x0604,0x01697342,0x01989b72,0x00e8df56)    R(0x0605,0x02f92359,0x01989b72,0x01697342)    R(0x0606,0x00e8df56,0x00c90326,0x00f9b71f)    R(0x0607,0x00c90326,0x0238eeeb,0x0179bee7)    R(0x0608,0x05099b31,0x0568f74f,0x02f92359)    R(0x0609,0x0179bee7,0x0238eeeb,0x02a93ea4)    R(0x060a,0x01697342,0x00e8df56,0x00f9b71f)    R(0x060b,0x00f9b71f,0x00c90326,0x0179bee7)    R(0x060c,0x029a0b27,0x02f92359,0x01697342)    R(0x060d,0x05099b31,0x02f92359,0x029a0b27)\n    R(0x060e,0x0179bee7,0x02a93ea4,0x020a56b6)    R(0x060f,0x01697342,0x00f9b71f,0x016a5712)    R(0x0610,0x029a0b27,0x01697342,0x016a5712)    R(0x0611,0x054a3315,0x05099b31,0x029a0b27)    R(0x0612,0x00f9b71f,0x0179bee7,0x010a8ef0)    R(0x0613,0x016a5712,0x00f9b71f,0x010a8ef0)    R(0x0614,0x010a8ef0,0x0179bee7,0x020a56b6)    R(0x0615,0x054a3315,0x029a0b27,0x034ad6fe)    R(0x0616,0x029a0b27,0x016a5712,0x034ad6fe)    R(0x0617,0x010a8ef0,0x020a56b6,0x011b22bd)\n    R(0x0618,0x016a5712,0x010a8ef0,0x018b32eb)    R(0x0619,0x054a3315,0x034ad6fe,0x05bb170a)    R(0x061a,0x034ad6fe,0x016a5712,0x018b32eb)    R(0x061b,0x010a8ef0,0x011b22bd,0x014b96ca)    R(0x061c,0x018b32eb,0x010a8ef0,0x014b96ca)    R(0x061d,0x05bb170a,0x034ad6fe,0x03bba6df)    R(0x061e,0x034ad6fe,0x018b32eb,0x03bba6df)    R(0x061f,0x018b32eb,0x014b96ca,0x023c2ac4)    R(0x0620,0x03bba6df,0x018b32eb,0x023c2ac4)    R(0x0621,0x03bba6df,0x023c2ac4,0x04ec5ec1)\n    R(0x0622,0x03b762c1,0x13ac8788,0xffffffff)    R(0x0623,0x12676323,0x0f97b719,0x1237db44)    R(0x0624,0x0a478af3,0x08077af7,0x09380308)    R(0x0625,0x0df77f07,0x0c37df08,0x0f97b719)    R(0x0626,0x0c37df08,0x0a478af3,0x09380308)    R(0x0627,0x08077af7,0x06e7ab22,0x07984f1b)    R(0x0628,0x09380308,0x08077af7,0x07984f1b)    R(0x0629,0x1237db44,0x0f97b719,0x0e984f41)    R(0x062a,0x0f97b719,0x0c37df08,0x0e984f41)    R(0x062b,0x06e7ab22,0x0457db66,0x06686b46)\n    R(0x062c,0x07984f1b,0x06e7ab22,0x06686b46)    R(0x062d,0x0b588f39,0x0c37df08,0x09380308)    R(0x062e,0x1237db44,0x0e984f41,0x11487f70)    R(0x062f,0x06686b46,0x0457db66,0x03b87774)    R(0x0630,0x0e984f41,0x0c37df08,0x0b588f39)    R(0x0631,0x09380308,0x07984f1b,0x0818c333)    R(0x0632,0x0b588f39,0x09380308,0x0818c333)    R(0x0633,0x07984f1b,0x06686b46,0x06b8ff30)    R(0x0634,0x11487f70,0x0e984f41,0x0e59076a)    R(0x0635,0x06686b46,0x03b87774,0x0568f74f)\n    R(0x0636,0x0e59076a,0x0e984f41,0x0b588f39)    R(0x0637,0x0818c333,0x07984f1b,0x06b8ff30)    R(0x0638,0x06b8ff30,0x06686b46,0x0568f74f)    R(0x0639,0x12790388,0x11487f70,0x0e59076a)    R(0x063a,0x0b588f39,0x0818c333,0x0a793b55)    R(0x063b,0x0e59076a,0x0b588f39,0x0a793b55)    R(0x063c,0x0818c333,0x06b8ff30,0x06e98336)    R(0x063d,0x0a793b55,0x0818c333,0x06e98336)    R(0x063e,0x06b8ff30,0x0568f74f,0x05099b31)    R(0x063f,0x12790388,0x0e59076a,0x1059d378)\n    R(0x0640,0x0e59076a,0x0a793b55,0x0cd9db69)    R(0x0641,0x06e98336,0x06b8ff30,0x05099b31)    R(0x0642,0x1059d378,0x0e59076a,0x0cd9db69)    R(0x0643,0x0a793b55,0x06e98336,0x097a0753)    R(0x0644,0x0cd9db69,0x0a793b55,0x097a0753)    R(0x0645,0x06e98336,0x05099b31,0x054a3315)    R(0x0646,0x097a0753,0x06e98336,0x06ea7332)    R(0x0647,0x06ea7332,0x06e98336,0x054a3315)    R(0x0648,0x1059d378,0x0cd9db69,0x0e2aaf66)    R(0x0649,0x0cd9db69,0x097a0753,0x0a5ac351)\n    R(0x064a,0x121a9378,0x1059d378,0x0e2aaf66)    R(0x064b,0x0a5ac351,0x097a0753,0x06ea7332)    R(0x064c,0x0e2aaf66,0x0cd9db69,0x0a5ac351)    R(0x064d,0x06ea7332,0x054a3315,0x05bb170a)    R(0x064e,0x0a5ac351,0x06ea7332,0x086b4f32)    R(0x064f,0x121a9378,0x0e2aaf66,0x107b4f57)    R(0x0650,0x06ea7332,0x05bb170a,0x086b4f32)    R(0x0651,0x0e2aaf66,0x0a5ac351,0x0c7b8745)    R(0x0652,0x0e2aaf66,0x0c7b8745,0x107b4f57)    R(0x0653,0x0a5ac351,0x086b4f32,0x0c7b8745)\n    R(0x0654,0x086b4f32,0x05bb170a,0x069bd2f6)    R(0x0655,0x05bb170a,0x03bba6df,0x069bd2f6)    R(0x0656,0x0c7b8745,0x086b4f32,0x09cc0712)    R(0x0657,0x107b4f57,0x0c7b8745,0x103c0b33)    R(0x0658,0x086b4f32,0x069bd2f6,0x09cc0712)    R(0x0659,0x13ac1b31,0x107b4f57,0x103c0b33)    R(0x065a,0x0c7b8745,0x09cc0712,0x0d7c4714)    R(0x065b,0x103c0b33,0x0c7b8745,0x0d7c4714)    R(0x065c,0x069bd2f6,0x03bba6df,0x04ec5ec1)    R(0x065d,0x09cc0712,0x069bd2f6,0x080c86cd)\n    R(0x065e,0x069bd2f6,0x04ec5ec1,0x080c86cd)    R(0x065f,0x01abf482,0x13dfff33,0x00000135)    R(0x0660,0x01abf482,0x13de2333,0x000000a8)    R(0x0661,0x01bbf482,0x129e2213,0xffffffff)    R(0x0662,0x119cd8af,0x0dac7c9d,0x116c1482)    R(0x0663,0x0b6cf4d2,0x09bc44ae,0x0dac7c9d)    R(0x0664,0x0e9d48d4,0x0dac7c9d,0x119cd8af)    R(0x0665,0x0e9d48d4,0x0b6cf4d2,0x0dac7c9d)    R(0x0666,0x084c94e3,0x06abf4cd,0x09bc44ae)    R(0x0667,0x0b6cf4d2,0x084c94e3,0x09bc44ae)\n    R(0x0668,0x121d8ce5,0x0e9d48d4,0x119cd8af)    R(0x0669,0x097d2ce1,0x084c94e3,0x0b6cf4d2)    R(0x066a,0x0c8d70f0,0x0b6cf4d2,0x0e9d48d4)    R(0x066b,0x0b3dd0dd,0x08fdf4d8,0x097d2ce1)    R(0x066c,0x0c8d70f0,0x097d2ce1,0x0b6cf4d2)    R(0x066d,0x097d2ce1,0x08fdf4d8,0x069d1cec)    R(0x066e,0x084c94e3,0x053c3cfc,0x06abf4cd)    R(0x066f,0x0c8d70f0,0x0b3dd0dd,0x097d2ce1)    R(0x0670,0x097d2ce1,0x069d1cec,0x084c94e3)    R(0x0671,0x08fdf4d8,0x071e08ee,0x069d1cec)\n    R(0x0672,0x0f5dd50c,0x0e9d48d4,0x121d8ce5)    R(0x0673,0x0dbdf8f9,0x0b3dd0dd,0x0c8d70f0)    R(0x0674,0x069d1cec,0x053c3cfc,0x084c94e3)    R(0x0675,0x0f5dd50c,0x0c8d70f0,0x0e9d48d4)    R(0x0676,0x069d1cec,0x071e08ee,0x04fdc513)    R(0x0677,0x0f5dd50c,0x0dbdf8f9,0x0c8d70f0)    R(0x0678,0x069d1cec,0x041cf50e,0x053c3cfc)    R(0x0679,0x069d1cec,0x04fdc513,0x041cf50e)    R(0x067a,0x129e1122,0x0f5dd50c,0x121d8ce5)    R(0x067b,0x053c3cfc,0x041cf50e,0x02ac392d)\n    R(0x067c,0x041cf50e,0x04fdc513,0x030d3d3f)    R(0x067d,0x02ac392d,0x041cf50e,0x030d3d3f)    R(0x067e,0x030d3d3f,0x04fdc513,0x044e2150)    R(0x067f,0x01ecc972,0x02ac392d,0x030d3d3f)    R(0x0680,0x01ecc972,0x01bbf55d,0x02ac392d)    R(0x0681,0x02dd9d88,0x030d3d3f,0x044e2150)    R(0x0682,0x01ecc972,0x030d3d3f,0x02dd9d88)    R(0x0683,0x01ec25a9,0x01bbf55d,0x01ecc972)    R(0x0684,0x020cfdc1,0x01ecc972,0x02dd9d88)    R(0x0685,0x020cfdc1,0x01ec25a9,0x01ecc972)\n    R(0x0686,0x020cfdc1,0x02dd9d88,0x036dc5d7)    R(0x0687,0x01bc59fc,0x01ec25a9,0x020cfdc1)    R(0x0688,0x02ed0a11,0x020cfdc1,0x036dc5d7)    R(0x0689,0x02ed0a11,0x01bc59fc,0x020cfdc1)    R(0x068a,0x02ed0a11,0x036dc5d7,0x04adbe13)    R(0x068b,0x01ac05fc,0x13de2333,0xffffffff)    R(0x068c,0x022c8e50,0x01bc59fc,0x02ed0a11)    R(0x068d,0x032cc291,0x01ac4a99,0x022c8e50)    R(0x068e,0x023c2ac4,0x01ac4a99,0x032cc291)    R(0x068f,0x04bd2e4e,0x022c8e50,0x02ed0a11)\n    R(0x0690,0x032cc291,0x022c8e50,0x04bd2e4e)    R(0x0691,0x04ec5ec1,0x023c2ac4,0x032cc291)    R(0x0692,0x04bd2e4e,0x02ed0a11,0x04adbe13)    R(0x0693,0x05ecee92,0x032cc291,0x04bd2e4e)    R(0x0694,0x04ec5ec1,0x032cc291,0x05ecee92)    R(0x0695,0x04bd2e4e,0x04adbe13,0x06edd62f)    R(0x0696,0x080c86cd,0x04ec5ec1,0x05ecee92)    R(0x0697,0x05ecee92,0x04bd2e4e,0x083d925f)    R(0x0698,0x083d925f,0x04bd2e4e,0x06edd62f)    R(0x0699,0x080c86cd,0x05ecee92,0x09ad32a1)\n    R(0x069a,0x09ad32a1,0x05ecee92,0x083d925f)    R(0x069b,0x083d925f,0x06edd62f,0x0a9e1637)    R(0x069c,0x0b5cc2e3,0x080c86cd,0x09ad32a1)    R(0x069d,0x09cc0712,0x080c86cd,0x0b5cc2e3)    R(0x069e,0x09ad32a1,0x083d925f,0x0c3dde78)    R(0x069f,0x0c3dde78,0x083d925f,0x0a9e1637)    R(0x06a0,0x0b5cc2e3,0x09ad32a1,0x0d1d52b2)    R(0x06a1,0x0d7c4714,0x09cc0712,0x0b5cc2e3)    R(0x06a2,0x0d1d52b2,0x09ad32a1,0x0c3dde78)    R(0x06a3,0x0f8ceee1,0x0b5cc2e3,0x0d1d52b2)\n    R(0x06a4,0x0d7c4714,0x0b5cc2e3,0x0f8ceee1)    R(0x06a5,0x104d9a9b,0x0d1d52b2,0x0c3dde78)    R(0x06a6,0x0f8ceee1,0x0d1d52b2,0x104d9a9b)    R(0x06a7,0x104d9a9b,0x0c3dde78,0x107e2260)    R(0x06a8,0x122cb70b,0x0d7c4714,0x0f8ceee1)    R(0x06a9,0x103c0b33,0x0d7c4714,0x122cb70b)    R(0x06aa,0x132d52ce,0x0f8ceee1,0x104d9a9b)    R(0x06ab,0x104d9a9b,0x107e2260,0x13ddee86)    R(0x06ac,0x122cb70b,0x0f8ceee1,0x132d52ce)    R(0x06ad,0x02dd9cd8,0x12cffe78,0x000000ae)\n    R(0x06ae,0x02dd9cd8,0x0c5ffa37,0xffffffff)    R(0x06af,0x0aeea0df,0x08fdf4d8,0x0b3dd0dd)    R(0x06b0,0x0aeea0df,0x089ec4f8,0x08fdf4d8)    R(0x06b1,0x089ec4f8,0x071e08ee,0x08fdf4d8)    R(0x06b2,0x0aeea0df,0x0acf4507,0x089ec4f8)    R(0x06b3,0x066ea521,0x071e08ee,0x089ec4f8)    R(0x06b4,0x04fdc513,0x071e08ee,0x066ea521)    R(0x06b5,0x0acf4507,0x089f6134,0x089ec4f8)    R(0x06b6,0x089f6134,0x066ea521,0x089ec4f8)    R(0x06b7,0x0c2fb932,0x089f6134,0x0acf4507)\n    R(0x06b8,0x044e2150,0x04fdc513,0x066ea521)    R(0x06b9,0x05feed63,0x066ea521,0x089f6134)    R(0x06ba,0x044e2150,0x066ea521,0x05feed63)    R(0x06bb,0x0a8fd96e,0x089f6134,0x0c2fb932)    R(0x06bc,0x05feed63,0x089f6134,0x07ef8579)    R(0x06bd,0x07ef8579,0x089f6134,0x0a8fd96e)    R(0x06be,0x047e6d9e,0x044e2150,0x05feed63)    R(0x06bf,0x02dd9d88,0x044e2150,0x047e6d9e)    R(0x06c0,0x066f25b0,0x05feed63,0x07ef8579)    R(0x06c1,0x092fb9b2,0x07ef8579,0x0a8fd96e)\n    R(0x06c2,0x047e6d9e,0x05feed63,0x066f25b0)    R(0x06c3,0x092fb9b2,0x0a8fd96e,0x0c3ff9a8)    R(0x06c4,0x066f25b0,0x07ef8579,0x092fb9b2)    R(0x06c5,0x036dc5d7,0x02dd9d88,0x047e6d9e)    R(0x06c6,0x055e89e8,0x047e6d9e,0x066f25b0)    R(0x06c7,0x0aefa9e5,0x092fb9b2,0x0c3ff9a8)    R(0x06c8,0x07ef35ec,0x066f25b0,0x092fb9b2)    R(0x06c9,0x036dc5d7,0x047e6d9e,0x055e89e8)    R(0x06ca,0x07ef35ec,0x092fb9b2,0x0aefa9e5)    R(0x06cb,0x055e89e8,0x066f25b0,0x07ef35ec)\n    R(0x06cc,0x04adbe13,0x036dc5d7,0x055e89e8)    R(0x06cd,0x098f1615,0x07ef35ec,0x0aefa9e5)    R(0x06ce,0x06be9219,0x055e89e8,0x07ef35ec)    R(0x06cf,0x098f1615,0x0aefa9e5,0x0c5f6204)    R(0x06d0,0x04adbe13,0x055e89e8,0x06be9219)    R(0x06d1,0x06be9219,0x07ef35ec,0x098f1615)    R(0x06d2,0x0b6e9e1f,0x098f1615,0x0c5f6204)    R(0x06d3,0x08ce5a2c,0x06be9219,0x098f1615)    R(0x06d4,0x06edd62f,0x04adbe13,0x06be9219)    R(0x06d5,0x08ce5a2c,0x098f1615,0x0b6e9e1f)\n    R(0x06d6,0x06edd62f,0x06be9219,0x08ce5a2c)    R(0x06d7,0x0a9e1637,0x08ce5a2c,0x0b6e9e1f)    R(0x06d8,0x0a9e1637,0x06edd62f,0x08ce5a2c)    R(0x06d9,0x0a8dd0dd,0x12cffe78,0xffffffff)    R(0x06da,0x0d3ea4e6,0x0aeea0df,0x0b3dd0dd)    R(0x06db,0x0d3ea4e6,0x0b3dd0dd,0x0dbdf8f9)    R(0x06dc,0x0d3ea4e6,0x0d2f3cfd,0x0aeea0df)    R(0x06dd,0x0d2f3cfd,0x0acf4507,0x0aeea0df)    R(0x06de,0x0f9e6d10,0x0d3ea4e6,0x0dbdf8f9)    R(0x06df,0x0f9f2d0d,0x0d2f3cfd,0x0d3ea4e6)\n    R(0x06e0,0x0f9e6d10,0x0f9f2d0d,0x0d3ea4e6)    R(0x06e1,0x0f9e6d10,0x0dbdf8f9,0x0f5dd50c)    R(0x06e2,0x0eefa52a,0x0d2f3cfd,0x0f9f2d0d)    R(0x06e3,0x0c2fb932,0x0acf4507,0x0d2f3cfd)    R(0x06e4,0x110e4132,0x0f9e6d10,0x0f5dd50c)    R(0x06e5,0x112ec934,0x0f9f2d0d,0x0f9e6d10)    R(0x06e6,0x0eefa52a,0x0c2fb932,0x0d2f3cfd)    R(0x06e7,0x110e4132,0x0f5dd50c,0x129e1122)    R(0x06e8,0x10ff753e,0x0eefa52a,0x0f9f2d0d)    R(0x06e9,0x110e4132,0x112ec934,0x0f9e6d10)\n    R(0x06ea,0x10ff753e,0x0f9f2d0d,0x112ec934)    R(0x06eb,0x0daffd68,0x0c2fb932,0x0eefa52a)    R(0x06ec,0x0fffd95f,0x0eefa52a,0x10ff753e)    R(0x06ed,0x11de8163,0x112ec934,0x110e4132)    R(0x06ee,0x11df016a,0x10ff753e,0x112ec934)    R(0x06ef,0x0fffd95f,0x0daffd68,0x0eefa52a)    R(0x06f0,0x12ce6967,0x11de8163,0x110e4132)    R(0x06f1,0x11df016a,0x112ec934,0x11de8163)    R(0x06f2,0x0daffd68,0x0a8fd96e,0x0c2fb932)    R(0x06f3,0x114fa17f,0x0fffd95f,0x10ff753e)\n    R(0x06f4,0x114fa17f,0x10ff753e,0x11df016a)    R(0x06f5,0x0f3ff199,0x0daffd68,0x0fffd95f)    R(0x06f6,0x11cea19b,0x11df016a,0x11de8163)    R(0x06f7,0x0f3ff199,0x0fffd95f,0x114fa17f)    R(0x06f8,0x0c3ff9a8,0x0a8fd96e,0x0daffd68)    R(0x06f9,0x119f05a0,0x114fa17f,0x11df016a)    R(0x06fa,0x119f05a0,0x11df016a,0x11cea19b)    R(0x06fb,0x0f3ff199,0x0c3ff9a8,0x0daffd68)    R(0x06fc,0x107fa5b5,0x0f3ff199,0x114fa17f)    R(0x06fd,0x107fa5b5,0x114fa17f,0x119f05a0)\n    R(0x06fe,0x106ef9d1,0x119f05a0,0x11cea19b)    R(0x06ff,0x0ddfd1d2,0x0c3ff9a8,0x0f3ff199)    R(0x0700,0x107fa5b5,0x0ddfd1d2,0x0f3ff199)    R(0x0701,0x106ef9d1,0x107fa5b5,0x119f05a0)    R(0x0702,0x104e9dda,0x11cea19b,0x123e95c0)    R(0x0703,0x104e9dda,0x106ef9d1,0x11cea19b)    R(0x0704,0x0aefa9e5,0x0c3ff9a8,0x0ddfd1d2)    R(0x0705,0x106ef9d1,0x0eff7de5,0x107fa5b5)    R(0x0706,0x0eff7de5,0x0ddfd1d2,0x107fa5b5)    R(0x0707,0x10ee760c,0x104e9dda,0x123e95c0)\n    R(0x0708,0x104e9dda,0x0e1ed9ff,0x106ef9d1)    R(0x0709,0x0e1ed9ff,0x0eff7de5,0x106ef9d1)    R(0x070a,0x0c5f6204,0x0aefa9e5,0x0ddfd1d2)    R(0x070b,0x0c5f6204,0x0ddfd1d2,0x0eff7de5)    R(0x070c,0x0dce6e0d,0x0e1ed9ff,0x104e9dda)    R(0x070d,0x0e1ed9ff,0x0c5f6204,0x0eff7de5)    R(0x070e,0x10ee760c,0x0dce6e0d,0x104e9dda)    R(0x070f,0x0b6e9e1f,0x0c5f6204,0x0e1ed9ff)    R(0x0710,0x0dce6e0d,0x0b6e9e1f,0x0e1ed9ff)    R(0x0711,0x0d9e423b,0x0dce6e0d,0x10ee760c)\n    R(0x0712,0x0a9e1637,0x0b6e9e1f,0x0dce6e0d)    R(0x0713,0x0d9e423b,0x0a9e1637,0x0dce6e0d)    R(0x0714,0x107e2260,0x0d9e423b,0x10ee760c)    R(0x0715,0x0c3dde78,0x0a9e1637,0x0d9e423b)    R(0x0716,0x0c3dde78,0x0d9e423b,0x107e2260)    R(0x0717,0x10370c3b,0x290ea38e,0x00000298)    R(0x0718,0x10470c3b,0x290ea22a,0x0000011e)    R(0x0719,0x10470c3b,0x1ccea21b,0x0000009c)    R(0x071a,0x10470c3b,0x1ccd20c7,0xffffffff)    R(0x071b,0x1ae83c74,0x19873c62,0x1b67789f)\n    R(0x071c,0x1898004d,0x1537f43b,0x16c70c47)    R(0x071d,0x1ae83c74,0x1898004d,0x19873c62)    R(0x071e,0x1c6848b0,0x1ae83c74,0x1b67789f)    R(0x071f,0x16e8d046,0x1537f43b,0x1898004d)    R(0x0720,0x13a9083e,0x1197e840,0x1537f43b)    R(0x0721,0x19a90458,0x1898004d,0x1ae83c74)    R(0x0722,0x1b99288e,0x1ae83c74,0x1c6848b0)    R(0x0723,0x13a9083e,0x1537f43b,0x16e8d046)    R(0x0724,0x19a90458,0x16e8d046,0x1898004d)    R(0x0725,0x1b99288e,0x19a90458,0x1ae83c74)\n    R(0x0726,0x16f9d04f,0x16e8d046,0x19a90458)    R(0x0727,0x16f9d04f,0x13a9083e,0x16e8d046)    R(0x0728,0x1a09f470,0x19a90458,0x1b99288e)    R(0x0729,0x130a144c,0x10499045,0x13a9083e)    R(0x072a,0x1a09f470,0x16f9d04f,0x19a90458)    R(0x072b,0x16f9d04f,0x130a144c,0x13a9083e)    R(0x072c,0x1cca009e,0x1a09f470,0x1b99288e)    R(0x072d,0x18bac871,0x16f9d04f,0x1a09f470)    R(0x072e,0x156ac05d,0x130a144c,0x16f9d04f)    R(0x072f,0x1c1ae88f,0x1a09f470,0x1cca009e)\n    R(0x0730,0x18bac871,0x156ac05d,0x16f9d04f)    R(0x0731,0x1c1ae88f,0x18bac871,0x1a09f470)    R(0x0732,0x156ac05d,0x112b0c5a,0x130a144c)    R(0x0733,0x17cbb87f,0x156ac05d,0x18bac871)    R(0x0734,0x143b946f,0x112b0c5a,0x156ac05d)    R(0x0735,0x1b1bd09a,0x18bac871,0x1c1ae88f)    R(0x0736,0x17cbb87f,0x143b946f,0x156ac05d)    R(0x0737,0x1b1bd09a,0x17cbb87f,0x18bac871)    R(0x0738,0x116c1482,0x112b0c5a,0x143b946f)    R(0x0739,0x153c7090,0x143b946f,0x17cbb87f)\n    R(0x073a,0x153c7090,0x116c1482,0x143b946f)    R(0x073b,0x18bc9ca2,0x17cbb87f,0x1b1bd09a)    R(0x073c,0x18bc9ca2,0x153c7090,0x17cbb87f)    R(0x073d,0x1c8c9cc7,0x18bc9ca2,0x1b1bd09a)    R(0x073e,0x119cd8af,0x116c1482,0x153c7090)    R(0x073f,0x158d20ba,0x153c7090,0x18bc9ca2)    R(0x0740,0x158d20ba,0x119cd8af,0x153c7090)    R(0x0741,0x10ec9ca2,0x1c8ea21b,0xffffffff)    R(0x0742,0x192d4cd4,0x158d20ba,0x18bc9ca2)    R(0x0743,0x192d4cd4,0x18bc9ca2,0x1c8c9cc7)\n    R(0x0744,0x121d8ce5,0x119cd8af,0x158d20ba)    R(0x0745,0x160db8f7,0x158d20ba,0x192d4cd4)    R(0x0746,0x160db8f7,0x121d8ce5,0x158d20ba)    R(0x0747,0x1c3d7105,0x192d4cd4,0x1c8c9cc7)    R(0x0748,0x192de91d,0x160db8f7,0x192d4cd4)    R(0x0749,0x192de91d,0x192d4cd4,0x1c3d7105)    R(0x074a,0x129e1122,0x121d8ce5,0x160db8f7)    R(0x074b,0x15be3143,0x160db8f7,0x192de91d)    R(0x074c,0x15be3143,0x129e1122,0x160db8f7)    R(0x074d,0x1c4de94f,0x192de91d,0x1c3d7105)\n    R(0x074e,0x12ce6967,0x110e4132,0x129e1122)    R(0x074f,0x12ce6967,0x129e1122,0x15be3143)    R(0x0750,0x18ce416e,0x15be3143,0x192de91d)    R(0x0751,0x18ce416e,0x192de91d,0x1c4de94f)    R(0x0752,0x152e7999,0x12ce6967,0x15be3143)    R(0x0753,0x152e7999,0x15be3143,0x18ce416e)    R(0x0754,0x1bbe2da0,0x18ce416e,0x1c4de94f)    R(0x0755,0x11cea19b,0x11de8163,0x12ce6967)    R(0x0756,0x123e95c0,0x12ce6967,0x152e7999)    R(0x0757,0x123e95c0,0x11cea19b,0x12ce6967)\n    R(0x0758,0x187e6dc8,0x152e7999,0x18ce416e)    R(0x0759,0x187e6dc8,0x18ce416e,0x1bbe2da0)    R(0x075a,0x14ee85ef,0x123e95c0,0x152e7999)    R(0x075b,0x14ee85ef,0x152e7999,0x187e6dc8)    R(0x075c,0x1bce35f8,0x187e6dc8,0x1bbe2da0)    R(0x075d,0x10ee760c,0x123e95c0,0x14ee85ef)    R(0x075e,0x183e5a1b,0x14ee85ef,0x187e6dc8)    R(0x075f,0x183e5a1b,0x187e6dc8,0x1bce35f8)    R(0x0760,0x1b17508e,0x290e362a,0x000000c1)    R(0x0761,0x1b67508e,0x290b5a11,0xffffffff)\n    R(0x0762,0x1c6848b0,0x1b67789f,0x1d175cca)    R(0x0763,0x1dd910b6,0x1b99288e,0x1c6848b0)    R(0x0764,0x1cca009e,0x1b99288e,0x1dd910b6)    R(0x0765,0x1c1ae88f,0x1cca009e,0x1f5ac0b8)    R(0x0766,0x1f282cc6,0x1c6848b0,0x1d175cca)    R(0x0767,0x1dd910b6,0x1c6848b0,0x1f282cc6)    R(0x0768,0x1ff9d4bc,0x1cca009e,0x1dd910b6)    R(0x0769,0x1f5ac0b8,0x1cca009e,0x1ff9d4bc)    R(0x076a,0x217910cc,0x1dd910b6,0x1f282cc6)    R(0x076b,0x1ff9d4bc,0x1dd910b6,0x217910cc)\n    R(0x076c,0x223834f1,0x1f282cc6,0x206750ee)    R(0x076d,0x1f5ac0b8,0x1ff9d4bc,0x22ca2cd6)    R(0x076e,0x217910cc,0x1f282cc6,0x223834f1)    R(0x076f,0x220b40db,0x1f5ac0b8,0x22ca2cd6)    R(0x0770,0x22ca2cd6,0x1ff9d4bc,0x217910cc)    R(0x0771,0x23f928f3,0x217910cc,0x223834f1)    R(0x0772,0x22ca2cd6,0x217910cc,0x23f928f3)    R(0x0773,0x220b40db,0x22ca2cd6,0x24cae103)    R(0x0774,0x25385d2a,0x223834f1,0x23776126)    R(0x0775,0x23f928f3,0x223834f1,0x25385d2a)\n    R(0x0776,0x2549f900,0x22ca2cd6,0x23f928f3)    R(0x0777,0x24cae103,0x22ca2cd6,0x2549f900)    R(0x0778,0x25385d2a,0x23776126,0x25d7ad64)    R(0x0779,0x26995534,0x23f928f3,0x25385d2a)    R(0x077a,0x26995534,0x2549f900,0x23f928f3)    R(0x077b,0x24cae103,0x2549f900,0x270a593b)    R(0x077c,0x263b5943,0x24cae103,0x270a593b)    R(0x077d,0x2788a568,0x25385d2a,0x25d7ad64)    R(0x077e,0x270a593b,0x2549f900,0x26995534)    R(0x077f,0x26995534,0x25385d2a,0x2788a568)\n    R(0x0780,0x2788a568,0x25d7ad64,0x279815aa)    R(0x0781,0x263b5943,0x270a593b,0x282ac57b)    R(0x0782,0x2859b971,0x270a593b,0x26995534)    R(0x0783,0x2859b971,0x26995534,0x2788a568)    R(0x0784,0x285895f8,0x279815aa,0x274799f5)    R(0x0785,0x282ac57b,0x270a593b,0x2859b971)    R(0x0786,0x28a919ae,0x2788a568,0x279815aa)    R(0x0787,0x2859b971,0x2788a568,0x28a919ae)    R(0x0788,0x28a919ae,0x279815aa,0x285895f8)    R(0x0789,0x27eb5a11,0x284b19c4,0x28ea8605)\n    R(0x078a,0x284b19c4,0x282ac57b,0x290a25b6)    R(0x078b,0x290a25b6,0x282ac57b,0x2859b971)    R(0x078c,0x28f995fc,0x28a919ae,0x285895f8)    R(0x078d,0x290a25b6,0x2859b971,0x28a919ae)    R(0x078e,0x28ea8605,0x284b19c4,0x290a25b6)    R(0x078f,0x290a25b6,0x28a919ae,0x28f995fc)    R(0x0790,0x28ea8605,0x290a25b6,0x28f995fc)    R(0x0791,0x1b1ac08f,0x284e362a,0xffffffff)    R(0x0792,0x1e7bb4b7,0x1c1ae88f,0x1f5ac0b8)    R(0x0793,0x26cbbd8b,0x282ac57b,0x284b19c4)\n    R(0x0794,0x1e7bb4b7,0x1f5ac0b8,0x220b40db)    R(0x0795,0x26cbbd8b,0x263b5943,0x282ac57b)    R(0x0796,0x23abdd11,0x220b40db,0x24cae103)    R(0x0797,0x23abdd11,0x24cae103,0x263b5943)    R(0x0798,0x1e7bb4b7,0x1b1bd09a,0x1c1ae88f)    R(0x0799,0x26bc05da,0x284b19c4,0x27eb5a11)    R(0x079a,0x26bc05da,0x26cbbd8b,0x284b19c4)    R(0x079b,0x20ac30e3,0x1e7bb4b7,0x220b40db)    R(0x079c,0x20ac30e3,0x220b40db,0x23abdd11)    R(0x079d,0x249c4956,0x263b5943,0x26cbbd8b)\n    R(0x079e,0x265c122a,0x26bc05da,0x27eb5a11)    R(0x079f,0x249c4956,0x23abdd11,0x263b5943)    R(0x07a0,0x1c8c9cc7,0x1b1bd09a,0x1e7bb4b7)    R(0x07a1,0x24bca1a8,0x26cbbd8b,0x26bc05da)    R(0x07a2,0x20ac30e3,0x1c8c9cc7,0x1e7bb4b7)    R(0x07a3,0x24bca1a8,0x249c4956,0x26cbbd8b)    R(0x07a4,0x21fcb125,0x20ac30e3,0x23abdd11)    R(0x07a5,0x24bcc1fd,0x26bc05da,0x265c122a)    R(0x07a6,0x21fcb125,0x23abdd11,0x249c4956)    R(0x07a7,0x24bcc1fd,0x24bca1a8,0x26bc05da)\n    R(0x07a8,0x1efce4f8,0x1c8c9cc7,0x20ac30e3)    R(0x07a9,0x21fcb125,0x1efce4f8,0x20ac30e3)    R(0x07aa,0x225d1174,0x249c4956,0x24bca1a8)    R(0x07ab,0x225d1174,0x21fcb125,0x249c4956)    R(0x07ac,0x220d59ce,0x24bca1a8,0x24bcc1fd)    R(0x07ad,0x1c3d7105,0x1c8c9cc7,0x1efce4f8)    R(0x07ae,0x1f5d653c,0x1efce4f8,0x21fcb125)    R(0x07af,0x220d59ce,0x225d1174,0x24bca1a8)    R(0x07b0,0x225d1174,0x1f5d653c,0x21fcb125)    R(0x07b1,0x227d3e22,0x220d59ce,0x24bcc1fd)\n    R(0x07b2,0x1f5d653c,0x1c3d7105,0x1efce4f8)    R(0x07b3,0x220d59ce,0x1f6dad85,0x225d1174)    R(0x07b4,0x1f6dad85,0x1f5d653c,0x225d1174)    R(0x07b5,0x227d3e22,0x1f5dce0a,0x220d59ce)    R(0x07b6,0x1c4de94f,0x1c3d7105,0x1f5d653c)    R(0x07b7,0x1eade5c8,0x1f6dad85,0x220d59ce)    R(0x07b8,0x1f6dad85,0x1c4de94f,0x1f5d653c)    R(0x07b9,0x1f5dce0a,0x1eade5c8,0x220d59ce)    R(0x07ba,0x1eade5c8,0x1bbe2da0,0x1f6dad85)    R(0x07bb,0x1bbe2da0,0x1c4de94f,0x1f6dad85)\n    R(0x07bc,0x1bce35f8,0x1eade5c8,0x1f5dce0a)    R(0x07bd,0x1bce35f8,0x1bbe2da0,0x1eade5c8)    R(0x07be,0x103721ef,0x28fe878e,0x0000013a)    R(0x07bf,0x103761ef,0x1e4e878e,0x000000c5)    R(0x07c0,0x105762ea,0x1e4c6b8e,0xffffffff)    R(0x07c1,0x1507b348,0x12676323,0x1237db44)    R(0x07c2,0x17c7c342,0x1507b348,0x16d83f6e)    R(0x07c3,0x1507b348,0x1237db44,0x14285380)    R(0x07c4,0x1a57d737,0x17c7c342,0x19685f4a)    R(0x07c5,0x1e47db1b,0x1a57d737,0x1be88f26)\n    R(0x07c6,0x16d83f6e,0x1507b348,0x14285380)    R(0x07c7,0x19685f4a,0x17c7c342,0x16d83f6e)    R(0x07c8,0x14285380,0x1237db44,0x11487f70)    R(0x07c9,0x1be88f26,0x1a57d737,0x19685f4a)    R(0x07ca,0x16d83f6e,0x14285380,0x1598eb8e)    R(0x07cb,0x19685f4a,0x16d83f6e,0x1868fb79)    R(0x07cc,0x14285380,0x11487f70,0x12790388)    R(0x07cd,0x1be88f26,0x19685f4a,0x1ac9173f)    R(0x07ce,0x1868fb79,0x16d83f6e,0x1598eb8e)    R(0x07cf,0x1598eb8e,0x14285380,0x12790388)\n    R(0x07d0,0x1ac9173f,0x19685f4a,0x1868fb79)    R(0x07d1,0x1c596314,0x1be88f26,0x1ac9173f)    R(0x07d2,0x1598eb8e,0x12790388,0x1429b386)    R(0x07d3,0x1868fb79,0x1598eb8e,0x1799bf7e)    R(0x07d4,0x1ac9173f,0x1868fb79,0x19e9c364)    R(0x07d5,0x1799bf7e,0x1598eb8e,0x1429b386)    R(0x07d6,0x1c596314,0x1ac9173f,0x1bb9f728)    R(0x07d7,0x19e9c364,0x1868fb79,0x1799bf7e)    R(0x07d8,0x1429b386,0x12790388,0x1059d378)    R(0x07d9,0x1bb9f728,0x1ac9173f,0x19e9c364)\n    R(0x07da,0x1cda5eff,0x1c596314,0x1bb9f728)    R(0x07db,0x1799bf7e,0x1429b386,0x162a8771)    R(0x07dc,0x1429b386,0x1059d378,0x121a9378)    R(0x07dd,0x19e9c364,0x1799bf7e,0x199a9b59)    R(0x07de,0x1bb9f728,0x19e9c364,0x199a9b59)    R(0x07df,0x162a8771,0x1429b386,0x121a9378)    R(0x07e0,0x199a9b59,0x1799bf7e,0x162a8771)    R(0x07e1,0x1cda5eff,0x1bb9f728,0x1b8acf1f)    R(0x07e2,0x1bb9f728,0x199a9b59,0x1b8acf1f)    R(0x07e3,0x199a9b59,0x162a8771,0x179b4753)\n    R(0x07e4,0x162a8771,0x121a9378,0x144b575a)    R(0x07e5,0x1b8acf1f,0x199a9b59,0x19fb9b25)    R(0x07e6,0x162a8771,0x144b575a,0x179b4753)    R(0x07e7,0x121a9378,0x107b4f57,0x144b575a)    R(0x07e8,0x199a9b59,0x179b4753,0x19fb9b25)    R(0x07e9,0x1b8acf1f,0x19fb9b25,0x1cab7afb)    R(0x07ea,0x179b4753,0x144b575a,0x16fc0b2d)    R(0x07eb,0x144b575a,0x107b4f57,0x13ac1b31)    R(0x07ec,0x19fb9b25,0x179b4753,0x16fc0b2d)    R(0x07ed,0x1cab7afb,0x19fb9b25,0x1c5c42ea)\n    R(0x07ee,0x16fc0b2d,0x144b575a,0x13ac1b31)    R(0x07ef,0x19fb9b25,0x16fc0b2d,0x192c6afb)    R(0x07f0,0x19fb9b25,0x192c6afb,0x1c5c42ea)    R(0x07f1,0x103c09ef,0x1d5e8733,0xffffffff)    R(0x07f2,0x144e523c,0x10ee760c,0x14ee85ef)    R(0x07f3,0x144e523c,0x14ee85ef,0x183e5a1b)    R(0x07f4,0x1b8dfe47,0x183e5a1b,0x1bce35f8)    R(0x07f5,0x144e523c,0x107e2260,0x10ee760c)    R(0x07f6,0x17ae1667,0x144e523c,0x183e5a1b)    R(0x07f7,0x17ae1667,0x183e5a1b,0x1b8dfe47)\n    R(0x07f8,0x13ddee86,0x107e2260,0x144e523c)    R(0x07f9,0x17ae1667,0x13ddee86,0x144e523c)    R(0x07fa,0x1a0db292,0x17ae1667,0x1b8dfe47)    R(0x07fb,0x1a0db292,0x1b8dfe47,0x1d5d6680)    R(0x07fc,0x168d9aae,0x13ddee86,0x17ae1667)    R(0x07fd,0x1a0db292,0x168d9aae,0x17ae1667)    R(0x07fe,0x1bccfec1,0x1a0db292,0x1d5d6680)    R(0x07ff,0x132d52ce,0x104d9a9b,0x13ddee86)    R(0x0800,0x132d52ce,0x13ddee86,0x168d9aae)    R(0x0801,0x18ad26d3,0x168d9aae,0x1a0db292)\n    R(0x0802,0x1bccfec1,0x18ad26d3,0x1a0db292)    R(0x0803,0x159cd2fa,0x132d52ce,0x168d9aae)    R(0x0804,0x159cd2fa,0x168d9aae,0x18ad26d3)    R(0x0805,0x192c6afb,0x18ad26d3,0x1bccfec1)    R(0x0806,0x1c5c42ea,0x192c6afb,0x1bccfec1)    R(0x0807,0x192c6afb,0x159cd2fa,0x18ad26d3)    R(0x0808,0x159cd2fa,0x122cb70b,0x132d52ce)    R(0x0809,0x16fc0b2d,0x159cd2fa,0x192c6afb)    R(0x080a,0x13ac1b31,0x122cb70b,0x159cd2fa)    R(0x080b,0x16fc0b2d,0x13ac1b31,0x159cd2fa)\n    R(0x080c,0x13ac1b31,0x103c0b33,0x122cb70b)    R(0x080d,0x1b8721f5,0x28fe3726,0xffffffff)    R(0x080e,0x27781e41,0x26672241,0x25b7c683)    R(0x080f,0x24a86abf,0x25b7c683,0x23777ac4)    R(0x0810,0x24a86abf,0x23777ac4,0x2167f2f1)    R(0x0811,0x285895f8,0x274799f5,0x27781e41)    R(0x0812,0x2167f2f1,0x1e47db1b,0x1f68d30c)    R(0x0813,0x26c8ba87,0x27781e41,0x25b7c683)    R(0x0814,0x26c8ba87,0x25b7c683,0x24a86abf)    R(0x0815,0x24a86abf,0x2167f2f1,0x22b8dae8)\n    R(0x0816,0x1f68d30c,0x1e47db1b,0x1be88f26)    R(0x0817,0x22b8dae8,0x2167f2f1,0x1f68d30c)    R(0x0818,0x28491e43,0x285895f8,0x27781e41)    R(0x0819,0x28491e43,0x27781e41,0x26c8ba87)    R(0x081a,0x25197ebf,0x26c8ba87,0x24a86abf)    R(0x081b,0x25197ebf,0x24a86abf,0x22b8dae8)    R(0x081c,0x1f68d30c,0x1be88f26,0x1c596314)    R(0x081d,0x28f995fc,0x285895f8,0x28491e43)    R(0x081e,0x21e9b2ef,0x22b8dae8,0x1f68d30c)    R(0x081f,0x2749a283,0x28491e43,0x26c8ba87)\n    R(0x0820,0x2749a283,0x26c8ba87,0x25197ebf)    R(0x0821,0x1e79bf09,0x1f68d30c,0x1c596314)    R(0x0822,0x25197ebf,0x22b8dae8,0x21e9b2ef)    R(0x0823,0x21e9b2ef,0x1f68d30c,0x1e79bf09)    R(0x0824,0x286a1e48,0x28f995fc,0x28491e43)    R(0x0825,0x286a1e48,0x28491e43,0x2749a283)    R(0x0826,0x1e79bf09,0x1c596314,0x1cda5eff)    R(0x0827,0x23ba66ca,0x25197ebf,0x21e9b2ef)    R(0x0828,0x266a7a90,0x2749a283,0x25197ebf)    R(0x0829,0x21e9b2ef,0x1e79bf09,0x203a82ec)\n    R(0x082a,0x28ea8605,0x28f995fc,0x286a1e48)    R(0x082b,0x266a7a90,0x286a1e48,0x2749a283)    R(0x082c,0x23ba66ca,0x266a7a90,0x25197ebf)    R(0x082d,0x23ba66ca,0x21e9b2ef,0x203a82ec)    R(0x082e,0x203a82ec,0x1e79bf09,0x1cda5eff)    R(0x082f,0x279b0656,0x286a1e48,0x266a7a90)    R(0x0830,0x279b0656,0x28ea8605,0x286a1e48)    R(0x0831,0x203a82ec,0x1cda5eff,0x1e7b1add)    R(0x0832,0x24bb3a9d,0x266a7a90,0x23ba66ca)    R(0x0833,0x219b3ec1,0x23ba66ca,0x203a82ec)\n    R(0x0834,0x1cda5eff,0x1b8acf1f,0x1cab7afb)    R(0x0835,0x24bb3a9d,0x279b0656,0x266a7a90)    R(0x0836,0x203a82ec,0x1e7b1add,0x219b3ec1)    R(0x0837,0x219b3ec1,0x24bb3a9d,0x23ba66ca)    R(0x0838,0x279b0656,0x27eb5a11,0x28ea8605)    R(0x0839,0x1cda5eff,0x1cab7afb,0x1e7b1add)    R(0x083a,0x25abbe6b,0x279b0656,0x24bb3a9d)    R(0x083b,0x1e7b1add,0x1f3beac5,0x219b3ec1)    R(0x083c,0x265c122a,0x27eb5a11,0x279b0656)    R(0x083d,0x1e7b1add,0x1cab7afb,0x1f3beac5)\n    R(0x083e,0x219b3ec1,0x228c1e91,0x24bb3a9d)    R(0x083f,0x25abbe6b,0x265c122a,0x279b0656)    R(0x0840,0x228c1e91,0x25abbe6b,0x24bb3a9d)    R(0x0841,0x1f3beac5,0x228c1e91,0x219b3ec1)    R(0x0842,0x1cab7afb,0x1c5c42ea,0x1f3beac5)    R(0x0843,0x242c9251,0x265c122a,0x25abbe6b)    R(0x0844,0x228c1e91,0x242c9251,0x25abbe6b)    R(0x0845,0x1f3beac5,0x1efcaaa5,0x228c1e91)    R(0x0846,0x1f3beac5,0x1c5c42ea,0x1efcaaa5)    R(0x0847,0x242c9251,0x24bcc1fd,0x265c122a)\n    R(0x0848,0x228c1e91,0x213cfa6e,0x242c9251)    R(0x0849,0x1efcaaa5,0x213cfa6e,0x228c1e91)    R(0x084a,0x1c5c42ea,0x1bccfec1,0x1efcaaa5)    R(0x084b,0x227d3e22,0x24bcc1fd,0x242c9251)    R(0x084c,0x213cfa6e,0x227d3e22,0x242c9251)    R(0x084d,0x1efcaaa5,0x1d5d6680,0x213cfa6e)    R(0x084e,0x1bccfec1,0x1d5d6680,0x1efcaaa5)    R(0x084f,0x213cfa6e,0x1f5d8a46,0x227d3e22)    R(0x0850,0x1d5d6680,0x1f5d8a46,0x213cfa6e)    R(0x0851,0x1f5d8a46,0x1f5dce0a,0x227d3e22)\n    R(0x0852,0x1d5d6680,0x1b8dfe47,0x1f5d8a46)    R(0x0853,0x1b8dfe47,0x1f5dce0a,0x1f5d8a46)    R(0x0854,0x1b8dfe47,0x1bce35f8,0x1f5dce0a)  }\n  return r;\n}\n\nvec4 encode_int(in int x) {\n    ivec4 col = (ivec4(x)>>ivec4(0,8,16,24))&255;\n    return vec4(col)/255.0;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Test whether data should be sent. Data is sent if:\n    //  this is the first frame or\n    //  rendering area was resized (previous width/height stored in first pixel)\n    bool reset = (iFrame < 10);\n    reset = reset || (get_data(RESOLUTION_OFFSET,0) != int(iChannelResolution[0].x));\n    reset = reset || (get_data(RESOLUTION_OFFSET,1) != int(iChannelResolution[0].y));\n    if(reset) {  \n       ivec2 uv = ivec2(fragCoord); \n       int index = uv.x + uv.y * int(iResolution.x); \n       if(index < 2) {\n           fragColor = encode_int(int(iResolution[index]));\n       } else {\n          index -= MESH_DATA_OFFSET;\n          if(index < AABB_data_size*3) {\n            int comp = index % 3;\n            index = index / 3;\n            ivec3 P = AABB_data(index);\n            fragColor = encode_int(P[comp]);    \n          } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n       }\n    } else {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n}\n ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 626, 626, 776], [970, 970, 1033, 1033, 1331], [1333, 1333, 1370, 1370, 1473], [1547, 1547, 1576, 1576, 1682], [1684, 1684, 1730, 1730, 1774], [1776, 1776, 1848, 1848, 1910], [1912, 1912, 2042, 2042, 2398], [2400, 2400, 2471, 2471, 2664], [2667, 2667, 2783, 2783, 3071], [3128, 3128, 3148, 3148, 3176], [3178, 3178, 3215, 3215, 3286], [3288, 3288, 3326, 3326, 3395], [3397, 3397, 3426, 3426, 3555], [3557, 3557, 3604, 3604, 3637], [3639, 3639, 3686, 3686, 3719], [3721, 3721, 3769, 3769, 5225], [5229, 5305, 5361, 5361, 6124], [6126, 6126, 6146, 6146, 6259], [6261, 6261, 6318, 6318, 7035]], "test": "untested"}
{"id": "WltSR7", "name": "Fluid trail", "author": "Ref", "description": "Fluid trail", "tags": ["fluid", "backbuffer"], "likes": 3, "viewed": 450, "published": 3, "date": "1580657000", "time_retrieved": "2024-07-30T21:26:20.099557", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ADD_POWER 5.0\n#define DIFFUSE_RATE 0.125\n#define FADE_RATE 0.458\n\nfloat hash11(float t)\n{\n    return fract(sin(t * 12.9898) * 43758.5453);\n}\n\nfloat noise11(float t)\n{\n    float i = floor(t);\n    float f = fract(t);\n\t\n\tfloat u = f*f*(3.0-2.0*f);\n\n    return mix(hash11(i + 0.0), \n               hash11(i + 1.0), u);\n}\n\nvec3 hue2rgb(float hue)\n{\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\nvoid add(inout vec3 col, vec2 cen, vec2 pos, vec2 res, float offset)\n{\n    float dist = distance(cen / res, pos / res) * ADD_POWER;\n    col += hue2rgb(fract(iTime * 0.1 + offset)) * (1.0 - clamp(dist, 0.0, 1.0));\n}\n\nvoid diffuse(inout vec3 col, vec2 pos, vec2 res)\n{\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            col += texture(iChannel0, (pos + vec2(x, y)) / res).rgb * DIFFUSE_RATE;\n        }\n    }\n}\n\nvoid fade(inout vec3 col)\n{  \n    col *= FADE_RATE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float res = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    if(iMouse.z >= 0.0001)\n    {\n        add(col, iMouse.xy, fragCoord, vec2(res, res), 0.0);\n    }\n    \n    vec2 pos = vec2(noise11(iTime + 698.355), noise11(iTime + 358.647)) * iResolution.xy;\n    add(col, pos, fragCoord, vec2(res, res), 0.25);\n    pos = vec2(noise11(iTime + 124.408), noise11(iTime + 124.957)) * iResolution.xy;\n    add(col, pos, fragCoord, vec2(res, res), 0.50);\n    pos = vec2(noise11(iTime + 305.047), noise11(iTime + 684.105)) * iResolution.xy;\n    add(col, pos, fragCoord, vec2(res, res), 0.75);\n    \n    diffuse(col, fragCoord, iResolution.xy);   \n    fade(col);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 177]], "test": "untested"}
{"id": "3ldSR7", "name": "Path Traced Cake", "author": "angelo12", "description": "Part 1, just rough shapes and rendering code.", "tags": ["pathtracing"], "likes": 3, "viewed": 382, "published": 3, "date": "1580655939", "time_retrieved": "2024-07-30T21:26:20.846558", "image_code": "/*\n\tShader Sundays! (5/52) \n\t\"Office Cake Part 1\"\n\t\n\tThis week I've started my first attempt at a path traced cake. It looks kinda boring now but the idea\n\tis to come in next week and make it a bit more interesting. \n\n*/\n\n#define INV_GAMMA  0.454545\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec2 uv = (fragPos) /iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n    }\n\n    col *= 2.5;// Exposure\n    col = pow(col, vec3(INV_GAMMA)); //Gamma correction\n    fragColor = vec4(col, 1.0);\n}   ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 304, 304, 593]], "test": "untested"}
{"id": "WtdXzM", "name": "japanese traditional textile pt1", "author": "yasuo", "description": "japanese traditional textile pack part1", "tags": ["textile"], "likes": 9, "viewed": 424, "published": 3, "date": "1580652610", "time_retrieved": "2024-07-30T21:26:21.591566", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions2d\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 textile1(vec2 p, vec3 col, vec3 rhcol) {\n    vec2 size = vec2(0.04,0.1);\n    float rh = sdRhombus(p,size);\n    col = mix(col, rhcol,S(rh,-0.01));\n    \n    rh = sdRhombus((p+vec2(0.1,0.06))*Rot(radians(-65.0)),size);\n    col = mix(col, rhcol,S(rh,-0.01));      \n    \n    rh = sdRhombus((p+vec2(-0.1,0.06))*Rot(radians(65.0)),size);\n    col = mix(col, rhcol,S(rh,-0.01));   \n    return col;\n}\n\nvec3 jpTraditionalTex1(vec2 p, vec3 col, vec3 rhcol) {\n    vec2 pref = p;\n    \n    float scale = 1.5;\n    p*=scale;\n    p.x = mod(p.x,0.42)-0.21;\n    p.y = mod(p.y,0.22)-0.11;\n\n\tp.y = abs(p.y);\n    p.y -= 0.11;\n    col = textile1(p,col,rhcol);\n    \n    p = pref;\n    p*=scale;\n    p.x -= 0.21;\n    p.x = mod(p.x,0.42)-0.21;\n    p.y = mod(p.y,0.44)-0.22;\n    p.y = abs(p.y);\n    p.y -= 0.11;\n\tfloat rh = sdRhombus(p,vec2(0.04,0.1));\n    col = mix(col, rhcol,S(rh,-0.01));\n    \n    return col;\n}\n\nvec3 textile2(vec2 p, vec3 col, vec3 bcol){\nfloat bsize = 0.15;\n    p *= Rot(radians(45.0));\n    float b = dBox2d(p,vec2(bsize));\n    p = abs(p);\n    p.x -= 0.067;\n    p.y -= 0.067;\n    float b2 = dBox2d(p,vec2(bsize/3.0));\n    b = max(-b2,b);\n    col = mix(col, bcol,S(b,-0.01));\n    return col;\n}\n\nvec3 jpTraditionalTex2(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n\n    float scale = 1.5;\n    p*=scale;\n    \n    p = mod(p,0.45)-0.225;\n    col = textile2(p,col,bcol);\n    \n    p = pref;\n    p*=scale;\n    p -= 0.225;\n    p = mod(p,0.45)-0.225;\n    col = textile2(p,col,bcol);\n    \n    return col;\n}\n\nvec3 jpTraditionalTex3(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    p.x = mod(p.x,0.25)-(0.25*0.5);\n    p.y = mod(p.y,0.26)-(0.26*0.5);\n    \n    float r = 0.15;\n    p = abs(p);\n    p.x -= 0.06;\n    p.y -= 0.065;\n    \n    float c = sdVesica(p*Rot(radians(-45.0)),r-0.02,r*0.63);\n    col = mix(col, ccol,S(c,0.0));\n    \n    return col;\n}\n\nvec3 textile4(vec2 p, vec3 col, vec3 ccol){\n    float r = 0.16;\n    \n    float c =sdPie(p,vec2(0.16,0.1),r);\n    c = max(-(length(p)-0.05),c);\n    col = mix(col, ccol,S(c,0.0)); \n    c =sdPie(p,vec2(0.16,0.1),r-0.02);\n    c = max(-(length(p)-0.075),c);\n    col = mix(col, vec3(1.0),S(c,0.0)); \n    c =sdPie(p,vec2(0.16,0.1),r-0.037);\n    c = max(-(length(p)-0.095),c);\n    col = mix(col, ccol,S(c,0.0)); \n    c = length(p-vec2(0.0,0.015))-0.02;\n    col = mix(col, vec3(1.0),S(c,0.0)); \n    return col;\n}\n\nvec3 jpTraditionalTex4(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    p.x = mod(p.x,0.4)-(0.2);\n    p.y = mod(p.y,0.18)-(0.09);\n    p.y +=0.085;\n    col = textile4(p,col,ccol);\n    p= pref;\n    \n    p.x += 0.2;\n    p.y -=0.085;\n    p.x = mod(p.x,0.4)-(0.2);\n    p.y = mod(p.y,0.18)-(0.09);\n    p.y +=0.085;\n    col = textile4(p,col,ccol);\n    return col;\n}\n\nvec3 textile5(vec2 p, vec3 col, vec3 ccol){\n    vec2 pref = p;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    float c = sdEllipse(p,vec2(0.04,0.06));\n    float c2 = sdEllipse((p-vec2(-0.02,-0.01))*Rot(radians(-10.0)),vec2(0.04,0.05));\n    float c3 = sdEllipse((p-vec2(0.02,-0.01))*Rot(radians(10.0)),vec2(0.04,0.05));\n    c = min(c, min(c2,c3));\n    c = max(-(length(p-vec2(0.0,-0.05))-0.04),c);\n\tcol = mix(col, ccol,S(c,0.0));\n    p = pref;\n    \n    p.x = abs(p.x);\n    p.x -= 0.13;\n    c = sdEllipse(p,vec2(0.09,0.03));\n    c2 = sdEllipse((p-vec2(-0.015,-0.015))*Rot(radians(15.0)),vec2(0.07,0.04));\n    c3 = sdEllipse((p-vec2(-0.015,0.015))*Rot(radians(-15.0)),vec2(0.07,0.04));\n    float c4 = sdEllipse(p-vec2(-0.05,0.0),vec2(0.07,0.025));\n    c = min(c, min(c2,c3));\n    c = max(-c4,c);\n    col = mix(col, ccol,S(c,0.0));\n    p = pref;\n    \n    col = mix(col, ccol,S(length(p)-0.03,0.0));\n    \n    p = abs(p);\n    \n    float b = dBox2d(p-vec2(0.0,0.23),vec2(0.05,0.045));\n    float b2 = dBox2d(p-vec2(0.35,0.0),vec2(0.05,0.045));\n    b = min(b,b2);\n    col = mix(col, ccol,S(abs(b)-0.003,0.0));\n    \n    float l = sdLine(p,vec2(0.05,0.185),vec2(0.3,0.045));\n    float l2 = sdLine(p,vec2(0.05,0.205),vec2(0.325,0.048));\n    float l3 = sdLine(p,vec2(0.05,0.225),vec2(0.355,0.048));\n    l = min(l,min(l2,l3));\n    col = mix(col, ccol,S(l-0.002,0.0));\n    return col;\n}\n\nvec3 jpTraditionalTex5(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    float scale = 1.5;\n    p*=scale;\n    \n    p.x = mod(p.x,0.7)-0.35;\n    p.y = mod(p.y,0.46)-0.23;\n    col = textile5(p,col,ccol);\n    p = pref;\n    \n    p*=scale;\n    p.x -= 0.35;\n    p.y -= 0.23;\n    p.x = mod(p.x,0.7)-0.35;\n    p.y = mod(p.y,0.46)-0.23;\n    col = textile5(p,col,ccol);\n    \n    return col;\n}\n\nvec3 textile6(vec2 p, vec3 col, vec3 ccol){\n\tfloat n = 5.0;\n    float deg = 360.0/n;\n    float startRad = radians(180.0);\n    for(float i = 0.0; i<n; i+=1.0) {\n        float rad = radians(deg*i)+startRad;\n        mat2 rot = Rot(rad);\n        float dist = 0.15;\n        float x = sin(rad)*dist;\n        float y = cos(rad)*dist;\n\n        float v = sdVesica((p+vec2(x,y))*rot,0.14,0.075);\n\t\t\n        dist = 0.07;\n        x = sin(rad)*dist;\n        y = cos(rad)*dist;\n        float e = sdEllipse((((p+vec2(x,y)))*rot),vec2(0.015,0.07));\n        v = max(-e,v);\n        col = mix(col, ccol,S(v,0.0));\n    }\n    \n    float c = length(p)-0.03;\n    col = mix(col, ccol,S(c,0.0));\n    return col;\n}\n\nvec3 textile6RepeatBg(vec2 p, vec3 col, vec3 ccol){\n    float scale = 1.5;\n    p*=scale;\n    p.x = mod(p.x,0.9)-0.45;\n    p.y = mod(p.y,0.54)-0.275;\n    col = textile6(p,col,ccol);\n    return col;\n}\n\nvec3 jpTraditionalTex6(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    col = textile6RepeatBg(p,col,ccol);\n    \n    p.x -= 0.9;\n    p.y -= 0.54;\n    col = textile6RepeatBg(p,col,ccol);\n    \n    return col;\n}\n\nfloat leaf(vec2 p) {\n\tfloat c = length(p)-0.1;\n    p.x *= 0.8;\n    p.y *= 0.6;\n    float c2  = length(p-vec2(0.06,0.05))-0.08;\n    c = max(-c2,c);\n    return c;\n}\n\nvec3 textile7(vec2 p, vec3 col, vec3 ccol){\n    float n = 5.0;\n    float deg = 360.0/n;\n    float startRad = radians(180.0);\n    float ld = 1.0;\n    for(float i = 0.0; i<n; i+=1.0) {\n        float rad = radians(deg*i)+startRad;\n        mat2 rot = Rot(rad);\n        float dist = 0.11;\n        float x = sin(rad)*dist;\n        float y = cos(rad)*dist;\n\n       \tfloat l = leaf((p+vec2(x,y))*rot);\n        ld = min(ld,l);\n    }\n\n    ld = max(-( length(p)-0.05),ld);\n    col = mix(col, ccol,S(ld,0.0));\n    float c = length(p)-0.02;\n    ld = min(c,ld);\n    col = mix(col, ccol,S(ld,0.0));\n    return col;\n}\n\nvec3 jpTraditionalTex7(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n   \tfloat scale = 1.5;\n    p*=scale;\n    \n    p.x = mod(p.x,0.8)-0.4;\n    p.y = mod(p.y,0.5)-0.25;\n    col = textile7(p, col, ccol);\n    p = pref;\n    \n    p*=scale;\n    p.x -= 0.4;\n    p.y -= 0.25;\n\tp.x = mod(p.x,0.8)-0.4;\n    p.y = mod(p.y,0.5)-0.25;\n    col = textile7(p, col, ccol);\n    return col;\n}\n\nvec3 textile8(vec2 p, vec3 col, vec3 ccol){\n    float b = sdBox(p*Rot(radians(45.0)),vec2(0.05))-0.05;\n    b = max(-(length(p)-0.03),b);\n    col = mix(col, ccol,S(b,0.0));\n    return col;\n}\n\nvec3 jpTraditionalTex8(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n    p = mod(p,0.3)-0.15;\n    col = textile8(p,col,ccol);\n    p = pref;\n    \n    p -= 0.15;\n    p = mod(p,0.3)-0.15;\n    col = textile8(p,col,ccol);\n    return col;\n}\n\nvec3 textile9(vec2 p, vec3 col, vec3 ccol){\n    float b = dBox2d(p,vec2(0.1));\n    p.x = abs(p.x);\n    p.x-=0.04;\n    float b2 = dBox2d(p,vec2(0.02,0.11));\n    b = max(-b2,b);\n    col = mix(col, ccol,S(b,0.0));\n    return col;\n}\n\nvec3 textile9RepeatBg(vec2 p, vec3 col, vec3 ccol) {\n\tvec2 pref = p;\n    p.x = mod(p.x,0.45)-0.225;\n\tp.y = mod(p.y,0.45)-0.225;\n    col = textile9(p,col,ccol);\n    p = pref;\n    \n    p.y -= 0.225;\n    p.x = mod(p.x,0.45)-0.225;\n    p.y = mod(p.y,0.45)-0.225;\n    col = textile9(p*Rot(radians(90.0)),col,ccol);\n    return col;\n}\n\nvec3 jpTraditionalTex9(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n    col = textile9RepeatBg(p,col,ccol);\n    p -= 0.225;\n    col = textile9RepeatBg(p,col,ccol);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.8,0.9,1.0);\n\tvec3 baseCol = vec3(0.0,0.3,0.5);\n    \n    uv.y -= iTime*0.1;\n    \n    float ratio = 1.0;\n    float ntextile = 9.0;\n    float scene = mod(iTime,ratio*ntextile);\n    if(scene<ratio) {\n        col = jpTraditionalTex1(uv,col,baseCol);\n    } else if(scene>=ratio && scene<ratio*2.0){\n        col = jpTraditionalTex2(uv,col,baseCol);\n    } else if(scene>=ratio*2.0 && scene<ratio*3.0){\n        col = jpTraditionalTex3(uv,col,baseCol);\n    } else if(scene>=ratio*3.0 && scene<ratio*4.0){\n        col = jpTraditionalTex4(uv,col,baseCol);\n    } else if(scene>=ratio*4.0 && scene<ratio*5.0){\n        col = jpTraditionalTex5(uv,col,baseCol);\n    } else if(scene>=ratio*5.0 && scene<ratio*6.0){\n        col = jpTraditionalTex6(uv,col,baseCol);\n    } else if(scene>=ratio*6.0 && scene<ratio*7.0){\n        col = jpTraditionalTex7(uv,col,baseCol);\n    } else if(scene>=ratio*7.0 && scene<ratio*8.0){\n        col = jpTraditionalTex8(uv,col,baseCol);\n    } else if(scene>=ratio*8.0 && scene<ratio*9.0){\n        col = jpTraditionalTex9(uv,col,baseCol);\n    }\n    \n    /*\n    col = vec3(0.8,0.9,1.0);\n    col = jpTraditionalTex6(uv,col,vec3(0.0,0.3,0.5));\n\t*/\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 275, 275, 303], [305, 305, 335, 335, 385], [387, 387, 424, 424, 508], [510, 510, 559, 559, 733], [735, 735, 777, 777, 934], [936, 936, 978, 978, 1173], [1175, 1175, 1217, 1217, 2239], [2241, 2241, 2290, 2290, 2409], [2411, 2411, 2456, 2456, 2806], [2808, 2808, 2862, 2862, 3301], [3303, 3303, 3346, 3346, 3601], [3603, 3603, 3656, 3656, 3908], [3910, 3910, 3963, 3963, 4255], [4257, 4257, 4300, 4300, 4760], [4762, 4762, 4815, 4815, 5126], [5128, 5128, 5171, 5171, 6491], [6493, 6493, 6546, 6546, 6880], [6882, 6882, 6925, 6925, 7570], [7572, 7572, 7623, 7623, 7770], [7772, 7772, 7825, 7825, 7986], [7988, 7988, 8008, 8008, 8150], [8152, 8152, 8195, 8195, 8753], [8755, 8755, 8808, 8808, 9132], [9134, 9134, 9177, 9177, 9323], [9325, 9325, 9378, 9378, 9563], [9565, 9565, 9608, 9608, 9793], [9795, 9795, 9847, 9847, 10122], [10124, 10124, 10177, 10177, 10310], [10312, 10312, 10369, 10369, 11647]], "test": "untested"}
{"id": "WttSzM", "name": "Dithering RGB", "author": "Ref", "description": "Image dithering based on ordered dithering algorithm\nThere are only 8 different colors taken from a given palette", "tags": ["palette", "dithering", "bayer"], "likes": 3, "viewed": 421, "published": 3, "date": "1580647986", "time_retrieved": "2024-07-30T21:26:22.332585", "image_code": "#define PALETTE vec3[](vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0))\n#define COUNT 8\n#define FACTOR 1.0\n\nconst int[] dithMatrix = int[]\n(\n\t0,  48, 12, 60, 3,  51, 15, 63,\n    32, 16, 44, 28, 35, 19, 47, 31,\n    8,  56, 4,  52, 11, 59, 7,  55,\n    40, 24, 36, 20, 43, 27, 39, 23,\n    2,  50, 14, 62, 1,  49, 13, 61,\n    34, 18, 46, 30, 33, 17, 45, 29,\n    10, 58, 6,  54, 9,  57, 5,  53,\n    42, 26, 38, 22, 41, 25, 37, 21\n);\n\nvec3 average()\n{\n    vec3 sum = vec3(0);\n    \n    for(int i = 0; i < COUNT; i++)\n\t{\n        sum += PALETTE[i];\n    }\n    \n    return sum / float(COUNT);\n}\n\nvec3 deviation()\n{\n    vec3 sum = vec3(0);\n    vec3 avg = average();\n    \n    for(int i = 0; i < COUNT; i++)\n\t{\n        sum += abs(PALETTE[i] - avg);\n    }\n    \n    return sum / float(COUNT);\n}\n\nfloat squaredDistance(vec3 point1, vec3 point2)\n{\n\tvec3 distanceVector = point2 - point1;\n\treturn dot(distanceVector, distanceVector);\n}\n\nvoid quantize(inout vec3 color)\n{\n\tvec3 closest = vec3(0.0, 0.0, 0.0);\n\tfloat minDist = 9999.9;\n\n\tfor(int i = 0; i < COUNT; i++)\n\t{\n\t\tvec3 plt = PALETTE[i];\n\t\tfloat dist = squaredDistance(color, plt);\n\t\tif(dist < minDist) \n\t\t{\n\t\t\tminDist = dist;\n\t\t\tclosest = plt;\n\t\t}\n\t}\n\n\tcolor = closest;\n}\n\nvoid ditherize(inout vec3 color, vec2 position)\n{\n\tint index = int(mod(position.x, 8.0)) + int(mod(position.y, 8.0)) * 8;\n\tfloat offset = (float(dithMatrix[index]) + 1.0) / 64.0 - 0.5;\n\tcolor += offset * FACTOR * deviation(); \n\tquantize(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    ditherize(col, fragCoord);\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 564, 564, 702], [704, 704, 722, 722, 897], [899, 899, 948, 948, 1035], [1037, 1037, 1070, 1070, 1328], [1578, 1578, 1635, 1635, 1826]], "test": "untested"}
{"id": "WldSRM", "name": "Trailz", "author": "hanabi", "description": "Leaving trail...", "tags": ["trail"], "likes": 0, "viewed": 315, "published": 3, "date": "1580645237", "time_retrieved": "2024-07-30T21:26:23.212233", "image_code": "  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 60, 142]], "test": "untested"}
{"id": "tl3XRN", "name": "Bunny AABB", "author": "BrunoLevy", "description": "Stanford bunny with a SAH axis-aligned bounding box tree.\n(faster version of https://www.shadertoy.com/view/ttcSzr)\nC++ sources of the 'MeshCompiler' included in the comments in Buffer A\nStill fast with up to 8K triangles (but compilation takes forever)", "tags": ["raytracing", "aabb", "mesh"], "likes": 23, "viewed": 2946, "published": 3, "date": "1580640367", "time_retrieved": "2024-07-30T21:26:24.759097", "image_code": "#define SHOW_AABB\n\nivec3 get_facet(in int f) {\n    return ivec3(\n        get_data(MESH_DATA_OFFSET,3*f),\n        get_data(MESH_DATA_OFFSET,3*f+1),\n        get_data(MESH_DATA_OFFSET,3*f+2)\n    );\n}\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Material {\n   vec3 Ka;\n   vec3 Kd;\n   vec3 Ks;\n   float s;\n   vec3 Ke;\n};\n\nstruct Intersection {\n   float t;\n   Material material;\n   vec3 P;\n   vec3 N;\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   return I;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_triangle(\n    in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t, \n    out float u, out float v, out vec3 N\n) { \n   // Mller et Trumbore,  Fast, Minimum Storage Ray-Triangle Intersection , \n   // Journal of Graphics Tools, vol. 2, 1997, p. 2128 \n   // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm \n   // (with small adaptations: branchless, and reusing the normal vector)\n   // \n   // Notation: O = R.Origin; D = R.Dir)\n   //           E1 = B-A; E2 = C-A\n   // \n   // (1) O + tD = A + uE1 + vE2 \n   // (2) uE1 + vE2 -tD = O-A\n   // \n   //                [u]\n   // (3) [E1|E2|-D] [v] = O-A\n   //                [t]\n   // \n   //  (where [E1|E2|-D] is the 3x3 matrix with E1,E2,-D as its columns)\n   //\n   //  Using Cramer's formula for the solution of:\n   //\n   //    [a11 a12 a13][x1]   [b1]\n   //    [a12 a22 a23][x2] = [b2]\n   //    [a31 a32 a33][x3]   [b3]\n   //\n   //  gives: \n   // \n   //        |b1 a12 a13|   |a11 a12 a13|\n   //   x1 = |b2 a22 a23| / |a21 a22 a23|\n   //        |b3 a32 a33|   |a31 a32 a33|\n   //\n   //        |a11 b1 a13|   |a11 a12 a13|\n   //   x2 = |a21 b2 a23| / |a21 a22 a23|\n   //        |a31 b3 a33|   |a31 a32 a33|\n   //\n   //        |a11 a12 b1|   |a11 a12 a13|\n   //   x3 = |a21 a22 b2| / |a21 a22 a23|\n   //        |a31 a32 b3|   |a31 a32 a33|\n   // \n   // Now we get:\n   //\n   //   u = (O-A,E2,-D) / (E1,E2,-D)\n   //   v = (E1,O-A,-D) / (E1,E2,-D)\n   //   t = (E1,E2,O-A) / (E1,E2,-D)\n   // \n   // where (A,B,C) denotes the determinant of the 3x3 matrix with A,B,C as its\n   //  column vectors.\n   // \n   // Now we use the following identities:\n   //   (A,B,C) = dot(A,cross(B,C))  (develop the determinant w.r.t. first column)\n   //   (B,A,C) = -(A,B,C)           (swapping two vectors changes the sign)\n   //   (B,C,A) =  (A,B,C)           (circular permutation does not change the sign)\n   // \n   // Now we get:\n   //\n   // u = -(E2,O-A,D)  / (D,E1,E2)\n   // v =  (E1,O-A,D)  / (D,E1,E2)\n   // t = -(O-A,E1,E2) / (D,E1,E2)  \n   //\n   // Using N=cross(E1,E2); AO = O-A; DAO = cross(D,AO)\n   //  gives the following code : \n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n         N = cross(E1,E2);\n   float det = -dot(R.Dir, N);\n   float invdet = 1.0/det;\n   vec3 AO  = R.Origin - A;\n   vec3 DAO = cross(AO, R.Dir);\n   u =  dot(E2,DAO) * invdet;\n   v = -dot(E1,DAO) * invdet;\n   t =  dot(AO,N)  * invdet; \n   return (det >= 1e-6 && t >= 0.0 && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0);\n}\n\nvoid triangle(in Ray R, vec3 A, vec3 B, vec3 C, in Material M, inout Intersection I) {\n   float t,u,v;\n   vec3 N;\n   if(intersect_triangle(R, A,B,C, t, u, v, N) && t < I.t) {\n      I.t = t;\n      I.material = M;\n      I.P = R.Origin + t*R.Dir;\n      I.N = normalize(N);\n   }\n}\n \nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax,\n  in float t // t of current intersection, used for pruning, see iq's comment.\n) {  \n   // References: \n   //    https://tavianator.com/fast-branchless-raybounding-box-intersections/ \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2);\n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);\n}\n\nint stack_top = -1;\nint stack_b[10];\nint stack_e[10];\n\nbool stack_empty() {\n  return (stack_top < 0);\n}\n\nvoid stack_push(in int b, in int e) {\n  stack_top++;\n  stack_b[stack_top] = b;\n  stack_e[stack_top] = e;  \n}\n\nvoid stack_pop(out int b, out int e) {\n  b = stack_b[stack_top];\n  e = stack_e[stack_top];\n  --stack_top;\n}\n\nvec3 decode_vertex(int xyz) {\n   int x = (xyz & 1023);\n   int y = (xyz & (1023 << 10)) >> 10;\n   int z = (xyz & (1023 << 20)) >> 20;\n   return bbox_min + vec3(float(x), float(y), float(z)) / 1023.0 * (bbox_max - bbox_min);\n}\n\nvec3 min3(in vec3 p1, in vec3 p2, in vec3 p3) {\n    return min(min(p1,p2),p3);\n}\n\nvec3 max3(in vec3 p1, in vec3 p2, in vec3 p3) {\n    return max(max(p1,p2),p3);\n}\n\n#ifdef SHOW_AABB\nint max_depth = 0;\n#endif\n\nvoid mesh_AABB(in Ray R, in Material M, inout Intersection I) {\n    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);\n    stack_push(0, AABB_data_size);\n    while(!stack_empty()) {\n        int b,e;\n        stack_pop(b,e);\n        // First 'facet' of sequece contains:\n        //   x: bbox_min (10 bits, 10 bits, 10 bits) \n        //   y: bbox_max (10 bits, 10 bits, 10 bits)\n        //   z: axis (2 bits), nb items in left subtree, or -1 for a leaf\n        ivec3 node = get_facet(b);\n        vec3 bbox_min = decode_vertex(node.x);\n        vec3 bbox_max = decode_vertex(node.y);\n        if(!segment_box_intersection(R.Origin, invDir, bbox_min, bbox_max, I.t)) {\n            continue;\n        }\n#ifdef SHOW_AABB        \n        max_depth = max(max_depth, stack_top);\n#endif        \n        b++;\n        if(node.z == -1) { // leaf\n           for(int i=b; i<e; ++i) {\n              ivec3 F = get_facet(i);\n              vec3 p1 = decode_vertex(F.x);\n              vec3 p2 = decode_vertex(F.y);\n              vec3 p3 = decode_vertex(F.z);\n              triangle(R, p1, p2, p3, M, I);\n          }\n        } else {\n          int coord = node.z & 3;\n          int nb    = node.z >> 2; \n          int m     = b + nb;  \n          if(R.Dir[coord] < 0.0) {\n             stack_push(b,m);\n             stack_push(m,e);                  \n          } else {\n             stack_push(m,e);\n             stack_push(b,m); // positive -> process this child first                                    \n          } \n        }\n     }\n}  \n\n\nvoid sky(out vec4 fragColor, in Ray R) {\n   vec3 V = normalize(R.Dir);\n   float s = 0.5 * (V.z + 1.0);\n   fragColor = mix( \n      vec4(0.0, 0.0, 0.0, 1.0),\n      vec4(1.0, 1.0, 2.0, 1.0),\n      s\n   );\n}\n\n\nvec3 lighting( in Intersection I, in vec3 LightPos) {\n   vec3 L = LightPos - I.P;\n   float diffuse = max(dot(I.N, L)/length(L),0.0);\n   return diffuse * I.material.Kd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float alpha = iTime + iMouse.x/100.0;\n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.5),\n       vec3(0.0, 0.0, 0.0),\n       20.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n\n   const Material WHITE = Material(\n      vec3(0.0, 0.0, 0.0),\n      vec3(1.0, 1.0, 1.0),\n      vec3(0.0, 0.0, 0.0),\n      0.0,\n      vec3(0.0, 0.0, 0.0)\n   );\n\n   mesh_AABB(R, WHITE, I);\n \n   if(I.t == FARAWAY) {\n      sky(fragColor, R);\n   } else {\n      fragColor.xyz = I.material.Ka;\n      fragColor.xyz += lighting(I, vec3(0.5, 1.3, 0.5));\n   }\n#ifdef SHOW_AABB    \n   fragColor.xyz += float(max_depth) * vec3(0.1); \n#endif    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Mesh data description: bbox and number of facets\n\nconst vec3 bbox_min = vec3(-0.253035,-0.340497,-0.346693);\nconst vec3 bbox_max = vec3(0.252403,0.340004,0.345965);\nconst int AABB_data_size = 2133;\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n// (implementation of get_data(), do not call directly)\nint get_data_raw(in sampler2D channel, in int width, in int index) {\n   vec4 col = 255.0*vec4(texelFetch(channel, ivec2(index%width,index/width), 0));\n   return (int(col.r)      ) | \n          (int(col.g) << 8 ) |\n          (int(col.b) << 16) |\n          (int(col.a) << 24) ;\n}\n\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n//  offset: one of RESOLUTION_OFFSET, MESH_DATA_OFFSET\n//  index: the index of the data to be read\n#define get_data(offset, index) \\\n    get_data_raw(iChannel0, int(iChannelResolution[0].x), (offset)+(index))\n\n// In BufferA, data is organized in sections\n// RESOLUTION_OFFSET: 2 integers (previous width and height, used to detect win resize)\n// MESH_DATA_OFFSET: facets_data_size * 3 integers. Each integer encores the x,y,z \n//                    coordinates of a vertex (x:10 bits, y:10 bits, z:10 bits). \nconst int RESOLUTION_OFFSET=0;\nconst int MESH_DATA_OFFSET=2;\n", "buffer_a_code": "#pragma optimize(off)\n\n/*\n// MeshCompiler [Bruno Levy Jan 2020]\n// Converts a .obj (Alias|Wavefront) tri mesh into an AABB, encoded in GLSL, for ShaderToy.\n \n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Sorts a vector and removes duplicated entries.\ntemplate <typename VECTOR> inline void sort_unique(VECTOR& v) {\n    std::sort(v.begin(), v.end()); v.erase(std::unique(v.begin(), v.end()), v.end());\n}\n\n// -------- GLSL-compatible types //-----------------------------------------------------\n\ntemplate <class T> class gvec3 {\npublic:\n    gvec3() {  }\n    gvec3(T x_in, T y_in, T z_in) : x(x_in), y(y_in), z(z_in) {  }\n    T& operator[](int i)             { return (&x)[i]; }\n    const T& operator[](int i) const { return (&x)[i]; }\n    T x,y,z;\n};\n\ntemplate <class T> inline gvec3<T> operator+(gvec3<T> u, gvec3<T> v) {\n    return gvec3<T>(u.x+v.x,u.y+v.y,u.z+v.z);\n}\n\ntemplate <class T> inline gvec3<T> min(gvec3<T> u, gvec3<T> v) {\n    return gvec3<T>(std::min(u.x,v.x),std::min(u.y,v.y),std::min(u.z,v.z));\n}\n\ntemplate <class T> inline gvec3<T> max(gvec3<T> u, gvec3<T> v) {\n    return gvec3<T>(std::max(u.x,v.x),std::max(u.y,v.y),std::max(u.z,v.z));\n}\n\ntypedef gvec3<double> vec3; typedef gvec3<int> ivec3;\n\n// -------- Encode/Decode //----------------------------------------------------------\n\n// Encodes a vertex, using 10 bits per coordinate\nint encode_vertex(ivec3 p) {\n    return p.x | (p.y << 10) | (p.z << 20);\n}\n\n// Encodes a vertex, using 10 bits per coordinate, relative to bbox\nint encode_vertex(vec3 p, vec3 bbox_min, vec3 bbox_max) {\n    double x = (p.x - bbox_min.x) / (bbox_max.x - bbox_min.x);\n    double y = (p.y - bbox_min.y) / (bbox_max.y - bbox_min.y);\n    double z = (p.z - bbox_min.z) / (bbox_max.z - bbox_min.z);\n    int ix = int(x * 1023.0); int iy = int(y * 1023.0); int iz = int(z * 1023.0);\n    return ix | (iy << 10) | (iz << 20);\n}\n\n// Decodes the three integer coordinates of a vertex (10 bits per coordinate)\nivec3 decode_vertex(int xyz) {\n   return ivec3( \n       (xyz & 1023),\t\n       (xyz & (1023 << 10)) >> 10, \n       (xyz & (1023 << 20)) >> 20\n   );\n}\n\n// Encodes the coordinates of the three vertices of a triangle in an ivec3\nivec3 encode_facet(vec3 p1, vec3 p2, vec3 p3, vec3 bbox_min, vec3 bbox_max) {\n    return ivec3(\n\tencode_vertex(p1, bbox_min, bbox_max),\n\tencode_vertex(p2, bbox_min, bbox_max),\n\tencode_vertex(p3, bbox_min, bbox_max)\t    \n    );\n}\n\n// -------- Mesh geometry //-------------------------------------------------------------------\n\n// Computes (three times) the barycenter of a facet\nivec3 facet_center(ivec3 f) {\n    return decode_vertex(f.x) + decode_vertex(f.y) + decode_vertex(f.z);\n}\n\n// Computes the (floating-point) bbox of a pointset\nvoid get_bbox(const std::vector<vec3>& pts, vec3& bbox_min, vec3& bbox_max) {\n    bbox_min = pts[0]; bbox_max = pts[0];\n    for(int i=1; i<pts.size(); ++i) {\n\tbbox_min = min(bbox_min, pts[i]); bbox_max = max(bbox_max, pts[i]);\t\n    }\n}\n\n// Computes the (integer) bbox of a triangle\nvoid get_facet_bbox(ivec3 f, ivec3& bbox_min, ivec3& bbox_max) {\n    bbox_min = decode_vertex(f.x); bbox_max = decode_vertex(f.x);\n     ivec3 p = decode_vertex(f.y); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);\n           p = decode_vertex(f.z); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);\n}\n\n// -------- I/O //---------------------------------------------------------------------------\n\n// Outputs a floating point number, 6.6 digits\nstd::string format(double x) {\n    static char buff[300]; sprintf(buff,\"%-6.6f\",x); return std::string(buff);\n}\n\n// Outputs an integer in hexa, 8 digits\nstd::string format_int(int x) {\n    static char buff[300]; sprintf(buff,\"0x%08x\",x); return buff;\n}\n\n// Outputs an integer in hexa, 4 digits\nstd::string format_small_int(int x) {\n    static char buff[300]; sprintf(buff,\"0x%04x\",x); return buff;\n}\n\n// Generates a GLSL function that encodes an array of ivec3, as a (huge) switch statement\n// (It is stupid, I know, but this is the only way I found to send a big array to ShaderToy).\nvoid gen_ivec3_func(std::ostream& out, const std::vector<ivec3>& array, std::string name) {\n    out << \"const int \" << name << \"_size = \" << array.size() << \";\" << std::endl;\n    out << \"ivec3 \" << name << \"(in int i) {\" << std::endl;\n    out << \"#  ifdef R\"   << std::endl;\n    out << \"#    undef R\" << std::endl;\n    out << \"#  endif\"     << std::endl;\n    out << \"#  define R(i,a,b,c) case i: r=ivec3(a,b,c); break;\" << std::endl;\n    out << \"  ivec3 r;\" << std::endl;\n    out << \"  switch(i) {\" << std::endl;\n    for(int i=0; i<int(array.size()); ++i) {\n       out << \"    R(\" << format_small_int(i) << \",\"\n\t               << format_int(array[i].x) << \",\" << format_int(array[i].y) << \",\" << format_int(array[i].z) << \")\";\n       if(!((i+1)%10)) { out << std::endl; }\n    }\n    out << \"  }\" << std::endl;\n    out << \"  return r;\" << std::endl;\n    out << \"}\" << std::endl;\n}\n\n// Loads a mesh from a .obj (Alias|Wavefront) file. Gets the point coordinates and triangle vertex indices.\nbool load_mesh(const std::string& filename, std::vector<vec3>& points, std::vector<ivec3>& triangles) {\n    points.clear();\n    triangles.clear();\n    FILE* F = fopen(filename.c_str(),\"r\");\n    if(!F) { return false;  }\n    char* line=nullptr;\n    size_t linelen=0;\n    int lineno = 0;\n    while(getline(&line,&linelen,F) >= 0) {\n\t++lineno;\n\tswitch(line[0]) {\n\t    case 'v': {\n\t\tfloat x,y,z;\n\t\tbool ok = (sscanf(line+1, \"%f %f %f\", &x, &y, &z) == 3);\n\t\tif(!ok) {\n\t\t    std::cerr << lineno << \": malformed vertex\" << std::endl;\n\t\t    std::cerr << line << std::endl;\n\t\t    return false;\n\t\t}\n\t\tpoints.push_back(vec3(double(x),double(y),double(z)));\n\t    } break;\n\t    case 'f': {\n\t\tint v1 =-1,v2 =-1,v3 =-1;\n\t\tint vt1=-1,vt2=-1,vt3=-1;\n\t\tint vn1=-1,vn2=-1,vn3=-1;\n\t\tbool ok = false;\n\t\tok = ok || (sscanf(line+1,\"%d %d %d\",                   &v1,&v2,&v3                              ) == 3);\n\t\tok = ok || (sscanf(line+1,\"%d/%d %d/%d %d/%d\",          &v1,&vn1,&v2,&vn2,&v3,&vn3               ) == 6);\n\t\tok = ok || (sscanf(line+1,\"%d/%d/%d %d/%d/%d %d/%d/%d\", &v1,&vn1,&vt1,&v2,&vn2,&vt2,&v3,&vn3,&vt3) == 9);\n\t\tok = ok || (sscanf(line+1,\"%d//%d %d//%d %d//%d\",       &v1,&vt1,&v2,&vt2,&v3,&vt3               ) == 6);\n\t\tif(!ok || v1<1 || v2<1 || v3<1) {\n\t\t    std::cerr << lineno << \": malformed facet\" << std::endl;\n\t\t    std::cerr << line << std::endl;\n\t\t    return false;\n\t\t}\n\t\ttriangles.push_back(ivec3(v1-1,v2-1,v3-1));\n\t    } break;\n\t}\n    }\n    free(line);\n    fclose(F);\n    return true;\n}\n\n// Loads a mesh from a .obj (Alias|Wavefront) file. Gets the bbox and for each triangle its vertices coordinates packed\n// in a single integer (10 bits per component).\nbool load_and_convert_mesh(const std::string& filename, std::vector<ivec3>& triangles_out, vec3& bbox_min, vec3& bbox_max) {\n    std::vector<vec3> points;\n    std::vector<ivec3> triangles;\n    if(!load_mesh(filename, points, triangles)) { return false; }\n    get_bbox(points, bbox_min, bbox_max);\n    triangles_out.resize(triangles.size());\n    for(int t=0; t<triangles.size(); ++t) {\n\tivec3 T = triangles[t];\n\ttriangles_out[t] = ivec3(\n\t    encode_vertex(points[T.x], bbox_min, bbox_max),\n\t    encode_vertex(points[T.y], bbox_min, bbox_max),\n\t    encode_vertex(points[T.z], bbox_min, bbox_max)\n\t);\n    }\n    return true;\n}\n\n// -------- AABB with SAH ----------------------------------------------------------------\n\nvoid sort(std::vector<ivec3>& mesh, int b, int e, int coord) {\n    std::sort(\n\tmesh.begin() + b, mesh.begin() + e,\n\t[coord](const ivec3& F1, const ivec3& F2) {\n\t    return (facet_center(F1)[coord] < facet_center(F2)[coord]);\n\t}\n    );\n}\n\nvoid get_bbox(std::vector<ivec3>& mesh, int b, int e, ivec3& bbox_min, ivec3& bbox_max) {\n    get_facet_bbox(mesh[b], bbox_min, bbox_max);\n    for(int i=b+1; i<e; ++i) {\n\tivec3 cur_bbox_min, cur_bbox_max;\n\tget_facet_bbox(mesh[i], cur_bbox_min, cur_bbox_max);\n\tbbox_min = min(bbox_min, cur_bbox_min); bbox_max = max(bbox_max, cur_bbox_max);\n    }\n}\n\ndouble bbox_area(ivec3 bbox_min, ivec3 bbox_max, vec3 fbbox_min, vec3 fbbox_max) {\n    double l1 = (double(bbox_max.x) - double(bbox_min.x)) * (fbbox_max.x - fbbox_min.x) / 1023.0;\n    double l2 = (double(bbox_max.y) - double(bbox_min.y)) * (fbbox_max.y - fbbox_min.y) / 1023.0;\n    double l3 = (double(bbox_max.z) - double(bbox_min.z)) * (fbbox_max.z - fbbox_min.z) / 1023.0;\n    return l1*l2 + l2*l3 + l3*l1;\n}\n\n// Returns true if node should be split\n// split_nb: number of facets in left subtree\n// split_coord: coordinate along which bbox is split\nbool sort_SAH(std::vector<ivec3>& mesh, int b, int e, vec3 fbbox_min, vec3 fbbox_max, int& split_nb, int& split_coord) {\n    const double c_t = 30.0; // Cost of traversing a node\n    const double c_i = 1.0;  // Cost of computing an intersection\n\n    // bbox of sequence [b..i-b[\n    std::vector<ivec3> bbox_min_1(e-b);\n    std::vector<ivec3> bbox_max_1(e-b);\n\n    // bbox of sequence [i..e[\n    std::vector<ivec3> bbox_min_2(e-b);\n    std::vector<ivec3> bbox_max_2(e-b);\n    \n    double best_c = 1e30;\n    int best_coord = -1;\n    int best_m = -1;\n    for(int coord=0; coord<3; ++coord) {\n\tsort(mesh, b, e, coord);\n\tget_facet_bbox(mesh[b], bbox_min_1[0], bbox_max_1[0]);\n\tfor(int i=b+1; i<e; ++i) {\n\t    ivec3 cur_bbox_min, cur_bbox_max;\n\t    get_facet_bbox(mesh[i], cur_bbox_min, cur_bbox_max);\n\t    bbox_min_1[i-b] = min(bbox_min_1[i-1-b], cur_bbox_min);\n\t    bbox_max_1[i-b] = max(bbox_max_1[i-1-b], cur_bbox_max);\t\n\t}\n\tget_facet_bbox(mesh[e-1], bbox_min_2[e-1-b], bbox_max_2[e-1-b]);\n\tfor(int i=e-2; i>=b; --i) {\n\t    ivec3 cur_bbox_min, cur_bbox_max;\n\t    get_facet_bbox(mesh[i], cur_bbox_min, cur_bbox_max);\n\t    bbox_min_2[i-b] = min(bbox_min_2[i+1-b], cur_bbox_min);\n\t    bbox_max_2[i-b] = max(bbox_max_2[i+1-b], cur_bbox_max);\t\n\t}\n\tdouble Sparent = bbox_area(bbox_min_1[e-b-1], bbox_max_1[e-b-1], fbbox_min, fbbox_max);\n\tfor(int i=b+1; i<e-1; ++i) {\n\t    double Sleft  = bbox_area(bbox_min_1[i-1-b], bbox_max_1[i-1-b], fbbox_min, fbbox_max);\n\t    double Sright = bbox_area(bbox_min_2[i-b],   bbox_max_2[i-b]  , fbbox_min, fbbox_max);\n\t    double c = c_t + (Sleft  / Sparent) * double(i-b)*c_i + (Sright / Sparent) * double(e-i)*c_i ;\n\t    if(c < best_c) { best_c = c; best_coord = coord; best_m = i; }\n\t}\n    }\n    if(best_coord != 2) { sort(mesh, b, e, best_coord); }\n    split_coord = best_coord; split_nb = best_m - b;\n    return (best_c < double(e-b)*c_i);\n}\n\nvoid init_AABB(std::vector<ivec3>& mesh, int b, int e, std::vector<ivec3>& out, vec3 fbbox_min, vec3 fbbox_max) {\n    ivec3 bbox_min, bbox_max;\n    get_bbox(mesh, b, e, bbox_min, bbox_max);\n    int nb,coord;\n    if(sort_SAH(mesh, b, e, fbbox_min, fbbox_max, nb, coord)) {\n\tint m = b + nb;\n\tint node = out.size();\n\tout.push_back(ivec3());\n\tinit_AABB(mesh, b, m, out, fbbox_min, fbbox_max);\n\tint new_m = out.size();\n\tinit_AABB(mesh, m, e, out, fbbox_min, fbbox_max);\n\tout[node] = ivec3(encode_vertex(bbox_min), encode_vertex(bbox_max), coord | ((new_m-node-1) << 2));\n    } else {\n\tout.push_back(ivec3(encode_vertex(bbox_min), encode_vertex(bbox_max), -1));\n\tfor(int i=b; i<e; ++i) {\n\t    out.push_back(mesh[i]);\n\t}\n    }\n}\n\nint main(int argc, char** argv) {\n    if(argc != 2) {\n\tstd::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n\treturn -1;\n    }\n    vec3 bbox_min, bbox_max;\n    std::vector<ivec3> facets;\n    if(!load_and_convert_mesh(argv[1], facets, bbox_min, bbox_max)) {\n\tstd::cerr << \"Could not load \" << argv[1] << std::endl;\n\treturn -1;\n    }\n    std::cout << \"const vec3 bbox_min = vec3(\" << bbox_min.x << \",\" << bbox_min.y << \",\" << bbox_min.z << \");\" << std::endl;\n    std::cout << \"const vec3 bbox_max = vec3(\" << bbox_max.x << \",\" << bbox_max.y << \",\" << bbox_max.z << \");\" << std::endl;\n\n    std::vector<ivec3> AABB;\n    init_AABB(facets, 0, int(facets.size()), AABB, bbox_min, bbox_max);\n    gen_ivec3_func(std::cout, AABB, \"AABB_data\");\t\n    \n    return 0;\n}\n*/\n\nivec3 AABB_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c) case i: r=ivec3(a,b,c); break;\n  ivec3 r;\n  switch(i) {\n    R(0x0000,0x00000000,0x3fffffff,0x00001565)    R(0x0001,0x00000000,0x3ff837ff,0x000009ca)    R(0x0002,0x00009c3b,0x20682b85,0x000005b6)    R(0x0003,0x00024c5e,0x0e182b80,0x00000258)    R(0x0004,0x0002585e,0x0db81207,0x0000014c)    R(0x0005,0x00744c5e,0x0d38117d,0x000000ee)    R(0x0006,0x00744c8a,0x0708117d,0xffffffff)    R(0x0007,0x01045d30,0x00a4810f,0x00844d5c)    R(0x0008,0x02145d54,0x02247105,0x01045d30)    R(0x0009,0x02247105,0x011490df,0x01045d30)\n    R(0x000a,0x04349d33,0x02247105,0x02145d54)    R(0x000b,0x011490df,0x00a4810f,0x01045d30)    R(0x000c,0x00a4810f,0x0074a554,0x00844d5c)    R(0x000d,0x0254c4cc,0x011490df,0x02247105)    R(0x000e,0x0474dcee,0x02247105,0x04349d33)    R(0x000f,0x011490df,0x00c4f4ca,0x00a4810f)    R(0x0010,0x0254c4cc,0x02247105,0x0474dcee)    R(0x0011,0x0094f505,0x0074a554,0x00a4810f)    R(0x0012,0x0645293d,0x04349d33,0x04f49d6c)    R(0x0013,0x00c4f4ca,0x0094f505,0x00a4810f)\n    R(0x0014,0x0254c4cc,0x01451cb3,0x011490df)    R(0x0015,0x0645293d,0x0474dcee,0x04349d33)    R(0x0016,0x01451cb3,0x00c4f4ca,0x011490df)    R(0x0017,0x0155455f,0x0074a554,0x0094f505)    R(0x0018,0x05256cc4,0x0254c4cc,0x0474dcee)    R(0x0019,0x02e558ae,0x01451cb3,0x0254c4cc)    R(0x001a,0x05256cc4,0x02e558ae,0x0254c4cc)    R(0x001b,0x069590fa,0x0474dcee,0x0645293d)    R(0x001c,0x00b5b8ce,0x0094f505,0x00c4f4ca)    R(0x001d,0x0155455f,0x0094f505,0x01659919)\n    R(0x001e,0x0105c8ac,0x00c4f4ca,0x01451cb3)    R(0x001f,0x05256cc4,0x0474dcee,0x069590fa)    R(0x0020,0x01659919,0x0094f505,0x00b5b8ce)    R(0x0021,0x0215f0a5,0x01451cb3,0x02e558ae)    R(0x0022,0x00b5b8ce,0x00c4f4ca,0x0105c8ac)    R(0x0023,0x0215f0a5,0x0105c8ac,0x01451cb3)    R(0x0024,0x05061cad,0x02e558ae,0x05256cc4)    R(0x0025,0x02961150,0x0155455f,0x01659919)    R(0x0026,0x06c60cce,0x05256cc4,0x069590fa)    R(0x0027,0x05061cad,0x0215f0a5,0x02e558ae)\n    R(0x0028,0x06c60cce,0x05061cad,0x05256cc4)    R(0x0029,0x01f65d02,0x01659919,0x00b5b8ce)    R(0x002a,0x02961150,0x01659919,0x01f65d02)    R(0x002b,0x0116bcb3,0x00b5b8ce,0x0105c8ac)    R(0x002c,0x01c6d0a4,0x0105c8ac,0x0215f0a5)    R(0x002d,0x07067cab,0x05061cad,0x06c60cce)    R(0x002e,0x01f65d02,0x00b5b8ce,0x00e6a4d2)    R(0x002f,0x0466c8a2,0x0215f0a5,0x05061cad)    R(0x0030,0x00e6a4d2,0x00b5b8ce,0x0116bcb3)    R(0x0031,0x0116bcb3,0x0105c8ac,0x01c6d0a4)\n    R(0x0032,0x07067cab,0x0466c8a2,0x05061cad)    R(0x0033,0x02c70138,0x02961150,0x01f65d02)    R(0x0034,0x0466c8a2,0x01c6d0a4,0x0215f0a5)    R(0x0035,0x01f65d02,0x00e6a4d2,0x02074cf4)    R(0x0036,0x06c73c8a,0x0466c8a2,0x07067cab)    R(0x0037,0x02c70138,0x01f65d02,0x02074cf4)    R(0x0038,0x00e6a4d2,0x0116bcb3,0x011790c3)    R(0x0039,0x0387a49f,0x01c6d0a4,0x0466c8a2)    R(0x003a,0x0177cca9,0x0116bcb3,0x01c6d0a4)    R(0x003b,0x02074cf4,0x00e6a4d2,0x011790c3)\n    R(0x003c,0x06c73c8a,0x0387a49f,0x0466c8a2)    R(0x003d,0x011790c3,0x0116bcb3,0x0177cca9)    R(0x003e,0x0177cca9,0x01c6d0a4,0x0387a49f)    R(0x003f,0x02c70138,0x02074cf4,0x0308112b)    R(0x0040,0x02b7a17d,0x02c70138,0x0308112b)    R(0x0041,0x0645285e,0x0d381161,0xffffffff)    R(0x0042,0x0a77705e,0x0976c07f,0x0d16a85e)    R(0x0043,0x0a77705e,0x0688107d,0x06c73c8a)    R(0x0044,0x0a77705e,0x06c73c8a,0x0976c07f)    R(0x0045,0x0d16a85e,0x0976c07f,0x0b563893)\n    R(0x0046,0x0976c07f,0x06c73c8a,0x07067cab)    R(0x0047,0x0b563893,0x0976c07f,0x07067cab)    R(0x0048,0x0b563893,0x07067cab,0x08e618c7)    R(0x0049,0x0d35d0bc,0x0b563893,0x08e618c7)    R(0x004a,0x08e618c7,0x07067cab,0x06c60cce)    R(0x004b,0x0d35d0bc,0x08e618c7,0x0b15dcfc)    R(0x004c,0x08e618c7,0x06c60cce,0x07f5f0ff)    R(0x004d,0x08e618c7,0x07f5f0ff,0x0b15dcfc)    R(0x004e,0x06c60cce,0x069590fa,0x07f5f0ff)    R(0x004f,0x0b15dcfc,0x07f5f0ff,0x0935e938)\n    R(0x0050,0x07f5f0ff,0x069590fa,0x07b5d141)    R(0x0051,0x0b15dcfc,0x0935e938,0x0c05b93b)    R(0x0052,0x07f5f0ff,0x07b5d141,0x0935e938)    R(0x0053,0x07b5d141,0x069590fa,0x0645293d)    R(0x0054,0x0c05b93b,0x0935e938,0x0935c15a)    R(0x0055,0x0935e938,0x07b5d141,0x0935c15a)    R(0x0056,0x07655161,0x07b5d141,0x0645293d)    R(0x0057,0x0c05b93b,0x0935c15a,0x0be55d55)    R(0x0058,0x00025930,0x0db7a207,0xffffffff)    R(0x0059,0x0002e604,0x002305bc,0x0013bddd)\n    R(0x005a,0x00326df8,0x002305bc,0x0002e604)    R(0x005b,0x0013bddd,0x002305bc,0x0043f192)    R(0x005c,0x00348604,0x0013bddd,0x0054c9ab)    R(0x005d,0x0054c9ab,0x0013bddd,0x0043f192)    R(0x005e,0x0072b5be,0x002305bc,0x00326df8)    R(0x005f,0x0043f192,0x002305bc,0x00738d8a)    R(0x0060,0x006591e2,0x00348604,0x0054c9ab)    R(0x0061,0x0054c9ab,0x0043f192,0x0074a554)    R(0x0062,0x00738d8a,0x002305bc,0x0072b5be)    R(0x0063,0x0074a554,0x0043f192,0x00844d5c)\n    R(0x0064,0x00844d5c,0x0043f192,0x00738d8a)    R(0x0065,0x00b259f3,0x0072b5be,0x00326df8)    R(0x0066,0x00c42168,0x00844d5c,0x00738d8a)    R(0x0067,0x00e34d96,0x00738d8a,0x0072b5be)    R(0x0068,0x00c42168,0x00738d8a,0x00e34d96)    R(0x0069,0x0054c9ab,0x0074a554,0x0155455f)    R(0x006a,0x01045d30,0x00844d5c,0x00c42168)    R(0x006b,0x006591e2,0x0054c9ab,0x01b5b1a0)    R(0x006c,0x0182a1c6,0x0072b5be,0x00b259f3)    R(0x006d,0x00e34d96,0x0072b5be,0x0182a1c6)\n    R(0x006e,0x01b5b1a0,0x0054c9ab,0x0155455f)    R(0x006f,0x015669e1,0x006591e2,0x01b5b1a0)    R(0x0070,0x02145d54,0x01045d30,0x00c42168)    R(0x0071,0x02540978,0x00c42168,0x00e34d96)    R(0x0072,0x02a281f7,0x0182a1c6,0x00b259f3)    R(0x0073,0x02b345a5,0x00e34d96,0x0182a1c6)    R(0x0074,0x02145d54,0x00c42168,0x02540978)    R(0x0075,0x015669e1,0x01b5b1a0,0x02869d92)    R(0x0076,0x01b5b1a0,0x0155455f,0x02961150)    R(0x0077,0x02540978,0x00e34d96,0x02b345a5)\n    R(0x0078,0x026745d6,0x015669e1,0x02869d92)    R(0x0079,0x02869d92,0x01b5b1a0,0x02961150)    R(0x007a,0x026745d6,0x02869d92,0x02b7a17d)    R(0x007b,0x02869d92,0x02961150,0x02c70138)    R(0x007c,0x02b7a17d,0x02869d92,0x02c70138)    R(0x007d,0x042315d0,0x0182a1c6,0x02a281f7)    R(0x007e,0x02b345a5,0x0182a1c6,0x042315d0)    R(0x007f,0x04f49d6c,0x02145d54,0x02540978)    R(0x0080,0x0553e1a3,0x02540978,0x02b345a5)    R(0x0081,0x04f49d6c,0x04349d33,0x02145d54)\n    R(0x0082,0x05132207,0x042315d0,0x02a281f7)    R(0x0083,0x0553e1a3,0x02b345a5,0x042315d0)    R(0x0084,0x04f49d6c,0x02540978,0x0553e1a3)    R(0x0085,0x0653a5dc,0x042315d0,0x05132207)    R(0x0086,0x0553e1a3,0x042315d0,0x0653a5dc)    R(0x0087,0x07447d81,0x04f49d6c,0x0553e1a3)    R(0x0088,0x07655161,0x0645293d,0x04f49d6c)    R(0x0089,0x07655161,0x04f49d6c,0x07447d81)    R(0x008a,0x0833edae,0x0553e1a3,0x0653a5dc)    R(0x008b,0x07447d81,0x0553e1a3,0x0833edae)\n    R(0x008c,0x0833edae,0x0653a5dc,0x0893bde6)    R(0x008d,0x09750169,0x07655161,0x07447d81)    R(0x008e,0x0935c15a,0x07b5d141,0x07655161)    R(0x008f,0x09750169,0x0935c15a,0x07655161)    R(0x0090,0x0aa43d7f,0x07447d81,0x0833edae)    R(0x0091,0x09750169,0x07447d81,0x0aa43d7f)    R(0x0092,0x0b13b9b9,0x0833edae,0x0893bde6)    R(0x0093,0x0aa43d7f,0x0833edae,0x0b13b9b9)    R(0x0094,0x0b13b9b9,0x0893bde6,0x0a53a9f8)    R(0x0095,0x0be55d55,0x0935c15a,0x09750169)\n    R(0x0096,0x0db49156,0x09750169,0x0aa43d7f)    R(0x0097,0x0c6321cd,0x0b13b9b9,0x0a53a9f8)    R(0x0098,0x0db49156,0x0be55d55,0x09750169)    R(0x0099,0x0d73c589,0x0aa43d7f,0x0b13b9b9)    R(0x009a,0x00024dcd,0x0e182b80,0x000001b0)    R(0x009b,0x00024dcd,0x0d381af2,0x000000ee)    R(0x009c,0x000255d6,0x03681af0,0xffffffff)    R(0x009d,0x00b259f3,0x00925e33,0x01725627)    R(0x009e,0x00b259f3,0x00326df8,0x00925e33)    R(0x009f,0x02a281f7,0x00b259f3,0x01725627)\n    R(0x00a0,0x01725627,0x00925e33,0x01828252)    R(0x00a1,0x02a281f7,0x01725627,0x03629630)    R(0x00a2,0x03629630,0x01725627,0x01828252)    R(0x00a3,0x00925e33,0x00326df8,0x0022b243)    R(0x00a4,0x01828252,0x00925e33,0x0092ce67)    R(0x00a5,0x0092ce67,0x00925e33,0x0022b243)    R(0x00a6,0x03629630,0x01828252,0x0332ee5a)    R(0x00a7,0x00326df8,0x0002e604,0x0022b243)    R(0x00a8,0x01533e81,0x01828252,0x0092ce67)    R(0x00a9,0x0332ee5a,0x01828252,0x01533e81)\n    R(0x00aa,0x0092ce67,0x0022b243,0x00336a7d)    R(0x00ab,0x0022b243,0x0002e604,0x00039e40)    R(0x00ac,0x01533e81,0x0092ce67,0x00839a97)    R(0x00ad,0x00336a7d,0x0022b243,0x00039e40)    R(0x00ae,0x00839a97,0x0092ce67,0x00336a7d)    R(0x00af,0x0323be7f,0x0332ee5a,0x01533e81)    R(0x00b0,0x00039e40,0x0002e604,0x0013bddd)    R(0x00b1,0x0143caa0,0x01533e81,0x00839a97)    R(0x00b2,0x0323be7f,0x01533e81,0x0143caa0)    R(0x00b3,0x00839a97,0x00336a7d,0x0043c6bc)\n    R(0x00b4,0x00336a7d,0x00039e40,0x00141296)    R(0x00b5,0x00b3c2b0,0x00839a97,0x0043c6bc)    R(0x00b6,0x00b3c2b0,0x0043c6bc,0x00c39eec)    R(0x00b7,0x0143caa0,0x00839a97,0x00b3c2b0)    R(0x00b8,0x0213cacd,0x00b3c2b0,0x00c39eec)    R(0x00b9,0x0043c6bc,0x00336a7d,0x00141296)    R(0x00ba,0x0143caa0,0x00b3c2b0,0x0213cacd)    R(0x00bb,0x0304269f,0x0323be7f,0x0143caa0)    R(0x00bc,0x0304269f,0x0143caa0,0x0213cacd)    R(0x00bd,0x00039e40,0x0013bddd,0x00348604)\n    R(0x00be,0x0043c6bc,0x00141296,0x001422f0)    R(0x00bf,0x00141296,0x00039e40,0x00549e59)    R(0x00c0,0x00549e59,0x00039e40,0x00348604)    R(0x00c1,0x001422f0,0x00141296,0x0014f2b6)    R(0x00c2,0x0014f2b6,0x00141296,0x00549e59)    R(0x00c3,0x00549e59,0x00348604,0x00e5561e)    R(0x00c4,0x0014f2b6,0x00549e59,0x00b58e72)    R(0x00c5,0x00e5561e,0x00348604,0x006591e2)    R(0x00c6,0x00b58e72,0x00549e59,0x00e5561e)    R(0x00c7,0x0055eecd,0x0014f2b6,0x00b58e72)\n    R(0x00c8,0x00b58e72,0x00e5561e,0x00c62e2a)    R(0x00c9,0x00c62e2a,0x00e5561e,0x006591e2)    R(0x00ca,0x0055eecd,0x00b58e72,0x00a67a74)    R(0x00cb,0x00c62e2a,0x006591e2,0x015669e1)    R(0x00cc,0x00a67a74,0x00b58e72,0x00c62e2a)    R(0x00cd,0x0106eeb8,0x0055eecd,0x00a67a74)    R(0x00ce,0x0146f227,0x00c62e2a,0x015669e1)    R(0x00cf,0x00a67a74,0x00c62e2a,0x0146f227)    R(0x00d0,0x0146f227,0x015669e1,0x026745d6)    R(0x00d1,0x0106eeb8,0x00a67a74,0x01c74e72)\n    R(0x00d2,0x01c74e72,0x00a67a74,0x0146f227)    R(0x00d3,0x0257d221,0x0146f227,0x026745d6)    R(0x00d4,0x01c74e72,0x0146f227,0x0257d221)    R(0x00d5,0x02681ab8,0x0106eeb8,0x01c74e72)    R(0x00d6,0x018772eb,0x0106eeb8,0x02681ab8)    R(0x00d7,0x02124dcd,0x0d34e2f2,0xffffffff)    R(0x00d8,0x0ba29a50,0x0d324e07,0x0b033214)    R(0x00d9,0x05132207,0x02a281f7,0x03629630)    R(0x00da,0x0b033214,0x0d324e07,0x0c6321cd)    R(0x00db,0x05234a37,0x03629630,0x0332ee5a)\n    R(0x00dc,0x05132207,0x03629630,0x05234a37)    R(0x00dd,0x0ba2e2a3,0x0ba29a50,0x0a538667)    R(0x00de,0x0a538667,0x0ba29a50,0x0b033214)    R(0x00df,0x0d131ef2,0x0ba2e2a3,0x0b03cab8)    R(0x00e0,0x05234a37,0x0332ee5a,0x0323be7f)    R(0x00e1,0x0b033214,0x0c6321cd,0x0a53a9f8)    R(0x00e2,0x06d3ba13,0x05132207,0x05234a37)    R(0x00e3,0x0b03cab8,0x0ba2e2a3,0x0a538667)    R(0x00e4,0x06d3ba13,0x0653a5dc,0x05132207)    R(0x00e5,0x0a538667,0x0b033214,0x09d3ea36)\n    R(0x00e6,0x0b033214,0x0a53a9f8,0x09d3ea36)    R(0x00e7,0x06d3ba13,0x05234a37,0x0593fa4c)    R(0x00e8,0x0593fa4c,0x05234a37,0x0323be7f)    R(0x00e9,0x0893bde6,0x0653a5dc,0x06d3ba13)    R(0x00ea,0x0a53a9f8,0x0893bde6,0x08c3de1b)    R(0x00eb,0x08c3de1b,0x0893bde6,0x06d3ba13)    R(0x00ec,0x09d3ea36,0x0a53a9f8,0x08c3de1b)    R(0x00ed,0x0b03cab8,0x0a538667,0x09b46e81)    R(0x00ee,0x08c3de1b,0x06d3ba13,0x07444245)    R(0x00ef,0x0a538667,0x09d3ea36,0x09b46e81)\n    R(0x00f0,0x07444245,0x06d3ba13,0x0593fa4c)    R(0x00f1,0x04843eda,0x0304269f,0x0213cacd)    R(0x00f2,0x09d3ea36,0x08c3de1b,0x08d46a4f)    R(0x00f3,0x0593fa4c,0x0323be7f,0x04f48a76)    R(0x00f4,0x04f48a76,0x0323be7f,0x0304269f)    R(0x00f5,0x08d46a4f,0x08c3de1b,0x07444245)    R(0x00f6,0x09b46e81,0x09d3ea36,0x08d46a4f)    R(0x00f7,0x07444245,0x0593fa4c,0x04f48a76)    R(0x00f8,0x0b03cab8,0x09b46e81,0x0b24a2d5)    R(0x00f9,0x0594baa1,0x0304269f,0x04843eda)\n    R(0x00fa,0x0594baa1,0x04f48a76,0x0304269f)    R(0x00fb,0x08d46a4f,0x07444245,0x0704ce6f)    R(0x00fc,0x07444245,0x04f48a76,0x0704ce6f)    R(0x00fd,0x09b46e81,0x08d46a4f,0x08d4c686)    R(0x00fe,0x0694e2e7,0x0594baa1,0x04843eda)    R(0x00ff,0x0b24a2d5,0x09b46e81,0x09e4daca)    R(0x0100,0x08d46a4f,0x0704ce6f,0x08d4c686)    R(0x0101,0x09b46e81,0x08d4c686,0x09e4daca)    R(0x0102,0x0704ce6f,0x04f48a76,0x0594baa1)    R(0x0103,0x07c4dab4,0x0704ce6f,0x0594baa1)\n    R(0x0104,0x08d4c686,0x0704ce6f,0x07c4dab4)    R(0x0105,0x07c4dab4,0x0594baa1,0x0694e2e7)    R(0x0106,0x09e4daca,0x08d4c686,0x07c4dab4)    R(0x0107,0x00139eb4,0x0e182b80,0x00000132)    R(0x0108,0x00139eb6,0x07082b80,0xffffffff)    R(0x0109,0x01d3ab12,0x00c39eec,0x00c3bb32)    R(0x010a,0x0213cacd,0x00c39eec,0x01d3ab12)    R(0x010b,0x00c39eec,0x0043c317,0x00c3bb32)    R(0x010c,0x00c39eec,0x0043c6bc,0x0043c317)    R(0x010d,0x01d3ab12,0x00c3bb32,0x0213f74e)\n    R(0x010e,0x03e3eb1c,0x0213cacd,0x01d3ab12)    R(0x010f,0x03e3eb1c,0x01d3ab12,0x0213f74e)    R(0x0110,0x00c3bb32,0x0043c317,0x00841b5b)    R(0x0111,0x0043c317,0x0043c6bc,0x001422f0)    R(0x0112,0x0213f74e,0x00c3bb32,0x00841b5b)    R(0x0113,0x04843eda,0x0213cacd,0x03e3eb1c)    R(0x0114,0x00841b5b,0x0043c317,0x00244b48)    R(0x0115,0x00244b48,0x0043c317,0x001422f0)    R(0x0116,0x03e3eb1c,0x0213f74e,0x04344f53)    R(0x0117,0x0213f74e,0x00841b5b,0x01846f73)\n    R(0x0118,0x04344f53,0x0213f74e,0x01846f73)    R(0x0119,0x05a4931b,0x04843eda,0x03e3eb1c)    R(0x011a,0x05a4931b,0x03e3eb1c,0x04344f53)    R(0x011b,0x0094bf78,0x00841b5b,0x00244b48)    R(0x011c,0x01846f73,0x00841b5b,0x0094bf78)    R(0x011d,0x00244b48,0x001422f0,0x00350311)    R(0x011e,0x04344f53,0x01846f73,0x0364c374)    R(0x011f,0x0694e2e7,0x04843eda,0x05a4931b)    R(0x0120,0x05a4931b,0x04344f53,0x0574f745)    R(0x0121,0x0574f745,0x04344f53,0x0364c374)\n    R(0x0122,0x00350311,0x001422f0,0x0014f2b6)    R(0x0123,0x0094bf78,0x00244b48,0x00451b60)    R(0x0124,0x01b50b80,0x01846f73,0x0094bf78)    R(0x0125,0x0364c374,0x01846f73,0x01b50b80)    R(0x0126,0x00451b60,0x00244b48,0x00350311)    R(0x0127,0x06d54312,0x0694e2e7,0x05a4931b)    R(0x0128,0x06d54312,0x05a4931b,0x0574f745)    R(0x0129,0x0574f745,0x0364c374,0x03e56764)    R(0x012a,0x03e56764,0x0364c374,0x01b50b80)    R(0x012b,0x01b50b80,0x0094bf78,0x00c59f68)\n    R(0x012c,0x00c59f68,0x0094bf78,0x00451b60)    R(0x012d,0x06d54312,0x0574f745,0x05e5a72f)    R(0x012e,0x00350311,0x0014f2b6,0x0055eecd)    R(0x012f,0x00451b60,0x00350311,0x0055d333)    R(0x0130,0x05e5a72f,0x0574f745,0x03e56764)    R(0x0131,0x03e56764,0x01b50b80,0x01f5b368)    R(0x0132,0x01f5b368,0x01b50b80,0x00c59f68)    R(0x0133,0x00c59f68,0x00451b60,0x0055d333)    R(0x0134,0x0055d333,0x00350311,0x0055eecd)    R(0x0135,0x05e5a72f,0x03e56764,0x03d6433d)\n    R(0x0136,0x03d6433d,0x03e56764,0x01f5b368)    R(0x0137,0x01f5b368,0x00c59f68,0x01766344)    R(0x0138,0x00c59f68,0x0055d333,0x00b6673b)    R(0x0139,0x07063f23,0x05e5a72f,0x03d6433d)    R(0x013a,0x03d6433d,0x01f5b368,0x01766344)    R(0x013b,0x0055d333,0x0055eecd,0x0076a30b)    R(0x013c,0x01766344,0x00c59f68,0x00b6673b)    R(0x013d,0x00b6673b,0x0055d333,0x0076a30b)    R(0x013e,0x03d6433d,0x01766344,0x02d6af35)    R(0x013f,0x07063f23,0x03d6433d,0x0606df18)\n    R(0x0140,0x0076a30b,0x0055eecd,0x0106eeb8)    R(0x0141,0x01766344,0x00b6673b,0x0136c73c)    R(0x0142,0x03d6433d,0x02d6af35,0x0606df18)    R(0x0143,0x01766344,0x0136c73c,0x02d6af35)    R(0x0144,0x00b6673b,0x0076a30b,0x00b73344)    R(0x0145,0x0136c73c,0x00b6673b,0x00b73344)    R(0x0146,0x0606df18,0x02d6af35,0x04b71f3b)    R(0x0147,0x02d6af35,0x0136c73c,0x02973757)    R(0x0148,0x02d6af35,0x02973757,0x04b71f3b)    R(0x0149,0x018772eb,0x0076a30b,0x0106eeb8)\n    R(0x014a,0x00b73344,0x0076a30b,0x00977f28)    R(0x014b,0x00b73344,0x01476b60,0x0136c73c)    R(0x014c,0x0136c73c,0x01476b60,0x02973757)    R(0x014d,0x00977f28,0x0076a30b,0x018772eb)    R(0x014e,0x0606df18,0x04b71f3b,0x06e7ab22)    R(0x014f,0x04b71f3b,0x02973757,0x0457db66)    R(0x0150,0x02973757,0x01476b60,0x0227f77a)    R(0x0151,0x06e7ab22,0x04b71f3b,0x0457db66)    R(0x0152,0x00f80f71,0x01476b60,0x00b73344)    R(0x0153,0x00a82b50,0x00b73344,0x00977f28)\n    R(0x0154,0x05e3cab4,0x0e17df39,0xffffffff)    R(0x0155,0x0ca41308,0x0b03cab8,0x0b24a2d5)    R(0x0156,0x0ca41308,0x0b24a2d5,0x0cc4ff16)    R(0x0157,0x0b24a2d5,0x09e4daca,0x0ae53701)    R(0x0158,0x0cc4ff16,0x0b24a2d5,0x0ae53701)    R(0x0159,0x09e4daca,0x07c4dab4,0x087522f3)    R(0x015a,0x087522f3,0x07c4dab4,0x0694e2e7)    R(0x015b,0x0ae53701,0x09e4daca,0x087522f3)    R(0x015c,0x087522f3,0x0694e2e7,0x06d54312)    R(0x015d,0x0cc4ff16,0x0ae53701,0x0c45c328)\n    R(0x015e,0x0ae53701,0x087522f3,0x0895af1c)    R(0x015f,0x0895af1c,0x087522f3,0x06d54312)    R(0x0160,0x0895af1c,0x06d54312,0x05e5a72f)    R(0x0161,0x0c45c328,0x0ae53701,0x0895af1c)    R(0x0162,0x0895af1c,0x05e5a72f,0x07063f23)    R(0x0163,0x0c45c328,0x0895af1c,0x0a26572a)    R(0x0164,0x0a26572a,0x0895af1c,0x07063f23)    R(0x0165,0x0e165339,0x0c45c328,0x0a26572a)    R(0x0166,0x0a26572a,0x07063f23,0x0886ff07)    R(0x0167,0x0e165339,0x0a26572a,0x0bd70717)\n    R(0x0168,0x0886ff07,0x07063f23,0x0606df18)    R(0x0169,0x0bd70717,0x0a26572a,0x0886ff07)    R(0x016a,0x0886ff07,0x0606df18,0x08077af7)    R(0x016b,0x0bd70717,0x0886ff07,0x0a478af3)    R(0x016c,0x08077af7,0x0606df18,0x06e7ab22)    R(0x016d,0x0a478af3,0x0886ff07,0x08077af7)    R(0x016e,0x0df77f07,0x0bd70717,0x0a478af3)    R(0x016f,0x0df77f07,0x0a478af3,0x0c37df08)    R(0x0170,0x0a709c3b,0x20681b85,0x00000211)    R(0x0171,0x0b009d26,0x1fc49385,0x000000e8)\n    R(0x0172,0x0b109d26,0x1f74927a,0xffffffff)    R(0x0173,0x1b00b63d,0x17a0c60b,0x17709e5f)    R(0x0174,0x17709e5f,0x1420da28,0x14b0c27a)    R(0x0175,0x17709e5f,0x17a0c60b,0x1420da28)    R(0x0176,0x1b6109ee,0x17a0c60b,0x1b00b63d)    R(0x0177,0x1e710624,0x1b00b63d,0x1e20d26c)    R(0x0178,0x14b0c27a,0x1420da28,0x11612259)    R(0x0179,0x17a0c60b,0x14611ddf,0x1420da28)    R(0x017a,0x1b6109ee,0x1b00b63d,0x1e710624)    R(0x017b,0x180135be,0x17a0c60b,0x1b6109ee)\n    R(0x017c,0x180135be,0x14611ddf,0x17a0c60b)    R(0x017d,0x1420da28,0x14611ddf,0x10816a04)    R(0x017e,0x11612259,0x1420da28,0x10816a04)    R(0x017f,0x1f5185e3,0x1b6109ee,0x1e710624)    R(0x0180,0x1bc19dae,0x180135be,0x1b6109ee)    R(0x0181,0x14c19197,0x14611ddf,0x180135be)    R(0x0182,0x14611ddf,0x11c19dbd,0x10816a04)    R(0x0183,0x1bc19dae,0x1b6109ee,0x1f5185e3)    R(0x0184,0x14c19197,0x11c19dbd,0x14611ddf)    R(0x0185,0x11612259,0x10816a04,0x0e81c645)\n    R(0x0186,0x1831e185,0x14c19197,0x180135be)    R(0x0187,0x1831e185,0x180135be,0x1bc19dae)    R(0x0188,0x11c19dbd,0x0f2239c3,0x10816a04)    R(0x0189,0x1f2239a0,0x1bc19dae,0x1f5185e3)    R(0x018a,0x11923581,0x11c19dbd,0x14c19197)    R(0x018b,0x0e81c645,0x10816a04,0x0d324e07)    R(0x018c,0x14c24d67,0x14c19197,0x1831e185)    R(0x018d,0x1bc26974,0x1831e185,0x1bc19dae)    R(0x018e,0x10816a04,0x0f2239c3,0x0d324e07)    R(0x018f,0x11923581,0x0f2239c3,0x11c19dbd)\n    R(0x0190,0x14c24d67,0x11923581,0x14c19197)    R(0x0191,0x1bc26974,0x1bc19dae,0x1f2239a0)    R(0x0192,0x0ba29a50,0x0e81c645,0x0d324e07)    R(0x0193,0x1872c550,0x14c24d67,0x1831e185)    R(0x0194,0x1872c550,0x1831e185,0x1bc26974)    R(0x0195,0x0f02f586,0x0f2239c3,0x11923581)    R(0x0196,0x1202fd55,0x11923581,0x14c24d67)    R(0x0197,0x1ef2f968,0x1bc26974,0x1f2239a0)    R(0x0198,0x0d324e07,0x0f2239c3,0x0c6321cd)    R(0x0199,0x1202fd55,0x0f02f586,0x11923581)\n    R(0x019a,0x15531d3c,0x14c24d67,0x1872c550)    R(0x019b,0x0c6321cd,0x0f2239c3,0x0f02f586)    R(0x019c,0x15531d3c,0x1202fd55,0x14c24d67)    R(0x019d,0x1b93513e,0x1872c550,0x1bc26974)    R(0x019e,0x1b93513e,0x1bc26974,0x1ef2f968)    R(0x019f,0x1823c128,0x15531d3c,0x1872c550)    R(0x01a0,0x1053c958,0x0f02f586,0x1202fd55)    R(0x01a1,0x1823c128,0x1872c550,0x1b93513e)    R(0x01a2,0x0d73c589,0x0c6321cd,0x0f02f586)    R(0x01a3,0x1403e92f,0x1202fd55,0x15531d3c)\n    R(0x01a4,0x1f73c94c,0x1b93513e,0x1ef2f968)    R(0x01a5,0x1053c958,0x0d73c589,0x0f02f586)    R(0x01a6,0x0d73c589,0x0b13b9b9,0x0c6321cd)    R(0x01a7,0x1403e92f,0x1053c958,0x1202fd55)    R(0x01a8,0x1823c128,0x1403e92f,0x15531d3c)    R(0x01a9,0x1c743d26,0x1823c128,0x1b93513e)    R(0x01aa,0x1c743d26,0x1b93513e,0x1f73c94c)    R(0x01ab,0x1053c958,0x0db49156,0x0d73c589)    R(0x01ac,0x0b009e3d,0x1fc48b85,0xffffffff)    R(0x01ad,0x0d622687,0x0e81c645,0x0ba29a50)\n    R(0x01ae,0x1aa0a294,0x1b00b63d,0x17709e5f)    R(0x01af,0x11612259,0x0e81c645,0x1001869c)    R(0x01b0,0x1e20d26c,0x1b00b63d,0x1aa0a294)    R(0x01b1,0x1001869c,0x0e81c645,0x0d622687)    R(0x01b2,0x0ba2e2a3,0x0d622687,0x0ba29a50)    R(0x01b3,0x134112b9,0x14b0c27a,0x11612259)    R(0x01b4,0x1730b6be,0x17709e5f,0x14b0c27a)    R(0x01b5,0x134112b9,0x11612259,0x1001869c)    R(0x01b6,0x1aa0a294,0x17709e5f,0x1730b6be)    R(0x01b7,0x1e00e2b4,0x1e20d26c,0x1aa0a294)\n    R(0x01b8,0x1730b6be,0x14b0c27a,0x134112b9)    R(0x01b9,0x0e4246d3,0x1001869c,0x0d622687)    R(0x01ba,0x0e4246d3,0x0d622687,0x0ba2e2a3)    R(0x01bb,0x1e00e2b4,0x1aa0a294,0x1b40dadd)    R(0x01bc,0x1b40dadd,0x1aa0a294,0x1730b6be)    R(0x01bd,0x134112b9,0x1001869c,0x1151b2ed)    R(0x01be,0x1151b2ed,0x1001869c,0x0e4246d3)    R(0x01bf,0x0d131ef2,0x0e4246d3,0x0ba2e2a3)    R(0x01c0,0x15013f00,0x1730b6be,0x134112b9)    R(0x01c1,0x1e113af6,0x1e00e2b4,0x1b40dadd)\n    R(0x01c2,0x1e113af6,0x1fc0c2e3,0x1e00e2b4)    R(0x01c3,0x1b40dadd,0x1730b6be,0x18310304)    R(0x01c4,0x15013f00,0x134112b9,0x1151b2ed)    R(0x01c5,0x0ca41308,0x0d131ef2,0x0b03cab8)    R(0x01c6,0x18310304,0x1730b6be,0x15013f00)    R(0x01c7,0x0fd27f1d,0x1151b2ed,0x0e4246d3)    R(0x01c8,0x0fd27f1d,0x0e4246d3,0x0d131ef2)    R(0x01c9,0x1e113af6,0x1b40dadd,0x1b415f1e)    R(0x01ca,0x1b415f1e,0x1b40dadd,0x18310304)    R(0x01cb,0x15013f00,0x1151b2ed,0x1311e730)\n    R(0x01cc,0x0ee36f39,0x0d131ef2,0x0ca41308)    R(0x01cd,0x1311e730,0x1151b2ed,0x0fd27f1d)    R(0x01ce,0x1741b33b,0x18310304,0x15013f00)    R(0x01cf,0x1db1d731,0x1e113af6,0x1b415f1e)    R(0x01d0,0x0ee36f39,0x0fd27f1d,0x0d131ef2)    R(0x01d1,0x1db1d731,0x1f716726,0x1e113af6)    R(0x01d2,0x1b415f1e,0x18310304,0x1741b33b)    R(0x01d3,0x1741b33b,0x15013f00,0x1311e730)    R(0x01d4,0x0ef46b46,0x0ee36f39,0x0ca41308)    R(0x01d5,0x1db1d731,0x1b415f1e,0x1b02234f)\n    R(0x01d6,0x11c2df56,0x1311e730,0x0fd27f1d)    R(0x01d7,0x1e422b4d,0x1f716726,0x1db1d731)    R(0x01d8,0x1b02234f,0x1b415f1e,0x1741b33b)    R(0x01d9,0x11c2df56,0x0fd27f1d,0x0ee36f39)    R(0x01da,0x1741b33b,0x1311e730,0x14b25b5d)    R(0x01db,0x1d72a760,0x1e422b4d,0x1db1d731)    R(0x01dc,0x1d72a760,0x1db1d731,0x1b02234f)    R(0x01dd,0x14b25b5d,0x1311e730,0x11c2df56)    R(0x01de,0x11a3db6b,0x0ee36f39,0x0ef46b46)    R(0x01df,0x11a3db6b,0x11c2df56,0x0ee36f39)\n    R(0x01e0,0x1b02234f,0x1741b33b,0x17c29f70)    R(0x01e1,0x17c29f70,0x1741b33b,0x14b25b5d)    R(0x01e2,0x1d72a760,0x1b02234f,0x1b22fb6e)    R(0x01e3,0x1d72a760,0x1e52a770,0x1e422b4d)    R(0x01e4,0x1e035f60,0x1eb33b64,0x1d72a760)    R(0x01e5,0x1ec43751,0x1e035f60,0x1b83db75)    R(0x01e6,0x1b22fb6e,0x1b02234f,0x17c29f70)    R(0x01e7,0x1e52a770,0x1ef1df71,0x1e422b4d)    R(0x01e8,0x1e035f60,0x1d72a760,0x1b22fb6e)    R(0x01e9,0x14b33f7c,0x14b25b5d,0x11c2df56)\n    R(0x01ea,0x1eb33b64,0x1e52a770,0x1d72a760)    R(0x01eb,0x14b33f7c,0x11c2df56,0x11a3db6b)    R(0x01ec,0x1e035f60,0x1b22fb6e,0x1b83db75)    R(0x01ed,0x17c29f70,0x14b25b5d,0x14b33f7c)    R(0x01ee,0x1b22fb6e,0x17c29f70,0x17d39385)    R(0x01ef,0x1b83db75,0x1b22fb6e,0x17d39385)    R(0x01f0,0x14e42b85,0x14b33f7c,0x11a3db6b)    R(0x01f1,0x17d39385,0x17c29f70,0x14b33f7c)    R(0x01f2,0x1b83db75,0x17d39385,0x18348b83)    R(0x01f3,0x17d39385,0x14b33f7c,0x14e42b85)\n    R(0x01f4,0x18348b83,0x17d39385,0x14e42b85)    R(0x01f5,0x0a73c03b,0x20681b85,0x00000130)    R(0x01f6,0x0a73c03b,0x20681989,0x000000b8)    R(0x01f7,0x0a75403b,0x20681902,0xffffffff)    R(0x01f8,0x0ee72c49,0x0a77705e,0x0d16a85e)    R(0x01f9,0x0d38184b,0x0a77705e,0x0ee72c49)    R(0x01fa,0x0d35d0bc,0x0b15dcfc,0x0f059102)    R(0x01fb,0x0f260079,0x0d16a85e,0x0b563893)    R(0x01fc,0x0f260079,0x0b563893,0x0d35d0bc)    R(0x01fd,0x0ee72c49,0x0d16a85e,0x11065852)\n    R(0x01fe,0x10f58ca7,0x0d35d0bc,0x0f059102)    R(0x01ff,0x11065852,0x0d16a85e,0x0f260079)    R(0x0200,0x10f58ca7,0x0f260079,0x0d35d0bc)    R(0x0201,0x10f58ca7,0x0f059102,0x126558e9)    R(0x0202,0x13270443,0x0ee72c49,0x11065852)    R(0x0203,0x1305bc74,0x0f260079,0x10f58ca7)    R(0x0204,0x1305bc74,0x11065852,0x0f260079)    R(0x0205,0x1197e840,0x0ee72c49,0x13270443)    R(0x0206,0x148568af,0x10f58ca7,0x126558e9)    R(0x0207,0x148568af,0x1305bc74,0x10f58ca7)\n    R(0x0208,0x14e64055,0x11065852,0x1305bc74)    R(0x0209,0x13270443,0x11065852,0x14e64055)    R(0x020a,0x1197e840,0x13270443,0x1537f43b)    R(0x020b,0x148568af,0x126558e9,0x157540f1)    R(0x020c,0x1675bc7e,0x1305bc74,0x148568af)    R(0x020d,0x1675bc7e,0x14e64055,0x1305bc74)    R(0x020e,0x16c70c47,0x13270443,0x14e64055)    R(0x020f,0x1537f43b,0x13270443,0x16c70c47)    R(0x0210,0x176590c8,0x148568af,0x157540f1)    R(0x0211,0x176590c8,0x1675bc7e,0x148568af)\n    R(0x0212,0x18165868,0x14e64055,0x1675bc7e)    R(0x0213,0x16c70c47,0x14e64055,0x18165868)    R(0x0214,0x176590c8,0x157540f1,0x182548f0)    R(0x0215,0x1935fcad,0x1675bc7e,0x176590c8)    R(0x0216,0x1935fcad,0x18165868,0x1675bc7e)    R(0x0217,0x19873c62,0x16c70c47,0x18165868)    R(0x0218,0x1898004d,0x16c70c47,0x19873c62)    R(0x0219,0x1a75e0e3,0x176590c8,0x182548f0)    R(0x021a,0x1a75e0e3,0x1935fcad,0x176590c8)    R(0x021b,0x1a36a893,0x18165868,0x1935fcad)\n    R(0x021c,0x19873c62,0x18165868,0x1a36a893)    R(0x021d,0x1b26a8cc,0x1a36a893,0x1935fcad)    R(0x021e,0x1b26a8cc,0x1935fcad,0x1a75e0e3)    R(0x021f,0x1b67789f,0x19873c62,0x1a36a893)    R(0x0220,0x1b67789f,0x1a36a893,0x1b26a8cc)    R(0x0221,0x1dc664e7,0x1b26a8cc,0x1a75e0e3)    R(0x0222,0x1d175cca,0x1b67789f,0x1b26a8cc)    R(0x0223,0x1d175cca,0x1b26a8cc,0x1dc664e7)    R(0x0224,0x206750ee,0x1d175cca,0x1dc664e7)    R(0x0225,0x0aa3c0e3,0x20066589,0xffffffff)\n    R(0x0226,0x0db49156,0x0aa43d7f,0x0d73c589)    R(0x0227,0x0f059102,0x0b15dcfc,0x0c05b93b)    R(0x0228,0x0f255133,0x0c05b93b,0x0be55d55)    R(0x0229,0x0f255133,0x0be55d55,0x0db49156)    R(0x022a,0x0f059102,0x0c05b93b,0x0f255133)    R(0x022b,0x1184a933,0x0f255133,0x0db49156)    R(0x022c,0x1184a933,0x0db49156,0x1053c958)    R(0x022d,0x12953117,0x0f059102,0x0f255133)    R(0x022e,0x12953117,0x0f255133,0x1184a933)    R(0x022f,0x126558e9,0x0f059102,0x12953117)\n    R(0x0230,0x1403e92f,0x1184a933,0x1053c958)    R(0x0231,0x15b4b514,0x12953117,0x1184a933)    R(0x0232,0x157540f1,0x126558e9,0x12953117)    R(0x0233,0x15b4b514,0x1184a933,0x1403e92f)    R(0x0234,0x157540f1,0x12953117,0x15b4b514)    R(0x0235,0x1823c128,0x15b4b514,0x1403e92f)    R(0x0236,0x182548f0,0x157540f1,0x15b4b514)    R(0x0237,0x182548f0,0x15b4b514,0x19549d0f)    R(0x0238,0x19549d0f,0x15b4b514,0x1823c128)    R(0x0239,0x1c653d08,0x182548f0,0x19549d0f)\n    R(0x023a,0x1c743d26,0x19549d0f,0x1823c128)    R(0x023b,0x1a75e0e3,0x182548f0,0x1c653d08)    R(0x023c,0x1c653d08,0x19549d0f,0x1c743d26)    R(0x023d,0x1dc664e7,0x1a75e0e3,0x1c653d08)    R(0x023e,0x2004bd36,0x1c653d08,0x1c743d26)    R(0x023f,0x1dc664e7,0x1c653d08,0x1f75ad16)    R(0x0240,0x1f75ad16,0x1c653d08,0x2004bd36)    R(0x0241,0x2004bd36,0x1c743d26,0x1f73c94c)    R(0x0242,0x0bd3db03,0x2007db85,0xffffffff)    R(0x0243,0x1ec43751,0x1b83db75,0x1bb4bf69)\n    R(0x0244,0x14e42b85,0x11a3db6b,0x11e4e76a)    R(0x0245,0x1bb4bf69,0x1b83db75,0x18348b83)    R(0x0246,0x11e4e76a,0x11a3db6b,0x0ef46b46)    R(0x0247,0x0ef46b46,0x0ca41308,0x0cc4ff16)    R(0x0248,0x18348b83,0x14e42b85,0x15351b77)    R(0x0249,0x1f752336,0x1ec43751,0x1bb4bf69)    R(0x024a,0x15351b77,0x14e42b85,0x11e4e76a)    R(0x024b,0x11e4e76a,0x0ef46b46,0x0f456b40)    R(0x024c,0x0ef46b46,0x0cc4ff16,0x0f456b40)    R(0x024d,0x1bb4bf69,0x18348b83,0x18a58f66)\n    R(0x024e,0x18a58f66,0x18348b83,0x15351b77)    R(0x024f,0x1f752336,0x1bb4bf69,0x1c458f51)    R(0x0250,0x1c458f51,0x1bb4bf69,0x18a58f66)    R(0x0251,0x15351b77,0x11e4e76a,0x11b5f34f)    R(0x0252,0x0f456b40,0x0cc4ff16,0x0c45c328)    R(0x0253,0x11e4e76a,0x0f456b40,0x11b5f34f)    R(0x0254,0x18a58f66,0x15351b77,0x1515e75c)    R(0x0255,0x1e26372c,0x1f752336,0x1c458f51)    R(0x0256,0x15351b77,0x11b5f34f,0x1515e75c)    R(0x0257,0x1c458f51,0x18a58f66,0x1a765345)\n    R(0x0258,0x0f456b40,0x0c45c328,0x0e165339)    R(0x0259,0x11b5f34f,0x0f456b40,0x0e165339)    R(0x025a,0x18a58f66,0x1515e75c,0x17067749)    R(0x025b,0x1e26372c,0x1c458f51,0x1a765345)    R(0x025c,0x1a765345,0x18a58f66,0x17067749)    R(0x025d,0x1515e75c,0x11b5f34f,0x13a6d33b)    R(0x025e,0x17067749,0x1515e75c,0x13a6d33b)    R(0x025f,0x11b5f34f,0x0e165339,0x10070329)    R(0x0260,0x1e26372c,0x1a765345,0x1c670730)    R(0x0261,0x13a6d33b,0x11b5f34f,0x10070329)\n    R(0x0262,0x1a765345,0x17067749,0x19073345)    R(0x0263,0x20070303,0x1e26372c,0x1c670730)    R(0x0264,0x10070329,0x0e165339,0x0bd70717)    R(0x0265,0x1c670730,0x1a765345,0x19073345)    R(0x0266,0x17067749,0x13a6d33b,0x15f74b37)    R(0x0267,0x19073345,0x17067749,0x15f74b37)    R(0x0268,0x13a6d33b,0x10070329,0x12676323)    R(0x0269,0x15f74b37,0x13a6d33b,0x12676323)    R(0x026a,0x10070329,0x0bd70717,0x0df77f07)    R(0x026b,0x20070303,0x1c670730,0x1e47db1b)\n    R(0x026c,0x12676323,0x10070329,0x0df77f07)    R(0x026d,0x1c670730,0x19073345,0x1a57d737)    R(0x026e,0x19073345,0x15f74b37,0x17c7c342)    R(0x026f,0x15f74b37,0x12676323,0x1507b348)    R(0x0270,0x12676323,0x0df77f07,0x0f97b719)    R(0x0271,0x1e47db1b,0x1c670730,0x1a57d737)    R(0x0272,0x17c7c342,0x15f74b37,0x1507b348)    R(0x0273,0x1a57d737,0x19073345,0x17c7c342)    R(0x0274,0x1d100000,0x3ff837ff,0x0000058e)    R(0x0275,0x1d102cc2,0x313837ff,0x00000278)\n    R(0x0276,0x1d105cc2,0x31383672,0x0000011a)    R(0x0277,0x1d105cc6,0x2888366c,0x00000081)    R(0x0278,0x1e205d36,0x2884c66c,0xffffffff)    R(0x0279,0x2100a255,0x24d05e54,0x2460ba1d)    R(0x027a,0x2460ba1d,0x24d05e54,0x2870b630)    R(0x027b,0x20f11a1a,0x2100a255,0x2460ba1d)    R(0x027c,0x1e20d26c,0x2100a255,0x1e710624)    R(0x027d,0x271139f7,0x2460ba1d,0x2870b630)    R(0x027e,0x1e710624,0x2100a255,0x20f11a1a)    R(0x027f,0x22f179ec,0x20f11a1a,0x2460ba1d)\n    R(0x0280,0x22f179ec,0x2460ba1d,0x271139f7)    R(0x0281,0x1f5185e3,0x1e710624,0x20f11a1a)    R(0x0282,0x1f5185e3,0x20f11a1a,0x22f179ec)    R(0x0283,0x25c1fdd1,0x22f179ec,0x271139f7)    R(0x0284,0x223231c7,0x1f5185e3,0x22f179ec)    R(0x0285,0x223231c7,0x22f179ec,0x25c1fdd1)    R(0x0286,0x1f2239a0,0x1f5185e3,0x223231c7)    R(0x0287,0x24e2ddbe,0x223231c7,0x25c1fdd1)    R(0x0288,0x2242f995,0x1f2239a0,0x223231c7)    R(0x0289,0x24e2ddbe,0x25c1fdd1,0x2882a5cb)\n    R(0x028a,0x2242f995,0x223231c7,0x24e2ddbe)    R(0x028b,0x1ef2f968,0x1f2239a0,0x2242f995)    R(0x028c,0x27538dcc,0x24e2ddbe,0x2882a5cb)    R(0x028d,0x2523a9ad,0x2242f995,0x24e2ddbe)    R(0x028e,0x22b3d970,0x1ef2f968,0x2242f995)    R(0x028f,0x2523a9ad,0x24e2ddbe,0x27538dcc)    R(0x0290,0x22b3d970,0x2242f995,0x2523a9ad)    R(0x0291,0x1f73c94c,0x1ef2f968,0x22b3d970)    R(0x0292,0x27344dd7,0x2523a9ad,0x27538dcc)    R(0x0293,0x25a47d96,0x22b3d970,0x2523a9ad)\n    R(0x0294,0x2004bd36,0x1f73c94c,0x22b3d970)    R(0x0295,0x25a47d96,0x2523a9ad,0x27344dd7)    R(0x0296,0x2334c562,0x22b3d970,0x25a47d96)    R(0x0297,0x2004bd36,0x22b3d970,0x2334c562)    R(0x0298,0x1d144cc6,0x2798366c,0xffffffff)    R(0x0299,0x1f282cc6,0x1d175cca,0x206750ee)    R(0x029a,0x21668518,0x1dc664e7,0x1f75ad16)    R(0x029b,0x206750ee,0x1dc664e7,0x21668518)    R(0x029c,0x2265b145,0x1f75ad16,0x2004bd36)    R(0x029d,0x21668518,0x1f75ad16,0x2265b145)\n    R(0x029e,0x23776126,0x206750ee,0x21668518)    R(0x029f,0x2265b145,0x2004bd36,0x2334c562)    R(0x02a0,0x223834f1,0x206750ee,0x23776126)    R(0x02a1,0x24469160,0x21668518,0x2265b145)    R(0x02a2,0x23776126,0x21668518,0x24469160)    R(0x02a3,0x2265b145,0x2334c562,0x24c58180)    R(0x02a4,0x24469160,0x2265b145,0x24c58180)    R(0x02a5,0x25d7ad64,0x23776126,0x24469160)    R(0x02a6,0x24c58180,0x2334c562,0x25a47d96)    R(0x02a7,0x24469160,0x24c58180,0x25962dab)\n    R(0x02a8,0x262719a3,0x24469160,0x25962dab)    R(0x02a9,0x25d7ad64,0x24469160,0x262719a3)    R(0x02aa,0x25962dab,0x24c58180,0x26a521be)    R(0x02ab,0x24c58180,0x25a47d96,0x26a521be)    R(0x02ac,0x262719a3,0x25962dab,0x2656b9ee)    R(0x02ad,0x2656b9ee,0x25962dab,0x26c5c5f2)    R(0x02ae,0x25962dab,0x26a521be,0x26c5c5f2)    R(0x02af,0x26672241,0x2696462c,0x2646466c)    R(0x02b0,0x26672241,0x2656b9ee,0x2696462c)    R(0x02b1,0x26a521be,0x25a47d96,0x27344dd7)\n    R(0x02b2,0x279815aa,0x25d7ad64,0x262719a3)    R(0x02b3,0x2656b9ee,0x26c5c5f2,0x2696462c)    R(0x02b4,0x274799f5,0x262719a3,0x2656b9ee)    R(0x02b5,0x274799f5,0x2656b9ee,0x26672241)    R(0x02b6,0x2696462c,0x2745664e,0x2646466c)    R(0x02b7,0x2696462c,0x26c5c5f2,0x2745664e)    R(0x02b8,0x279815aa,0x262719a3,0x274799f5)    R(0x02b9,0x26c5c5f2,0x26a521be,0x2794f60b)    R(0x02ba,0x27781e41,0x274799f5,0x26672241)    R(0x02bb,0x26a521be,0x27344dd7,0x2794f60b)\n    R(0x02bc,0x26c5c5f2,0x2794f60b,0x2745664e)    R(0x02bd,0x25c0a0c2,0x31356672,0x000000a9)    R(0x02be,0x25c0a0c2,0x3132b272,0xffffffff)    R(0x02bf,0x2f21351c,0x3020ecc2,0x2fe148db)    R(0x02c0,0x2fc0e501,0x3020ecc2,0x2f21351c)    R(0x02c1,0x2f01c132,0x2fe148db,0x30c1ccf5)    R(0x02c2,0x2f21351c,0x2fe148db,0x2f01c132)    R(0x02c3,0x2f01c132,0x30c1ccf5,0x2ff22d49)    R(0x02c4,0x2f412158,0x2fc0e501,0x2f21351c)    R(0x02c5,0x2f412158,0x3100f541,0x2fc0e501)\n    R(0x02c6,0x2e11a578,0x2f21351c,0x2f01c132)    R(0x02c7,0x2f412158,0x2f21351c,0x2e11a578)    R(0x02c8,0x2e222984,0x2f01c132,0x2ff22d49)    R(0x02c9,0x2e11a578,0x2f01c132,0x2e222984)    R(0x02ca,0x2e222984,0x2ff22d49,0x2fa27d93)    R(0x02cb,0x2e11a578,0x2e8155a8,0x2f412158)    R(0x02cc,0x2e8155a8,0x31310593,0x2f412158)    R(0x02cd,0x2cf225bd,0x2e11a578,0x2e222984)    R(0x02ce,0x2d8285c0,0x2e222984,0x2fa27d93)    R(0x02cf,0x2d31adc2,0x2e8155a8,0x2e11a578)\n    R(0x02d0,0x2cf225bd,0x2d31adc2,0x2e11a578)    R(0x02d1,0x2cf225bd,0x2e222984,0x2d8285c0)    R(0x02d2,0x2ff139d6,0x31310593,0x2e8155a8)    R(0x02d3,0x2d8285c0,0x2fa27d93,0x2f72b1d1)    R(0x02d4,0x2bf269d3,0x2cf225bd,0x2d8285c0)    R(0x02d5,0x2d9169f0,0x2e8155a8,0x2d31adc2)    R(0x02d6,0x2c11d9de,0x2d31adc2,0x2cf225bd)    R(0x02d7,0x2bf269d3,0x2c11d9de,0x2cf225bd)    R(0x02d8,0x2d9169f0,0x2ff139d6,0x2e8155a8)    R(0x02d9,0x2882a5cb,0x25c1fdd1,0x29c1e5dc)\n    R(0x02da,0x2882a5cb,0x29c1e5dc,0x2bf269d3)    R(0x02db,0x29c1e5dc,0x2c11d9de,0x2bf269d3)    R(0x02dc,0x2c11d9de,0x2d9169f0,0x2d31adc2)    R(0x02dd,0x25c1fdd1,0x271139f7,0x29c1e5dc)    R(0x02de,0x29c1e5dc,0x2b114e01,0x2c11d9de)    R(0x02df,0x2b114e01,0x2d9169f0,0x2c11d9de)    R(0x02e0,0x29c1e5dc,0x271139f7,0x2b114e01)    R(0x02e1,0x2d9169f0,0x30214215,0x2ff139d6)    R(0x02e2,0x2b114e01,0x2d510633,0x2d9169f0)    R(0x02e3,0x271139f7,0x2870b630,0x2b114e01)\n    R(0x02e4,0x2d510633,0x30214215,0x2d9169f0)    R(0x02e5,0x2b114e01,0x2870b630,0x2d510633)    R(0x02e6,0x2d510633,0x30411a53,0x30214215)    R(0x02e7,0x2870b630,0x2b20a272,0x2d510633)    R(0x02e8,0x273269ad,0x31356669,0xffffffff)    R(0x02e9,0x2bf269d3,0x2d8285c0,0x2da2d5e2)    R(0x02ea,0x2da2d5e2,0x2d8285c0,0x2f72b1d1)    R(0x02eb,0x2f72b1d1,0x30e29df2,0x2ff2ea02)    R(0x02ec,0x2882a5cb,0x2bf269d3,0x2b0331db)    R(0x02ed,0x2da2d5e2,0x2f72b1d1,0x2ff2ea02)\n    R(0x02ee,0x2b0331db,0x2bf269d3,0x2da2d5e2)    R(0x02ef,0x2da2d5e2,0x2ff2ea02,0x2e1361f6)    R(0x02f0,0x27538dcc,0x2882a5cb,0x2b0331db)    R(0x02f1,0x2b0331db,0x2da2d5e2,0x2e1361f6)    R(0x02f2,0x2e1361f6,0x2ff2ea02,0x30533606)    R(0x02f3,0x2e1361f6,0x30533606,0x2f73bdeb)    R(0x02f4,0x2b0331db,0x2e1361f6,0x2c43f5fd)    R(0x02f5,0x27538dcc,0x2b0331db,0x297405eb)    R(0x02f6,0x2e1361f6,0x2f73bdeb,0x2df409f5)    R(0x02f7,0x297405eb,0x2b0331db,0x2c43f5fd)\n    R(0x02f8,0x2c43f5fd,0x2e1361f6,0x2df409f5)    R(0x02f9,0x27344dd7,0x27538dcc,0x297405eb)    R(0x02fa,0x2df409f5,0x2f73bdeb,0x30046dca)    R(0x02fb,0x2c43f5fd,0x2df409f5,0x2d444e0e)    R(0x02fc,0x297405eb,0x2c43f5fd,0x2b545e22)    R(0x02fd,0x2b545e22,0x2c43f5fd,0x2d444e0e)    R(0x02fe,0x27344dd7,0x297405eb,0x28d48e11)    R(0x02ff,0x2d444e0e,0x2df409f5,0x2ec499e7)    R(0x0300,0x28d48e11,0x297405eb,0x2b545e22)    R(0x0301,0x2df409f5,0x30046dca,0x2ec499e7)\n    R(0x0302,0x2b545e22,0x2d444e0e,0x2d547236)    R(0x0303,0x2b545e22,0x2d547236,0x2bd49669)    R(0x0304,0x2d444e0e,0x2e94be0b,0x2d547236)    R(0x0305,0x2d547236,0x2f14ba2f,0x2f447663)    R(0x0306,0x2d444e0e,0x2ec499e7,0x2e94be0b)    R(0x0307,0x2794f60b,0x27344dd7,0x28d48e11)    R(0x0308,0x28d48e11,0x2b545e22,0x2904e657)    R(0x0309,0x2904e657,0x2b545e22,0x2bd49669)    R(0x030a,0x2d547236,0x2e94be0b,0x2f14ba2f)    R(0x030b,0x2f14ba2f,0x3134ea2f,0x2f447663)\n    R(0x030c,0x2ec499e7,0x30046dca,0x30e529ad)    R(0x030d,0x2794f60b,0x28d48e11,0x2904e657)    R(0x030e,0x2ec499e7,0x305555d3,0x2e94be0b)    R(0x030f,0x2e94be0b,0x30b551fa,0x2f14ba2f)    R(0x0310,0x2f14ba2f,0x30b551fa,0x3134ea2f)    R(0x0311,0x2ec499e7,0x30e529ad,0x305555d3)    R(0x0312,0x2745664e,0x2794f60b,0x2904e657)    R(0x0313,0x2e94be0b,0x305555d3,0x30b551fa)    R(0x0314,0x1e002e30,0x3107f3ff,0x00000184)    R(0x0315,0x1e002e30,0x3107f35a,0x000000a5)\n    R(0x0316,0x1e002e30,0x3101ab4f,0xffffffff)    R(0x0317,0x1e00e2b4,0x1fd09a9f,0x1e20d26c)    R(0x0318,0x1f716726,0x1fc0c2e3,0x1e113af6)    R(0x0319,0x1fc0c2e3,0x1fd09a9f,0x1e00e2b4)    R(0x031a,0x1fd09a9f,0x2100a255,0x1e20d26c)    R(0x031b,0x1f716726,0x21b0af2a,0x1fc0c2e3)    R(0x031c,0x1fc0c2e3,0x227042e4,0x1fd09a9f)    R(0x031d,0x1fd09a9f,0x22703e93,0x2100a255)    R(0x031e,0x21b0af2a,0x227042e4,0x1fc0c2e3)    R(0x031f,0x227042e4,0x22703e93,0x1fd09a9f)\n    R(0x0320,0x22703e93,0x24d05e54,0x2100a255)    R(0x0321,0x21b0af2a,0x24208f3f,0x227042e4)    R(0x0322,0x227042e4,0x25502eb0,0x22703e93)    R(0x0323,0x24208f3f,0x25703efa,0x227042e4)    R(0x0324,0x25502eb0,0x24d05e54,0x22703e93)    R(0x0325,0x25703efa,0x25502eb0,0x227042e4)    R(0x0326,0x24208f3f,0x28509316,0x25703efa)    R(0x0327,0x27e05679,0x24d05e54,0x25502eb0)    R(0x0328,0x25703efa,0x29006ac6,0x25502eb0)    R(0x0329,0x2870b630,0x24d05e54,0x27e05679)\n    R(0x032a,0x25502eb0,0x29006ac6,0x27e05679)    R(0x032b,0x28509316,0x29006ac6,0x25703efa)    R(0x032c,0x2870b630,0x27e05679,0x2b20a272)    R(0x032d,0x27e05679,0x29006ac6,0x2b20a272)    R(0x032e,0x28509316,0x2bd08700,0x29006ac6)    R(0x032f,0x28509316,0x2af0ef4f,0x2bd08700)    R(0x0330,0x29006ac6,0x2ca07ebe,0x2b20a272)    R(0x0331,0x2bd08700,0x2ca07ebe,0x29006ac6)    R(0x0332,0x2af0ef4f,0x2e20ab26,0x2bd08700)    R(0x0333,0x2b20a272,0x2ca07ebe,0x2ea0ae89)\n    R(0x0334,0x2d510633,0x2b20a272,0x2ea0ae89)    R(0x0335,0x2ef072dd,0x2ca07ebe,0x2bd08700)    R(0x0336,0x2e20ab26,0x2ef072dd,0x2bd08700)    R(0x0337,0x2ea0ae89,0x2ca07ebe,0x2ef072dd)    R(0x0338,0x2d510633,0x2ea0ae89,0x30411a53)    R(0x0339,0x3030d2f9,0x2ef072dd,0x2e20ab26)    R(0x033a,0x3030d2f9,0x2e20ab26,0x2f412b41)    R(0x033b,0x2ea0ae89,0x2ef072dd,0x3060caaa)    R(0x033c,0x2ea0ae89,0x3060caaa,0x30411a53)    R(0x033d,0x3060caaa,0x2ef072dd,0x3030d2f9)\n    R(0x033e,0x3101ab1f,0x3030d2f9,0x2f412b41)    R(0x033f,0x1e23de36,0x30e7f35a,0xffffffff)    R(0x0340,0x2115f309,0x1f752336,0x1e26372c)    R(0x0341,0x20070303,0x2115f309,0x1e26372c)    R(0x0342,0x1f752336,0x2134a72d,0x1ec43751)    R(0x0343,0x2167f2f1,0x20070303,0x1e47db1b)    R(0x0344,0x2115f309,0x22453303,0x1f752336)    R(0x0345,0x22453303,0x2134a72d,0x1f752336)    R(0x0346,0x22e6aad9,0x2115f309,0x20070303)    R(0x0347,0x23777ac4,0x20070303,0x2167f2f1)\n    R(0x0348,0x23777ac4,0x22e6aad9,0x20070303)    R(0x0349,0x23d5a6d6,0x22453303,0x2115f309)    R(0x034a,0x22453303,0x23d50710,0x2134a72d)    R(0x034b,0x22e6aad9,0x23d5a6d6,0x2115f309)    R(0x034c,0x23d50710,0x22e47355,0x2134a72d)    R(0x034d,0x23d5a6d6,0x24c54ecc,0x22453303)    R(0x034e,0x24c54ecc,0x23d50710,0x22453303)    R(0x034f,0x23777ac4,0x24e6fe8f,0x22e6aad9)    R(0x0350,0x22e6aad9,0x25163eae,0x23d5a6d6)    R(0x0351,0x23d50710,0x2604ab43,0x22e47355)\n    R(0x0352,0x24e6fe8f,0x25163eae,0x22e6aad9)    R(0x0353,0x25b7c683,0x24e6fe8f,0x23777ac4)    R(0x0354,0x23d5a6d6,0x26058694,0x24c54ecc)    R(0x0355,0x25163eae,0x26058694,0x23d5a6d6)    R(0x0356,0x24c54ecc,0x270516eb,0x23d50710)    R(0x0357,0x24e6fe8f,0x2646466c,0x25163eae)    R(0x0358,0x270516eb,0x2604ab43,0x23d50710)    R(0x0359,0x25b7c683,0x26672241,0x24e6fe8f)    R(0x035a,0x2646466c,0x26058694,0x25163eae)    R(0x035b,0x26672241,0x2646466c,0x24e6fe8f)\n    R(0x035c,0x26058694,0x27653695,0x24c54ecc)    R(0x035d,0x24c54ecc,0x27653695,0x270516eb)    R(0x035e,0x2646466c,0x2745664e,0x26058694)    R(0x035f,0x2745664e,0x27653695,0x26058694)    R(0x0360,0x270516eb,0x29849315,0x2604ab43)    R(0x0361,0x2745664e,0x2904e657,0x27653695)    R(0x0362,0x29849315,0x2884175a,0x2604ab43)    R(0x0363,0x27653695,0x2a44c6ba,0x270516eb)    R(0x0364,0x2904e657,0x2a44c6ba,0x27653695)    R(0x0365,0x270516eb,0x2a44c6ba,0x29849315)\n    R(0x0366,0x29849315,0x2c140f3b,0x2884175a)    R(0x0367,0x2904e657,0x2bd49669,0x2a44c6ba)    R(0x0368,0x2a44c6ba,0x2ca476f2,0x29849315)    R(0x0369,0x29849315,0x2ca476f2,0x2c140f3b)    R(0x036a,0x2bd49669,0x2e246eaa,0x2a44c6ba)    R(0x036b,0x2a44c6ba,0x2e246eaa,0x2ca476f2)    R(0x036c,0x2ca476f2,0x2f443f1f,0x2c140f3b)    R(0x036d,0x2d547236,0x2f447663,0x2bd49669)    R(0x036e,0x2bd49669,0x2f447663,0x2e246eaa)    R(0x036f,0x2c140f3b,0x2f443f1f,0x2ee3df56)\n    R(0x0370,0x2e246eaa,0x306456e2,0x2ca476f2)    R(0x0371,0x2ca476f2,0x306456e2,0x2f443f1f)    R(0x0372,0x2f447663,0x30d43e93,0x2e246eaa)    R(0x0373,0x2f443f1f,0x30e40f1c,0x2ee3df56)    R(0x0374,0x2e246eaa,0x30d43e93,0x306456e2)    R(0x0375,0x306456e2,0x30e40f1c,0x2f443f1f)    R(0x0376,0x1e008f16,0x3104abff,0x000000f6)    R(0x0377,0x1e008f16,0x28c4abff,0xffffffff)    R(0x0378,0x24208f3f,0x2740db62,0x28509316)    R(0x0379,0x21f0db80,0x24208f3f,0x21b0af2a)\n    R(0x037a,0x2490e79a,0x2740db62,0x24208f3f)    R(0x037b,0x21f0db80,0x2490e79a,0x24208f3f)    R(0x037c,0x20312b69,0x21f0db80,0x21b0af2a)    R(0x037d,0x22211fbd,0x2490e79a,0x21f0db80)    R(0x037e,0x2490e79a,0x28c13fa5,0x2740db62)    R(0x037f,0x20312b69,0x21b0af2a,0x1f716726)    R(0x0380,0x25115bd0,0x2490e79a,0x22211fbd)    R(0x0381,0x202177b1,0x22211fbd,0x21f0db80)    R(0x0382,0x202177b1,0x21f0db80,0x20312b69)    R(0x0383,0x25115bd0,0x28c13fa5,0x2490e79a)\n    R(0x0384,0x2261b3df,0x25115bd0,0x22211fbd)    R(0x0385,0x2261b3df,0x22211fbd,0x202177b1)    R(0x0386,0x1ef1df71,0x20312b69,0x1f716726)    R(0x0387,0x2811dfe3,0x28c13fa5,0x25115bd0)    R(0x0388,0x1ef1df71,0x202177b1,0x20312b69)    R(0x0389,0x25321bf3,0x25115bd0,0x2261b3df)    R(0x038a,0x20a22bd2,0x2261b3df,0x202177b1)    R(0x038b,0x25321bf3,0x2811dfe3,0x25115bd0)    R(0x038c,0x1e422b4d,0x1ef1df71,0x1f716726)    R(0x038d,0x1f125fa8,0x202177b1,0x1ef1df71)\n    R(0x038e,0x1f125fa8,0x20a22bd2,0x202177b1)    R(0x038f,0x22c2cfef,0x25321bf3,0x2261b3df)    R(0x0390,0x26b2a7ff,0x2811dfe3,0x25321bf3)    R(0x0391,0x22c2cfef,0x2261b3df,0x20a22bd2)    R(0x0392,0x1e52a770,0x1f125fa8,0x1ef1df71)    R(0x0393,0x22c2cfef,0x26b2a7ff,0x25321bf3)    R(0x0394,0x206317d6,0x20a22bd2,0x1f125fa8)    R(0x0395,0x22c2cfef,0x20a22bd2,0x206317d6)    R(0x0396,0x1f232b91,0x1f125fa8,0x1e52a770)    R(0x0397,0x1f232b91,0x206317d6,0x1f125fa8)\n    R(0x0398,0x24734ff3,0x26b2a7ff,0x22c2cfef)    R(0x0399,0x1eb33b64,0x1f232b91,0x1e52a770)    R(0x039a,0x27e327e7,0x26b2a7ff,0x24734ff3)    R(0x039b,0x22239be3,0x22c2cfef,0x206317d6)    R(0x039c,0x22239be3,0x24734ff3,0x22c2cfef)    R(0x039d,0x20a3a7bb,0x206317d6,0x1f232b91)    R(0x039e,0x2083cf71,0x1f232b91,0x1eb33b64)    R(0x039f,0x2483cbd6,0x27e327e7,0x24734ff3)    R(0x03a0,0x22239be3,0x206317d6,0x20a3a7bb)    R(0x03a1,0x2013ef50,0x1eb33b64,0x1e035f60)\n    R(0x03a2,0x2083cf71,0x20a3a7bb,0x1f232b91)    R(0x03a3,0x2783b7ab,0x27e327e7,0x2483cbd6)    R(0x03a4,0x2483cbd6,0x24734ff3,0x22239be3)    R(0x03a5,0x2013ef50,0x2083cf71,0x1eb33b64)    R(0x03a6,0x228403a7,0x22239be3,0x20a3a7bb)    R(0x03a7,0x228403a7,0x2483cbd6,0x22239be3)    R(0x03a8,0x228403a7,0x20a3a7bb,0x2083cf71)    R(0x03a9,0x1ec43751,0x2013ef50,0x1e035f60)    R(0x03aa,0x24f42789,0x2783b7ab,0x2483cbd6)    R(0x03ab,0x24f42789,0x2483cbd6,0x228403a7)\n    R(0x03ac,0x2884175a,0x2783b7ab,0x24f42789)    R(0x03ad,0x22e47355,0x2083cf71,0x2013ef50)    R(0x03ae,0x22e47355,0x228403a7,0x2083cf71)    R(0x03af,0x22e47355,0x24f42789,0x228403a7)    R(0x03b0,0x2134a72d,0x2013ef50,0x1ec43751)    R(0x03b1,0x2604ab43,0x2884175a,0x24f42789)    R(0x03b2,0x2134a72d,0x22e47355,0x2013ef50)    R(0x03b3,0x2604ab43,0x24f42789,0x22e47355)    R(0x03b4,0x26b09316,0x310417ff,0xffffffff)    R(0x03b5,0x2ee3df56,0x30e40f1c,0x30636f50)\n    R(0x03b6,0x2740db62,0x2af0ef4f,0x28509316)    R(0x03b7,0x3101ab1f,0x2f412b41,0x2f01df74)    R(0x03b8,0x30f28f42,0x3101ab1f,0x2f01df74)    R(0x03b9,0x2f412b41,0x2e20ab26,0x2cc1437a)    R(0x03ba,0x2cc1437a,0x2e20ab26,0x2af0ef4f)    R(0x03bb,0x2c140f3b,0x2ee3df56,0x2b33b37e)    R(0x03bc,0x2c140f3b,0x2b33b37e,0x2884175a)    R(0x03bd,0x30636f50,0x30f28f42,0x2f02c386)    R(0x03be,0x2f01df74,0x2f412b41,0x2cc1437a)    R(0x03bf,0x2ee3df56,0x30636f50,0x2dd35b8d)\n    R(0x03c0,0x30f28f42,0x2f01df74,0x2f02c386)    R(0x03c1,0x28c13fa5,0x2af0ef4f,0x2740db62)    R(0x03c2,0x2ee3df56,0x2dd35b8d,0x2b33b37e)    R(0x03c3,0x30636f50,0x2f02c386,0x2dd35b8d)    R(0x03c4,0x2cc1437a,0x2af0ef4f,0x28c13fa5)    R(0x03c5,0x2884175a,0x2b33b37e,0x2783b7ab)    R(0x03c6,0x2f01df74,0x2cc1437a,0x2b41b7b6)    R(0x03c7,0x2f02c386,0x2f01df74,0x2cd24bb3)    R(0x03c8,0x2b33b37e,0x2dd35b8d,0x2a935fba)    R(0x03c9,0x2b41b7b6,0x2cc1437a,0x28c13fa5)\n    R(0x03ca,0x2dd35b8d,0x2f02c386,0x2bd2e7c4)    R(0x03cb,0x2cd24bb3,0x2f01df74,0x2b41b7b6)    R(0x03cc,0x2b33b37e,0x2a935fba,0x2783b7ab)    R(0x03cd,0x2f02c386,0x2cd24bb3,0x2bd2e7c4)    R(0x03ce,0x2dd35b8d,0x2bd2e7c4,0x2a935fba)    R(0x03cf,0x2b41b7b6,0x28c13fa5,0x2811dfe3)    R(0x03d0,0x2783b7ab,0x2a935fba,0x27e327e7)    R(0x03d1,0x29a27be7,0x2cd24bb3,0x2b41b7b6)    R(0x03d2,0x2bd2e7c4,0x2cd24bb3,0x29a27be7)    R(0x03d3,0x2a935fba,0x2bd2e7c4,0x27e327e7)\n    R(0x03d4,0x29a27be7,0x2b41b7b6,0x2811dfe3)    R(0x03d5,0x27e327e7,0x2bd2e7c4,0x29a27be7)    R(0x03d6,0x29a27be7,0x2811dfe3,0x26b2a7ff)    R(0x03d7,0x27e327e7,0x29a27be7,0x26b2a7ff)    R(0x03d8,0x2f400000,0x3ff7af50,0x00000379)    R(0x03d9,0x2f400000,0x3d149f50,0x000001e8)    R(0x03da,0x2fc00000,0x3d12656d,0x00000134)    R(0x03db,0x2fe00000,0x3d11d8db,0xffffffff)    R(0x03dc,0x3020ecc2,0x31310c8b,0x2fe148db)    R(0x03dd,0x2fe148db,0x31310c8b,0x31916ca8)\n    R(0x03de,0x3120d0aa,0x3210e46f,0x3020ecc2)    R(0x03df,0x3020ecc2,0x3210e46f,0x31310c8b)    R(0x03e0,0x31310c8b,0x32a1305f,0x31916ca8)    R(0x03e1,0x3210e46f,0x33910c40,0x31310c8b)    R(0x03e2,0x3120d0aa,0x33e0d464,0x3210e46f)    R(0x03e3,0x31310c8b,0x33910c40,0x32a1305f)    R(0x03e4,0x31916ca8,0x32a1305f,0x3431786d)    R(0x03e5,0x3120d0aa,0x3430d4b8,0x33e0d464)    R(0x03e6,0x31916ca8,0x3431786d,0x33f1d8c3)    R(0x03e7,0x3210e46f,0x34e0f42d,0x33910c40)\n    R(0x03e8,0x33e0d464,0x34e0f42d,0x3210e46f)    R(0x03e9,0x33910c40,0x35314825,0x32a1305f)    R(0x03ea,0x32a1305f,0x35314825,0x3431786d)    R(0x03eb,0x33f1d8c3,0x3431786d,0x36c1a07d)    R(0x03ec,0x34e0f42d,0x3691380f,0x33910c40)    R(0x03ed,0x3430d4b8,0x3730b484,0x33e0d464)    R(0x03ee,0x33910c40,0x3691380f,0x35314825)    R(0x03ef,0x3431786d,0x35314825,0x36e1702b)    R(0x03f0,0x33e0d464,0x3790dc37,0x34e0f42d)    R(0x03f1,0x33f1d8c3,0x36c1a07d,0x36a1c8cd)\n    R(0x03f2,0x3431786d,0x36e1702b,0x36c1a07d)    R(0x03f3,0x370068d9,0x3730b484,0x3430d4b8)    R(0x03f4,0x33e0d464,0x3730b484,0x3790dc37)    R(0x03f5,0x3691380f,0x38315c03,0x35314825)    R(0x03f6,0x34e0f42d,0x3891180a,0x3691380f)    R(0x03f7,0x35314825,0x38315c03,0x36e1702b)    R(0x03f8,0x3790dc37,0x3891180a,0x34e0f42d)    R(0x03f9,0x36a1c8cd,0x36c1a07d,0x39315c8d)    R(0x03fa,0x36c1a07d,0x36e1702b,0x39a16840)    R(0x03fb,0x370068d9,0x3950349f,0x3730b484)\n    R(0x03fc,0x36a1c8cd,0x39315c8d,0x38c154d9)    R(0x03fd,0x36e1702b,0x38315c03,0x39a1640a)    R(0x03fe,0x3691380f,0x3a113c00,0x38315c03)    R(0x03ff,0x3891180a,0x3a113c00,0x3691380f)    R(0x0400,0x36c1a07d,0x39a16840,0x39315c8d)    R(0x0401,0x3730b484,0x3af05065,0x3790dc37)    R(0x0402,0x36e1702b,0x39a1640a,0x39a16840)    R(0x0403,0x3790dc37,0x3b30bc29,0x3891180a)    R(0x0404,0x3950349f,0x3af05065,0x3730b484)    R(0x0405,0x38315c03,0x3af14803,0x39a1640a)\n    R(0x0406,0x38c154d9,0x39315c8d,0x3af0c09f)    R(0x0407,0x3a113c00,0x3af14803,0x38315c03)    R(0x0408,0x3790dc37,0x3af05065,0x3b30bc29)    R(0x0409,0x393008c2,0x3b500087,0x3950349f)    R(0x040a,0x39315c8d,0x39a16840,0x3be10054)    R(0x040b,0x3891180a,0x3c40e017,0x3a113c00)    R(0x040c,0x3a700cb4,0x3b500087,0x393008c2)    R(0x040d,0x39a16840,0x39a1640a,0x3bf13419)    R(0x040e,0x3b500087,0x3af05065,0x3950349f)    R(0x040f,0x3b30bc29,0x3c40e017,0x3891180a)\n    R(0x0410,0x39315c8d,0x3be10054,0x3af0c09f)    R(0x0411,0x39a1640a,0x3af14803,0x3bf13419)    R(0x0412,0x39a16840,0x3bf13419,0x3be10054)    R(0x0413,0x3c810015,0x3af14803,0x3a113c00)    R(0x0414,0x3b2044ac,0x3c402476,0x3a700cb4)    R(0x0415,0x3a700cb4,0x3c402476,0x3b500087)    R(0x0416,0x3af05065,0x3ca0584f,0x3b30bc29)    R(0x0417,0x3c40e017,0x3c810015,0x3a113c00)    R(0x0418,0x3af0c09f,0x3cc07c68,0x3b2044ac)    R(0x0419,0x3b500087,0x3ca0584f,0x3af05065)\n    R(0x041a,0x3bf13419,0x3af14803,0x3c810015)    R(0x041b,0x3af0c09f,0x3be10054,0x3cc07c68)    R(0x041c,0x3b30bc29,0x3ca0584f,0x3c40e017)    R(0x041d,0x3cc07c68,0x3c402476,0x3b2044ac)    R(0x041e,0x3c402476,0x3ca0584f,0x3b500087)    R(0x041f,0x3be10054,0x3bf13419,0x3d00d830)    R(0x0420,0x3bf13419,0x3c810015,0x3d00d830)    R(0x0421,0x3be10054,0x3d00d830,0x3cc07c68)    R(0x0422,0x3d10903c,0x3c810015,0x3c40e017)    R(0x0423,0x3c40e017,0x3ca0584f,0x3d10903c)\n    R(0x0424,0x3d10903c,0x3ca0584f,0x3c402476)    R(0x0425,0x3cc07c68,0x3d10903c,0x3c402476)    R(0x0426,0x3d00d830,0x3c810015,0x3d10903c)    R(0x0427,0x3d00d830,0x3d10903c,0x3cc07c68)    R(0x0428,0x2fc0089f,0x3b22656d,0xffffffff)    R(0x0429,0x2fc0e501,0x3120d0aa,0x3020ecc2)    R(0x042a,0x2fe148db,0x31916ca8,0x30c1ccf5)    R(0x042b,0x3100f541,0x31c0e0f5,0x2fc0e501)    R(0x042c,0x2fc0e501,0x31c0e0f5,0x3120d0aa)    R(0x042d,0x2ff22d49,0x30c1ccf5,0x32422513)\n    R(0x042e,0x2ff22d49,0x32422513,0x32526564)    R(0x042f,0x30c1ccf5,0x31916ca8,0x33f1d8c3)    R(0x0430,0x30c1ccf5,0x33f1d8c3,0x32422513)    R(0x0431,0x31c0e0f5,0x3430d4b8,0x3120d0aa)    R(0x0432,0x3100f541,0x34f0a519,0x31c0e0f5)    R(0x0433,0x32526564,0x32422513,0x34a22117)    R(0x0434,0x3390c95f,0x34f0a519,0x3100f541)    R(0x0435,0x32422513,0x33f1d8c3,0x34a22117)    R(0x0436,0x34f0a519,0x3430d4b8,0x31c0e0f5)    R(0x0437,0x32526564,0x34a22117,0x34c2296b)\n    R(0x0438,0x3390c95f,0x35a0854b,0x34f0a519)    R(0x0439,0x34a22117,0x33f1d8c3,0x36a1c8cd)    R(0x043a,0x34f0a519,0x370068d9,0x3430d4b8)    R(0x043b,0x34c2296b,0x34a22117,0x36d1cd21)    R(0x043c,0x35a0854b,0x36f03d07,0x34f0a519)    R(0x043d,0x34a22117,0x36a1c8cd,0x36d1cd21)    R(0x043e,0x34c2296b,0x36d1cd21,0x36a1a16d)    R(0x043f,0x34f0a519,0x36f03d07,0x370068d9)    R(0x0440,0x35a0854b,0x381038fa,0x36f03d07)    R(0x0441,0x3730993d,0x381038fa,0x35a0854b)\n    R(0x0442,0x36d1cd21,0x38414926,0x36a1a16d)    R(0x0443,0x36d1cd21,0x36a1c8cd,0x38c154d9)    R(0x0444,0x36a1a16d,0x38414926,0x37c1094e)    R(0x0445,0x36f03d07,0x393008c2,0x370068d9)    R(0x0446,0x36d1cd21,0x38c154d9,0x38414926)    R(0x0447,0x37c1094e,0x390074fa,0x3730993d)    R(0x0448,0x381038fa,0x393008c2,0x36f03d07)    R(0x0449,0x390074fa,0x381038fa,0x3730993d)    R(0x044a,0x370068d9,0x393008c2,0x3950349f)    R(0x044b,0x38414926,0x3990c8eb,0x37c1094e)\n    R(0x044c,0x37c1094e,0x3990c8eb,0x390074fa)    R(0x044d,0x38c154d9,0x3990c8eb,0x38414926)    R(0x044e,0x390074fa,0x3a700cb4,0x381038fa)    R(0x044f,0x3a700cb4,0x393008c2,0x381038fa)    R(0x0450,0x38c154d9,0x3af0c09f,0x3990c8eb)    R(0x0451,0x3990c8eb,0x3b2044ac,0x390074fa)    R(0x0452,0x390074fa,0x3b2044ac,0x3a700cb4)    R(0x0453,0x3af0c09f,0x3b2044ac,0x3990c8eb)    R(0x0454,0x2f40853d,0x38c49f50,0x000000e4)    R(0x0455,0x2f40853d,0x38c49e38,0xffffffff)\n    R(0x0456,0x3730993d,0x35a0854b,0x35d0f586)    R(0x0457,0x33f0d998,0x35a0854b,0x3390c95f)    R(0x0458,0x35d0f586,0x35a0854b,0x33f0d998)    R(0x0459,0x37c1094e,0x3730993d,0x35d0f586)    R(0x045a,0x31310593,0x33f0d998,0x3390c95f)    R(0x045b,0x31310593,0x3390c95f,0x3100f541)    R(0x045c,0x32512de1,0x33f0d998,0x31310593)    R(0x045d,0x35d0f586,0x33f0d998,0x340149d3)    R(0x045e,0x2f412158,0x31310593,0x3100f541)    R(0x045f,0x340149d3,0x33f0d998,0x32512de1)\n    R(0x0460,0x2ff139d6,0x32512de1,0x31310593)    R(0x0461,0x37c1094e,0x35d0f586,0x35d16da2)    R(0x0462,0x30214215,0x32512de1,0x2ff139d6)    R(0x0463,0x35d16da2,0x35d0f586,0x340149d3)    R(0x0464,0x32017e1f,0x32512de1,0x30214215)    R(0x0465,0x32017e1f,0x340149d3,0x32512de1)    R(0x0466,0x36a1a16d,0x37c1094e,0x35d16da2)    R(0x0467,0x35d16da2,0x340149d3,0x33c1b5f2)    R(0x0468,0x33c1b5f2,0x340149d3,0x32017e1f)    R(0x0469,0x36a1a16d,0x35d16da2,0x34a1f1b6)\n    R(0x046a,0x34a1f1b6,0x35d16da2,0x33c1b5f2)    R(0x046b,0x3241f638,0x33c1b5f2,0x32017e1f)    R(0x046c,0x34c2296b,0x36a1a16d,0x34a1f1b6)    R(0x046d,0x34a1f1b6,0x33c1b5f2,0x32c229f9)    R(0x046e,0x32c229f9,0x33c1b5f2,0x3241f638)    R(0x046f,0x324271b2,0x34a1f1b6,0x32c229f9)    R(0x0470,0x324271b2,0x34c2296b,0x34a1f1b6)    R(0x0471,0x3182921f,0x32c229f9,0x3241f638)    R(0x0472,0x324271b2,0x32526564,0x34c2296b)    R(0x0473,0x2fa27d93,0x2ff22d49,0x32526564)\n    R(0x0474,0x324271b2,0x32c229f9,0x30e29df2)    R(0x0475,0x2fa27d93,0x32526564,0x324271b2)    R(0x0476,0x30e29df2,0x32c229f9,0x3182921f)    R(0x0477,0x2f72b1d1,0x2fa27d93,0x324271b2)    R(0x0478,0x2f72b1d1,0x324271b2,0x30e29df2)    R(0x0479,0x2ff2ea02,0x30e29df2,0x3182921f)    R(0x047a,0x2ff2ea02,0x3182921f,0x3172fe23)    R(0x047b,0x2ff2ea02,0x3172fe23,0x30533606)    R(0x047c,0x30533606,0x3172fe23,0x3293660d)    R(0x047d,0x3172fe23,0x32f35e31,0x3293660d)\n    R(0x047e,0x30533606,0x3293660d,0x31739ded)    R(0x047f,0x30533606,0x31739ded,0x2f73bdeb)    R(0x0480,0x32f35e31,0x35a3e9f7,0x3293660d)    R(0x0481,0x3293660d,0x3433edd4,0x31739ded)    R(0x0482,0x34e3e627,0x35a3e9f7,0x32f35e31)    R(0x0483,0x35a3e9f7,0x3433edd4,0x3293660d)    R(0x0484,0x2f73bdeb,0x31739ded,0x324431bb)    R(0x0485,0x31739ded,0x3433edd4,0x324431bb)    R(0x0486,0x35a3e9f7,0x36c451b9,0x3433edd4)    R(0x0487,0x34e3e627,0x37b475f0,0x35a3e9f7)\n    R(0x0488,0x2f73bdeb,0x324431bb,0x30046dca)    R(0x0489,0x324431bb,0x3433edd4,0x35549d8e)    R(0x048a,0x36547e19,0x37b475f0,0x34e3e627)    R(0x048b,0x35a3e9f7,0x38c49dbd,0x36c451b9)    R(0x048c,0x3433edd4,0x36c451b9,0x35549d8e)    R(0x048d,0x37b475f0,0x38c49dbd,0x35a3e9f7)    R(0x048e,0x2f40ca15,0x36548b50,0xffffffff)    R(0x048f,0x31816acc,0x3060caaa,0x3030d2f9)    R(0x0490,0x30411a53,0x3060caaa,0x3171766d)    R(0x0491,0x3171766d,0x3060caaa,0x31816acc)\n    R(0x0492,0x30214215,0x30411a53,0x32017e1f)    R(0x0493,0x31816acc,0x3030d2f9,0x3101ab1f)    R(0x0494,0x32017e1f,0x30411a53,0x3171766d)    R(0x0495,0x3241f638,0x32017e1f,0x3171766d)    R(0x0496,0x32122e98,0x3171766d,0x31816acc)    R(0x0497,0x32026aee,0x31816acc,0x3101ab1f)    R(0x0498,0x3241f638,0x3171766d,0x32122e98)    R(0x0499,0x32122e98,0x31816acc,0x32026aee)    R(0x049a,0x30f28f42,0x32026aee,0x3101ab1f)    R(0x049b,0x3202d25a,0x3241f638,0x32122e98)\n    R(0x049c,0x3182921f,0x3241f638,0x3202d25a)    R(0x049d,0x32333ead,0x32122e98,0x32026aee)    R(0x049e,0x3202d25a,0x32122e98,0x32333ead)    R(0x049f,0x31c35f09,0x32026aee,0x30f28f42)    R(0x04a0,0x3182921f,0x3202d25a,0x3172fe23)    R(0x04a1,0x32333ead,0x32026aee,0x31c35f09)    R(0x04a2,0x3202d25a,0x32f35e31,0x3172fe23)    R(0x04a3,0x30636f50,0x31c35f09,0x30f28f42)    R(0x04a4,0x3293865b,0x3202d25a,0x32333ead)    R(0x04a5,0x3293865b,0x32f35e31,0x3202d25a)\n    R(0x04a6,0x31a3fed0,0x32333ead,0x31c35f09)    R(0x04a7,0x31f3ea7e,0x3293865b,0x32333ead)    R(0x04a8,0x34e3e627,0x32f35e31,0x3293865b)    R(0x04a9,0x30e40f1c,0x31c35f09,0x30636f50)    R(0x04aa,0x31f3ea7e,0x32333ead,0x31a3fed0)    R(0x04ab,0x31a3fed0,0x31c35f09,0x30e40f1c)    R(0x04ac,0x33740a4e,0x34e3e627,0x3293865b)    R(0x04ad,0x33740a4e,0x3293865b,0x31f3ea7e)    R(0x04ae,0x30d43e93,0x31f3ea7e,0x31a3fed0)    R(0x04af,0x31b45a5d,0x33740a4e,0x31f3ea7e)\n    R(0x04b0,0x306456e2,0x31a3fed0,0x30e40f1c)    R(0x04b1,0x33740a4e,0x36547e19,0x34e3e627)    R(0x04b2,0x31b45a5d,0x31f3ea7e,0x30d43e93)    R(0x04b3,0x30d43e93,0x31a3fed0,0x306456e2)    R(0x04b4,0x31b45a5d,0x34348a37,0x33740a4e)    R(0x04b5,0x2f447663,0x31b45a5d,0x30d43e93)    R(0x04b6,0x34348a37,0x36547e19,0x33740a4e)    R(0x04b7,0x2f4430a6,0x3ff7ae63,0x00000158)    R(0x04b8,0x334540a6,0x3ff7ad87,0x000000a0)    R(0x04b9,0x366638a6,0x3ff7ad20,0xffffffff)\n    R(0x04ba,0x36e79101,0x3897a4d7,0x36679520)    R(0x04bb,0x36679520,0x3897a4d7,0x3837acf3)    R(0x04bc,0x37c75cec,0x396788c1,0x36e79101)    R(0x04bd,0x36e79101,0x396788c1,0x3897a4d7)    R(0x04be,0x3856b907,0x3a373cc1,0x37c75cec)    R(0x04bf,0x3a373cc1,0x396788c1,0x37c75cec)    R(0x04c0,0x3897a4d7,0x3b2788b8,0x3837acf3)    R(0x04c1,0x3837acf3,0x3ae780d7,0x38d7750e)    R(0x04c2,0x396788c1,0x3af77cae,0x3897a4d7)    R(0x04c3,0x3856b907,0x3b56a4ea,0x3a373cc1)\n    R(0x04c4,0x3837acf3,0x3b2788b8,0x3ae780d7)    R(0x04c5,0x3897a4d7,0x3af77cae,0x3b2788b8)    R(0x04c6,0x3a373cc1,0x3bf758a6,0x396788c1)    R(0x04c7,0x396788c1,0x3bf758a6,0x3af77cae)    R(0x04c8,0x38d7750e,0x3ae780d7,0x3d2714f9)    R(0x04c9,0x3b56a4ea,0x3cc718b3,0x3a373cc1)    R(0x04ca,0x3a373cc1,0x3cc718b3,0x3bf758a6)    R(0x04cb,0x3af77cae,0x3d4750ab,0x3b2788b8)    R(0x04cc,0x3bf758a6,0x3d4750ab,0x3af77cae)    R(0x04cd,0x3b2788b8,0x3e3734c5,0x3ae780d7)\n    R(0x04ce,0x3c863917,0x3e56c8d8,0x3b56a4ea)    R(0x04cf,0x3ae780d7,0x3e3734c5,0x3d2714f9)    R(0x04d0,0x3b56a4ea,0x3e56c8d8,0x3cc718b3)    R(0x04d1,0x3b2788b8,0x3d4750ab,0x3e3734c5)    R(0x04d2,0x3cc718b3,0x3e1728b1,0x3bf758a6)    R(0x04d3,0x3bf758a6,0x3e1728b1,0x3d4750ab)    R(0x04d4,0x3e56c8d8,0x3e1728b1,0x3cc718b3)    R(0x04d5,0x3c863917,0x3f168514,0x3e56c8d8)    R(0x04d6,0x3e1728b1,0x3f2710c8,0x3d4750ab)    R(0x04d7,0x3d4750ab,0x3f2710c8,0x3e3734c5)\n    R(0x04d8,0x3d2714f9,0x3e3734c5,0x3f76d51a)    R(0x04d9,0x3e56c8d8,0x3f86e8d9,0x3e1728b1)    R(0x04da,0x3f86e8d9,0x3f2710c8,0x3e1728b1)    R(0x04db,0x3f168514,0x3f86e8d9,0x3e56c8d8)    R(0x04dc,0x3e3734c5,0x3f2710c8,0x3fd6e8f4)    R(0x04dd,0x3f76d51a,0x3e3734c5,0x3fd6e8f4)    R(0x04de,0x3ff6c907,0x3f86e8d9,0x3f168514)    R(0x04df,0x3ff6c907,0x3f2710c8,0x3f86e8d9)    R(0x04e0,0x3fd6e8f4,0x3f2710c8,0x3ff6c907)    R(0x04e1,0x334540ea,0x3ff7ad87,0xffffffff)\n    R(0x04e2,0x3345b174,0x35f6313d,0x33e68d65)    R(0x04e3,0x3345b174,0x3565615d,0x35f6313d)    R(0x04e4,0x33e68d65,0x35c70d2c,0x34f7414a)    R(0x04e5,0x35f6313d,0x35c70d2c,0x33e68d65)    R(0x04e6,0x34f7414a,0x36679520,0x34d73969)    R(0x04e7,0x34d73969,0x3657853a,0x35071d82)    R(0x04e8,0x34d73969,0x36679520,0x3657853a)    R(0x04e9,0x35c70d2c,0x36e79101,0x34f7414a)    R(0x04ea,0x34f7414a,0x36e79101,0x36679520)    R(0x04eb,0x35071d82,0x3657853a,0x36f7294d)\n    R(0x04ec,0x35f6313d,0x3856b907,0x35c70d2c)    R(0x04ed,0x3565615d,0x3905f927,0x35f6313d)    R(0x04ee,0x35c70d2c,0x37c75cec,0x36e79101)    R(0x04ef,0x36679520,0x3837acf3,0x3657853a)    R(0x04f0,0x3856b907,0x37c75cec,0x35c70d2c)    R(0x04f1,0x3565615d,0x37b5415a,0x3905f927)    R(0x04f2,0x3657853a,0x38d7750e,0x36f7294d)    R(0x04f3,0x35f6313d,0x3905f927,0x3856b907)    R(0x04f4,0x3657853a,0x3837acf3,0x38d7750e)    R(0x04f5,0x36f7294d,0x3a46cd30,0x3866516b)\n    R(0x04f6,0x36f7294d,0x38d7750e,0x3a46cd30)    R(0x04f7,0x37b5415a,0x3ab5994e,0x3905f927)    R(0x04f8,0x3905f927,0x3b56a4ea,0x3856b907)    R(0x04f9,0x3866516b,0x3a46cd30,0x3b763d79)    R(0x04fa,0x3ab5994e,0x3c863917,0x3905f927)    R(0x04fb,0x38d7750e,0x3d2714f9,0x3a46cd30)    R(0x04fc,0x3905f927,0x3c863917,0x3b56a4ea)    R(0x04fd,0x3b054d86,0x3d35fd51,0x3ab5994e)    R(0x04fe,0x3b763d79,0x3a46cd30,0x3d66a541)    R(0x04ff,0x3ab5994e,0x3d35fd51,0x3c863917)\n    R(0x0500,0x3a46cd30,0x3d2714f9,0x3d66a541)    R(0x0501,0x3b763d79,0x3d66a541,0x3e467963)    R(0x0502,0x3d35fd51,0x3f168514,0x3c863917)    R(0x0503,0x3cb5dd87,0x3ee6714a,0x3d35fd51)    R(0x0504,0x3d66a541,0x3d2714f9,0x3f76d51a)    R(0x0505,0x3d66a541,0x3f76d51a,0x3e467963)    R(0x0506,0x3ee6714a,0x3f168514,0x3d35fd51)    R(0x0507,0x3e467963,0x3f86a539,0x3db63d7b)    R(0x0508,0x3db63d7b,0x3f86a539,0x3ee6714a)    R(0x0509,0x3e467963,0x3f76d51a,0x3f86a539)\n    R(0x050a,0x3ee6714a,0x3ff6c907,0x3f168514)    R(0x050b,0x3f86a539,0x3ff6c907,0x3ee6714a)    R(0x050c,0x3f76d51a,0x3fd6e8f4,0x3f86a539)    R(0x050d,0x3f86a539,0x3fd6e8f4,0x3ff6c907)    R(0x050e,0x2f44314a,0x3ee74263,0x000000b5)    R(0x050f,0x2f44314e,0x3d360663,0xffffffff)    R(0x0510,0x2f447663,0x3134ea2f,0x31b45a5d)    R(0x0511,0x305555d3,0x322605c4,0x30b551fa)    R(0x0512,0x30e529ad,0x3215f59c,0x305555d3)    R(0x0513,0x30046dca,0x32c4e190,0x30e529ad)\n    R(0x0514,0x305555d3,0x3215f59c,0x322605c4)    R(0x0515,0x30b551fa,0x3305c9f0,0x3134ea2f)    R(0x0516,0x30046dca,0x324431bb,0x32c4e190)    R(0x0517,0x30b551fa,0x322605c4,0x3305c9f0)    R(0x0518,0x30e529ad,0x3345b174,0x3215f59c)    R(0x0519,0x3134ea2f,0x33951217,0x31b45a5d)    R(0x051a,0x30e529ad,0x32c4e190,0x3345b174)    R(0x051b,0x3134ea2f,0x3305c9f0,0x33951217)    R(0x051c,0x31b45a5d,0x33951217,0x34348a37)    R(0x051d,0x324431bb,0x35549d8e,0x32c4e190)\n    R(0x051e,0x3305c9f0,0x34258df0,0x33951217)    R(0x051f,0x32c4e190,0x3565615d,0x3345b174)    R(0x0520,0x32c4e190,0x35549d8e,0x3565615d)    R(0x0521,0x33951217,0x34258df0,0x36955de8)    R(0x0522,0x33951217,0x36f50a09,0x34348a37)    R(0x0523,0x33951217,0x36955de8,0x36f50a09)    R(0x0524,0x34258df0,0x36a5d1a9,0x36955de8)    R(0x0525,0x34348a37,0x36f50a09,0x36547e19)    R(0x0526,0x35549d8e,0x37b5415a,0x3565615d)    R(0x0527,0x36c451b9,0x38b4e585,0x35549d8e)\n    R(0x0528,0x35549d8e,0x38b4e585,0x37b5415a)    R(0x0529,0x36f50a09,0x38e519e8,0x36547e19)    R(0x052a,0x36955de8,0x36a5d1a9,0x3925c9b2)    R(0x052b,0x36547e19,0x38e519e8,0x37b475f0)    R(0x052c,0x36955de8,0x398591d8,0x36f50a09)    R(0x052d,0x38c49dbd,0x38b4e585,0x36c451b9)    R(0x052e,0x36955de8,0x3925c9b2,0x398591d8)    R(0x052f,0x36f50a09,0x398591d8,0x38e519e8)    R(0x0530,0x37b475f0,0x3a6529ba,0x38c49dbd)    R(0x0531,0x38e519e8,0x3a6529ba,0x37b475f0)\n    R(0x0532,0x38b4e585,0x3ab5994e,0x37b5415a)    R(0x0533,0x38c49dbd,0x3b054d86,0x38b4e585)    R(0x0534,0x398591d8,0x3b55b9b4,0x38e519e8)    R(0x0535,0x3a6529ba,0x3b054d86,0x38c49dbd)    R(0x0536,0x3b054d86,0x3ab5994e,0x38b4e585)    R(0x0537,0x38e519e8,0x3b55b9b4,0x3a6529ba)    R(0x0538,0x398591d8,0x3c1605a0,0x3b55b9b4)    R(0x0539,0x3a6529ba,0x3cb5dd87,0x3b054d86)    R(0x053a,0x3b55b9b4,0x3cb5dd87,0x3a6529ba)    R(0x053b,0x3cb5dd87,0x3d35fd51,0x3b054d86)\n    R(0x053c,0x32158d4a,0x3ee741f0,0xffffffff)    R(0x053d,0x3215f59c,0x3376b58b,0x322605c4)    R(0x053e,0x322605c4,0x33d6a1ae,0x3305c9f0)    R(0x053f,0x3345b174,0x33e68d65,0x3215f59c)    R(0x0540,0x322605c4,0x3376b58b,0x33d6a1ae)    R(0x0541,0x3215f59c,0x33e68d65,0x3376b58b)    R(0x0542,0x3305c9f0,0x33d6a1ae,0x344671c6)    R(0x0543,0x3305c9f0,0x344671c6,0x34258df0)    R(0x0544,0x3376b58b,0x34d73969,0x33d6a1ae)    R(0x0545,0x33e68d65,0x34f7414a,0x3376b58b)\n    R(0x0546,0x33d6a1ae,0x35071d82,0x344671c6)    R(0x0547,0x3376b58b,0x34f7414a,0x34d73969)    R(0x0548,0x344671c6,0x34e61dc3,0x34258df0)    R(0x0549,0x33d6a1ae,0x34d73969,0x35071d82)    R(0x054a,0x344671c6,0x35c6b18a,0x34e61dc3)    R(0x054b,0x344671c6,0x35071d82,0x35c6b18a)    R(0x054c,0x34258df0,0x34e61dc3,0x36a5d1a9)    R(0x054d,0x34e61dc3,0x35c6b18a,0x36a5d1a9)    R(0x054e,0x35071d82,0x36f7294d,0x35c6b18a)    R(0x054f,0x35c6b18a,0x3866516b,0x36a5d1a9)\n    R(0x0550,0x35c6b18a,0x36f7294d,0x3866516b)    R(0x0551,0x36a5d1a9,0x3866516b,0x3925c9b2)    R(0x0552,0x3925c9b2,0x3866516b,0x3b763d79)    R(0x0553,0x3925c9b2,0x3c1605a0,0x398591d8)    R(0x0554,0x3925c9b2,0x3b763d79,0x3c1605a0)    R(0x0555,0x3c1605a0,0x3db63d7b,0x3b55b9b4)    R(0x0556,0x3b55b9b4,0x3db63d7b,0x3cb5dd87)    R(0x0557,0x3b763d79,0x3e467963,0x3c1605a0)    R(0x0558,0x3c1605a0,0x3e467963,0x3db63d7b)    R(0x0559,0x3db63d7b,0x3ee6714a,0x3cb5dd87)\n    R(0x055a,0x00970c3b,0x290fff8e,0x000006f2)    R(0x055b,0x00972c3e,0x13dfff88,0x0000040d)    R(0x055c,0x00972c3e,0x13ac8f88,0x000001d8)    R(0x055d,0x01172c3e,0x13ac7e2d,0x0000011a)    R(0x055e,0x01174487,0x057c5a2d,0x00000090)    R(0x055f,0x01174c87,0x057c3d2d,0xffffffff)    R(0x0560,0x02074cf4,0x011790c3,0x021834ec)    R(0x0561,0x0308112b,0x02074cf4,0x021834ec)    R(0x0562,0x011790c3,0x0177cca9,0x014878bc)    R(0x0563,0x03788496,0x0177cca9,0x0387a49f)\n    R(0x0564,0x021834ec,0x011790c3,0x014878bc)    R(0x0565,0x014878bc,0x0177cca9,0x01a8d09e)    R(0x0566,0x01a8d09e,0x0177cca9,0x03788496)    R(0x0567,0x0308112b,0x021834ec,0x03391d25)    R(0x0568,0x021834ec,0x014878bc,0x023910e5)    R(0x0569,0x03391d25,0x021834ec,0x023910e5)    R(0x056a,0x016964b7,0x014878bc,0x01a8d09e)    R(0x056b,0x0399648d,0x01a8d09e,0x03788496)    R(0x056c,0x023910e5,0x014878bc,0x016964b7)    R(0x056d,0x01d9c099,0x01a8d09e,0x0399648d)\n    R(0x056e,0x01d9c099,0x016964b7,0x01a8d09e)    R(0x056f,0x03391d25,0x023910e5,0x0239dcec)    R(0x0570,0x023910e5,0x016964b7,0x0239dcec)    R(0x0571,0x03391d25,0x0239dcec,0x0279fd2a)    R(0x0572,0x038a2c88,0x01d9c099,0x0399648d)    R(0x0573,0x019a4cbe,0x016964b7,0x01d9c099)    R(0x0574,0x0239dcec,0x016964b7,0x019a4cbe)    R(0x0575,0x0279fd2a,0x0239dcec,0x018a9907)    R(0x0576,0x027a9ca1,0x01d9c099,0x038a2c88)    R(0x0577,0x019a4cbe,0x01d9c099,0x027a9ca1)\n    R(0x0578,0x018a9907,0x0239dcec,0x019a4cbe)    R(0x0579,0x057ad487,0x027a9ca1,0x038a2c88)    R(0x057a,0x018a9907,0x019a4cbe,0x020afcde)    R(0x057b,0x020afcde,0x019a4cbe,0x027a9ca1)    R(0x057c,0x045b38bb,0x027a9ca1,0x057ad487)    R(0x057d,0x020afcde,0x027a9ca1,0x045b38bb)    R(0x057e,0x01bb4d29,0x018a9907,0x020afcde)    R(0x057f,0x038b9900,0x020afcde,0x045b38bb)    R(0x0580,0x01bb4d29,0x020afcde,0x038b9900)    R(0x0581,0x01bb4d29,0x038b9900,0x02ac392d)\n    R(0x0582,0x02ac392d,0x038b9900,0x053c3cfc)    R(0x0583,0x01374507,0x033c5a2d,0xffffffff)    R(0x0584,0x029835c6,0x026745d6,0x02b7a17d)    R(0x0585,0x0257d221,0x026745d6,0x029835c6)    R(0x0586,0x02f8b171,0x02b7a17d,0x0308112b)    R(0x0587,0x029835c6,0x02b7a17d,0x02f8b171)    R(0x0588,0x0298d20e,0x0257d221,0x029835c6)    R(0x0589,0x02f8b171,0x0308112b,0x03391d25)    R(0x058a,0x02b921bb,0x029835c6,0x02f8b171)    R(0x058b,0x0298d20e,0x029835c6,0x02b921bb)\n    R(0x058c,0x02f8b171,0x03391d25,0x0279a16e)    R(0x058d,0x02b921bb,0x02f8b171,0x0279a16e)    R(0x058e,0x0219c5f8,0x0298d20e,0x02b921bb)    R(0x058f,0x02b921bb,0x0279a16e,0x0189ddb2)    R(0x0590,0x0279a16e,0x03391d25,0x0279fd2a)    R(0x0591,0x0219c5f8,0x02b921bb,0x0189ddb2)    R(0x0592,0x0189ddb2,0x0279a16e,0x015a755f)    R(0x0593,0x0279a16e,0x0279fd2a,0x015a755f)    R(0x0594,0x0219c5f8,0x0189ddb2,0x013ab9ff)    R(0x0595,0x0189ddb2,0x015a755f,0x016a91b0)\n    R(0x0596,0x015a755f,0x0279fd2a,0x018a9907)    R(0x0597,0x013ab9ff,0x0189ddb2,0x016a91b0)    R(0x0598,0x016a91b0,0x015a755f,0x01eb4178)    R(0x0599,0x015a755f,0x018a9907,0x01bb4d29)    R(0x059a,0x013ab9ff,0x016a91b0,0x01bb71d7)    R(0x059b,0x01eb4178,0x015a755f,0x01bb4d29)    R(0x059c,0x01bb71d7,0x016a91b0,0x01eb4178)    R(0x059d,0x016bba2d,0x013ab9ff,0x01bb71d7)    R(0x059e,0x01eb4178,0x01bb4d29,0x01bbf55d)    R(0x059f,0x01bb71d7,0x01eb4178,0x01ec25a9)\n    R(0x05a0,0x01ec25a9,0x01eb4178,0x01bbf55d)    R(0x05a1,0x01bbf55d,0x01bb4d29,0x02ac392d)    R(0x05a2,0x016bba2d,0x01bb71d7,0x01bc59fc)    R(0x05a3,0x01bc59fc,0x01bb71d7,0x01ec25a9)    R(0x05a4,0x03772c3e,0x13ac7d00,0xffffffff)    R(0x05a5,0x0688107d,0x0387a49f,0x06c73c8a)    R(0x05a6,0x1197e840,0x0d38184b,0x0ee72c49)    R(0x05a7,0x09986c5d,0x0688107d,0x0a77705e)    R(0x05a8,0x0d38184b,0x09986c5d,0x0a77705e)    R(0x05a9,0x03788496,0x0387a49f,0x0688107d)\n    R(0x05aa,0x1028b043,0x0d38184b,0x1197e840)    R(0x05ab,0x06790076,0x0688107d,0x09986c5d)    R(0x05ac,0x06790076,0x03788496,0x0688107d)    R(0x05ad,0x13a9083e,0x1028b043,0x1197e840)    R(0x05ae,0x0cc9304d,0x09986c5d,0x0d38184b)    R(0x05af,0x1028b043,0x0cc9304d,0x0d38184b)    R(0x05b0,0x0959605a,0x06790076,0x09986c5d)    R(0x05b1,0x0399648d,0x03788496,0x06790076)    R(0x05b2,0x0cc9304d,0x0959605a,0x09986c5d)    R(0x05b3,0x13a9083e,0x10499045,0x1028b043)\n    R(0x05b4,0x10499045,0x0cc9304d,0x1028b043)    R(0x05b5,0x070a086e,0x06790076,0x0959605a)    R(0x05b6,0x070a086e,0x0399648d,0x06790076)    R(0x05b7,0x0b0a3054,0x0959605a,0x0cc9304d)    R(0x05b8,0x0eca584d,0x0cc9304d,0x10499045)    R(0x05b9,0x070a086e,0x038a2c88,0x0399648d)    R(0x05ba,0x070a086e,0x0959605a,0x0b0a3054)    R(0x05bb,0x0eca584d,0x0b0a3054,0x0cc9304d)    R(0x05bc,0x130a144c,0x0eca584d,0x10499045)    R(0x05bd,0x057ad487,0x038a2c88,0x070a086e)\n    R(0x05be,0x08eae066,0x070a086e,0x0b0a3054)    R(0x05bf,0x112b0c5a,0x0eca584d,0x130a144c)    R(0x05c0,0x0c5b005b,0x0b0a3054,0x0eca584d)    R(0x05c1,0x08eae066,0x057ad487,0x070a086e)    R(0x05c2,0x08eae066,0x0b0a3054,0x0c5b005b)    R(0x05c3,0x112b0c5a,0x0c5b005b,0x0eca584d)    R(0x05c4,0x077b8490,0x057ad487,0x08eae066)    R(0x05c5,0x0aabac7e,0x08eae066,0x0c5b005b)    R(0x05c6,0x077b8490,0x045b38bb,0x057ad487)    R(0x05c7,0x0e5ba876,0x0c5b005b,0x112b0c5a)\n    R(0x05c8,0x0aabac7e,0x077b8490,0x08eae066)    R(0x05c9,0x0aabac7e,0x0c5b005b,0x0e5ba876)    R(0x05ca,0x06abf4cd,0x045b38bb,0x077b8490)    R(0x05cb,0x038b9900,0x045b38bb,0x06abf4cd)    R(0x05cc,0x116c1482,0x0e5ba876,0x112b0c5a)    R(0x05cd,0x09bc44ae,0x077b8490,0x0aabac7e)    R(0x05ce,0x09bc44ae,0x06abf4cd,0x077b8490)    R(0x05cf,0x053c3cfc,0x038b9900,0x06abf4cd)    R(0x05d0,0x0dac7c9d,0x0aabac7e,0x0e5ba876)    R(0x05d1,0x0dac7c9d,0x0e5ba876,0x116c1482)\n    R(0x05d2,0x0dac7c9d,0x09bc44ae,0x0aabac7e)    R(0x05d3,0x009731f8,0x13ac8f88,0x0000013a)    R(0x05d4,0x009731f8,0x05bc8f7a,0x00000070)    R(0x05d5,0x01174df8,0x02ec8eca,0xffffffff)    R(0x05d6,0x02686268,0x01c74e72,0x0257d221)    R(0x05d7,0x02681ab8,0x01c74e72,0x02686268)    R(0x05d8,0x02686268,0x0257d221,0x0298d20e)    R(0x05d9,0x02a93ea4,0x02681ab8,0x02686268)    R(0x05da,0x02a96a4c,0x02686268,0x0298d20e)    R(0x05db,0x02a93ea4,0x02686268,0x02a96a4c)\n    R(0x05dc,0x02a96a4c,0x0298d20e,0x0219c5f8)    R(0x05dd,0x02a93ea4,0x02a96a4c,0x02ea3677)    R(0x05de,0x024a5230,0x02a96a4c,0x0219c5f8)    R(0x05df,0x020a56b6,0x02a93ea4,0x02ea3677)    R(0x05e0,0x02ea3677,0x02a96a4c,0x024a5230)    R(0x05e1,0x024a5230,0x0219c5f8,0x013ab9ff)    R(0x05e2,0x022b1a4f,0x02ea3677,0x024a5230)    R(0x05e3,0x020a56b6,0x02ea3677,0x023b1686)    R(0x05e4,0x022b1a4f,0x024a5230,0x013ab9ff)    R(0x05e5,0x023b1686,0x02ea3677,0x022b1a4f)\n    R(0x05e6,0x011b22bd,0x020a56b6,0x023b1686)    R(0x05e7,0x016bba2d,0x022b1a4f,0x013ab9ff)    R(0x05e8,0x015bd27d,0x023b1686,0x022b1a4f)    R(0x05e9,0x015bd27d,0x011b22bd,0x023b1686)    R(0x05ea,0x014b96ca,0x011b22bd,0x015bd27d)    R(0x05eb,0x015bd27d,0x022b1a4f,0x016bba2d)    R(0x05ec,0x01ac4a99,0x014b96ca,0x015bd27d)    R(0x05ed,0x023c2ac4,0x014b96ca,0x01ac4a99)    R(0x05ee,0x022c8e50,0x015bd27d,0x016bba2d)    R(0x05ef,0x022c8e50,0x016bba2d,0x01bc59fc)\n    R(0x05f0,0x01ac4a99,0x015bd27d,0x022c8e50)    R(0x05f1,0x009732a4,0x05bc5f7a,0xffffffff)    R(0x05f2,0x0457db66,0x02973757,0x0227f77a)    R(0x05f3,0x00977f28,0x018772eb,0x0178330b)    R(0x05f4,0x00f80f71,0x00b73344,0x00a82b50)    R(0x05f5,0x0227f77a,0x01476b60,0x00f80f71)    R(0x05f6,0x0178330b,0x018772eb,0x02681ab8)    R(0x05f7,0x00a82b50,0x00977f28,0x0178330b)    R(0x05f8,0x0457db66,0x0227f77a,0x03b87774)    R(0x05f9,0x01989b72,0x0227f77a,0x00f80f71)\n    R(0x05fa,0x03b87774,0x0227f77a,0x01989b72)    R(0x05fb,0x00e8df56,0x00f80f71,0x00a82b50)    R(0x05fc,0x0178330b,0x02681ab8,0x0238eeeb)    R(0x05fd,0x00a82b50,0x0178330b,0x00c90326)    R(0x05fe,0x01989b72,0x00f80f71,0x00e8df56)    R(0x05ff,0x00e8df56,0x00a82b50,0x00c90326)    R(0x0600,0x00c90326,0x0178330b,0x0238eeeb)    R(0x0601,0x02f92359,0x03b87774,0x01989b72)    R(0x0602,0x0238eeeb,0x02681ab8,0x02a93ea4)    R(0x0603,0x0568f74f,0x03b87774,0x02f92359)\n    R(0x0604,0x01697342,0x01989b72,0x00e8df56)    R(0x0605,0x02f92359,0x01989b72,0x01697342)    R(0x0606,0x00e8df56,0x00c90326,0x00f9b71f)    R(0x0607,0x00c90326,0x0238eeeb,0x0179bee7)    R(0x0608,0x05099b31,0x0568f74f,0x02f92359)    R(0x0609,0x0179bee7,0x0238eeeb,0x02a93ea4)    R(0x060a,0x01697342,0x00e8df56,0x00f9b71f)    R(0x060b,0x00f9b71f,0x00c90326,0x0179bee7)    R(0x060c,0x029a0b27,0x02f92359,0x01697342)    R(0x060d,0x05099b31,0x02f92359,0x029a0b27)\n    R(0x060e,0x0179bee7,0x02a93ea4,0x020a56b6)    R(0x060f,0x01697342,0x00f9b71f,0x016a5712)    R(0x0610,0x029a0b27,0x01697342,0x016a5712)    R(0x0611,0x054a3315,0x05099b31,0x029a0b27)    R(0x0612,0x00f9b71f,0x0179bee7,0x010a8ef0)    R(0x0613,0x016a5712,0x00f9b71f,0x010a8ef0)    R(0x0614,0x010a8ef0,0x0179bee7,0x020a56b6)    R(0x0615,0x054a3315,0x029a0b27,0x034ad6fe)    R(0x0616,0x029a0b27,0x016a5712,0x034ad6fe)    R(0x0617,0x010a8ef0,0x020a56b6,0x011b22bd)\n    R(0x0618,0x016a5712,0x010a8ef0,0x018b32eb)    R(0x0619,0x054a3315,0x034ad6fe,0x05bb170a)    R(0x061a,0x034ad6fe,0x016a5712,0x018b32eb)    R(0x061b,0x010a8ef0,0x011b22bd,0x014b96ca)    R(0x061c,0x018b32eb,0x010a8ef0,0x014b96ca)    R(0x061d,0x05bb170a,0x034ad6fe,0x03bba6df)    R(0x061e,0x034ad6fe,0x018b32eb,0x03bba6df)    R(0x061f,0x018b32eb,0x014b96ca,0x023c2ac4)    R(0x0620,0x03bba6df,0x018b32eb,0x023c2ac4)    R(0x0621,0x03bba6df,0x023c2ac4,0x04ec5ec1)\n    R(0x0622,0x03b762c1,0x13ac8788,0xffffffff)    R(0x0623,0x12676323,0x0f97b719,0x1237db44)    R(0x0624,0x0a478af3,0x08077af7,0x09380308)    R(0x0625,0x0df77f07,0x0c37df08,0x0f97b719)    R(0x0626,0x0c37df08,0x0a478af3,0x09380308)    R(0x0627,0x08077af7,0x06e7ab22,0x07984f1b)    R(0x0628,0x09380308,0x08077af7,0x07984f1b)    R(0x0629,0x1237db44,0x0f97b719,0x0e984f41)    R(0x062a,0x0f97b719,0x0c37df08,0x0e984f41)    R(0x062b,0x06e7ab22,0x0457db66,0x06686b46)\n    R(0x062c,0x07984f1b,0x06e7ab22,0x06686b46)    R(0x062d,0x0b588f39,0x0c37df08,0x09380308)    R(0x062e,0x1237db44,0x0e984f41,0x11487f70)    R(0x062f,0x06686b46,0x0457db66,0x03b87774)    R(0x0630,0x0e984f41,0x0c37df08,0x0b588f39)    R(0x0631,0x09380308,0x07984f1b,0x0818c333)    R(0x0632,0x0b588f39,0x09380308,0x0818c333)    R(0x0633,0x07984f1b,0x06686b46,0x06b8ff30)    R(0x0634,0x11487f70,0x0e984f41,0x0e59076a)    R(0x0635,0x06686b46,0x03b87774,0x0568f74f)\n    R(0x0636,0x0e59076a,0x0e984f41,0x0b588f39)    R(0x0637,0x0818c333,0x07984f1b,0x06b8ff30)    R(0x0638,0x06b8ff30,0x06686b46,0x0568f74f)    R(0x0639,0x12790388,0x11487f70,0x0e59076a)    R(0x063a,0x0b588f39,0x0818c333,0x0a793b55)    R(0x063b,0x0e59076a,0x0b588f39,0x0a793b55)    R(0x063c,0x0818c333,0x06b8ff30,0x06e98336)    R(0x063d,0x0a793b55,0x0818c333,0x06e98336)    R(0x063e,0x06b8ff30,0x0568f74f,0x05099b31)    R(0x063f,0x12790388,0x0e59076a,0x1059d378)\n    R(0x0640,0x0e59076a,0x0a793b55,0x0cd9db69)    R(0x0641,0x06e98336,0x06b8ff30,0x05099b31)    R(0x0642,0x1059d378,0x0e59076a,0x0cd9db69)    R(0x0643,0x0a793b55,0x06e98336,0x097a0753)    R(0x0644,0x0cd9db69,0x0a793b55,0x097a0753)    R(0x0645,0x06e98336,0x05099b31,0x054a3315)    R(0x0646,0x097a0753,0x06e98336,0x06ea7332)    R(0x0647,0x06ea7332,0x06e98336,0x054a3315)    R(0x0648,0x1059d378,0x0cd9db69,0x0e2aaf66)    R(0x0649,0x0cd9db69,0x097a0753,0x0a5ac351)\n    R(0x064a,0x121a9378,0x1059d378,0x0e2aaf66)    R(0x064b,0x0a5ac351,0x097a0753,0x06ea7332)    R(0x064c,0x0e2aaf66,0x0cd9db69,0x0a5ac351)    R(0x064d,0x06ea7332,0x054a3315,0x05bb170a)    R(0x064e,0x0a5ac351,0x06ea7332,0x086b4f32)    R(0x064f,0x121a9378,0x0e2aaf66,0x107b4f57)    R(0x0650,0x06ea7332,0x05bb170a,0x086b4f32)    R(0x0651,0x0e2aaf66,0x0a5ac351,0x0c7b8745)    R(0x0652,0x0e2aaf66,0x0c7b8745,0x107b4f57)    R(0x0653,0x0a5ac351,0x086b4f32,0x0c7b8745)\n    R(0x0654,0x086b4f32,0x05bb170a,0x069bd2f6)    R(0x0655,0x05bb170a,0x03bba6df,0x069bd2f6)    R(0x0656,0x0c7b8745,0x086b4f32,0x09cc0712)    R(0x0657,0x107b4f57,0x0c7b8745,0x103c0b33)    R(0x0658,0x086b4f32,0x069bd2f6,0x09cc0712)    R(0x0659,0x13ac1b31,0x107b4f57,0x103c0b33)    R(0x065a,0x0c7b8745,0x09cc0712,0x0d7c4714)    R(0x065b,0x103c0b33,0x0c7b8745,0x0d7c4714)    R(0x065c,0x069bd2f6,0x03bba6df,0x04ec5ec1)    R(0x065d,0x09cc0712,0x069bd2f6,0x080c86cd)\n    R(0x065e,0x069bd2f6,0x04ec5ec1,0x080c86cd)    R(0x065f,0x01abf482,0x13dfff33,0x00000135)    R(0x0660,0x01abf482,0x13de2333,0x000000a8)    R(0x0661,0x01bbf482,0x129e2213,0xffffffff)    R(0x0662,0x119cd8af,0x0dac7c9d,0x116c1482)    R(0x0663,0x0b6cf4d2,0x09bc44ae,0x0dac7c9d)    R(0x0664,0x0e9d48d4,0x0dac7c9d,0x119cd8af)    R(0x0665,0x0e9d48d4,0x0b6cf4d2,0x0dac7c9d)    R(0x0666,0x084c94e3,0x06abf4cd,0x09bc44ae)    R(0x0667,0x0b6cf4d2,0x084c94e3,0x09bc44ae)\n    R(0x0668,0x121d8ce5,0x0e9d48d4,0x119cd8af)    R(0x0669,0x097d2ce1,0x084c94e3,0x0b6cf4d2)    R(0x066a,0x0c8d70f0,0x0b6cf4d2,0x0e9d48d4)    R(0x066b,0x0b3dd0dd,0x08fdf4d8,0x097d2ce1)    R(0x066c,0x0c8d70f0,0x097d2ce1,0x0b6cf4d2)    R(0x066d,0x097d2ce1,0x08fdf4d8,0x069d1cec)    R(0x066e,0x084c94e3,0x053c3cfc,0x06abf4cd)    R(0x066f,0x0c8d70f0,0x0b3dd0dd,0x097d2ce1)    R(0x0670,0x097d2ce1,0x069d1cec,0x084c94e3)    R(0x0671,0x08fdf4d8,0x071e08ee,0x069d1cec)\n    R(0x0672,0x0f5dd50c,0x0e9d48d4,0x121d8ce5)    R(0x0673,0x0dbdf8f9,0x0b3dd0dd,0x0c8d70f0)    R(0x0674,0x069d1cec,0x053c3cfc,0x084c94e3)    R(0x0675,0x0f5dd50c,0x0c8d70f0,0x0e9d48d4)    R(0x0676,0x069d1cec,0x071e08ee,0x04fdc513)    R(0x0677,0x0f5dd50c,0x0dbdf8f9,0x0c8d70f0)    R(0x0678,0x069d1cec,0x041cf50e,0x053c3cfc)    R(0x0679,0x069d1cec,0x04fdc513,0x041cf50e)    R(0x067a,0x129e1122,0x0f5dd50c,0x121d8ce5)    R(0x067b,0x053c3cfc,0x041cf50e,0x02ac392d)\n    R(0x067c,0x041cf50e,0x04fdc513,0x030d3d3f)    R(0x067d,0x02ac392d,0x041cf50e,0x030d3d3f)    R(0x067e,0x030d3d3f,0x04fdc513,0x044e2150)    R(0x067f,0x01ecc972,0x02ac392d,0x030d3d3f)    R(0x0680,0x01ecc972,0x01bbf55d,0x02ac392d)    R(0x0681,0x02dd9d88,0x030d3d3f,0x044e2150)    R(0x0682,0x01ecc972,0x030d3d3f,0x02dd9d88)    R(0x0683,0x01ec25a9,0x01bbf55d,0x01ecc972)    R(0x0684,0x020cfdc1,0x01ecc972,0x02dd9d88)    R(0x0685,0x020cfdc1,0x01ec25a9,0x01ecc972)\n    R(0x0686,0x020cfdc1,0x02dd9d88,0x036dc5d7)    R(0x0687,0x01bc59fc,0x01ec25a9,0x020cfdc1)    R(0x0688,0x02ed0a11,0x020cfdc1,0x036dc5d7)    R(0x0689,0x02ed0a11,0x01bc59fc,0x020cfdc1)    R(0x068a,0x02ed0a11,0x036dc5d7,0x04adbe13)    R(0x068b,0x01ac05fc,0x13de2333,0xffffffff)    R(0x068c,0x022c8e50,0x01bc59fc,0x02ed0a11)    R(0x068d,0x032cc291,0x01ac4a99,0x022c8e50)    R(0x068e,0x023c2ac4,0x01ac4a99,0x032cc291)    R(0x068f,0x04bd2e4e,0x022c8e50,0x02ed0a11)\n    R(0x0690,0x032cc291,0x022c8e50,0x04bd2e4e)    R(0x0691,0x04ec5ec1,0x023c2ac4,0x032cc291)    R(0x0692,0x04bd2e4e,0x02ed0a11,0x04adbe13)    R(0x0693,0x05ecee92,0x032cc291,0x04bd2e4e)    R(0x0694,0x04ec5ec1,0x032cc291,0x05ecee92)    R(0x0695,0x04bd2e4e,0x04adbe13,0x06edd62f)    R(0x0696,0x080c86cd,0x04ec5ec1,0x05ecee92)    R(0x0697,0x05ecee92,0x04bd2e4e,0x083d925f)    R(0x0698,0x083d925f,0x04bd2e4e,0x06edd62f)    R(0x0699,0x080c86cd,0x05ecee92,0x09ad32a1)\n    R(0x069a,0x09ad32a1,0x05ecee92,0x083d925f)    R(0x069b,0x083d925f,0x06edd62f,0x0a9e1637)    R(0x069c,0x0b5cc2e3,0x080c86cd,0x09ad32a1)    R(0x069d,0x09cc0712,0x080c86cd,0x0b5cc2e3)    R(0x069e,0x09ad32a1,0x083d925f,0x0c3dde78)    R(0x069f,0x0c3dde78,0x083d925f,0x0a9e1637)    R(0x06a0,0x0b5cc2e3,0x09ad32a1,0x0d1d52b2)    R(0x06a1,0x0d7c4714,0x09cc0712,0x0b5cc2e3)    R(0x06a2,0x0d1d52b2,0x09ad32a1,0x0c3dde78)    R(0x06a3,0x0f8ceee1,0x0b5cc2e3,0x0d1d52b2)\n    R(0x06a4,0x0d7c4714,0x0b5cc2e3,0x0f8ceee1)    R(0x06a5,0x104d9a9b,0x0d1d52b2,0x0c3dde78)    R(0x06a6,0x0f8ceee1,0x0d1d52b2,0x104d9a9b)    R(0x06a7,0x104d9a9b,0x0c3dde78,0x107e2260)    R(0x06a8,0x122cb70b,0x0d7c4714,0x0f8ceee1)    R(0x06a9,0x103c0b33,0x0d7c4714,0x122cb70b)    R(0x06aa,0x132d52ce,0x0f8ceee1,0x104d9a9b)    R(0x06ab,0x104d9a9b,0x107e2260,0x13ddee86)    R(0x06ac,0x122cb70b,0x0f8ceee1,0x132d52ce)    R(0x06ad,0x02dd9cd8,0x12cffe78,0x000000ae)\n    R(0x06ae,0x02dd9cd8,0x0c5ffa37,0xffffffff)    R(0x06af,0x0aeea0df,0x08fdf4d8,0x0b3dd0dd)    R(0x06b0,0x0aeea0df,0x089ec4f8,0x08fdf4d8)    R(0x06b1,0x089ec4f8,0x071e08ee,0x08fdf4d8)    R(0x06b2,0x0aeea0df,0x0acf4507,0x089ec4f8)    R(0x06b3,0x066ea521,0x071e08ee,0x089ec4f8)    R(0x06b4,0x04fdc513,0x071e08ee,0x066ea521)    R(0x06b5,0x0acf4507,0x089f6134,0x089ec4f8)    R(0x06b6,0x089f6134,0x066ea521,0x089ec4f8)    R(0x06b7,0x0c2fb932,0x089f6134,0x0acf4507)\n    R(0x06b8,0x044e2150,0x04fdc513,0x066ea521)    R(0x06b9,0x05feed63,0x066ea521,0x089f6134)    R(0x06ba,0x044e2150,0x066ea521,0x05feed63)    R(0x06bb,0x0a8fd96e,0x089f6134,0x0c2fb932)    R(0x06bc,0x05feed63,0x089f6134,0x07ef8579)    R(0x06bd,0x07ef8579,0x089f6134,0x0a8fd96e)    R(0x06be,0x047e6d9e,0x044e2150,0x05feed63)    R(0x06bf,0x02dd9d88,0x044e2150,0x047e6d9e)    R(0x06c0,0x066f25b0,0x05feed63,0x07ef8579)    R(0x06c1,0x092fb9b2,0x07ef8579,0x0a8fd96e)\n    R(0x06c2,0x047e6d9e,0x05feed63,0x066f25b0)    R(0x06c3,0x092fb9b2,0x0a8fd96e,0x0c3ff9a8)    R(0x06c4,0x066f25b0,0x07ef8579,0x092fb9b2)    R(0x06c5,0x036dc5d7,0x02dd9d88,0x047e6d9e)    R(0x06c6,0x055e89e8,0x047e6d9e,0x066f25b0)    R(0x06c7,0x0aefa9e5,0x092fb9b2,0x0c3ff9a8)    R(0x06c8,0x07ef35ec,0x066f25b0,0x092fb9b2)    R(0x06c9,0x036dc5d7,0x047e6d9e,0x055e89e8)    R(0x06ca,0x07ef35ec,0x092fb9b2,0x0aefa9e5)    R(0x06cb,0x055e89e8,0x066f25b0,0x07ef35ec)\n    R(0x06cc,0x04adbe13,0x036dc5d7,0x055e89e8)    R(0x06cd,0x098f1615,0x07ef35ec,0x0aefa9e5)    R(0x06ce,0x06be9219,0x055e89e8,0x07ef35ec)    R(0x06cf,0x098f1615,0x0aefa9e5,0x0c5f6204)    R(0x06d0,0x04adbe13,0x055e89e8,0x06be9219)    R(0x06d1,0x06be9219,0x07ef35ec,0x098f1615)    R(0x06d2,0x0b6e9e1f,0x098f1615,0x0c5f6204)    R(0x06d3,0x08ce5a2c,0x06be9219,0x098f1615)    R(0x06d4,0x06edd62f,0x04adbe13,0x06be9219)    R(0x06d5,0x08ce5a2c,0x098f1615,0x0b6e9e1f)\n    R(0x06d6,0x06edd62f,0x06be9219,0x08ce5a2c)    R(0x06d7,0x0a9e1637,0x08ce5a2c,0x0b6e9e1f)    R(0x06d8,0x0a9e1637,0x06edd62f,0x08ce5a2c)    R(0x06d9,0x0a8dd0dd,0x12cffe78,0xffffffff)    R(0x06da,0x0d3ea4e6,0x0aeea0df,0x0b3dd0dd)    R(0x06db,0x0d3ea4e6,0x0b3dd0dd,0x0dbdf8f9)    R(0x06dc,0x0d3ea4e6,0x0d2f3cfd,0x0aeea0df)    R(0x06dd,0x0d2f3cfd,0x0acf4507,0x0aeea0df)    R(0x06de,0x0f9e6d10,0x0d3ea4e6,0x0dbdf8f9)    R(0x06df,0x0f9f2d0d,0x0d2f3cfd,0x0d3ea4e6)\n    R(0x06e0,0x0f9e6d10,0x0f9f2d0d,0x0d3ea4e6)    R(0x06e1,0x0f9e6d10,0x0dbdf8f9,0x0f5dd50c)    R(0x06e2,0x0eefa52a,0x0d2f3cfd,0x0f9f2d0d)    R(0x06e3,0x0c2fb932,0x0acf4507,0x0d2f3cfd)    R(0x06e4,0x110e4132,0x0f9e6d10,0x0f5dd50c)    R(0x06e5,0x112ec934,0x0f9f2d0d,0x0f9e6d10)    R(0x06e6,0x0eefa52a,0x0c2fb932,0x0d2f3cfd)    R(0x06e7,0x110e4132,0x0f5dd50c,0x129e1122)    R(0x06e8,0x10ff753e,0x0eefa52a,0x0f9f2d0d)    R(0x06e9,0x110e4132,0x112ec934,0x0f9e6d10)\n    R(0x06ea,0x10ff753e,0x0f9f2d0d,0x112ec934)    R(0x06eb,0x0daffd68,0x0c2fb932,0x0eefa52a)    R(0x06ec,0x0fffd95f,0x0eefa52a,0x10ff753e)    R(0x06ed,0x11de8163,0x112ec934,0x110e4132)    R(0x06ee,0x11df016a,0x10ff753e,0x112ec934)    R(0x06ef,0x0fffd95f,0x0daffd68,0x0eefa52a)    R(0x06f0,0x12ce6967,0x11de8163,0x110e4132)    R(0x06f1,0x11df016a,0x112ec934,0x11de8163)    R(0x06f2,0x0daffd68,0x0a8fd96e,0x0c2fb932)    R(0x06f3,0x114fa17f,0x0fffd95f,0x10ff753e)\n    R(0x06f4,0x114fa17f,0x10ff753e,0x11df016a)    R(0x06f5,0x0f3ff199,0x0daffd68,0x0fffd95f)    R(0x06f6,0x11cea19b,0x11df016a,0x11de8163)    R(0x06f7,0x0f3ff199,0x0fffd95f,0x114fa17f)    R(0x06f8,0x0c3ff9a8,0x0a8fd96e,0x0daffd68)    R(0x06f9,0x119f05a0,0x114fa17f,0x11df016a)    R(0x06fa,0x119f05a0,0x11df016a,0x11cea19b)    R(0x06fb,0x0f3ff199,0x0c3ff9a8,0x0daffd68)    R(0x06fc,0x107fa5b5,0x0f3ff199,0x114fa17f)    R(0x06fd,0x107fa5b5,0x114fa17f,0x119f05a0)\n    R(0x06fe,0x106ef9d1,0x119f05a0,0x11cea19b)    R(0x06ff,0x0ddfd1d2,0x0c3ff9a8,0x0f3ff199)    R(0x0700,0x107fa5b5,0x0ddfd1d2,0x0f3ff199)    R(0x0701,0x106ef9d1,0x107fa5b5,0x119f05a0)    R(0x0702,0x104e9dda,0x11cea19b,0x123e95c0)    R(0x0703,0x104e9dda,0x106ef9d1,0x11cea19b)    R(0x0704,0x0aefa9e5,0x0c3ff9a8,0x0ddfd1d2)    R(0x0705,0x106ef9d1,0x0eff7de5,0x107fa5b5)    R(0x0706,0x0eff7de5,0x0ddfd1d2,0x107fa5b5)    R(0x0707,0x10ee760c,0x104e9dda,0x123e95c0)\n    R(0x0708,0x104e9dda,0x0e1ed9ff,0x106ef9d1)    R(0x0709,0x0e1ed9ff,0x0eff7de5,0x106ef9d1)    R(0x070a,0x0c5f6204,0x0aefa9e5,0x0ddfd1d2)    R(0x070b,0x0c5f6204,0x0ddfd1d2,0x0eff7de5)    R(0x070c,0x0dce6e0d,0x0e1ed9ff,0x104e9dda)    R(0x070d,0x0e1ed9ff,0x0c5f6204,0x0eff7de5)    R(0x070e,0x10ee760c,0x0dce6e0d,0x104e9dda)    R(0x070f,0x0b6e9e1f,0x0c5f6204,0x0e1ed9ff)    R(0x0710,0x0dce6e0d,0x0b6e9e1f,0x0e1ed9ff)    R(0x0711,0x0d9e423b,0x0dce6e0d,0x10ee760c)\n    R(0x0712,0x0a9e1637,0x0b6e9e1f,0x0dce6e0d)    R(0x0713,0x0d9e423b,0x0a9e1637,0x0dce6e0d)    R(0x0714,0x107e2260,0x0d9e423b,0x10ee760c)    R(0x0715,0x0c3dde78,0x0a9e1637,0x0d9e423b)    R(0x0716,0x0c3dde78,0x0d9e423b,0x107e2260)    R(0x0717,0x10370c3b,0x290ea38e,0x00000298)    R(0x0718,0x10470c3b,0x290ea22a,0x0000011e)    R(0x0719,0x10470c3b,0x1ccea21b,0x0000009c)    R(0x071a,0x10470c3b,0x1ccd20c7,0xffffffff)    R(0x071b,0x1ae83c74,0x19873c62,0x1b67789f)\n    R(0x071c,0x1898004d,0x1537f43b,0x16c70c47)    R(0x071d,0x1ae83c74,0x1898004d,0x19873c62)    R(0x071e,0x1c6848b0,0x1ae83c74,0x1b67789f)    R(0x071f,0x16e8d046,0x1537f43b,0x1898004d)    R(0x0720,0x13a9083e,0x1197e840,0x1537f43b)    R(0x0721,0x19a90458,0x1898004d,0x1ae83c74)    R(0x0722,0x1b99288e,0x1ae83c74,0x1c6848b0)    R(0x0723,0x13a9083e,0x1537f43b,0x16e8d046)    R(0x0724,0x19a90458,0x16e8d046,0x1898004d)    R(0x0725,0x1b99288e,0x19a90458,0x1ae83c74)\n    R(0x0726,0x16f9d04f,0x16e8d046,0x19a90458)    R(0x0727,0x16f9d04f,0x13a9083e,0x16e8d046)    R(0x0728,0x1a09f470,0x19a90458,0x1b99288e)    R(0x0729,0x130a144c,0x10499045,0x13a9083e)    R(0x072a,0x1a09f470,0x16f9d04f,0x19a90458)    R(0x072b,0x16f9d04f,0x130a144c,0x13a9083e)    R(0x072c,0x1cca009e,0x1a09f470,0x1b99288e)    R(0x072d,0x18bac871,0x16f9d04f,0x1a09f470)    R(0x072e,0x156ac05d,0x130a144c,0x16f9d04f)    R(0x072f,0x1c1ae88f,0x1a09f470,0x1cca009e)\n    R(0x0730,0x18bac871,0x156ac05d,0x16f9d04f)    R(0x0731,0x1c1ae88f,0x18bac871,0x1a09f470)    R(0x0732,0x156ac05d,0x112b0c5a,0x130a144c)    R(0x0733,0x17cbb87f,0x156ac05d,0x18bac871)    R(0x0734,0x143b946f,0x112b0c5a,0x156ac05d)    R(0x0735,0x1b1bd09a,0x18bac871,0x1c1ae88f)    R(0x0736,0x17cbb87f,0x143b946f,0x156ac05d)    R(0x0737,0x1b1bd09a,0x17cbb87f,0x18bac871)    R(0x0738,0x116c1482,0x112b0c5a,0x143b946f)    R(0x0739,0x153c7090,0x143b946f,0x17cbb87f)\n    R(0x073a,0x153c7090,0x116c1482,0x143b946f)    R(0x073b,0x18bc9ca2,0x17cbb87f,0x1b1bd09a)    R(0x073c,0x18bc9ca2,0x153c7090,0x17cbb87f)    R(0x073d,0x1c8c9cc7,0x18bc9ca2,0x1b1bd09a)    R(0x073e,0x119cd8af,0x116c1482,0x153c7090)    R(0x073f,0x158d20ba,0x153c7090,0x18bc9ca2)    R(0x0740,0x158d20ba,0x119cd8af,0x153c7090)    R(0x0741,0x10ec9ca2,0x1c8ea21b,0xffffffff)    R(0x0742,0x192d4cd4,0x158d20ba,0x18bc9ca2)    R(0x0743,0x192d4cd4,0x18bc9ca2,0x1c8c9cc7)\n    R(0x0744,0x121d8ce5,0x119cd8af,0x158d20ba)    R(0x0745,0x160db8f7,0x158d20ba,0x192d4cd4)    R(0x0746,0x160db8f7,0x121d8ce5,0x158d20ba)    R(0x0747,0x1c3d7105,0x192d4cd4,0x1c8c9cc7)    R(0x0748,0x192de91d,0x160db8f7,0x192d4cd4)    R(0x0749,0x192de91d,0x192d4cd4,0x1c3d7105)    R(0x074a,0x129e1122,0x121d8ce5,0x160db8f7)    R(0x074b,0x15be3143,0x160db8f7,0x192de91d)    R(0x074c,0x15be3143,0x129e1122,0x160db8f7)    R(0x074d,0x1c4de94f,0x192de91d,0x1c3d7105)\n    R(0x074e,0x12ce6967,0x110e4132,0x129e1122)    R(0x074f,0x12ce6967,0x129e1122,0x15be3143)    R(0x0750,0x18ce416e,0x15be3143,0x192de91d)    R(0x0751,0x18ce416e,0x192de91d,0x1c4de94f)    R(0x0752,0x152e7999,0x12ce6967,0x15be3143)    R(0x0753,0x152e7999,0x15be3143,0x18ce416e)    R(0x0754,0x1bbe2da0,0x18ce416e,0x1c4de94f)    R(0x0755,0x11cea19b,0x11de8163,0x12ce6967)    R(0x0756,0x123e95c0,0x12ce6967,0x152e7999)    R(0x0757,0x123e95c0,0x11cea19b,0x12ce6967)\n    R(0x0758,0x187e6dc8,0x152e7999,0x18ce416e)    R(0x0759,0x187e6dc8,0x18ce416e,0x1bbe2da0)    R(0x075a,0x14ee85ef,0x123e95c0,0x152e7999)    R(0x075b,0x14ee85ef,0x152e7999,0x187e6dc8)    R(0x075c,0x1bce35f8,0x187e6dc8,0x1bbe2da0)    R(0x075d,0x10ee760c,0x123e95c0,0x14ee85ef)    R(0x075e,0x183e5a1b,0x14ee85ef,0x187e6dc8)    R(0x075f,0x183e5a1b,0x187e6dc8,0x1bce35f8)    R(0x0760,0x1b17508e,0x290e362a,0x000000c1)    R(0x0761,0x1b67508e,0x290b5a11,0xffffffff)\n    R(0x0762,0x1c6848b0,0x1b67789f,0x1d175cca)    R(0x0763,0x1dd910b6,0x1b99288e,0x1c6848b0)    R(0x0764,0x1cca009e,0x1b99288e,0x1dd910b6)    R(0x0765,0x1c1ae88f,0x1cca009e,0x1f5ac0b8)    R(0x0766,0x1f282cc6,0x1c6848b0,0x1d175cca)    R(0x0767,0x1dd910b6,0x1c6848b0,0x1f282cc6)    R(0x0768,0x1ff9d4bc,0x1cca009e,0x1dd910b6)    R(0x0769,0x1f5ac0b8,0x1cca009e,0x1ff9d4bc)    R(0x076a,0x217910cc,0x1dd910b6,0x1f282cc6)    R(0x076b,0x1ff9d4bc,0x1dd910b6,0x217910cc)\n    R(0x076c,0x223834f1,0x1f282cc6,0x206750ee)    R(0x076d,0x1f5ac0b8,0x1ff9d4bc,0x22ca2cd6)    R(0x076e,0x217910cc,0x1f282cc6,0x223834f1)    R(0x076f,0x220b40db,0x1f5ac0b8,0x22ca2cd6)    R(0x0770,0x22ca2cd6,0x1ff9d4bc,0x217910cc)    R(0x0771,0x23f928f3,0x217910cc,0x223834f1)    R(0x0772,0x22ca2cd6,0x217910cc,0x23f928f3)    R(0x0773,0x220b40db,0x22ca2cd6,0x24cae103)    R(0x0774,0x25385d2a,0x223834f1,0x23776126)    R(0x0775,0x23f928f3,0x223834f1,0x25385d2a)\n    R(0x0776,0x2549f900,0x22ca2cd6,0x23f928f3)    R(0x0777,0x24cae103,0x22ca2cd6,0x2549f900)    R(0x0778,0x25385d2a,0x23776126,0x25d7ad64)    R(0x0779,0x26995534,0x23f928f3,0x25385d2a)    R(0x077a,0x26995534,0x2549f900,0x23f928f3)    R(0x077b,0x24cae103,0x2549f900,0x270a593b)    R(0x077c,0x263b5943,0x24cae103,0x270a593b)    R(0x077d,0x2788a568,0x25385d2a,0x25d7ad64)    R(0x077e,0x270a593b,0x2549f900,0x26995534)    R(0x077f,0x26995534,0x25385d2a,0x2788a568)\n    R(0x0780,0x2788a568,0x25d7ad64,0x279815aa)    R(0x0781,0x263b5943,0x270a593b,0x282ac57b)    R(0x0782,0x2859b971,0x270a593b,0x26995534)    R(0x0783,0x2859b971,0x26995534,0x2788a568)    R(0x0784,0x285895f8,0x279815aa,0x274799f5)    R(0x0785,0x282ac57b,0x270a593b,0x2859b971)    R(0x0786,0x28a919ae,0x2788a568,0x279815aa)    R(0x0787,0x2859b971,0x2788a568,0x28a919ae)    R(0x0788,0x28a919ae,0x279815aa,0x285895f8)    R(0x0789,0x27eb5a11,0x284b19c4,0x28ea8605)\n    R(0x078a,0x284b19c4,0x282ac57b,0x290a25b6)    R(0x078b,0x290a25b6,0x282ac57b,0x2859b971)    R(0x078c,0x28f995fc,0x28a919ae,0x285895f8)    R(0x078d,0x290a25b6,0x2859b971,0x28a919ae)    R(0x078e,0x28ea8605,0x284b19c4,0x290a25b6)    R(0x078f,0x290a25b6,0x28a919ae,0x28f995fc)    R(0x0790,0x28ea8605,0x290a25b6,0x28f995fc)    R(0x0791,0x1b1ac08f,0x284e362a,0xffffffff)    R(0x0792,0x1e7bb4b7,0x1c1ae88f,0x1f5ac0b8)    R(0x0793,0x26cbbd8b,0x282ac57b,0x284b19c4)\n    R(0x0794,0x1e7bb4b7,0x1f5ac0b8,0x220b40db)    R(0x0795,0x26cbbd8b,0x263b5943,0x282ac57b)    R(0x0796,0x23abdd11,0x220b40db,0x24cae103)    R(0x0797,0x23abdd11,0x24cae103,0x263b5943)    R(0x0798,0x1e7bb4b7,0x1b1bd09a,0x1c1ae88f)    R(0x0799,0x26bc05da,0x284b19c4,0x27eb5a11)    R(0x079a,0x26bc05da,0x26cbbd8b,0x284b19c4)    R(0x079b,0x20ac30e3,0x1e7bb4b7,0x220b40db)    R(0x079c,0x20ac30e3,0x220b40db,0x23abdd11)    R(0x079d,0x249c4956,0x263b5943,0x26cbbd8b)\n    R(0x079e,0x265c122a,0x26bc05da,0x27eb5a11)    R(0x079f,0x249c4956,0x23abdd11,0x263b5943)    R(0x07a0,0x1c8c9cc7,0x1b1bd09a,0x1e7bb4b7)    R(0x07a1,0x24bca1a8,0x26cbbd8b,0x26bc05da)    R(0x07a2,0x20ac30e3,0x1c8c9cc7,0x1e7bb4b7)    R(0x07a3,0x24bca1a8,0x249c4956,0x26cbbd8b)    R(0x07a4,0x21fcb125,0x20ac30e3,0x23abdd11)    R(0x07a5,0x24bcc1fd,0x26bc05da,0x265c122a)    R(0x07a6,0x21fcb125,0x23abdd11,0x249c4956)    R(0x07a7,0x24bcc1fd,0x24bca1a8,0x26bc05da)\n    R(0x07a8,0x1efce4f8,0x1c8c9cc7,0x20ac30e3)    R(0x07a9,0x21fcb125,0x1efce4f8,0x20ac30e3)    R(0x07aa,0x225d1174,0x249c4956,0x24bca1a8)    R(0x07ab,0x225d1174,0x21fcb125,0x249c4956)    R(0x07ac,0x220d59ce,0x24bca1a8,0x24bcc1fd)    R(0x07ad,0x1c3d7105,0x1c8c9cc7,0x1efce4f8)    R(0x07ae,0x1f5d653c,0x1efce4f8,0x21fcb125)    R(0x07af,0x220d59ce,0x225d1174,0x24bca1a8)    R(0x07b0,0x225d1174,0x1f5d653c,0x21fcb125)    R(0x07b1,0x227d3e22,0x220d59ce,0x24bcc1fd)\n    R(0x07b2,0x1f5d653c,0x1c3d7105,0x1efce4f8)    R(0x07b3,0x220d59ce,0x1f6dad85,0x225d1174)    R(0x07b4,0x1f6dad85,0x1f5d653c,0x225d1174)    R(0x07b5,0x227d3e22,0x1f5dce0a,0x220d59ce)    R(0x07b6,0x1c4de94f,0x1c3d7105,0x1f5d653c)    R(0x07b7,0x1eade5c8,0x1f6dad85,0x220d59ce)    R(0x07b8,0x1f6dad85,0x1c4de94f,0x1f5d653c)    R(0x07b9,0x1f5dce0a,0x1eade5c8,0x220d59ce)    R(0x07ba,0x1eade5c8,0x1bbe2da0,0x1f6dad85)    R(0x07bb,0x1bbe2da0,0x1c4de94f,0x1f6dad85)\n    R(0x07bc,0x1bce35f8,0x1eade5c8,0x1f5dce0a)    R(0x07bd,0x1bce35f8,0x1bbe2da0,0x1eade5c8)    R(0x07be,0x103721ef,0x28fe878e,0x0000013a)    R(0x07bf,0x103761ef,0x1e4e878e,0x000000c5)    R(0x07c0,0x105762ea,0x1e4c6b8e,0xffffffff)    R(0x07c1,0x1507b348,0x12676323,0x1237db44)    R(0x07c2,0x17c7c342,0x1507b348,0x16d83f6e)    R(0x07c3,0x1507b348,0x1237db44,0x14285380)    R(0x07c4,0x1a57d737,0x17c7c342,0x19685f4a)    R(0x07c5,0x1e47db1b,0x1a57d737,0x1be88f26)\n    R(0x07c6,0x16d83f6e,0x1507b348,0x14285380)    R(0x07c7,0x19685f4a,0x17c7c342,0x16d83f6e)    R(0x07c8,0x14285380,0x1237db44,0x11487f70)    R(0x07c9,0x1be88f26,0x1a57d737,0x19685f4a)    R(0x07ca,0x16d83f6e,0x14285380,0x1598eb8e)    R(0x07cb,0x19685f4a,0x16d83f6e,0x1868fb79)    R(0x07cc,0x14285380,0x11487f70,0x12790388)    R(0x07cd,0x1be88f26,0x19685f4a,0x1ac9173f)    R(0x07ce,0x1868fb79,0x16d83f6e,0x1598eb8e)    R(0x07cf,0x1598eb8e,0x14285380,0x12790388)\n    R(0x07d0,0x1ac9173f,0x19685f4a,0x1868fb79)    R(0x07d1,0x1c596314,0x1be88f26,0x1ac9173f)    R(0x07d2,0x1598eb8e,0x12790388,0x1429b386)    R(0x07d3,0x1868fb79,0x1598eb8e,0x1799bf7e)    R(0x07d4,0x1ac9173f,0x1868fb79,0x19e9c364)    R(0x07d5,0x1799bf7e,0x1598eb8e,0x1429b386)    R(0x07d6,0x1c596314,0x1ac9173f,0x1bb9f728)    R(0x07d7,0x19e9c364,0x1868fb79,0x1799bf7e)    R(0x07d8,0x1429b386,0x12790388,0x1059d378)    R(0x07d9,0x1bb9f728,0x1ac9173f,0x19e9c364)\n    R(0x07da,0x1cda5eff,0x1c596314,0x1bb9f728)    R(0x07db,0x1799bf7e,0x1429b386,0x162a8771)    R(0x07dc,0x1429b386,0x1059d378,0x121a9378)    R(0x07dd,0x19e9c364,0x1799bf7e,0x199a9b59)    R(0x07de,0x1bb9f728,0x19e9c364,0x199a9b59)    R(0x07df,0x162a8771,0x1429b386,0x121a9378)    R(0x07e0,0x199a9b59,0x1799bf7e,0x162a8771)    R(0x07e1,0x1cda5eff,0x1bb9f728,0x1b8acf1f)    R(0x07e2,0x1bb9f728,0x199a9b59,0x1b8acf1f)    R(0x07e3,0x199a9b59,0x162a8771,0x179b4753)\n    R(0x07e4,0x162a8771,0x121a9378,0x144b575a)    R(0x07e5,0x1b8acf1f,0x199a9b59,0x19fb9b25)    R(0x07e6,0x162a8771,0x144b575a,0x179b4753)    R(0x07e7,0x121a9378,0x107b4f57,0x144b575a)    R(0x07e8,0x199a9b59,0x179b4753,0x19fb9b25)    R(0x07e9,0x1b8acf1f,0x19fb9b25,0x1cab7afb)    R(0x07ea,0x179b4753,0x144b575a,0x16fc0b2d)    R(0x07eb,0x144b575a,0x107b4f57,0x13ac1b31)    R(0x07ec,0x19fb9b25,0x179b4753,0x16fc0b2d)    R(0x07ed,0x1cab7afb,0x19fb9b25,0x1c5c42ea)\n    R(0x07ee,0x16fc0b2d,0x144b575a,0x13ac1b31)    R(0x07ef,0x19fb9b25,0x16fc0b2d,0x192c6afb)    R(0x07f0,0x19fb9b25,0x192c6afb,0x1c5c42ea)    R(0x07f1,0x103c09ef,0x1d5e8733,0xffffffff)    R(0x07f2,0x144e523c,0x10ee760c,0x14ee85ef)    R(0x07f3,0x144e523c,0x14ee85ef,0x183e5a1b)    R(0x07f4,0x1b8dfe47,0x183e5a1b,0x1bce35f8)    R(0x07f5,0x144e523c,0x107e2260,0x10ee760c)    R(0x07f6,0x17ae1667,0x144e523c,0x183e5a1b)    R(0x07f7,0x17ae1667,0x183e5a1b,0x1b8dfe47)\n    R(0x07f8,0x13ddee86,0x107e2260,0x144e523c)    R(0x07f9,0x17ae1667,0x13ddee86,0x144e523c)    R(0x07fa,0x1a0db292,0x17ae1667,0x1b8dfe47)    R(0x07fb,0x1a0db292,0x1b8dfe47,0x1d5d6680)    R(0x07fc,0x168d9aae,0x13ddee86,0x17ae1667)    R(0x07fd,0x1a0db292,0x168d9aae,0x17ae1667)    R(0x07fe,0x1bccfec1,0x1a0db292,0x1d5d6680)    R(0x07ff,0x132d52ce,0x104d9a9b,0x13ddee86)    R(0x0800,0x132d52ce,0x13ddee86,0x168d9aae)    R(0x0801,0x18ad26d3,0x168d9aae,0x1a0db292)\n    R(0x0802,0x1bccfec1,0x18ad26d3,0x1a0db292)    R(0x0803,0x159cd2fa,0x132d52ce,0x168d9aae)    R(0x0804,0x159cd2fa,0x168d9aae,0x18ad26d3)    R(0x0805,0x192c6afb,0x18ad26d3,0x1bccfec1)    R(0x0806,0x1c5c42ea,0x192c6afb,0x1bccfec1)    R(0x0807,0x192c6afb,0x159cd2fa,0x18ad26d3)    R(0x0808,0x159cd2fa,0x122cb70b,0x132d52ce)    R(0x0809,0x16fc0b2d,0x159cd2fa,0x192c6afb)    R(0x080a,0x13ac1b31,0x122cb70b,0x159cd2fa)    R(0x080b,0x16fc0b2d,0x13ac1b31,0x159cd2fa)\n    R(0x080c,0x13ac1b31,0x103c0b33,0x122cb70b)    R(0x080d,0x1b8721f5,0x28fe3726,0xffffffff)    R(0x080e,0x27781e41,0x26672241,0x25b7c683)    R(0x080f,0x24a86abf,0x25b7c683,0x23777ac4)    R(0x0810,0x24a86abf,0x23777ac4,0x2167f2f1)    R(0x0811,0x285895f8,0x274799f5,0x27781e41)    R(0x0812,0x2167f2f1,0x1e47db1b,0x1f68d30c)    R(0x0813,0x26c8ba87,0x27781e41,0x25b7c683)    R(0x0814,0x26c8ba87,0x25b7c683,0x24a86abf)    R(0x0815,0x24a86abf,0x2167f2f1,0x22b8dae8)\n    R(0x0816,0x1f68d30c,0x1e47db1b,0x1be88f26)    R(0x0817,0x22b8dae8,0x2167f2f1,0x1f68d30c)    R(0x0818,0x28491e43,0x285895f8,0x27781e41)    R(0x0819,0x28491e43,0x27781e41,0x26c8ba87)    R(0x081a,0x25197ebf,0x26c8ba87,0x24a86abf)    R(0x081b,0x25197ebf,0x24a86abf,0x22b8dae8)    R(0x081c,0x1f68d30c,0x1be88f26,0x1c596314)    R(0x081d,0x28f995fc,0x285895f8,0x28491e43)    R(0x081e,0x21e9b2ef,0x22b8dae8,0x1f68d30c)    R(0x081f,0x2749a283,0x28491e43,0x26c8ba87)\n    R(0x0820,0x2749a283,0x26c8ba87,0x25197ebf)    R(0x0821,0x1e79bf09,0x1f68d30c,0x1c596314)    R(0x0822,0x25197ebf,0x22b8dae8,0x21e9b2ef)    R(0x0823,0x21e9b2ef,0x1f68d30c,0x1e79bf09)    R(0x0824,0x286a1e48,0x28f995fc,0x28491e43)    R(0x0825,0x286a1e48,0x28491e43,0x2749a283)    R(0x0826,0x1e79bf09,0x1c596314,0x1cda5eff)    R(0x0827,0x23ba66ca,0x25197ebf,0x21e9b2ef)    R(0x0828,0x266a7a90,0x2749a283,0x25197ebf)    R(0x0829,0x21e9b2ef,0x1e79bf09,0x203a82ec)\n    R(0x082a,0x28ea8605,0x28f995fc,0x286a1e48)    R(0x082b,0x266a7a90,0x286a1e48,0x2749a283)    R(0x082c,0x23ba66ca,0x266a7a90,0x25197ebf)    R(0x082d,0x23ba66ca,0x21e9b2ef,0x203a82ec)    R(0x082e,0x203a82ec,0x1e79bf09,0x1cda5eff)    R(0x082f,0x279b0656,0x286a1e48,0x266a7a90)    R(0x0830,0x279b0656,0x28ea8605,0x286a1e48)    R(0x0831,0x203a82ec,0x1cda5eff,0x1e7b1add)    R(0x0832,0x24bb3a9d,0x266a7a90,0x23ba66ca)    R(0x0833,0x219b3ec1,0x23ba66ca,0x203a82ec)\n    R(0x0834,0x1cda5eff,0x1b8acf1f,0x1cab7afb)    R(0x0835,0x24bb3a9d,0x279b0656,0x266a7a90)    R(0x0836,0x203a82ec,0x1e7b1add,0x219b3ec1)    R(0x0837,0x219b3ec1,0x24bb3a9d,0x23ba66ca)    R(0x0838,0x279b0656,0x27eb5a11,0x28ea8605)    R(0x0839,0x1cda5eff,0x1cab7afb,0x1e7b1add)    R(0x083a,0x25abbe6b,0x279b0656,0x24bb3a9d)    R(0x083b,0x1e7b1add,0x1f3beac5,0x219b3ec1)    R(0x083c,0x265c122a,0x27eb5a11,0x279b0656)    R(0x083d,0x1e7b1add,0x1cab7afb,0x1f3beac5)\n    R(0x083e,0x219b3ec1,0x228c1e91,0x24bb3a9d)    R(0x083f,0x25abbe6b,0x265c122a,0x279b0656)    R(0x0840,0x228c1e91,0x25abbe6b,0x24bb3a9d)    R(0x0841,0x1f3beac5,0x228c1e91,0x219b3ec1)    R(0x0842,0x1cab7afb,0x1c5c42ea,0x1f3beac5)    R(0x0843,0x242c9251,0x265c122a,0x25abbe6b)    R(0x0844,0x228c1e91,0x242c9251,0x25abbe6b)    R(0x0845,0x1f3beac5,0x1efcaaa5,0x228c1e91)    R(0x0846,0x1f3beac5,0x1c5c42ea,0x1efcaaa5)    R(0x0847,0x242c9251,0x24bcc1fd,0x265c122a)\n    R(0x0848,0x228c1e91,0x213cfa6e,0x242c9251)    R(0x0849,0x1efcaaa5,0x213cfa6e,0x228c1e91)    R(0x084a,0x1c5c42ea,0x1bccfec1,0x1efcaaa5)    R(0x084b,0x227d3e22,0x24bcc1fd,0x242c9251)    R(0x084c,0x213cfa6e,0x227d3e22,0x242c9251)    R(0x084d,0x1efcaaa5,0x1d5d6680,0x213cfa6e)    R(0x084e,0x1bccfec1,0x1d5d6680,0x1efcaaa5)    R(0x084f,0x213cfa6e,0x1f5d8a46,0x227d3e22)    R(0x0850,0x1d5d6680,0x1f5d8a46,0x213cfa6e)    R(0x0851,0x1f5d8a46,0x1f5dce0a,0x227d3e22)\n    R(0x0852,0x1d5d6680,0x1b8dfe47,0x1f5d8a46)    R(0x0853,0x1b8dfe47,0x1f5dce0a,0x1f5d8a46)    R(0x0854,0x1b8dfe47,0x1bce35f8,0x1f5dce0a)  }\n  return r;\n}\n\nvec4 encode_int(in int x) {\n    ivec4 col = (ivec4(x)>>ivec4(0,8,16,24))&255;\n    return vec4(col)/255.0;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Test whether data should be sent. Data is sent if:\n    //  this is the first frame or\n    //  rendering area was resized (previous width/height stored in first pixel)\n    bool reset = (iFrame < 10);\n    reset = reset || (get_data(RESOLUTION_OFFSET,0) != int(iChannelResolution[0].x));\n    reset = reset || (get_data(RESOLUTION_OFFSET,1) != int(iChannelResolution[0].y));\n    if(reset) {  \n       ivec2 uv = ivec2(fragCoord); \n       int index = uv.x + uv.y * int(iResolution.x); \n       if(index < 2) {\n           fragColor = encode_int(int(iResolution[index]));\n       } else {\n          index -= MESH_DATA_OFFSET;\n          if(index < AABB_data_size*3) {\n            int comp = index % 3;\n            index = index / 3;\n            ivec3 P = AABB_data(index);\n            fragColor = encode_int(P[comp]);    \n          } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n       }\n    } else {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n}\n ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 46, 46, 196], [390, 390, 453, 453, 751], [753, 753, 790, 790, 893], [1060, 1060, 1089, 1089, 1141], [1191, 1191, 1321, 3317, 3667], [3669, 3669, 3755, 3755, 3945], [3948, 3948, 4129, 4230, 4516], [4573, 4573, 4593, 4593, 4621], [4623, 4623, 4660, 4660, 4731], [4733, 4733, 4771, 4771, 4840], [4842, 4842, 4871, 4871, 5066], [5068, 5068, 5115, 5115, 5148], [5150, 5150, 5197, 5197, 5230], [5276, 5276, 5339, 5339, 6794], [6799, 6799, 6839, 6839, 7002], [7005, 7005, 7058, 7058, 7174], [7176, 7176, 7233, 7233, 7936]], "test": "untested"}
{"id": "tt3Xz7", "name": "KIFS experiments 7", "author": "rodgzilla", "description": "A slight modification on https://www.shadertoy.com/view/ttdXzN by smoothsteping the rotation speed.", "tags": ["kifs", "spikingrotation"], "likes": 1, "viewed": 304, "published": 3, "date": "1580638938", "time_retrieved": "2024-07-30T21:26:25.529039", "image_code": "#define time iTime\n#define ZPOS -50.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * cos(time * tempo) + .5;\n}\n\nvec3 palette(float x) {\n\n    vec3 a = vec3(1., .7, .7);\n    vec3 b = vec3(.8, 1., 1.);\n    vec3 c = vec3(1., .8, 1.);\n    vec3 d = vec3(1., 1., 1.);\n\n    return a + b * sin(2. * PI * (c + x * d));\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float it, float s, float tf, float ss) {\n    float t = tf * time;\n    t = floor(ss * t) + smoothstep(0., .8, fract(ss * t));\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(tf * t);\n        p.yz *= rot2d(tf * t + i);\n        p = abs(p);\n        p -= s;\n        s *= .8;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    float d = 1000.;\n    vec3 pk1 = kifs(p, 2., 2., .5, 1.); \n    vec3 pk2 = kifs(pk1, 4., 1.5, .3, 2.);\n    vec3 pk3 = kifs(pk2, 8., 1.3, .2, .5);\n    \n    float sph1 = sph(pk1, 1.);\n    float sph2 = sph(pk2, 1.);\n    float sph3 = sph(pk3, 1.);\n  \td = min(d,\n            mix(\n                mix(\n                \tsph1, \n\t                sph2, \n    \t            wave(1.)\n       \t\t    ),\n                sph3,\n                wave(.3)\n        )\n    );   \n//    d = min(d, sph1);\n\n    return d;\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n        \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .001 || ds > 100.) {\n            break;\n        }\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n\tvec3 lp = vec3(2, 2, ZPOS);\n    vec3 n = normal(p);\n    vec3 tl = normalize(lp - p);\n    float dif = dot(tl, n);\n    float dl = rm(p + .01 * n, tl);\n    \n    if (dl < length(lp - p)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n  \tcol = dif * palette(.5 * cos(length(p) / 20. + .5) + p.z / 5.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3Xz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 86, 86, 128], [130, 130, 153, 153, 328], [330, 330, 351, 351, 419], [421, 421, 479, 479, 747], [749, 749, 777, 777, 805], [807, 807, 826, 826, 1322], [1324, 1324, 1352, 1352, 1592], [1594, 1594, 1614, 1614, 1785], [1787, 1787, 1808, 1808, 2042], [2044, 2044, 2101, 2101, 2528]], "test": "untested"}
{"id": "wtcXR7", "name": "shortest heart ( 140 chars )", "author": "FabriceNeyret2", "description": "could it be shorter ? :-)", "tags": ["heart", "onetweet", "golf"], "likes": 4, "viewed": 898, "published": 3, "date": "1580636123", "time_retrieved": "2024-07-30T21:26:26.284020", "image_code": "// Derived from Hearth curve http://mathworld.wolfram.com/HeartCurve.html\n//    x = 16 sin(t) ; y = 13 cos(t) - 5 cos(2 t) - 2 cos(3 t) - cos(4 t)\n// see also: https://www.desmos.com/calculator/f0xnkcfbbr\n\n// NB: -12 without anti-aliasing.  or -7 with approx AA  O /= 3.\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = iResolution.xy,\n          C = u/u - pow( abs( U = (u+u-U)/U.y ).x, .67),\n          A = 19. -8.*C,\n          B = 6. -C-C  -8.*C*C - U*16.;\n    O.ar =    C * A*A - B*B;\n    O /= fwidth(O);\n}/*\n\n\n\n\n\n// --- 143 chars  ( above (i.e. squaring) is even smoother ! even allow good aliased version )\n\n#define mainImage(O,u)                       \\\n    vec2  R = iResolution.xy,                \\\n          U = ( u+u - R ) / R.y,             \\\n          C = R/R - pow(abs(U.x),.67);       \\\n    O.ar =    sqrt(C) * ( 19. -8.*C )        \\\n           - abs( 6. -C-C  -8.*C*C - U*16.); \\\n    O /= fwidth(O)                          /*\n\n\n\n\n\n// --- 149 chars\n\n#define mainImage(O,u)                    \\\n    vec2  R = iResolution.xy,             \\\n          U = ( u+u - R ) / R.y;          \\\n    float C = 1. - pow(abs(U.x),.67);     \\\n    O.r =       sqrt(C) * ( 19. -8.*C )   \\\n          - abs(      6. -C-C  -8.*C*C    \\\n                -U.y*16.              );  \\\n    O /= fwidth(O)                       /*\n\n\n\n\n\n// --- 152 chars\n\n#define mainImage(O,u)                      \\\n    vec2  R = iResolution.xy,               \\\n          U = ( u+u - R ) / R.y;            \\\n    float S = pow(abs(U.x),.67);            \\\n    O.r  =      sqrt(1.-S)* (11. +8.*S)     \\\n         - abs(  -4.   +S * (18. -8.*S)     \\\n                -U.y*16.  );                \\\n    O /= fwidth(O)                         /*\n\n\n\n\n\n// --- 160 chars (trigo based, plein red heart )\n\n#define C cos( asin(pow(abs(U.x),.33))            //\n#define mainImage(O,u)                             \\\n    vec2  R = iResolution.xy,                      \\\n          U = ( u+u - R ) / R.y;                   \\\n    O.r +=      13.* C)          - 2.* C*3.)       \\\n         - abs(        - 5.* C*2.)         - C*4.) \\\n                -U.y*16. + 2. );                   \\\n    O /= fwidth(O)                                /*\n\n\n\n\n\n// --- 174 chars : white heart contour\n\n#define C cos( asin(pow(abs(U.x),.33))           //\n#define mainImage(O,u)                            \\\n    vec2  R = iResolution.xy,                     \\\n          U = ( u+u - R ) / R.y;                  \\\n    O +=        13.* C)         - 2.* C*3.)       \\\n         - abs(       - 5.* C*2.)         - C*4.) \\\n               -U.y*16. + 2. );                   \\\n    O = 1. -  abs(O) / fwidth(O)                 /*\n\n\n\n\n\n// --- 195 chars ( heart contour )\n\nvoid mainImage( out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy, \n         U = ( u+u - R ) / R.y;\n\n    float t = asin(pow(abs(U.x),.33)),\n          a =      13. * cos(t)             - 2. * cos(3.*t) \n             -abs(           - 5. * cos(2.*t)              - cos(4.*t)\n                 -U.y*16. + 3.6 );\n    O += 1. -  abs(a) / fwidth(a) -O;\n} /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 310, 310, 513]], "test": "untested"}
{"id": "tt3XR7", "name": "Coronavirus-2020", "author": "EvilRyu", "description": "Tough 2020...", "tags": ["dof", "virus"], "likes": 90, "viewed": 5837, "published": 3, "date": "1580635378", "time_retrieved": "2024-07-30T21:26:27.033018", "image_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// From Virgill: https://www.shadertoy.com/view/ltKGzc\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    fragColor=vec4(0,0,0,1);\n \tif( uv.y>.1 && uv.y<.9 )\n    {\n       \tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n    }\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p*vec3(5.3983,5.4472,6.9371));\n    p+=dot(p.yzx,p.xyz+vec3(21.5351,14.3137,15.3219));\n    return fract(p.x*p.y*p.z*95.4337);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat line(vec3 p, float h, float r)\n{\n  p.y-=clamp(p.y, 0.0, h);\n  return length(p)-r;\n}\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n    \tfloat a=1./(1.+n.y);\n    \tfloat b=-n.x*n.z*a;\n    \tb1=vec3(1.-n.x*n.x*a,-n.x,b);\n    \tb2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct=cos(t),st=sin(t);\n    vec2 q=p;\n\tp.x=ct*q.x+st*q.y;\n    p.y=-st*q.x+ct*q.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a,b,-k);\n}\n\nconst float PI=3.14159265359;\nconst float PHI=1.61803398875;\n\n// iq's inverse spherical fibonnacci: https://www.shadertoy.com/view/lllXz4\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel1, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\n\nint id=0;\n\nvec4 get_corona_params(vec3 p)\n{\n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),100.);\n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n    // bending\n    rot2d(q.xy,(hash13(fibo.xyz)*2.-1.)*q.y*.45);\n    return vec4(q,0.1+0.088*hash13(fibo.xyz+vec3(13.399,71.137,151.11)));\n}\n\nvec3 movement(vec3 p)\n{\n    float t=mod(iTime,1.5)/1.5;\n    p*=1.-0.02*clamp(sin(6.*t)*exp(-t*4.),-2.,2.);\n\trot2d(p.xz, iTime*0.05);\n    rot2d(p.xy,iTime*0.02);\n\treturn p;\n}\n\nfloat map(vec3 p)\n{\n    p=mod(p-vec3(4.),8.)-4.;\n   \tp=movement(p);\n    float d0=sphere(p*vec3(.9,1.,.98),1.)-0.1*texcube(iChannel0, p*.8, normalize(p)).x;\n    vec4 q=get_corona_params(p);\n\n    float d1=line(q.xyz,q.w*3.,0.07);\n    \n    if(d0>d1)id=1;\n    \n    d0=smin(d0,d1,0.1);\n    \n    d1=sphere(q.xyz-vec3((q.w*2.-.2)*0.2,q.w*3.+0.05,0.),0.05+q.w*0.4);\n    d0=smin(d0,d1,0.2);\n    \n    d1=line(q.xyz-vec3(0,q.w*3.,0.), q.w*3., 0.02+0.07*q.y);\n    d0=smax(d0,-d1,0.12);\n        \n    return d0*.55;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec3 eps=vec3(0.001,0,0);\n    return normalize(vec3(map(p+eps.xyz)-map(p-eps.xyz),\n                     map(p+eps.yxz)-map(p-eps.yxz),\n                     map(p+eps.yzx)-map(p-eps.yzx)));\n}\n\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\n{\n    float mid=0.;\n    vec3 p=ro+near*rd;\n    float sgn=sign(map(p));\n    for (int i=0; i<6; i++)\n    { \n        mid=(near+far)*.5;\n        p=ro+mid*rd;\n        float d=map(p);\n        if(abs(d)<0.001)break;\n        d*sgn<0. ? far=mid : near=mid;\n    }\n    return (near+far)*.5;\n}\n\n#define FAR 30.0\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n\tfloat sgn=sign(d);\n    float told=0.;\n\tbool doBisect=false;\n\n   \tfor(int i=0;i<128;++i)\n    {         \n        d=map(ro+t*rd);\n        if (sign(d)!=sgn)\n        {\n            doBisect=true;\n            break;\n        }\n        \n        if(d<0.003&&t>FAR)\n        \tbreak;\n        \n        told=t;\n        t+=d;\n    }\n    if (doBisect)t=bisect(ro,rd,told,t);\n    return t;\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=m*p*2.;\n    f+=.25*noise(p); p=m*p*2.;\n    f+=.125*noise(p); p=m*p*2.;\n    f+=.0625*noise(p); p=m*p*2.;\n    f+=.03125*noise(p);\n    return f/0.984375;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r+=w*(d-map(p+n*d));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 n, float d, float i) \n{ \n    float o,v; \n    for(o=0.;i>0.;i--) \n        o+=(i*d+map(p+n*i*d))/exp2(i); \n    return o; \n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float s = 1.0,t = 0.01,h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = map(ro + rd*t);\n        s = min( s, 16.*h/t );\n        if( s<0.0001 ) break;\n        t += clamp( h, .01, .05 );\n    }\n    return clamp(s,.0,1.);\n}\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 n, float t, vec3 p)\n{    \n    id=0;\n    float d=map(p);\n    vec3 ld0=normalize(vec3(1,1.2,-1.3));\n    \n    if(id==1)\n    {\n        n=bump_mapping(movement(p), n, 0.0265);\n    }\n\n    float dif=max(0.,dot(ld0,n));\n    float spe=pow(max(0.,dot(rd,reflect(ld0,n))), 24.0);\n    float bac=max(0.,dot(-ld0,n));\n    float amb=clamp(0.3+0.7*n.y,0.0,1.0);\n    float sca=sss(p,-n,.6,6.);\n    float fre=clamp(1.-dot(n,-rd),0.,1.);\n\tfloat sha=shadow(p,ld0);\n    vec3 mate=vec3(1.9,0.352,0.45)*.5+pow(texcube(iChannel1, 3.*movement(p), n).x,8.5)*vec3(.5);\n    \n    \n    float ao=get_ao(p,n)*1.5;\n    \n    vec3 col=(4.0*dif+0.5*bac+1.*amb+5.5*fre)*mate*ao+3.5*spe*vec3(1);\n    col*=sha;\n  \tcol+=1.*mate*sca*sca;\n    col*=0.2;\n    col*=clamp(pow(length(p)/1.5,2.),0.,1.);\n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 bg(vec2 p)\n{\n    vec3 col=vec3(0.05,0.25,0.05)*pow(fbm(p*4.),2.);\n    col+=vec3(0.8,0.1,0.3)*pow(fbm(p*6.),15.)*80.;\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p=q*2.0-1.;\n    p.x*=iResolution.x/iResolution.y;\n\n    vec3 ro=vec3(1,2,-6.);\n    vec3 ta=vec3(0,0,0);\n     // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n    \tro=vec3(0.,0,-3)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*5.;\n     \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(vec3(0,1,0),f));\n    vec3 u=normalize(cross(f,r));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.x,p.y,2.8));\n    \n    vec3 col=bg(p);\n    \n    float t=0.01;\n    t=intersect(ro,rd);\n    if(t<FAR)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        col=lighting(ro, rd,n,t,pos);\n    }\n    float depth=clamp(0.033*t, 0.,1.);\n\tcol=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\tfragColor=vec4(col.xyz,abs(.2-depth)*1.);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XR7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[240, 240, 283, 283, 558], [560, 560, 614, 614, 800]], "test": "untested"}
{"id": "WtcSz7", "name": "Voronoi Triangulation", "author": "wyatt", "description": "This would be better with delaunay triangulation - but that is a pain in the butt! - this is much easier - but I'm missing a third point to interpolate :( ", "tags": ["triangulation"], "likes": 18, "viewed": 1033, "published": 3, "date": "1580626704", "time_retrieved": "2024-07-30T21:26:27.787002", "image_code": "Main {\n    Q = B(U);\n    vec2 a = Q.xy,b = Q.zw;\n    float t = smoothstep(-.5,.5,sin(.7*iTime));\n    Q = mix(D(U),D(a),t);\n   \tQ *= 1.-.1*t*smoothstep(2.*t,0.,abs(mp(U,a,b))*length(a-b));\n    Q *= 1.-t*smoothstep(1.5*t,0.,length(U-a));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,floor(U)/R)\n#define B(U) texture(iChannel1,floor(U)/R)\n#define C(U) texture(iChannel2,floor(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn dot(p-m,b-m)/dot(b-m,b-m); // pojection\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat tri (vec2 u, vec2 a, vec2 b, vec2 c) {\n\tfloat ab = sg(u,a,b);\n\tfloat bc = sg(u,b,c);\n    float ca = sg(u,c,a);\n    return min(ab,min(bc,ca));\n}", "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = B(U+r);\n    float ln = length(n.xy-U), la = length(Q.xy-U),\n         l = abs(mp(U,Q.xy,Q.zw)),\n         o = abs(mp(U,Q.xy,n.zw)),\n         o1 = abs(mp(U,Q.xy,n.xy));\n    if (ln<la) {\n    \tQ.xy = n.xy;\n    }\n    if (o<l) {\n    \tQ.zw = n.zw;\n    }\n    if (o1<l) {\n    \tQ.zw = n.xy;\n    }\n}\nvoid Xr (inout vec4 Q, vec2 U, float r) {\n\t X(Q,U,vec2(r,0));\n     X(Q,U,vec2(0,r));\n     X(Q,U,vec2(0,-r));\n     X(Q,U,vec2(-r,0));\n}\nvec2 grad (vec2 u) {\n\tvec4\n        n = D(u+vec2(0,1)),\n        e = D(u+vec2(1,0)),\n        s = D(u-vec2(0,1)),\n        w = D(u-vec2(1,0));\n    return vec2(e.w-w.w,n.w-s.w);\n}\nMain {\n\tQ = B(U);\n    Xr(Q,U,1.);\n    Xr(Q,U,2.);\n    Xr(Q,U,3.);\n    Xr(Q,U,4.);\n    Q.xy += 10.*grad(Q.xy);\n    Q.zw += 10.*grad(Q.zw);\n    if (iFrame%10==0&&D(U).w>.6) Q.xy = U;\n    Init {\n    \tU = floor(U/100.+0.5)*100.;\n        Q = vec4(U,0,0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = B(U);\n\tvec2 a = Q.xy, b = Q.zw;\n    vec4 col1 = A(a),\n         col2 = A(b);\n    Q = mix(col1,col2,(0.5+0.5*mp(U,a,b)));\n    vec2 u = (vec2(U-a.xy));\n    u = normalize(u)*(1.+.1*length(u));\n    u = vec2(-u.y,u.x);\n    vec4 m = 0.5*(D(U+u)+D(U-u));\n    vec4 d = Q-A(U);\n    Q = mix(m,Q,.1);\n    Q.w = mix((m.w),abs(dot(d,vec4(0.25))),0.9);\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlcXRM", "name": "Hearty", "author": "hanabi", "description": "trying a heart", "tags": ["heart"], "likes": 2, "viewed": 364, "published": 3, "date": "1580608106", "time_retrieved": "2024-07-30T21:26:28.540986", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1, 0, 0, 1) * texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec2 xy = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec4 hightLight = vec4(1);\n    drawHeart(hightLight, xy, 0.03, float(iFrame));\n\n    if (hightLight.a > 0.)\n        fragColor = hightLight;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.14159265358\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    drawHeart(fragColor, xy, 0.02, float(iFrame));\n    if (fragColor.a < 1.)\n        discard;\n}", "buffer_a_inputs": [], "common_code": "#define M_PI 3.14159265358\n\nvoid drawHeart(out vec4 fragColor, in vec2 xy, in float pointSize, float fFrame) {\n/*\n    t = 0  2\n    x = 16 sin(t)\n    y = 13 cos(t) - 5 cos(2 t) - 2 cos(3 t) - cos(4 t)\n*/\n    float t = fFrame * M_PI / 360.;\n    float x = 16. * sin(t) * sin(t) * sin(t);\n    float y = 13. * cos(t) - 5. * cos(2. * t) - 2. * cos(3. * t) - cos(4. * t);\n    \n    vec2 hpos = vec2(x, y);\n    hpos *= .055;\n    hpos.y += .2;\n    \n    vec2 xyS = vec2(-xy.x, xy.y);\n    \n    if (distance(hpos, xy) < pointSize || distance(hpos, xyS) < pointSize)\n        fragColor = vec4(1);\n    else\n        fragColor = vec4(0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 351]], "test": "untested"}
{"id": "ttcSRM", "name": "Coronavirus", "author": "zovox", "description": "Coronavirus", "tags": ["coronavirus"], "likes": 3, "viewed": 464, "published": 3, "date": "1580603641", "time_retrieved": "2024-07-30T21:26:29.291978", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 b = texture(iChannel0, uv);\n    fragColor = vec4(b.rgb, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI/GR/E)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n#define S(x,r) smoothstep( 2e2/R.y, 0., length(vec2(x-l*cos(a),l*sin(a))) -r )//\nfloat biohazard( in vec2 u )\n{\n    vec2  R = iResolution.xy,                                   \n          U = u+u - R;                                          \n    float l = length(U)*30./R.y,  /* .955 = 3/pi  1.05 = pi/3 */\n          a = ( mod( .955*atan(U.y,U.x)-.5, 2.) - 1. ) *1.05,   \n          c = S(15.5,10.5);   \n    return max( 0., S(12.,15.) - S(,3.) - c                      \n                   - max( 0., 1. - (abs(a)-.1)*R.y*.1 )         \n             ) + S(,14.) - S(,10.5)                             \n               + S(15.,9.) - c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv;\n    uv = uv*2.0-1.0;\n    uv = (rotatePoint(vec3(uv, 0.)*vec3(aspect, 1., 0.), vec3(0., 0., 1.), -PI/2.).xy/vec2(aspect, 1.));\n    uv.x *= aspect;\n    \n    \n\tfloat sum = 0.;\n    float border = 1.;\n    \n    float bordered = smoothstep(0.4, 0.6, saw(time*E));\n    \n    const float min_outer_radials = 8.0;\n    const float max_outer_radials = 16.0;\n    \n    \n    float outer_count = min_outer_radials+(max_outer_radials-min_outer_radials)*saw(time);\n    \n    for(float i = 0.0; i < max_outer_radials; i+=1.0)\n    {\n        if(i > outer_count)\n            break;\n        float theta = float(i)/float(outer_count)*PI*2.0;\n        vec2 p1 = vec2(cos(theta), sin(theta))*(saw(time*PI*E)*.75+.25);\n    \n        const float min_inner_radials = 8.0;\n        const float max_inner_radials = 32.0;\n\n    \tfloat inner_count = min_inner_radials+(max_inner_radials-min_inner_radials)*saw(time);\n        \n        for(float j = 0.0; j < max_inner_radials; j+=1.0)\n        {\n            if(j > inner_count)\n                break;\n        \tfloat theta2 = float(j)/float(inner_count)*PI*2.0+time*PI*E;\n            vec2 p2 = p1+vec2(cos(theta2), sin(theta2));\n\n            float d = \n                    (p2.y-p1.y)*uv.x-\n                    (p2.x-p1.x)*uv.y+\n                    p2.x*p1.y-p2.y*p1.x/\n                    length(p2-p1);\n            float maxd = .01;\n            \n            float vd = abs(d);\n            \n            if(vd < maxd)\n            {\n                float value = ((length(p1-uv)));\n                sum += value;\n                border *= vd/maxd;\n            }\n        }\n    }\n   \tvec2 u = fragCoord.xy/iResolution.xy;\n    \n    //u = (rotatePoint(vec3(u*2.-1., 0.)*vec3(aspect, 1., 0.), vec3(0., 0., 1.), time).xy/vec2(aspect, 1.)*.5+.5);\n    \n    float bio = biohazard(u*iResolution.xy);\n    float bio_edge = clamp(bio, 0., 1.);\n    vec4 last = texture(iChannel0, uv0);\n    float b = clamp((1.-border),0., 1.);//*bio_edge;\n    float t = time*PI*E;\n    fragColor = vec4(pow(flux(sum*GR+t), vec3(2./3.)), 1.0)*(1.-bio_edge)*b\n        //+(1.-bio_edge)*vec4(pow(flux(bio+PI+t+sum), vec3(1.-saw(time)/GR)), 1.)\n        +last*(bio_edge)-1./64.;\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    fragColor = a;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 172]], "test": "untested"}
{"id": "tl3XRM", "name": "neon updated", "author": "tezza321", "description": "an update for my own use of the neon heart by Alro", "tags": ["heart", "nean"], "likes": 4, "viewed": 558, "published": 3, "date": "1580602971", "time_retrieved": "2024-07-30T21:26:30.038980", "image_code": "#define POINT_COUNT 10\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.6;\nconst float len = 0.40;\nconst float scale = 0.015;\nfloat intensity = 1.2;\nfloat radius = 0.03;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(22.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));\n    }\n    return max(0.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos,3.1);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    col += 0.1*vec3(smoothstep(0.040, 0.021, dist));\n    //Pink glow\n    col += glow * vec3(0.94,0.14,0.4);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 0.0);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    col += 0.1*vec3(smoothstep(1.015, 1.07, dist));\n    //Blue glow\n    col += glow * vec3(0.0,0.23,0.56);\n        \n    //Tone mapping\n    col = 0.9 - exp(-col);\n\n    //Output to screen\n    fragColor = vec4(col,0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 252, 301, 301, 1577], [1580, 1627, 1658, 1658, 1811], [1813, 1853, 1910, 1910, 1952], [1954, 1954, 2004, 2004, 2500], [2502, 2502, 2558, 2558, 3461]], "test": "untested"}
{"id": "Wt3Xz7", "name": "Simple Ellipse", "author": "hanabi", "description": "Ellipse", "tags": ["ellipse"], "likes": 2, "viewed": 782, "published": 3, "date": "1580591645", "time_retrieved": "2024-07-30T21:26:30.780997", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float fFrame = float(iFrame) / 100.;\n    vec2 center = vec2(iResolution) / 2.;\n    vec2 diff = vec2(cos(fFrame), sin(fFrame)) * iResolution.y / 2.2;\n    vec2 pos1 = center - diff;\n\tvec2 pos2 = center + diff;\n\n    fragColor = vec4(0, 0, 0, 1);\n    if ((distance(fragCoord, pos1) + distance(fragCoord, pos2)) < distance(pos1, pos2) + 20.)\n        fragColor.r = 1.;\n    \n    if (distance(fragCoord, pos1) < 3. || distance(fragCoord, pos2) < 3.)\n        fragColor.bg = vec2(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3Xz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 538]], "test": "untested"}
{"id": "wtXSW8", "name": "raycaster thing", "author": "unnick", "description": "a thing i made a very long while ago.\nA/D = move left/right\nW/S = move forwards/backwards\nQ/E = rotate left/right", "tags": ["raycasting", "dda"], "likes": 10, "viewed": 482, "published": 3, "date": "1580586701", "time_retrieved": "2024-07-30T21:26:31.538970", "image_code": "vec3[3] colors = vec3[](vec3(1.), vec3(1., 0., 0.), vec3(0., 1., 0.));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec4 a = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0.));\n    float dist = a.z;\n    int id = int(a.x);\n    fragColor = mix(vec4(colors[id-1], 1.) * a.y, vec4(.25), step(.5, abs(pos.y) * dist));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > 4.) return;\n    vec4 prot = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 rd = vec2((fragCoord.x * 2. - iResolution.x) / iResolution.y, 1.);\n    {\n        rd = vec2(rd.x*prot.w + rd.y*prot.z, rd.y*prot.w - rd.x*prot.z);\n    }\n    vec2 nrd = normalize(rd);\n    vec2 pos = prot.xy; //starting position\n    ivec2 mpos = ivec2(floor(pos)); //starting tile\n    vec2 ddxy = 1. / abs(nrd); //stuff\n    int side = 0; //even more dda stuff\n    ivec2 stxy = ivec2(rd.x > 0. ? 1 : -1, rd.y > 0. ? 1 : -1); //tile stepping direction\n    vec2 sdxy = fract(pos); //more stuff\n    if(stxy.x > 0) sdxy.x = 1. - sdxy.x;\n    if(stxy.y > 0) sdxy.y = 1. - sdxy.y;\n    sdxy *= ddxy;\n    int tile_hit = 1;\n    for(int i = 0; i < 32; i++) {\n        if(sdxy.x < sdxy.y) {\n        \tsdxy.x += ddxy.x;\n            mpos.x += stxy.x;\n            side = 0;\n        } else {\n        \tsdxy.y += ddxy.y;\n            mpos.y += stxy.y;\n            side = 1;\n        }\n        if(is_solid(tile_hit = tile_at(mpos))) break;\n    }\n    float dist = float(mpos[side]) - pos[side];\n    dist += float((1 - stxy[side]) / 2);\n    dist /= rd[side];\n    //vec2 normal = vec2(0.);\n    //normal[side] = float(stxy[side]);\n    fragColor = vec4(\n        tile_hit,\n        float(stxy[side]) * .20 + .80,\n        dist,\n        0.\n    );\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define R_LEFT  81\n#define R_RIGHT 69\n#define LEFT    65\n#define RIGHT   68\n#define DOWN    83\n#define UP      87\n\n#define iTimeDelta (1./60.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(any(greaterThan(fragCoord, vec2(1.)))) return;\n    if(iFrame == 0) {\n        fragColor = vec4(8., 8., 1., 0.); return;\n    }\n    fragColor = texelFetch(iChannel1, ivec2(0.), 0);\n    float c = cos(2. * iTimeDelta);\n    float s = sin(2. * iTimeDelta);\n    if(texelFetch(iChannel0, ivec2(R_RIGHT, 0), 0).x > .5) fragColor.zw *= mat2(c,s,-s,c);\n    if(texelFetch(iChannel0, ivec2(R_LEFT , 0), 0).x > .5) fragColor.zw *= mat2(c,-s,s,c);\n    fragColor.xy += fragColor.zw * 5. * texelFetch(iChannel0, ivec2(UP   , 0), 0).x * iTimeDelta;\n    fragColor.xy -= fragColor.zw * 5. * texelFetch(iChannel0, ivec2(DOWN , 0), 0).x * iTimeDelta;\n    fragColor.xy += fragColor.wz * vec2(1., -1.) * 5. * texelFetch(iChannel0, ivec2(RIGHT, 0), 0).x * iTimeDelta;\n    fragColor.xy -= fragColor.wz * vec2(1., -1.) * 5. * texelFetch(iChannel0, ivec2(LEFT , 0), 0).x * iTimeDelta;\n    /*ivec2 tilepos = ivec2(floor(fragColor.xy));\n    if(is_solid(tile_at(tilepos))) {\n        vec2 pos_wtile = fract(fragColor.xy);\n        vec2 apos = abs(pos_wtile - .5);\n        int side = 0;\n        if(apos.y > apos.x) side = 1;\n        ivec2 b = ivec2(pos_wtile.x > .5 ? 1 : -1, pos_wtile.y > .5 ? 1 : -1);\n        if(is_solid(tile_at(tilepos + b))) {\n            float c = fragColor.xy[side];\n            fragColor.xy = step(.5, fragColor.xy) * 1.02 - .01;\n            fragColor.xy[side] = c;\n        } else {\n            fragColor.xy[side] += (.51 - apos[side]) * (pos_wtile[side] > .5 ? 1. : -1.);\n        }\n    }*/\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int[256] map = int[](\n  1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n  1,0,1,0,1,0,0,0,0,0,0,0,0,3,0,1,\n  1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,\n  1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,\n  1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,\n  0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n  1,0,3,0,0,0,0,0,0,0,0,0,0,2,0,1,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n  1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1\n);\n\nint tile_at(ivec2 p) {\n    p.x = p.x % 16;\n    if(p.x < 0) p.x += 16;\n    p.y = p.y % 16;\n    if(p.y < 0) p.y += 16;\n    return map[p.y * 16 + p.x];\n}\n\nbool is_solid(int id) {\n    return id > 0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 405]], "test": "untested"}
{"id": "Wt3SR7", "name": "LazyBalls", "author": "hanabi", "description": "Metaballs try...", "tags": ["metaballs"], "likes": 0, "viewed": 281, "published": 3, "date": "1580586516", "time_retrieved": "2024-07-30T21:26:32.282981", "image_code": "struct Ball {\n\tvec2 pos;\n    vec2 speed;\n    float s;\n    vec4 color;\n};\n\nvoid move(inout Ball box, float fFrame) {\n    float xPos = box.pos.x + box.speed.x * fFrame;\n    box.pos.x = mod(xPos, iResolution.x);\n    float tx = floor(mod(xPos / iResolution.x, 2.0));\n    box.pos.x = ((1. - tx) * box.pos.x) + (tx * (iResolution.x - box.pos.x));\n    \n    float yPos = box.pos.y + box.speed.y * fFrame;\n    box.pos.y = mod(yPos, iResolution.y);\n    float ty = floor(mod(yPos / iResolution.y, 2.0));\n    box.pos.y = ((1. - ty) * box.pos.y) + (ty * (iResolution.y - box.pos.y));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float fFrame = float(iFrame) / 1.;\n    \n    Ball[] balls = Ball[](\n        Ball(\n            iResolution.xy / 2.,\n            vec2(-3., 2),\n            8.,\n            vec4(1., 0., 0., 1.)\n        ),\n        Ball(\n            iResolution.xy / 3.,\n            vec2(-2.3, -1.3 * iResolution.x / iResolution.y),\n            8.,\n            vec4(1., 0., 0., 1.)\n        ),\n        Ball(\n            iResolution.xy / 4.,\n            vec2(1.5, -1.9 * iResolution.y / iResolution.x),\n            8.,\n            vec4(1., 0., 0., 1.)\n        )\n    );\n    \n    fragColor = vec4(0., 0., 0., 1.0);\n    \n    for (int i = 0; i < balls.length(); i++) {\n        Ball ball = balls[i];\n    \tmove(ball, fFrame);\n        float d = distance(fragCoord, ball.pos);\n        float f = inversesqrt(d) * ball.s;\n        f = smoothstep(0.75, 1., f);\n        fragColor += f * ball.color;\n    }\n\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3SR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 115, 115, 572]], "test": "untested"}
{"id": "3tcSR7", "name": "t-cumulated min or max w. relax", "author": "FabriceNeyret2", "description": "cumulated min (left) and max (right) with relaxation.\nMouse.x pans the limit.\n", "tags": ["video"], "likes": 5, "viewed": 371, "published": 3, "date": "1580580263", "time_retrieved": "2024-07-30T21:26:33.031978", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T0(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O =    T0(U-U).a != R.x                // frame 0 or resize\n        || textureSize(iChannel1,0).x < 2  // texture not loaded yet\n        ? vec4(.5)  \n        : U.x/R.x < ( iMouse.z <= 0. ? .5 : iMouse.x/R.x )\n#if 0\n            ? min( T0(U)*1.01, T1(U) )\n            : max( T0(U)/1.01, T1(U) );\n#else\n            ? min( T0(U)+.005, T1(U) )\n            : max( T0(U)-.005, T1(U) );\n#endif\n    \n    if (U==vec2(.5)) O.a = R.x;            // resize ref\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T0(U) texture(iChannel0, (U)/R)\n#define T1(U) texture(iChannel1, (U)/R)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 55]], "test": "untested"}
{"id": "3l3SzM", "name": "Sakura Fubuki (cherry blossoms)", "author": "whisky_shusuky", "description": "spring in japan", "tags": ["raymarching", "japan", "cineshader"], "likes": 16, "viewed": 27163, "published": 3, "date": "1580574469", "time_retrieved": "2024-07-30T21:26:33.792944", "image_code": "// https://github.com/whisky-shusuky/glsl_storage/blob/master/glsl/sakurahubuki.glsl\nprecision highp float;\n\nconst float fluid_speed     = 208.0;  // Drives speed, higher number will make it slower.\nfloat gTime = 0.;\n\n// \nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n\tfloat k0 = length(p/r);\n\tfloat k1 = length(p/(r*r));\n\treturn k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sakura(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdEllipsoid(pos, vec3(.4,.6,.2)) /1.5;\n\tpos.xy *= 5.;\n\t//pos.yz *= rot(.);\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat cut = sdBox(pos  , vec3(1.,1.,1.));\n\tfloat result = min(-base,cut) *2.;\n\treturn result;\n}\n\nfloat sakura_set(vec3 pos) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y -= .1;\n\tfloat sakura1 = sakura(pos,2.);\n\tpos = pos_origin;\n\tpos .x += .35;\n\tpos .y += .15;\n\tpos.xy *=   rot(.9);\n\tfloat sakura2 = sakura(pos,2.);\n\tpos = pos_origin;\n\tpos .x -= .35;\n\tpos .y += .15;\n\tpos.xy *=   rot(-.9);\n\tfloat sakura3 = sakura(pos,2.);\t\n\tpos = pos_origin;\n\tpos .x += .225;\n\tpos .y += .6;\n\tpos.xy *=   rot(2.5);\n\tfloat sakura4 = sakura(pos,2.);\t\n\tpos = pos_origin;\n\tpos .x -= .225;\n\tpos .y += .6;\n\tpos.xy *=   rot(-2.5);\n\tfloat sakura5 = sakura(pos,2.);\t\n\tfloat result = max(max(max(max(sakura1,sakura2),sakura3),sakura4),sakura5);\n\treturn result;\n}\n\nfloat map(vec3 pos) {\n\tvec3 pos_origin = pos;\n\tfloat sakura_set1 = sakura_set(pos);\n\tpos.x +=sin(gTime);\n\tpos.y +=sin(gTime);\n\tpos.z +=sin(gTime);\n    pos.yz *= rot(sin(gTime * 2.)) * 2.;\n\tpos *= 1.5;\n\tfloat result =sakura_set1;\n\n\treturn result;\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat linearFog(float d, float start, float end) {\n\t// (end - d) / (end - start)01\n\t// d start 0,start,1~0\n\treturn clamp((end - d) / (end - start), 0.0, 1.0);\n}\n\nfloat expFog(float d, float density) {\n    return exp(-d * density);\n}\n\nfloat exp2Fog(float d, float density) {\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0.5, sin(iTime) * 2.  + 0.3 ,iTime * 2.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\n\tfloat t = 0.01;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\tro.xy  =ro.xy * rot(sin(iTime* .005)) * .1;\n\tro.yz  =ro.yz * rot(sin(iTime* .005)) * 0.05;\n\tray.xy  =ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz  =ray.yz * rot(sin(iTime * .03) * 5.);\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\tpos.xy = pos.xy  * rot(iTime);\n\t\t\n\t\tpos.yz = pos.yz  * rot(sin(iTime) /2.);\n\t\t\n\t\tfloat d = map(pos);\n\n\t\td = max(abs(d), 0.02);\n\t\tac += exp(-d*3.);\n\n\t\tt += d* 0.15;\n\t}\n\n    for(int i=1;i<140;i++)\n\t{\n\t\tvec2 newp=p + iTime*0.005;\n\t\tnewp.x+=0.9/float(i)*sin(float(i)*p.y+iTime/fluid_speed+0.3*float(i)) + sin(iTime)* 0.01; // + mouse.y/mouse_factor+mouse_offset;\n\t\tnewp.y+=0.85/float(i)*sin(float(i)*p.x+iTime/fluid_speed+0.3*float(i+10) + sin(iTime)* 0.01); // - mouse.x/mouse_factor+mouse_offset;\n\t\tp=newp;\n\t}\n    \n\tcol = vec3(ac * 0.04);\n\tvec3 finalColor = vec3 ( 0., 0., 0. );\n\n\tcol += smoothstep(0.5, 1.,sin(iTime)) * .15 * vec3 ( 1.0, 0.3, 0.5 );\n\tcol += smoothstep(0.5, 1.,cos(iTime)) * .15 * vec3 ( .0, 0.3, 1.0 );\n\n\tcol.z += + 0.54;\n\tcol.y = col.y * abs(sin(iTime) / 4.) + 0.540;\n\n\n\tfragColor = vec4(col ,1.0 -  t *  0.005);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3SzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 234, 253, 253, 310], [312, 312, 355, 355, 435], [437, 437, 468, 468, 553], [555, 555, 592, 592, 829], [831, 831, 859, 859, 1476], [1478, 1478, 1499, 1499, 1725], [1727, 1790, 1840, 2025, 2079], [2081, 2081, 2119, 2119, 2151], [2153, 2153, 2192, 2192, 2248], [2251, 2251, 2308, 2308, 3687]], "test": "untested"}
{"id": "Wt3XRM", "name": "HAL 9k", "author": "hanabi", "description": "space odyssey ", "tags": ["hal"], "likes": 0, "viewed": 300, "published": 3, "date": "1580570375", "time_retrieved": "2024-07-30T21:26:34.546928", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n      // uv = vec2(iResolution.x / iResolution.y, 1.) - 2.0 * fragCoord / iResolution.y;\n      // uv = vec2(1., 1.) - 2.0 * fragCoord / iResolution.xy;\n\tfloat r = length(uv); //distance(vec2(0., 0.), uv);\n\n    fragColor = (1. - r) * vec4(1., 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 380]], "test": "untested"}
{"id": "Wl3XRM", "name": "Red Round Sphere", "author": "hanabi", "description": "simple sphere imitation", "tags": ["redsphere"], "likes": 0, "viewed": 282, "published": 3, "date": "1580570360", "time_retrieved": "2024-07-30T21:26:35.298917", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n         // = vec2(iResolution.x/iResolution.y, 1.) - 2.0 * fragCoord /iResolution.y;\n    \t // = vec2(1., 1.) - 2.0 * fragCoord /iResolution.xy;\n    vec3 pos = vec3(xy, sqrt(1. - dot(xy, xy)));\n          // = vec3(xy, sqrt(1. - pow(length(xy), 2.0)));\n    vec3 lightPos = normalize(vec3(cos(iTime), sin(iTime), 1.));\n    float l = dot(lightPos, pos);\n    fragColor = l * vec4(1., 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3XRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 518]], "test": "untested"}
{"id": "WltSzN", "name": "Fire on Camera", "author": "ManuManu", "description": "Set what is red in the webcam to fire.\n\nNot completely satisfied with the fire effect, but the overall effect is nice....", "tags": ["fire", "red", "webcam"], "likes": 6, "viewed": 936, "published": 3, "date": "1580569019", "time_retrieved": "2024-07-30T21:26:36.163605", "image_code": "// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nvec4 shapeToFlame(vec2 uv, float n, float c )\n{\n    float c1 = n * c * (1.5-pow(1.5*uv.y,.9));\n//\tfloat c1 = n * c * (1.5-pow(2.50*uv.y,4.));\n\tc1=clamp(c1,0.,1.);\n\n    float boostRed = 1.6;\n\tvec4 col = vec4(boostRed*c1, boostRed*c1*c1*c1, c1*c1*c1*c1*c1*c1,c1);\n    \n#ifdef TRY_SMOKE\n    float blackAdded = 1.- distance( c1, 0.3 );\n    blackAdded = clamp( blackAdded, 0.,1.);\n    blackAdded = pow( blackAdded, 20.0);\n    \n    vec4 blackCol = vec4(0., 0.,0.,1.);\n    col = mix ( col, blackCol, blackAdded-noise(uv+vec2(0, iTime))*0.5);\n#endif // TRY_SMOKE    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float strength = floor(uv.x+1.);\n\tfloat T3 = max(3.,1.25*strength)*iTime;\n\n    float n= fbm( uv * strength *4.5 - vec2(0,T3) );\n    \n    float flameShape = vec3( texture(iChannel0, uv)).r;\n    //flameShape = 10.0;\n    float maxVal = 1.5;\n    flameShape = clamp(flameShape, 0.,maxVal);\n    \n    \n    if ( isDebug()> .5 )\n    {\n        if ( uv.x > 0.9 )\n            flameShape = ( 1.-uv.y) * maxVal;\n    }\n    \n    flameShape = pow(flameShape/maxVal, 0.8)*maxVal;\n    \n    \n    if ( isDebug()> .5 )\n    {\n        if ( uv.x > 0.8 && uv.x < 0.9 )\n            flameShape = ( 1.-uv.y) * maxVal;\n    }    \n    vec4 colFire = shapeToFlame( uv, n, flameShape );\n    \n    \n    \n    \n    vec3 col;// = colFire;\n    \n    col = mix( texture(iChannel1, uv).rgb, colFire.rgb, colFire.a);\n    \n   /* \n    float valTry = col.r;\n    if ( uv.y < .5 )\n    {\n        if ( uv.x < .5 )\n            col.r = 0.2;\n        else\n            col.r = col.g;\n    }\n    else\n    {\n        float minVal = .2;\n        float maxVal = col.g;\n        //col.r = step( .5, uv.x ) * ( maxVal - minVal ) + minVal;\n        col.r = mix( minVal, maxVal, step(.5, uv.x ) );\n    }   \n    */\n    \n    \n    \n\n    \n    //col = vec3(n);\n    //col = vec3(flameShape);\n    \n    // for test :\n    //col = vec3( texture(iChannel2, uv));\n    //col = vec3( texture(iChannel0, uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float isRedColor( vec3 color )\n{\n    vec3 wantedColor=  vec3( 1.0, .0, .0 );\n    float distToColor = distance( color.rgb, wantedColor ) ;\n    return distToColor;\n}\n\n\nconst float threshold = .6;\nvec3 onlyRedImage2( vec3 color )\n{\n    float isRed = isRedColor( color );\n    return mix( color, vec3(0.), step(threshold, isRed ) );\n}\n\n\nvec3 onlyRedImage1( vec3 col )\n{\n\tfloat maxgb = max( col.g, col.b );\n    float k = clamp( (col.r-maxgb)*5.0, 0.0, 1.0 );\n    return mix( vec3(0.), col, k);\n}\n\nvec3 onlyRedImage( vec3 col )\n{\n    if (lotsOfRed() > 0.5)\n        return onlyRedImage1(col);\n\treturn onlyRedImage2(col);\n}\n\n\nfloat HorizontalLine( vec2 uv, float size )\n{\n    uv = uv /  vec2( size, .02);\n    vec2 absUV = abs(uv);\n    \n    return 1.-step( 1., max(absUV.x, absUV.y) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origColor = vec3( texture(iChannel0, uv));\n    \n    \n    // get red color from camera :\n\tvec3 color = onlyRedImage( origColor );\n    \n    if ( isDebug()> .5 )\n    {\n        float m = HorizontalLine( uv - vec2( .1, .1), .05);\n        const vec3 redColor = vec3(1., .0, .0);\n        color = mix( color, redColor, m );\n    }\n\n    fragColor = vec4(color, .1);\n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n//#define FOUR_POINTS\n\n\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origColor = vec3( texture(iChannel0, uv));\n\n    vec2 pix = 1.0 / iResolution.xy;\n    \n\n#ifdef FOUR_POINTS\n    vec3 fireColor = \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y)).rgb + \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*2.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-pix.x, pix.y)).rgb;\n\tfireColor *= 0.248;  // cold phase\n#else\n    vec3 fireColor = \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y)).rgb + \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*2.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*3.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(2.*pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-2.*pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-pix.x, pix.y)).rgb;\n    vec3 randSeed = vec3( uv.x + 5.1*iTime, uv.y + 3.2*iTime, iTime/1.5);\n    //float randValue = rand(randSeed);\n    float randValue = hash13(randSeed);\n    //float randValue = .5;\n\tfireColor *= 0.135 + randValue / 100.;  // cold phase\n#endif // FOUR_POINTS\n    \n    \n    // Output to screen\n    fragColor = vec4(fireColor + origColor,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DEBUG_MODE 1\n\n\nfloat isDebug()\n{\n    return 0.0;\n}\n\n\nfloat lotsOfRed()\n{\n    return 0.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 49, 49, 168], [170, 170, 196, 196, 654], [656, 656, 676, 676, 906], [908, 908, 955, 955, 1484], [1487, 1487, 1544, 1544, 2955]], "test": "untested"}
{"id": "wldXzN", "name": "Field experiments", "author": "Shoseki", "description": "Experiments with fields in 2D", "tags": ["2d"], "likes": 1, "viewed": 328, "published": 3, "date": "1580564919", "time_retrieved": "2024-07-30T21:26:36.926565", "image_code": "\nvec2 normalizeUV(vec2 fragCoord, vec3 iResolution) {\n    // Normalized pixel coordinates (from 0 to 1) taking into consideration resolution\n\tfloat minRes = iResolution.x;\n    if (iResolution.y < minRes) minRes = iResolution.y;\n    \n\treturn fragCoord.xy / minRes;\n}\nvec2 normalizeCenter(vec3 iResolution) {\n    float minRes = iResolution.x;\n    if (iResolution.y < minRes) minRes = iResolution.y;\n    return vec2((iResolution.x / minRes * 0.5), 0.5);\n}\n\n// Field 1 is to test generating a field centered, strength distance from center (animation to help visualize)\nfloat field(vec2 uv, vec2 centeruv, float iTime) {\n    vec2 uvOffset = vec2(uv.x - centeruv.x, uv.y - centeruv.y);\n    return (sqrt((uvOffset.x * uvOffset.x) + (uvOffset.y * uvOffset.y)) * 2.0) - (sin(iTime * 100.0 * 2.0 * 3.14159 / 360.0)/2.0);\n}\n// Field 2 is to test infinite xy field, pattern based on sin wave\nfloat field2(vec2 uv, vec2 centeruv, float iTime) {\n    return 0.50 - (sin(25.0 * uv.x + iTime) * sin(25.0 * uv.y + iTime)); \n}\n// Field 3 is to test morphing, manipulates position and feeds in second field\nfloat field3(vec2 uv, vec2 centeruv, float iTime) {\n    vec2 uvOffset = vec2(uv.x - centeruv.x, uv.y - centeruv.y);\n    \n    float l = (sqrt((uvOffset.x * uvOffset.x) + (uvOffset.y * uvOffset.y)) * 2.0);\n    float rotate = sin(iTime/50.0*l*3.14159*2.0);//cos(iTime);\n    \n    vec2 newUv = vec2(0.0, 0.0);\n    newUv.x = (uvOffset.x * cos(rotate)) - (uvOffset.y * sin(rotate));\n    newUv.y = (uvOffset.x * sin(rotate)) + (uvOffset.y * cos(rotate));\n    return field2(newUv, centeruv, iTime);\n}\n\nfloat modF(float value) {\n\tif (value < 0.0) value = - value;\n    return value;\n}\n\nfloat iso(float fieldValue, float desiredValue, float tolerance) {\n    float iso = 0.0;\n    float difference = desiredValue - fieldValue;\n    difference = modF(difference);\n    if (difference < tolerance) iso = 1.0- (difference/tolerance);\n    \n    return iso;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = normalizeUV(fragCoord, iResolution);\n    \n    vec2 centeruv = normalizeCenter(iResolution);\n    \n    float fieldValue = field3(uv, centeruv, iTime);\n    \n    float desiredValue =  1.0; // iTime / 10.0;\n    float tolerance = 0.25;\n    float isoValue = iso(fieldValue, desiredValue, tolerance);\n\n    float uniColour = 1.0;\n    \n    if (iMouse.z > 0.0) {\n     \tuniColour = isoValue;\n    }\n    else {\n        uniColour = fieldValue;\n        \n    }\n    // Output to screen\n    fragColor = vec4(uniColour, uniColour, uniColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 140, 265], [266, 266, 306, 306, 452], [454, 565, 615, 615, 812], [813, 880, 931, 931, 1007], [1008, 1087, 1138, 1138, 1578], [1580, 1580, 1605, 1605, 1660], [1662, 1662, 1728, 1728, 1924], [1926, 1926, 1983, 1983, 2528]], "test": "untested"}
{"id": "ttdXzN", "name": "KIFS experiments 6", "author": "rodgzilla", "description": "Applying KIFS recursively and mixing different recursion depth space.", "tags": ["raymarching", "kifs", "recursion"], "likes": 1, "viewed": 365, "published": 3, "date": "1580564033", "time_retrieved": "2024-07-30T21:26:37.664592", "image_code": "#define time iTime\n#define ZPOS -50.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * cos(time * tempo) + .5;\n}\n\nvec3 palette(float x) {\n\n    vec3 a = vec3(1., .7, .7);\n    vec3 b = vec3(.8, 1., 1.);\n    vec3 c = vec3(1., .8, 1.);\n    vec3 d = vec3(1., 1., 1.);\n\n    return a + b * sin(2. * PI * (c + x * d));\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float it, float s, float tf) {\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(tf * time);\n        p.yz *= rot2d(tf * time + i);\n        p = abs(p);\n        p -= s;\n        s *= .8;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    float d = 1000.;\n    vec3 pk1 = kifs(p, 2., 2., .5); \n    vec3 pk2 = kifs(pk1, 4., 1.5, .3);\n    vec3 pk3 = kifs(pk2, 8., 1.3, .2);\n    \n    float sph1 = sph(pk1, 1.);\n    float sph2 = sph(pk2, 1.);\n    float sph3 = sph(pk3, 1.);\n  \td = min(d,\n            mix(\n                mix(\n                \tsph1, \n\t                sph2, \n    \t            wave(1.)\n       \t\t    ),\n                sph3,\n                wave(.3)\n        )\n    );   \n\n    return d;\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n        \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .001 || ds > 100.) {\n            break;\n        }\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n\tvec3 lp = vec3(2, 2, ZPOS);\n    vec3 n = normal(p);\n    vec3 tl = normalize(lp - p);\n    float dif = dot(tl, n);\n    float dl = rm(p + .01 * n, tl);\n    \n    if (dl < length(lp - p)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n  \tcol = dif * palette(.5 * cos(length(p) / 20. + .5) + p.z / 5.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 86, 86, 128], [130, 130, 153, 153, 328], [330, 330, 351, 351, 419], [421, 421, 469, 469, 659], [661, 661, 689, 689, 717], [719, 719, 738, 738, 1198], [1200, 1200, 1228, 1228, 1468], [1470, 1470, 1490, 1490, 1661], [1663, 1663, 1684, 1684, 1918], [1920, 1920, 1977, 1977, 2404]], "test": "untested"}
{"id": "tldXRN", "name": "Day 44", "author": "jeyko", "description": "This is a description of a shader.", "tags": ["mdtmjvm"], "likes": 10, "viewed": 375, "published": 3, "date": "1580563275", "time_retrieved": "2024-07-30T21:26:38.417579", "image_code": "// For more buffer feedback check out wyatt, michael0884, Flexi\n// This particular one is inspired by wyatt's zoomy stuff\n\nvoid mainImage(out vec4 C, in vec2 U )\n{\n    C = T(U);\n    C = abs(sin(C*0.5 + 1.7 + 1.2*pow(length( (U )/R - 0.5),3.)));\n    C = smoothstep(0.,1.,C);\n    C = clamp(C, 0., 1.);\n    C = pow(C, vec4(2.1)) + 0.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define init abs(0.4*sin((rot(iTime*2.)*(U - 0.5*R)).xyxy*0.2))\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nfloat blur(in vec2 p){\n    #define bcomp x\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1./iResolution.xy;\n\tfloat res = 0.0;\n\tres += T(p + e.xx*px ).bcomp + T(p + e.xz*px ).bcomp + T(p + e.zx*px ).bcomp + T(p + e.zz*px ).bcomp;\n    res += (T(p + e.xy*px ).bcomp + T(p + e.yx*px ).bcomp + T(p + e.yz*px ).bcomp + T(p + e.zy*px ).bcomp)*2.;\n\tres += T(p + e.yy*px ).bcomp*4.;\n    return res/16.;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 n = T(U+vec2(0,1)), e = T(U+vec2(1,0)), s = T(U-vec2(0,1)), w = T(U-vec2(1,0));\n    \n    U -= 0.5*R;\n    U *= 0.999;\n    \n    U *= rot(0.001);\n    U *= 1. - dot(U/R,U/R)*0.003;\n    U += 0.5*R;\n\n    U -= grad(x)*1.2;\n    U -= grad(w)*4.;\n    U += grad(y)*0.2;\n    C = T(U);\n    \n    C.x += grad(y).x;\n    C.y += div(x)*0.1*length((U)/R-0.5);\n\tC.xy -= blur(U)*0.01;    \n    \n    C = mix(C, init, 0.004);\n    \n    if(iMouse.z > 0.){\n        float r = 0.1;\n        float dMouse = length((iMouse.xy - U.xy)/R.y );\n        C = mix(C, vec4(1,1,1,1)*1., smoothstep(r,r*0.04,dMouse)*0.1);\n    \n    }\n    \n    if(iFrame == 0) {\n    \tC = init;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define C0 iChannel0\n#define C1 iChannel1\n#define C2 iChannel2\n#define C3 iChannel3\n\n#define R (iResolution.xy)\n\n#define T(u) texture(iChannel0, (u)/R)\n\n\n#define grad(i) 0.25*vec2(w.i-e.i,s.i-n.i)\n#define div(i) 0.25*(n.i-s.i+e.i-w.i)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 163, 163, 334]], "test": "untested"}
{"id": "wldXRN", "name": "shortest Sierpinski tria (68 ch)", "author": "FabriceNeyret2", "description": "see comments for infinite zoom variant ( 99 chars ).", "tags": ["sierpinski", "short", "halftweet", "golf", "sierpinsky"], "likes": 7, "viewed": 441, "published": 3, "date": "1580559666", "time_retrieved": "2024-07-30T21:26:39.288251", "image_code": "// triangular variant of https://shadertoy.com/view/ldlfRM\n\n\n// -2 by Xor\n\nvoid mainImage(out vec4 o, vec2 u) { o = vec4( int(u *= mat2(.87,-.5,0,1) ) &int(u.y) ); }\n\n// -2 by coyote\n\n// void mainImage(out vec4 o, vec2 u) { o = vec4( int( o.yx = u * mat2(.87,-.5,0,1) ) &int(o) ); }\n\n\n\n\n/**\nvoid mainImage(out vec4 o, vec2 u) { o = vec4( int( o.xy = u * mat2(.87,-.5,0,1) ) &int(o.y) ); }\n/**/\n\n\n\n\n/* // infinite zoom variant :  ( 99 chars )\n\n#define mainImage(o,u) float t = exp2(fract(iTime)); \\\n    o = vec4( int( o.xy = u * mat2(.87,-.5,0,1) * t ) &int(o.y) ) / t /*\n        \n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 111, 111, 165]], "test": "untested"}
{"id": "ttG3Rt", "name": "sierpinski triangle generator", "author": "DolfinShark", "description": "generate the sierpinski triangle", "tags": ["fractal"], "likes": 2, "viewed": 432, "published": 3, "date": "1580557682", "time_retrieved": "2024-07-30T21:26:40.138976", "image_code": "const float pi = 3.1415926536;\nconst float tau = 6.2831853071;\nconst float sqrt3 = 1.7320508076;\n\n\nfloat distToTriangle(in vec2 p) {\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1. / sqrt3;\n    \n    if(p.x + sqrt3* p.y > 0.)\n        p = vec2(p.x - sqrt3 * p.y, -sqrt3 * p.x - p.y) * .5;\n    \n    p.x -= clamp(p.x, -2., 0.);\n    \n    return -length(p) * sign(p.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float angle = tau / 3.;\n    angle = tau / (3. + sin(iTime * 0.1));\n    \n    uv *= 3.;\n    for(int i = 0; i < 8; i++) {\n        uv *= 2.;\n        uv.x = abs(uv.x);\n        \n        vec2 n = vec2(cos(angle), sin(angle));\n        uv -= 2. * n * min(0., dot(uv, n));\n        \n        uv.y -= 2. * tan(pi / 6.);\n    }\n    \n    float d = distToTriangle(uv);\n    d = smoothstep(1. / iResolution.y, 0., d);\n\n    fragColor = vec4(d, d, d, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 132, 132, 361], [364, 364, 418, 418, 929]], "test": "untested"}
{"id": "ttdSRN", "name": "Stellar magnetic field (~400 ch)", "author": "FabriceNeyret2", "description": "golfed version of  \"Stellar magnetic field\" by tdhooper. [url]https://shadertoy.com/view/3lc3WN[/url] ( original 1439 chars )", "tags": ["field", "magnetic", "golf", "3tweets"], "likes": 12, "viewed": 541, "published": 3, "date": "1580551260", "time_retrieved": "2024-07-30T21:26:40.951803", "image_code": "// Golfing https://shadertoy.com/view/wtdXz4 ( original 1439 chars )\n// deferred: -18 chars by injecting d, a, d, a\n//           -18 chars with usual #define mainImage trick\n// Shortened version of \"Stellar magnetic field\" by tdhooper. https://shadertoy.com/view/3lc3WN\n\n#define H(n)   ( fract(sin(n) * 4e5 )*2. - 1. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy,\n          p = 3.* (2.*U - R) / R.x, f;\n    float N = 15.,  i=-1., s=i, TAU = 6.2832, a = 0., d;\n  \tfor ( ; ++i < N ; s=-s )\n        f  = p - sin( TAU *( ( i +  H(i/N)/2. + H(i+1.)*(iTime+23.78e3) ) / N +vec2(0,.25))),\n        a += s* atan(f.x, f.y) / TAU;\n                                                        // --- derivative\n    d = 1.6* length( fract( vec2(dFdx(a),dFdy(a)) +.5 )  - .5 ); // fract: anti-wrap\n    s = 1./30.;                                         // s = 1 / nb radial isolines\n    a = abs( mod( a, s ) *2. -s );                      // --- isolines\n    a = clamp( a/d - R.x/2e3 ,0.,1.);\n    d = length(p) - 1.;                                 // --- central disk\n    a = mix( 1.-a, a, clamp(d*R.x/6.,0.,1.)) ; \n    O = vec4( sqrt(a) );                                // --- to sRGB\n} /*\n\n\n\n\n\n// --- 445 chars\n\n#define H(n)   ( fract(sin(n) * 4e5 )*2. - 1. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy,\n          p = 3.* (2.*U - R) / R.x, f;\n    float N = 15.,  i=-1., s=i, TAU = 6.2832, a = 0., d;\n  \tfor ( ; ++i < N ; s=-s )\n        f  = p - sin( TAU *( ( i +  H(i/N)/2. + H(i+1.)*(iTime+23.78e3) ) / N +vec2(0,.25))),\n        a += s* atan(f.x, f.y) / TAU;\n    f = abs(vec2(dFdx(a),dFdy(a)));                     // --- derivative\n    d = 1.6* length( f - floor(f+.5) );                 // floor: anti-wrap\n    s = 1./30.;                                         // 1 / nb radial iso\n    a = abs( mod( a, s ) *2. -s );                      // --- isolines\n    a = clamp( a/d - R.x/2e3 ,0.,1.);\n    d = length(p) - 1.;                                 // --- central disk\n    a = mix( 1.-a, a, clamp(d/fwidth(d),0.,1.)) ;       \n    O = vec4( sqrt(a) );                                // --- to sRGB\n} /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 358, 358, 1196]], "test": "untested"}
{"id": "wtdXz4", "name": "Stellar magnetic field (short)", "author": "FabriceNeyret2", "description": "Shortened version of  \"Stellar magnetic field\" by tdhooper. [url]https://shadertoy.com/view/3lc3WN[/url]\nAt first for me to better understand ( via holistic view of equations gathered in one window ).\n\nRemaining questions in [...]in comments\n", "tags": ["field", "magnetic"], "likes": 5, "viewed": 446, "published": 3, "date": "1580547115", "time_retrieved": "2024-07-30T21:26:41.801531", "image_code": "// Shortened version of \"Stellar magnetic field\" by tdhooper. https://shadertoy.com/view/3lc3WN\n// Even shorter version: https://www.shadertoy.com/view/ttdSRN\n\n#define SC(a)    vec2( sin(a), cos(a) )\n#define H(n)   ( fract(sin(n) * 4e5 )*2. - 1. )\n#define R        iResolution.xy\n\nfloat Velocity(vec2 p) {            // --- adding complex poles. returns Arg(result)\n  \tvec2  f; // , V = vec2(0);      //    [ how is this a \"velocity\" ? is it holomorphic ]\n  \tfloat j = 0., N = 15.;\n  \tfor (float i=0.,s=-1.; i < N; i++, s=-s )\n        f  = p - SC( 6.28 * ( i +  H(i/N)/2. + H(i+1.)*(iTime+23.78e3) ) / N ),\n        j += s* atan(f.x, f.y);\n     // V -= s* f/dot(f,f);\n    return j;                       // CORRECT_STREAMLINES\n  //return atan(V.x, V.y);\n}\n\n// --- [ what kind of derivative is this ? looks like an extension of ||complex derivative|| ]\n //    [ is Velocity not holomorphic ?  And why this stange FD pattern ? ]\n#define L(i,j)       length( SC(a) - SC( Velocity( p + vec2(i,j) *2./R.x ) ) )\n#define Derivative(a, p)   ( L(0,1) + L(1,0) + L(1,1) + L(1,-1) ) / 4.\n\nvoid mainImage( out vec4 O, vec2 U )      // --------------------------\n{\n    vec2  p = 3.* (2.*U - R) / R.x;\n    float s = 1./30.,                                   // 1./ number or radial iso lines\n          a = Velocity(p),\n          d = Derivative(a, p); // very close to below without wrap glitch :\n       // d = fwidth(a/6.28);  if (d>.5) d--; d*=1.2;   // trying to kill the glitch\n   // vec2 D = abs(vec2(dFdx(a/6.28),dFdy(a/6.28)));    // done !\n   // d = 1.6*length(D-step(.5,D));\n    \n    a = abs( mod( a/6.28, s ) *2. -s );                 // isolines\n    a = clamp( a/d - R.x/2e3 ,0.,1.);\n  //a = mod( a/6.28 , s ) ;                             // isolines\n  //a = clamp( 2.*min(a,s-a)/d - R.x/2e3 ,0.,1.);\n    d = length(p) - 1.;                                 // central disk\n    a = mix( 1.-a, a, clamp(d/fwidth(d),0.,1.)) ;\n    O = vec4( pow( a , 1./2.2 ) );                      // to sRGB\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 305, 365, 754], [1077, 1077, 1150, 1150, 1987]], "test": "untested"}
{"id": "tldSz4", "name": "My First Worley Noise GLSL", "author": "DonKarlssonSan", "description": "Based on blue noise", "tags": ["noise", "worley"], "likes": 1, "viewed": 375, "published": 3, "date": "1580544474", "time_retrieved": "2024-07-30T21:26:42.712096", "image_code": "// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\n\nvec2 hash2(vec2 p)\n{\n    return textureLod(iChannel0, (p + 0.5) / 256.0, 0.0).xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y += iTime / 10.0;\n    vec2 hash = hash2(uv) * 10.0;\n    vec2 F = cellular(hash);\n    float facets = 0.1 + F.y - F.x;\n    fragColor = vec4(facets, facets, facets, 1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSz4.jpg", "access": "api", "license": "mit", "functions": [[217, 264, 286, 286, 331], [333, 439, 462, 462, 1993], [1996, 1996, 2016, 2016, 2079], [2081, 2081, 2136, 2136, 2354]], "test": "untested"}
{"id": "WstXDX", "name": "Jake's Global Illumination", "author": "JakeLockey", "description": "Diffuse illumination only for the moment", "tags": ["ray", "global", "illumination", "tracing"], "likes": 1, "viewed": 268, "published": 3, "date": "1580533754", "time_retrieved": "2024-07-30T21:26:43.786224", "image_code": "vec2 curCoord = vec2(0.0,0.0);\nbool eviLight = true;\nint bounceCount = 1;\nfloat AA = 4.0; //perfect squares only\n\nvec3 b2(vec3 P, vec3 refRay,vec3 N, vec3 col, float gTd, float sTr, float fres){\n    \n    vec3 diffCol = vec3(0.0,0.0,0.0);\n    \n    for(int i=0; i<int(RaySims); i++){\n        vec3 rayDir = genDiffRay(P,N,curCoord*iTime*(float(i)+1.0));\n        //vec3 rayDir = refRay;\n        vec3 Collision = checkCollide(P,rayDir);\n        if(Collision.x>0.0){\n            if(int(Collision.y)==0){ //Sphere\n                Sphere tempS = objects.spheres[int(Collision.z)];\n\n                if(bounceCount >= 3){\n                    vec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = (tempS.pos-newP)/length(tempS.pos-newP);\n                \tnewP = newP + newN*(0.0001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    //diffCol+=b3(newP,tempRef,newN,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);\n                }\n                else{\n                    //diffCol+=tempS.col;\n                }\n\n            }\n            if(int(Collision.y)==1){ //Triangle\n                Triangle tempT = objects.triangles[int(Collision.z)];\n\n                if(bounceCount >= 3){\n                \tvec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                \tnewN = newN/length(newN);\n                \tnewP = newP + newN*(0.00001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    //diffCol+=b3(newP,tempRef,newN,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);\n                }\n                else{\n                \t//diffCol+=tempT.col;\n                }\n            }\n\n            if(int(Collision.y)==2){ //Light\n                Light tempL = objects.lights[int(Collision.z)];\n                diffCol+=tempL.col;\n                //return tempL.col;\n\n            }\n\n        }\n        else{\n            if(eviLight){\n\t\t\t\tdiffCol+=texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n            }\n        }\n    }\n    \n    vec3 shadowCol = vec3(0.0,0.0,0.0);\n    if(!checkShadow(P)){\n        shadowCol = col;\n    }\n    \n    //diffCol/=RaySims;\n    col*=diffCol;\n    col/=RaySims;\n    col = (col+shadowCol)/2.0;\n    \n    return col;\n}\n\n\nvec3 b1(vec3 P, vec3 refRay,vec3 N, vec3 col, float gTd, float sTr, float fres){\n    \n    vec3 diffCol = vec3(0.0,0.0,0.0);\n    float tempCount = 0.0;\n    \n    for(int i=0; i<int(RaySims); i++){\n        vec3 rayDir = genDiffRay(P,N,curCoord*iTime*(float(i)+1.0));\n        //vec3 rayDir = refRay;\n        vec3 Collision = checkCollide(P,rayDir);\n        if(Collision.x>0.0){\n            if(int(Collision.y)==0){ //Sphere\n                Sphere tempS = objects.spheres[int(Collision.z)];\n\t\t\t\t\n                if(bounceCount >= 2){\n                    vec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = (tempS.pos-newP)/length(tempS.pos-newP);\n                \tnewP = newP + newN*(0.0001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    diffCol+=b2(newP,tempRef,newN,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);\n                }\n                else{\n\t\t\t\t\ttempCount+=1.0;\n                    //diffCol+=tempS.col;\n                }\n           \t\t\n\n            }\n            if(int(Collision.y)==1){ //Triangle\n                Triangle tempT = objects.triangles[int(Collision.z)];\n\t\t\t\t\n                if(bounceCount >= 2){\n                \tvec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                \tnewN = newN/length(newN);\n                \tnewP = newP + newN*(0.00001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    diffCol+=b2(newP,tempRef,newN,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);\n                }\n                else{\n                    tempCount+=1.0;\n                \t//diffCol+=tempT.col;\n                }\n            }\n\n            if(int(Collision.y)==2){ //Light\n                Light tempL = objects.lights[int(Collision.z)];\n                diffCol+=tempL.col;\n                //return tempL.col;\n\n            }\n\n        }\n        else{\n\t\t\tif(eviLight){\n\t\t\t\tdiffCol+=texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n            }\n            else{\n                tempCount+=1.0;\n            }\n        }\n    }\n    \n    vec3 shadowCol = vec3(0.0,0.0,0.0);\n    if(!checkShadow(P)){\n        shadowCol = col;\n    }\n    \n    //diffCol/=(RaySims-tempCount);\n    col*=diffCol;\n    col/=(RaySims);\n    //col = (col+shadowCol)/2.0;\n    \n    return col;\n}\n\n\n\n\nvec3 castCamRay(vec2 xy){\n    float ratio = Cam.dir.z/length(Cam.dir.xy);\n    vec3 VertPerp = vec3(-Cam.dir.x*ratio, -Cam.dir.y*ratio, length(Cam.dir.xy));\n    vec3 yComp = VertPerp * xy.y;\n    \n    vec3 HoriPerp = vec3(Cam.dir.y,-Cam.dir.x,0.0)/length(vec3(Cam.dir.y,-Cam.dir.x,0.0));\n    vec3 xComp = HoriPerp * xy.x;\n    \n    vec3 ray = (Cam.dir*3.0)+xComp+yComp;\n    vec3 rayDir = (ray/length(ray));\n\n    vec3 P = Cam.pos;\n    vec3 N = vec3(0.0,0.0,0.0);\n    vec3 Collision = checkCollide(P,rayDir);\n    if(Collision.x>0.0){\n        if(int(Collision.y)==0){ //Sphere\n            Sphere tempS = objects.spheres[int(Collision.z)];\n\t\t\t\n            if(bounceCount>=1){\n                P = P + (rayDir*Collision.x);\n                N = (tempS.pos-P)/length(tempS.pos-P);\n                P = P + N*(0.0001);\n                vec3 tempRef = reflect(rayDir,N)/length(reflect(rayDir,N));\n                return b1(P,tempRef,-N,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);\n            }\n            else{\n                return tempS.col;\n            }\n        }\n        if(int(Collision.y)==1){ //Triangle\n            Triangle tempT = objects.triangles[int(Collision.z)];\n\n            if(bounceCount>=1){\n                P = P + (rayDir*Collision.x);\n                N = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                N = -N/length(N);\n                P = P + N*(0.00001);\n                vec3 tempRef = reflect(rayDir,N)/length(reflect(rayDir,N));\n                return b1(P,tempRef,N,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);\n            }\n            else{\n                return tempT.col;\n            }\n        }\n\n        if(int(Collision.y)==2){ //Light\n            Light tempL = objects.lights[int(Collision.z)];\n            return tempL.col;\n\n        }\n\n    }\n    else{\n\t\tif(eviLight){\n\t\t\treturn texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n        }\n    }\n    \n    \n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 LookAt = vec3(0.0,0.0,1.0);\n    Cam.pos.x =\t12.0*cos(iTime/1.2);\n   \tCam.pos.y = 12.0*sin(iTime/1.2);\n    Cam.dir = (LookAt-Cam.pos)/length(LookAt-Cam.pos);\n    \n    \n    Sphere[3] spheres = Sphere[](S1,S2,S3);\n\tTriangle[2] triangles = Triangle[](T1,T2);\n    Light[1] lights = Light[](L1);\n    \n    \n    objects = SceneObjects(spheres,triangles,lights);\n    \n    \n    // Normalized pixel coordinates (from -1 to 1 on the y axis, and propotional to the res on the x)\n    vec2 xy = vec2((2.0*(iResolution.x/iResolution.y)) * fragCoord.x/iResolution.x - (iResolution.x/iResolution.y), 2.0 * fragCoord.y/iResolution.y - 1.0);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    \n    for(float i = -0.5+(0.5/(AA/sqrt(AA))); i<0.5; i+=1.0/(AA/sqrt(AA))){\n        for(float j = -0.5+(0.5/(AA/sqrt(AA))); j<0.5; j+=1.0/(AA/sqrt(AA))){\n    \t\tcurCoord = xy + vec2(i/iResolution.x,j/iResolution.y);\n    \t\tcol+=castCamRay(curCoord);\n        }\n    }\n\n  \t\n    col = col/AA;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float RaySims = 30.0;\nfloat PI = 3.14159265359;\n\nstruct Light{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\nLight L1 = Light(vec3(-5.0,0.0,5.0), 0.0, vec3(1.0,1.0,1.0)*1.0);\n    \nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n    float dist;\n};\nCamera Cam = Camera(vec3(-8.0,8.0,9.0),vec3(1.0,-1.0,-0.9),3.0);\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n    vec3 col;\n    float gTd; //Scale from pure gloss to pure diffuse (0.0 - 1.0)\n    float sTr; //Scale from perfectly smooth to perfectly rough (0.0 - 1.0)\n    float fres; //Steepness of the fresnel effect (Higher => more diffuse faster)\n        \n};\nSphere S1 = Sphere(vec3(0.0,0.0,1.0),2.0,vec3(1.0,0.0,0.0),1.0,1.0,100.0);\nSphere S2 = Sphere(vec3(2.1213,2.1213,1.0),1.0, vec3(0.0,1.0,0.0),1.0,1.0,100.0);\nSphere S3 = Sphere(vec3(-2.1213,-2.1213,1.0),1.0, vec3(0.0,0.0,1.0),1.0,1.0,100.0);\n\n\nstruct Triangle{\n    vec3 Vert1;\n    vec3 Vert2;\n    vec3 Vert3;\n    vec3 col;\n    float gTd; //Scale from pure gloss to pure diffuse (0.0 - 1.0)\n    float sTr; //Scale from perfectly smooth to perfectly rough (0.0 - 1.0)\n    float fres; //Steepness of the fresnel effect (Higher => more diffuse faster)\n};\nTriangle T1 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(-5.0,5.0,-1.0), vec3(0.7,0.7,0.7),1.0,1.0,100.0);\nTriangle T2 = Triangle(vec3(5.0,-5.0,-1.0), vec3(-5.0,-5.0,-1.0), vec3(-5.0,5.0,-1.0), vec3(0.8,0.8,0.8),1.0,1.0,100.0);\nTriangle T3 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,10.0), vec3(5.0,-5.0,-1.0), vec3(0.8,0.8,0.8),1.0,1.0,100.0);\nTriangle T4 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,5.0,10.0), vec3(5.0,-5.0,10.0), vec3(0.7,0.7,0.7),1.0,1.0,100.0);\n    \nstruct SceneObjects{\n    Sphere[3] spheres;\n    Triangle[2] triangles;\n    Light[1] lights;\n};\nSceneObjects objects;\n\n\n\n\nvec3 checkCollide(vec3 Origin, vec3 rayDir){\n    float closestP = -1.0;\n    int objectNum = -1;\n    int SphTriOrLight = -1;\n    \n    //Check Spheres\n    for(int i = 0; i<objects.spheres.length(); i++){\n        Sphere tempS = objects.spheres[i];\n        \n        vec3 L = (tempS.pos-Origin); //Ray from sphere center to origin\n    \tfloat tca = dot(L,rayDir); //Distance to the closest point rayDir gets to sphere center\n    \n    \n    \tif(tca<=0.0){ //If the sphere is behind the camera\n    \t   \tcontinue;\n    \t}\n    \n    \tfloat d = sqrt(abs(dot(L,L)-(tca*tca))); //Gets the distance from the closest point to the sphere center\n        \n        if(length(L)-tca<0.00000000001){\n            d=0.00000000001;\n        };\n    \n    \tif(d>=tempS.r){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempS.r*tempS.r)-(d*d)); //Gets the distance from the closest point to the first point of intersection\n    \tfloat distToPoint= tca-thc; //Gets the distance away from the origin to the first point of intersection along rayDir\n        \n        if(i==0||closestP==-1.0){\n            closestP = distToPoint;\n            SphTriOrLight = 0;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphTriOrLight = 0;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    //Check triangles\n    for(int i = 0; i<objects.triangles.length(); i++){\n        Triangle tempT = objects.triangles[i];\n        \n        vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n        \n        //Test if ray is parallel to plane \n        if(dot(rayDir,normal)<0.001){\n            continue;\n        }\n        \n        vec3 p0l0 = tempT.Vert1 - Origin;\n        \n        //Dist to Intersection Point on plane\n        float distToPoint = dot(p0l0,normal) / dot(rayDir,normal);\n        if(distToPoint<0.0){\n            continue;\n        }\n        \n        vec3 P = Origin + rayDir*distToPoint; //Point of intersection\n        \n        //Check to see if ray is within the triangle\n        vec3 C;\n        //edge 1\n        vec3 edge1 = tempT.Vert2 - tempT.Vert1;\n\t\tvec3 vp1 = P - tempT.Vert1;\n        C = cross(edge1,vp1);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 2\n        vec3 edge2 = tempT.Vert3 - tempT.Vert2;\n\t\tvec3 vp2 = P - tempT.Vert2;\n        C = cross(edge2,vp2);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 3\n        vec3 edge3 = tempT.Vert1 - tempT.Vert3;\n\t\tvec3 vp3 = P - tempT.Vert3;\n        C = cross(edge3,vp3);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        \n        \n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphTriOrLight = 1;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphTriOrLight = 1;\n        \tobjectNum = i;\n        }\n        \n    }\n    //Check Lights\n    for(int i = 0; i<objects.lights.length(); i++){\n        Light tempL = objects.lights[i];\n        \n        vec3 L = (tempL.pos-Origin);\n    \tfloat tca = dot(L,rayDir);\n    \n    \n    \tif(tca<=0.0){\n    \t   \tcontinue;\n    \t}\n    \n    \tfloat d = sqrt(abs(dot(L,L)-(tca*tca)));\n        \n        if(length(L)-tca<0.00000000001){\n            d=0.00000000001;\n        };\n    \n    \tif(d>=tempL.r){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempL.r*tempL.r)-(d*d));\n    \tfloat distToPoint= tca-thc;\n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphTriOrLight = 2;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphTriOrLight = 2;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    \n    return vec3(closestP,SphTriOrLight,objectNum);\n       \n}\n\nbool checkShadow(vec3 P){\n\tvec3 rayDir = (L1.pos - P)/length(L1.pos - P);\n    vec3 Collision = checkCollide(P,rayDir);\n    \n    if(Collision.y==2.0){\n        return false;\n    }\n    return true;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 genDiffRay(vec3 P, vec3 N, vec2 seed){\n    /*vec2 randAng = vec2(rand(seed)*PI,rand(seed*2.0)*PI);\n    \n    float ratio = N.z/length(N.xy);\n    \n    vec3 VertPerp = vec3(0.0,0.0,0.0);\n    vec3 HoriPerp = vec3(0.0,0.0,0.0);\n\tif(N==vec3(0.0,0.0,1.0)||N==vec3(0.0,0.0,-1.0)){\n        VertPerp = vec3(1.0,0.0,0.0);\n        HoriPerp = vec3(0.0,1.0,0.0);\n    }\n    else{\n        VertPerp = vec3(-N.x*ratio, -N.y*ratio, length(N.xy));\n        HoriPerp = vec3(N.y,-N.x,0.0)/length(vec3(N.y,-N.x,0.0));\n    }\n    \n    vec3 yComp = (VertPerp * cos(randAng.x))+(N*sin(randAng.x));\n    yComp/=length(yComp);\n    vec3 xComp = (HoriPerp * cos(randAng.y))+(N*sin(randAng.y));\n    xComp/=length(xComp);\n    vec3 diffRay = yComp+xComp-N;*/\n    \n    \n    vec3 randPoint = vec3((rand(seed)*2.0)-1.0,(rand(seed*4.0)*2.0)-1.0,(rand(seed*3.0)*2.0)-1.0)+P; //gen rand point around P\n    vec3 randRay = P-randPoint;\n    //randRay = randRay/length(randRay);\n    vec3 diffRay = N+randRay;\n    return (diffRay/length(diffRay));\n}\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4719, 4719, 4744, 4744, 6636]], "test": "untested"}
{"id": "3ldXzN", "name": "Voronoi with Adjustable Power", "author": "adasba", "description": "A simple voronoi shader with a parameter for adjusting how the \"closest\" point is calculated. Rather than using x^2+y^2 to calculate the distance between two points, this shader uses x^1.2+y^1.2 by default, which can be adjusted.", "tags": ["2d", "voronoi"], "likes": 6, "viewed": 373, "published": 3, "date": "1580533086", "time_retrieved": "2024-07-30T21:26:44.530235", "image_code": "#define POWER 1.2\n\nconst int pointCount = 32;\n\nvec2 points[pointCount];\n\nint taxicabVoronoi(vec2[pointCount] pts, vec2 position, inout float finalDist) {\n    float minDist = 999.9;\n    int minDistIndex = 0;\n    for (int i = 0; i < pointCount; i++) {\n        float dist = pow(abs(position.x - pts[i].x), POWER) + pow(abs(position.y - pts[i].y), POWER);\n        if (dist < minDist) {\n        \tminDist = dist;\n            minDistIndex = i;\n        }\n    }\n    finalDist = minDist;\n    return minDistIndex;\n}\n\nfloat n(inout float noiseSeed) {\n    noiseSeed = noiseSeed + 0.02342;\n    return (texture(iChannel0, vec2(noiseSeed))[0]);\n}\n\nvoid setPoints() {\n    float s = 0.0;\n\n    \n    int pc = pointCount;\n    for (int i = 0; i < pointCount; i++) {\n    \tpoints[i].x = (n(s) - 0.25) * 2.0 + cos(iTime * n(s) * 0.5) * 0.3;\n        points[i].y = (n(s) - 0.25) * 2.0 + cos(iTime * n(s) * 0.5) * 0.3;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tsetPoints();\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n    \n    //stuff for borders\n    float dist;\n    float idx = float(taxicabVoronoi(points, uv.xy, dist));\n    float idx2 = 0.0;\n    bool borderCondition = false;\n    for (float i = 0.0; i < 4.0; i++) {\n    \tfloat dist2;\n    \tidx2 = float(taxicabVoronoi(points, uv.xy - vec2(mod(i, 2.0) * 0.002 - 0.001, floor(i / 2.0) * 0.002 - 0.001), dist2));\n        borderCondition = borderCondition || (idx != idx2);\n    }\n   \n    float border = 0.0;\n    border += (borderCondition) ? 1.0 : 0.0;\n    // Output to screen\n    fragColor = vec4(vec3(idx / float(pointCount * 2) + border), 1.0);\n}\n\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 538, 538, 630], [632, 632, 650, 650, 898], [900, 900, 957, 957, 1670]], "test": "untested"}
{"id": "3ldSRN", "name": "Multi-Scale Actors", "author": "wyatt", "description": "Complicated particle tracking. Absolutely insane way of going about things. A direction I've wanted to go for a long while! More to come hopefully.", "tags": ["triangulation"], "likes": 16, "viewed": 552, "published": 3, "date": "1580517190", "time_retrieved": "2024-07-30T21:26:45.334086", "image_code": "Main {\n    vec4 bb = B(U), cc = C(U), dd = D(U),\n         a = A(bb.xy), b = A(cc.xy);\n    a.zw = A(bb.zw).xy;\n    b.zw = A(cc.zw).xy;\n    float la = length(U-a.xy)-rad(bb.xy),\n          lc = length(U-a.zw)-rad(bb.zw),\n          lb = length(U-b.xy)-rad(cc.xy);\n    lc = min(lc,min(la,lb));\n\tQ = vec4(1);\n    Q *= smoothstep(0.,2.,abs(lc));\n    Q *= 0.5+0.5*sin(2.*(cc.x/R.x+cc.y/R.y*vec4(1,2,3,4)));\n    Q = mix(Q,\n        mix(1.-Q,vec4(0),dd.z*smoothstep(1.,.0,sg(U,a.xy,b.xy))),\n        smoothstep(1.,-1.,lc));\n\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,floor(U)/R)\n#define B(U) texture(iChannel1,floor(U)/R)\n#define C(U) texture(iChannel2,floor(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat rad (vec2 u) {\n    float r = hash12(u);\n\treturn -20.*log(1.-.5*r);\n}", "buffer_a_code": "// Information Storage\nvec2 grad (vec2 u) {\n\tvec4\n        n = D(u+vec2(0,2)),\n        e = D(u+vec2(2,0)),\n        s = D(u-vec2(0,2)),\n        w = D(u-vec2(2,0));\n    return vec2(e.z-w.z,n.z-s.z);\n}\nMain {\n\tQ = A(U);\n    if (iMouse.z>0.&&length(iMouse.xy-Q.xy)>0.) {\n    \tQ.zw += .05*normalize(iMouse.xy-Q.xy);\n    }\n    float r = rad(U);\n    Q.zw -= grad(Q.xy)-1e-3;\n    if (length(Q.zw)>.5)\n        Q.zw = mix(Q.zw,0.5*normalize(Q.zw),.5);\n    Q.xy += Q.zw;\n    \n    \n    if (Q.x<2.) {Q.x = 2.; Q.z *= -1.;}\n    if (R.x-Q.x<2.) {Q.x = R.x-2.; Q.z *= -1.;}\n    if (Q.y<2.) {Q.y = 2.; Q.w *= -1.;}\n    if (R.y-Q.y<2.) {Q.y = R.y-2.; Q.w *= -1.;}\n    \n    \n    Init {\n    \tU = floor(U/20.+0.5)*20.;\n        Q = vec4(U,.3,.4);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, inout vec4 a, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    n.zw = A(b.zw).xy;\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n    ln = length(n.zw-U), la = length(a.zw-U);\n    if (min(abs(ln-rad(b.zw)),ln)<min(abs(la-rad(Q.zw)),la)) {\n    \tQ.zw = b.zw;\n        a.zw = n.zw;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, vec2 U, float r) {\n\t X(Q,a,U,vec2(r,0));\n     X(Q,a,U,vec2(0,r));\n     X(Q,a,U,vec2(0,-r));\n     X(Q,a,U,vec2(-r,0));\n}\nMain {\n\tQ = B(U);\n    vec4 a = A(Q.xy);\n    a.zw = A(Q.zw).xy;\n    Xr(Q,a,U,1.);\n    Xr(Q,a,U,2.);\n    Xr(Q,a,U,3.);\n    Xr(Q,a,U,4.);\n   \t\n    if (length(U-a.zw)<length(U-a.xy))\n        Q.xy = Q.zw;\n    \n    Init {\n    \tQ = A(U).xyxy;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Nearest Normalized Bisector\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, vec2 r) {\n    vec4 Qn = C(U+r), qn = B(U+r), na = A(qn.xy), nb = A(Qn.xy);\n   \tfloat l = mp(U,a.xy,b.xy);\n    \n    if (mp(U,a.xy,na.xy)<l) {\n    \tQ = qn;\n        b = na;\n    }\n    if (mp(U,a.xy,nb.xy)<l) {\n        Q = Qn;\n        b = nb;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, float r) {\n\t X(Q,a,b,U,vec2(r,0));\n     X(Q,a,b,U,vec2(0,r));\n     X(Q,a,b,U,vec2(0,-r));\n     X(Q,a,b,U,vec2(-r,0));\n}\nMain {\n\tQ = C(U);\n    vec4 q = B(U),\n         a = A(q.xy),\n         b = A(Q.xy);\n    Xr (Q,a,b,U,1.);\n    Xr (Q,a,b,U,2.);\n    Xr (Q,a,b,U,3.);\n    \n    float r = length(a.xy-b.xy)-rad(Q.xy)-rad(q.xy);\n    Q.z = 3.*(1.+abs(r))*step(r,0.);\n    Init Q = A(U);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = vec4(0);\n    for (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++) {\n    \tvec2 r = vec2(x,y);\n        Q += C(U+r).z*exp(-.5*dot(r,r));\n    }\n    Q /= 25.;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ltSRN", "name": "CarlVitasaTest", "author": "bchap728", "description": "test2", "tags": ["test"], "likes": 0, "viewed": 223, "published": 3, "date": "1580511782", "time_retrieved": "2024-07-30T21:26:46.176833", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,8.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
